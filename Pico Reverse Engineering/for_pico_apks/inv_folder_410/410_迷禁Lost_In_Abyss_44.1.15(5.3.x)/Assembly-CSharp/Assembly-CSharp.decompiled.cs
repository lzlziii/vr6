using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Mail;
using System.Net.Security;
using System.Net.Sockets;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.Serialization;
using System.Security.Cryptography.X509Certificates;
using System.Text;
using System.Threading;
using System.Timers;
using CommandTerminal;
using DG.Tweening;
using EFramework.Core;
using EFramework.Tweens;
using EFramework.Tweens.Core;
using EFramework.Unity.Tools;
using EFramework.Utility;
using JetBrains.Annotations;
using Microsoft.CodeAnalysis;
using MiniEXR;
using NaughtyAttributes;
using TMPro;
using Unity.XR.PXR;
using UnityEngine;
using UnityEngine.AI;
using UnityEngine.EventSystems;
using UnityEngine.Events;
using UnityEngine.Playables;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;
using UnityEngine.SceneManagement;
using UnityEngine.TextCore.LowLevel;
using UnityEngine.UI;
using UnityEngine.Video;
using UnityEngine.XR;
using UnityEngine.XR.Interaction.Toolkit;
using VRPanorama;

[assembly: CompilationRelaxations(8)]
[assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)]
[assembly: Debuggable(DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)]
[assembly: AssemblyVersion("0.0.0.0")]
namespace Microsoft.CodeAnalysis
{
	[CompilerGenerated]
	[Microsoft.CodeAnalysis.Embedded]
	internal sealed class EmbeddedAttribute : Attribute
	{
	}
}
namespace System.Runtime.CompilerServices
{
	[CompilerGenerated]
	[Microsoft.CodeAnalysis.Embedded]
	internal sealed class IsReadOnlyAttribute : Attribute
	{
	}
}
public class OverallViewManager : MonoSingleton<OverallViewManager>
{
	public List<VideoClip> videoClips;

	private VideoPlayer videoPlayer;

	private MeshRenderer meshRenderer;

	public RenderTexture renderTexture;

	public Vector3 originPos;

	private bool isPause;

	public bool isPlaying;

	public OverallViewType overallViewType;

	private void Start()
	{
		videoPlayer = GetComponent<VideoPlayer>();
		meshRenderer = GetComponent<MeshRenderer>();
	}

	private void Update()
	{
		if (isPlaying)
		{
			switch (overallViewType)
			{
			case OverallViewType.初始化位置_初始化旋转_跟随位置:
				SetPos();
				break;
			case OverallViewType.初始化位置_初始化旋转_跟随位置_跟随Y旋转:
				SetPos();
				SetRotByHead();
				break;
			case OverallViewType.None:
				break;
			}
		}
	}

	public void Play(int id, Transform startPos, Transform endPos, bool autoClose = true, bool loop = true)
	{
		Play(id, autoClose, loop);
	}

	public void Play(int id, bool autoClose = true, bool loop = true)
	{
		Play(videoClips[id], autoClose, loop);
	}

	public void Play(VideoClip clip, bool autoClose = true, bool loop = true)
	{
		GC.Collect();
		MonoSingleton<PlayerInfo>.Instance.SetPos(new Vector3(1000f, 0f, 1000f));
		MonoSingleton<PlayerInfo>.Instance.SetEasyVRController(move: false, left: false, right: false);
		originPos = MonoSingleton<PlayerInfo>.Instance.transform.position;
		renderTexture.Release();
		videoPlayer.clip = clip;
		videoPlayer.Play();
		meshRenderer.enabled = true;
		MonoSingleton<PlayerInfo>.Instance.CanMove = false;
		videoPlayer.isLooping = loop;
		isPlaying = true;
		if (autoClose)
		{
			Invoke("NewStop", (float)clip.length);
		}
		SetPos();
		SetRotByHead();
	}

	public void NewStop()
	{
		videoPlayer.Stop();
		MonoSingleton<PlayerInfo>.Instance.SetEasyVRController(move: true, left: true, right: true);
		meshRenderer.enabled = false;
		isPlaying = false;
	}

	public void Pause()
	{
		isPause = true;
		videoPlayer.Pause();
		base.transform.GetChild(0).gameObject.SetActive(value: true);
		isPlaying = false;
	}

	public void Stop()
	{
		UnityEngine.Debug.Log("显示手了StopPlay");
		MonoSingleton<PlayerInfo>.Instance.SetEasyVRController(move: true, left: true, right: true);
		if (!isPause)
		{
			this.AttachTimer(0f, delegate
			{
				GetComponent<MeshRenderer>().enabled = false;
			});
		}
	}

	public void SetPos()
	{
		base.transform.parent.position = MonoSingleton<PlayerInfo>.Instance.EasyVRHead.transform.position;
	}

	public void SetRotByHead(bool isY = true)
	{
		SetRot(MonoSingleton<PlayerInfo>.Instance.EasyVRHead.transform, isY);
	}

	public void SetRot(Transform head, bool isY = true)
	{
		base.transform.parent.rotation = head.rotation;
		if (isY)
		{
			base.transform.parent.rotation = Quaternion.Euler(0f, base.transform.parent.rotation.eulerAngles.y, 0f);
		}
	}
}
public class VideoInfo
{
	public Vector3 angle;

	public VideoClip clip;

	public VideoInfo(VideoClip clip, float x, float y, float z)
	{
		this.clip = clip;
		angle = new Vector3(x, y, z);
	}
}
public enum OverallViewType
{
	None,
	初始化位置_初始化旋转_跟随位置,
	初始化位置_初始化旋转_跟随位置_跟随Y旋转
}
public class Test360 : MonoBehaviour
{
	private int id;

	public GameObject ui;

	private void Start()
	{
		UnityEngine.Debug.Log(">>>>>>>>>>" + base.name);
		MonoSingleton<PlayerInfo>.Instance.canOpenUI = false;
		this.AttachTimer(1f, delegate
		{
			UnityEngine.Debug.Log(">>>>>>>>>>" + base.name);
			MonoSingleton<OverallViewManager>.Instance.Play(0, autoClose: false);
			this.AttachTimer((float)MonoSingleton<OverallViewManager>.Instance.videoClips[0].length - 0.1f, delegate
			{
				MonoSingleton<GlobalManager>.Instance.CurrentUI = MJFSM.UIPanelType.协议;
				base.transform.GetChild(1).localPosition = Vector3.zero;
				MonoSingleton<PlayerInfo>.Instance.canOpenUI = false;
				MonoSingleton<PlayerInfo>.Instance.showRay = true;
				MonoSingleton<OverallViewManager>.Instance.Play(1, autoClose: false);
				ui.SetActive(value: true);
				MonoSingleton<PlayerInfo>.Instance.SetEasyVRController(move: false, left: false, right: true);
			});
		});
	}
}
public class Car : MonoBehaviour
{
	private void Start()
	{
		Terminal.Shell.AddCommand("set.car", Test, 0, 1, "测试非静态", "提示");
		Terminal.Shell.AddCommand("set.car", Test1, 0, 1, "测试非静态", "提示");
		Terminal.Autocomplete.Register("test");
	}

	[CommandTerminal.RegisterCommand(null, Help = "开车", Hint = "car 0/1/2/3", MaxArgCount = 1, MinArgCount = 1, Name = "set.car")]
	public static void Run(CommandArg[] args)
	{
		switch (args[0].Int)
		{
		case 0:
			UnityEngine.Debug.Log("前");
			break;
		case 1:
			UnityEngine.Debug.Log("后");
			break;
		case 2:
			UnityEngine.Debug.Log("左");
			break;
		case 3:
			UnityEngine.Debug.Log("右");
			break;
		}
	}

	public void Test1(CommandArg[] args)
	{
		UnityEngine.Debug.Log(base.name + "1");
	}

	public void Test(CommandArg[] args)
	{
		UnityEngine.Debug.Log(base.name);
	}
}
public class Pad : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
		if (Input.GetKey(KeyCode.Space))
		{
			Terminal.Shell.RunCommand("car 1");
		}
		if (!Input.GetKeyUp(KeyCode.A))
		{
			return;
		}
		foreach (KeyValuePair<string, CommandInfo> command in Terminal.Shell.Commands)
		{
			Terminal.Log(command.Key);
		}
	}
}
public class MonoSingleton<T> : MonoBehaviour where T : MonoBehaviour
{
	private static T _instance;

	private static object _lock = new object();

	private static bool applicationIsQuitting = false;

	public static T Instance
	{
		get
		{
			if (applicationIsQuitting)
			{
				UnityEngine.Debug.LogWarning("[Singleton] Instance '" + typeof(T)?.ToString() + "' already destroyed on application quit. Won't create again - returning null.");
				return null;
			}
			lock (_lock)
			{
				if (_instance == null)
				{
					_instance = (T)UnityEngine.Object.FindObjectOfType(typeof(T));
					if (UnityEngine.Object.FindObjectsOfType(typeof(T)).Length > 1)
					{
						UnityEngine.Debug.LogError("[Singleton] Something went really wrong  - there should never be more than 1 singleton! Reopening the scene might fix it.");
						return _instance;
					}
					if (_instance == null)
					{
						GameObject gameObject = new GameObject();
						_instance = gameObject.AddComponent<T>();
						gameObject.name = "(singleton) " + typeof(T).ToString();
						UnityEngine.Object.DontDestroyOnLoad(gameObject);
						UnityEngine.Debug.Log("[Singleton] An instance of " + typeof(T)?.ToString() + " is needed in the scene, so '" + gameObject?.ToString() + "' was created with DontDestroyOnLoad.");
					}
					else
					{
						UnityEngine.Debug.Log("[Singleton] Using instance already created: " + _instance.gameObject.name);
					}
				}
				return _instance;
			}
		}
	}

	public void OnDestroy()
	{
		applicationIsQuitting = true;
	}
}
public abstract class Singleton<T> where T : Singleton<T>, new()
{
	private static T ms_instance;

	public static T Instance
	{
		get
		{
			if (ms_instance == null)
			{
				ms_instance = new T();
				ms_instance.InitSingleton();
			}
			return ms_instance;
		}
	}

	protected virtual void InitSingleton()
	{
	}
}
public class TestCommand : MonoBehaviour
{
	public static Signal<int> signal = new Signal<int>();

	private void Start()
	{
		signal.AddListener(Test0);
		signal += new Action<int>(Test1);
		EventManager.AddListener<int>("Test2", Test2);
		signal.Invoke(1);
		EventManager.SendEvent("Test2", 2);
		EventManager.SendEvent("TestCommand.Test3", 3);
		EventManager.SendEvent("Test4", 4);
	}

	public void Test0(int a)
	{
		UnityEngine.Debug.Log("Test0" + a);
	}

	public void Test1(int a)
	{
		UnityEngine.Debug.Log("Test1" + a);
	}

	public void Test2(int a)
	{
		UnityEngine.Debug.Log("Test2" + a);
	}

	public void Test3(int a)
	{
		UnityEngine.Debug.Log("Test3" + a);
	}

	public void Test4(int a)
	{
		UnityEngine.Debug.Log("Test4" + a);
	}
}
public class TimerTest : MonoBehaviour
{
	private void Start()
	{
		Color color = Color.white;
		float transitionDuration = 5f;
		EFramework.Unity.Tools.Timer.Register(transitionDuration, delegate
		{
			UnityEngine.Debug.Log("Color is now red");
		}, delegate(float secondsElapsed)
		{
			color.r = 255f * (secondsElapsed / transitionDuration);
		});
		this.AttachTimer(5f, delegate
		{
			base.gameObject.transform.position = Vector3.zero;
		});
	}

	private void Update()
	{
	}
}
public class UnityDictionaryTest : MonoBehaviour
{
	public UnityDictionary<string, string[]> dict = new UnityDictionary<string, string[]>();

	private void Start()
	{
		dict.Add("a", new string[2] { "aa", "bbbb" });
		dict.Add("b", new string[2] { "aa", "bbbb" });
		dict.Remove("a");
		dict["b"][1] = "cccc";
	}
}
public class CommandManager : MonoBehaviour
{
	public bool enabledLog;

	private void Start()
	{
		RegisterCommands();
	}

	public void RegisterCommands()
	{
		BindingFlags bindingAttr = BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic;
		Type[] types = Assembly.Load("Assembly-CSharp").GetTypes();
		foreach (Type type in types)
		{
			MethodInfo[] methods = type.GetMethods(bindingAttr);
			foreach (MethodInfo methodInfo in methods)
			{
				if (Attribute.GetCustomAttribute(methodInfo, typeof(EFramework.Core.RegisterCommandAttribute), inherit: false) is EFramework.Core.RegisterCommandAttribute registerCommandAttribute)
				{
					if (string.IsNullOrEmpty(registerCommandAttribute.Command))
					{
						registerCommandAttribute.Command = type.Name + "." + methodInfo.Name;
					}
					UnityEngine.Object[] array = UnityEngine.Object.FindObjectsOfType(type);
					foreach (UnityEngine.Object @object in array)
					{
						UnityEngine.Debug.Log((">>> 添加订阅: " + registerCommandAttribute.Command).ToColor(Color.red) + "  From: " + @object.name);
						AddCommand(registerCommandAttribute.Command, registerCommandAttribute.Description, @object, methodInfo, registerCommandAttribute.ParameterNames);
					}
				}
			}
		}
	}

	private static void AddCommand(string command, string description, UnityEngine.Object targetComponent, MethodInfo method, string[] parameterNames)
	{
		if (string.IsNullOrEmpty(command))
		{
			UnityEngine.Debug.LogError("Command name can't be empty!");
			return;
		}
		command = command.Trim();
		if (command.IndexOf(' ') >= 0)
		{
			UnityEngine.Debug.LogError("Command name can't contain whitespace: " + command);
			return;
		}
		ParameterInfo[] array = method.GetParameters();
		if (array == null)
		{
			array = new ParameterInfo[0];
		}
		Type[] array2 = new Type[array.Length];
		for (int i = 0; i < array.Length; i++)
		{
			if (array[i].ParameterType.IsByRef)
			{
				UnityEngine.Debug.LogError("Command can't have 'out' or 'ref' parameters");
				return;
			}
			array2[i] = array[i].ParameterType;
		}
		EventAgentDelegate<string>.Instance.AddListener(command, GetActionDelegate(method, targetComponent, array2));
	}

	private static Delegate GetActionDelegate(MethodInfo methodInfo, object targetComponent, Type[] parameterTypes)
	{
		Type typeFromHandle;
		switch (parameterTypes.Length)
		{
		case 0:
			return (Action)delegate
			{
				methodInfo.Invoke(targetComponent, null);
			};
		case 1:
			typeFromHandle = typeof(Action<>);
			break;
		case 2:
			typeFromHandle = typeof(Action<, >);
			break;
		case 3:
			typeFromHandle = typeof(Action<, , >);
			break;
		case 4:
			typeFromHandle = typeof(Action<, , , >);
			break;
		case 5:
			typeFromHandle = typeof(Action<, , , , >);
			break;
		default:
			return null;
		}
		return Delegate.CreateDelegate(typeFromHandle.MakeGenericType(parameterTypes), targetComponent, methodInfo);
	}
}
public static class TimerExtensions
{
	public static EFramework.Unity.Tools.Timer AttachTimer(this MonoBehaviour behaviour, float duration, Action onComplete, Action<float> onUpdate = null, bool isLooped = false, bool useRealTime = false)
	{
		return EFramework.Unity.Tools.Timer.Register(duration, onComplete, onUpdate, isLooped, useRealTime, behaviour);
	}
}
public class TimerManger : MonoSingleton<TimerManger>
{
	[Serializable]
	public class Timer
	{
		private float startTime;

		private float triggerTime;

		private UnityAction action;

		public Timer(float currentTime, float second, UnityAction action)
		{
			startTime = currentTime;
			triggerTime = currentTime + second;
			this.action = action;
		}

		public void Check(float currentTime)
		{
			if (currentTime > triggerTime)
			{
				action();
				MonoSingleton<TimerManger>.Instance.timerLst.Remove(this);
			}
		}
	}

	public List<Timer> timerLst = new List<Timer>();

	public float mainTime;

	public void Delay(float time, UnityAction action)
	{
		timerLst.Add(new Timer(mainTime, time, action));
	}

	private void Update()
	{
		mainTime += Time.deltaTime;
		if (timerLst.Count > 0)
		{
			for (int i = 0; i < timerLst.Count; i++)
			{
				timerLst[i].Check(mainTime);
			}
		}
	}
}
[Serializable]
public class UnityDictionary<K, V>
{
	[Serializable]
	public class Dict
	{
		public K key;

		public V value;
	}

	private Dictionary<K, V> cache = new Dictionary<K, V>();

	public List<Dict> dict = new List<Dict>();

	public V this[K key] => cache[key];

	public void Add(K k, V v)
	{
		cache.Add(k, v);
		dict.Add(new Dict
		{
			key = k,
			value = v
		});
	}

	public bool ContainsKey(K k)
	{
		return cache.ContainsKey(k);
	}

	public void Remove(K k)
	{
		cache.Remove(k);
		for (int i = 0; i < dict.Count; i++)
		{
			if (dict[i].key.Equals(k))
			{
				dict.Remove(dict[i]);
			}
		}
	}
}
public class GetDepthTexFromCam : MonoBehaviour
{
	private Camera myCamera;

	public Camera cam
	{
		get
		{
			if (myCamera == null)
			{
				myCamera = GetComponent<Camera>();
			}
			return myCamera;
		}
	}

	private void OnEnable()
	{
		cam.depthTextureMode |= DepthTextureMode.Depth;
	}
}
public class EasyFollow : MonoBehaviour
{
	public Transform followTarget;

	private Vector3 offset;

	private void Start()
	{
		offset = base.transform.position - followTarget.position;
	}

	private void Update()
	{
		base.transform.position = followTarget.position + offset;
	}
}
public class EasyTest : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
	}
}
public class EasyVRInteractionBase : MonoBehaviour
{
	public EasyVRHandInfo handInfo;

	private Rigidbody rigibody;

	public List<Collider> colliders = new List<Collider>();

	public bool showEvents;

	[ShowIf("showEvents")]
	public UnityEvent<EasyVRHandInfo> onGrabEvent;

	[ShowIf("showEvents")]
	public UnityEvent onReleaseEvent;

	[ShowIf("showEvents")]
	public UnityEvent<EasyVRHandInfo> onHandTouchTriggerEnterEvent;

	[ShowIf("showEvents")]
	public UnityEvent<EasyVRHandInfo> onHandTouchTriggerExitEvent;

	public Rigidbody Rigibody
	{
		get
		{
			if (rigibody == null)
			{
				if (GetComponent<Rigidbody>() != null)
				{
					rigibody = GetComponent<Rigidbody>();
				}
				else
				{
					rigibody = base.gameObject.AddComponent<Rigidbody>();
				}
			}
			return rigibody;
		}
		set
		{
			if (rigibody == null)
			{
				if (GetComponent<Rigidbody>() != null)
				{
					rigibody = GetComponent<Rigidbody>();
				}
				else
				{
					rigibody = base.gameObject.AddComponent<Rigidbody>();
				}
			}
			rigibody = value;
		}
	}

	private void Start()
	{
		Init();
		colliders.AddRange(GetComponentsInChildren<Collider>());
	}

	private void OnMouseDown()
	{
		PressDown();
	}

	private void OnMouseUp()
	{
		PressUp();
	}

	public virtual void Init()
	{
	}

	public virtual void RayEnter()
	{
	}

	public virtual void RayStay()
	{
	}

	public virtual void RayExit()
	{
	}

	[Obsolete("OnGrabbing")]
	public virtual void PressDown()
	{
		Rigibody.useGravity = false;
		Rigibody.isKinematic = true;
		foreach (Collider collider in colliders)
		{
			collider.isTrigger = true;
		}
	}

	public virtual void Pressed()
	{
	}

	[Obsolete("OnRelease")]
	public virtual void PressUp()
	{
		foreach (Collider collider in colliders)
		{
			collider.isTrigger = false;
		}
		handInfo.RemoveSelectedInHand();
		base.transform.SetParent(null);
		ThrowObject();
		Rigibody.useGravity = true;
		Rigibody.isKinematic = false;
	}

	public virtual void OnGrabbing(EasyVRHandInfo handInfo)
	{
	}

	public virtual void OnRelease()
	{
	}

	[Obsolete]
	public virtual void OldTriggerEnter(EasyVRHandInfo obj)
	{
	}

	[Obsolete]
	public virtual void OldTriggerStay(EasyVRHandInfo obj)
	{
	}

	[Obsolete]
	public virtual void OldTriggerExit(EasyVRHandInfo obj)
	{
	}

	public virtual void OnBodyTriggerEnter(object obj)
	{
	}

	public virtual void OnBodyTriggerStay(object obj)
	{
	}

	public virtual void OnBodyTriggerExit(object obj)
	{
	}

	public virtual void OnBodyTriggerEnterVoid()
	{
	}

	public virtual void OnBodyTriggerStayVoid()
	{
	}

	public virtual void OnBodyTriggerExitVoid()
	{
	}

	public virtual void OnHandTouchEnter(EasyVRHandInfo handInfo)
	{
		onHandTouchTriggerEnterEvent?.Invoke(handInfo);
	}

	public virtual void OnHandTouchStay(EasyVRHandInfo handInfo)
	{
	}

	public virtual void OnHandTouchExit(EasyVRHandInfo handInfo)
	{
		onHandTouchTriggerExitEvent?.Invoke(handInfo);
	}

	public virtual void Show()
	{
		base.gameObject.SetActive(value: true);
	}

	public virtual void Hide()
	{
		base.gameObject.SetActive(value: false);
	}

	public void SetHandInfo(EasyVRHandInfo hand)
	{
		handInfo = hand;
	}

	public void ThrowObject()
	{
		try
		{
			handInfo.handController.velocityEstimator.BeginEstimatingVelocity();
			Rigibody.velocity = handInfo.handController.velocity;
			Rigibody.angularVelocity = -handInfo.handController.angularVelocity;
			Rigibody.maxAngularVelocity = Rigibody.angularVelocity.magnitude;
		}
		catch (Exception ex)
		{
			UnityEngine.Debug.LogWarning(base.name + "    " + ex.Message);
		}
	}

	public void MJDestroy()
	{
		MonoSingleton<PoolManager>.Instance.RecycleObj(base.gameObject);
	}
}
public class MoveBase : EasyVRInteractionBase
{
	public float max = 1f;

	public float min;

	public MoveDirectionType moveDirection = MoveDirectionType.z;

	private Vector3 offset;

	public override void PressDown()
	{
		offset = handInfo.transform.position - base.transform.position;
		UnityEngine.Debug.Log("controller:" + handInfo.transform.position.ToString());
		Vector3 vector = offset;
		UnityEngine.Debug.Log("offset:" + vector.ToString());
	}

	public override void Pressed()
	{
		Vector3 vector = handInfo.transform.position - offset;
		base.transform.position = new Vector3((moveDirection == MoveDirectionType.x) ? vector.x : base.transform.position.x, (moveDirection == MoveDirectionType.y) ? vector.y : base.transform.position.y, (moveDirection == MoveDirectionType.z) ? vector.z : base.transform.position.z);
	}

	public override void PressUp()
	{
	}
}
public enum MoveDirectionType
{
	x,
	y,
	z
}
public class RotationBase : EasyVRInteractionBase
{
	[Serializable]
	public class AngleFloatEvent : UnityEvent<float>
	{
	}

	[Serializable]
	public class AngleIntEvent : UnityEvent<int>
	{
	}

	public float min = -45f;

	public float max = 45f;

	public float angle;

	public int angleInt;

	public float angleFloat;

	public float step = 0.1f;

	public Vector3 lockWorldAxis = Vector3.up;

	private Transform origin;

	public AngleIntEvent angle2IntEvent;

	public AngleFloatEvent angle2FloatEvent;

	public UnityEvent maxAngleEvent;

	public UnityEvent minAngleEvent;

	public bool inHand;

	private int angleIntTmp = -1;

	private float angleFloatTmp = -1f;

	public override void Init()
	{
		base.Init();
		origin = new GameObject("origin").transform;
		origin.SetPositionAndRotation(base.transform.position, base.transform.rotation);
		origin.SetParent(base.transform.parent);
	}

	public override void PressDown()
	{
		foreach (Collider collider in colliders)
		{
			collider.isTrigger = true;
		}
		inHand = true;
	}

	public override void PressUp()
	{
		foreach (Collider collider in colliders)
		{
			collider.isTrigger = false;
		}
		inHand = false;
		handInfo.RemoveSelectedInHand();
	}

	private void Update()
	{
		if (inHand && handInfo != null)
		{
			FllowHand(handInfo.transform.position);
		}
	}

	public void FllowHand(Vector3 handPos)
	{
		angle = Mathf.Clamp(AngleSigned(origin.transform.forward, Vector3.ProjectOnPlane(handPos - origin.position, lockWorldAxis), lockWorldAxis), min, max);
		SetAngle();
		angleInt = Mathf.FloorToInt(angle);
		angleFloat = angle - angle % step;
		if (angleInt != angleIntTmp)
		{
			angle2IntEvent?.Invoke(angleInt);
			if ((float)angleInt == min)
			{
				minAngleEvent?.Invoke();
				UnityEngine.Debug.Log("min");
			}
			if ((float)angleInt == max)
			{
				maxAngleEvent?.Invoke();
			}
			angleIntTmp = angleInt;
		}
		if (angleFloat != angleFloatTmp)
		{
			angle2FloatEvent?.Invoke(angleFloat);
			angleFloatTmp = angleFloat;
		}
	}

	public static float AngleSigned(Vector3 v1, Vector3 v2, Vector3 n)
	{
		return Mathf.Atan2(Vector3.Dot(n, Vector3.Cross(v1, v2)), Vector3.Dot(v1, v2)) * 57.29578f;
	}

	public void SetAngle(float angle, float time)
	{
		UnityEngine.Debug.Log(angle);
		DOTween.To(() => this.angle, delegate(float x)
		{
			this.angle = x;
		}, angle, time).OnUpdate(SetAngle);
	}

	public void SetAngle(float angle)
	{
		this.angle = angle;
	}

	public void SetAngle()
	{
		base.transform.rotation = Quaternion.AngleAxis(angle, lockWorldAxis) * origin.rotation;
	}
}
public class EasyVRTouchBase : EasyVRInteractionBase
{
}
public class EasyVRJointHelper : MonoBehaviour
{
	public bool LockXPosition;

	public bool LockYPosition;

	public bool LockZPosition;

	public bool LockXScale = true;

	public bool LockYScale = true;

	public bool LockZScale = true;

	public bool LockXRotation;

	public bool LockYRotation;

	public bool LockZRotation;

	private Vector3 initialPosition;

	private Vector3 initialRotation;

	private Vector3 initialScale;

	private Vector3 currentPosition;

	private Vector3 currentScale;

	private Vector3 currentRotation;

	private void Start()
	{
		initialPosition = base.transform.localPosition;
		initialRotation = base.transform.localEulerAngles;
		initialScale = base.transform.localScale;
	}

	private void lockPosition()
	{
		if (LockXPosition || LockYPosition || LockZPosition)
		{
			currentPosition = base.transform.localPosition;
			base.transform.localPosition = new Vector3(LockXPosition ? initialPosition.x : currentPosition.x, LockYPosition ? initialPosition.y : currentPosition.y, LockZPosition ? initialPosition.z : currentPosition.z);
		}
		if (LockXScale || LockYScale || LockZScale)
		{
			currentScale = base.transform.localScale;
			base.transform.localScale = new Vector3(LockXScale ? initialScale.x : currentScale.x, LockYScale ? initialScale.y : currentScale.y, LockZScale ? initialScale.z : currentScale.z);
		}
		if (LockXRotation || LockYRotation || LockZRotation)
		{
			currentRotation = base.transform.localEulerAngles;
			base.transform.localEulerAngles = new Vector3(LockXRotation ? initialRotation.x : currentRotation.x, LockYRotation ? initialRotation.y : currentRotation.y, LockZRotation ? initialRotation.z : currentRotation.z);
		}
	}

	private void LateUpdate()
	{
		lockPosition();
	}

	private void FixedUpdate()
	{
		lockPosition();
	}
}
public class EasyVRScreenFade : MonoSingleton<EasyVRScreenFade>
{
	private Image maskImg;

	private void Start()
	{
		maskImg = GetComponent<Image>();
		maskImg.enabled = false;
	}

	public void FadeClose()
	{
		FadeClose(0f, Color.black);
	}

	public void FadeClose(float time)
	{
		FadeClose(time, Color.black);
	}

	public void FadeClose(float time, Color color)
	{
		maskImg.enabled = true;
		maskImg.color = color;
		maskImg.DOFade(0f, time).OnComplete(delegate
		{
			maskImg.enabled = false;
		});
	}

	public void FadeOpen()
	{
		FadeOpen(0f, Color.black);
	}

	public void FadeOpen(float time)
	{
		UnityEngine.Debug.Log("<color=red>Open</color>");
		FadeOpen(time, Color.black);
	}

	public void FadeOpen(float time, Color color)
	{
		UnityEngine.Debug.Log("<color=red>Open</color>");
		maskImg.enabled = true;
		color.a = 0f;
		maskImg.color = color;
		maskImg.DOFade(1f, time);
	}
}
public class EasyVRSetting : Singleton<EasyVRSetting>
{
}
public enum EasyVRDeviceType
{
	EASYVR_STEAMVR_XR,
	EASYVR_PICOVR_XR,
	EASYVR_PICOVR,
	EASYVR_QUEST_XR,
	EASYVR_FOCUS_XR,
	EASYVR_PC,
	EASYVR_PC_TEST
}
public class EasyVRHandController : MonoBehaviour
{
	public VelocityEstimator velocityEstimator;

	public int controllerIndex;

	public bool showEvent;

	public bool showBool;

	public UnityEvent<EasyHandControllerKeyType> OnKeyEvent;

	[ShowIf("showBool")]
	public bool TriggerPressDown;

	[ShowIf("showBool")]
	public bool TriggerPressed;

	[ShowIf("showBool")]
	public bool TriggerPressUp;

	[ShowIf("showEvent")]
	public UnityEvent TriggerPressDownEvent;

	[ShowIf("showEvent")]
	public UnityEvent TriggerPressedEvent;

	[ShowIf("showEvent")]
	public UnityEvent TriggerPressUpEvent;

	public Vector2 JoyStickAxis;

	[ShowIf("showBool")]
	public bool JoyStickTouchDown;

	[ShowIf("showBool")]
	public bool JoyStickTouched;

	[ShowIf("showBool")]
	public bool JoyStickTouchUp;

	[ShowIf("showEvent")]
	public UnityEvent<Vector2> JoyStickAxisEvent;

	[ShowIf("showEvent")]
	public UnityEvent JoyStickTouchDownEvent;

	[ShowIf("showEvent")]
	public UnityEvent JoyStickTouchedEvent;

	[ShowIf("showEvent")]
	public UnityEvent JoyStickTouchUpEvent;

	[ShowIf("showBool")]
	public bool GripPressDown;

	[ShowIf("showBool")]
	public bool GripPressed;

	[ShowIf("showBool")]
	public bool GripPressUp;

	[ShowIf("showEvent")]
	public UnityEvent GripPressDownEvent;

	[ShowIf("showEvent")]
	public UnityEvent GripPressedEvent;

	[ShowIf("showEvent")]
	public UnityEvent GripPressUpEvent;

	[ShowIf("showBool")]
	public bool MenuPressDown;

	[ShowIf("showBool")]
	public bool MenuPressed;

	[ShowIf("showBool")]
	public bool MenuPressUp;

	[ShowIf("showEvent")]
	public UnityEvent MenuPressDownEvent;

	[ShowIf("showEvent")]
	public UnityEvent MenuPressedEvent;

	[ShowIf("showEvent")]
	public UnityEvent MenuPressUpEvent;

	[ShowIf("showBool")]
	public bool XPressDown;

	[ShowIf("showBool")]
	public bool XPressed;

	[ShowIf("showBool")]
	public bool XPressUp;

	[ShowIf("showEvent")]
	public UnityEvent XPressDownEvent;

	[ShowIf("showEvent")]
	public UnityEvent XPressedEvent;

	[ShowIf("showEvent")]
	public UnityEvent XPressUpEvent;

	[ShowIf("showBool")]
	public bool YPressDown;

	[ShowIf("showBool")]
	public bool YPressed;

	[ShowIf("showBool")]
	public bool YPressUp;

	[ShowIf("showEvent")]
	public UnityEvent YPressDownEvent;

	[ShowIf("showEvent")]
	public UnityEvent YPressedEvent;

	[ShowIf("showEvent")]
	public UnityEvent YPressUpEvent;

	[ShowIf("showBool")]
	public bool BPressDown;

	[ShowIf("showBool")]
	public bool BPressed;

	[ShowIf("showBool")]
	public bool BPressUp;

	[ShowIf("showEvent")]
	public UnityEvent BPressDownEvent;

	[ShowIf("showEvent")]
	public UnityEvent BPressedEvent;

	[ShowIf("showEvent")]
	public UnityEvent BPressUpEvent;

	[ShowIf("showBool")]
	public bool APressDown;

	[ShowIf("showBool")]
	public bool APressed;

	[ShowIf("showBool")]
	public bool APressUp;

	[ShowIf("showEvent")]
	public UnityEvent APressDownEvent;

	[ShowIf("showEvent")]
	public UnityEvent APressedEvent;

	[ShowIf("showEvent")]
	public UnityEvent APressUpEvent;

	[ShowIf("showEvent")]
	public UnityEvent<float, float> ShakeUnityEvent;

	public Vector3 angularVelocity => velocityEstimator.GetAngularVelocityEstimate();

	public Vector3 velocity => velocityEstimator.GetVelocityEstimate();

	private void Start()
	{
		controllerIndex = ((!(base.name == "Left")) ? 1 : 0);
		velocityEstimator = GetComponent<VelocityEstimator>();
		ShakeUnityEvent.AddListener(Shake);
	}

	public virtual void OnTriggerPressDown(bool state)
	{
		TriggerPressDown = state;
		if (state)
		{
			TriggerPressDownEvent?.Invoke();
			OnKeyEvent?.Invoke(EasyHandControllerKeyType.TriggerDown);
		}
	}

	public virtual void OnTriggerPressed(bool state)
	{
		TriggerPressed = state;
		if (state)
		{
			TriggerPressedEvent?.Invoke();
		}
	}

	public virtual void OnTriggerPressUp(bool state)
	{
		TriggerPressUp = state;
		if (state)
		{
			TriggerPressUpEvent?.Invoke();
			OnKeyEvent?.Invoke(EasyHandControllerKeyType.TriggerUp);
		}
	}

	public virtual void OnJoyStickAxis(Vector2 axis)
	{
		JoyStickAxis = axis;
		JoyStickAxisEvent.Invoke(axis);
	}

	public virtual void OnJoyStickTouchDown(bool state)
	{
		JoyStickTouchDown = state;
		if (state)
		{
			JoyStickTouchDownEvent?.Invoke();
			OnKeyEvent?.Invoke(EasyHandControllerKeyType.JoyStickDown);
		}
	}

	public virtual void OnJoyStickTouched(bool state)
	{
		JoyStickTouched = state;
		if (state)
		{
			JoyStickTouchedEvent?.Invoke();
		}
	}

	public virtual void OnJoyStickTouchUp(bool state)
	{
		JoyStickTouchUp = state;
		if (state)
		{
			JoyStickTouchUpEvent?.Invoke();
			OnKeyEvent?.Invoke(EasyHandControllerKeyType.JoyStickUp);
		}
	}

	public virtual void OnGripPressDown(bool state)
	{
		GripPressDown = state;
		if (state)
		{
			GripPressDownEvent?.Invoke();
			OnKeyEvent?.Invoke(EasyHandControllerKeyType.GripDown);
		}
	}

	public virtual void OnGripPressed(bool state)
	{
		GripPressed = state;
		if (state)
		{
			GripPressedEvent?.Invoke();
		}
	}

	public virtual void OnGripPressUp(bool state)
	{
		GripPressUp = state;
		if (state)
		{
			GripPressUpEvent?.Invoke();
			OnKeyEvent?.Invoke(EasyHandControllerKeyType.GripUp);
		}
	}

	public virtual void OnMenuPressDown(bool state)
	{
		MenuPressDown = state;
		if (state)
		{
			MenuPressDownEvent?.Invoke();
			OnKeyEvent?.Invoke(EasyHandControllerKeyType.MenuDown);
		}
	}

	public virtual void OnMenuPressed(bool state)
	{
		MenuPressed = state;
		if (state)
		{
			MenuPressedEvent?.Invoke();
		}
	}

	public virtual void OnMenuPressUp(bool state)
	{
		MenuPressUp = state;
		if (state)
		{
			MenuPressUpEvent?.Invoke();
			OnKeyEvent?.Invoke(EasyHandControllerKeyType.MenuUp);
		}
	}

	public virtual void OnXPressDown(bool state)
	{
		XPressDown = state;
		if (state)
		{
			XPressDownEvent?.Invoke();
			OnKeyEvent?.Invoke(EasyHandControllerKeyType.XDown);
		}
	}

	public virtual void OnXPressed(bool state)
	{
		XPressed = state;
		if (state)
		{
			XPressedEvent?.Invoke();
		}
	}

	public virtual void OnXPressUp(bool state)
	{
		XPressUp = state;
		if (state)
		{
			XPressUpEvent?.Invoke();
			OnKeyEvent?.Invoke(EasyHandControllerKeyType.XUp);
		}
	}

	public virtual void OnYPressDown(bool state)
	{
		YPressDown = state;
		if (state)
		{
			YPressDownEvent?.Invoke();
			OnKeyEvent?.Invoke(EasyHandControllerKeyType.YDown);
		}
	}

	public virtual void OnYPressed(bool state)
	{
		YPressed = state;
		if (state)
		{
			YPressedEvent?.Invoke();
		}
	}

	public virtual void OnYPressUp(bool state)
	{
		YPressUp = state;
		if (state)
		{
			YPressUpEvent?.Invoke();
			OnKeyEvent?.Invoke(EasyHandControllerKeyType.YUp);
		}
	}

	public virtual void OnBPressDown(bool state)
	{
		BPressDown = state;
		if (state)
		{
			BPressDownEvent?.Invoke();
			OnKeyEvent?.Invoke(EasyHandControllerKeyType.BDown);
		}
	}

	public virtual void OnBPressed(bool state)
	{
		BPressed = state;
		if (state)
		{
			BPressedEvent?.Invoke();
		}
	}

	public virtual void OnBPressUp(bool state)
	{
		BPressUp = state;
		if (state)
		{
			BPressUpEvent?.Invoke();
			OnKeyEvent?.Invoke(EasyHandControllerKeyType.BUp);
		}
	}

	public virtual void OnAPressDown(bool state)
	{
		APressDown = state;
		if (state)
		{
			APressDownEvent?.Invoke();
			OnKeyEvent?.Invoke(EasyHandControllerKeyType.ADown);
		}
	}

	public virtual void OnAPressed(bool state)
	{
		APressed = state;
		if (state)
		{
			APressedEvent?.Invoke();
		}
	}

	public virtual void OnAPressUp(bool state)
	{
		APressUp = state;
		if (state)
		{
			APressUpEvent?.Invoke();
			OnKeyEvent?.Invoke(EasyHandControllerKeyType.AUp);
		}
	}

	public void Shake(float time, float level)
	{
		ShakeUnityEvent?.Invoke(time, level);
	}
}
public enum EasyHandControllerKeyType
{
	TriggerUp,
	TriggerDown,
	JoyStickUp,
	JoyStickDown,
	GripUp,
	GripDown,
	MenuUp,
	MenuDown,
	XUp,
	XDown,
	YUp,
	YDown,
	BUp,
	BDown,
	AUp,
	ADown
}
public class EasyVRHandGrab : MonoBehaviour
{
	public LayerMask layerMask;

	[Tooltip("优先级,0-9 0为最高")]
	public int priority = 9;

	private EasyVRHandTouch handTouch;

	private EasyVRHandInfo handInfo;

	private List<EasyVRInteractionBase> selectObjs;

	private void Start()
	{
		handTouch = GetComponentInParent<EasyVRHandTouch>();
		handInfo = GetComponentInParent<EasyVRHandInfo>();
		selectObjs = new List<EasyVRInteractionBase>();
	}

	public bool IsInLayerMask(GameObject obj, LayerMask layerMask)
	{
		int num = 1 << obj.layer;
		return (layerMask.value & num) > 0;
	}

	private void OnTriggerEnter(Collider other)
	{
		if (IsInLayerMask(other.gameObject, layerMask) && other.TryGetComponent<EasyVRInteractionBase>(out var component))
		{
			handTouch.SetSelectItem(priority, component);
			component?.OnHandTouchEnter(handInfo);
		}
	}

	private void OnTriggerStay(Collider other)
	{
		if (IsInLayerMask(other.gameObject, layerMask) && other.TryGetComponent<EasyVRInteractionBase>(out var component))
		{
			component?.OnHandTouchStay(handInfo);
		}
	}

	private void OnTriggerExit(Collider other)
	{
		if (IsInLayerMask(other.gameObject, layerMask) && other.TryGetComponent<EasyVRInteractionBase>(out var component))
		{
			component?.OnHandTouchExit(handInfo);
			handTouch.RemoveSelectItem(priority, component);
		}
	}
}
public class EasyVRHandInfo : MonoBehaviour
{
	[HideInInspector]
	public EasyVRHandController handController;

	[ReadOnly]
	private HandPostureType postureType;

	[ReadOnly]
	public GameObject selectedObj;

	[ReadOnly]
	public EasyVRInteractionBase selectedInteractionBase;

	public TouchBase selectedTouchBase;

	public LayerMask layerMask;

	public GameObject model;

	public HandPostureType PostureType
	{
		get
		{
			return postureType;
		}
		set
		{
			postureType = value;
			switch (value)
			{
			case HandPostureType.舒展:
				model.GetComponent<Animator>().Play("normal");
				break;
			case HandPostureType.抓握:
				model.GetComponent<Animator>().Play("Take");
				break;
			case HandPostureType.指向:
				model.GetComponent<Animator>().Play("Indicate");
				break;
			}
		}
	}

	private void Start()
	{
		handController = GetComponent<EasyVRHandController>();
		model = base.transform.Find("model")?.gameObject;
	}

	public void OnGrabbing(EasyVRInteractionBase item)
	{
		if (!(item == null))
		{
			selectedObj = item.gameObject;
			selectedInteractionBase = item;
			if (!item.CompareTag("Door"))
			{
				selectedTouchBase = item as TouchBase;
				selectedObj.transform.parent = base.transform;
				selectedObj.transform.localPosition = Vector3.zero;
				selectedObj.transform.localRotation = Quaternion.identity;
			}
		}
	}

	public void CreateItemInHand(ItemType type)
	{
		UnityEngine.Debug.Log("生成物品" + type);
		selectedTouchBase = MonoSingleton<PoolManager>.Instance.GetTouchBase(type);
		if (!(selectedTouchBase == null))
		{
			selectedObj = selectedTouchBase.gameObject;
			selectedInteractionBase = selectedTouchBase;
			selectedInteractionBase.PressDown();
			selectedInteractionBase.OnGrabbing(this);
			selectedObj.transform.parent = base.transform;
			selectedObj.transform.localPosition = Vector3.zero;
			selectedObj.transform.localRotation = Quaternion.identity;
		}
	}

	public void RemoveSelectedInHand()
	{
		selectedObj = null;
		selectedTouchBase = null;
		selectedInteractionBase = null;
	}

	public void DelectSelectedInHand()
	{
		if (selectedTouchBase == null)
		{
			UnityEngine.Debug.LogError("无法移除物体,因为选中物体是空的");
		}
		selectedTouchBase.Recycle();
		RemoveSelectedInHand();
	}

	public void DelectSelectedAndRemoveInfoInBackpack()
	{
		if (selectedTouchBase == null)
		{
			UnityEngine.Debug.LogError("无法从背包中移除物体,因为选中物体是空的");
		}
		MonoSingleton<BackpackManager>.Instance.RemoveItemInfoInBackpackArray(selectedTouchBase.info.id);
		DelectSelectedInHand();
	}
}
public enum HandPostureType
{
	舒展,
	抓握,
	指向
}
public class EasyVRHandRay : MonoBehaviour
{
	public Transform dot;

	public Transform start;

	public GameObject rayLine;

	public Transform currentTarget;

	public Transform lastTarget;

	public float length = 4f;

	public LayerMask layer;

	public CullingGroup types;

	private Ray ray;

	private RaycastHit hit;

	private EasyVRHandInfo handInfo;

	private EasyVRHandTouch handTouch;

	private int priority;

	private void Start()
	{
		dot = base.transform.Find("dot");
		start = base.transform.Find("start");
		rayLine = base.transform.Find("ray_alpha").gameObject;
		handInfo = GetComponentInParent<EasyVRHandInfo>();
		handTouch = GetComponentInParent<EasyVRHandTouch>();
		EventsCentral.UI._Invoke_开启界面.AddListener(delegate
		{
			dot.gameObject.SetActive(MonoSingleton<PlayerInfo>.Instance.showRay);
			rayLine.gameObject.SetActive(MonoSingleton<PlayerInfo>.Instance.showRay);
		});
	}

	private void Update()
	{
		dot.gameObject.SetActive(MonoSingleton<PlayerInfo>.Instance.showRay);
		rayLine.gameObject.SetActive(MonoSingleton<PlayerInfo>.Instance.showRay);
		ray.direction = base.transform.forward - base.transform.up * 0.25f;
		ray.origin = start.position;
		if (Physics.Raycast(ray, out hit, length, layer) && handInfo.selectedObj == null)
		{
			currentTarget = hit.transform;
			if (lastTarget == null || lastTarget != currentTarget)
			{
				if (lastTarget != null)
				{
					handTouch.SetSelectItem(priority, null);
					lastTarget.GetComponent<EasyVRInteractionBase>()?.RayExit();
				}
				lastTarget = currentTarget;
				currentTarget.GetComponent<EasyVRInteractionBase>()?.RayEnter();
			}
			if (lastTarget == currentTarget)
			{
				lastTarget.GetComponent<EasyVRInteractionBase>()?.RayStay();
			}
			if (currentTarget != null)
			{
				DrawLine();
			}
		}
		else if (currentTarget != null)
		{
			lastTarget.GetComponent<EasyVRInteractionBase>()?.RayExit();
			handTouch.SetSelectItem(priority, null);
			currentTarget = null;
			lastTarget = null;
			dot.transform.position = Vector3.zero;
		}
	}

	private void DrawLine()
	{
		dot.position = hit.point;
		float num = 0.178f * dot.localPosition.z / 3.3f * 2f;
		Mathf.Clamp(num, 0.05f, 0.178f);
		dot.localScale = new Vector3(num, num, 1f);
	}
}
public class EasyVRHandTouch : MonoBehaviour
{
	private Transform itemContainer;

	public EasyVRHandInfo handInfo;

	public EasyVRHandController handController;

	public EasyVRInteractionBase raySelect = new EasyVRInteractionBase();

	public List<EasyVRInteractionBase> selectArray = new List<EasyVRInteractionBase>();

	public List<EasyVRInteractionBase> remoteSelectArray = new List<EasyVRInteractionBase>();

	public Transform startPoint;

	public Transform endPoint;

	public void SetSelectItem(int Priority, EasyVRInteractionBase item)
	{
		if (!(handInfo.selectedObj == null))
		{
			return;
		}
		switch (Priority)
		{
		case 0:
			raySelect = item;
			break;
		case 1:
			if (!selectArray.Contains(item))
			{
				selectArray.Add(item);
			}
			break;
		case 2:
			if (!remoteSelectArray.Contains(item))
			{
				remoteSelectArray.Add(item);
			}
			break;
		}
	}

	public void RemoveSelectItem(int Priority, EasyVRInteractionBase item)
	{
		if (!(handInfo.selectedObj == null))
		{
			return;
		}
		switch (Priority)
		{
		case 0:
			raySelect = null;
			break;
		case 1:
			if (selectArray.Contains(item))
			{
				selectArray.Remove(item);
			}
			break;
		case 2:
			if (remoteSelectArray.Contains(item))
			{
				remoteSelectArray.Remove(item);
			}
			break;
		}
	}

	public void RemoveAllSelectedArray()
	{
		raySelect = null;
		selectArray.Clear();
		remoteSelectArray.Clear();
	}

	public EasyVRInteractionBase GetClosestDistanceObj()
	{
		if (raySelect != null)
		{
			UnityEngine.Debug.Log(raySelect.name);
			return raySelect;
		}
		if (selectArray.Count != 0)
		{
			EasyVRInteractionBase easyVRInteractionBase = selectArray[0];
			for (int i = 1; i < selectArray.Count; i++)
			{
				if (DistanceFromPoint2Line(selectArray[i].transform.position) <= DistanceFromPoint2Line(easyVRInteractionBase.transform.position))
				{
					easyVRInteractionBase = selectArray[i];
				}
			}
			selectArray.Remove(easyVRInteractionBase);
			return easyVRInteractionBase;
		}
		if (remoteSelectArray.Count != 0)
		{
			EasyVRInteractionBase easyVRInteractionBase2 = remoteSelectArray[0];
			for (int j = 1; j < remoteSelectArray.Count; j++)
			{
				if (DistanceFromPoint2Line(remoteSelectArray[j].transform.position) <= DistanceFromPoint2Line(easyVRInteractionBase2.transform.position))
				{
					easyVRInteractionBase2 = remoteSelectArray[j];
				}
			}
			remoteSelectArray.Remove(easyVRInteractionBase2);
			return easyVRInteractionBase2;
		}
		return null;
	}

	private float DistanceFromPoint2Line(Vector3 point)
	{
		return DistanceFromPoint2Line(point, startPoint.position, endPoint.position);
	}

	private float DistanceFromPoint2Line(Vector3 p, Vector3 line_p1, Vector3 line_p2)
	{
		float num = Vector3.Distance(line_p2, p);
		Vector3 lhs = line_p2 - line_p1;
		Vector3 rhs = line_p2 - p;
		float f = Mathf.Acos(Vector3.Dot(lhs, rhs) / (lhs.magnitude * num));
		return num * Mathf.Sin(f);
	}

	private void Start()
	{
		handInfo = GetComponentInParent<EasyVRHandInfo>();
		handController = GetComponentInParent<EasyVRHandController>();
		handController.TriggerPressDownEvent.AddListener(OnGrab);
		handController.TriggerPressUpEvent.AddListener(OnRelease);
		EventsCentral.RaySelected.AddListener(RaySelect);
	}

	public void RaySelect(ItemType type)
	{
		if (type != 0)
		{
			TouchBase touchBase = MonoSingleton<PoolManager>.Instance.GetTouchBase(type);
			SetSelectItem(0, touchBase);
		}
		else
		{
			raySelect = null;
		}
	}

	private void OnGrab()
	{
		handInfo.PostureType = HandPostureType.抓握;
		handInfo.OnGrabbing(GetClosestDistanceObj());
		if (handInfo.selectedObj != null)
		{
			handInfo.selectedInteractionBase?.SetHandInfo(handInfo);
			handInfo.selectedInteractionBase?.PressDown();
			handInfo.selectedInteractionBase?.OnGrabbing(handInfo);
			handInfo.selectedInteractionBase?.onGrabEvent?.Invoke(handInfo);
			handInfo.model.SetActive(value: false);
		}
		RemoveAllSelectedArray();
	}

	private void OnRelease()
	{
		handInfo.model.SetActive(value: true);
		handInfo.PostureType = HandPostureType.舒展;
		if (handInfo.selectedObj != null)
		{
			handInfo.selectedInteractionBase?.PressUp();
			handInfo.selectedInteractionBase?.OnRelease();
			handInfo.selectedInteractionBase?.onReleaseEvent?.Invoke();
		}
	}
}
public class EasyVRRay : MonoBehaviour
{
	public Transform currentTarget;

	public Transform lastTarget;

	public float length = 4f;

	public LayerMask layer;

	private Ray ray;

	private RaycastHit hit;

	private EasyVRHandController handController;

	private EasyVRHandInfo handInfo;

	private void Start()
	{
		handController = GetComponentInParent<EasyVRHandController>();
		handInfo = GetComponentInParent<EasyVRHandInfo>();
	}

	private void Update()
	{
		ray.direction = base.transform.forward - base.transform.up * 0.25f;
		ray.origin = base.transform.position;
		if (Physics.Raycast(ray, out hit, length, layer))
		{
			if (!hit.transform.CompareTag("CheckStaticItem"))
			{
				return;
			}
			currentTarget = hit.transform;
			if (lastTarget == null || lastTarget != currentTarget)
			{
				if (lastTarget != null)
				{
					lastTarget.GetComponent<EasyVRInteractionBase>()?.SetHandInfo(null);
					lastTarget.GetComponent<EasyVRInteractionBase>()?.RayExit();
				}
				lastTarget = currentTarget;
				currentTarget.GetComponent<EasyVRInteractionBase>()?.SetHandInfo(handInfo);
				currentTarget.GetComponent<EasyVRInteractionBase>()?.RayEnter();
			}
			if (lastTarget == currentTarget)
			{
				lastTarget.GetComponent<EasyVRInteractionBase>()?.RayStay();
				if (handController.TriggerPressDown)
				{
					lastTarget.GetComponent<EasyVRInteractionBase>()?.PressDown();
				}
				if (handController.TriggerPressUp)
				{
					lastTarget.GetComponent<EasyVRInteractionBase>()?.PressUp();
				}
			}
		}
		else if (currentTarget != null)
		{
			lastTarget.GetComponent<EasyVRInteractionBase>()?.RayExit();
			currentTarget = null;
			lastTarget = null;
		}
	}
}
public class PCTestHand : MonoBehaviour
{
}
public class PCTestInput : MonoBehaviour
{
	public EasyVRHandController controller;

	private void Start()
	{
		controller = GetComponent<EasyVRHandController>();
	}

	private void Update()
	{
		controller.TriggerPressUp = Input.GetMouseButtonUp(0);
		controller.TriggerPressed = Input.GetMouseButton(0);
		controller.TriggerPressDown = Input.GetMouseButtonDown(0);
		controller.JoyStickAxis = new Vector2((Input.GetKey(KeyCode.A) ? 1 : 0) + (Input.GetKey(KeyCode.D) ? (-1) : 0), (Input.GetKey(KeyCode.W) ? 1 : 0) + (Input.GetKey(KeyCode.S) ? (-1) : 0));
	}
}
public class PicoHandInput : MonoBehaviour
{
	private EasyVRHandController controller;

	public XRController vrhand;

	private Vector2 joyStickAxis;

	private bool trigger;

	private bool grip;

	private bool bKey;

	public PXR_Input.Controller index => (PXR_Input.Controller)controller.controllerIndex;

	public bool TriggerPressed
	{
		set
		{
			if (!controller.TriggerPressed && value)
			{
				controller.TriggerPressDown = true;
			}
			else
			{
				controller.TriggerPressDown = false;
			}
			if (controller.TriggerPressed && !value)
			{
				controller.TriggerPressUp = true;
			}
			else
			{
				controller.TriggerPressUp = false;
			}
			controller.TriggerPressed = value;
		}
	}

	public bool GripPressed
	{
		set
		{
			if (!controller.GripPressed && value)
			{
				controller.GripPressDown = true;
			}
			else
			{
				controller.GripPressDown = false;
			}
			if (controller.GripPressed && !value)
			{
				controller.GripPressUp = true;
			}
			else
			{
				controller.GripPressUp = false;
			}
			controller.GripPressed = value;
		}
	}

	public bool BPressed
	{
		set
		{
			if (!controller.BPressed && value)
			{
				controller.BPressDown = true;
			}
			else
			{
				controller.BPressDown = false;
			}
			if (controller.BPressed && !value)
			{
				controller.BPressUp = true;
			}
			else
			{
				controller.BPressUp = false;
			}
			controller.BPressed = value;
		}
	}

	private void Start()
	{
		controller = GetComponent<EasyVRHandController>();
		vrhand = ((controller.controllerIndex == 0) ? MonoSingleton<PlayerInfo>.Instance.leftEasyVRHand.GetComponentInParent<XRController>() : MonoSingleton<PlayerInfo>.Instance.rightEasyVRHand.GetComponentInParent<XRController>());
		EventManager.AddListener<int>("Shake", Shake);
	}

	private string GetStringByIndex()
	{
		if (index != 0)
		{
			return "Right";
		}
		return "Left";
	}

	private void Shake(int obj)
	{
		PXR_Input.SetControllerVibration(obj / 4, 1, index);
	}

	private void Update()
	{
		Sync();
	}

	private void Sync()
	{
		if (PXR_Input.IsControllerConnected(index))
		{
			InputDevices.GetDeviceAtXRNode((XRNode)(4 + controller.controllerIndex)).TryGetFeatureValue(CommonUsages.primary2DAxis, out joyStickAxis);
			InputDevices.GetDeviceAtXRNode((XRNode)(4 + controller.controllerIndex)).TryGetFeatureValue(CommonUsages.secondaryButton, out bKey);
			InputDevices.GetDeviceAtXRNode((XRNode)(4 + controller.controllerIndex)).TryGetFeatureValue(CommonUsages.gripButton, out grip);
			InputDevices.GetDeviceAtXRNode((XRNode)(4 + controller.controllerIndex)).TryGetFeatureValue(CommonUsages.triggerButton, out trigger);
			TriggerPressed = trigger;
			GripPressed = grip;
			BPressed = bKey;
			controller.OnJoyStickAxis(joyStickAxis);
			controller.OnTriggerPressDown(controller.TriggerPressDown);
			controller.OnTriggerPressed(controller.TriggerPressed);
			controller.OnTriggerPressUp(controller.TriggerPressUp);
			controller.OnGripPressDown(controller.GripPressDown);
			controller.OnGripPressed(controller.GripPressed);
			controller.OnGripPressUp(controller.GripPressUp);
			controller.OnBPressDown(controller.BPressDown);
			controller.OnBPressed(controller.BPressed);
			controller.OnBPressUp(controller.BPressUp);
		}
	}
}
public class QuestHandInput : MonoBehaviour
{
}
public class AutoInputModule : BaseInputModule
{
	private List<HandCanvasPointer> pointers = new List<HandCanvasPointer>();

	private PointerEventData[] eventDatas;

	private AutoInputModule _instance;

	private bool _isDestroyed;

	public AutoInputModule Instance
	{
		get
		{
			if (_isDestroyed)
			{
				return null;
			}
			if (_instance == null && !(_instance = UnityEngine.Object.FindObjectOfType<AutoInputModule>()))
			{
				_instance = new GameObject().AddComponent<AutoInputModule>();
			}
			return _instance;
		}
	}

	protected override void Awake()
	{
		base.Awake();
	}

	protected override void OnDestroy()
	{
		_isDestroyed = true;
	}

	public int AddPointer(HandCanvasPointer pointer)
	{
		if (!pointers.Contains(pointer))
		{
			pointers.Add(pointer);
			eventDatas = new PointerEventData[pointers.Count];
			for (int i = 0; i < eventDatas.Length; i++)
			{
				eventDatas[i] = new PointerEventData(base.eventSystem);
				eventDatas[i].delta = Vector2.zero;
				eventDatas[i].position = new Vector2(Screen.width / 2, Screen.height / 2);
			}
		}
		return pointers.IndexOf(pointer);
	}

	public void RemovePointer(HandCanvasPointer pointer)
	{
		if (pointers.Contains(pointer))
		{
			pointers.Remove(pointer);
		}
		foreach (HandCanvasPointer pointer2 in pointers)
		{
			pointer2.SetIndex(pointers.IndexOf(pointer2));
		}
		eventDatas = new PointerEventData[pointers.Count];
		for (int i = 0; i < eventDatas.Length; i++)
		{
			eventDatas[i] = new PointerEventData(base.eventSystem);
			eventDatas[i].delta = Vector2.zero;
			eventDatas[i].position = new Vector2(Screen.width / 2, Screen.height / 2);
		}
	}

	public override void Process()
	{
		for (int i = 0; i < pointers.Count; i++)
		{
			try
			{
				if (pointers[i] != null && pointers[i].enabled)
				{
					pointers[i].Preprocess();
					base.eventSystem.RaycastAll(eventDatas[i], m_RaycastResultCache);
					eventDatas[i].pointerCurrentRaycast = BaseInputModule.FindFirstRaycast(m_RaycastResultCache);
					HandlePointerExitAndEnter(eventDatas[i], eventDatas[i].pointerCurrentRaycast.gameObject);
					ExecuteEvents.Execute(eventDatas[i].pointerDrag, eventDatas[i], ExecuteEvents.dragHandler);
				}
			}
			catch
			{
			}
		}
	}

	public void ProcessPress(int index)
	{
		pointers[index].Preprocess();
		eventDatas[index].pointerPressRaycast = eventDatas[index].pointerCurrentRaycast;
		eventDatas[index].pointerPress = ExecuteEvents.GetEventHandler<IPointerClickHandler>(eventDatas[index].pointerPressRaycast.gameObject);
		eventDatas[index].pointerDrag = ExecuteEvents.GetEventHandler<IDragHandler>(eventDatas[index].pointerPressRaycast.gameObject);
		ExecuteEvents.Execute(eventDatas[index].pointerPress, eventDatas[index], ExecuteEvents.pointerDownHandler);
		ExecuteEvents.Execute(eventDatas[index].pointerDrag, eventDatas[index], ExecuteEvents.beginDragHandler);
	}

	public void ProcessRelease(int index)
	{
		pointers[index].Preprocess();
		GameObject eventHandler = ExecuteEvents.GetEventHandler<IPointerClickHandler>(eventDatas[index].pointerCurrentRaycast.gameObject);
		if (eventDatas[index].pointerPress == eventHandler)
		{
			ExecuteEvents.Execute(eventDatas[index].pointerPress, eventDatas[index], ExecuteEvents.pointerClickHandler);
		}
		ExecuteEvents.Execute(eventDatas[index].pointerPress, eventDatas[index], ExecuteEvents.pointerUpHandler);
		ExecuteEvents.Execute(eventDatas[index].pointerDrag, eventDatas[index], ExecuteEvents.endDragHandler);
		eventDatas[index].pointerPress = null;
		eventDatas[index].pointerDrag = null;
		eventDatas[index].pointerCurrentRaycast.Clear();
	}

	public PointerEventData GetData(int index)
	{
		return eventDatas[index];
	}
}
public class HandCanvasPointer : MonoBehaviour
{
	[Header("References")]
	public GameObject hitPointMarker;

	private LineRenderer lineRenderer;

	[Header("Ray settings")]
	public float raycastLength = 8f;

	public bool autoShowTarget = true;

	public LayerMask UILayer;

	[Header("Events")]
	public UnityEvent StartSelect;

	public UnityEvent StopSelect;

	public UnityEvent StartPoint;

	public UnityEvent StopPoint;

	private bool hover;

	private AutoInputModule inputModule;

	private static Camera cam;

	private int pointerIndex;

	public GameObject select;

	private void OnEnable()
	{
		if (cam == null)
		{
			cam = new GameObject("Camera Canvas Pointer (I AM CREATED AT RUNTIME FOR UI CANVAS INTERACTION, I AM NOT RENDERING ANYTHING, I AM NOT CREATING ADDITIONAL OVERHEAD, THANK YOU FOR READING MY STORY)").AddComponent<Camera>();
			cam.clearFlags = CameraClearFlags.Nothing;
			cam.stereoTargetEye = StereoTargetEyeMask.None;
			cam.orthographic = true;
			cam.orthographicSize = 0.001f;
			cam.cullingMask = 0;
			cam.nearClipPlane = 0.01f;
			cam.depth = 0f;
			cam.allowHDR = false;
			cam.enabled = false;
			cam.fieldOfView = 1E-05f;
			Canvas[] array = UnityEngine.Object.FindObjectsOfType<Canvas>();
			for (int i = 0; i < array.Length; i++)
			{
				array[i].worldCamera = cam;
			}
		}
		if (inputModule.Instance != null)
		{
			pointerIndex = inputModule.Instance.AddPointer(this);
		}
	}

	private void OnDisable()
	{
		inputModule.Instance?.RemovePointer(this);
	}

	public void SetIndex(int index)
	{
		pointerIndex = index;
	}

	internal void Preprocess()
	{
		cam.transform.position = base.transform.position;
		cam.transform.forward = base.transform.forward;
	}

	public void Press()
	{
		UnityEngine.Debug.LogError("Press");
		inputModule.ProcessPress(pointerIndex);
		if (!autoShowTarget && hover)
		{
			ShowRay(show: true);
		}
		StartSelect?.Invoke();
	}

	public void Release()
	{
		UnityEngine.Debug.LogError("Release");
		inputModule.ProcessRelease(pointerIndex);
		StopSelect?.Invoke();
	}

	private void Awake()
	{
		if (lineRenderer == null)
		{
			base.gameObject.TryGetComponent<LineRenderer>(out lineRenderer);
		}
		if (inputModule == null)
		{
			EventSystem eventSystem;
			if (base.gameObject.TryGetComponent<AutoInputModule>(out var component))
			{
				inputModule = component;
			}
			else if (!(inputModule = UnityEngine.Object.FindObjectOfType<AutoInputModule>()) && (bool)(eventSystem = UnityEngine.Object.FindObjectOfType<EventSystem>()))
			{
				inputModule = eventSystem.gameObject.AddComponent<AutoInputModule>();
			}
		}
	}

	private void Start()
	{
		MonoSingleton<PlayerInfo>.Instance.rightController.TriggerPressDownEvent.AddListener(Press);
		MonoSingleton<PlayerInfo>.Instance.leftController.TriggerPressDownEvent.AddListener(Release);
	}

	private void Update()
	{
		UpdateLine();
	}

	private void UpdateLine()
	{
		PointerEventData data = inputModule.GetData(pointerIndex);
		float num = ((data.pointerCurrentRaycast.distance == 0f) ? raycastLength : data.pointerCurrentRaycast.distance);
		if (data.pointerCurrentRaycast.distance != 0f && !hover)
		{
			StartPoint?.Invoke();
			if (autoShowTarget)
			{
				ShowRay(show: true);
			}
			hover = true;
		}
		else if (data.pointerCurrentRaycast.distance == 0f && hover)
		{
			StopPoint?.Invoke();
			ShowRay(show: false);
			hover = false;
		}
		RaycastHit raycastHit = CreateRaycast(num);
		Vector3 position = base.transform.position + base.transform.forward * num;
		if ((bool)raycastHit.collider)
		{
			position = raycastHit.point;
		}
		if ((bool)raycastHit.collider)
		{
			UnityEngine.Debug.Log(raycastHit.collider.name);
		}
		hitPointMarker.transform.position = position;
		lineRenderer.SetPosition(0, base.transform.position);
		lineRenderer.SetPosition(1, position);
	}

	private RaycastHit CreateRaycast(float dist)
	{
		Physics.Raycast(new Ray(base.transform.position, base.transform.forward), out var hitInfo, dist, UILayer.value);
		return hitInfo;
	}

	private void ShowRay(bool show)
	{
		hitPointMarker.SetActive(show);
		lineRenderer.enabled = show;
	}
}
public class HTCHandInput : MonoBehaviour
{
}
public class VRInput : MonoBehaviour
{
	[Serializable]
	public enum Hands
	{
		Left,
		Right
	}

	public Hands hand;

	public float gripValue;

	public float joystickAxisHorizontalValue;

	public float joystickAxisVerticalValue;

	public Vector3 velocity;

	public Vector3 angularVelocity;

	private Vector3 previousPosition;

	private Vector3 previousAngularRotation;

	private string gripAxis;

	private string joystickAxisVertical;

	private string joystickAxisHorizontal;

	private void Start()
	{
		joystickAxisVertical = $"XRI_{hand}_Primary2DAxis_Vertical";
		joystickAxisHorizontal = $"XRI_{hand}_Primary2DAxis_Horizontal";
	}

	private void Update()
	{
		joystickAxisVerticalValue = Input.GetAxis(joystickAxisVertical);
		joystickAxisHorizontalValue = Input.GetAxis(joystickAxisHorizontal);
		velocity = (base.transform.position - previousPosition) / Time.deltaTime;
		previousPosition = base.transform.position;
		angularVelocity = (base.transform.eulerAngles - previousAngularRotation) / Time.deltaTime;
	}
}
public class JoyStickMovement2 : MonoBehaviour
{
	[SerializeField]
	private EasyVRHandController Lcontroller;

	[SerializeField]
	private EasyVRHandController Rcontroller;

	public float Speed = 2f;

	private CharacterController _characterController;

	public float DistanceFromGround;

	public RaycastHit groundHit;

	public LayerMask GroundedLayers;

	[Tooltip("真实身高")]
	public float rawHeight = 1.75f;

	public float heightOffset;

	[SerializeField]
	private Vector3 _direction;

	public AudioSource audioSource;

	private bool enableLinearMovement = true;

	public bool isTouchpad;

	public float flag;

	public Vector3 delta;

	public Transform head => MonoSingleton<PlayerInfo>.Instance.hmdTransform;

	public bool EnableLinearMovement
	{
		get
		{
			return enableLinearMovement;
		}
		set
		{
			enableLinearMovement = value;
		}
	}

	private void Start()
	{
		_characterController = GetComponent<CharacterController>();
		audioSource = GetComponent<AudioSource>();
		Lcontroller = MonoSingleton<PlayerInfo>.Instance.leftController;
		Rcontroller = MonoSingleton<PlayerInfo>.Instance.rightController;
		EventManager.AddListener<Vector3, float, bool>("MoveTo", SpeedMoveTo);
	}

	private void Update()
	{
		if (EnableLinearMovement)
		{
			flag = Rcontroller.JoyStickAxis.x;
			_direction = MonoSingleton<PlayerInfo>.Instance.hmdTransform.TransformDirection(new Vector3((Mathf.Abs(Lcontroller.JoyStickAxis.x) >= Mathf.Abs(Rcontroller.JoyStickAxis.x)) ? Lcontroller.JoyStickAxis.x : Rcontroller.JoyStickAxis.x, 0f, (Mathf.Abs(Lcontroller.JoyStickAxis.y) >= Mathf.Abs(Rcontroller.JoyStickAxis.y)) ? Lcontroller.JoyStickAxis.y : Rcontroller.JoyStickAxis.y)).normalized;
			if (_direction.magnitude > 0.5f && MonoSingleton<PlayerInfo>.Instance.CanMove)
			{
				if (!audioSource.isPlaying)
				{
					audioSource.Play();
				}
			}
			else if (audioSource.isPlaying)
			{
				audioSource.Pause();
			}
			Vector3 vector = new Vector3(0f, 9.8f, 0f);
			_characterController.Move(Speed * Time.deltaTime * Vector3.ProjectOnPlane(MonoSingleton<PlayerInfo>.Instance.CanMove ? _direction : Vector3.zero, Vector3.up) - vector * Time.deltaTime);
			CheckCharacterCollisionMove();
		}
		UpdateCharacterHeight();
	}

	private void CheckCharacterCollisionMove()
	{
		Vector3 position = MonoSingleton<PlayerInfo>.Instance.transform.position;
		Vector3 easyVRHeadPos = MonoSingleton<PlayerInfo>.Instance.GetEasyVRHeadPos();
		delta = easyVRHeadPos - base.transform.position;
		delta.y = 0f;
		if (delta.magnitude > 0f)
		{
			_characterController.Move(delta);
			MonoSingleton<PlayerInfo>.Instance.transform.position = new Vector3(position.x, MonoSingleton<PlayerInfo>.Instance.transform.position.y, position.z);
		}
	}

	public void UpdateCharacterHeight()
	{
		if ((bool)_characterController && Physics.Raycast(head.transform.position, -_characterController.transform.up, out groundHit, 20f, GroundedLayers, QueryTriggerInteraction.Ignore))
		{
			MonoSingleton<PlayerInfo>.Instance.transform.localPosition.Y(0f);
			DistanceFromGround = MonoSingleton<PlayerInfo>.Instance.hmdTransform.position.y - MonoSingleton<PlayerInfo>.Instance.feetGlobalPositionGuess.y;
			_characterController.height = Mathf.Clamp(DistanceFromGround, 0.1f, 4.8f);
		}
	}

	public void SpeedMoveTo(Vector3 targetPos, float time, bool endPointStop = false)
	{
		UnityEngine.Debug.Log(targetPos);
		EnableLinearMovement = false;
		float num = Vector3.Distance(base.transform.position, targetPos);
		if (endPointStop)
		{
			time = num / Speed;
		}
		targetPos = Vector3.LerpUnclamped(base.transform.position, targetPos, 1f / num * time * Speed);
		MonoSingleton<PlayerInfo>.Instance.CanMove = false;
		base.transform.DOMove(targetPos, time).SetEase(Ease.Linear).OnComplete(delegate
		{
			EnableLinearMovement = true;
			MonoSingleton<PlayerInfo>.Instance.CanMove = true;
		});
	}

	public void MoveTo(Vector3 targetPos, float time)
	{
		EnableLinearMovement = false;
		MonoSingleton<PlayerInfo>.Instance.CanMove = false;
		base.transform.DOMove(targetPos, time).SetEase(Ease.OutQuart).OnComplete(delegate
		{
			EnableLinearMovement = true;
			MonoSingleton<PlayerInfo>.Instance.CanMove = true;
		});
	}
}
public class JoyStickMovement3 : MonoBehaviour
{
	private EasyVRHandController Lcontroller;

	private EasyVRHandController Rcontroller;

	public LayerMask groundLayerMask;

	public bool EnableLinearMovement = true;

	public bool EnableRotation = true;

	public bool HMDRotatesPlayer = true;

	public bool RotationEitherThumbstick;

	public float RotationAngle = 45f;

	public float Speed = 1f;

	private Vector3 Gravity = new Vector3(0f, 9.8f, 0f);

	[ReadOnly]
	public PlayerInfo CameraRig;

	[SerializeField]
	private bool ReadyToSnapTurn;

	[ReadOnly]
	private CharacterController character;

	public AudioSource audioSource;

	public Vector3 delta;

	private Vector2 moveAxis => MonoSingleton<PlayerInfo>.Instance.leftController.JoyStickAxis;

	private Vector2 rotateAxis => MonoSingleton<PlayerInfo>.Instance.rightController.JoyStickAxis;

	public event Action CameraUpdated;

	public event Action PreCharacterMove;

	private void Awake()
	{
		audioSource = GetComponent<AudioSource>();
		character = GetComponent<CharacterController>();
		if (CameraRig == null)
		{
			CameraRig = GetComponentInChildren<PlayerInfo>();
		}
	}

	private void Start()
	{
		Lcontroller = MonoSingleton<PlayerInfo>.Instance.leftController;
		Rcontroller = MonoSingleton<PlayerInfo>.Instance.rightController;
	}

	public void MoveTo(Vector3 targetPos, float time, bool endPointStop = false)
	{
		float num = Vector3.Distance(base.transform.position, targetPos);
		if (endPointStop)
		{
			time = num / Speed;
		}
		targetPos = Vector3.LerpUnclamped(base.transform.position, targetPos, 1f / num * time * Speed);
		MonoSingleton<PlayerInfo>.Instance.CanMove = false;
		base.transform.DOMove(targetPos, time).SetEase(Ease.Linear).OnComplete(delegate
		{
		});
	}

	private void Update()
	{
		if (MonoSingleton<PlayerInfo>.Instance.CanMove)
		{
			GetInput();
		}
		if (HMDRotatesPlayer)
		{
			RotatePlayerToHMD();
		}
		if (EnableLinearMovement)
		{
			StickMovement();
		}
		if (EnableRotation)
		{
			SnapTurn();
		}
		UpdateHeight();
	}

	private void LateUpdate()
	{
	}

	private void GetInput()
	{
	}

	private void CheckCharacterCollisionMove()
	{
		Vector3 position = CameraRig.transform.position;
		Vector3 easyVRHeadPos = MonoSingleton<PlayerInfo>.Instance.GetEasyVRHeadPos();
		delta = easyVRHeadPos - base.transform.transform.position;
		delta.y = 0f;
		if (delta.magnitude > 0f)
		{
			character.Move(delta);
			CameraRig.transform.position = position;
		}
	}

	private void RotatePlayerToHMD()
	{
		Transform obj = CameraRig.transform;
		Transform transform = CameraRig.EasyVRHead.transform;
		Vector3 position = obj.position;
		Quaternion rotation = obj.rotation;
		base.transform.rotation = Quaternion.Euler(0f, transform.rotation.eulerAngles.y, 0f);
		obj.position = position;
		obj.rotation = rotation;
	}

	private void StickMovement()
	{
		if (moveAxis.magnitude > 0.1f)
		{
			Vector3 vector = MonoSingleton<PlayerInfo>.Instance.hmdTransform.TransformDirection(new Vector3(moveAxis.x, 0f, moveAxis.y));
			character.Move(Speed * Time.deltaTime * Vector3.ProjectOnPlane(vector, Vector3.up) - new Vector3(0f, 9.81f, 0f) * Time.deltaTime);
			if (moveAxis.magnitude > 0.5f && MonoSingleton<PlayerInfo>.Instance.CanMove)
			{
				if (!audioSource.isPlaying)
				{
					audioSource.Play();
				}
			}
			else if (audioSource.isPlaying)
			{
				audioSource.Pause();
			}
		}
		else
		{
			character.Move(new Vector3(0f, -9.81f, 0f) * Time.deltaTime);
		}
	}

	private void UpdateHeight()
	{
		character.height = Vector3.Dot(MonoSingleton<PlayerInfo>.Instance.EasyVRHead.transform.localPosition, Vector3.up) - 0.2f;
		character.center = new Vector3(MonoSingleton<PlayerInfo>.Instance.EasyVRHead.localPosition.x, character.height / 2f, MonoSingleton<PlayerInfo>.Instance.EasyVRHead.localPosition.z);
	}

	private void SnapTurn()
	{
		if (rotateAxis.x < -0.5f)
		{
			if (ReadyToSnapTurn)
			{
				ReadyToSnapTurn = false;
				base.transform.RotateAround(CameraRig.EasyVRHead.transform.position, Vector3.up, 0f - RotationAngle);
			}
		}
		else if (rotateAxis.x > 0.5f)
		{
			if (ReadyToSnapTurn)
			{
				ReadyToSnapTurn = false;
				base.transform.RotateAround(CameraRig.EasyVRHead.transform.position, Vector3.up, RotationAngle);
			}
		}
		else
		{
			ReadyToSnapTurn = true;
		}
	}
}
public class JoyStickMovement4 : MonoBehaviour
{
	private EasyVRHandController Lcontroller;

	private EasyVRHandController Rcontroller;

	public float Speed = 2f;

	private CharacterController _characterController;

	public float DistanceFromGround;

	public RaycastHit groundHit;

	public LayerMask GroundedLayers;

	[Tooltip("真实身高")]
	public float rawHeight = 1.75f;

	public float heightOffset;

	private Vector3 _direction;

	public AudioSource audioSource;

	public bool isTouchpad;

	public Transform head => MonoSingleton<PlayerInfo>.Instance.hmdTransform;

	private void Start()
	{
		_characterController = GetComponent<CharacterController>();
		audioSource = GetComponent<AudioSource>();
		Lcontroller = MonoSingleton<PlayerInfo>.Instance.leftController;
		Rcontroller = MonoSingleton<PlayerInfo>.Instance.rightController;
	}

	private void Update()
	{
		_direction = MonoSingleton<PlayerInfo>.Instance.hmdTransform.TransformDirection(new Vector3((Mathf.Abs(Lcontroller.JoyStickAxis.x) >= Mathf.Abs(Rcontroller.JoyStickAxis.x)) ? Lcontroller.JoyStickAxis.x : Rcontroller.JoyStickAxis.x, 0f, (Mathf.Abs(Lcontroller.JoyStickAxis.y) >= Mathf.Abs(Rcontroller.JoyStickAxis.y)) ? Lcontroller.JoyStickAxis.y : Rcontroller.JoyStickAxis.y));
		if (_direction.magnitude > 0.5f && MonoSingleton<PlayerInfo>.Instance.CanMove)
		{
			if (!audioSource.isPlaying)
			{
				audioSource.Play();
			}
		}
		else if (audioSource.isPlaying)
		{
			audioSource.Pause();
		}
		Vector3 vector = new Vector3(0f, 9.8f, 0f);
		_characterController.Move(Speed * Time.deltaTime * Vector3.ProjectOnPlane(MonoSingleton<PlayerInfo>.Instance.CanMove ? _direction : Vector3.zero, Vector3.up) - vector * Time.deltaTime);
		UpdateCharacterHeight();
	}

	public void UpdateCharacterHeight()
	{
		if ((bool)_characterController && Physics.Raycast(head.transform.position, -_characterController.transform.up, out groundHit, 20f, GroundedLayers, QueryTriggerInteraction.Ignore))
		{
			DistanceFromGround = MonoSingleton<PlayerInfo>.Instance.hmdTransform.position.y - MonoSingleton<PlayerInfo>.Instance.feetGlobalPositionGuess.y;
			_characterController.height = Mathf.Clamp(DistanceFromGround, 0.1f, 4.8f);
			_characterController.center = new Vector3(head.localPosition.x, DistanceFromGround / 2f, head.localPosition.z);
		}
	}

	public void MoveTo(Vector3 targetPos, float time, bool endPointStop = false)
	{
		float num = Vector3.Distance(base.transform.position, targetPos);
		if (endPointStop)
		{
			time = num / Speed;
		}
		targetPos = Vector3.LerpUnclamped(base.transform.position, targetPos, 1f / num * time * Speed);
		MonoSingleton<PlayerInfo>.Instance.CanMove = false;
		base.transform.DOMove(targetPos, time).SetEase(Ease.Linear).OnComplete(delegate
		{
		});
	}
}
public class JoyStickMovement5 : MonoBehaviour
{
	private EasyVRHandController Lcontroller;

	private EasyVRHandController Rcontroller;

	public float Speed = 2f;

	private CharacterController _characterController;

	public bool EnableLinearMovement = true;

	public float DistanceFromGround;

	public RaycastHit groundHit;

	public LayerMask GroundedLayers;

	[Tooltip("真实身高")]
	public float rawHeight = 1.75f;

	public float heightOffset;

	private Vector3 _direction;

	public AudioSource audioSource;

	public bool isTouchpad;

	[SerializeField]
	private Vector2 moveAxis;

	[SerializeField]
	private Vector2 rotateAxis;

	private Vector3 _gravity = new Vector3(0f, 9.8f, 0f);

	public Vector3 delta;

	public Transform head => MonoSingleton<PlayerInfo>.Instance.hmdTransform;

	private void Start()
	{
		_characterController = GetComponent<CharacterController>();
		audioSource = GetComponent<AudioSource>();
		Lcontroller = MonoSingleton<PlayerInfo>.Instance.leftController;
		Rcontroller = MonoSingleton<PlayerInfo>.Instance.rightController;
	}

	private void FixedUpdate()
	{
		GetInput();
		if (EnableLinearMovement)
		{
			Move();
		}
		if (EnableLinearMovement)
		{
			CheckCharacterCollisionMove();
		}
	}

	private void GetInput()
	{
		moveAxis = new Vector2(Lcontroller.JoyStickAxis.x, (Mathf.Abs(Lcontroller.JoyStickAxis.y) >= Mathf.Abs(Rcontroller.JoyStickAxis.y)) ? Lcontroller.JoyStickAxis.y : Rcontroller.JoyStickAxis.y);
		rotateAxis = Rcontroller.JoyStickAxis;
	}

	private void Move()
	{
		if (_direction.magnitude > 0.5f && MonoSingleton<PlayerInfo>.Instance.CanMove)
		{
			if (!audioSource.isPlaying)
			{
				audioSource.Play();
			}
		}
		else if (audioSource.isPlaying)
		{
			audioSource.Pause();
		}
		moveAxis.x *= 0.3f;
		_direction = MonoSingleton<PlayerInfo>.Instance.hmdTransform.TransformDirection(moveAxis);
		_characterController.Move(Speed * Time.deltaTime * Vector3.ProjectOnPlane(MonoSingleton<PlayerInfo>.Instance.CanMove ? _direction : Vector3.zero, Vector3.up) - _gravity * Time.deltaTime);
	}

	private void CheckCharacterCollisionMove()
	{
		Vector3 position = MonoSingleton<PlayerInfo>.Instance.transform.position;
		Vector3 easyVRHeadPos = MonoSingleton<PlayerInfo>.Instance.GetEasyVRHeadPos();
		delta = easyVRHeadPos - base.transform.position;
		delta.y = 0f;
		if (delta.magnitude > 0f)
		{
			_characterController.Move(delta);
			MonoSingleton<PlayerInfo>.Instance.transform.position = position;
		}
	}

	public void UpdateCharacterHeight()
	{
		if ((bool)_characterController && Physics.Raycast(head.transform.position, -_characterController.transform.up, out groundHit, 20f, GroundedLayers, QueryTriggerInteraction.Ignore))
		{
			DistanceFromGround = MonoSingleton<PlayerInfo>.Instance.hmdTransform.position.y - MonoSingleton<PlayerInfo>.Instance.feetGlobalPositionGuess.y;
			_characterController.height = Mathf.Clamp(DistanceFromGround, 0.1f, 4.8f);
			_characterController.center = new Vector3(head.localPosition.x, DistanceFromGround / 2f, head.localPosition.z);
		}
	}

	public void MoveTo(Vector3 targetPos, float time, bool endPointStop = false)
	{
		float num = Vector3.Distance(base.transform.position, targetPos);
		if (endPointStop)
		{
			time = num / Speed;
		}
		targetPos = Vector3.LerpUnclamped(base.transform.position, targetPos, 1f / num * time * Speed);
		MonoSingleton<PlayerInfo>.Instance.CanMove = false;
		base.transform.DOMove(targetPos, time).SetEase(Ease.Linear).OnComplete(delegate
		{
		});
	}
}
public class Movement : MonoBehaviour
{
	public CharacterController controller;

	public float walkSpeed = 5f;

	public float runSpeed = 6f;

	public float gravity = -9.81f;

	private Vector3 velocity;

	public Transform groundCheck;

	public float groundDistance = 0.4f;

	public LayerMask groundMask;

	private bool isGrounded;

	public float jumpHeight = 2f;

	private void Start()
	{
		controller = GetComponent<CharacterController>();
	}

	private void Update()
	{
		isGrounded = Physics.CheckSphere(groundCheck.position, groundDistance, groundMask);
		if (isGrounded && velocity.y < 0f)
		{
			velocity.y = -2f;
		}
		if (Input.GetButtonDown("Jump") && isGrounded)
		{
			velocity.y = Mathf.Sqrt(jumpHeight * -2f * gravity);
		}
		float axis = Input.GetAxis("Horizontal");
		float axis2 = Input.GetAxis("Vertical");
		Vector3 vector = base.transform.right * axis + base.transform.forward * axis2;
		controller.Move(vector * walkSpeed * Time.deltaTime);
		velocity.y += gravity * Time.deltaTime;
		controller.Move(velocity * Time.deltaTime);
		if (Input.GetKey(KeyCode.W) && Input.GetKey(KeyCode.Q))
		{
			controller.Move(vector * runSpeed * Time.deltaTime);
		}
	}
}
public class PlayerInfo : MonoSingleton<PlayerInfo>
{
	public EasyVRDeviceType deviceType;

	public Transform EasyVRHead;

	public Transform leftEasyVRHand;

	public Transform rightEasyVRHand;

	[ReadOnly]
	public EasyVRHandController leftController;

	[ReadOnly]
	public EasyVRHandController rightController;

	[ReadOnly]
	public EasyVRHandInfo leftTouch;

	[ReadOnly]
	public EasyVRHandInfo rightTouch;

	private JoyStickMovement3 movement;

	public float radius = 2f;

	[SerializeReference]
	private bool canMove;

	public bool canOpenUI;

	public bool canInput;

	public bool showRay;

	private Transform draw;

	public bool CanMove
	{
		get
		{
			return canMove;
		}
		set
		{
			canMove = value;
			SetSpeed(value ? 1 : 0);
		}
	}

	public Transform hmdTransform
	{
		get
		{
			if (EasyVRHead != null)
			{
				return EasyVRHead.transform;
			}
			return null;
		}
	}

	public float eyeHeight
	{
		get
		{
			Transform transform = hmdTransform;
			if ((bool)transform)
			{
				return Vector3.Project(transform.position - base.transform.position, base.transform.up).magnitude / base.transform.lossyScale.x;
			}
			return 0f;
		}
	}

	public Vector3 feetGlobalPositionGuess
	{
		get
		{
			Transform transform = hmdTransform;
			if ((bool)transform)
			{
				return base.transform.position + Vector3.ProjectOnPlane(transform.position - base.transform.position, base.transform.up);
			}
			return base.transform.position;
		}
	}

	public Vector3 feetLocalPositionGuess
	{
		get
		{
			Transform transform = hmdTransform;
			if ((bool)transform)
			{
				return Vector3.ProjectOnPlane(transform.position - base.transform.position, base.transform.up);
			}
			return base.transform.position;
		}
	}

	public Vector3 bodyDirectionGuess
	{
		get
		{
			Transform transform = hmdTransform;
			if ((bool)transform)
			{
				Vector3 vector = base.transform.position + Vector3.ProjectOnPlane(transform.forward, base.transform.up);
				if (Vector3.Dot(transform.up, base.transform.up) < 0f)
				{
					vector = -vector;
				}
				return vector;
			}
			return base.transform.forward;
		}
	}

	public Quaternion GetBodyDirection => draw.rotation;

	public Vector3 GetBodyPosition => base.transform.position;

	private void Awake()
	{
		UnityEngine.Object.DontDestroyOnLoad(base.transform.root);
		leftController = leftEasyVRHand.GetComponent<EasyVRHandController>();
		rightController = rightEasyVRHand.GetComponent<EasyVRHandController>();
		leftTouch = leftController.GetComponent<EasyVRHandInfo>();
		rightTouch = rightController.GetComponent<EasyVRHandInfo>();
		movement = GetComponent<JoyStickMovement3>();
	}

	private void Start()
	{
	}

	public Vector3 GetEasyVRHeadPos()
	{
		return EasyVRHead.transform.position;
	}

	public Transform GetEasyVRLeftHandTransform()
	{
		return GetEasyVRHandController(0);
	}

	public Transform GetEasyVRRightHandTransform()
	{
		return GetEasyVRHandController(1);
	}

	public Transform GetEasyVRHandController(int id)
	{
		if (id != 0)
		{
			return rightEasyVRHand.transform;
		}
		return leftEasyVRHand.transform;
	}

	public void SetCanMove(bool state, float timer = -1f)
	{
		CanMove = state;
		if (timer != -1f)
		{
			this.AttachTimer(timer, delegate
			{
				CanMove = true;
				UnityEngine.Debug.LogError("可以移动了");
			});
		}
	}

	public void SetEasyVRController(bool move, bool left, bool right)
	{
		UnityEngine.Debug.Log(move + "-----" + left + "------" + right);
		CanMove = move;
		leftEasyVRHand.gameObject.SetActive(left);
		rightEasyVRHand.gameObject.SetActive(right);
	}

	public void SetSpeed(float speed)
	{
		movement.Speed = speed;
	}

	public void SetPos(Transform pos, float time)
	{
		UnityEngine.Debug.Log(time);
		SetPos(pos.position, pos.rotation, rotatePlayer: true, time);
	}

	public void SetPos(Vector3 playerDestination, float time = 0f)
	{
		SetPos(playerDestination, base.transform.rotation, rotatePlayer: true, time);
	}

	public void SetPos(Vector3 playerDestination, Quaternion playerRotation)
	{
		SetPos(playerDestination, playerRotation, rotatePlayer: true);
	}

	public void SetPos(Vector3 playerDestination, Quaternion playerRotation, bool rotatePlayer)
	{
		SetPos(playerDestination, playerRotation, rotatePlayer, 0f, useFade: true);
	}

	public void SetPos(Transform pos)
	{
		SetPos(pos.position, pos.rotation, rotatePlayer: true);
	}

	public void SetPos(Vector3 playerDestination, Quaternion playerRotation, bool rotatePlayer = true, float time = 0f, bool useFade = true)
	{
		movement.enabled = false;
		Vector3 vector = feetGlobalPositionGuess - base.transform.position;
		base.transform.position = playerDestination - vector;
		Quaternion quaternion = playerRotation * Quaternion.Inverse(EasyVRHead.transform.rotation);
		base.transform.RotateAround(EasyVRHead.transform.position, Vector3.up, quaternion.eulerAngles.y);
		this.AttachTimer(0.1f, delegate
		{
			movement.enabled = true;
		});
	}

	internal void SpeedMoveTo(Vector3 position, float time, bool canMove, Action action = null)
	{
		Vector3 offset = feetGlobalPositionGuess - base.transform.position;
		base.transform.TweenPosition(position - offset, time).SetOnComplete(delegate
		{
			action?.Invoke();
			CanMove = canMove;
			string[] array = new string[5];
			Vector3 vector = position;
			array[0] = vector.ToString();
			array[1] = "   ";
			array[2] = base.transform.position.ToString();
			array[3] = "    ";
			vector = offset;
			array[4] = vector.ToString();
			UnityEngine.Debug.Log(string.Concat(array));
		});
	}

	private void Update()
	{
	}

	private void Draw()
	{
	}

	private void OnDrawGizmos()
	{
		Gizmos.color = Color.cyan;
		Gizmos.DrawLine(feetGlobalPositionGuess, feetGlobalPositionGuess + base.transform.up * eyeHeight);
		Gizmos.color = Color.blue;
		Vector3 vector = bodyDirectionGuess;
		Vector3 vector2 = Vector3.Cross(base.transform.up, vector);
		Vector3 vector3 = feetGlobalPositionGuess;
		Vector3 vector4 = vector3 + vector * 0.33f;
		Gizmos.DrawLine(vector3, vector4);
		Gizmos.DrawLine(vector4, vector4 - 0.033f * (vector + vector2));
		Gizmos.DrawLine(vector4, vector4 - 0.033f * (vector - vector2));
	}
}
public class PreventThroughWall : MonoBehaviour
{
	public GameObject obj;

	private void Start()
	{
	}

	private void OnTriggerEnter(Collider other)
	{
		obj = other.gameObject;
		if (1 << other.gameObject.layer == LayerMask.GetMask("Ground") || 1 << other.gameObject.layer == LayerMask.GetMask("Door"))
		{
			MonoSingleton<EasyVRScreenFade>.Instance.FadeOpen(0.5f);
		}
	}

	private void OnTriggerExit(Collider other)
	{
		if (1 << other.gameObject.layer == LayerMask.GetMask("Ground") || 1 << other.gameObject.layer == LayerMask.GetMask("Door"))
		{
			MonoSingleton<EasyVRScreenFade>.Instance.FadeClose(0.5f);
		}
	}
}
[RequireComponent(typeof(HingeJoint))]
public class SVLever : MonoBehaviour
{
	public float leverOnAngle = -45f;

	public float leverOffAngle = 45f;

	public bool leverIsOn;

	public bool leverWasSwitched;

	private HingeJoint leverHingeJoint;

	private bool wasGrabbed;

	private Vector3 startingEuler;

	private void Start()
	{
		leverHingeJoint = GetComponent<HingeJoint>();
		JointLimits limits = leverHingeJoint.limits;
		limits.max = Mathf.Max(leverOnAngle, leverOffAngle);
		limits.min = Mathf.Min(leverOnAngle, leverOffAngle);
		leverHingeJoint.limits = limits;
		leverHingeJoint.useLimits = true;
		startingEuler = base.transform.localEulerAngles;
		UpdateHingeJoint();
	}

	private void Update()
	{
		leverWasSwitched = false;
		float f = Quaternion.Angle(base.transform.localRotation, OffHingeAngle());
		if (Mathf.Abs(Quaternion.Angle(base.transform.localRotation, OnHingeAngle())) < Mathf.Abs(f) != leverIsOn)
		{
			leverIsOn = !leverIsOn;
			leverWasSwitched = true;
			UpdateHingeJoint();
		}
	}

	private void UpdateHingeJoint()
	{
		JointSpring spring = leverHingeJoint.spring;
		if (leverIsOn)
		{
			spring.targetPosition = leverOnAngle;
		}
		else
		{
			spring.targetPosition = leverOffAngle;
		}
		leverHingeJoint.useSpring = true;
		leverHingeJoint.spring = spring;
	}

	private Quaternion OnHingeAngle()
	{
		return Quaternion.Euler(leverHingeJoint.axis * leverOnAngle + startingEuler);
	}

	private Quaternion OffHingeAngle()
	{
		return Quaternion.Euler(leverHingeJoint.axis * leverOffAngle + startingEuler);
	}
}
public class ShowCharacterController : MonoBehaviour
{
	public CharacterController characterController;

	private void Update()
	{
		base.transform.localPosition = characterController.center;
		base.transform.localScale = new Vector3(characterController.radius, characterController.height, characterController.radius);
	}
}
public class TestAngle : MonoBehaviour
{
	public float angle;

	public Transform target;

	public Vector3 origin;

	public Vector3 cross;

	public float angleOffset;

	public bool x;

	public bool y;

	public bool z;

	private void Start()
	{
		origin = base.transform.position + new Vector3(x ? 1 : 0, z ? 1 : 0, y ? 1 : 0);
	}

	private void Update()
	{
		angle = (float)Angle(base.transform.position, origin, target.position) + angleOffset;
		base.transform.rotation = Quaternion.Euler(x ? angle : 0f, y ? angle : 0f, z ? angle : 0f);
	}

	public double Angle(Vector3 cen, Vector3 first, Vector3 second)
	{
		cross = Vector3.Cross(first - cen, second - cen);
		float num = Vector3.Angle(first - cen, second - cen);
		if (x)
		{
			return (cross.x > 0f) ? num : (360f - num);
		}
		if (y)
		{
			return (cross.y > 0f) ? num : (360f - num);
		}
		if (z)
		{
			return (cross.z > 0f) ? num : (360f - num);
		}
		return 0.0;
	}
}
public class TransformConstraint : MonoBehaviour
{
	public bool LockXPosition;

	public bool LockYPosition;

	public bool LockZPosition;

	public bool LockXScale = true;

	public bool LockYScale = true;

	public bool LockZScale = true;

	public bool LockXRotation;

	public bool LockYRotation;

	public bool LockZRotation;

	private Vector3 initialPosition;

	private Vector3 initialRotation;

	private Vector3 initialScale;

	private Vector3 currentPosition;

	private Vector3 currentScale;

	private Vector3 currentRotation;

	private void Start()
	{
		initialPosition = base.transform.localPosition;
		initialRotation = base.transform.localEulerAngles;
		initialScale = base.transform.localScale;
	}

	private void lockPosition()
	{
		if (LockXPosition || LockYPosition || LockZPosition)
		{
			currentPosition = base.transform.localPosition;
			base.transform.localPosition = new Vector3(LockXPosition ? initialPosition.x : currentPosition.x, LockYPosition ? initialPosition.y : currentPosition.y, LockZPosition ? initialPosition.z : currentPosition.z);
		}
		if (LockXScale || LockYScale || LockZScale)
		{
			currentScale = base.transform.localScale;
			base.transform.localScale = new Vector3(LockXScale ? initialScale.x : currentScale.x, LockYScale ? initialScale.y : currentScale.y, LockZScale ? initialScale.z : currentScale.z);
		}
		if (LockXRotation || LockYRotation || LockZRotation)
		{
			currentRotation = base.transform.localEulerAngles;
			base.transform.localEulerAngles = new Vector3(LockXRotation ? initialRotation.x : currentRotation.x, LockYRotation ? initialRotation.y : currentRotation.y, LockZRotation ? initialRotation.z : currentRotation.z);
		}
	}

	private void LateUpdate()
	{
		lockPosition();
	}

	private void FixedUpdate()
	{
		lockPosition();
	}
}
public class VRHeadBlocking : MonoBehaviour
{
	[SerializeField]
	private bool fadeEnabled = true;

	[SerializeField]
	private Color fadeColor = Color.black;

	[SerializeField]
	private LayerMask layerMask;

	private Collider[] objs = new Collider[10];

	private Vector3 prevHeadPos;

	private int fadeState;

	private float fadeDuration = 0.5f;

	private float internalFadeTimer;

	private float backupCap = 0.2f;

	private void Start()
	{
		layerMask = 256;
		layerMask = ~(int)layerMask;
		prevHeadPos = base.transform.position;
		FadeToColor();
		Invoke("FadeFromColor", fadeDuration);
	}

	private void FadeToColor()
	{
	}

	private void FadeFromColor()
	{
	}

	private int DetectHit(Vector3 loc)
	{
		int num = 0;
		int num2 = Physics.OverlapSphereNonAlloc(loc, backupCap, objs, layerMask, QueryTriggerInteraction.Ignore);
		for (int i = 0; i < num2; i++)
		{
			if (objs[i].tag != "Player")
			{
				num++;
			}
		}
		return num;
	}

	private void OnTriggerEnter(Collider other)
	{
		FadeToColor();
	}

	private void OnTriggerExit(Collider other)
	{
		FadeFromColor();
	}

	public void Update()
	{
	}
}
public class VelocityEstimator : MonoBehaviour
{
	[Tooltip("How many frames to average over for computing velocity")]
	public int velocityAverageFrames = 5;

	[Tooltip("How many frames to average over for computing angular velocity")]
	public int angularVelocityAverageFrames = 11;

	public bool estimateOnAwake;

	private Coroutine routine;

	private int sampleCount;

	private Vector3[] velocitySamples;

	private Vector3[] angularVelocitySamples;

	public void BeginEstimatingVelocity()
	{
		FinishEstimatingVelocity();
		routine = StartCoroutine(EstimateVelocityCoroutine());
	}

	public void FinishEstimatingVelocity()
	{
		if (routine != null)
		{
			StopCoroutine(routine);
			routine = null;
		}
	}

	public Vector3 GetVelocityEstimate()
	{
		Vector3 zero = Vector3.zero;
		int num = 5;
		if (num != 0)
		{
			for (int i = 0; i < num; i++)
			{
				zero += velocitySamples[i];
			}
			zero *= 1f / (float)num;
		}
		return zero;
	}

	public Vector3 GetAngularVelocityEstimate()
	{
		Vector3 zero = Vector3.zero;
		int num = 11;
		if (num != 0)
		{
			for (int i = 0; i < num; i++)
			{
				zero += angularVelocitySamples[i];
			}
			zero *= 1f / (float)num;
		}
		return zero;
	}

	public Vector3 GetAccelerationEstimate()
	{
		Vector3 zero = Vector3.zero;
		for (int i = 2 + sampleCount - velocitySamples.Length; i < sampleCount; i++)
		{
			if (i >= 2)
			{
				int num = i - 2;
				int num2 = i - 1;
				Vector3 vector = velocitySamples[num % velocitySamples.Length];
				Vector3 vector2 = velocitySamples[num2 % velocitySamples.Length];
				zero += vector2 - vector;
			}
		}
		return zero * (1f / Time.deltaTime);
	}

	private void Awake()
	{
		velocitySamples = new Vector3[velocityAverageFrames];
		angularVelocitySamples = new Vector3[angularVelocityAverageFrames];
		if (estimateOnAwake)
		{
			BeginEstimatingVelocity();
		}
	}

	private IEnumerator EstimateVelocityCoroutine()
	{
		sampleCount = 0;
		Vector3 previousPosition = base.transform.position;
		Quaternion previousRotation = base.transform.rotation;
		while (true)
		{
			yield return new WaitForEndOfFrame();
			float num = 1f / Time.deltaTime;
			int num2 = sampleCount % velocitySamples.Length;
			int num3 = sampleCount % angularVelocitySamples.Length;
			sampleCount++;
			velocitySamples[num2] = num * (base.transform.position - previousPosition);
			Quaternion quaternion = base.transform.rotation * Quaternion.Inverse(previousRotation);
			float num4 = 2f * Mathf.Acos(Mathf.Clamp(quaternion.w, -1f, 1f));
			if (num4 > (float)Math.PI)
			{
				num4 -= (float)Math.PI * 2f;
			}
			Vector3 vector = new Vector3(quaternion.x, quaternion.y, quaternion.z);
			if (vector.sqrMagnitude > 0f)
			{
				vector = num4 * num * vector.normalized;
			}
			angularVelocitySamples[num3] = vector;
			previousPosition = base.transform.position;
			previousRotation = base.transform.rotation;
		}
	}
}
public class TestManager : MonoSingleton<TestManager>
{
	public bool showConfig;

	[Label("行数")]
	[ShowIf("showConfig")]
	public int numberRows = 10;

	[ShowIf("showConfig")]
	public Vector2 buttonSize = new Vector2(100f, 50f);

	public Dictionary<string, Action> buttonDict = new Dictionary<string, Action>();

	public Dictionary<KeyCode, Action> keyDict = new Dictionary<KeyCode, Action>();

	public List<string> lst = new List<string>();

	private int temp;

	public GameObject panel;

	private void Start()
	{
		AddTest("跳转到古宅1", delegate
		{
			MonoSingleton<GlobalManager>.Instance.CurrentScene = MJFSM.SceneType.古宅;
		});
		AddTest("跳转到古宅2", delegate
		{
			MonoSingleton<GlobalManager>.Instance.CurrentScene = MJFSM.SceneType.兰登卧室;
		});
		AddTest("跳转到古宅3", delegate
		{
			MonoSingleton<GlobalManager>.Instance.CurrentScene = MJFSM.SceneType.酒店大厅;
		});
		AddTest("添加录音带", delegate
		{
			MonoSingleton<BackpackManager>.Instance.AddItem(ItemType._130047_物品_幻室_录音带Ⅰ);
		});
		AddTest("添加线索[一张画]", delegate
		{
			MonoSingleton<BackpackManager>.Instance.AddItem(ItemType._130101_线索_幻室_一张画);
		});
		AddTest("添加线索[致凯瑟琳的信]", delegate
		{
			MonoSingleton<BackpackManager>.Instance.AddItem(ItemType._130103_线索_幻室_致凯瑟琳的信);
		});
		AddTest("添加线索[狂化药剂]", delegate
		{
			MonoSingleton<BackpackManager>.Instance.AddItem(ItemType._140006_物品_幻室_狂化药剂);
		});
	}

	public static void AddTest(string name, Action action)
	{
		MonoSingleton<TestManager>.Instance.buttonDict.Add(name, action);
		MonoSingleton<TestManager>.Instance.lst.Add(name);
	}

	public static void AddTest(KeyCode key, Action action)
	{
		MonoSingleton<TestManager>.Instance.keyDict.Add(key, action);
	}

	private void Update()
	{
	}

	public void Show1(int index, string name, Action action)
	{
		panel.transform.GetChild(index).gameObject.SetActive(value: true);
		panel.transform.GetChild(index).GetComponent<Button>().onClick.AddListener(delegate
		{
			action();
		});
		panel.transform.GetChild(index).GetComponentInChildren<Text>().text = name;
	}
}
public class Cleanup : MonoBehaviour
{
	public float TimeBeforeCleanup;

	private void Awake()
	{
		StartCoroutine(CleanupObject());
	}

	public IEnumerator CleanupObject()
	{
		yield return new WaitForSeconds(TimeBeforeCleanup);
		UnityEngine.Object.DestroyObject(base.gameObject);
	}
}
[RequireComponent(typeof(AudioSource))]
public class Lightning : MonoBehaviour
{
	public Light TargetLight;

	public bool Enabled;

	public float MinWaitTime;

	public float MaxWaitTime;

	public AudioSource Sound;

	public void Awake()
	{
		if (!(TargetLight == null) && Enabled)
		{
			StartCoroutine(PlayLightning());
		}
	}

	private IEnumerator PlayLightning()
	{
		while (Enabled)
		{
			yield return new WaitForSeconds(UnityEngine.Random.Range(MinWaitTime, MaxWaitTime));
			TargetLight.intensity = 0f;
			if (Sound != null)
			{
				Sound.Play();
			}
			while (TargetLight.intensity < 0.3f)
			{
				TargetLight.intensity = Mathf.Lerp(TargetLight.intensity, 0.4f, Time.deltaTime * 15f);
				yield return new WaitForSeconds(0f);
			}
			while (TargetLight.intensity > 0f)
			{
				TargetLight.intensity = Mathf.Lerp(TargetLight.intensity, -0.1f, Time.deltaTime * 3f);
				yield return new WaitForSeconds(0f);
			}
			TargetLight.intensity = 0f;
		}
	}
}
public class PlayEffect : MonoBehaviour
{
	public GameObject Effect;

	public Transform Node;

	public float OverrideTime;

	private float m_Time;

	public void Awake()
	{
		m_Time = Time.time;
	}

	private void Update()
	{
		if (Effect == null)
		{
			return;
		}
		if (OverrideTime > 0f)
		{
			if (Time.time >= m_Time + OverrideTime)
			{
				UnityEngine.Object.Instantiate(Effect, Node.position, Node.rotation);
				m_Time = Time.time;
			}
		}
		else if (Time.time >= m_Time + 1.5f)
		{
			UnityEngine.Object.Instantiate(Effect, Node.position, Node.rotation);
			m_Time = Time.time;
		}
	}
}
public class Visual : MonoBehaviour
{
	public float DontChangeThis;

	private void OnDrawGizmosSelected()
	{
		Gizmos.color = new Color(1f, 1f, 1f, 0.5f);
		Gizmos.DrawCube(base.transform.position, new Vector3(15f, DontChangeThis, 15f));
	}
}
public class DemoGUI : MonoBehaviour
{
	public GameObject[] Prefabs;

	private int currentNomber;

	private GameObject currentInstance;

	private GUIStyle guiStyleHeader = new GUIStyle();

	private void Start()
	{
		guiStyleHeader.fontSize = 15;
		guiStyleHeader.normal.textColor = new Color(0.15f, 0.15f, 0.15f);
		currentInstance = UnityEngine.Object.Instantiate(Prefabs[currentNomber], base.transform.position, default(Quaternion));
		currentInstance.AddComponent<DemoReactivator>().TimeDelayToReactivate = 1.5f;
	}

	private void OnGUI()
	{
		if (GUI.Button(new Rect(10f, 15f, 105f, 30f), "Previous Effect"))
		{
			ChangeCurrent(-1);
		}
		if (GUI.Button(new Rect(130f, 15f, 105f, 30f), "Next Effect"))
		{
			ChangeCurrent(1);
		}
		GUI.Label(new Rect(300f, 15f, 100f, 20f), "Prefab name is \"" + Prefabs[currentNomber].name + "\"  \r\nHold any mouse button that would move the camera", guiStyleHeader);
	}

	private void ChangeCurrent(int delta)
	{
		currentNomber += delta;
		if (currentNomber > Prefabs.Length - 1)
		{
			currentNomber = 0;
		}
		else if (currentNomber < 0)
		{
			currentNomber = Prefabs.Length - 1;
		}
		if (currentInstance != null)
		{
			UnityEngine.Object.Destroy(currentInstance);
		}
		currentInstance = UnityEngine.Object.Instantiate(Prefabs[currentNomber], base.transform.position, default(Quaternion));
		currentInstance.AddComponent<DemoReactivator>().TimeDelayToReactivate = 1.5f;
	}
}
public class DemoReactivator : MonoBehaviour
{
	public float TimeDelayToReactivate = 3f;

	private void Start()
	{
		InvokeRepeating("Reactivate", 0f, TimeDelayToReactivate);
	}

	private void Reactivate()
	{
		Transform[] componentsInChildren = GetComponentsInChildren<Transform>();
		foreach (Transform obj in componentsInChildren)
		{
			obj.gameObject.SetActive(value: false);
			obj.gameObject.SetActive(value: true);
		}
	}
}
internal class UVTextureAnimator : MonoBehaviour
{
	public int Rows = 4;

	public int Columns = 4;

	public float Fps = 20f;

	public int OffsetMat;

	public bool IsLoop = true;

	public float StartDelay;

	private bool isInizialised;

	private int index;

	private int count;

	private int allCount;

	private float deltaFps;

	private bool isVisible;

	private bool isCorutineStarted;

	private Renderer currentRenderer;

	private Material instanceMaterial;

	private void Start()
	{
		currentRenderer = GetComponent<Renderer>();
		InitDefaultVariables();
		isInizialised = true;
		isVisible = true;
		Play();
	}

	private void InitDefaultVariables()
	{
		currentRenderer = GetComponent<Renderer>();
		if (currentRenderer == null)
		{
			throw new Exception("UvTextureAnimator can't get renderer");
		}
		if (!currentRenderer.enabled)
		{
			currentRenderer.enabled = true;
		}
		allCount = 0;
		deltaFps = 1f / Fps;
		count = Rows * Columns;
		index = Columns - 1;
		Vector3 zero = Vector3.zero;
		OffsetMat -= OffsetMat / count * count;
		Vector2 value = new Vector2(1f / (float)Columns, 1f / (float)Rows);
		if (currentRenderer != null)
		{
			instanceMaterial = currentRenderer.material;
			instanceMaterial.SetTextureScale("_MainTex", value);
			instanceMaterial.SetTextureOffset("_MainTex", zero);
		}
	}

	private void Play()
	{
		if (!isCorutineStarted)
		{
			if (StartDelay > 0.0001f)
			{
				Invoke("PlayDelay", StartDelay);
			}
			else
			{
				StartCoroutine(UpdateCorutine());
			}
			isCorutineStarted = true;
		}
	}

	private void PlayDelay()
	{
		StartCoroutine(UpdateCorutine());
	}

	private void OnEnable()
	{
		if (isInizialised)
		{
			InitDefaultVariables();
			isVisible = true;
			Play();
		}
	}

	private void OnDisable()
	{
		isCorutineStarted = false;
		isVisible = false;
		StopAllCoroutines();
		CancelInvoke("PlayDelay");
	}

	private IEnumerator UpdateCorutine()
	{
		while (isVisible && (IsLoop || allCount != count))
		{
			UpdateCorutineFrame();
			if (!IsLoop && allCount == count)
			{
				break;
			}
			yield return new WaitForSeconds(deltaFps);
		}
		isCorutineStarted = false;
		currentRenderer.enabled = false;
	}

	private void UpdateCorutineFrame()
	{
		allCount++;
		index++;
		if (index >= count)
		{
			index = 0;
		}
		Vector2 value = new Vector2((float)index / (float)Columns - (float)(index / Columns), 1f - (float)(index / Columns) / (float)Rows);
		if (currentRenderer != null)
		{
			instanceMaterial.SetTextureOffset("_MainTex", value);
		}
	}

	private void OnDestroy()
	{
		if (instanceMaterial != null)
		{
			UnityEngine.Object.Destroy(instanceMaterial);
			instanceMaterial = null;
		}
	}
}
public class CharacterBlood : MonoBehaviour
{
	public Material[] mat;

	public GameObject bloodFX;

	private bool startFade;

	private void Start()
	{
		for (int i = 0; i <= mat.Length - 1; i++)
		{
			mat[i].SetOverrideTag("RenderType", "");
			mat[i].SetInt("_SrcBlend", 1);
			mat[i].SetInt("_DstBlend", 0);
			mat[i].SetInt("_ZWrite", 1);
			mat[i].DisableKeyword("_ALPHATEST_ON");
			mat[i].DisableKeyword("_ALPHABLEND_ON");
			mat[i].DisableKeyword("_ALPHAPREMULTIPLY_ON");
			mat[i].renderQueue = -1;
			mat[i].SetColor("_Color", Color.gray);
			mat[i].SetColor("_SpecColor", Color.grey);
			mat[i].SetFloat("_Glossiness", 0.141f);
		}
		bloodFX.SetActive(value: false);
	}

	private void Update()
	{
		if (Input.GetButtonDown("Fire1"))
		{
			for (int i = 0; i <= mat.Length - 1; i++)
			{
				mat[i].SetInt("_SrcBlend", 5);
				mat[i].SetInt("_DstBlend", 10);
				mat[i].EnableKeyword("_ALPHABLEND_ON");
				mat[i].DisableKeyword("_ALPHAPREMULTIPLY_ON");
				mat[i].SetInt("_ZWrite", 0);
				mat[i].DisableKeyword("_ALPHATEST_ON");
				mat[i].renderQueue = 3000;
				mat[i].SetFloat("_Mode", 2f);
				mat[i].SetColor("_Color", Color.red);
				mat[i].SetColor("_SpecColor", Color.red);
			}
			bloodFX.SetActive(value: true);
			startFade = true;
		}
		if (startFade)
		{
			FadeOut();
		}
	}

	private void FadeOut()
	{
		for (int i = 0; i <= mat.Length - 1; i++)
		{
			Color color = mat[i].color;
			if (color.a >= 0f)
			{
				color.a -= 0.1f;
				mat[i].color = color;
				base.gameObject.SetActive(value: false);
			}
		}
	}
}
public class CharacterFire : MonoBehaviour
{
	public Material[] mat;

	public GameObject fireFX;

	public Light ExplodeLight;

	private bool startFade;

	private float t;

	private float fadeStart = 4f;

	private float fadeEnd;

	private float fadeTime = 1f;

	private float pauseTime;

	private Color32 defaultCol;

	public bool trigger;

	private void Start()
	{
		for (int i = 0; i <= mat.Length - 1; i++)
		{
			mat[i].SetOverrideTag("RenderType", "");
			mat[i].SetInt("_SrcBlend", 1);
			mat[i].SetInt("_DstBlend", 0);
			mat[i].SetInt("_ZWrite", 1);
			mat[i].DisableKeyword("_ALPHATEST_ON");
			mat[i].DisableKeyword("_ALPHABLEND_ON");
			mat[i].DisableKeyword("_ALPHAPREMULTIPLY_ON");
			mat[i].renderQueue = -1;
			mat[i].SetColor("_Color", Color.gray);
			mat[i].SetColor("_SpecColor", Color.grey);
			mat[i].SetFloat("_Glossiness", 0.141f);
		}
		fireFX.SetActive(value: false);
	}

	private void Update()
	{
		if (trigger)
		{
			for (int i = 0; i <= mat.Length - 1; i++)
			{
				mat[i].SetInt("_SrcBlend", 5);
				mat[i].SetInt("_DstBlend", 10);
				mat[i].EnableKeyword("_ALPHABLEND_ON");
				mat[i].DisableKeyword("_ALPHAPREMULTIPLY_ON");
				mat[i].SetInt("_ZWrite", 0);
				mat[i].DisableKeyword("_ALPHATEST_ON");
				mat[i].renderQueue = 3000;
				mat[i].SetFloat("_Mode", 2f);
			}
			StartCoroutine("FadeLight");
			startFade = true;
			fireFX.SetActive(value: true);
			trigger = false;
		}
		if (startFade)
		{
			FadeOut();
		}
	}

	private void FadeOut()
	{
		for (int i = 0; i <= mat.Length - 1; i++)
		{
			Color color = mat[i].color;
			if (color.a >= 0f)
			{
				color.a -= 0.05f;
				mat[i].color = color;
			}
		}
	}

	private IEnumerator FadeLight()
	{
		while (t < fadeTime)
		{
			if (pauseTime == 0f)
			{
				t += Time.deltaTime;
			}
			ExplodeLight.intensity = Mathf.Lerp(fadeStart, fadeEnd, t / fadeTime);
			yield return 0;
		}
		t = 0f;
	}
}
public class RFX4_AudioCurves : MonoBehaviour
{
	public AnimationCurve AudioCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public float GraphTimeMultiplier = 1f;

	public bool IsLoop;

	private bool canUpdate;

	private float startTime;

	private AudioSource audioSource;

	private float startVolume;

	private void Awake()
	{
		audioSource = GetComponent<AudioSource>();
		startVolume = audioSource.volume;
		audioSource.volume = AudioCurve.Evaluate(0f);
	}

	private void OnEnable()
	{
		startTime = Time.time;
		canUpdate = true;
	}

	private void Update()
	{
		float num = Time.time - startTime;
		if (canUpdate)
		{
			float volume = AudioCurve.Evaluate(num / GraphTimeMultiplier) * startVolume;
			audioSource.volume = volume;
		}
		if (num >= GraphTimeMultiplier)
		{
			if (IsLoop)
			{
				startTime = Time.time;
			}
			else
			{
				canUpdate = false;
			}
		}
	}
}
public class RFX4_LightCurves : MonoBehaviour
{
	public AnimationCurve LightCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public float GraphTimeMultiplier = 1f;

	public float GraphIntensityMultiplier = 1f;

	public bool IsLoop;

	public bool UseShadowsIfPossible;

	[HideInInspector]
	public bool canUpdate;

	private float startTime;

	private Light lightSource;

	private void Awake()
	{
		lightSource = GetComponent<Light>();
		lightSource.intensity = LightCurve.Evaluate(0f);
	}

	private void OnEnable()
	{
		startTime = Time.time;
		canUpdate = true;
	}

	private void Update()
	{
		float num = Time.time - startTime;
		if (canUpdate)
		{
			float intensity = LightCurve.Evaluate(num / GraphTimeMultiplier) * GraphIntensityMultiplier;
			lightSource.intensity = intensity;
			lightSource.shadows = (UseShadowsIfPossible ? LightShadows.Soft : LightShadows.None);
		}
		if (num >= GraphTimeMultiplier)
		{
			if (IsLoop)
			{
				startTime = Time.time;
			}
			else
			{
				canUpdate = false;
			}
		}
	}
}
public class RFX4_PhysicsForceCurves : MonoBehaviour
{
	public float ForceRadius = 5f;

	public float ForceMultiplier = 1f;

	public AnimationCurve ForceCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public ForceMode ForceMode;

	public float GraphTimeMultiplier = 1f;

	public float GraphIntensityMultiplier = 1f;

	public bool IsLoop;

	public float DestoryDistance = -1f;

	public bool UseDistanceScale;

	public AnimationCurve DistanceScaleCurve = AnimationCurve.EaseInOut(1f, 1f, 1f, 1f);

	public bool UseUPVector;

	public AnimationCurve DragCurve = AnimationCurve.EaseInOut(0f, 0f, 0f, 1f);

	public float DragGraphTimeMultiplier = -1f;

	public float DragGraphIntensityMultiplier = -1f;

	public string AffectedName;

	[HideInInspector]
	public float forceAdditionalMultiplier = 1f;

	private bool canUpdate;

	private float startTime;

	private Transform t;

	private void Awake()
	{
		t = base.transform;
	}

	private void OnEnable()
	{
		startTime = Time.time;
		canUpdate = true;
		forceAdditionalMultiplier = 1f;
	}

	private void FixedUpdate()
	{
		float num = Time.time - startTime;
		if (canUpdate)
		{
			float num2 = ForceCurve.Evaluate(num / GraphTimeMultiplier) * GraphIntensityMultiplier;
			Collider[] array = Physics.OverlapSphere(t.position, ForceRadius);
			foreach (Collider collider in array)
			{
				Rigidbody component = collider.GetComponent<Rigidbody>();
				if (!(component == null) && (AffectedName.Length <= 0 || collider.name.Contains(AffectedName)))
				{
					Vector3 vector;
					float num3;
					if (UseUPVector)
					{
						vector = Vector3.up;
						num3 = 1f - Mathf.Clamp01(collider.transform.position.y - t.position.y);
						num3 *= 1f - (collider.transform.position - t.position).magnitude / ForceRadius;
					}
					else
					{
						vector = collider.transform.position - t.position;
						num3 = 1f - vector.magnitude / ForceRadius;
					}
					if (UseDistanceScale)
					{
						collider.transform.localScale = DistanceScaleCurve.Evaluate(num3) * collider.transform.localScale;
					}
					if (DestoryDistance > 0f && vector.magnitude < DestoryDistance)
					{
						UnityEngine.Object.Destroy(collider.gameObject);
					}
					component.AddForce(vector.normalized * num3 * ForceMultiplier * num2 * forceAdditionalMultiplier, ForceMode);
					if (DragGraphTimeMultiplier > 0f)
					{
						component.drag = DragCurve.Evaluate(num / DragGraphTimeMultiplier) * DragGraphIntensityMultiplier;
						component.angularDrag = component.drag / 10f;
					}
				}
			}
		}
		if (num >= GraphTimeMultiplier)
		{
			if (IsLoop)
			{
				startTime = Time.time;
			}
			else
			{
				canUpdate = false;
			}
		}
	}

	private void OnDrawGizmosSelected()
	{
		Gizmos.color = Color.yellow;
		Gizmos.DrawWireSphere(base.transform.position, ForceRadius);
	}
}
public class RFX4_ScaleCurves : MonoBehaviour
{
	public AnimationCurve FloatCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public float GraphTimeMultiplier = 1f;

	public float GraphIntensityMultiplier = 1f;

	public bool IsLoop;

	private bool canUpdate;

	private float startTime;

	private Transform t;

	private int nameId;

	private Projector proj;

	private Vector3 startScale;

	private void Awake()
	{
		t = GetComponent<Transform>();
		startScale = t.localScale;
		t.localScale = Vector3.zero;
		proj = GetComponent<Projector>();
	}

	private void OnEnable()
	{
		startTime = Time.time;
		canUpdate = true;
		t.localScale = Vector3.zero;
	}

	private void Update()
	{
		float num = Time.time - startTime;
		if (canUpdate)
		{
			float num2 = FloatCurve.Evaluate(num / GraphTimeMultiplier) * GraphIntensityMultiplier;
			t.localScale = num2 * startScale;
			if (proj != null)
			{
				proj.orthographicSize = num2;
			}
		}
		if (num >= GraphTimeMultiplier)
		{
			if (IsLoop)
			{
				startTime = Time.time;
			}
			else
			{
				canUpdate = false;
			}
		}
	}
}
public class RFX4_ShaderColorGradient : MonoBehaviour
{
	public RFX4_ShaderProperties ShaderColorProperty;

	public Gradient Color = new Gradient();

	public float TimeMultiplier = 1f;

	public bool IsLoop;

	[HideInInspector]
	public float HUE = -1f;

	[HideInInspector]
	public bool canUpdate;

	private int propertyID;

	private float startTime;

	private Color startColor;

	private bool isInitialized;

	private string shaderProperty;

	private MaterialPropertyBlock props;

	private Renderer rend;

	private void Awake()
	{
		if (props == null)
		{
			props = new MaterialPropertyBlock();
		}
		if (rend == null)
		{
			rend = GetComponent<Renderer>();
		}
		shaderProperty = ShaderColorProperty.ToString();
		propertyID = Shader.PropertyToID(shaderProperty);
		startColor = rend.sharedMaterial.GetColor(propertyID);
	}

	private void OnEnable()
	{
		startTime = Time.time;
		canUpdate = true;
		rend.GetPropertyBlock(props);
		startColor = rend.sharedMaterial.GetColor(propertyID);
		props.SetColor(propertyID, startColor * Color.Evaluate(0f));
		rend.SetPropertyBlock(props);
	}

	private void Update()
	{
		rend.GetPropertyBlock(props);
		float num = Time.time - startTime;
		if (canUpdate)
		{
			Color color = Color.Evaluate(num / TimeMultiplier);
			if (HUE > -0.9f)
			{
				color = RFX4_ColorHelper.ConvertRGBColorByHUE(color, HUE);
				startColor = RFX4_ColorHelper.ConvertRGBColorByHUE(startColor, HUE);
			}
			props.SetColor(propertyID, color * startColor);
		}
		if (num >= TimeMultiplier)
		{
			if (IsLoop)
			{
				startTime = Time.time;
			}
			else
			{
				canUpdate = false;
			}
		}
		rend.SetPropertyBlock(props);
	}
}
public class RFX4_ShaderFloatCurve : MonoBehaviour
{
	public RFX4_ShaderProperties ShaderFloatProperty = RFX4_ShaderProperties._Cutout;

	public AnimationCurve FloatCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public float GraphTimeMultiplier = 1f;

	public float GraphIntensityMultiplier = 1f;

	public bool IsLoop;

	private bool canUpdate;

	private float startTime;

	private int propertyID;

	private string shaderProperty;

	private bool isInitialized;

	private MaterialPropertyBlock props;

	private Renderer rend;

	private void Awake()
	{
		if (props == null)
		{
			props = new MaterialPropertyBlock();
		}
		if (rend == null)
		{
			rend = GetComponent<Renderer>();
		}
		shaderProperty = ShaderFloatProperty.ToString();
		propertyID = Shader.PropertyToID(shaderProperty);
	}

	private void OnEnable()
	{
		startTime = Time.time;
		canUpdate = true;
		rend.GetPropertyBlock(props);
		float value = FloatCurve.Evaluate(0f) * GraphIntensityMultiplier;
		props.SetFloat(propertyID, value);
		rend.SetPropertyBlock(props);
	}

	private void Update()
	{
		rend.GetPropertyBlock(props);
		float num = Time.time - startTime;
		if (canUpdate)
		{
			float value = FloatCurve.Evaluate(num / GraphTimeMultiplier) * GraphIntensityMultiplier;
			props.SetFloat(propertyID, value);
		}
		if (num >= GraphTimeMultiplier)
		{
			if (IsLoop)
			{
				startTime = Time.time;
			}
			else
			{
				canUpdate = false;
			}
		}
		rend.SetPropertyBlock(props);
	}
}
public enum RFX4_ShaderProperties
{
	_TintColor,
	_Cutoff,
	_Color,
	_EmissionColor,
	_MaskPow,
	_Cutout,
	_Speed,
	_BumpAmt,
	_MainColor,
	_Distortion,
	_FresnelColor
}
public class RFX4_WindCurves : MonoBehaviour
{
	public AnimationCurve WindCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public float GraphTimeMultiplier = 1f;

	public float GraphIntensityMultiplier = 1f;

	public bool IsLoop;

	private bool canUpdate;

	private float startTime;

	private WindZone windZone;

	private void Awake()
	{
		windZone = GetComponent<WindZone>();
		windZone.windMain = WindCurve.Evaluate(0f);
		windZone.windMain = 0f - WindCurve.Evaluate(0f);
	}

	private void OnEnable()
	{
		startTime = Time.time;
		canUpdate = true;
	}

	private void Update()
	{
		float num = Time.time - startTime;
		if (canUpdate)
		{
			float num2 = WindCurve.Evaluate(num / GraphTimeMultiplier) * GraphIntensityMultiplier;
			windZone.windMain = 0f - num2;
		}
		if (num >= GraphTimeMultiplier)
		{
			if (IsLoop)
			{
				startTime = Time.time;
			}
			else
			{
				canUpdate = false;
			}
		}
	}
}
public class RFX4_EffectSettings : MonoBehaviour
{
	[Range(0.1f, 1f)]
	public float ParticlesBudget = 1f;

	public bool UseLightShadows;

	public bool UseFastFlatDecalsForMobiles = true;

	public bool UseCustomColor;

	public Color EffectColor = Color.red;

	public bool IsVisible = true;

	public float FadeoutTime = 1.5f;

	public bool UseCollisionDetection = true;

	public bool LimitMaxDistance;

	public float MaxDistnace = -1f;

	public float Mass = 1f;

	public float Speed = 10f;

	public float AirDrag = 0.1f;

	public bool UseGravity = true;

	private const string distortionNamePC = "KriptoFX/RFX4/Distortion";

	private const string distortionNameMobile = "KriptoFX/RFX4/DistortionMobile";

	private bool isCheckedDistortion;

	private bool prevIsVisible;

	private float currentFadeoutTime;

	private Renderer[] renderers;

	private Renderer[] skinRenderers;

	private Light[] lights;

	private ParticleSystem[] particleSystems;

	private AudioSource[] audioSources;

	private string[] colorProperties = new string[3] { "_TintColor", "_Color", "_MainColor" };

	private void Awake()
	{
		prevIsVisible = IsVisible;
		CacheRenderers();
	}

	private void OnEnable()
	{
		if (ParticlesBudget < 0.99f)
		{
			ChangeParticlesBudget(ParticlesBudget);
		}
		if (UseCustomColor)
		{
			ChangeParticleColor();
		}
		if (UseFastFlatDecalsForMobiles && IsMobilePlatform())
		{
			SetFlatDecals();
		}
		if (!UseLightShadows || IsMobilePlatform())
		{
			DisableShadows();
		}
	}

	private void Update()
	{
		if (prevIsVisible != IsVisible)
		{
			prevIsVisible = IsVisible;
			if (!IsVisible)
			{
				StartCoroutine(Fadeout());
			}
			else
			{
				Fadein();
			}
		}
	}

	private void ChangeParticlesBudget(float particlesMul)
	{
		ParticleSystem[] componentsInChildren = GetComponentsInChildren<ParticleSystem>(includeInactive: true);
		foreach (ParticleSystem obj in componentsInChildren)
		{
			ParticleSystem.MainModule main = obj.main;
			main.maxParticles = Mathf.Max(1, (int)((float)main.maxParticles * particlesMul));
			ParticleSystem.EmissionModule emission = obj.emission;
			if (!emission.enabled)
			{
				continue;
			}
			ParticleSystem.MinMaxCurve rateOverTime = emission.rateOverTime;
			if (rateOverTime.constantMin > 1f)
			{
				rateOverTime.constantMin *= particlesMul;
			}
			if (rateOverTime.constantMax > 1f)
			{
				rateOverTime.constantMax *= particlesMul;
			}
			emission.rateOverTime = rateOverTime;
			ParticleSystem.MinMaxCurve rateOverDistance = emission.rateOverDistance;
			if (rateOverDistance.constantMin > 1f)
			{
				if (rateOverDistance.constantMin > 1f)
				{
					rateOverDistance.constantMin *= particlesMul;
				}
				if (rateOverDistance.constantMax > 1f)
				{
					rateOverDistance.constantMax *= particlesMul;
				}
				emission.rateOverDistance = rateOverDistance;
			}
		}
	}

	public void ChangeParticleColor()
	{
		UnityEngine.Debug.Log("ColorChanged");
		float h = RFX4_ColorHelper.ColorToHSV(EffectColor).H;
		RFX4_ColorHelper.ChangeObjectColorByHUE(base.gameObject, h);
		RFX4_PhysicsMotion componentInChildren = GetComponentInChildren<RFX4_PhysicsMotion>();
		if (componentInChildren != null)
		{
			componentInChildren.HUE = h;
		}
		RFX4_RaycastCollision componentInChildren2 = GetComponentInChildren<RFX4_RaycastCollision>();
		if (componentInChildren2 != null)
		{
			componentInChildren2.HUE = h;
		}
	}

	public void SetFlatDecals()
	{
		RFX4_Decal[] componentsInChildren = GetComponentsInChildren<RFX4_Decal>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			componentsInChildren[i].IsScreenSpace = false;
		}
	}

	public void DisableShadows()
	{
		Light[] componentsInChildren = GetComponentsInChildren<Light>();
		foreach (Light obj in componentsInChildren)
		{
			RFX4_LightCurves component = obj.GetComponent<RFX4_LightCurves>();
			if (component != null && component.UseShadowsIfPossible)
			{
				component.UseShadowsIfPossible = false;
			}
			obj.shadows = LightShadows.None;
		}
		RFX4_ParticleLight[] componentsInChildren2 = GetComponentsInChildren<RFX4_ParticleLight>();
		for (int i = 0; i < componentsInChildren2.Length; i++)
		{
			componentsInChildren2[i].UseShadows = false;
		}
	}

	private bool IsMobilePlatform()
	{
		bool result = false;
		if (Application.isMobilePlatform)
		{
			result = true;
		}
		return result;
	}

	private IEnumerator Fadeout()
	{
		currentFadeoutTime = Time.time;
		while (Time.time - currentFadeoutTime < FadeoutTime)
		{
			ChangeAlphaFade();
			yield return new WaitForSeconds(1f / 30f);
		}
	}

	private void UpdateAlphaByProperties(Material mat, float overrideAlpha = -1f)
	{
		string[] array = colorProperties;
		foreach (string text in array)
		{
			if (mat.HasProperty(text))
			{
				Color color = mat.GetColor(text);
				if (overrideAlpha > -0.5f)
				{
					color.a = overrideAlpha;
				}
				else
				{
					color.a -= 1f / 30f / FadeoutTime;
				}
				mat.SetColor(text, color);
			}
		}
	}

	private void ChangeAlphaFade()
	{
		Renderer[] array = renderers;
		foreach (Renderer renderer in array)
		{
			if (!(renderer.GetComponent<ParticleSystem>() != null))
			{
				Material[] materials = renderer.materials;
				for (int j = 0; j < materials.Length; j++)
				{
					UpdateAlphaByProperties(materials[j]);
				}
			}
		}
		array = skinRenderers;
		for (int i = 0; i < array.Length; i++)
		{
			Material[] materials2 = array[i].materials;
			for (int k = 0; k < materials2.Length; k++)
			{
				UpdateAlphaByProperties(materials2[k]);
			}
		}
		for (int l = 0; l < lights.Length; l++)
		{
			lights[l].intensity -= 1f / 30f / FadeoutTime;
		}
		ParticleSystem[] array2 = particleSystems;
		foreach (ParticleSystem particleSystem in array2)
		{
			if (!particleSystem.isStopped)
			{
				particleSystem.Stop();
			}
		}
		AudioSource[] array3 = audioSources;
		for (int i = 0; i < array3.Length; i++)
		{
			array3[i].volume -= 1f / 30f / FadeoutTime;
		}
	}

	private void CacheRenderers()
	{
		renderers = GetComponentsInChildren<Renderer>(includeInactive: true);
		Renderer[] componentsInChildren = GetComponentsInChildren<SkinnedMeshRenderer>(includeInactive: true);
		skinRenderers = componentsInChildren;
		lights = GetComponentsInChildren<Light>(includeInactive: true);
		particleSystems = GetComponentsInChildren<ParticleSystem>(includeInactive: true);
		audioSources = GetComponentsInChildren<AudioSource>();
	}

	private void Fadein()
	{
		Transform[] componentsInChildren = base.gameObject.GetComponentsInChildren<Transform>();
		foreach (Transform obj in componentsInChildren)
		{
			obj.gameObject.SetActive(value: false);
			obj.gameObject.SetActive(value: true);
		}
		Renderer[] array = renderers;
		foreach (Renderer renderer in array)
		{
			if (!(renderer.GetComponent<ParticleSystem>() != null))
			{
				Material[] materials = renderer.materials;
				for (int j = 0; j < materials.Length; j++)
				{
					UpdateAlphaByProperties(materials[j], 1f);
				}
			}
		}
		AudioSource[] array2 = audioSources;
		for (int i = 0; i < array2.Length; i++)
		{
			array2[i].volume = 1f;
		}
	}
}
public class RFX4_CollisionPropertyDeactiavtion : MonoBehaviour
{
	public float DeactivateTimeDelay = 1f;

	private float startTime;

	private WindZone windZone;

	private ParticleSystem ps;

	private ParticleSystem.CollisionModule collisionModule;

	private void Awake()
	{
		ps = GetComponent<ParticleSystem>();
		collisionModule = ps.collision;
	}

	private void OnEnable()
	{
		startTime = Time.time;
		collisionModule.enabled = true;
	}

	private void Update()
	{
		if (Time.time - startTime >= DeactivateTimeDelay)
		{
			collisionModule.enabled = false;
		}
	}
}
public class RFX4_ParticleGravityDelay : MonoBehaviour
{
	public AnimationCurve GravityByTime = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public float TimeMultiplier = 3f;

	[Space]
	public float GravityMultiplierMin = 1f;

	public float GravityMultiplierMax = 1f;

	private ParticleSystem.MainModule main;

	private float startTime;

	private float startMinGrav;

	private float startMaxGrav;

	private void Awake()
	{
		main = GetComponent<ParticleSystem>().main;
		startMinGrav = main.gravityModifier.constantMin;
		startMaxGrav = main.gravityModifier.constantMax;
	}

	private void OnEnable()
	{
		startTime = Time.time;
		ParticleSystem.MinMaxCurve gravityModifier = main.gravityModifier;
		gravityModifier.constantMin = startMinGrav;
		gravityModifier.constantMax = startMaxGrav;
		main.gravityModifier = gravityModifier;
	}

	private void Update()
	{
		float num = Time.time - startTime;
		if (num < TimeMultiplier)
		{
			ParticleSystem.MinMaxCurve gravityModifier = main.gravityModifier;
			float num2 = GravityByTime.Evaluate(num / TimeMultiplier);
			gravityModifier.constantMin = num2 * GravityMultiplierMin;
			gravityModifier.constantMax = num2 * GravityMultiplierMax;
			main.gravityModifier = gravityModifier;
		}
	}
}
[ExecuteInEditMode]
[RequireComponent(typeof(ParticleSystem))]
public class RFX4_ParticleLight : MonoBehaviour
{
	public float LightIntencityMultiplayer = 1f;

	public bool UseShadows;

	public int LightsLimit = 10;

	private ParticleSystem ps;

	private ParticleSystem.Particle[] particles;

	private Light[] lights;

	private bool isLocalSpace;

	private void Start()
	{
		ps = GetComponent<ParticleSystem>();
		ParticleSystem.MainModule main = ps.main;
		if (main.maxParticles > LightsLimit)
		{
			main.maxParticles = LightsLimit;
		}
		particles = new ParticleSystem.Particle[main.maxParticles];
		isLocalSpace = ps.main.simulationSpace == ParticleSystemSimulationSpace.Local;
		lights = new Light[main.maxParticles];
		for (int i = 0; i < lights.Length; i++)
		{
			GameObject gameObject = new GameObject("ParticleLight" + i);
			gameObject.hideFlags = HideFlags.DontSave;
			lights[i] = gameObject.AddComponent<Light>();
			lights[i].transform.parent = base.transform;
			lights[i].intensity = 0f;
			lights[i].shadows = (UseShadows ? LightShadows.Soft : LightShadows.None);
		}
	}

	private void Update()
	{
		int num = ps.GetParticles(particles);
		for (int i = 0; i < num; i++)
		{
			lights[i].gameObject.SetActive(value: true);
			lights[i].transform.position = (isLocalSpace ? ps.transform.TransformPoint(particles[i].position) : particles[i].position);
			lights[i].color = particles[i].GetCurrentColor(ps);
			lights[i].range = particles[i].GetCurrentSize(ps);
			lights[i].intensity = (float)(int)particles[i].GetCurrentColor(ps).a / 255f * LightIntencityMultiplayer;
			lights[i].shadows = (UseShadows ? LightShadows.Soft : LightShadows.None);
			if (lights[i].intensity < 0.01f)
			{
				lights[i].gameObject.SetActive(value: false);
			}
		}
		for (int j = num; j < particles.Length; j++)
		{
			lights[j].gameObject.SetActive(value: false);
		}
	}
}
[RequireComponent(typeof(ParticleSystem))]
public class RFX4_ParticleTrail : MonoBehaviour
{
	public GameObject Target;

	public Vector2 DefaultSizeMultiplayer = Vector2.one;

	public float VertexLifeTime = 2f;

	public float TrailLifeTime = 2f;

	public bool UseShaderMaterial;

	public Material TrailMaterial;

	public bool UseColorOverLifeTime;

	public Gradient ColorOverLifeTime = new Gradient();

	public RFX4_ShaderProperties colorShaderProperty;

	public float ColorLifeTime = 1f;

	public bool UseUvAnimation;

	public int TilesX = 4;

	public int TilesY = 4;

	public int FPS = 30;

	public bool IsLoop = true;

	[Range(0.001f, 1f)]
	public float MinVertexDistance = 0.01f;

	public bool GetVelocityFromParticleSystem;

	public float Gravity = 0.01f;

	public Vector3 Force = new Vector3(0f, 0.01f, 0f);

	public float InheritVelocity;

	public float Drag = 0.01f;

	[Range(0.001f, 10f)]
	public float Frequency = 1f;

	[Range(0.001f, 10f)]
	public float OffsetSpeed = 0.5f;

	public bool RandomTurbulenceOffset;

	[Range(0.001f, 10f)]
	public float Amplitude = 2f;

	public float TurbulenceStrength = 0.1f;

	public AnimationCurve VelocityByDistance = AnimationCurve.EaseInOut(0f, 1f, 1f, 1f);

	public float AproximatedFlyDistance = -1f;

	public bool SmoothCurves = true;

	private Dictionary<int, LineRenderer> dict = new Dictionary<int, LineRenderer>();

	private ParticleSystem ps;

	private ParticleSystem.Particle[] particles;

	private TrailRenderer[] trails;

	private Color psColor;

	private Transform targetT;

	private int layer;

	private bool isLocalSpace = true;

	private Transform t;

	private void OnEnable()
	{
		if (Target != null)
		{
			targetT = Target.transform;
		}
		ps = GetComponent<ParticleSystem>();
		t = base.transform;
		isLocalSpace = ps.main.simulationSpace == ParticleSystemSimulationSpace.Local;
		particles = new ParticleSystem.Particle[ps.main.maxParticles];
		if (TrailMaterial != null)
		{
			psColor = TrailMaterial.GetColor(TrailMaterial.HasProperty("_TintColor") ? "_TintColor" : "_Color");
		}
		layer = base.gameObject.layer;
		Update();
	}

	private void ClearTrails()
	{
		TrailRenderer[] array = trails;
		foreach (TrailRenderer trailRenderer in array)
		{
			if (trailRenderer != null)
			{
				UnityEngine.Object.Destroy(trailRenderer.gameObject);
			}
		}
		trails = null;
	}

	private void Update()
	{
		if (dict.Count > 10)
		{
			RemoveEmptyTrails();
		}
		int num = ps.GetParticles(particles);
		for (int i = 0; i < num; i++)
		{
			int hashCode = particles[i].rotation3D.GetHashCode();
			if (!dict.ContainsKey(hashCode))
			{
				GameObject gameObject = new GameObject(hashCode.ToString());
				gameObject.transform.parent = base.transform;
				gameObject.transform.position = ps.transform.position;
				if (TrailLifeTime > 1E-05f)
				{
					UnityEngine.Object.Destroy(gameObject, TrailLifeTime + VertexLifeTime);
				}
				gameObject.layer = layer;
				LineRenderer lineRenderer = gameObject.AddComponent<LineRenderer>();
				lineRenderer.startWidth = 0f;
				lineRenderer.endWidth = 0f;
				lineRenderer.sharedMaterial = TrailMaterial;
				lineRenderer.useWorldSpace = false;
				if (UseColorOverLifeTime)
				{
					RFX4_ShaderColorGradient rFX4_ShaderColorGradient = gameObject.AddComponent<RFX4_ShaderColorGradient>();
					rFX4_ShaderColorGradient.Color = ColorOverLifeTime;
					rFX4_ShaderColorGradient.TimeMultiplier = ColorLifeTime;
					rFX4_ShaderColorGradient.ShaderColorProperty = colorShaderProperty;
				}
				if (UseUvAnimation)
				{
					RFX4_UVAnimation rFX4_UVAnimation = gameObject.AddComponent<RFX4_UVAnimation>();
					rFX4_UVAnimation.TilesX = TilesX;
					rFX4_UVAnimation.TilesY = TilesY;
					rFX4_UVAnimation.FPS = FPS;
					rFX4_UVAnimation.IsLoop = IsLoop;
				}
				dict.Add(hashCode, lineRenderer);
				continue;
			}
			LineRenderer lineRenderer2 = dict[hashCode];
			if (!(lineRenderer2 == null))
			{
				if (!lineRenderer2.useWorldSpace)
				{
					lineRenderer2.useWorldSpace = true;
					InitTrailRenderer(lineRenderer2.gameObject);
				}
				Vector2 vector = DefaultSizeMultiplayer * particles[i].GetCurrentSize(ps);
				lineRenderer2.startWidth = vector.y;
				lineRenderer2.endWidth = vector.x;
				if (Target != null)
				{
					float num2 = 1f - particles[i].remainingLifetime / particles[i].startLifetime;
					Vector3 a = Vector3.Lerp(particles[i].position, targetT.position, num2);
					lineRenderer2.transform.position = Vector3.Lerp(a, targetT.position, Time.deltaTime * num2);
				}
				else
				{
					lineRenderer2.transform.position = (isLocalSpace ? ps.transform.TransformPoint(particles[i].position) : particles[i].position);
				}
				lineRenderer2.transform.rotation = t.rotation;
				Color32 currentColor = particles[i].GetCurrentColor(ps);
				Color endColor = (lineRenderer2.startColor = psColor * currentColor);
				lineRenderer2.endColor = endColor;
			}
		}
		ps.SetParticles(particles, num);
	}

	private void InitTrailRenderer(GameObject go)
	{
		RFX4_TrailRenderer rFX4_TrailRenderer = go.AddComponent<RFX4_TrailRenderer>();
		rFX4_TrailRenderer.Amplitude = Amplitude;
		rFX4_TrailRenderer.Drag = Drag;
		rFX4_TrailRenderer.Gravity = Gravity;
		rFX4_TrailRenderer.Force = Force;
		rFX4_TrailRenderer.Frequency = Frequency;
		rFX4_TrailRenderer.InheritVelocity = InheritVelocity;
		rFX4_TrailRenderer.VertexLifeTime = VertexLifeTime;
		rFX4_TrailRenderer.TrailLifeTime = TrailLifeTime;
		rFX4_TrailRenderer.MinVertexDistance = MinVertexDistance;
		rFX4_TrailRenderer.OffsetSpeed = OffsetSpeed;
		rFX4_TrailRenderer.SmoothCurves = SmoothCurves;
		rFX4_TrailRenderer.AproximatedFlyDistance = AproximatedFlyDistance;
		rFX4_TrailRenderer.VelocityByDistance = VelocityByDistance;
		rFX4_TrailRenderer.RandomTurbulenceOffset = RandomTurbulenceOffset;
		rFX4_TrailRenderer.TurbulenceStrength = TurbulenceStrength;
	}

	private void RemoveEmptyTrails()
	{
		for (int i = 0; i < dict.Count; i++)
		{
			KeyValuePair<int, LineRenderer> keyValuePair = dict.ElementAt(i);
			if (keyValuePair.Value == null)
			{
				dict.Remove(keyValuePair.Key);
			}
		}
	}

	private void OnDisable()
	{
		foreach (KeyValuePair<int, LineRenderer> item in dict)
		{
			if (item.Value != null)
			{
				UnityEngine.Object.Destroy(item.Value.gameObject);
			}
		}
		dict.Clear();
	}
}
[ExecuteInEditMode]
[RequireComponent(typeof(ParticleSystem))]
public class RFX4_Turbulence : MonoBehaviour
{
	public enum MoveMethodEnum
	{
		Position,
		Velocity,
		RelativePosition
	}

	public enum PerfomanceEnum
	{
		High,
		Low
	}

	public float TurbulenceStrenght = 1f;

	public bool TurbulenceByTime;

	public float TimeDelay;

	public AnimationCurve TurbulenceStrengthByTime = AnimationCurve.EaseInOut(1f, 1f, 1f, 1f);

	public Vector3 Frequency = new Vector3(1f, 1f, 1f);

	public Vector3 OffsetSpeed = new Vector3(0.5f, 0.5f, 0.5f);

	public Vector3 Amplitude = new Vector3(5f, 5f, 5f);

	public Vector3 GlobalForce;

	public bool UseGlobalOffset = true;

	public MoveMethodEnum MoveMethod;

	public PerfomanceEnum Perfomance;

	public float ThreshholdSpeed;

	public AnimationCurve VelocityByDistance = AnimationCurve.EaseInOut(0f, 1f, 1f, 1f);

	public float AproximatedFlyDistance = -1f;

	private float lastStopTime;

	private Vector3 currentOffset;

	private float deltaTime;

	private float deltaTimeLastUpdateOffset;

	private ParticleSystem.Particle[] particleArray;

	private ParticleSystem particleSys;

	private float time;

	private int currentSplit;

	private float fpsTime;

	private int FPS;

	private int splitUpdate = 2;

	private PerfomanceEnum perfomanceOldSettings;

	private bool skipFrame;

	private Transform t;

	private float currentDelay;

	private void Start()
	{
		t = base.transform;
		particleSys = GetComponent<ParticleSystem>();
		if (particleArray == null || particleArray.Length < particleSys.main.maxParticles)
		{
			particleArray = new ParticleSystem.Particle[particleSys.main.maxParticles];
		}
		perfomanceOldSettings = Perfomance;
		UpdatePerfomanceSettings();
	}

	private void OnEnable()
	{
		currentDelay = 0f;
	}

	private void Update()
	{
		if (!Application.isPlaying)
		{
			deltaTime = Time.realtimeSinceStartup - lastStopTime;
			lastStopTime = Time.realtimeSinceStartup;
		}
		else
		{
			deltaTime = Time.deltaTime;
		}
		currentDelay += deltaTime;
		if (currentDelay < TimeDelay)
		{
			return;
		}
		if (!UseGlobalOffset)
		{
			currentOffset += OffsetSpeed * deltaTime;
		}
		else if (Application.isPlaying)
		{
			currentOffset = OffsetSpeed * Time.time;
		}
		else
		{
			currentOffset = OffsetSpeed * Time.realtimeSinceStartup;
		}
		if (Perfomance != perfomanceOldSettings)
		{
			perfomanceOldSettings = Perfomance;
			UpdatePerfomanceSettings();
		}
		time += deltaTime;
		if (QualitySettings.vSyncCount == 2)
		{
			UpdateTurbulence();
		}
		else if (QualitySettings.vSyncCount == 1)
		{
			if (Perfomance == PerfomanceEnum.Low)
			{
				if (skipFrame)
				{
					UpdateTurbulence();
				}
				skipFrame = !skipFrame;
			}
			if (Perfomance == PerfomanceEnum.High)
			{
				UpdateTurbulence();
			}
		}
		else if (QualitySettings.vSyncCount == 0)
		{
			if (time >= fpsTime)
			{
				time = 0f;
				UpdateTurbulence();
				deltaTimeLastUpdateOffset = 0f;
			}
			else
			{
				deltaTimeLastUpdateOffset += deltaTime;
			}
		}
	}

	private void UpdatePerfomanceSettings()
	{
		if (Perfomance == PerfomanceEnum.High)
		{
			FPS = 80;
			splitUpdate = 2;
		}
		if (Perfomance == PerfomanceEnum.Low)
		{
			FPS = 40;
			splitUpdate = 2;
		}
		fpsTime = 1f / (float)FPS;
	}

	private void UpdateTurbulence()
	{
		int particles = particleSys.GetParticles(particleArray);
		int num = 1;
		int num2;
		int num3;
		if (splitUpdate > 1)
		{
			num2 = particles / splitUpdate * currentSplit;
			num3 = Mathf.CeilToInt((float)particles * 1f / (float)splitUpdate * ((float)currentSplit + 1f));
			num = splitUpdate;
		}
		else
		{
			num2 = 0;
			num3 = particles;
		}
		for (int i = num2; i < num3; i++)
		{
			ParticleSystem.Particle particle = particleArray[i];
			float num4 = 1f;
			if (TurbulenceByTime)
			{
				num4 = TurbulenceStrengthByTime.Evaluate(1f - particle.remainingLifetime / particle.startLifetime);
			}
			if (ThreshholdSpeed > 1E-07f && num4 < ThreshholdSpeed)
			{
				return;
			}
			Vector3 position = particle.position;
			position.x /= Frequency.x + 1E-07f;
			position.y /= Frequency.y + 1E-07f;
			position.z /= Frequency.z + 1E-07f;
			Vector3 vector = default(Vector3);
			float num5 = deltaTime + deltaTimeLastUpdateOffset;
			vector.x = (Mathf.PerlinNoise(position.z - currentOffset.z, position.y - currentOffset.y) * 2f - 1f) * Amplitude.x * num5;
			vector.y = (Mathf.PerlinNoise(position.x - currentOffset.x, position.z - currentOffset.z) * 2f - 1f) * Amplitude.y * num5;
			vector.z = (Mathf.PerlinNoise(position.y - currentOffset.y, position.x - currentOffset.x) * 2f - 1f) * Amplitude.z * num5;
			float num6 = TurbulenceStrenght * num4 * (float)num;
			float num7 = 1f;
			float num8 = Mathf.Abs((particle.position - t.position).magnitude);
			if (AproximatedFlyDistance > 0f)
			{
				num7 = VelocityByDistance.Evaluate(Mathf.Clamp01(num8 / AproximatedFlyDistance));
			}
			vector *= num6;
			if (MoveMethod == MoveMethodEnum.Position)
			{
				particleArray[i].position += vector * num7;
			}
			if (MoveMethod == MoveMethodEnum.Velocity)
			{
				particleArray[i].velocity += vector * num7;
			}
			if (MoveMethod == MoveMethodEnum.RelativePosition)
			{
				particleArray[i].position += vector * particleArray[i].velocity.magnitude;
				particleArray[i].velocity = particleArray[i].velocity * 0.85f + vector.normalized * 0.15f * num7 + GlobalForce * num7;
			}
		}
		particleSys.SetParticles(particleArray, particles);
		currentSplit++;
		if (currentSplit >= splitUpdate)
		{
			currentSplit = 0;
		}
	}
}
public class RFX4_CameraShake : MonoBehaviour
{
	public AnimationCurve ShakeCurve = AnimationCurve.EaseInOut(0f, 1f, 1f, 0f);

	public float Duration = 2f;

	public float Speed = 22f;

	public float Magnitude = 1f;

	public float DistanceForce = 100f;

	public float RotationDamper = 2f;

	public bool IsEnabled = true;

	private bool isPlaying;

	[HideInInspector]
	public bool canUpdate;

	private void PlayShake()
	{
		StopAllCoroutines();
		StartCoroutine(Shake());
	}

	private void Update()
	{
		if (isPlaying && IsEnabled)
		{
			isPlaying = false;
			PlayShake();
		}
	}

	private void OnEnable()
	{
		isPlaying = true;
		if (UnityEngine.Object.FindObjectsOfType(typeof(RFX4_CameraShake)) is RFX4_CameraShake[] array)
		{
			RFX4_CameraShake[] array2 = array;
			for (int i = 0; i < array2.Length; i++)
			{
				array2[i].canUpdate = false;
			}
		}
		canUpdate = true;
	}

	private IEnumerator Shake()
	{
		float elapsed = 0f;
		Transform camT = Camera.main.transform;
		Vector3 originalCamRotation = camT.rotation.eulerAngles;
		Vector3 direction = (base.transform.position - camT.position).normalized;
		float time = 0f;
		float randomStart = UnityEngine.Random.Range(-1000f, 1000f);
		float distanceDamper = 1f - Mathf.Clamp01((camT.position - base.transform.position).magnitude / DistanceForce);
		Vector3 oldRotation = Vector3.zero;
		while (elapsed < Duration && canUpdate)
		{
			elapsed += Time.deltaTime;
			float num = elapsed / Duration;
			float num2 = ShakeCurve.Evaluate(num) * distanceDamper;
			time += Time.deltaTime * num2;
			camT.position -= direction * Time.deltaTime * Mathf.Sin(time * Speed) * num2 * Magnitude / 2f;
			float num3 = randomStart + Speed * num / 10f;
			float num4 = Mathf.PerlinNoise(num3, 0f) * 2f - 1f;
			float num5 = Mathf.PerlinNoise(1000f + num3, num3 + 1000f) * 2f - 1f;
			float num6 = Mathf.PerlinNoise(0f, num3) * 2f - 1f;
			if (Quaternion.Euler(originalCamRotation + oldRotation) != camT.rotation)
			{
				originalCamRotation = camT.rotation.eulerAngles;
			}
			oldRotation = Mathf.Sin(time * Speed) * num2 * Magnitude * new Vector3(0.5f + num5, 0.3f + num4, 0.3f + num6) * RotationDamper;
			camT.rotation = Quaternion.Euler(originalCamRotation + oldRotation);
			yield return null;
		}
	}
}
public static class RFX4_ColorHelper
{
	public struct HSBColor
	{
		public float H;

		public float S;

		public float B;

		public float A;

		public HSBColor(float h, float s, float b, float a)
		{
			H = h;
			S = s;
			B = b;
			A = a;
		}
	}

	private const float TOLERANCE = 0.0001f;

	private static string[] colorProperties = new string[8] { "_TintColor", "_Color", "_EmissionColor", "_BorderColor", "_ReflectColor", "_RimColor", "_MainColor", "_CoreColor" };

	public static HSBColor ColorToHSV(Color color)
	{
		HSBColor result = new HSBColor(0f, 0f, 0f, color.a);
		float r = color.r;
		float g = color.g;
		float b = color.b;
		float num = Mathf.Max(r, Mathf.Max(g, b));
		if (num <= 0f)
		{
			return result;
		}
		float num2 = Mathf.Min(r, Mathf.Min(g, b));
		float num3 = num - num2;
		if (num > num2)
		{
			if (Math.Abs(g - num) < 0.0001f)
			{
				result.H = (b - r) / num3 * 60f + 120f;
			}
			else if (Math.Abs(b - num) < 0.0001f)
			{
				result.H = (r - g) / num3 * 60f + 240f;
			}
			else if (b > g)
			{
				result.H = (g - b) / num3 * 60f + 360f;
			}
			else
			{
				result.H = (g - b) / num3 * 60f;
			}
			if (result.H < 0f)
			{
				result.H += 360f;
			}
		}
		else
		{
			result.H = 0f;
		}
		result.H *= 0.0027777778f;
		result.S = num3 / num * 1f;
		result.B = num;
		return result;
	}

	public static Color HSVToColor(HSBColor hsbColor)
	{
		float value = hsbColor.B;
		float value2 = hsbColor.B;
		float value3 = hsbColor.B;
		if (Math.Abs(hsbColor.S) > 0.0001f)
		{
			float b = hsbColor.B;
			float num = hsbColor.B * hsbColor.S;
			float num2 = hsbColor.B - num;
			float num3 = hsbColor.H * 360f;
			if (num3 < 60f)
			{
				value = b;
				value2 = num3 * num / 60f + num2;
				value3 = num2;
			}
			else if (num3 < 120f)
			{
				value = (0f - (num3 - 120f)) * num / 60f + num2;
				value2 = b;
				value3 = num2;
			}
			else if (num3 < 180f)
			{
				value = num2;
				value2 = b;
				value3 = (num3 - 120f) * num / 60f + num2;
			}
			else if (num3 < 240f)
			{
				value = num2;
				value2 = (0f - (num3 - 240f)) * num / 60f + num2;
				value3 = b;
			}
			else if (num3 < 300f)
			{
				value = (num3 - 240f) * num / 60f + num2;
				value2 = num2;
				value3 = b;
			}
			else if (num3 <= 360f)
			{
				value = b;
				value2 = num2;
				value3 = (0f - (num3 - 360f)) * num / 60f + num2;
			}
			else
			{
				value = 0f;
				value2 = 0f;
				value3 = 0f;
			}
		}
		return new Color(Mathf.Clamp01(value), Mathf.Clamp01(value2), Mathf.Clamp01(value3), hsbColor.A);
	}

	public static Color ConvertRGBColorByHUE(Color rgbColor, float hue)
	{
		float num = ColorToHSV(rgbColor).B;
		if (num < 0.0001f)
		{
			num = 0.0001f;
		}
		HSBColor hsbColor = ColorToHSV(rgbColor / num);
		hsbColor.H = hue;
		Color result = HSVToColor(hsbColor) * num;
		result.a = rgbColor.a;
		return result;
	}

	public static void ChangeObjectColorByHUE(GameObject go, float hue)
	{
		Renderer[] componentsInChildren = go.GetComponentsInChildren<Renderer>(includeInactive: true);
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			Material material = componentsInChildren[i].material;
			if (material == null)
			{
				continue;
			}
			string[] array = colorProperties;
			foreach (string name in array)
			{
				if (material.HasProperty(name))
				{
					setMatHUEColor(material, name, hue);
				}
			}
		}
		ParticleSystemRenderer[] componentsInChildren2 = go.GetComponentsInChildren<ParticleSystemRenderer>(includeInactive: true);
		foreach (ParticleSystemRenderer particleSystemRenderer in componentsInChildren2)
		{
			Material trailMaterial = particleSystemRenderer.trailMaterial;
			if (trailMaterial == null)
			{
				continue;
			}
			trailMaterial = (particleSystemRenderer.trailMaterial = new Material(trailMaterial)
			{
				name = trailMaterial.name + " (Instance)"
			});
			string[] array = colorProperties;
			foreach (string name2 in array)
			{
				if (trailMaterial.HasProperty(name2))
				{
					setMatHUEColor(trailMaterial, name2, hue);
				}
			}
		}
		SkinnedMeshRenderer[] componentsInChildren3 = go.GetComponentsInChildren<SkinnedMeshRenderer>(includeInactive: true);
		for (int i = 0; i < componentsInChildren3.Length; i++)
		{
			Material material3 = componentsInChildren3[i].material;
			if (material3 == null)
			{
				continue;
			}
			string[] array = colorProperties;
			foreach (string name3 in array)
			{
				if (material3.HasProperty(name3))
				{
					setMatHUEColor(material3, name3, hue);
				}
			}
		}
		Light[] componentsInChildren4 = go.GetComponentsInChildren<Light>(includeInactive: true);
		foreach (Light obj in componentsInChildren4)
		{
			HSBColor hsbColor = ColorToHSV(obj.color);
			hsbColor.H = hue;
			obj.color = HSVToColor(hsbColor);
		}
		ParticleSystem[] componentsInChildren5 = go.GetComponentsInChildren<ParticleSystem>(includeInactive: true);
		foreach (ParticleSystem obj2 in componentsInChildren5)
		{
			ParticleSystem.MainModule main = obj2.main;
			HSBColor hsbColor2 = ColorToHSV(obj2.main.startColor.color);
			hsbColor2.H = hue;
			main.startColor = HSVToColor(hsbColor2);
			ParticleSystem.ColorOverLifetimeModule colorOverLifetime = obj2.colorOverLifetime;
			ParticleSystem.MinMaxGradient color = colorOverLifetime.color;
			Gradient gradient = colorOverLifetime.color.gradient;
			GradientColorKey[] colorKeys = colorOverLifetime.color.gradient.colorKeys;
			float num = 0f;
			hsbColor2 = ColorToHSV(colorKeys[0].color);
			num = Math.Abs(ColorToHSV(colorKeys[1].color).H - hsbColor2.H);
			hsbColor2.H = hue;
			colorKeys[0].color = HSVToColor(hsbColor2);
			for (int k = 1; k < colorKeys.Length; k++)
			{
				hsbColor2 = ColorToHSV(colorKeys[k].color);
				hsbColor2.H = Mathf.Repeat(hsbColor2.H + num, 1f);
				colorKeys[k].color = HSVToColor(hsbColor2);
			}
			gradient.colorKeys = colorKeys;
			color.gradient = gradient;
			colorOverLifetime.color = color;
		}
		RFX4_ShaderColorGradient[] componentsInChildren6 = go.GetComponentsInChildren<RFX4_ShaderColorGradient>(includeInactive: true);
		for (int i = 0; i < componentsInChildren6.Length; i++)
		{
			componentsInChildren6[i].HUE = hue;
		}
	}

	private static Material setMatHUEColor(Material mat, string name, float hueColor)
	{
		Color value = ConvertRGBColorByHUE(mat.GetColor(name), hueColor);
		mat.SetColor(name, value);
		return mat;
	}

	private static Material setMatAlphaColor(Material mat, string name, float alpha)
	{
		Color color = mat.GetColor(name);
		color.a = alpha;
		mat.SetColor(name, color);
		return mat;
	}
}
public class RFX4_CopyPosition : MonoBehaviour
{
	public Transform CopiedTransform;

	private Transform t;

	private void Start()
	{
		t = base.transform;
	}

	private void Update()
	{
		t.position = CopiedTransform.position;
	}
}
[ExecuteInEditMode]
public class RFX4_CustomLight : MonoBehaviour
{
	public Light[] ImportantLights;

	private static int MaxLightsCount = 8;

	private Texture2D PointLightAttenuation;

	private List<Light> sceneLights;

	private void Awake()
	{
		sceneLights = UnityEngine.Object.FindObjectsOfType<Light>().ToList();
	}

	private void Update()
	{
		List<Light> allLights = GetAllLights();
		int num = 0;
		List<Vector4> list = new List<Vector4>();
		List<Vector4> list2 = new List<Vector4>();
		num += FillDirectionalLights(allLights, list, list2);
		allLights = SortPointLightsByDistance(allLights);
		num += FillPointLights(allLights, list, list2);
		Shader.SetGlobalInt("RFX4_LightCount", Mathf.Min(MaxLightsCount, num));
		Shader.SetGlobalVectorArray("RFX4_LightPositions", ListToArrayWithMaxCount(list, MaxLightsCount));
		Shader.SetGlobalVectorArray("RFX4_LightColors", ListToArrayWithMaxCount(list2, MaxLightsCount));
		Color value = SampleLightProbesUp(base.transform.position, 0.5f);
		Shader.SetGlobalColor("RFX4_AmbientColor", value);
	}

	private void OnDisable()
	{
		Shader.SetGlobalInt("RFX4_LightCount", 0);
		Shader.SetGlobalVectorArray("RFX4_LightPositions", new Vector4[1] { Vector4.zero });
		Shader.SetGlobalVectorArray("RFX4_LightColors", new Vector4[1] { Vector4.zero });
		Shader.SetGlobalColor("RFX4_AmbientColor", Color.black);
	}

	private List<Light> GetAllLights()
	{
		List<Light> list = base.transform.root.GetComponentsInChildren<Light>().ToList();
		foreach (Light sceneLight in sceneLights)
		{
			if (sceneLight != null)
			{
				list.Add(sceneLight);
			}
		}
		return list;
	}

	private int FillDirectionalLights(List<Light> lights, List<Vector4> lightPositions, List<Vector4> lightColors)
	{
		int num = 0;
		for (int i = 0; i < lights.Count; i++)
		{
			if (lights[i].isActiveAndEnabled && lights[i].type == LightType.Directional)
			{
				Vector3 vector = -lights[i].transform.forward;
				lightPositions.Add(new Vector4(vector.x, vector.y, vector.z, 0f));
				Color color = lights[i].color * lights[i].intensity;
				lightColors.Add(new Vector4(color.r, color.g, color.b, 0f));
				num++;
			}
		}
		return num;
	}

	private int FillPointLights(List<Light> lights, List<Vector4> lightPositions, List<Vector4> lightColors)
	{
		int num = 0;
		for (int i = 0; i < lights.Count; i++)
		{
			if (lights[i].isActiveAndEnabled && lights[i].type == LightType.Point)
			{
				Vector3 position = lights[i].transform.position;
				lightPositions.Add(new Vector4(position.x, position.y, position.z, lights[i].range));
				Color color = lights[i].color * lights[i].intensity;
				lightColors.Add(new Vector4(color.r, color.g, color.b, 1f));
				num++;
			}
		}
		return num;
	}

	private Vector4[] ListToArrayWithMaxCount(List<Vector4> list, int count)
	{
		Vector4[] array = new Vector4[count];
		for (int i = 0; i < count; i++)
		{
			if (list.Count > i)
			{
				array[i] = list[i];
			}
			else
			{
				array[i] = Vector4.zero;
			}
		}
		return array;
	}

	private List<Light> SortPointLightsByDistance(List<Light> lights)
	{
		Vector3 position = base.transform.position;
		SortedDictionary<float, Light> sortedDictionary = new SortedDictionary<float, Light>();
		foreach (Light light in lights)
		{
			if (light.type == LightType.Point && light.isActiveAndEnabled)
			{
				float num = (position - light.transform.position).magnitude;
				if (ImportantLights.Contains(light))
				{
					num = 0f;
				}
				num += UnityEngine.Random.Range(-10000f, 10000f) / 1000000f;
				if (!sortedDictionary.ContainsKey(num))
				{
					sortedDictionary.Add(num, light);
				}
			}
		}
		return sortedDictionary.Values.ToList();
	}

	public Color SampleLightProbesUp(Vector3 pos, float grayScaleFactor)
	{
		LightProbes.GetInterpolatedProbe(pos, null, out var probe);
		Vector4 a = new Vector4(probe[0, 3], probe[0, 1], probe[0, 2], probe[0, 0] - probe[0, 6]);
		Vector4 a2 = new Vector4(probe[1, 3], probe[1, 1], probe[1, 2], probe[1, 0] - probe[1, 6]);
		Vector4 a3 = new Vector4(probe[2, 3], probe[2, 1], probe[2, 2], probe[2, 0] - probe[2, 6]);
		Vector4 a4 = new Vector4(probe[0, 4], probe[0, 6], probe[0, 5] * 3f, probe[0, 7]);
		Vector4 a5 = new Vector4(probe[1, 4], probe[1, 6], probe[1, 5] * 3f, probe[1, 7]);
		Vector4 a6 = new Vector4(probe[2, 4], probe[2, 6], probe[2, 5] * 3f, probe[2, 7]);
		Vector3 vector = new Vector3(probe[0, 8], probe[2, 8], probe[1, 8]);
		Vector4 b = new Vector4(0f, 1f, 0f, 1f);
		Color black = Color.black;
		black.r = Vector4.Dot(a, b);
		black.g = Vector4.Dot(a2, b);
		black.b = Vector4.Dot(a3, b);
		Vector4 b2 = new Vector4(b.x * b.y, b.y * b.z, b.z * b.z, b.z * b.x);
		Color black2 = Color.black;
		black2.r = Vector4.Dot(a4, b2);
		black2.g = Vector4.Dot(a5, b2);
		black2.b = Vector4.Dot(a6, b2);
		float num = b.x * b.x - b.y * b.y;
		Vector3 vector2 = vector * num;
		Color color = new Color(vector2.x, vector2.y, vector2.z);
		Color a7 = black + black2 + color;
		float num2 = a7.r * 0.33f + a7.g * 0.33f + a7.b * 0.33f;
		a7 = Color.Lerp(a7, Color.white * num2, grayScaleFactor);
		if (QualitySettings.activeColorSpace == ColorSpace.Gamma)
		{
			return (black + black2 + color).gamma;
		}
		return a7;
	}
}
public class RFX4_DeactivateByTime : MonoBehaviour
{
	public GameObject DeactivatedGameObject;

	public float DeactivateTime = 3f;

	private bool isActiveState;

	private float currentTime;

	private void OnEnable()
	{
		currentTime = 0f;
		isActiveState = true;
	}

	private void Update()
	{
		currentTime += Time.deltaTime;
		if (isActiveState && currentTime >= DeactivateTime)
		{
			isActiveState = false;
			DeactivatedGameObject.SetActive(value: false);
		}
	}
}
public class RFX4_DeactivateRigidbodyByTime : MonoBehaviour
{
	public float TimeDelayToDeactivate = 6f;

	private void OnEnable()
	{
		Rigidbody component = GetComponent<Rigidbody>();
		component.isKinematic = false;
		component.detectCollisions = true;
		Invoke("Deactivate", TimeDelayToDeactivate);
	}

	private void Deactivate()
	{
		Rigidbody component = GetComponent<Rigidbody>();
		component.isKinematic = true;
		component.detectCollisions = false;
	}
}
[ExecuteInEditMode]
public class RFX4_Decal : MonoBehaviour
{
	public bool IsScreenSpace = true;

	private ParticleSystem ps;

	private ParticleSystem.MainModule psMain;

	private MaterialPropertyBlock props;

	private MeshRenderer rend;

	private void OnEnable()
	{
		ps = GetComponent<ParticleSystem>();
		if (ps != null)
		{
			psMain = ps.main;
		}
		if (Camera.main.depthTextureMode != DepthTextureMode.Depth)
		{
			Camera.main.depthTextureMode = DepthTextureMode.Depth;
		}
		GetComponent<MeshRenderer>().reflectionProbeUsage = ReflectionProbeUsage.Off;
		if (!IsScreenSpace)
		{
			Material sharedMaterial = GetComponent<Renderer>().sharedMaterial;
			sharedMaterial.EnableKeyword("USE_QUAD_DECAL");
			sharedMaterial.SetInt("_ZTest1", 4);
			if (Application.isPlaying)
			{
				Vector3 localPosition = base.transform.localPosition;
				localPosition.z += 0.1f;
				base.transform.localPosition = localPosition;
				Vector3 localScale = base.transform.localScale;
				localScale.y = 0.001f;
				base.transform.localScale = localScale;
			}
		}
		else
		{
			Material sharedMaterial2 = GetComponent<Renderer>().sharedMaterial;
			sharedMaterial2.DisableKeyword("USE_QUAD_DECAL");
			sharedMaterial2.SetInt("_ZTest1", 5);
		}
	}

	private void LateUpdate()
	{
		Matrix4x4 worldToLocalMatrix = base.transform.worldToLocalMatrix;
		if (props == null)
		{
			props = new MaterialPropertyBlock();
		}
		if (rend == null)
		{
			rend = GetComponent<MeshRenderer>();
		}
		rend.GetPropertyBlock(props);
		props.SetMatrix("_InverseTransformMatrix", worldToLocalMatrix);
		rend.SetPropertyBlock(props);
		if (ps != null)
		{
			psMain.scalingMode = ParticleSystemScalingMode.Hierarchy;
		}
	}

	private void OnDrawGizmosSelected()
	{
		Gizmos.matrix = Matrix4x4.TRS(base.transform.TransformPoint(Vector3.zero), base.transform.rotation, base.transform.lossyScale);
		Gizmos.color = new Color(1f, 1f, 1f, 1f);
		Gizmos.DrawWireCube(Vector3.zero, Vector3.one);
	}
}
public class RFX4_DemoReactivation : MonoBehaviour
{
	public float ReactivationTime = 5f;

	public GameObject Effect;

	private void Start()
	{
		InvokeRepeating("Reactivate", 0f, ReactivationTime);
	}

	private void Reactivate()
	{
		Effect.SetActive(value: false);
		Effect.SetActive(value: true);
	}
}
public class RFX4_EffectEvent : MonoBehaviour
{
	public GameObject CharacterEffect;

	public Transform CharacterAttachPoint;

	public float CharacterEffect_DestroyTime = 10f;

	[Space]
	public GameObject CharacterEffect2;

	public Transform CharacterAttachPoint2;

	public float CharacterEffect2_DestroyTime = 10f;

	[Space]
	public GameObject MainEffect;

	public Transform AttachPoint;

	public Transform OverrideAttachPointToTarget;

	public float Effect_DestroyTime = 10f;

	[Space]
	public GameObject AdditionalEffect;

	public Transform AdditionalEffectAttachPoint;

	public float AdditionalEffect_DestroyTime = 10f;

	[HideInInspector]
	public bool IsMobile;

	public void ActivateEffect()
	{
		if (!(MainEffect == null))
		{
			GameObject gameObject = ((!(OverrideAttachPointToTarget == null)) ? UnityEngine.Object.Instantiate(MainEffect, AttachPoint.transform.position, Quaternion.LookRotation(-(AttachPoint.position - OverrideAttachPointToTarget.position))) : UnityEngine.Object.Instantiate(MainEffect, AttachPoint.transform.position, AttachPoint.transform.rotation));
			UpdateEffectForMobileIsNeed(gameObject);
			if (Effect_DestroyTime > 0.01f)
			{
				UnityEngine.Object.Destroy(gameObject, Effect_DestroyTime);
			}
		}
	}

	public void ActivateAdditionalEffect()
	{
		if (AdditionalEffect == null)
		{
			return;
		}
		if (AdditionalEffectAttachPoint != null)
		{
			GameObject gameObject = UnityEngine.Object.Instantiate(AdditionalEffect, AdditionalEffectAttachPoint.transform.position, AdditionalEffectAttachPoint.transform.rotation);
			UpdateEffectForMobileIsNeed(gameObject);
			if (AdditionalEffect_DestroyTime > 0.01f)
			{
				UnityEngine.Object.Destroy(gameObject, AdditionalEffect_DestroyTime);
			}
		}
		else
		{
			AdditionalEffect.SetActive(value: true);
		}
	}

	public void ActivateCharacterEffect()
	{
		if (!(CharacterEffect == null))
		{
			GameObject gameObject = UnityEngine.Object.Instantiate(CharacterEffect, CharacterAttachPoint.transform.position, CharacterAttachPoint.transform.rotation, CharacterAttachPoint.transform);
			UpdateEffectForMobileIsNeed(gameObject);
			if (CharacterEffect_DestroyTime > 0.01f)
			{
				UnityEngine.Object.Destroy(gameObject, CharacterEffect_DestroyTime);
			}
		}
	}

	public void ActivateCharacterEffect2()
	{
		if (!(CharacterEffect2 == null))
		{
			GameObject gameObject = UnityEngine.Object.Instantiate(CharacterEffect2, CharacterAttachPoint2.transform.position, CharacterAttachPoint2.transform.rotation, CharacterAttachPoint2);
			UpdateEffectForMobileIsNeed(gameObject);
			if (CharacterEffect2_DestroyTime > 0.01f)
			{
				UnityEngine.Object.Destroy(gameObject, CharacterEffect2_DestroyTime);
			}
		}
	}

	private void UpdateEffectForMobileIsNeed(GameObject instance)
	{
		_ = instance.GetComponent<RFX4_EffectSettings>() != null;
	}
}
[RequireComponent(typeof(Renderer))]
[ExecuteInEditMode]
public class RFX4_MaterialQueue : MonoBehaviour
{
	[Tooltip("Background=1000, Geometry=2000, AlphaTest=2450, Transparent=3000, Overlay=4000")]
	public int queue = 2000;

	public int[] queues;

	private void Start()
	{
		Renderer component = GetComponent<Renderer>();
		if ((bool)component && (bool)component.sharedMaterial && queues != null)
		{
			component.sharedMaterial.renderQueue = queue;
			for (int i = 0; i < queues.Length && i < component.sharedMaterials.Length; i++)
			{
				component.sharedMaterials[i].renderQueue = queues[i];
			}
		}
	}

	private void OnValidate()
	{
		Start();
	}

	private void Update()
	{
		if (!Application.isPlaying)
		{
			Start();
		}
	}
}
public class RFX4_OnEnableResetTransform : MonoBehaviour
{
	private Transform t;

	private Vector3 startPosition;

	private Quaternion startRotation;

	private Vector3 startScale;

	private bool isInitialized;

	private void OnEnable()
	{
		if (!isInitialized)
		{
			isInitialized = true;
			t = base.transform;
			startPosition = t.position;
			startRotation = t.rotation;
			startScale = t.localScale;
		}
		else
		{
			t.position = startPosition;
			t.rotation = startRotation;
			t.localScale = startScale;
		}
	}

	private void OnDisable()
	{
		if (!isInitialized)
		{
			isInitialized = true;
			t = base.transform;
			startPosition = t.position;
			startRotation = t.rotation;
			startScale = t.localScale;
		}
		else
		{
			t.position = startPosition;
			t.rotation = startRotation;
			t.localScale = startScale;
		}
	}
}
public class RFX4_ParticleCollisionGameObject : MonoBehaviour
{
	public GameObject InstancedGO;

	public float DestroyDelay = 5f;

	public GameObject RotationParent;

	private List<ParticleCollisionEvent> collisionEvents = new List<ParticleCollisionEvent>();

	private ParticleSystem initiatorPS;

	private void OnEnable()
	{
		collisionEvents.Clear();
		initiatorPS = GetComponent<ParticleSystem>();
	}

	private void OnParticleCollision(GameObject other)
	{
		int num = initiatorPS.GetCollisionEvents(other, collisionEvents);
		for (int i = 0; i < num; i++)
		{
			GameObject obj = ((!(RotationParent != null)) ? UnityEngine.Object.Instantiate(InstancedGO, collisionEvents[i].intersection, default(Quaternion)) : UnityEngine.Object.Instantiate(InstancedGO, collisionEvents[i].intersection, RotationParent.transform.rotation));
			UnityEngine.Object.Destroy(obj, DestroyDelay);
		}
	}
}
[ExecuteInEditMode]
public class RFX4_ParticleGravityPoint : MonoBehaviour
{
	public Transform target;

	public float Force = 1f;

	public float StopDistance = -1f;

	private ParticleSystem ps;

	private ParticleSystem.Particle[] particles;

	private ParticleSystem.MainModule mainModule;

	private void Start()
	{
		ps = GetComponent<ParticleSystem>();
		mainModule = ps.main;
	}

	private void LateUpdate()
	{
		int maxParticles = mainModule.maxParticles;
		if (particles == null || particles.Length < maxParticles)
		{
			particles = new ParticleSystem.Particle[maxParticles];
		}
		int num = ps.GetParticles(particles);
		float num2 = Time.deltaTime * Force;
		Vector3 vector = Vector3.zero;
		if (mainModule.simulationSpace == ParticleSystemSimulationSpace.Local)
		{
			vector = base.transform.InverseTransformPoint(target.position);
		}
		if (mainModule.simulationSpace == ParticleSystemSimulationSpace.World)
		{
			vector = target.position;
		}
		for (int i = 0; i < num; i++)
		{
			Vector3 vector2 = Vector3.Normalize(vector - particles[i].position) * num2;
			if (StopDistance > 0f && (particles[i].position - target.position).magnitude < StopDistance)
			{
				particles[i].velocity = Vector3.zero;
			}
			else
			{
				particles[i].velocity += vector2;
			}
		}
		ps.SetParticles(particles, num);
	}
}
public class RFX4_PhysXSetImpulse : MonoBehaviour
{
	public float Force = 1f;

	public ForceMode ForceMode;

	private Rigidbody rig;

	private Transform t;

	private void Start()
	{
		rig = GetComponent<Rigidbody>();
		t = base.transform;
	}

	private void FixedUpdate()
	{
		if (rig != null)
		{
			rig.AddForce(t.forward * Force, ForceMode);
		}
	}

	private void OnDisable()
	{
		if (rig != null)
		{
			rig.velocity = Vector3.zero;
		}
	}
}
public class RFX4_PhysicsMotion : MonoBehaviour
{
	public class RFX4_CollisionInfo : EventArgs
	{
		public Vector3 HitPoint;

		public Collider HitCollider;

		public GameObject HitGameObject;
	}

	public bool UseCollisionDetect = true;

	public float MaxDistnace = -1f;

	public float Mass = 1f;

	public float Speed = 10f;

	public float RandomSpeedOffset;

	public float AirDrag = 0.1f;

	public bool UseGravity = true;

	public ForceMode ForceMode = ForceMode.Impulse;

	public Vector3 AddRealtimeForce = Vector3.zero;

	public float MinSpeed;

	public float ColliderRadius = 0.05f;

	public bool FreezeRotation;

	public bool UseTargetPositionAfterCollision;

	public GameObject EffectOnCollision;

	public bool CollisionEffectInWorldSpace = true;

	public bool LookAtNormal = true;

	public float CollisionEffectDestroyAfter = 5f;

	public GameObject[] DeactivateObjectsAfterCollision;

	[HideInInspector]
	public float HUE = -1f;

	private Rigidbody rigid;

	private SphereCollider collid;

	private ContactPoint lastContactPoint;

	private Collider lastCollider;

	private Vector3 offsetColliderPoint;

	private bool isCollided;

	private GameObject targetAnchor;

	private bool isInitializedForce;

	private float currentSpeedOffset;

	private RFX4_EffectSettings effectSettings;

	public event EventHandler<RFX4_CollisionInfo> CollisionEnter;

	private void OnEnable()
	{
		effectSettings = GetComponentInParent<RFX4_EffectSettings>();
		GameObject[] deactivateObjectsAfterCollision = DeactivateObjectsAfterCollision;
		foreach (GameObject gameObject in deactivateObjectsAfterCollision)
		{
			if (gameObject != null)
			{
				if (gameObject.GetComponent<ParticleSystem>() != null)
				{
					gameObject.SetActive(value: false);
				}
				gameObject.SetActive(value: true);
			}
		}
		currentSpeedOffset = UnityEngine.Random.Range((0f - RandomSpeedOffset) * 10000f, RandomSpeedOffset * 10000f) / 10000f;
		InitializeRigid();
	}

	private void InitializeRigid()
	{
		if (effectSettings.UseCollisionDetection)
		{
			collid = base.gameObject.AddComponent<SphereCollider>();
			collid.radius = ColliderRadius;
		}
		isInitializedForce = false;
	}

	private void InitializeForce()
	{
		rigid = base.gameObject.AddComponent<Rigidbody>();
		rigid.mass = effectSettings.Mass;
		rigid.drag = effectSettings.AirDrag;
		rigid.useGravity = effectSettings.UseGravity;
		if (FreezeRotation)
		{
			rigid.constraints = RigidbodyConstraints.FreezeRotation;
		}
		rigid.collisionDetectionMode = CollisionDetectionMode.ContinuousDynamic;
		rigid.interpolation = RigidbodyInterpolation.Interpolate;
		rigid.AddForce(base.transform.forward * (effectSettings.Speed + currentSpeedOffset), ForceMode);
		isInitializedForce = true;
	}

	private void OnCollisionEnter(Collision collision)
	{
		if (isCollided && !effectSettings.UseCollisionDetection)
		{
			return;
		}
		ContactPoint[] contacts = collision.contacts;
		for (int i = 0; i < contacts.Length; i++)
		{
			ContactPoint contactPoint = contacts[i];
			if (!isCollided)
			{
				isCollided = true;
				if (UseTargetPositionAfterCollision)
				{
					if (targetAnchor != null)
					{
						UnityEngine.Object.Destroy(targetAnchor);
					}
					targetAnchor = new GameObject();
					targetAnchor.hideFlags = HideFlags.HideAndDontSave;
					targetAnchor.transform.parent = contactPoint.otherCollider.transform;
					targetAnchor.transform.position = contactPoint.point;
					targetAnchor.transform.rotation = base.transform.rotation;
				}
			}
			this.CollisionEnter?.Invoke(this, new RFX4_CollisionInfo
			{
				HitPoint = contactPoint.point,
				HitCollider = contactPoint.otherCollider,
				HitGameObject = contactPoint.otherCollider.gameObject
			});
			if (EffectOnCollision != null)
			{
				GameObject gameObject = UnityEngine.Object.Instantiate(EffectOnCollision, contactPoint.point, default(Quaternion));
				if (HUE > -0.9f)
				{
					RFX4_ColorHelper.ChangeObjectColorByHUE(gameObject, HUE);
				}
				if (LookAtNormal)
				{
					gameObject.transform.LookAt(contactPoint.point + contactPoint.normal);
				}
				else
				{
					gameObject.transform.rotation = base.transform.rotation;
				}
				if (!CollisionEffectInWorldSpace)
				{
					gameObject.transform.parent = contactPoint.otherCollider.transform.parent;
				}
				UnityEngine.Object.Destroy(gameObject, CollisionEffectDestroyAfter);
			}
		}
		GameObject[] deactivateObjectsAfterCollision = DeactivateObjectsAfterCollision;
		foreach (GameObject gameObject2 in deactivateObjectsAfterCollision)
		{
			if (gameObject2 != null)
			{
				ParticleSystem component = gameObject2.GetComponent<ParticleSystem>();
				if (component != null)
				{
					component.Stop();
				}
				else
				{
					gameObject2.SetActive(value: false);
				}
			}
		}
		if (rigid != null)
		{
			UnityEngine.Object.Destroy(rigid);
		}
		if (collid != null)
		{
			UnityEngine.Object.Destroy(collid);
		}
	}

	private void FixedUpdate()
	{
		if (!isInitializedForce)
		{
			InitializeForce();
		}
		if (rigid != null && AddRealtimeForce.magnitude > 0.001f)
		{
			rigid.AddForce(AddRealtimeForce);
		}
		if (rigid != null && MinSpeed > 0.001f)
		{
			rigid.AddForce(base.transform.forward * MinSpeed);
		}
		if (rigid != null && effectSettings.MaxDistnace > 0f && base.transform.localPosition.magnitude > effectSettings.MaxDistnace)
		{
			RemoveRigidbody();
		}
		if (UseTargetPositionAfterCollision && isCollided && targetAnchor != null)
		{
			base.transform.position = targetAnchor.transform.position;
			base.transform.rotation = targetAnchor.transform.rotation;
		}
	}

	private void OnDisable()
	{
		base.transform.localPosition = Vector3.zero;
		base.transform.localRotation = default(Quaternion);
		RemoveRigidbody();
	}

	private void RemoveRigidbody()
	{
		isCollided = false;
		if (rigid != null)
		{
			UnityEngine.Object.Destroy(rigid);
		}
		if (collid != null)
		{
			UnityEngine.Object.Destroy(collid);
		}
	}

	private void OnDrawGizmosSelected()
	{
		if (!Application.isPlaying)
		{
			Transform transform = base.transform;
			Gizmos.color = Color.green;
			Gizmos.DrawWireSphere(transform.position, ColliderRadius);
			Gizmos.color = Color.blue;
			Gizmos.DrawLine(transform.position, transform.position + transform.forward * 100f);
		}
	}
}
public class RFX4_RaycastCollision : MonoBehaviour
{
	public float RaycastDistance = 100f;

	public GameObject[] Effects;

	public float Offset;

	public float EnableTimeDelay;

	public float DestroyTime = 3f;

	public bool UsePivotPosition;

	public bool UseNormalRotation = true;

	public bool IsWorldSpace = true;

	public bool RealTimeUpdateRaycast;

	public bool DestroyAfterDisabling;

	[HideInInspector]
	public float HUE = -1f;

	[HideInInspector]
	public List<GameObject> CollidedInstances = new List<GameObject>();

	private const string particlesAdditionalName = "Distance";

	private ParticleSystem[] distanceParticles;

	private bool canUpdate;

	public event EventHandler<RFX4_PhysicsMotion.RFX4_CollisionInfo> CollisionEnter;

	private void Awake()
	{
		distanceParticles = base.transform.root.GetComponentsInChildren<ParticleSystem>();
	}

	private void OnEnable()
	{
		CollidedInstances.Clear();
		if ((double)EnableTimeDelay > 0.001)
		{
			Invoke("UpdateRaycast", EnableTimeDelay);
		}
		else
		{
			UpdateRaycast();
		}
	}

	private void OnDisable()
	{
		if (!DestroyAfterDisabling)
		{
			return;
		}
		foreach (GameObject collidedInstance in CollidedInstances)
		{
			UnityEngine.Object.Destroy(collidedInstance);
		}
	}

	private void Update()
	{
		if (canUpdate)
		{
			UpdateRaycast();
		}
	}

	private void UpdateRaycast()
	{
		if (Physics.Raycast(base.transform.position, base.transform.forward, out var hitInfo, RaycastDistance))
		{
			Vector3 position = ((!UsePivotPosition) ? (hitInfo.point + hitInfo.normal * Offset) : hitInfo.transform.position);
			this.CollisionEnter?.Invoke(this, new RFX4_PhysicsMotion.RFX4_CollisionInfo
			{
				HitPoint = hitInfo.point,
				HitCollider = hitInfo.collider,
				HitGameObject = hitInfo.transform.gameObject
			});
			if (distanceParticles != null)
			{
				ParticleSystem[] array = distanceParticles;
				foreach (ParticleSystem particleSystem in array)
				{
					if (particleSystem != null && particleSystem.name.Contains("Distance"))
					{
						particleSystem.GetComponent<ParticleSystemRenderer>().lengthScale = (base.transform.position - hitInfo.point).magnitude / particleSystem.main.startSize.constantMax;
					}
				}
			}
			if (CollidedInstances.Count == 0)
			{
				GameObject[] effects = Effects;
				foreach (GameObject gameObject in effects)
				{
					if (gameObject != null)
					{
						GameObject gameObject2 = UnityEngine.Object.Instantiate(gameObject, position, default(Quaternion));
						RFX4_EffectSettings component = gameObject2.GetComponent<RFX4_EffectSettings>();
						RFX4_EffectSettings componentInParent = GetComponentInParent<RFX4_EffectSettings>();
						if (component != null)
						{
							_ = componentInParent != null;
						}
						CollidedInstances.Add(gameObject2);
						if (HUE > -0.9f)
						{
							RFX4_ColorHelper.ChangeObjectColorByHUE(gameObject2, HUE);
						}
						if (!IsWorldSpace)
						{
							gameObject2.transform.parent = base.transform;
						}
						if (UseNormalRotation)
						{
							gameObject2.transform.LookAt(hitInfo.point + hitInfo.normal);
						}
						if (DestroyTime > 0.0001f)
						{
							UnityEngine.Object.Destroy(gameObject2, DestroyTime);
						}
					}
				}
			}
			else
			{
				foreach (GameObject collidedInstance in CollidedInstances)
				{
					if (!(collidedInstance == null))
					{
						collidedInstance.transform.position = position;
						if (UseNormalRotation)
						{
							collidedInstance.transform.LookAt(hitInfo.point + hitInfo.normal);
						}
					}
				}
			}
		}
		if (RealTimeUpdateRaycast)
		{
			canUpdate = true;
		}
	}

	private void OnDrawGizmosSelected()
	{
		Gizmos.color = Color.blue;
		Gizmos.DrawLine(base.transform.position, base.transform.position + base.transform.forward * RaycastDistance);
	}
}
public class RFX4_ReplaceModelOnCollision : MonoBehaviour
{
	public GameObject[] PhysicsObjects;

	private bool isCollided;

	private Transform t;

	private void OnCollisionEnter(Collision collision)
	{
		if (!isCollided)
		{
			isCollided = true;
			GameObject[] physicsObjects = PhysicsObjects;
			for (int i = 0; i < physicsObjects.Length; i++)
			{
				physicsObjects[i].SetActive(value: true);
			}
			MeshRenderer component = GetComponent<MeshRenderer>();
			if (component != null)
			{
				component.enabled = false;
			}
			Rigidbody component2 = GetComponent<Rigidbody>();
			component2.isKinematic = true;
			component2.detectCollisions = false;
		}
	}

	private void OnEnable()
	{
		isCollided = false;
		GameObject[] physicsObjects = PhysicsObjects;
		for (int i = 0; i < physicsObjects.Length; i++)
		{
			physicsObjects[i].SetActive(value: false);
		}
		MeshRenderer component = GetComponent<MeshRenderer>();
		if (component != null)
		{
			component.enabled = true;
		}
		Rigidbody component2 = GetComponent<Rigidbody>();
		component2.isKinematic = false;
		component2.detectCollisions = true;
	}
}
public class RFX4_RotateAround : MonoBehaviour
{
	public Vector3 Offset = Vector3.forward;

	public Vector3 RotateVector = Vector3.forward;

	public float LifeTime = 1f;

	private Transform t;

	private float currentTime;

	private Quaternion rotation;

	private void Start()
	{
		t = base.transform;
		rotation = t.rotation;
	}

	private void OnEnable()
	{
		currentTime = 0f;
		if (t != null)
		{
			t.rotation = rotation;
		}
	}

	private void Update()
	{
		if (!(currentTime >= LifeTime) || !(LifeTime > 0.0001f))
		{
			currentTime += Time.deltaTime;
			t.Rotate(RotateVector * Time.deltaTime);
		}
	}
}
public class RFX4_StartDelay : MonoBehaviour
{
	public GameObject ActivatedGameObject;

	public float Delay = 1f;

	private float currentTime;

	private bool isEnabled;

	private void OnEnable()
	{
		ActivatedGameObject.SetActive(value: false);
		isEnabled = false;
		currentTime = 0f;
	}

	private void Update()
	{
		currentTime += Time.deltaTime;
		if (!isEnabled && currentTime >= Delay)
		{
			isEnabled = true;
			ActivatedGameObject.SetActive(value: true);
		}
	}
}
public enum RFX4_TextureShaderProperties
{
	_MainTex,
	_DistortTex,
	_Mask,
	_Cutout,
	_CutoutTex,
	_Bump,
	_BumpTex,
	_EmissionTex
}
public class RFX4_TornadoParticles : MonoBehaviour
{
	public Material TornadoMaterial;

	private ParticleSystem.Particle[] particleArray;

	private ParticleSystem particleSys;

	private Light myLight;

	private Vector4 _twistScale;

	private int materialID = -1;

	private void Start()
	{
		particleSys = GetComponent<ParticleSystem>();
		myLight = GetComponent<Light>();
		if (particleSys != null)
		{
			particleArray = new ParticleSystem.Particle[particleSys.main.maxParticles];
		}
		if (TornadoMaterial.HasProperty("_TwistScale"))
		{
			materialID = Shader.PropertyToID("_TwistScale");
		}
		else
		{
			UnityEngine.Debug.Log(TornadoMaterial.name + " not have property twist");
		}
		if (materialID != -1)
		{
			_twistScale = TornadoMaterial.GetVector(materialID);
		}
	}

	private void Update()
	{
		if (materialID != -1)
		{
			_twistScale = TornadoMaterial.GetVector(materialID);
		}
		if (particleSys != null)
		{
			int particles = particleSys.GetParticles(particleArray);
			for (int i = 0; i < particles; i++)
			{
				Vector3 position = particleArray[i].position;
				float num = position.y * _twistScale.y;
				position.x = Mathf.Sin(Time.time * _twistScale.z + position.y * _twistScale.x) * num;
				position.z = Mathf.Sin(Time.time * _twistScale.z + position.y * _twistScale.x + 1.57075f) * num;
				particleArray[i].position = position;
				particleSys.SetParticles(particleArray, particles);
			}
		}
		if (myLight != null)
		{
			Vector3 localPosition = base.transform.localPosition;
			float num2 = localPosition.y * _twistScale.y;
			localPosition.x = Mathf.Sin(Time.time * _twistScale.z + localPosition.y * _twistScale.x) * num2;
			localPosition.z = Mathf.Sin(Time.time * _twistScale.z + localPosition.y * _twistScale.x + 1.57075f) * num2;
			base.transform.localPosition = localPosition;
		}
	}
}
[RequireComponent(typeof(LineRenderer))]
public class RFX4_TrailRenderer : MonoBehaviour
{
	public float VertexLifeTime = 2f;

	public float TrailLifeTime = 2f;

	[Range(0.001f, 1f)]
	public float MinVertexDistance = 0.01f;

	public float Gravity = 0.01f;

	public Vector3 Force = new Vector3(0f, 0f, 0f);

	public float InheritVelocity;

	public float Drag = 0.01f;

	[Range(0.001f, 10f)]
	public float Frequency = 1f;

	[Range(0.001f, 10f)]
	public float OffsetSpeed = 0.5f;

	public bool RandomTurbulenceOffset;

	[Range(0.001f, 10f)]
	public float Amplitude = 2f;

	public float TurbulenceStrength = 0.1f;

	public AnimationCurve VelocityByDistance = AnimationCurve.EaseInOut(0f, 1f, 1f, 1f);

	public float AproximatedFlyDistance = -1f;

	public bool SmoothCurves;

	private LineRenderer lineRenderer;

	private List<Vector3> positions;

	private List<float> currentTimes;

	private List<Vector3> velocities;

	[HideInInspector]
	public float currentLifeTime;

	private Transform t;

	private Vector3 prevPosition;

	private Vector3 startPosition;

	private List<Vector3> controlPoints = new List<Vector3>();

	private int curveCount;

	private const float MinimumSqrDistance = 0.01f;

	private const float DivisionThreshold = -0.99f;

	private const float SmoothCurvesScale = 0.5f;

	private float currentVelocity;

	private float turbulenceRandomOffset;

	private bool isInitialized;

	private void Start()
	{
		Init();
		isInitialized = true;
	}

	private void OnEnable()
	{
		if (isInitialized)
		{
			Init();
		}
	}

	private void Init()
	{
		positions = new List<Vector3>();
		currentTimes = new List<float>();
		velocities = new List<Vector3>();
		currentLifeTime = 0f;
		curveCount = 0;
		currentVelocity = 0f;
		t = base.transform;
		prevPosition = t.position;
		startPosition = t.position;
		lineRenderer = GetComponent<LineRenderer>();
		lineRenderer.positionCount = 0;
		positions.Add(t.position);
		currentTimes.Add(currentLifeTime);
		velocities.Add(Vector3.zero);
		turbulenceRandomOffset = (RandomTurbulenceOffset ? (UnityEngine.Random.Range(0f, 10000f) / 1000f) : 0f);
	}

	private void Update()
	{
		if (!((double)Time.timeScale < 0.001))
		{
			UpdatePositionsCount();
			UpdateForce();
			UpdateImpulse();
			UpdateVelocity();
			int lastDeletedIndex = GetLastDeletedIndex();
			RemovePositionsBeforeIndex(lastDeletedIndex);
			if (SmoothCurves && positions.Count > 2)
			{
				InterpolateBezier(positions, 0.5f);
				List<Vector3> drawingPoints = GetDrawingPoints();
				lineRenderer.positionCount = drawingPoints.Count;
				lineRenderer.SetPositions(drawingPoints.ToArray());
			}
			else
			{
				lineRenderer.positionCount = positions.Count;
				lineRenderer.SetPositions(positions.ToArray());
			}
		}
	}

	private int GetLastDeletedIndex()
	{
		int result = -1;
		int count = currentTimes.Count;
		for (int i = 1; i < count; i++)
		{
			currentTimes[i] -= Time.deltaTime;
			if (currentTimes[i] <= 0f)
			{
				result = i;
			}
		}
		return result;
	}

	private void UpdatePositionsCount()
	{
		if (!(TrailLifeTime > 0.0001f) || !(currentLifeTime > TrailLifeTime))
		{
			currentLifeTime += Time.deltaTime;
			Vector3 vector = ((positions.Count != 0) ? positions[positions.Count - 1] : Vector3.zero);
			if (Mathf.Abs((t.position - vector).magnitude) > MinVertexDistance && positions.Count > 0)
			{
				AddInterpolatedPositions(vector, t.position);
			}
		}
	}

	private void AddInterpolatedPositions(Vector3 start, Vector3 end)
	{
		int num = (int)((start - end).magnitude / MinVertexDistance);
		float num2 = currentTimes.LastOrDefault();
		Vector3 zero = Vector3.zero;
		for (int i = 1; i <= num - 1; i++)
		{
			Vector3 item = start + (end - start) * i * 1f / num;
			float item2 = num2 + (VertexLifeTime - num2) * (float)i * 1f / (float)num;
			positions.Add(item);
			currentTimes.Add(item2);
			velocities.Add(zero);
		}
	}

	private void RemovePositionsBeforeIndex(int lastDeletedIndex)
	{
		if (lastDeletedIndex != -1)
		{
			if (positions.Count - lastDeletedIndex == 1)
			{
				positions.Clear();
				currentTimes.Clear();
				velocities.Clear();
			}
			else
			{
				positions.RemoveRange(0, lastDeletedIndex);
				currentTimes.RemoveRange(0, lastDeletedIndex);
				velocities.RemoveRange(0, lastDeletedIndex);
			}
		}
	}

	private void UpdateForce()
	{
		if (positions.Count < 1)
		{
			return;
		}
		Vector3 vector = Gravity * Vector3.down * Time.deltaTime;
		Vector3 vector2 = t.rotation * Force * Time.deltaTime;
		for (int i = 0; i < positions.Count; i++)
		{
			Vector3 zero = Vector3.zero;
			if (TurbulenceStrength > 1E-06f)
			{
				Vector3 vector3 = positions[i] / Frequency;
				float num = (Time.time + turbulenceRandomOffset) * OffsetSpeed;
				vector3 -= num * Vector3.one;
				zero.x += (Mathf.PerlinNoise(vector3.z, vector3.y) * 2f - 1f) * Amplitude * Time.deltaTime * TurbulenceStrength / 10f;
				zero.y += (Mathf.PerlinNoise(vector3.x, vector3.z) * 2f - 1f) * Amplitude * Time.deltaTime * TurbulenceStrength / 10f;
				zero.z += (Mathf.PerlinNoise(vector3.y, vector3.x) * 2f - 1f) * Amplitude * Time.deltaTime * TurbulenceStrength / 10f;
			}
			Vector3 vector4 = vector + vector2 + zero;
			if (AproximatedFlyDistance > 0.01f)
			{
				float num2 = Mathf.Abs((positions[i] - startPosition).magnitude);
				vector4 *= VelocityByDistance.Evaluate(Mathf.Clamp01(num2 / AproximatedFlyDistance));
			}
			velocities[i] += vector4;
		}
	}

	private void UpdateImpulse()
	{
		if (velocities.Count != 0)
		{
			currentVelocity = (t.position - prevPosition).magnitude / Time.deltaTime;
			Vector3 normalized = (t.position - prevPosition).normalized;
			prevPosition = t.position;
			velocities[velocities.Count - 1] += currentVelocity * InheritVelocity * normalized * Time.deltaTime;
		}
	}

	private void UpdateVelocity()
	{
		if (velocities.Count == 0)
		{
			return;
		}
		int count = positions.Count;
		for (int i = 0; i < count; i++)
		{
			if (Drag > 1E-05f)
			{
				velocities[i] -= Drag * velocities[i] * Time.deltaTime;
			}
			if (velocities[i].magnitude < 1E-05f)
			{
				velocities[i] = Vector3.zero;
			}
			positions[i] += velocities[i] * Time.deltaTime;
		}
	}

	public void InterpolateBezier(List<Vector3> segmentPoints, float scale)
	{
		controlPoints.Clear();
		if (segmentPoints.Count < 2)
		{
			return;
		}
		for (int i = 0; i < segmentPoints.Count; i++)
		{
			if (i == 0)
			{
				Vector3 vector = segmentPoints[i];
				Vector3 vector2 = segmentPoints[i + 1] - vector;
				Vector3 item = vector + scale * vector2;
				controlPoints.Add(vector);
				controlPoints.Add(item);
			}
			else if (i == segmentPoints.Count - 1)
			{
				Vector3 vector3 = segmentPoints[i - 1];
				Vector3 vector4 = segmentPoints[i];
				Vector3 vector5 = vector4 - vector3;
				Vector3 item2 = vector4 - scale * vector5;
				controlPoints.Add(item2);
				controlPoints.Add(vector4);
			}
			else
			{
				Vector3 vector6 = segmentPoints[i - 1];
				Vector3 vector7 = segmentPoints[i];
				Vector3 vector8 = segmentPoints[i + 1];
				Vector3 normalized = (vector8 - vector6).normalized;
				Vector3 item3 = vector7 - scale * normalized * (vector7 - vector6).magnitude;
				Vector3 item4 = vector7 + scale * normalized * (vector8 - vector7).magnitude;
				controlPoints.Add(item3);
				controlPoints.Add(vector7);
				controlPoints.Add(item4);
			}
		}
		curveCount = (controlPoints.Count - 1) / 3;
	}

	public List<Vector3> GetDrawingPoints()
	{
		List<Vector3> list = new List<Vector3>();
		for (int i = 0; i < curveCount; i++)
		{
			List<Vector3> list2 = FindDrawingPoints(i);
			if (i != 0)
			{
				list2.RemoveAt(0);
			}
			list.AddRange(list2);
		}
		return list;
	}

	private List<Vector3> FindDrawingPoints(int curveIndex)
	{
		List<Vector3> list = new List<Vector3>();
		Vector3 item = CalculateBezierPoint(curveIndex, 0f);
		Vector3 item2 = CalculateBezierPoint(curveIndex, 1f);
		list.Add(item);
		list.Add(item2);
		FindDrawingPoints(curveIndex, 0f, 1f, list, 1);
		return list;
	}

	private int FindDrawingPoints(int curveIndex, float t0, float t1, List<Vector3> pointList, int insertionIndex)
	{
		Vector3 vector = CalculateBezierPoint(curveIndex, t0);
		Vector3 vector2 = CalculateBezierPoint(curveIndex, t1);
		if ((vector - vector2).sqrMagnitude < 0.01f)
		{
			return 0;
		}
		float num = (t0 + t1) / 2f;
		Vector3 vector3 = CalculateBezierPoint(curveIndex, num);
		Vector3 normalized = (vector - vector3).normalized;
		Vector3 normalized2 = (vector2 - vector3).normalized;
		if (Vector3.Dot(normalized, normalized2) > -0.99f || Mathf.Abs(num - 0.5f) < 0.0001f)
		{
			int num2 = 0;
			num2 += FindDrawingPoints(curveIndex, t0, num, pointList, insertionIndex);
			pointList.Insert(insertionIndex + num2, vector3);
			num2++;
			return num2 + FindDrawingPoints(curveIndex, num, t1, pointList, insertionIndex + num2);
		}
		return 0;
	}

	public Vector3 CalculateBezierPoint(int curveIndex, float t)
	{
		int num = curveIndex * 3;
		Vector3 p = controlPoints[num];
		Vector3 p2 = controlPoints[num + 1];
		Vector3 p3 = controlPoints[num + 2];
		Vector3 p4 = controlPoints[num + 3];
		return CalculateBezierPoint(t, p, p2, p3, p4);
	}

	private Vector3 CalculateBezierPoint(float t, Vector3 p0, Vector3 p1, Vector3 p2, Vector3 p3)
	{
		float num = 1f - t;
		float num2 = t * t;
		float num3 = num * num;
		float num4 = num3 * num;
		float num5 = num2 * t;
		return num4 * p0 + 3f * num3 * t * p1 + 3f * num * num2 * p2 + num5 * p3;
	}
}
[ExecuteInEditMode]
public class RFX4_UVAnimation : MonoBehaviour
{
	public int TilesX = 4;

	public int TilesY = 4;

	[Range(1f, 360f)]
	public int FPS = 32;

	public int StartFrameOffset;

	public bool IsLoop = true;

	public bool IsReverse;

	public bool IsInterpolateFrames = true;

	public RFX4_TextureShaderProperties[] TextureNames = new RFX4_TextureShaderProperties[1];

	private int count;

	private Renderer currentRenderer;

	private Projector projector;

	private Material instanceMaterial;

	private float animationStartTime;

	private bool canUpdate;

	private int previousIndex;

	private int totalFrames;

	private float currentInterpolatedTime;

	private int currentIndex;

	private Vector2 size;

	private bool isInitialized;

	private float prevRealTime;

	private void OnEnable()
	{
		if (isInitialized)
		{
			InitDefaultVariables();
		}
	}

	private void Start()
	{
		InitDefaultVariables();
		isInitialized = true;
	}

	private void OnWillRenderObject()
	{
		if (!Application.isPlaying)
		{
			ManualUpdate();
		}
	}

	private void Update()
	{
		if (Application.isPlaying)
		{
			ManualUpdate();
		}
	}

	private void InitDefaultVariables()
	{
		currentRenderer = GetComponent<Renderer>();
		UpdateMaterial();
		totalFrames = TilesX * TilesY;
		previousIndex = 0;
		canUpdate = true;
		count = TilesY * TilesX;
		Vector3 zero = Vector3.zero;
		StartFrameOffset -= StartFrameOffset / count * count;
		size = new Vector2(1f / (float)TilesX, 1f / (float)TilesY);
		animationStartTime = (Application.isPlaying ? Time.time : Time.realtimeSinceStartup);
		if (instanceMaterial != null)
		{
			RFX4_TextureShaderProperties[] textureNames = TextureNames;
			for (int i = 0; i < textureNames.Length; i++)
			{
				RFX4_TextureShaderProperties rFX4_TextureShaderProperties = textureNames[i];
				instanceMaterial.SetTextureScale(rFX4_TextureShaderProperties.ToString(), size);
				instanceMaterial.SetTextureOffset(rFX4_TextureShaderProperties.ToString(), zero);
			}
		}
	}

	private void ManualUpdate()
	{
		if (canUpdate)
		{
			UpdateMaterial();
			SetSpriteAnimation();
			if (IsInterpolateFrames)
			{
				SetSpriteAnimationIterpolated();
			}
		}
	}

	private void UpdateMaterial()
	{
		if (!(currentRenderer == null))
		{
			if (Application.isPlaying)
			{
				instanceMaterial = currentRenderer.material;
			}
			instanceMaterial = currentRenderer.sharedMaterial;
			if (IsInterpolateFrames)
			{
				instanceMaterial.EnableKeyword("USE_SCRIPT_FRAMEBLENDING");
			}
			else
			{
				instanceMaterial.DisableKeyword("USE_SCRIPT_FRAMEBLENDING");
			}
		}
	}

	private void SetSpriteAnimation()
	{
		int num = (int)(((Application.isPlaying ? Time.time : Time.realtimeSinceStartup) - animationStartTime) * (float)FPS);
		num %= totalFrames;
		if (!IsLoop && num < previousIndex)
		{
			canUpdate = false;
			return;
		}
		if (IsInterpolateFrames && num != previousIndex)
		{
			currentInterpolatedTime = 0f;
		}
		previousIndex = num;
		if (IsReverse)
		{
			num = totalFrames - num - 1;
		}
		int num2 = num % TilesX;
		int num3 = num / TilesX;
		float x = (float)num2 * size.x;
		float y = 1f - size.y - (float)num3 * size.y;
		Vector2 value = new Vector2(x, y);
		if (instanceMaterial != null)
		{
			RFX4_TextureShaderProperties[] textureNames = TextureNames;
			for (int i = 0; i < textureNames.Length; i++)
			{
				RFX4_TextureShaderProperties rFX4_TextureShaderProperties = textureNames[i];
				instanceMaterial.SetTextureScale(rFX4_TextureShaderProperties.ToString(), size);
				instanceMaterial.SetTextureOffset(rFX4_TextureShaderProperties.ToString(), value);
			}
		}
	}

	public float DeltaTime()
	{
		if (Application.isPlaying)
		{
			return Time.deltaTime;
		}
		float result = Time.realtimeSinceStartup - prevRealTime;
		prevRealTime = Time.realtimeSinceStartup;
		return result;
	}

	private void SetSpriteAnimationIterpolated()
	{
		currentInterpolatedTime += DeltaTime();
		int num = previousIndex + 1;
		if (num == totalFrames)
		{
			num = previousIndex;
		}
		if (IsReverse)
		{
			num = totalFrames - num - 1;
		}
		int num2 = num % TilesX;
		int num3 = num / TilesX;
		float x = (float)num2 * size.x;
		float y = 1f - size.y - (float)num3 * size.y;
		Vector2 vector = new Vector2(x, y);
		if (instanceMaterial != null)
		{
			instanceMaterial.SetVector("_MainTex_NextFrame", new Vector4(size.x, size.y, vector.x, vector.y));
			instanceMaterial.SetFloat("InterpolationValue", Mathf.Clamp01(currentInterpolatedTime * (float)FPS));
		}
	}
}
public class RFX4_UVScroll : MonoBehaviour
{
	public Vector2 UvScrollMultiplier = new Vector2(1f, 0f);

	public RFX4_TextureShaderProperties TextureName;

	private Vector2 uvOffset = Vector2.zero;

	private Material mat;

	private void Start()
	{
		Renderer component = GetComponent<Renderer>();
		if (component == null)
		{
			Projector component2 = GetComponent<Projector>();
			if (component2 != null)
			{
				if (!component2.material.name.EndsWith("(Instance)"))
				{
					component2.material = new Material(component2.material)
					{
						name = component2.material.name + " (Instance)"
					};
				}
				mat = component2.material;
			}
		}
		else
		{
			mat = component.material;
		}
	}

	private void Update()
	{
		uvOffset += UvScrollMultiplier * Time.deltaTime;
		if (mat != null)
		{
			mat.SetTextureOffset(TextureName.ToString(), uvOffset);
		}
	}
}
public class RFX4_MobileDistortion : MonoBehaviour
{
	public bool IsActive = true;

	private CommandBuffer buf;

	private Camera cam;

	private bool bufferIsAdded;

	private void Awake()
	{
		cam = GetComponent<Camera>();
		CreateBuffer();
	}

	private void CreateBuffer()
	{
		_ = Camera.main;
		buf = new CommandBuffer();
		buf.name = "_GrabOpaqueColor";
		int num = Shader.PropertyToID("_ScreenCopyOpaqueColor");
		int num2 = -1;
		RenderTextureFormat format = (SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.RGB565) ? RenderTextureFormat.RGB565 : RenderTextureFormat.Default);
		buf.GetTemporaryRT(num, num2, num2, 0, FilterMode.Bilinear, format);
		buf.Blit(BuiltinRenderTextureType.CurrentActive, num);
		buf.SetGlobalTexture("_GrabTexture", num);
		buf.SetGlobalTexture("_GrabTextureMobile", num);
	}

	private void OnEnable()
	{
		AddBuffer();
	}

	private void OnDisable()
	{
		RemoveBuffer();
	}

	private void AddBuffer()
	{
		cam.AddCommandBuffer(CameraEvent.BeforeForwardAlpha, buf);
		bufferIsAdded = true;
	}

	private void RemoveBuffer()
	{
		cam.RemoveCommandBuffer(CameraEvent.BeforeForwardAlpha, buf);
		bufferIsAdded = false;
	}

	private void Update()
	{
		if (IsActive)
		{
			if (!bufferIsAdded)
			{
				AddBuffer();
			}
		}
		else if (bufferIsAdded)
		{
			RemoveBuffer();
		}
	}

	private bool IsSupportedHdr()
	{
		return Camera.main.allowHDR;
	}
}
public class RFX4_PerPlatformSettings : MonoBehaviour
{
	public bool DisableOnMobiles;

	public bool RenderMobileDistortion;

	[Range(0.1f, 1f)]
	public float ParticleBudgetForMobiles = 0.5f;

	private bool isMobile;

	private void Awake()
	{
		isMobile = IsMobilePlatform();
		if (isMobile)
		{
			if (DisableOnMobiles)
			{
				base.gameObject.SetActive(value: false);
			}
			else if (ParticleBudgetForMobiles < 0.99f)
			{
				ChangeParticlesBudget(ParticleBudgetForMobiles);
			}
		}
	}

	private void OnEnable()
	{
		Camera main = Camera.main;
		Legacy_Rendering_Check(main);
	}

	private void Update()
	{
		Camera main = Camera.main;
		Legacy_Rendering_Check(main);
	}

	private void Legacy_Rendering_Check(Camera cam)
	{
		if (!(cam == null) && RenderMobileDistortion && !DisableOnMobiles && isMobile)
		{
			RFX4_MobileDistortion rFX4_MobileDistortion = cam.GetComponent<RFX4_MobileDistortion>();
			if (rFX4_MobileDistortion == null)
			{
				rFX4_MobileDistortion = cam.gameObject.AddComponent<RFX4_MobileDistortion>();
			}
			rFX4_MobileDistortion.IsActive = true;
		}
	}

	private void OnDisable()
	{
		Camera main = Camera.main;
		if (!(main == null) && RenderMobileDistortion && !DisableOnMobiles && isMobile)
		{
			RFX4_MobileDistortion component = main.GetComponent<RFX4_MobileDistortion>();
			if (component != null)
			{
				component.IsActive = false;
			}
		}
	}

	private bool IsMobilePlatform()
	{
		bool result = false;
		if (Application.isMobilePlatform)
		{
			result = true;
		}
		return result;
	}

	private void ChangeParticlesBudget(float particlesMul)
	{
		ParticleSystem component = GetComponent<ParticleSystem>();
		if (component == null)
		{
			return;
		}
		ParticleSystem.MainModule main = component.main;
		main.maxParticles = Mathf.Max(1, (int)((float)main.maxParticles * particlesMul));
		ParticleSystem.EmissionModule emission = component.emission;
		if (!emission.enabled)
		{
			return;
		}
		ParticleSystem.MinMaxCurve rateOverTime = emission.rateOverTime;
		if (rateOverTime.constantMin > 1f)
		{
			rateOverTime.constantMin *= particlesMul;
		}
		if (rateOverTime.constantMax > 1f)
		{
			rateOverTime.constantMax *= particlesMul;
		}
		emission.rateOverTime = rateOverTime;
		ParticleSystem.MinMaxCurve rateOverDistance = emission.rateOverDistance;
		if (rateOverDistance.constantMin > 1f)
		{
			if (rateOverDistance.constantMin > 1f)
			{
				rateOverDistance.constantMin *= particlesMul;
			}
			if (rateOverDistance.constantMax > 1f)
			{
				rateOverDistance.constantMax *= particlesMul;
			}
			emission.rateOverDistance = rateOverDistance;
		}
		ParticleSystem.Burst[] array = new ParticleSystem.Burst[emission.burstCount];
		emission.GetBursts(array);
		for (int i = 0; i < array.Length; i++)
		{
			if (array[i].minCount > 1)
			{
				array[i].minCount = (short)((float)array[i].minCount * particlesMul);
			}
			if (array[i].maxCount > 1)
			{
				array[i].maxCount = (short)((float)array[i].maxCount * particlesMul);
			}
		}
		emission.SetBursts(array);
	}
}
public class FPS : MonoBehaviour
{
	public float UpdateInterval = 1f;

	private Text text;

	private int frames;

	private void Start()
	{
		Application.targetFrameRate = 1000;
		text = GetComponent<Text>();
		InvokeRepeating("UpdateFPS", UpdateInterval, UpdateInterval);
	}

	private void UpdateFPS()
	{
		if (frames < 30)
		{
			text.color = Color.red;
		}
		if (frames >= 30 && frames <= 50)
		{
			text.color = Color.yellow;
		}
		else
		{
			text.color = Color.green;
		}
		text.text = "FPS: " + frames;
		frames = 0;
	}

	private void Update()
	{
		frames++;
	}
}
public class RFX4_Debug : MonoBehaviour
{
	private void Start()
	{
		RFX4_PhysicsMotion componentInChildren = GetComponentInChildren<RFX4_PhysicsMotion>(includeInactive: true);
		if (componentInChildren != null)
		{
			componentInChildren.CollisionEnter += CollisionEnter;
		}
		RFX4_RaycastCollision componentInChildren2 = GetComponentInChildren<RFX4_RaycastCollision>(includeInactive: true);
		if (componentInChildren2 != null)
		{
			componentInChildren2.CollisionEnter += CollisionEnter;
		}
	}

	private void CollisionEnter(object sender, RFX4_PhysicsMotion.RFX4_CollisionInfo e)
	{
		UnityEngine.Debug.Log(e.HitPoint);
		UnityEngine.Debug.Log(e.HitGameObject.name);
		UnityEngine.Debug.Log(e.HitCollider.name);
	}
}
public class RFX4_DemoGUI : MonoBehaviour
{
	public GameObject[] Prefabs;

	public float[] ReactivationTimes;

	public Light Sun;

	public ReflectionProbe ReflectionProbe;

	public Light[] NightLights = new Light[0];

	public Texture HUETexture;

	public bool isDay;

	private int currentNomber;

	private GameObject currentInstance;

	public GUIStyle guiStyleHeader = new GUIStyle();

	private GUIStyle guiStyleHeaderMobile = new GUIStyle();

	private float dpiScale;

	private float colorHUE;

	private float startSunIntensity;

	private Quaternion startSunRotation;

	private Color startAmbientLight;

	private float startAmbientIntencity;

	private float startReflectionIntencity;

	private LightShadows startLightShadows;

	private bool isButtonPressed;

	private void Start()
	{
		if (Screen.dpi < 1f)
		{
			dpiScale = 1f;
		}
		if (Screen.dpi < 200f)
		{
			dpiScale = 1f;
		}
		else
		{
			dpiScale = Screen.dpi / 200f;
		}
		guiStyleHeader.fontSize = (int)(15f * dpiScale);
		guiStyleHeaderMobile.fontSize = (int)(17f * dpiScale);
		ChangeCurrent(0);
		startSunIntensity = Sun.intensity;
		startSunRotation = Sun.transform.rotation;
		startAmbientLight = RenderSettings.ambientLight;
		startAmbientIntencity = RenderSettings.ambientIntensity;
		startReflectionIntencity = RenderSettings.reflectionIntensity;
		startLightShadows = Sun.shadows;
		ChangeDayNight();
	}

	private void OnGUI()
	{
		if (Input.GetKeyUp(KeyCode.LeftArrow) || Input.GetKeyUp(KeyCode.RightArrow) || Input.GetKeyUp(KeyCode.DownArrow))
		{
			isButtonPressed = false;
		}
		if (GUI.Button(new Rect(10f * dpiScale, 15f * dpiScale, 135f * dpiScale, 37f * dpiScale), "PREVIOUS EFFECT") || (!isButtonPressed && Input.GetKeyDown(KeyCode.LeftArrow)))
		{
			isButtonPressed = true;
			ChangeCurrent(-1);
		}
		if (GUI.Button(new Rect(160f * dpiScale, 15f * dpiScale, 135f * dpiScale, 37f * dpiScale), "NEXT EFFECT") || (!isButtonPressed && Input.GetKeyDown(KeyCode.RightArrow)))
		{
			isButtonPressed = true;
			ChangeCurrent(1);
		}
		float num = 0f;
		if (GUI.Button(new Rect(10f * dpiScale, 63f * dpiScale + num, 285f * dpiScale, 37f * dpiScale), "Day / Night") || (!isButtonPressed && Input.GetKeyDown(KeyCode.DownArrow)))
		{
			ChangeDayNight();
		}
		GUI.Label(new Rect(350f * dpiScale, 15f * dpiScale + num / 2f, 500f * dpiScale, 20f * dpiScale), "press left mouse button for the camera rotating and scroll wheel for zooming", guiStyleHeader);
		GUI.Label(new Rect(350f * dpiScale, 35f * dpiScale + num / 2f, 160f * dpiScale, 20f * dpiScale), "prefab name is: " + Prefabs[currentNomber].name, guiStyleHeader);
	}

	private void ChangeDayNight()
	{
		isButtonPressed = true;
		if (ReflectionProbe != null)
		{
			ReflectionProbe.RenderProbe();
		}
		Sun.intensity = ((!isDay) ? 0.05f : startSunIntensity);
		Sun.shadows = (isDay ? startLightShadows : LightShadows.None);
		Light[] nightLights = NightLights;
		foreach (Light light in nightLights)
		{
			if (light != null)
			{
				light.shadows = ((!isDay) ? startLightShadows : LightShadows.None);
			}
		}
		Sun.transform.rotation = (isDay ? startSunRotation : Quaternion.Euler(350f, 30f, 90f));
		RenderSettings.ambientLight = ((!isDay) ? new Color(0.1f, 0.1f, 0.1f) : startAmbientLight);
		RenderSettings.ambientIntensity = (isDay ? startAmbientIntencity : 1f);
		RenderSettings.reflectionIntensity = (isDay ? startReflectionIntencity : 0.2f);
		isDay = !isDay;
	}

	private void ChangeCurrent(int delta)
	{
		currentNomber += delta;
		if (currentNomber > Prefabs.Length - 1)
		{
			currentNomber = 0;
		}
		else if (currentNomber < 0)
		{
			currentNomber = Prefabs.Length - 1;
		}
		if (currentInstance != null)
		{
			UnityEngine.Object.Destroy(currentInstance);
			RemoveClones();
		}
		currentInstance = UnityEngine.Object.Instantiate(Prefabs[currentNomber]);
		if (ReactivationTimes.Length == Prefabs.Length)
		{
			CancelInvoke();
			if (ReactivationTimes[currentNomber] > 0.1f)
			{
				InvokeRepeating("Reactivate", ReactivationTimes[currentNomber], ReactivationTimes[currentNomber]);
			}
		}
	}

	private void RemoveClones()
	{
		GameObject[] array = UnityEngine.Object.FindObjectsOfType<GameObject>();
		foreach (GameObject gameObject in array)
		{
			if (gameObject.name.Contains("(Clone)"))
			{
				UnityEngine.Object.Destroy(gameObject);
			}
		}
	}

	private void Reactivate()
	{
		currentInstance.SetActive(value: false);
		currentInstance.SetActive(value: true);
	}
}
public class RFX4_FPS : MonoBehaviour
{
	private readonly GUIStyle guiStyleHeader = new GUIStyle();

	private float timeleft;

	private float fps;

	private int frames;

	private void Awake()
	{
		guiStyleHeader.fontSize = 14;
		guiStyleHeader.normal.textColor = new Color(1f, 1f, 1f);
	}

	private void OnGUI()
	{
		GUI.Label(new Rect(0f, 0f, 30f, 30f), "FPS: " + (int)fps, guiStyleHeader);
	}

	private void Update()
	{
		timeleft -= Time.deltaTime;
		frames++;
		if ((double)timeleft <= 0.0)
		{
			fps = frames;
			timeleft = 1f;
			frames = 0;
		}
	}
}
public class RFX4_MouseOrbit : MonoBehaviour
{
	public GameObject target;

	public float distance = 10f;

	public float xSpeed = 250f;

	public float ySpeed = 120f;

	public float yMinLimit = -20f;

	public float yMaxLimit = 80f;

	private float x;

	private float y;

	private float prevDistance;

	private void Start()
	{
		Vector3 eulerAngles = base.transform.eulerAngles;
		x = eulerAngles.y;
		y = eulerAngles.x;
	}

	private void LateUpdate()
	{
		if (distance < 2f)
		{
			distance = 2f;
		}
		distance -= Input.GetAxis("Mouse ScrollWheel") * 2f;
		if ((bool)target && (Input.GetMouseButton(0) || Input.GetMouseButton(1)))
		{
			Vector3 mousePosition = Input.mousePosition;
			float num = 1f;
			if (Screen.dpi < 1f)
			{
				num = 1f;
			}
			num = ((!(Screen.dpi < 200f)) ? (Screen.dpi / 200f) : 1f);
			if (mousePosition.x < 380f * num && (float)Screen.height - mousePosition.y < 250f * num)
			{
				return;
			}
			Cursor.visible = false;
			Cursor.lockState = CursorLockMode.Locked;
			x += Input.GetAxis("Mouse X") * xSpeed * 0.02f;
			y -= Input.GetAxis("Mouse Y") * ySpeed * 0.02f;
			y = ClampAngle(y, yMinLimit, yMaxLimit);
			Quaternion quaternion = Quaternion.Euler(y, x, 0f);
			Vector3 position = quaternion * new Vector3(0f, 0f, 0f - distance) + target.transform.position;
			base.transform.rotation = quaternion;
			base.transform.position = position;
		}
		else
		{
			Cursor.visible = true;
			Cursor.lockState = CursorLockMode.None;
		}
		if (Math.Abs(prevDistance - distance) > 0.001f)
		{
			prevDistance = distance;
			Quaternion quaternion2 = Quaternion.Euler(y, x, 0f);
			Vector3 position2 = quaternion2 * new Vector3(0f, 0f, 0f - distance) + target.transform.position;
			base.transform.rotation = quaternion2;
			base.transform.position = position2;
		}
	}

	private static float ClampAngle(float angle, float min, float max)
	{
		if (angle < -360f)
		{
			angle += 360f;
		}
		if (angle > 360f)
		{
			angle -= 360f;
		}
		return Mathf.Clamp(angle, min, max);
	}
}
public class RFX4_RealtimeReflection : MonoBehaviour
{
	private ReflectionProbe probe;

	private Transform camT;

	private void Awake()
	{
		probe = GetComponent<ReflectionProbe>();
		camT = Camera.main.transform;
	}

	private void Update()
	{
		Vector3 position = camT.position;
		probe.transform.position = new Vector3(position.x, position.y * -1f, position.z);
		probe.RenderProbe();
	}
}
[ExecuteAlways]
public class GhostShot01Effct : MonoBehaviour
{
	public float ColorGrading_Contrast;

	private PostProcessVolume postProcessVolume;

	private void Start()
	{
		postProcessVolume = GetComponentInParent<PostProcessVolume>();
	}

	private void Update()
	{
		if (base.transform.parent.GetComponent<Filter>().currentFilter == FilterType.古宅1鬼镜)
		{
			postProcessVolume.profile.GetSetting<ColorGrading>().contrast.value = ColorGrading_Contrast;
		}
	}
}
[ExecuteAlways]
public class MemeoryShot01Effct : MonoBehaviour
{
	public float Bloom_Intensity;

	public float AutoExposure_Minimum;

	public float ChromaticAberration_Intensity;

	private PostProcessVolume postProcessVolume;

	private void Start()
	{
		postProcessVolume = GetComponentInParent<PostProcessVolume>();
	}

	private void Update()
	{
		if (base.transform.parent.GetComponent<Filter>().currentFilter == FilterType.古宅1回忆)
		{
			ChangeFilter();
		}
	}

	public void ChangeFilter()
	{
		postProcessVolume.profile.GetSetting<Bloom>().intensity.value = Bloom_Intensity;
		postProcessVolume.profile.GetSetting<AutoExposure>().minLuminance.value = AutoExposure_Minimum;
		postProcessVolume.profile.GetSetting<ChromaticAberration>().intensity.value = ChromaticAberration_Intensity;
	}
}
[ExecuteAlways]
public class Test1Effct : MonoBehaviour
{
	public float Bloom_Intensity;

	public float AutoExposure_Minimum;

	public float ChromaticAberration_Intensity;

	private PostProcessVolume postProcessVolume;

	private void Start()
	{
		postProcessVolume = GetComponentInParent<PostProcessVolume>();
	}

	private void Update()
	{
		postProcessVolume.profile.GetSetting<Bloom>().intensity.value = Bloom_Intensity;
		postProcessVolume.profile.GetSetting<AutoExposure>().minLuminance.value = AutoExposure_Minimum;
		postProcessVolume.profile.GetSetting<ChromaticAberration>().intensity.value = ChromaticAberration_Intensity;
	}
}
[ExecuteInEditMode]
public class MirrorReflection : MonoBehaviour
{
	public bool m_DisablePixelLights = true;

	public int m_TextureSize = 256;

	public float m_ClipPlaneOffset = 0.07f;

	public LayerMask m_ReflectLayers = -1;

	private Hashtable m_ReflectionCameras = new Hashtable();

	private RenderTexture m_ReflectionTexture;

	private int m_OldReflectionTextureSize;

	private static bool s_InsideRendering;

	public void OnWillRenderObject()
	{
		if (!base.enabled || !GetComponent<Renderer>() || !GetComponent<Renderer>().sharedMaterial || !GetComponent<Renderer>().enabled)
		{
			return;
		}
		Camera current = Camera.current;
		if (!current || s_InsideRendering)
		{
			return;
		}
		s_InsideRendering = true;
		CreateMirrorObjects(current, out var reflectionCamera);
		Vector3 position = base.transform.position;
		Vector3 up = base.transform.up;
		int pixelLightCount = QualitySettings.pixelLightCount;
		if (m_DisablePixelLights)
		{
			QualitySettings.pixelLightCount = 0;
		}
		UpdateCameraModes(current, reflectionCamera);
		float w = 0f - Vector3.Dot(up, position) - m_ClipPlaneOffset;
		Vector4 plane = new Vector4(up.x, up.y, up.z, w);
		Matrix4x4 reflectionMat = Matrix4x4.zero;
		CalculateReflectionMatrix(ref reflectionMat, plane);
		Vector3 position2 = current.transform.position;
		Vector3 position3 = reflectionMat.MultiplyPoint(position2);
		reflectionCamera.worldToCameraMatrix = current.worldToCameraMatrix * reflectionMat;
		Vector4 clipPlane = CameraSpacePlane(reflectionCamera, position, up, 1f);
		Matrix4x4 projection = current.projectionMatrix;
		CalculateObliqueMatrix(ref projection, clipPlane);
		reflectionCamera.projectionMatrix = projection;
		reflectionCamera.cullingMask = -17 & m_ReflectLayers.value;
		reflectionCamera.targetTexture = m_ReflectionTexture;
		GL.SetRevertBackfacing(revertBackFaces: true);
		reflectionCamera.transform.position = position3;
		Vector3 eulerAngles = current.transform.eulerAngles;
		reflectionCamera.transform.eulerAngles = new Vector3(0f, eulerAngles.y, eulerAngles.z);
		reflectionCamera.Render();
		reflectionCamera.transform.position = position2;
		GL.SetRevertBackfacing(revertBackFaces: false);
		Material[] sharedMaterials = GetComponent<Renderer>().sharedMaterials;
		Material[] array = sharedMaterials;
		foreach (Material material in array)
		{
			if (material.HasProperty("_ReflectionTex"))
			{
				material.SetTexture("_ReflectionTex", m_ReflectionTexture);
			}
		}
		Matrix4x4 matrix4x = Matrix4x4.TRS(new Vector3(0.5f, 0.5f, 0.5f), Quaternion.identity, new Vector3(0.5f, 0.5f, 0.5f));
		Vector3 lossyScale = base.transform.lossyScale;
		Matrix4x4 matrix4x2 = base.transform.localToWorldMatrix * Matrix4x4.Scale(new Vector3(1f / lossyScale.x, 1f / lossyScale.y, 1f / lossyScale.z));
		matrix4x2 = matrix4x * current.projectionMatrix * current.worldToCameraMatrix * matrix4x2;
		array = sharedMaterials;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetMatrix("_ProjMatrix", matrix4x2);
		}
		if (m_DisablePixelLights)
		{
			QualitySettings.pixelLightCount = pixelLightCount;
		}
		s_InsideRendering = false;
	}

	private void OnDisable()
	{
		if ((bool)m_ReflectionTexture)
		{
			UnityEngine.Object.DestroyImmediate(m_ReflectionTexture);
			m_ReflectionTexture = null;
		}
		foreach (DictionaryEntry reflectionCamera in m_ReflectionCameras)
		{
			UnityEngine.Object.DestroyImmediate(((Camera)reflectionCamera.Value).gameObject);
		}
		m_ReflectionCameras.Clear();
	}

	private void UpdateCameraModes(Camera src, Camera dest)
	{
		if (dest == null)
		{
			return;
		}
		dest.clearFlags = src.clearFlags;
		dest.backgroundColor = src.backgroundColor;
		if (src.clearFlags == CameraClearFlags.Skybox)
		{
			Skybox skybox = src.GetComponent(typeof(Skybox)) as Skybox;
			Skybox skybox2 = dest.GetComponent(typeof(Skybox)) as Skybox;
			if (!skybox || !skybox.material)
			{
				skybox2.enabled = false;
			}
			else
			{
				skybox2.enabled = true;
				skybox2.material = skybox.material;
			}
		}
		dest.farClipPlane = src.farClipPlane;
		dest.nearClipPlane = src.nearClipPlane;
		dest.orthographic = src.orthographic;
		dest.fieldOfView = src.fieldOfView;
		dest.aspect = src.aspect;
		dest.orthographicSize = src.orthographicSize;
	}

	private void CreateMirrorObjects(Camera currentCamera, out Camera reflectionCamera)
	{
		reflectionCamera = null;
		if (!m_ReflectionTexture || m_OldReflectionTextureSize != m_TextureSize)
		{
			if ((bool)m_ReflectionTexture)
			{
				UnityEngine.Object.DestroyImmediate(m_ReflectionTexture);
			}
			m_ReflectionTexture = new RenderTexture(m_TextureSize, m_TextureSize, 16);
			m_ReflectionTexture.name = "__MirrorReflection" + GetInstanceID();
			m_ReflectionTexture.isPowerOfTwo = true;
			m_ReflectionTexture.hideFlags = HideFlags.DontSave;
			m_OldReflectionTextureSize = m_TextureSize;
		}
		reflectionCamera = m_ReflectionCameras[currentCamera] as Camera;
		if (!reflectionCamera)
		{
			GameObject gameObject = new GameObject("Mirror Refl Camera id" + GetInstanceID() + " for " + currentCamera.GetInstanceID(), typeof(Camera), typeof(Skybox));
			reflectionCamera = gameObject.GetComponent<Camera>();
			reflectionCamera.enabled = false;
			reflectionCamera.transform.position = base.transform.position;
			reflectionCamera.transform.rotation = base.transform.rotation;
			reflectionCamera.gameObject.AddComponent<FlareLayer>();
			gameObject.hideFlags = HideFlags.HideAndDontSave;
			m_ReflectionCameras[currentCamera] = reflectionCamera;
		}
	}

	private static float sgn(float a)
	{
		if (a > 0f)
		{
			return 1f;
		}
		if (a < 0f)
		{
			return -1f;
		}
		return 0f;
	}

	private Vector4 CameraSpacePlane(Camera cam, Vector3 pos, Vector3 normal, float sideSign)
	{
		Vector3 point = pos + normal * m_ClipPlaneOffset;
		Matrix4x4 worldToCameraMatrix = cam.worldToCameraMatrix;
		Vector3 lhs = worldToCameraMatrix.MultiplyPoint(point);
		Vector3 rhs = worldToCameraMatrix.MultiplyVector(normal).normalized * sideSign;
		return new Vector4(rhs.x, rhs.y, rhs.z, 0f - Vector3.Dot(lhs, rhs));
	}

	private static void CalculateObliqueMatrix(ref Matrix4x4 projection, Vector4 clipPlane)
	{
		Vector4 b = projection.inverse * new Vector4(sgn(clipPlane.x), sgn(clipPlane.y), 1f, 1f);
		Vector4 vector = clipPlane * (2f / Vector4.Dot(clipPlane, b));
		projection[2] = vector.x - projection[3];
		projection[6] = vector.y - projection[7];
		projection[10] = vector.z - projection[11];
		projection[14] = vector.w - projection[15];
	}

	private static void CalculateReflectionMatrix(ref Matrix4x4 reflectionMat, Vector4 plane)
	{
		reflectionMat.m00 = 1f - 2f * plane[0] * plane[0];
		reflectionMat.m01 = -2f * plane[0] * plane[1];
		reflectionMat.m02 = -2f * plane[0] * plane[2];
		reflectionMat.m03 = -2f * plane[3] * plane[0];
		reflectionMat.m10 = -2f * plane[1] * plane[0];
		reflectionMat.m11 = 1f - 2f * plane[1] * plane[1];
		reflectionMat.m12 = -2f * plane[1] * plane[2];
		reflectionMat.m13 = -2f * plane[3] * plane[1];
		reflectionMat.m20 = -2f * plane[2] * plane[0];
		reflectionMat.m21 = -2f * plane[2] * plane[1];
		reflectionMat.m22 = 1f - 2f * plane[2] * plane[2];
		reflectionMat.m23 = -2f * plane[3] * plane[2];
		reflectionMat.m30 = 0f;
		reflectionMat.m31 = 0f;
		reflectionMat.m32 = 0f;
		reflectionMat.m33 = 1f;
	}
}
[ExecuteInEditMode]
[RequireComponent(typeof(Camera))]
[AddComponentMenu("Image Effects/Screen Space Ambient Occlusion")]
public class SSAOEffect : MonoBehaviour
{
	public enum SSAOSamples
	{
		Low,
		Medium,
		High
	}

	public float m_Radius = 0.4f;

	public SSAOSamples m_SampleCount = SSAOSamples.Medium;

	public float m_OcclusionIntensity = 1.5f;

	public int m_Blur = 2;

	public int m_Downsampling = 2;

	public float m_OcclusionAttenuation = 1f;

	public float m_MinZ = 0.01f;

	public Shader m_SSAOShader;

	private Material m_SSAOMaterial;

	public Texture2D m_RandomTexture;

	private bool m_Supported;

	private static Material CreateMaterial(Shader shader)
	{
		if (!shader)
		{
			return null;
		}
		return new Material(shader)
		{
			hideFlags = HideFlags.HideAndDontSave
		};
	}

	private static void DestroyMaterial(Material mat)
	{
		if ((bool)mat)
		{
			UnityEngine.Object.DestroyImmediate(mat);
			mat = null;
		}
	}

	private void OnDisable()
	{
		DestroyMaterial(m_SSAOMaterial);
	}

	private void Start()
	{
		if (!SystemInfo.supportsImageEffects || !SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.Depth))
		{
			m_Supported = false;
			base.enabled = false;
			return;
		}
		CreateMaterials();
		if (!m_SSAOMaterial || m_SSAOMaterial.passCount != 5)
		{
			m_Supported = false;
			base.enabled = false;
		}
		else
		{
			m_Supported = true;
		}
	}

	private void OnEnable()
	{
		GetComponent<Camera>().depthTextureMode |= DepthTextureMode.DepthNormals;
	}

	private void CreateMaterials()
	{
		if (!m_SSAOMaterial && m_SSAOShader.isSupported)
		{
			m_SSAOMaterial = CreateMaterial(m_SSAOShader);
			m_SSAOMaterial.SetTexture("_RandomTexture", m_RandomTexture);
		}
	}

	[ImageEffectOpaque]
	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		if (!m_Supported || !m_SSAOShader.isSupported)
		{
			base.enabled = false;
			return;
		}
		CreateMaterials();
		m_Downsampling = Mathf.Clamp(m_Downsampling, 1, 6);
		m_Radius = Mathf.Clamp(m_Radius, 0.05f, 1f);
		m_MinZ = Mathf.Clamp(m_MinZ, 1E-05f, 0.5f);
		m_OcclusionIntensity = Mathf.Clamp(m_OcclusionIntensity, 0.5f, 4f);
		m_OcclusionAttenuation = Mathf.Clamp(m_OcclusionAttenuation, 0.2f, 2f);
		m_Blur = Mathf.Clamp(m_Blur, 0, 4);
		RenderTexture renderTexture = RenderTexture.GetTemporary(source.width / m_Downsampling, source.height / m_Downsampling, 0);
		float fieldOfView = GetComponent<Camera>().fieldOfView;
		float farClipPlane = GetComponent<Camera>().farClipPlane;
		float num = Mathf.Tan(fieldOfView * ((float)Math.PI / 180f) * 0.5f) * farClipPlane;
		float x = num * GetComponent<Camera>().aspect;
		m_SSAOMaterial.SetVector("_FarCorner", new Vector3(x, num, farClipPlane));
		int num2;
		int num3;
		if ((bool)m_RandomTexture)
		{
			num2 = m_RandomTexture.width;
			num3 = m_RandomTexture.height;
		}
		else
		{
			num2 = 1;
			num3 = 1;
		}
		m_SSAOMaterial.SetVector("_NoiseScale", new Vector3((float)renderTexture.width / (float)num2, (float)renderTexture.height / (float)num3, 0f));
		m_SSAOMaterial.SetVector("_Params", new Vector4(m_Radius, m_MinZ, 1f / m_OcclusionAttenuation, m_OcclusionIntensity));
		bool num4 = m_Blur > 0;
		Graphics.Blit(num4 ? null : source, renderTexture, m_SSAOMaterial, (int)m_SampleCount);
		if (num4)
		{
			RenderTexture temporary = RenderTexture.GetTemporary(source.width, source.height, 0);
			m_SSAOMaterial.SetVector("_TexelOffsetScale", new Vector4((float)m_Blur / (float)source.width, 0f, 0f, 0f));
			m_SSAOMaterial.SetTexture("_SSAO", renderTexture);
			Graphics.Blit(null, temporary, m_SSAOMaterial, 3);
			RenderTexture.ReleaseTemporary(renderTexture);
			RenderTexture temporary2 = RenderTexture.GetTemporary(source.width, source.height, 0);
			m_SSAOMaterial.SetVector("_TexelOffsetScale", new Vector4(0f, (float)m_Blur / (float)source.height, 0f, 0f));
			m_SSAOMaterial.SetTexture("_SSAO", temporary);
			Graphics.Blit(source, temporary2, m_SSAOMaterial, 3);
			RenderTexture.ReleaseTemporary(temporary);
			renderTexture = temporary2;
		}
		m_SSAOMaterial.SetTexture("_SSAO", renderTexture);
		Graphics.Blit(source, destination, m_SSAOMaterial, 4);
		RenderTexture.ReleaseTemporary(renderTexture);
	}
}
[ExecuteInEditMode]
[RequireComponent(typeof(Camera))]
[RequireComponent(typeof(MeshRenderer))]
[RequireComponent(typeof(MeshFilter))]
public class VLightFog : MonoBehaviour
{
	public enum ShadowMode
	{
		None,
		Realtime,
		Baked
	}

	public float fogRadius = 1f;

	public Vector3 noiseSpeed;

	public ShadowMode shadowMode;

	public float aspectRatio = 1f;

	public int slices = 30;

	public int minSlices = 5;

	public bool dynamicLevelOfDetail;

	public Shader renderDepthShader;

	public Material fogMaterial;

	private Material _prevMaterialFog;

	public Material _instancedFogMaterial;

	[HideInInspector]
	public bool lockTransforms;

	public Mesh meshContainer;

	private int _maxSlices;

	private ShadowMode _prevShadowMode;

	private int _prevSlices;

	private bool _frustrumSwitch;

	private bool _prevIsOrtho;

	private float _prevNear;

	private float _prevFar;

	private float _prevFov;

	private float _prevOrthoSize;

	private float _prevPointLightRadius;

	private Matrix4x4 _worldToCamera;

	private Matrix4x4 _projectionMatrixCached;

	private Matrix4x4 _viewWorldToCameraMatrixCached;

	private Matrix4x4 _viewCameraToWorldMatrixCached;

	private Matrix4x4 _localToWorldMatrix;

	private Matrix4x4 _scrollA;

	private Matrix4x4 _scrollB;

	private Matrix4x4 _viewWorldLight;

	private Vector3[] _frustrumPoints;

	private Vector3 _angle = Vector3.zero;

	private Vector3 _minBounds;

	private Vector3 _maxBounds;

	private bool _cameraHasBeenUpdated;

	private MeshFilter _meshFilter;

	private RenderTexture _depthTexture;

	private const int VERT_COUNT = 65000;

	private const int TRI_COUNT = 195000;

	private const StringComparison STR_CMP_TYPE = StringComparison.OrdinalIgnoreCase;

	private Texture2D _positionX;

	private Texture2D _positionY;

	private Texture2D _positionZ;

	public Transform[] positions;

	private Color[] _colorX = new Color[24];

	private Color[] _colorY = new Color[24];

	private Color[] _colorZ = new Color[24];

	public int MaxSlices
	{
		get
		{
			return _maxSlices;
		}
		set
		{
			_maxSlices = value;
		}
	}

	public void OnEnable()
	{
		_maxSlices = slices;
		int num = LayerMask.NameToLayer("vlight");
		if (num != -1)
		{
			base.gameObject.layer = num;
		}
		GetComponent<Camera>().enabled = false;
		GetComponent<Camera>().cullingMask &= ~(1 << base.gameObject.layer);
		CreateMaterials();
	}

	private void OnApplicationQuit()
	{
	}

	private void OnDestroy()
	{
		CleanMaterials();
		SafeDestroy(_depthTexture);
		SafeDestroy(meshContainer);
		SafeDestroy(_positionX);
		SafeDestroy(_positionY);
		SafeDestroy(_positionZ);
	}

	private void Start()
	{
		CreateMaterials();
	}

	public void Reset()
	{
		CleanMaterials();
		SafeDestroy(_depthTexture);
		SafeDestroy(meshContainer);
	}

	public bool GenerateNewMaterial(Material originalMaterial, ref Material instancedMaterial)
	{
		string text = GetInstanceID().ToString();
		if (originalMaterial != null && (instancedMaterial == null || instancedMaterial.name.IndexOf(text, StringComparison.OrdinalIgnoreCase) < 0 || instancedMaterial.name.IndexOf(originalMaterial.name, StringComparison.OrdinalIgnoreCase) < 0))
		{
			if (!originalMaterial.shader.isSupported)
			{
				UnityEngine.Debug.LogError("Volumetric light shader not supported");
				base.enabled = false;
				return false;
			}
			Material source = originalMaterial;
			if (instancedMaterial != null && instancedMaterial.name.IndexOf(originalMaterial.name, StringComparison.OrdinalIgnoreCase) > 0)
			{
				source = instancedMaterial;
			}
			instancedMaterial = new Material(source);
			instancedMaterial.name = text + " " + originalMaterial.name;
		}
		return true;
	}

	public void CreateMaterials()
	{
		if (false | GenerateNewMaterial(fogMaterial, ref _instancedFogMaterial))
		{
			GetComponent<Renderer>().sharedMaterial = _instancedFogMaterial;
		}
	}

	private void CleanMaterials()
	{
		SafeDestroy(_instancedFogMaterial);
		SafeDestroy(GetComponent<Renderer>().sharedMaterial);
		SafeDestroy(meshContainer);
		_prevMaterialFog = null;
		_instancedFogMaterial = null;
		meshContainer = null;
	}

	private void OnDrawGizmosSelected()
	{
		if (_frustrumPoints != null)
		{
			Gizmos.color = new Color(0f, 1f, 0f, 0.2f);
			Gizmos.DrawLine(base.transform.TransformPoint(_frustrumPoints[0]), base.transform.TransformPoint(_frustrumPoints[1]));
			Gizmos.DrawLine(base.transform.TransformPoint(_frustrumPoints[2]), base.transform.TransformPoint(_frustrumPoints[3]));
			Gizmos.DrawLine(base.transform.TransformPoint(_frustrumPoints[4]), base.transform.TransformPoint(_frustrumPoints[5]));
			Gizmos.DrawLine(base.transform.TransformPoint(_frustrumPoints[6]), base.transform.TransformPoint(_frustrumPoints[7]));
			Gizmos.DrawLine(base.transform.TransformPoint(_frustrumPoints[1]), base.transform.TransformPoint(_frustrumPoints[3]));
			Gizmos.DrawLine(base.transform.TransformPoint(_frustrumPoints[3]), base.transform.TransformPoint(_frustrumPoints[7]));
			Gizmos.DrawLine(base.transform.TransformPoint(_frustrumPoints[7]), base.transform.TransformPoint(_frustrumPoints[5]));
			Gizmos.DrawLine(base.transform.TransformPoint(_frustrumPoints[5]), base.transform.TransformPoint(_frustrumPoints[1]));
			Gizmos.DrawLine(base.transform.TransformPoint(_frustrumPoints[0]), base.transform.TransformPoint(_frustrumPoints[2]));
			Gizmos.DrawLine(base.transform.TransformPoint(_frustrumPoints[2]), base.transform.TransformPoint(_frustrumPoints[6]));
			Gizmos.DrawLine(base.transform.TransformPoint(_frustrumPoints[6]), base.transform.TransformPoint(_frustrumPoints[4]));
			Gizmos.DrawLine(base.transform.TransformPoint(_frustrumPoints[4]), base.transform.TransformPoint(_frustrumPoints[0]));
			Gizmos.color = new Color(1f, 1f, 0f, 1f);
			Gizmos.DrawWireCube(GetComponent<Renderer>().bounds.center, GetComponent<Renderer>().bounds.size);
		}
	}

	private void CalculateMinMax(out Vector3 min, out Vector3 max, bool forceFrustrumUpdate)
	{
		if (_frustrumPoints == null || forceFrustrumUpdate)
		{
			VLightGeometryUtil.RecalculateFrustrumPoints(GetComponent<Camera>(), aspectRatio, out _frustrumPoints);
		}
		Vector3[] array = new Vector3[8];
		Vector3 vector = new Vector3(float.NegativeInfinity, float.NegativeInfinity, float.NegativeInfinity);
		Vector3 vector2 = new Vector3(float.PositiveInfinity, float.PositiveInfinity, float.PositiveInfinity);
		Matrix4x4 matrix4x = _viewWorldToCameraMatrixCached * _localToWorldMatrix;
		for (int i = 0; i < _frustrumPoints.Length; i++)
		{
			array[i] = matrix4x.MultiplyPoint(_frustrumPoints[i]);
			vector.x = ((vector.x > array[i].x) ? vector.x : array[i].x);
			vector.y = ((vector.y > array[i].y) ? vector.y : array[i].y);
			vector.z = ((vector.z > array[i].z) ? vector.z : array[i].z);
			vector2.x = ((vector2.x <= array[i].x) ? vector2.x : array[i].x);
			vector2.y = ((vector2.y <= array[i].y) ? vector2.y : array[i].y);
			vector2.z = ((vector2.z <= array[i].z) ? vector2.z : array[i].z);
		}
		min = vector;
		max = vector2;
	}

	private Matrix4x4 CalculateProjectionMatrix()
	{
		if (!GetComponent<Camera>().orthographic)
		{
			return Matrix4x4.Perspective(GetComponent<Camera>().fieldOfView, aspectRatio, GetComponent<Camera>().nearClipPlane, GetComponent<Camera>().farClipPlane);
		}
		return Matrix4x4.Ortho((0f - GetComponent<Camera>().orthographicSize) * 0.5f * aspectRatio, GetComponent<Camera>().orthographicSize * 0.5f * aspectRatio, (0f - GetComponent<Camera>().orthographicSize) * 0.5f, GetComponent<Camera>().orthographicSize * 0.5f, GetComponent<Camera>().farClipPlane, GetComponent<Camera>().nearClipPlane);
	}

	private void BuildMesh(bool manualPositioning, int planeCount, Vector3 minBounds, Vector3 maxBounds)
	{
		if (meshContainer == null || meshContainer.name.IndexOf(GetInstanceID().ToString(), StringComparison.OrdinalIgnoreCase) != 0)
		{
			meshContainer = new Mesh();
			meshContainer.hideFlags = HideFlags.HideAndDontSave;
			meshContainer.name = GetInstanceID().ToString();
		}
		if (_meshFilter == null)
		{
			_meshFilter = GetComponent<MeshFilter>();
		}
		Vector3[] array = new Vector3[65000];
		int[] array2 = new int[195000];
		int num = 0;
		int num2 = 0;
		float num3 = 1f / (float)(planeCount - 1);
		float num4 = (manualPositioning ? 1f : 0f);
		float x = 0f;
		float x2 = 1f;
		float y = 0f;
		float y2 = 1f;
		int num5 = 0;
		for (int i = 0; i < planeCount; i++)
		{
			Vector3[] array3 = new Vector3[4];
			Vector3[] array5;
			if (manualPositioning)
			{
				Plane[] array4 = GeometryUtility.CalculateFrustumPlanes(_projectionMatrixCached * GetComponent<Camera>().worldToCameraMatrix);
				for (int j = 0; j < array4.Length; j++)
				{
					Vector3 point = array4[j].normal * (0f - array4[j].distance);
					array4[j] = new Plane(_viewWorldToCameraMatrixCached.MultiplyVector(array4[j].normal), _viewWorldToCameraMatrixCached.MultiplyPoint3x4(point));
				}
				array3[0] = CalculateTriLerp(new Vector3(x, y, num4), minBounds, maxBounds);
				array3[1] = CalculateTriLerp(new Vector3(x, y2, num4), minBounds, maxBounds);
				array3[2] = CalculateTriLerp(new Vector3(x2, y2, num4), minBounds, maxBounds);
				array3[3] = CalculateTriLerp(new Vector3(x2, y, num4), minBounds, maxBounds);
				array5 = VLightGeometryUtil.ClipPolygonAgainstPlane(array3, array4);
			}
			else
			{
				array3[0] = new Vector3(x, y, num4);
				array3[1] = new Vector3(x, y2, num4);
				array3[2] = new Vector3(x2, y2, num4);
				array3[3] = new Vector3(x2, y, num4);
				array5 = array3;
			}
			num4 += (manualPositioning ? (0f - num3) : num3);
			if (array5.Length > 2)
			{
				Array.Copy(array5, 0, array, num, array5.Length);
				num += array5.Length;
				int[] array6 = new int[(array5.Length - 2) * 3];
				int num6 = 0;
				for (int k = 0; k < array6.Length; k += 3)
				{
					array6[k] = num5;
					array6[k + 1] = num5 + (num6 + 1);
					array6[k + 2] = num5 + (num6 + 2);
					num6++;
				}
				num5 += array5.Length;
				Array.Copy(array6, 0, array2, num2, array6.Length);
				num2 += array6.Length;
			}
		}
		meshContainer.Clear();
		Vector3[] array7 = new Vector3[num];
		Array.Copy(array, array7, num);
		meshContainer.vertices = array7;
		int[] array8 = new int[num2];
		Array.Copy(array2, array8, num2);
		meshContainer.triangles = array8;
		meshContainer.normals = new Vector3[num];
		meshContainer.uv = new Vector2[num];
		Vector3 zero = Vector3.zero;
		Vector3[] frustrumPoints = _frustrumPoints;
		foreach (Vector3 vector in frustrumPoints)
		{
			zero += vector;
		}
		zero /= (float)_frustrumPoints.Length;
		Bounds bounds = new Bounds(zero, Vector3.zero);
		frustrumPoints = _frustrumPoints;
		foreach (Vector3 point2 in frustrumPoints)
		{
			bounds.Encapsulate(point2);
		}
		_meshFilter.sharedMesh = meshContainer;
		_meshFilter.sharedMesh.bounds = bounds;
	}

	private Vector3 CalculateTriLerp(Vector3 vertex, Vector3 minBounds, Vector3 maxBounds)
	{
		Vector3 vector = new Vector3(1f, 1f, 1f) - vertex;
		return new Vector3(minBounds.x * vertex.x, minBounds.y * vertex.y, maxBounds.z * vertex.z) + new Vector3(maxBounds.x * vector.x, maxBounds.y * vector.y, minBounds.z * vector.z);
	}

	private void RenderShadowMap()
	{
		switch (shadowMode)
		{
		case ShadowMode.Realtime:
			if (SystemInfo.supportsImageEffects)
			{
				int num = LayerMask.NameToLayer("vlight");
				if (num != -1)
				{
					base.gameObject.layer = num;
					GetComponent<Camera>().backgroundColor = Color.red;
					GetComponent<Camera>().clearFlags = CameraClearFlags.Color;
					GetComponent<Camera>().depthTextureMode = DepthTextureMode.None;
					GetComponent<Camera>().renderingPath = RenderingPath.VertexLit;
					CreateDepthTexture();
					GetComponent<Camera>().targetTexture = null;
					GetComponent<Camera>().projectionMatrix = Matrix4x4.Perspective(90f, aspectRatio, 0.01f, GetComponent<Camera>().farClipPlane);
					GetComponent<Camera>().SetReplacementShader(renderDepthShader, "RenderType");
					GetComponent<Camera>().RenderToCubemap(_depthTexture, 63);
					GetComponent<Camera>().ResetReplacementShader();
				}
			}
			break;
		case ShadowMode.None:
		case ShadowMode.Baked:
			break;
		}
	}

	private void CreateDepthTexture()
	{
		if (_depthTexture == null)
		{
			_depthTexture = new RenderTexture(256, 256, 24);
			_depthTexture.hideFlags = HideFlags.HideAndDontSave;
			_depthTexture.isPowerOfTwo = true;
			_depthTexture.isCubemap = true;
		}
		else if (!_depthTexture.isCubemap && _depthTexture.IsCreated())
		{
			SafeDestroy(_depthTexture);
			_depthTexture = new RenderTexture(256, 256, 24);
			_depthTexture.hideFlags = HideFlags.HideAndDontSave;
			_depthTexture.isPowerOfTwo = true;
			_depthTexture.isCubemap = true;
		}
	}

	private void Update()
	{
		if (Application.isPlaying)
		{
			if (VLightManager.Instance.targetCamera != null)
			{
				UpdateViewMatrices(VLightManager.Instance.targetCamera);
			}
			else
			{
				UpdateViewMatrices(Camera.main);
			}
		}
		else if (Camera.current != null)
		{
			UpdateViewMatrices(Camera.current);
		}
		RenderShadowMap();
	}

	private void OnWillRenderObject()
	{
		if (fogMaterial == null || _instancedFogMaterial == null)
		{
			UnityEngine.Debug.Log("Materials not initialized");
			CreateMaterials();
		}
		else
		{
			if (lockTransforms)
			{
				return;
			}
			UpdateSettings();
			UpdateLightMatrices();
			if (Application.isPlaying)
			{
				if (VLightManager.Instance.targetCamera != null)
				{
					UpdateViewMatrices(VLightManager.Instance.targetCamera);
				}
				else
				{
					UpdateViewMatrices(Camera.main);
				}
			}
			else if (Camera.current != null)
			{
				UpdateViewMatrices(Camera.current);
			}
			SetShaderProperties();
		}
	}

	private bool CameraHasBeenUpdated()
	{
		return false | (_meshFilter == null || _meshFilter.sharedMesh == null) | (GetComponent<Camera>().farClipPlane != _prevFar) | (GetComponent<Camera>().nearClipPlane != _prevNear) | (GetComponent<Camera>().fieldOfView != _prevFov) | (GetComponent<Camera>().orthographicSize != _prevOrthoSize) | (GetComponent<Camera>().orthographic != _prevIsOrtho) | (fogRadius != _prevPointLightRadius) | (fogMaterial != _prevMaterialFog) | (_prevSlices != slices) | (_prevShadowMode != shadowMode);
	}

	public void UpdateSettings()
	{
		_cameraHasBeenUpdated = CameraHasBeenUpdated();
		if (_cameraHasBeenUpdated)
		{
			GetComponent<Renderer>().sharedMaterial = _instancedFogMaterial;
			GetComponent<Camera>().orthographic = true;
			GetComponent<Camera>().nearClipPlane = 0f - fogRadius;
			GetComponent<Camera>().farClipPlane = fogRadius;
			GetComponent<Camera>().orthographicSize = fogRadius * 2f;
			if ((shadowMode == ShadowMode.None || shadowMode == ShadowMode.Baked) && _depthTexture != null)
			{
				SafeDestroy(_depthTexture);
			}
		}
		_prevSlices = slices;
		_prevFov = GetComponent<Camera>().fieldOfView;
		_prevNear = GetComponent<Camera>().nearClipPlane;
		_prevFar = GetComponent<Camera>().farClipPlane;
		_prevIsOrtho = GetComponent<Camera>().orthographic;
		_prevOrthoSize = GetComponent<Camera>().orthographicSize;
		_prevMaterialFog = fogMaterial;
		_prevShadowMode = shadowMode;
		_prevPointLightRadius = fogRadius;
	}

	public void UpdateLightMatrices()
	{
		_localToWorldMatrix = base.transform.localToWorldMatrix;
		_worldToCamera = GetComponent<Camera>().worldToCameraMatrix;
		_scrollA = Matrix4x4.TRS(_angle, Quaternion.Euler(90f, 0f, 0f), Vector3.one);
		_scrollB = Matrix4x4.TRS(-_angle, Quaternion.Euler(0f, 0f, 0f), Vector3.one);
		_angle += noiseSpeed * Time.deltaTime;
		RebuildMesh();
	}

	public void UpdateViewMatrices(Camera targetCamera)
	{
		_viewWorldToCameraMatrixCached = targetCamera.worldToCameraMatrix;
		_viewCameraToWorldMatrixCached = targetCamera.cameraToWorldMatrix;
		Matrix4x4 matrix4x = Matrix4x4.TRS(-base.transform.position, Quaternion.identity, Vector3.one);
		_viewWorldLight = matrix4x * _viewCameraToWorldMatrixCached;
	}

	public void SetInterleavedOffset(float value)
	{
		GetComponent<Renderer>().sharedMaterial.SetFloat("_Offset", value);
	}

	public void RebuildMesh()
	{
		CalculateMinMax(out _minBounds, out _maxBounds, _cameraHasBeenUpdated);
		if (_cameraHasBeenUpdated)
		{
			_projectionMatrixCached = CalculateProjectionMatrix();
			CreateMaterials();
			BuildMesh(manualPositioning: false, slices, _minBounds, _maxBounds);
		}
	}

	public void OnGUI()
	{
		if (_positionX != null)
		{
			GUI.DrawTexture(new Rect(0f, 0f, Screen.width, 20f), _positionX);
		}
	}

	public void GenerateTexture(ref Texture2D tex)
	{
		if (tex == null)
		{
			tex = new Texture2D(24, 1, TextureFormat.RGBA32, mipChain: false);
			tex.hideFlags = HideFlags.HideAndDontSave;
			tex.filterMode = FilterMode.Point;
		}
	}

	public void SetShaderProperties()
	{
		Material sharedMaterial = GetComponent<Renderer>().sharedMaterial;
		sharedMaterial.SetVector("_minBounds", _minBounds);
		sharedMaterial.SetVector("_maxBounds", _maxBounds);
		sharedMaterial.SetMatrix("_Projection", _projectionMatrixCached);
		sharedMaterial.SetMatrix("_ViewWorldLight", _viewWorldLight);
		sharedMaterial.SetMatrix("_ScrollA", _scrollA);
		sharedMaterial.SetMatrix("_ScrollB", _scrollB);
		Plane[] array = GeometryUtility.CalculateFrustumPlanes(_projectionMatrixCached);
		for (int i = 0; i < array.Length; i++)
		{
			Vector3 vector = base.transform.TransformDirection(array[i].normal);
			float distance = array[i].distance;
			sharedMaterial.SetVector("_FrustrumPlane" + i, new Vector4(vector.x, vector.y, vector.z, distance));
		}
		switch (shadowMode)
		{
		case ShadowMode.Realtime:
			sharedMaterial.SetTexture("_ShadowTexture", _depthTexture);
			break;
		case ShadowMode.None:
			sharedMaterial.SetTexture("_ShadowTexture", null);
			break;
		}
		GenerateTexture(ref _positionX);
		GenerateTexture(ref _positionY);
		GenerateTexture(ref _positionZ);
		for (int j = 0; j < 24; j++)
		{
			Color color = VLightGeometryUtil.FloatToRGBA(0.5f);
			_colorX[j] = color;
			_colorY[j] = color;
			_colorZ[j] = color;
		}
		for (int k = 0; k < positions.Length; k++)
		{
			Vector3 vector2 = _worldToCamera.MultiplyPoint(positions[k].position);
			_colorX[k] = VLightGeometryUtil.FloatToRGBA((vector2.x + 20f) / 40f);
			_colorY[k] = VLightGeometryUtil.FloatToRGBA((vector2.y + 20f) / 40f);
			_colorZ[k] = VLightGeometryUtil.FloatToRGBA((vector2.z + 20f) / 40f);
		}
		_positionX.SetPixels(_colorX);
		_positionY.SetPixels(_colorY);
		_positionZ.SetPixels(_colorZ);
		_positionX.Apply(updateMipmaps: false);
		_positionY.Apply(updateMipmaps: false);
		_positionZ.Apply(updateMipmaps: false);
		sharedMaterial.SetFloat("_Points", positions.Length);
		sharedMaterial.SetTexture("_PositionX", _positionX);
		sharedMaterial.SetTexture("_PositionY", _positionY);
		sharedMaterial.SetTexture("_PositionZ", _positionZ);
		float farClipPlane = GetComponent<Camera>().farClipPlane;
		float nearClipPlane = GetComponent<Camera>().nearClipPlane;
		sharedMaterial.SetVector("_LightParams", new Vector4(nearClipPlane, farClipPlane, farClipPlane - nearClipPlane, GetComponent<Camera>().orthographic ? ((float)Math.PI) : (GetComponent<Camera>().fieldOfView * 0.5f * ((float)Math.PI / 180f))));
	}

	private void SafeDestroy(UnityEngine.Object obj)
	{
		if (obj != null)
		{
			if (Application.isPlaying)
			{
				UnityEngine.Object.Destroy(obj);
			}
			else
			{
				UnityEngine.Object.DestroyImmediate(obj, allowDestroyingAssets: true);
			}
		}
		obj = null;
	}
}
[ExecuteInEditMode]
[RequireComponent(typeof(Camera))]
public class EnableDepthTexture : MonoBehaviour
{
	public bool EnableInEditor = true;

	private void OnEnable()
	{
		GetComponent<Camera>().depthTextureMode = DepthTextureMode.Depth;
	}

	private void OnDisable()
	{
		GetComponent<Camera>().depthTextureMode = DepthTextureMode.None;
	}

	private void Update()
	{
	}
}
[ExecuteInEditMode]
public class Lightbeam : MonoBehaviour
{
	public bool IsModifyingMesh;

	public Material DefaultMaterial;

	public LightbeamSettings Settings;

	public float RadiusTop
	{
		get
		{
			return Settings.RadiusTop;
		}
		set
		{
			Settings.RadiusTop = value;
		}
	}

	public float RadiusBottom
	{
		get
		{
			return Settings.RadiusBottom;
		}
		set
		{
			Settings.RadiusBottom = value;
		}
	}

	public float Length
	{
		get
		{
			return Settings.Length;
		}
		set
		{
			Settings.Length = value;
		}
	}

	public int Subdivisions
	{
		get
		{
			return Settings.Subdivisions;
		}
		set
		{
			Settings.Subdivisions = value;
		}
	}

	public int SubdivisionsHeight
	{
		get
		{
			return Settings.SubdivisionsHeight;
		}
		set
		{
			Settings.SubdivisionsHeight = value;
		}
	}

	public void GenerateBeam()
	{
		MeshFilter component = GetComponent<MeshFilter>();
		CombineInstance[] array = new CombineInstance[2];
		array[0].mesh = GenerateMesh(reverseNormals: false);
		array[0].transform = Matrix4x4.identity;
		array[1].mesh = GenerateMesh(reverseNormals: true);
		array[1].transform = Matrix4x4.identity;
		Mesh mesh = new Mesh();
		mesh.CombineMeshes(array);
		if (component.sharedMesh == null)
		{
			component.sharedMesh = new Mesh();
		}
		component.sharedMesh.Clear();
		component.sharedMesh.vertices = mesh.vertices;
		component.sharedMesh.uv = mesh.uv;
		component.sharedMesh.triangles = mesh.triangles;
		component.sharedMesh.tangents = mesh.tangents;
		component.sharedMesh.normals = mesh.normals;
	}

	private Mesh GenerateMesh(bool reverseNormals)
	{
		int num = Settings.Subdivisions * (Settings.SubdivisionsHeight + 1);
		num += Settings.SubdivisionsHeight + 1;
		Vector3[] array = new Vector3[num];
		Vector2[] array2 = new Vector2[num];
		Vector3[] array3 = new Vector3[num];
		int[] array4 = new int[Settings.Subdivisions * 2 * Settings.SubdivisionsHeight * 3];
		int num2 = Settings.SubdivisionsHeight + 1;
		float num3 = (float)Math.PI * 2f / (float)Settings.Subdivisions;
		float lengthFrac = Settings.Length / (float)Settings.SubdivisionsHeight;
		float num4 = 1f / (float)Settings.Subdivisions;
		float num5 = 1f / (float)Settings.SubdivisionsHeight;
		for (int i = 0; i < Settings.Subdivisions + 1; i++)
		{
			float xAngle = Mathf.Cos((float)i * num3);
			float yAngle = Mathf.Sin((float)i * num3);
			Vector3 vector = CalculateVertex(lengthFrac, xAngle, yAngle, 0, Settings.RadiusTop);
			Vector3 vector2 = CalculateVertex(lengthFrac, xAngle, yAngle, num2 - 1, Settings.RadiusBottom) - vector;
			for (int j = 0; j < num2; j++)
			{
				float radius = Mathf.Lerp(Settings.RadiusTop, Settings.RadiusBottom, num5 * (float)j);
				Vector3 vector3 = CalculateVertex(lengthFrac, xAngle, yAngle, j, radius);
				Vector3 vector4 = Vector3.Cross(vector2.normalized, new Vector3(vector3.x, 0f, vector3.z).normalized);
				vector4 = ((!reverseNormals) ? Vector3.Cross(vector4.normalized, vector2.normalized) : Vector3.Cross(vector2.normalized, vector4.normalized));
				int num6 = i * num2 + j;
				array[num6] = vector3;
				array2[num6] = new Vector2(num4 * (float)i, 1f - num5 * (float)j);
				array3[num6] = vector4.normalized;
				array2[num6] = new Vector2(num4 * (float)i, 1f - num5 * (float)j);
			}
		}
		int num7 = 0;
		for (int k = 0; k < Settings.Subdivisions; k++)
		{
			for (int l = 0; l < num2 - 1; l++)
			{
				int num8 = k * num2 + l;
				int num9 = num8 + 1;
				int num10 = num8 + num2;
				if (num10 >= num)
				{
					num10 %= num;
				}
				if (reverseNormals)
				{
					array4[num7++] = num8;
					array4[num7++] = num9;
					array4[num7++] = num10;
				}
				else
				{
					array4[num7++] = num9;
					array4[num7++] = num8;
					array4[num7++] = num10;
				}
				int num11 = num8 + 1;
				int num12 = num8 + num2;
				if (num12 >= num)
				{
					num12 %= num;
				}
				int num13 = num12 + 1;
				if (reverseNormals)
				{
					array4[num7++] = num11;
					array4[num7++] = num13;
					array4[num7++] = num12;
				}
				else
				{
					array4[num7++] = num11;
					array4[num7++] = num12;
					array4[num7++] = num13;
				}
			}
		}
		Mesh mesh = new Mesh();
		mesh.Clear();
		mesh.vertices = array;
		mesh.uv = array2;
		mesh.triangles = array4;
		mesh.normals = array3;
		mesh.RecalculateBounds();
		CalculateMeshTangents(mesh);
		return mesh;
	}

	private static Vector3 CalculateVertex(float lengthFrac, float xAngle, float yAngle, int j, float radius)
	{
		float x = radius * xAngle;
		float z = radius * yAngle;
		return new Vector3(x, (float)j * (lengthFrac * -1f), z);
	}

	private static void CalculateMeshTangents(Mesh mesh)
	{
		int[] triangles = mesh.triangles;
		Vector3[] vertices = mesh.vertices;
		Vector2[] uv = mesh.uv;
		Vector3[] normals = mesh.normals;
		int num = triangles.Length;
		int num2 = vertices.Length;
		Vector3[] array = new Vector3[num2];
		Vector3[] array2 = new Vector3[num2];
		Vector4[] array3 = new Vector4[num2];
		for (long num3 = 0L; num3 < num; num3 += 3)
		{
			long num4 = triangles[num3];
			long num5 = triangles[num3 + 1];
			long num6 = triangles[num3 + 2];
			Vector3 vector = vertices[num4];
			Vector3 vector2 = vertices[num5];
			Vector3 vector3 = vertices[num6];
			Vector2 vector4 = uv[num4];
			Vector2 vector5 = uv[num5];
			Vector2 vector6 = uv[num6];
			float num7 = vector2.x - vector.x;
			float num8 = vector3.x - vector.x;
			float num9 = vector2.y - vector.y;
			float num10 = vector3.y - vector.y;
			float num11 = vector2.z - vector.z;
			float num12 = vector3.z - vector.z;
			float num13 = vector5.x - vector4.x;
			float num14 = vector6.x - vector4.x;
			float num15 = vector5.y - vector4.y;
			float num16 = vector6.y - vector4.y;
			float num17 = 1f / (num13 * num16 - num14 * num15);
			Vector3 vector7 = new Vector3((num16 * num7 - num15 * num8) * num17, (num16 * num9 - num15 * num10) * num17, (num16 * num11 - num15 * num12) * num17);
			Vector3 vector8 = new Vector3((num13 * num8 - num14 * num7) * num17, (num13 * num10 - num14 * num9) * num17, (num13 * num12 - num14 * num11) * num17);
			array[num4] += vector7;
			array[num5] += vector7;
			array[num6] += vector7;
			array2[num4] += vector8;
			array2[num5] += vector8;
			array2[num6] += vector8;
		}
		for (long num18 = 0L; num18 < num2; num18++)
		{
			Vector3 normal = normals[num18];
			Vector3 tangent = array[num18];
			Vector3.OrthoNormalize(ref normal, ref tangent);
			array3[num18].x = tangent.x;
			array3[num18].y = tangent.y;
			array3[num18].z = tangent.z;
			array3[num18].w = ((Vector3.Dot(Vector3.Cross(normal, tangent), array2[num18]) < 0f) ? (-1f) : 1f);
		}
		mesh.tangents = array3;
	}
}
public class LightbeamSettings : ScriptableObject
{
	public float RadiusTop = 1f;

	public float RadiusBottom = 5f;

	public float Length = 10f;

	public int Subdivisions = 25;

	public int SubdivisionsHeight = 6;
}
[ExecuteInEditMode]
[RequireComponent(typeof(Camera))]
[AddComponentMenu("V-Lights/VLight Image Effects")]
public class VLightInterleavedSampling : MonoBehaviour
{
	[SerializeField]
	private bool useInterleavedSampling = true;

	[SerializeField]
	private float ditherOffset = 0.02f;

	[SerializeField]
	private float blurRadius = 1.5f;

	[SerializeField]
	private int blurIterations = 1;

	[SerializeField]
	private int downSample = 4;

	[SerializeField]
	private Shader postEffectShader;

	[SerializeField]
	private Shader volumeLightShader;

	private GameObject _ppCameraGO;

	private LayerMask _volumeLightLayer;

	private VLight[] _vLights;

	private Material _postMaterial;

	private Material PostMaterial
	{
		get
		{
			if (_postMaterial == null)
			{
				_postMaterial = new Material(postEffectShader);
			}
			return _postMaterial;
		}
	}

	private void OnEnable()
	{
		_vLights = null;
		Init();
	}

	private void OnDisable()
	{
		if (_vLights != null)
		{
			VLight[] vLights = _vLights;
			foreach (VLight vLight in vLights)
			{
				if (!(vLight == null))
				{
					vLight.SetInterleavedOffset(0f);
					vLight.lockTransforms = false;
				}
			}
		}
		_vLights = null;
		CleanUp();
	}

	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		if (_vLights == null)
		{
			_vLights = UnityEngine.Object.FindObjectsOfType(typeof(VLight)) as VLight[];
		}
		int num = Mathf.Clamp(downSample, 1, 20);
		blurIterations = Mathf.Clamp(blurIterations, 0, 20);
		RenderTexture temporary = RenderTexture.GetTemporary(Screen.width / num, Screen.height / num, 1);
		RenderTexture temporary2 = RenderTexture.GetTemporary(Screen.width / num, Screen.height / num, 1);
		RenderTexture temporary3 = RenderTexture.GetTemporary(Screen.width / num, Screen.height / num, 1);
		RenderTexture temporary4 = RenderTexture.GetTemporary(Screen.width / num, Screen.height / num, 1);
		RenderTexture temporary5 = RenderTexture.GetTemporary(Screen.width, Screen.height, 0);
		Camera pPCamera = GetPPCamera();
		pPCamera.CopyFrom(GetComponent<Camera>());
		pPCamera.enabled = false;
		pPCamera.depthTextureMode = DepthTextureMode.None;
		pPCamera.clearFlags = CameraClearFlags.Color;
		pPCamera.cullingMask = _volumeLightLayer;
		pPCamera.backgroundColor = Color.clear;
		pPCamera.renderingPath = RenderingPath.VertexLit;
		VLight[] vLights = _vLights;
		foreach (VLight vLight in vLights)
		{
			if (!(vLight == null))
			{
				vLight.lockTransforms = true;
				vLight.UpdateSettings();
				vLight.UpdateLightMatrices();
				vLight.UpdateViewMatrices(Camera.current);
				vLight.SetShaderPropertiesBlock();
			}
		}
		if (useInterleavedSampling)
		{
			float num2 = 0f;
			RenderSample(num2, pPCamera, temporary);
			num2 += ditherOffset;
			RenderSample(num2, pPCamera, temporary2);
			num2 += ditherOffset;
			RenderSample(num2, pPCamera, temporary3);
			num2 += ditherOffset;
			RenderSample(num2, pPCamera, temporary4);
			PostMaterial.SetTexture("_MainTexA", temporary);
			PostMaterial.SetTexture("_MainTexB", temporary2);
			PostMaterial.SetTexture("_MainTexC", temporary3);
			PostMaterial.SetTexture("_MainTexD", temporary4);
			Graphics.Blit(null, temporary5, PostMaterial, 0);
		}
		else
		{
			RenderSample(0f, pPCamera, temporary);
			Graphics.Blit(temporary, temporary5);
		}
		vLights = _vLights;
		foreach (VLight vLight2 in vLights)
		{
			if (!(vLight2 == null))
			{
				vLight2.lockTransforms = false;
			}
		}
		RenderTexture temporary6 = RenderTexture.GetTemporary(Screen.width, Screen.height, 0);
		PostMaterial.SetFloat("_BlurSize", blurRadius);
		for (int j = 0; j < blurIterations; j++)
		{
			Graphics.Blit(temporary5, temporary6, PostMaterial, 1);
			Graphics.Blit(temporary6, temporary5, PostMaterial, 2);
		}
		RenderTexture.ReleaseTemporary(temporary6);
		PostMaterial.SetTexture("_MainTexBlurred", temporary5);
		Graphics.Blit(source, destination, PostMaterial, 3);
		RenderTexture.ReleaseTemporary(temporary);
		RenderTexture.ReleaseTemporary(temporary2);
		RenderTexture.ReleaseTemporary(temporary3);
		RenderTexture.ReleaseTemporary(temporary4);
		RenderTexture.ReleaseTemporary(temporary5);
	}

	private void RenderSample(float offset, Camera ppCamera, RenderTexture buffer)
	{
		VLight[] vLights = _vLights;
		foreach (VLight vLight in vLights)
		{
			if (!(vLight == null))
			{
				vLight.SetInterleavedOffset(offset);
			}
		}
		ppCamera.projectionMatrix = GetComponent<Camera>().projectionMatrix;
		ppCamera.targetTexture = buffer;
		ppCamera.RenderWithShader(volumeLightShader, "RenderType");
	}

	private void Init()
	{
		if (LayerMask.NameToLayer("vlight") == -1 || !SystemInfo.supportsImageEffects)
		{
			UnityEngine.Debug.LogWarning("vlight layer does not exist! Cannot use interleaved sampling please add this layer.");
			return;
		}
		_volumeLightLayer = 1 << LayerMask.NameToLayer("vlight");
		GetComponent<Camera>().cullingMask &= ~(int)_volumeLightLayer;
		GetComponent<Camera>().depthTextureMode |= DepthTextureMode.DepthNormals;
		if (postEffectShader == null)
		{
			postEffectShader = Shader.Find("Hidden/V-Light/Post");
		}
		if (volumeLightShader == null)
		{
			volumeLightShader = Shader.Find("Hidden/V-Light/Light Depth");
		}
	}

	private void CleanUp()
	{
		GetComponent<Camera>().cullingMask |= _volumeLightLayer;
		if (Application.isEditor)
		{
			UnityEngine.Object.DestroyImmediate(_postMaterial);
		}
		else
		{
			UnityEngine.Object.Destroy(_postMaterial);
		}
	}

	private Camera GetPPCamera()
	{
		if (_ppCameraGO == null)
		{
			_ppCameraGO = new GameObject("Post Processing Camera", typeof(Camera));
			_ppCameraGO.GetComponent<Camera>().enabled = false;
			_ppCameraGO.hideFlags = HideFlags.HideAndDontSave;
		}
		return _ppCameraGO.GetComponent<Camera>();
	}
}
public static class VLightGeometryUtil
{
	private static Vector3[] _outputList = new Vector3[20];

	private static Vector3[] _inputList = new Vector3[20];

	public static void RecalculateFrustrumPoints(Camera camera, float aspectRatio, out Vector3[] _frustrumPoints)
	{
		float farClipPlane = camera.farClipPlane;
		float nearClipPlane = camera.nearClipPlane;
		if (!camera.orthographic)
		{
			float num = 2f * Mathf.Tan(camera.fieldOfView * 0.5f * ((float)Math.PI / 180f)) * nearClipPlane;
			float num2 = num * aspectRatio;
			float num3 = 2f * Mathf.Tan(camera.fieldOfView * 0.5f * ((float)Math.PI / 180f)) * farClipPlane;
			float num4 = num3 * aspectRatio;
			Vector3 vector = Vector3.forward * farClipPlane;
			Vector3 vector2 = vector + Vector3.up * num3 / 2f - Vector3.right * num4 / 2f;
			Vector3 vector3 = vector + Vector3.up * num3 / 2f + Vector3.right * num4 / 2f;
			Vector3 vector4 = vector - Vector3.up * num3 / 2f - Vector3.right * num4 / 2f;
			Vector3 vector5 = vector - Vector3.up * num3 / 2f + Vector3.right * num4 / 2f;
			Vector3 vector6 = Vector3.forward * nearClipPlane;
			Vector3 vector7 = vector6 + Vector3.up * num / 2f - Vector3.right * num2 / 2f;
			Vector3 vector8 = vector6 + Vector3.up * num / 2f + Vector3.right * num2 / 2f;
			Vector3 vector9 = vector6 - Vector3.up * num / 2f - Vector3.right * num2 / 2f;
			Vector3 vector10 = vector6 - Vector3.up * num / 2f + Vector3.right * num2 / 2f;
			_frustrumPoints = new Vector3[8];
			_frustrumPoints[0] = vector7;
			_frustrumPoints[1] = vector2;
			_frustrumPoints[2] = vector8;
			_frustrumPoints[3] = vector3;
			_frustrumPoints[4] = vector9;
			_frustrumPoints[5] = vector4;
			_frustrumPoints[6] = vector10;
			_frustrumPoints[7] = vector5;
		}
		else
		{
			float num5 = camera.orthographicSize * 0.5f;
			_frustrumPoints = new Vector3[8];
			_frustrumPoints[0] = new Vector3(0f - num5, num5, nearClipPlane);
			_frustrumPoints[1] = new Vector3(0f - num5, num5, farClipPlane);
			_frustrumPoints[2] = new Vector3(num5, num5, nearClipPlane);
			_frustrumPoints[3] = new Vector3(num5, num5, farClipPlane);
			_frustrumPoints[4] = new Vector3(0f - num5, 0f - num5, nearClipPlane);
			_frustrumPoints[5] = new Vector3(0f - num5, 0f - num5, farClipPlane);
			_frustrumPoints[6] = new Vector3(num5, 0f - num5, nearClipPlane);
			_frustrumPoints[7] = new Vector3(num5, 0f - num5, farClipPlane);
		}
	}

	public static Vector3[] ClipPolygonAgainstPlane(Vector3[] subjectPolygon, Plane[] planes)
	{
		int num = 0;
		int num2 = 0;
		Array.Copy(subjectPolygon, _outputList, subjectPolygon.Length);
		num = subjectPolygon.Length;
		for (int i = 0; i < planes.Length; i++)
		{
			Plane plane = planes[i];
			Array.Copy(_outputList, _inputList, num);
			num2 = num;
			num = 0;
			if (num2 == 0)
			{
				continue;
			}
			Vector3 vector = _inputList[num2 - 1];
			for (int j = 0; j < num2; j++)
			{
				Vector3 vector2 = _inputList[j];
				bool side = plane.GetSide(vector2);
				bool side2 = plane.GetSide(vector);
				if (side)
				{
					if (!side2 && ComputeIntersection(vector, vector2, plane, 0f, out var result))
					{
						_outputList[num++] = result;
					}
					_outputList[num++] = vector2;
				}
				else if (side2)
				{
					if (ComputeIntersection(vector, vector2, plane, 0f, out var result2))
					{
						_outputList[num++] = result2;
					}
					else
					{
						_outputList[num++] = vector2;
					}
				}
				vector = vector2;
			}
		}
		Vector3[] array = new Vector3[num];
		Array.Copy(_outputList, array, num);
		return array;
	}

	public static bool ComputeIntersection(Vector3 start, Vector3 end, Plane plane, float e, out Vector3 result)
	{
		Vector3 rhs = start - end;
		float num = Vector3.Dot(plane.normal, start) + plane.distance;
		float num2 = Vector3.Dot(plane.normal, rhs);
		float num3 = num / num2;
		if (Mathf.Abs(num3) < e)
		{
			result = Vector3.zero;
		}
		else
		{
			if (num3 > 0f && num3 < 1f)
			{
				result = (end - start) * num3 + start;
				return true;
			}
			result = Vector3.zero;
		}
		return false;
	}

	public static Vector4 Vector4Multiply(Vector4 right, Vector4 left)
	{
		return new Vector4(right.x * left.x, right.y * left.y, right.z * left.z, right.w * left.w);
	}

	public static Vector4 Vector4Frac(Vector4 vector)
	{
		return new Vector4(Frac(vector.x), Frac(vector.y), Frac(vector.z), Frac(vector.w));
	}

	public static float Frac(float value)
	{
		return value - (float)Mathf.FloorToInt(value);
	}

	public static Color FloatToRGBA(float value)
	{
		Vector4 vector = new Vector4(1f, 255f, 65025f, 160581380f) * value;
		vector = Vector4Frac(vector);
		vector -= Vector4Multiply(new Vector4(vector.y, vector.z, vector.w, vector.w), new Vector4(0.003921569f, 0.003921569f, 0.003921569f, 0f));
		return vector;
	}
}
[ExecuteInEditMode]
[RequireComponent(typeof(Camera))]
[RequireComponent(typeof(MeshRenderer))]
[RequireComponent(typeof(MeshFilter))]
public class VLight : MonoBehaviour
{
	public enum ShadowMode
	{
		None,
		Realtime,
		Baked
	}

	public enum LightTypes
	{
		Spot,
		Point
	}

	[SerializeField]
	[HideInInspector]
	private Material spotMaterial;

	[SerializeField]
	[HideInInspector]
	private Material pointMaterial;

	[SerializeField]
	[HideInInspector]
	private Shader renderDepthShader;

	[HideInInspector]
	public bool lockTransforms;

	[HideInInspector]
	public bool renderWireFrame = true;

	public LightTypes lightType;

	public float pointLightRadius = 1f;

	public float spotRange = 1f;

	public float spotNear = 1f;

	public float spotAngle = 45f;

	public ShadowMode shadowMode;

	public int slices = 30;

	[SerializeField]
	private Color colorTint = Color.white;

	[SerializeField]
	private float lightMultiplier = 1f;

	[SerializeField]
	private float spotExponent = 1f;

	[SerializeField]
	private float constantAttenuation = 1f;

	[SerializeField]
	private float linearAttenuation = 10f;

	[SerializeField]
	private float quadraticAttenuation = 100f;

	[SerializeField]
	private Vector3 noiseSpeed;

	[SerializeField]
	[HideInInspector]
	private Texture spotEmission;

	[SerializeField]
	[HideInInspector]
	private Texture spotNoise;

	[SerializeField]
	[HideInInspector]
	private Texture spotShadow;

	[SerializeField]
	[HideInInspector]
	private Cubemap pointEmission;

	[SerializeField]
	[HideInInspector]
	private Cubemap pointNoise;

	[SerializeField]
	[HideInInspector]
	private Cubemap pointShadow;

	[HideInInspector]
	[SerializeField]
	private Mesh meshContainer;

	[HideInInspector]
	[SerializeField]
	private Material _prevMaterialSpot;

	[HideInInspector]
	[SerializeField]
	private Material _prevMaterialPoint;

	[HideInInspector]
	[SerializeField]
	public Material _instancedSpotMaterial;

	[HideInInspector]
	[SerializeField]
	public Material _instancedPointMaterial;

	private MaterialPropertyBlock _propertyBlock;

	private int _idColorTint;

	private int _idLightMultiplier;

	private int _idSpotExponent;

	private int _idConstantAttenuation;

	private int _idLinearAttenuation;

	private int _idQuadraticAttenuation;

	private int _idLightParams;

	private int _idMinBounds;

	private int _idMaxBounds;

	private int _idViewWorldLight;

	private int _idRotation;

	private int _idLocalRotation;

	private int _idProjection;

	private LightTypes _prevLightType;

	private ShadowMode _prevShadowMode;

	private int _prevSlices;

	private bool _frustrumSwitch;

	private bool _prevIsOrtho;

	private float _prevNear;

	private float _prevFar;

	private float _prevFov;

	private float _prevOrthoSize;

	private float _prevPointLightRadius;

	private Matrix4x4 _worldToCamera;

	private Matrix4x4 _projectionMatrixCached;

	private Matrix4x4 _viewWorldToCameraMatrixCached;

	private Matrix4x4 _viewCameraToWorldMatrixCached;

	private Matrix4x4 _localToWorldMatrix;

	private Matrix4x4 _rotation;

	private Matrix4x4 _localRotation;

	private Matrix4x4 _viewWorldLight;

	private Vector3[] _frustrumPoints;

	private Vector3 _angle = Vector3.zero;

	private Vector3 _minBounds;

	private Vector3 _maxBounds;

	private bool _cameraHasBeenUpdated;

	private MeshFilter _meshFilter;

	private RenderTexture _depthTexture;

	private const int VERT_COUNT = 65000;

	private const int TRI_COUNT = 195000;

	private const StringComparison STR_CMP_TYPE = StringComparison.OrdinalIgnoreCase;

	private int _maxSlices;

	public int MaxSlices
	{
		get
		{
			return _maxSlices;
		}
		set
		{
			_maxSlices = value;
		}
	}

	public void OnEnable()
	{
		_maxSlices = slices;
		int num = LayerMask.NameToLayer("vlight");
		if (num != -1)
		{
			base.gameObject.layer = num;
		}
		GetComponent<Camera>().enabled = false;
		GetComponent<Camera>().cullingMask &= ~(1 << base.gameObject.layer);
		CreateMaterials();
	}

	private void OnApplicationQuit()
	{
	}

	private void OnDestroy()
	{
		CleanMaterials();
		SafeDestroy(_depthTexture);
		SafeDestroy(meshContainer);
	}

	private void Start()
	{
		CreateMaterials();
		spotNear = GetComponent<Camera>().nearClipPlane;
		spotRange = GetComponent<Camera>().farClipPlane;
		spotAngle = GetComponent<Camera>().fieldOfView;
	}

	public void Reset()
	{
		CleanMaterials();
		SafeDestroy(_depthTexture);
		SafeDestroy(meshContainer);
	}

	public bool GenerateNewMaterial(Material originalMaterial, ref Material instancedMaterial)
	{
		string text = GetInstanceID().ToString();
		if (originalMaterial != null && (instancedMaterial == null || instancedMaterial.name.IndexOf(text, StringComparison.OrdinalIgnoreCase) < 0 || instancedMaterial.name.IndexOf(originalMaterial.name, StringComparison.OrdinalIgnoreCase) < 0))
		{
			if (!originalMaterial.shader.isSupported)
			{
				UnityEngine.Debug.LogError("Volumetric light shader not supported");
				base.enabled = false;
				return false;
			}
			Material source = originalMaterial;
			if (instancedMaterial != null && instancedMaterial.name.IndexOf(originalMaterial.name, StringComparison.OrdinalIgnoreCase) > 0)
			{
				source = instancedMaterial;
			}
			instancedMaterial = new Material(source);
			instancedMaterial.name = text + " " + originalMaterial.name;
		}
		return true;
	}

	public void CreateMaterials()
	{
		_propertyBlock = new MaterialPropertyBlock();
		_idColorTint = Shader.PropertyToID("_Color");
		_idLightMultiplier = Shader.PropertyToID("_Strength");
		_idSpotExponent = Shader.PropertyToID("_SpotExp");
		_idConstantAttenuation = Shader.PropertyToID("_ConstantAttn");
		_idLinearAttenuation = Shader.PropertyToID("_LinearAttn");
		_idQuadraticAttenuation = Shader.PropertyToID("_QuadAttn");
		_idLightParams = Shader.PropertyToID("_LightParams");
		_idMinBounds = Shader.PropertyToID("_minBounds");
		_idMaxBounds = Shader.PropertyToID("_maxBounds");
		_idViewWorldLight = Shader.PropertyToID("_ViewWorldLight");
		_idLocalRotation = Shader.PropertyToID("_LocalRotation");
		_idRotation = Shader.PropertyToID("_Rotation");
		_idProjection = Shader.PropertyToID("_Projection");
		if (((lightType == LightTypes.Spot) ? _instancedSpotMaterial : _instancedPointMaterial) == null)
		{
			if (lightType != 0)
			{
				_ = pointMaterial;
			}
			else
			{
				_ = spotMaterial;
			}
		}
		if (_instancedSpotMaterial != null)
		{
			spotEmission = _instancedSpotMaterial.GetTexture("_LightColorEmission");
			spotNoise = _instancedSpotMaterial.GetTexture("_NoiseTex");
			spotShadow = _instancedSpotMaterial.GetTexture("_ShadowTexture");
		}
		if (_instancedPointMaterial != null)
		{
			pointEmission = _instancedPointMaterial.GetTexture("_LightColorEmission") as Cubemap;
			pointNoise = _instancedPointMaterial.GetTexture("_NoiseTex") as Cubemap;
			pointShadow = _instancedPointMaterial.GetTexture("_ShadowTexture") as Cubemap;
		}
		if ((0u | (GenerateNewMaterial(pointMaterial, ref _instancedPointMaterial) ? 1u : 0u) | (GenerateNewMaterial(spotMaterial, ref _instancedSpotMaterial) ? 1u : 0u)) == 0)
		{
			return;
		}
		switch (lightType)
		{
		case LightTypes.Point:
			GetComponent<Renderer>().sharedMaterial = _instancedPointMaterial;
			if (pointEmission != null)
			{
				GetComponent<Renderer>().sharedMaterial.SetTexture("_LightColorEmission", pointEmission);
			}
			if (pointNoise != null)
			{
				GetComponent<Renderer>().sharedMaterial.SetTexture("_NoiseTex", pointNoise);
			}
			if (pointShadow != null)
			{
				GetComponent<Renderer>().sharedMaterial.SetTexture("_ShadowTexture", pointShadow);
			}
			break;
		case LightTypes.Spot:
			GetComponent<Renderer>().sharedMaterial = _instancedSpotMaterial;
			if (spotEmission != null)
			{
				GetComponent<Renderer>().sharedMaterial.SetTexture("_LightColorEmission", spotEmission);
			}
			if (spotNoise != null)
			{
				GetComponent<Renderer>().sharedMaterial.SetTexture("_NoiseTex", spotNoise);
			}
			if (spotShadow != null)
			{
				GetComponent<Renderer>().sharedMaterial.SetTexture("_ShadowTexture", spotShadow);
			}
			break;
		}
	}

	private void CleanMaterials()
	{
		SafeDestroy(_instancedSpotMaterial);
		SafeDestroy(_instancedPointMaterial);
		SafeDestroy(GetComponent<Renderer>().sharedMaterial);
		SafeDestroy(meshContainer);
		_prevMaterialPoint = null;
		_prevMaterialSpot = null;
		_instancedSpotMaterial = null;
		_instancedPointMaterial = null;
		meshContainer = null;
	}

	private void OnDrawGizmosSelected()
	{
		if (_frustrumPoints != null)
		{
			Gizmos.color = new Color(0f, 1f, 0f, 0.2f);
			Gizmos.DrawLine(base.transform.TransformPoint(_frustrumPoints[0]), base.transform.TransformPoint(_frustrumPoints[1]));
			Gizmos.DrawLine(base.transform.TransformPoint(_frustrumPoints[2]), base.transform.TransformPoint(_frustrumPoints[3]));
			Gizmos.DrawLine(base.transform.TransformPoint(_frustrumPoints[4]), base.transform.TransformPoint(_frustrumPoints[5]));
			Gizmos.DrawLine(base.transform.TransformPoint(_frustrumPoints[6]), base.transform.TransformPoint(_frustrumPoints[7]));
			Gizmos.DrawLine(base.transform.TransformPoint(_frustrumPoints[1]), base.transform.TransformPoint(_frustrumPoints[3]));
			Gizmos.DrawLine(base.transform.TransformPoint(_frustrumPoints[3]), base.transform.TransformPoint(_frustrumPoints[7]));
			Gizmos.DrawLine(base.transform.TransformPoint(_frustrumPoints[7]), base.transform.TransformPoint(_frustrumPoints[5]));
			Gizmos.DrawLine(base.transform.TransformPoint(_frustrumPoints[5]), base.transform.TransformPoint(_frustrumPoints[1]));
			Gizmos.DrawLine(base.transform.TransformPoint(_frustrumPoints[0]), base.transform.TransformPoint(_frustrumPoints[2]));
			Gizmos.DrawLine(base.transform.TransformPoint(_frustrumPoints[2]), base.transform.TransformPoint(_frustrumPoints[6]));
			Gizmos.DrawLine(base.transform.TransformPoint(_frustrumPoints[6]), base.transform.TransformPoint(_frustrumPoints[4]));
			Gizmos.DrawLine(base.transform.TransformPoint(_frustrumPoints[4]), base.transform.TransformPoint(_frustrumPoints[0]));
		}
	}

	private void CalculateMinMax(out Vector3 min, out Vector3 max, bool forceFrustrumUpdate)
	{
		if (_frustrumPoints == null || forceFrustrumUpdate)
		{
			VLightGeometryUtil.RecalculateFrustrumPoints(GetComponent<Camera>(), 1f, out _frustrumPoints);
		}
		Vector3[] array = new Vector3[8];
		Vector3 vector = new Vector3(float.NegativeInfinity, float.NegativeInfinity, float.NegativeInfinity);
		Vector3 vector2 = new Vector3(float.PositiveInfinity, float.PositiveInfinity, float.PositiveInfinity);
		Matrix4x4 matrix4x = _viewWorldToCameraMatrixCached * _localToWorldMatrix;
		for (int i = 0; i < _frustrumPoints.Length; i++)
		{
			array[i] = matrix4x.MultiplyPoint(_frustrumPoints[i]);
			vector.x = ((vector.x > array[i].x) ? vector.x : array[i].x);
			vector.y = ((vector.y > array[i].y) ? vector.y : array[i].y);
			vector.z = ((vector.z > array[i].z) ? vector.z : array[i].z);
			vector2.x = ((vector2.x <= array[i].x) ? vector2.x : array[i].x);
			vector2.y = ((vector2.y <= array[i].y) ? vector2.y : array[i].y);
			vector2.z = ((vector2.z <= array[i].z) ? vector2.z : array[i].z);
		}
		min = vector;
		max = vector2;
	}

	private Matrix4x4 CalculateProjectionMatrix()
	{
		if (!GetComponent<Camera>().orthographic)
		{
			return Matrix4x4.Perspective(GetComponent<Camera>().fieldOfView, 1f, GetComponent<Camera>().nearClipPlane, GetComponent<Camera>().farClipPlane);
		}
		float num = GetComponent<Camera>().orthographicSize * 0.5f;
		return Matrix4x4.Ortho(0f - num, num, 0f - num, num, GetComponent<Camera>().farClipPlane, GetComponent<Camera>().nearClipPlane);
	}

	private void BuildMesh(bool manualPositioning, int planeCount, Vector3 minBounds, Vector3 maxBounds)
	{
		if (meshContainer == null || meshContainer.name.IndexOf(GetInstanceID().ToString(), StringComparison.OrdinalIgnoreCase) != 0)
		{
			meshContainer = new Mesh();
			meshContainer.hideFlags = HideFlags.HideAndDontSave;
			meshContainer.name = GetInstanceID().ToString();
		}
		if (_meshFilter == null)
		{
			_meshFilter = GetComponent<MeshFilter>();
		}
		Vector3[] array = new Vector3[65000];
		int[] array2 = new int[195000];
		int num = 0;
		int num2 = 0;
		float num3 = 1f / (float)(planeCount - 1);
		float num4 = (manualPositioning ? 1f : 0f);
		float x = 0f;
		float x2 = 1f;
		float y = 0f;
		float y2 = 1f;
		int num5 = 0;
		for (int i = 0; i < planeCount; i++)
		{
			Vector3[] array3 = new Vector3[4];
			Vector3[] array5;
			if (manualPositioning)
			{
				Plane[] array4 = GeometryUtility.CalculateFrustumPlanes(_projectionMatrixCached * GetComponent<Camera>().worldToCameraMatrix);
				for (int j = 0; j < array4.Length; j++)
				{
					Vector3 point = array4[j].normal * (0f - array4[j].distance);
					array4[j] = new Plane(_viewWorldToCameraMatrixCached.MultiplyVector(array4[j].normal), _viewWorldToCameraMatrixCached.MultiplyPoint3x4(point));
				}
				array3[0] = CalculateTriLerp(new Vector3(x, y, num4), minBounds, maxBounds);
				array3[1] = CalculateTriLerp(new Vector3(x, y2, num4), minBounds, maxBounds);
				array3[2] = CalculateTriLerp(new Vector3(x2, y2, num4), minBounds, maxBounds);
				array3[3] = CalculateTriLerp(new Vector3(x2, y, num4), minBounds, maxBounds);
				array5 = VLightGeometryUtil.ClipPolygonAgainstPlane(array3, array4);
			}
			else
			{
				array3[0] = new Vector3(x, y, num4);
				array3[1] = new Vector3(x, y2, num4);
				array3[2] = new Vector3(x2, y2, num4);
				array3[3] = new Vector3(x2, y, num4);
				array5 = array3;
			}
			num4 += (manualPositioning ? (0f - num3) : num3);
			if (array5.Length > 2)
			{
				Array.Copy(array5, 0, array, num, array5.Length);
				num += array5.Length;
				int[] array6 = new int[(array5.Length - 2) * 3];
				int num6 = 0;
				for (int k = 0; k < array6.Length; k += 3)
				{
					array6[k] = num5;
					array6[k + 1] = num5 + (num6 + 1);
					array6[k + 2] = num5 + (num6 + 2);
					num6++;
				}
				num5 += array5.Length;
				Array.Copy(array6, 0, array2, num2, array6.Length);
				num2 += array6.Length;
			}
		}
		meshContainer.Clear();
		Vector3[] array7 = new Vector3[num];
		Array.Copy(array, array7, num);
		meshContainer.vertices = array7;
		int[] array8 = new int[num2];
		Array.Copy(array2, array8, num2);
		meshContainer.triangles = array8;
		meshContainer.normals = new Vector3[num];
		meshContainer.uv = new Vector2[num];
		Vector3 zero = Vector3.zero;
		Vector3[] frustrumPoints = _frustrumPoints;
		foreach (Vector3 vector in frustrumPoints)
		{
			zero += vector;
		}
		zero /= (float)_frustrumPoints.Length;
		Bounds bounds = new Bounds(zero, Vector3.zero);
		frustrumPoints = _frustrumPoints;
		foreach (Vector3 point2 in frustrumPoints)
		{
			bounds.Encapsulate(point2);
		}
		_meshFilter.sharedMesh = meshContainer;
		_meshFilter.sharedMesh.bounds = bounds;
	}

	private Vector3 CalculateTriLerp(Vector3 vertex, Vector3 minBounds, Vector3 maxBounds)
	{
		Vector3 vector = new Vector3(1f, 1f, 1f) - vertex;
		return new Vector3(minBounds.x * vertex.x, minBounds.y * vertex.y, maxBounds.z * vertex.z) + new Vector3(maxBounds.x * vector.x, maxBounds.y * vector.y, minBounds.z * vector.z);
	}

	private void RenderShadowMap()
	{
		switch (shadowMode)
		{
		case ShadowMode.Realtime:
		{
			if (!SystemInfo.supportsImageEffects)
			{
				break;
			}
			int num = LayerMask.NameToLayer("vlight");
			if (num != -1)
			{
				base.gameObject.layer = num;
				GetComponent<Camera>().backgroundColor = Color.red;
				GetComponent<Camera>().clearFlags = CameraClearFlags.Color;
				GetComponent<Camera>().depthTextureMode = DepthTextureMode.None;
				GetComponent<Camera>().renderingPath = RenderingPath.VertexLit;
				CreateDepthTexture(lightType);
				if (renderDepthShader == null)
				{
					renderDepthShader = Shader.Find("Hidden/V-Light/Depth");
				}
				switch (lightType)
				{
				case LightTypes.Spot:
					GetComponent<Camera>().targetTexture = _depthTexture;
					GetComponent<Camera>().projectionMatrix = CalculateProjectionMatrix();
					GetComponent<Camera>().RenderWithShader(renderDepthShader, "RenderType");
					break;
				case LightTypes.Point:
					GetComponent<Camera>().projectionMatrix = Matrix4x4.Perspective(90f, 1f, 0.1f, GetComponent<Camera>().farClipPlane);
					GetComponent<Camera>().SetReplacementShader(renderDepthShader, "RenderType");
					GetComponent<Camera>().RenderToCubemap(_depthTexture, 63);
					GetComponent<Camera>().ResetReplacementShader();
					break;
				}
			}
			break;
		}
		case ShadowMode.None:
		case ShadowMode.Baked:
			break;
		}
	}

	private RenderTexture GenerateShadowMap(int resX, int resY)
	{
		return new RenderTexture(256, 256, 1, RenderTextureFormat.ARGB32, RenderTextureReadWrite.Linear);
	}

	private void CreateDepthTexture(LightTypes type)
	{
		if (_depthTexture == null)
		{
			_depthTexture = GenerateShadowMap(256, 256);
			_depthTexture.hideFlags = HideFlags.HideAndDontSave;
			_depthTexture.isPowerOfTwo = true;
			if (type == LightTypes.Point)
			{
				_depthTexture.isCubemap = true;
			}
		}
		else if (type == LightTypes.Point && !_depthTexture.isCubemap && _depthTexture.IsCreated())
		{
			SafeDestroy(_depthTexture);
			_depthTexture = GenerateShadowMap(256, 256);
			_depthTexture.hideFlags = HideFlags.HideAndDontSave;
			_depthTexture.isPowerOfTwo = true;
			_depthTexture.isCubemap = true;
		}
		else if (type == LightTypes.Spot && _depthTexture.isCubemap && _depthTexture.IsCreated())
		{
			SafeDestroy(_depthTexture);
			_depthTexture = GenerateShadowMap(512, 512);
			_depthTexture.hideFlags = HideFlags.HideAndDontSave;
			_depthTexture.isPowerOfTwo = true;
			_depthTexture.isCubemap = false;
		}
	}

	private void LateUpdate()
	{
		if (Application.isPlaying)
		{
			if (VLightManager.Instance.targetCamera != null)
			{
				UpdateViewMatrices(VLightManager.Instance.targetCamera);
			}
			else if (Camera.main != null)
			{
				UpdateViewMatrices(Camera.main);
			}
		}
		else if (Camera.current != null)
		{
			UpdateViewMatrices(Camera.current);
		}
		RenderShadowMap();
	}

	private void OnWillRenderObject()
	{
		if (spotMaterial == null || pointMaterial == null || _instancedSpotMaterial == null || _instancedPointMaterial == null)
		{
			UnityEngine.Debug.Log("Materials not initialized");
			CreateMaterials();
		}
		else
		{
			if (lockTransforms)
			{
				return;
			}
			UpdateSettings();
			UpdateLightMatrices();
			if (Application.isPlaying)
			{
				if (VLightManager.Instance.targetCamera != null)
				{
					UpdateViewMatrices(VLightManager.Instance.targetCamera);
				}
				else
				{
					UpdateViewMatrices(Camera.main);
				}
			}
			else if (Camera.current != null)
			{
				UpdateViewMatrices(Camera.current);
			}
			SetShaderPropertiesBlock();
		}
	}

	private bool CameraHasBeenUpdated()
	{
		return false | (_meshFilter == null || _meshFilter.sharedMesh == null) | (spotRange != _prevFar) | (spotNear != _prevNear) | (spotAngle != _prevFov) | (GetComponent<Camera>().orthographicSize != _prevOrthoSize) | (GetComponent<Camera>().orthographic != _prevIsOrtho) | (pointLightRadius != _prevPointLightRadius) | (spotMaterial != _prevMaterialSpot) | (pointMaterial != _prevMaterialPoint) | (_prevSlices != slices) | (_prevShadowMode != shadowMode) | (_prevLightType != lightType);
	}

	public void UpdateSettings()
	{
		_cameraHasBeenUpdated = CameraHasBeenUpdated();
		if (_cameraHasBeenUpdated)
		{
			switch (lightType)
			{
			case LightTypes.Point:
				GetComponent<Renderer>().sharedMaterial = _instancedPointMaterial;
				GetComponent<Camera>().orthographic = true;
				GetComponent<Camera>().nearClipPlane = 0f - pointLightRadius;
				GetComponent<Camera>().farClipPlane = pointLightRadius;
				GetComponent<Camera>().orthographicSize = pointLightRadius * 2f;
				break;
			case LightTypes.Spot:
				GetComponent<Renderer>().sharedMaterial = _instancedSpotMaterial;
				GetComponent<Camera>().farClipPlane = spotRange;
				GetComponent<Camera>().nearClipPlane = spotNear;
				GetComponent<Camera>().fieldOfView = spotAngle;
				GetComponent<Camera>().orthographic = false;
				break;
			}
			if ((shadowMode == ShadowMode.None || shadowMode == ShadowMode.Baked) && _depthTexture != null)
			{
				SafeDestroy(_depthTexture);
			}
		}
		_prevSlices = slices;
		_prevFov = GetComponent<Camera>().fieldOfView;
		_prevNear = GetComponent<Camera>().nearClipPlane;
		_prevFar = GetComponent<Camera>().farClipPlane;
		_prevIsOrtho = GetComponent<Camera>().orthographic;
		_prevOrthoSize = GetComponent<Camera>().orthographicSize;
		_prevMaterialSpot = spotMaterial;
		_prevMaterialPoint = pointMaterial;
		_prevShadowMode = shadowMode;
		_prevLightType = lightType;
		_prevPointLightRadius = pointLightRadius;
	}

	public void UpdateLightMatrices()
	{
		_localToWorldMatrix = base.transform.localToWorldMatrix;
		_worldToCamera = GetComponent<Camera>().worldToCameraMatrix;
		_rotation = Matrix4x4.TRS(Vector3.zero, Quaternion.Euler(_angle.x, _angle.y, _angle.z), Vector3.one);
		_angle += noiseSpeed * Time.deltaTime;
		RebuildMesh();
	}

	public void UpdateViewMatrices(Camera targetCamera)
	{
		_viewWorldToCameraMatrixCached = targetCamera.worldToCameraMatrix;
		_viewCameraToWorldMatrixCached = targetCamera.cameraToWorldMatrix;
		switch (lightType)
		{
		case LightTypes.Spot:
			_viewWorldLight = _worldToCamera * _viewCameraToWorldMatrixCached;
			break;
		case LightTypes.Point:
		{
			Matrix4x4 matrix4x = Matrix4x4.TRS(-base.transform.position, Quaternion.identity, Vector3.one);
			_localRotation = Matrix4x4.TRS(Vector3.zero, base.transform.rotation, Vector3.one);
			_viewWorldLight = matrix4x * _viewCameraToWorldMatrixCached;
			break;
		}
		}
	}

	public void SetInterleavedOffset(float value)
	{
		GetComponent<Renderer>().sharedMaterial.SetFloat("_Offset", value);
	}

	public void RebuildMesh()
	{
		CalculateMinMax(out _minBounds, out _maxBounds, _cameraHasBeenUpdated);
		if (_cameraHasBeenUpdated)
		{
			_projectionMatrixCached = CalculateProjectionMatrix();
			CreateMaterials();
			BuildMesh(manualPositioning: false, slices, _minBounds, _maxBounds);
		}
	}

	public void SetShaderPropertiesBlock()
	{
		MaterialPropertyBlock propertyBlock = _propertyBlock;
		propertyBlock.SetVector(_idMinBounds, _minBounds);
		propertyBlock.SetVector(_idMaxBounds, _maxBounds);
		propertyBlock.SetMatrix(_idProjection, _projectionMatrixCached);
		propertyBlock.SetMatrix(_idViewWorldLight, _viewWorldLight);
		propertyBlock.SetMatrix(_idLocalRotation, _localRotation);
		propertyBlock.SetMatrix(_idRotation, _rotation);
		propertyBlock.SetColor(_idColorTint, colorTint);
		propertyBlock.SetFloat(_idSpotExponent, spotExponent);
		propertyBlock.SetFloat(_idConstantAttenuation, constantAttenuation);
		propertyBlock.SetFloat(_idLinearAttenuation, linearAttenuation);
		propertyBlock.SetFloat(_idQuadraticAttenuation, quadraticAttenuation);
		propertyBlock.SetFloat(_idLightMultiplier, lightMultiplier);
		switch (shadowMode)
		{
		case ShadowMode.Realtime:
			GetComponent<Renderer>().sharedMaterial.SetTexture("_ShadowTexture", _depthTexture);
			break;
		case ShadowMode.None:
			GetComponent<Renderer>().sharedMaterial.SetTexture("_ShadowTexture", null);
			break;
		}
		float farClipPlane = GetComponent<Camera>().farClipPlane;
		float nearClipPlane = GetComponent<Camera>().nearClipPlane;
		propertyBlock.SetVector(_idLightParams, new Vector4(nearClipPlane, farClipPlane, farClipPlane - nearClipPlane, GetComponent<Camera>().orthographic ? ((float)Math.PI) : (GetComponent<Camera>().fieldOfView * 0.5f * ((float)Math.PI / 180f))));
		GetComponent<Renderer>().SetPropertyBlock(_propertyBlock);
	}

	public void SetShaderPropertiesMaterials()
	{
		Material sharedMaterial = GetComponent<Renderer>().sharedMaterial;
		sharedMaterial.SetVector("_minBounds", _minBounds);
		sharedMaterial.SetVector("_maxBounds", _maxBounds);
		sharedMaterial.SetMatrix("_Projection", _projectionMatrixCached);
		sharedMaterial.SetMatrix("_ViewWorldLight", _viewWorldLight);
		sharedMaterial.SetMatrix("_LocalRotation", _localRotation);
		sharedMaterial.SetMatrix("_Rotation", _rotation);
		Plane[] array = GeometryUtility.CalculateFrustumPlanes(_projectionMatrixCached);
		switch (lightType)
		{
		case LightTypes.Point:
		{
			for (int j = 0; j < array.Length; j++)
			{
				Vector3 vector = base.transform.TransformDirection(array[j].normal);
				float distance2 = array[j].distance;
				sharedMaterial.SetVector("_FrustrumPlane" + j, new Vector4(vector.x, vector.y, vector.z, distance2));
			}
			break;
		}
		case LightTypes.Spot:
		{
			for (int i = 0; i < array.Length; i++)
			{
				Vector3 normal = array[i].normal;
				float distance = array[i].distance;
				sharedMaterial.SetVector("_FrustrumPlane" + i, new Vector4(normal.x, normal.y, normal.z, distance));
			}
			break;
		}
		}
		switch (shadowMode)
		{
		case ShadowMode.Realtime:
			sharedMaterial.SetTexture("_ShadowTexture", _depthTexture);
			break;
		case ShadowMode.None:
			sharedMaterial.SetTexture("_ShadowTexture", null);
			break;
		}
		float farClipPlane = GetComponent<Camera>().farClipPlane;
		float nearClipPlane = GetComponent<Camera>().nearClipPlane;
		sharedMaterial.SetVector("_LightParams", new Vector4(nearClipPlane, farClipPlane, farClipPlane - nearClipPlane, GetComponent<Camera>().orthographic ? ((float)Math.PI) : (GetComponent<Camera>().fieldOfView * 0.5f * ((float)Math.PI / 180f))));
	}

	private void SafeDestroy(UnityEngine.Object obj)
	{
		if (obj != null)
		{
			if (Application.isPlaying)
			{
				UnityEngine.Object.Destroy(obj);
			}
			else
			{
				UnityEngine.Object.DestroyImmediate(obj, allowDestroyingAssets: true);
			}
		}
		obj = null;
	}
}
[ExecuteInEditMode]
public class VLightManager : MonoBehaviour
{
	public const string VOLUMETRIC_LIGHT_LAYER_NAME = "vlight";

	public Camera targetCamera;

	public float maxDistance = 50f;

	private static VLightManager _instance;

	private Matrix4x4 _projection;

	private Matrix4x4 _cameraToWorld;

	private Matrix4x4 _worldToCamera;

	private List<VLight> _vLights = new List<VLight>();

	public static VLightManager Instance
	{
		get
		{
			if (_instance == null)
			{
				_instance = UnityEngine.Object.FindObjectOfType(typeof(VLightManager)) as VLightManager;
				if (_instance == null)
				{
					_instance = new GameObject("Volume Light Manager").AddComponent<VLightManager>();
				}
			}
			return _instance;
		}
	}

	public Matrix4x4 ViewProjection => _projection;

	public Matrix4x4 ViewCameraToWorldMatrix => _cameraToWorld;

	public Matrix4x4 ViewWorldToCameraMatrix => _worldToCamera;

	public List<VLight> VLights
	{
		get
		{
			return _vLights;
		}
		set
		{
			_vLights = value;
		}
	}

	public void UpdateViewCamera(Camera viewCam)
	{
		if (!(viewCam == null))
		{
			_cameraToWorld = viewCam.cameraToWorldMatrix;
			_worldToCamera = viewCam.worldToCameraMatrix;
			_projection = viewCam.projectionMatrix;
		}
	}

	private void Update()
	{
		if (Application.isPlaying)
		{
			Camera camera = ((Camera.current != null) ? Camera.current : ((!(targetCamera != null)) ? Camera.main : targetCamera));
			_ = camera == null;
		}
	}

	private void Start()
	{
		_vLights.Clear();
		VLight[] collection = UnityEngine.Object.FindObjectsOfType(typeof(VLight)) as VLight[];
		_vLights.AddRange(collection);
	}

	private void Enabled()
	{
		_vLights.Clear();
		VLight[] collection = UnityEngine.Object.FindObjectsOfType(typeof(VLight)) as VLight[];
		_vLights.AddRange(collection);
	}
}
[ExecuteInEditMode]
public class DissoveSetPos : MonoBehaviour
{
	public Transform endTF;

	public Transform startTF;

	public Transform playerTF;

	public float exitRange;

	public float destoryDelay = 2f;

	public float distanceFog;

	public float distancePlayer;

	public float distanceEnd;

	public Material matDog;

	public Material tempMat;

	private void Start()
	{
		playerTF = MonoSingleton<PlayerInfo>.Instance.EasyVRHead.transform;
	}

	private void Update()
	{
		if (endTF != null && startTF != null && startTF != null)
		{
			distanceFog = Vector3.Distance(startTF.position, base.transform.parent.position);
			distancePlayer = Vector3.Distance(playerTF.position, base.transform.parent.position);
			distanceEnd = Vector3.Distance(endTF.position, base.transform.parent.position);
			if (distanceFog < exitRange && distancePlayer > exitRange && distanceEnd > exitRange)
			{
				matDog.SetVector("_Target", startTF.position);
				MonoBehaviour.print("Fog" + (distanceFog < exitRange) + (distancePlayer > exitRange) + (distanceEnd > exitRange));
			}
			if (distanceFog > exitRange && distancePlayer < exitRange && distanceEnd > exitRange)
			{
				matDog.SetVector("_Target", playerTF.position);
				MonoBehaviour.print("Player");
			}
			if (distanceFog > exitRange && distancePlayer > exitRange && distanceEnd < exitRange)
			{
				matDog.SetVector("_Target", endTF.position);
				MonoBehaviour.print("Exit");
			}
		}
	}
}
public class SJE_MaskDrop : MonoBehaviour
{
	public float speed = 1f;

	public float upForce = 1f;

	public float scalingSpeed = 0.1f;

	private bool isScaling;

	public bool isLookCam = true;

	public bool isUseVRCam = true;

	public Transform cameraTF;

	public BoxCollider Region_GiveForce;

	public Transform SJE_group;

	public Rigidbody WoodenScreenRB;

	private Rigidbody rb;

	private void Start()
	{
		if (isUseVRCam)
		{
			cameraTF = MonoSingleton<PlayerInfo>.Instance.EasyVRHead.transform;
		}
		rb = GetComponent<Rigidbody>();
	}

	private void FixedUpdate()
	{
		if (isLookCam)
		{
			Vector3 worldPosition = new Vector3(cameraTF.position.x, SJE_group.position.y, cameraTF.position.z);
			SJE_group.LookAt(worldPosition);
		}
		if (isScaling)
		{
			base.transform.localScale *= 1f + Time.fixedDeltaTime * scalingSpeed;
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other == Region_GiveForce)
		{
			GetComponent<Collider>().isTrigger = true;
			isScaling = true;
			isLookCam = false;
			rb.useGravity = false;
			base.transform.LookAt(cameraTF.position);
			Vector3 vector = cameraTF.position + new Vector3(0f, cameraTF.position.y * upForce, 0f) - base.transform.position;
			rb.velocity = vector * speed;
			UnityEngine.Object.Destroy(base.gameObject, 1f);
		}
	}

	public void FlyHead()
	{
		MonoBehaviour.print("开始飞头");
		GetComponent<Collider>().isTrigger = true;
		isScaling = true;
		isLookCam = false;
		rb.useGravity = false;
		base.transform.LookAt(cameraTF.position);
		Vector3 vector = cameraTF.position + new Vector3(0f, cameraTF.position.y * upForce, 0f) - base.transform.position;
		rb.velocity = vector * speed;
		UnityEngine.Object.Destroy(base.gameObject, 1f);
	}
}
public class LayerCullDistances : MonoBehaviour
{
	private void Start()
	{
		Camera component = GetComponent<Camera>();
		float[] array = new float[32];
		array[9] = 4f;
		component.layerCullDistances = array;
	}
}
public class MovementTest : MonoBehaviour
{
	public Transform head;

	public Transform offsetObj;

	private Vector3 offset;

	private void Start()
	{
	}

	private void LateUpdate()
	{
		Vector3 position = base.transform.position;
		Vector3 position2 = offsetObj.position;
		offset = base.transform.position - head.position;
		base.transform.position = position + offset + Vector3.up * 2.2f;
		offsetObj.position = position2 - offset + Vector3.up * 1.1f;
	}
}
public class ComputerInfo : MonoBehaviour
{
	private void Start()
	{
	}
}
public class Config : Singleton<Config>
{
	public float SoundVolume = 1f;
}
public class FantasyRoom_2WomanGhost : MJListen
{
	public BoxCollider picture;

	public override void OnTrigger()
	{
		base.OnTrigger();
		GetComponent<Animator>().enabled = true;
	}

	public void OpenPic()
	{
		picture.enabled = true;
	}
}
public class BackpackManager : MonoSingleton<BackpackManager>
{
	public ItemInfo[] dataBase;

	public Dictionary<ItemType, ItemInfo> DataDict = new Dictionary<ItemType, ItemInfo>();

	public Dictionary<ItemType, ItemInfo> ClueDict = new Dictionary<ItemType, ItemInfo>();

	public ItemInfo[] backpack = new ItemInfo[9];

	public List<ItemType> clueLst = new List<ItemType>();

	public ItemType selectedType;

	private Vector3 originPos = Vector3.one;

	internal string GetItemIsHave(object _130105_线索_幻室_神秘相框)
	{
		throw new NotImplementedException();
	}

	private void Start()
	{
		EventManager.AddListener(MJFSM.Process._0004数据加载完成, Init);
		InitBackpackArray();
	}

	private void Init()
	{
		foreach (KeyValuePair<ItemType, ItemInfo> item in DataDict)
		{
			if (item.Value.GetOperationType() == OperationType._1_线索)
			{
				ClueDict.Add(item.Key, item.Value);
				clueLst.Add(item.Key);
			}
		}
	}

	public void InitBackpackArray()
	{
		backpack = new ItemInfo[9];
	}

	public void RemoveItemInfoInBackpackArray(ItemType type, bool isHave = false)
	{
		if (backpack.Length == 0)
		{
			UnityEngine.Debug.LogError("背包数组长度为0");
			return;
		}
		for (int i = 0; i < backpack.Length; i++)
		{
			if (backpack[i] != null && backpack[i].id != 0 && backpack[i].id == type)
			{
				backpack[i].isHave = isHave;
				backpack[i] = new ItemInfo();
			}
		}
	}

	public bool AddItem(ItemType itemType)
	{
		if (DataDict.ContainsKey(itemType) || itemType != 0)
		{
			if (itemType == ItemType.None)
			{
				return false;
			}
			if (!itemType.GetItemInfo().isHave && !MonoSingleton<PlayerPrefsGame>.Instance.isLoad)
			{
				string text = UITextType._100017_获得.GetString() + ": " + DataDict[itemType].itemName;
				UnityEngine.Debug.Log(">_<" + text);
				EventsCentral.Tips.Invoke(text);
			}
			DataDict[itemType].isHave = true;
			switch (DataDict[itemType].GetOperationType())
			{
			case OperationType._0_物品:
			{
				for (int i = 0; i < backpack.Length; i++)
				{
					UnityEngine.Debug.Log(i);
					if (backpack[i] == null || !backpack[i].isHave || backpack[i].id == itemType)
					{
						backpack[i] = DataDict[itemType];
						break;
					}
				}
				break;
			}
			case OperationType._1_线索:
				ClueDict[itemType].isHave = true;
				clueLst.Remove(itemType);
				clueLst.Insert(0, itemType);
				break;
			}
			EventsCentral.Backpack._添加物品到背包.Invoke(itemType);
			EventsCentral.UI.Refresh.InvokeSafe(MJFSM.UIPanelType.背包);
			return true;
		}
		UnityEngine.Debug.LogWarning(">>>字典里没有:" + itemType);
		return false;
	}

	public bool RemoveItem(ItemType itemType)
	{
		if (DataDict.ContainsKey(itemType) || itemType != 0)
		{
			EventsCentral.RemoveItemEvent.InvokeSafe(itemType);
			EventsCentral.UI.Tips.InvokeSafe(DataDict[itemType].itemName + " 移出背包");
			EventsCentral.UI.Refresh.InvokeSafe(MJFSM.UIPanelType.背包);
			for (int i = 0; i < backpack.Length; i++)
			{
				if (backpack[i] != null && backpack[i].id == itemType)
				{
					backpack[i].isHave = false;
					backpack[i] = new ItemInfo();
				}
			}
			return true;
		}
		UnityEngine.Debug.LogWarning("无法删除,因为这个item不在背包中:" + itemType);
		return false;
	}

	public ItemInfo GetItemInfo(ItemType itemType)
	{
		if (itemType == ItemType.None)
		{
			return null;
		}
		if (!DataDict.ContainsKey(itemType))
		{
			UnityEngine.Debug.LogWarning("获取不到信息,因为这个id不存在字典里: " + itemType);
		}
		return DataDict[itemType];
	}

	public ItemInfo GetItemInfo(string name)
	{
		return GetItemInfo(name.GetItemType());
	}

	public bool GetItemIsHave(ItemType itemType)
	{
		if (!DataDict.ContainsKey(itemType))
		{
			UnityEngine.Debug.LogError("背包中没有这个itemType" + itemType);
			return false;
		}
		return DataDict[itemType].isHave;
	}

	public ItemInfo GetItemInfoByIndex(int index)
	{
		if (ClueDict.Count == 0 || index < 0 || index > ClueDict.Count)
		{
			UnityEngine.Debug.LogError("GetItemInfoByIndex 出现问题");
			return null;
		}
		return ClueDict.ElementAt(index).Value;
	}
}
[Serializable]
public class ItemInfo
{
	public ItemType id;

	public string itemName;

	public string contentText;

	public int audioId;

	public bool read;

	public bool isHave;

	public int GetIconType()
	{
		return id.GetHashCode() / 1000 % 10;
	}

	public OperationType GetOperationType()
	{
		return id.GetOperationType();
	}

	public Sprite GetItemImage()
	{
		return MonoSingleton<PoolManager>.Instance.GetItemSprite(id);
	}
}
public class PoolManager : MonoSingleton<PoolManager>
{
	public Dictionary<string, object> pools = new Dictionary<string, object>();

	public Dictionary<ItemType, TouchBase> RecycleDict = new Dictionary<ItemType, TouchBase>();

	public List<ItemType> Key = new List<ItemType>();

	public List<TouchBase> Value = new List<TouchBase>();

	public Dictionary<string, AudioClip> audiosPools = new Dictionary<string, AudioClip>();

	public Sprite GetItemSprite(ItemType itemType)
	{
		return itemType.GetOperationType() switch
		{
			OperationType._0_物品 => GetItemSprite(itemType.GetHashCode()), 
			OperationType._1_线索 => GetClueSprite(itemType.GetHashCode()), 
			_ => null, 
		};
	}

	public Sprite GetItemSprite(int id)
	{
		string text = "ItemPic/" + id;
		if (!pools.ContainsKey(text))
		{
			pools.Add(text, Resources.Load<Sprite>(text));
		}
		return (Sprite)pools[text];
	}

	private Sprite GetClueSprite(int id)
	{
		string text = "ItemPic/" + id;
		if (!pools.ContainsKey(text))
		{
			pools.Add(text, Resources.Load<Sprite>(text));
		}
		return (Sprite)pools[text];
	}

	internal GameObject GetPrefabToGO(ItemType id)
	{
		return GetPrefabToGO(id.GetHashCode().ToString());
	}

	public GameObject GetPrefabToGO(string name)
	{
		string text = "Prefab/" + name;
		if (!pools.ContainsKey(text))
		{
			pools.Add(text, UnityEngine.Object.Instantiate(Resources.Load<GameObject>(text), base.transform));
		}
		return (GameObject)pools[text];
	}

	public TouchBase GetTouchBase(ItemType type)
	{
		if (!RecycleDict.ContainsKey(type))
		{
			UnityEngine.Debug.LogError("生成" + type);
			return GetPrefabToGO(type).GetComponent<TouchBase>();
		}
		UnityEngine.Debug.LogError("调取" + type);
		RecycleDict[type].gameObject.SetActive(value: true);
		return RecycleDict[type];
	}

	public void RecycleTouchBase(TouchBase touch)
	{
		if (!RecycleDict.ContainsKey(touch.info.id) && touch.info.id != 0)
		{
			RecycleDict.Add(touch.info.id, touch);
			Key.Add(touch.info.id);
			Value.Add(touch);
		}
		UnityEngine.Debug.Log("回收:" + touch.name);
		touch.gameObject.SetActive(value: false);
		touch.transform.SetParent(base.transform);
		touch.transform.localPosition = Vector3.zero;
	}

	public void RecycleObj(GameObject obj)
	{
		obj.SetActive(value: false);
		obj.transform.SetParent(base.transform);
		obj.transform.localPosition = Vector3.zero;
	}

	public AudioClip GetAudioClip(string name)
	{
		if (!audiosPools.ContainsKey(name))
		{
			audiosPools.Add(name, Resources.Load<AudioClip>("Audios/" + name));
		}
		return audiosPools[name];
	}

	public void ClearAudioPools()
	{
		audiosPools.Clear();
	}
}
public class ReadData : MonoSingleton<ReadData>
{
	[Serializable]
	public class AssetText
	{
		public TextAsset itemType;

		public TextAsset uitextPanel;

		public TextAsset audioType;

		public TextAsset subtitleType;
	}

	private TextAsset text;

	private string[] languages = new string[3] { "en", "cn", "esp" };

	public bool showAsset;

	[ShowIf("showAsset")]
	public List<AssetText> assetTexts = new List<AssetText>();

	public int id;

	private void Awake()
	{
		EventManager.AddListener<MJFSM.Process>(MJFSM.MJEvents._0_Process, Init);
		MonoSingleton<GlobalManager>.Instance.language = GetOSLanguage();
		id = MonoSingleton<GlobalManager>.Instance.language.GetHashCode();
		EventsCentral.System.切换语言.AddListener(ChangeLanguage);
	}

	public void Init(MJFSM.Process process)
	{
		if (process == MJFSM.Process._0003加载数据)
		{
			StartCoroutine(LoadData());
		}
	}

	public void ChangeLanguage(int id)
	{
		this.id = id;
		StartCoroutine(ChangeLoadData());
	}

	public IEnumerator LoadData()
	{
		yield return ReadUITextData(assetTexts[id].uitextPanel);
		yield return ReadBackpackData(assetTexts[id].itemType);
		yield return ReadAudioData(assetTexts[id].audioType);
		yield return ReadSubtitleData(assetTexts[id].subtitleType);
		MonoSingleton<GlobalManager>.Instance.CurrentProcess = MJFSM.Process._0004数据加载完成;
	}

	public IEnumerator ChangeLoadData()
	{
		yield return ChangeUITextData(assetTexts[id].uitextPanel);
		yield return ChangeBackpackData(assetTexts[id].itemType);
		yield return ChangeAudioData(assetTexts[id].audioType);
		yield return ChangeSubtitleData(assetTexts[id].subtitleType);
		EventsCentral.System.语言切换完成.Invoke();
	}

	public static LanguageType GetOSLanguage()
	{
		LanguageType languageType = LanguageType.English;
		string text = Application.systemLanguage.ToString();
		UnityEngine.Debug.LogError(text);
		return text switch
		{
			"ChineseSimplified" => LanguageType.中文, 
			"Spanish" => LanguageType.西班牙语, 
			"Italian" => LanguageType.意大利语, 
			"German" => LanguageType.德语, 
			"Japanese" => LanguageType.日语, 
			"Korean" => LanguageType.韩语, 
			"English" => LanguageType.English, 
			_ => LanguageType.English, 
		};
	}

	private bool ReadBackpackData(TextAsset textAsset)
	{
		ItemInfo[] dataBase = textAsset.ToString().FromJson<ItemInfo[]>();
		MonoSingleton<BackpackManager>.Instance.dataBase = dataBase;
		for (int i = 0; i < MonoSingleton<BackpackManager>.Instance.dataBase.Length; i++)
		{
			MonoSingleton<BackpackManager>.Instance.DataDict.Add(MonoSingleton<BackpackManager>.Instance.dataBase[i].id, MonoSingleton<BackpackManager>.Instance.dataBase[i]);
		}
		UnityEngine.Debug.Log(">>>背包数据加载完成,共" + MonoSingleton<BackpackManager>.Instance.DataDict.Count);
		return true;
	}

	private bool ReadUITextData(TextAsset textAsset)
	{
		UnityEngine.Debug.Log(textAsset.ToString());
		UITextInfo[] array = textAsset.ToString().FromJson<UITextInfo[]>();
		for (int i = 0; i < array.Length; i++)
		{
			MonoSingleton<UIManager>.Instance.UIDict.Add((UITextType)array[i].id, array[i]);
			MonoSingleton<UIManager>.Instance.uITextInfos.Add(array[i]);
		}
		UnityEngine.Debug.Log(">>>UI数据加载完成,共" + MonoSingleton<UIManager>.Instance.UIDict.Count);
		return true;
	}

	private bool ReadAudioData(TextAsset textAsset)
	{
		AudioInfo[] array = textAsset.ToString().FromJson<AudioInfo[]>();
		for (int i = 0; i < array.Length; i++)
		{
			MonoSingleton<AudioManager>.Instance.audioDict.Add(array[i].ID, array[i]);
		}
		UnityEngine.Debug.Log(">>>声音数据加载完成,共" + MonoSingleton<AudioManager>.Instance.audioDict.Count);
		return true;
	}

	private bool ReadSubtitleData(TextAsset textAsset)
	{
		SubtitleInfo[] array = textAsset.ToString().FromJson<SubtitleInfo[]>();
		for (int i = 0; i < array.Length; i++)
		{
			array[i].audioClip = Resources.Load<AudioClip>("Subittle/Audios/" + array[i].audioName);
			MonoSingleton<SubtitleManager>.Instance.subtitleDict.Add(array[i].id, array[i]);
		}
		MonoBehaviour.print("读取字幕表完成");
		return true;
	}

	private bool ChangeBackpackData(TextAsset textAsset)
	{
		ItemInfo[] array = textAsset.ToString().FromJson<ItemInfo[]>();
		foreach (ItemInfo itemInfo in array)
		{
			UnityEngine.Debug.Log(itemInfo.id);
			if (MonoSingleton<BackpackManager>.Instance.DataDict.ContainsKey(itemInfo.id))
			{
				MonoSingleton<BackpackManager>.Instance.DataDict[itemInfo.id].itemName = itemInfo.itemName;
				MonoSingleton<BackpackManager>.Instance.DataDict[itemInfo.id].contentText = itemInfo.contentText;
			}
		}
		UnityEngine.Debug.Log(">>>背包数据加载完成,共" + MonoSingleton<BackpackManager>.Instance.DataDict.Count);
		return true;
	}

	private bool ChangeUITextData(TextAsset textAsset)
	{
		UITextInfo[] array = textAsset.ToString().FromJson<UITextInfo[]>();
		foreach (UITextInfo uITextInfo in array)
		{
			if (MonoSingleton<UIManager>.Instance.UIDict.ContainsKey((UITextType)uITextInfo.id))
			{
				MonoSingleton<UIManager>.Instance.UIDict[(UITextType)uITextInfo.id].text = uITextInfo.text;
				MonoSingleton<UIManager>.Instance.uITextInfos.Add(uITextInfo);
			}
		}
		UnityEngine.Debug.Log(">>>UI数据加载完成,共" + MonoSingleton<BackpackManager>.Instance.DataDict.Count);
		return true;
	}

	private bool ChangeAudioData(TextAsset textAsset)
	{
		return true;
	}

	private bool ChangeSubtitleData(TextAsset textAsset)
	{
		SubtitleInfo[] array = textAsset.ToString().FromJson<SubtitleInfo[]>();
		foreach (SubtitleInfo subtitleInfo in array)
		{
			subtitleInfo.audioClip = Resources.Load<AudioClip>("Subittle/Audios/" + subtitleInfo.audioName);
			if (MonoSingleton<SubtitleManager>.Instance.subtitleDict.ContainsKey(subtitleInfo.id))
			{
				MonoSingleton<SubtitleManager>.Instance.subtitleDict[subtitleInfo.id].text = subtitleInfo.text;
			}
		}
		MonoBehaviour.print("读取字幕表完成");
		return true;
	}
}
public class FantansyRoomManager : MonoSingleton<FantansyRoomManager>
{
	[SerializeField]
	private FantansyRoomProcessType currentProcessType;

	public GameObject space;

	public GameObject flashLight;

	public int doorPassword = 8624;

	public FantansyRoomProcessType CurrentProcessType
	{
		get
		{
			return currentProcessType;
		}
		set
		{
			currentProcessType = value;
			EventManager.SendEvent(value);
		}
	}

	private void Init()
	{
		CurrentProcessType = FantansyRoomProcessType._0初始化;
	}

	private void Start()
	{
		Invoke("Init", 0.1f);
	}
}
public enum FantansyRoomProcessType
{
	_None = -1,
	_0初始化,
	_1开门,
	_2探索
}
public enum TaskItemType
{
	None = 0,
	兰登家病历本 = 120100,
	兰登家酒店邮件 = 120101,
	兰登家行程邮件 = 120102,
	兰登家M的邮件 = 120103,
	兰登家与母亲合照 = 120104,
	兰登家明信片 = 120105,
	兰登家召唤之书 = 120106,
	兰登家日历 = 120107,
	兰登家嘉达尔的宝藏 = 120108,
	兰登家牙齿 = 120109,
	古宅圣女传说 = 130101,
	古宅黑巫术 = 130102,
	古宅手电筒 = 131005,
	古宅罗盘传说 = 130103,
	古宅照片 = 130107,
	古宅钥匙 = 130004,
	古宅电脑 = 130005,
	酒店大厅1208房卡 = 140002,
	酒店大厅1209房卡 = 140003,
	酒店大厅1207房卡 = 140004,
	酒店大厅面具 = 140001,
	酒店大厅徽章硬币 = 140005,
	酒店大厅便签纸 = 140101,
	酒店卧室啤酒瓶的短信 = 150101,
	酒店卧室塞缪尔的短信 = 150102,
	酒店卧室忏悔书 = 150103,
	酒店卧室塞缪尔 = 150104,
	古宅大门 = 132000,
	古宅镜子 = 132001,
	兰登家铁盒 = 121301,
	酒店电柜 = 141401,
	酒店数字罗盘 = 141402,
	兰登家羊头 = 120210,
	兰登家骑士 = 120211,
	兰登家小熊 = 120212,
	兰登家儿童画 = 120213,
	兰登家哲学笔记 = 120214,
	古宅书架上的书 = 130207,
	古宅散落的书 = 130208,
	古宅电视机 = 133000
}
public class FantasyRoom_2AlyssaCrying : MJListen
{
	public override void OnTrigger()
	{
		base.OnTrigger();
		GetComponent<AudioSource>().Play();
		Invoke("OnTrigger", 21 + UnityEngine.Random.Range(30, 180));
	}

	public void StopCrying()
	{
		CancelInvoke();
	}
}
public class FantasyRoom_2BlackHole : MonoBehaviour
{
	public GameObject alchmyDoor;

	public void Run()
	{
		GetComponent<PlayableDirector>().enabled = true;
		alchmyDoor.GetComponent<DoorInfo>().enabled = true;
		FantasyRoom_2Furniture[] componentsInChildren = GetComponentsInChildren<FantasyRoom_2Furniture>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			componentsInChildren[i].up = true;
		}
	}
}
public class FantasyRoom_2Floor : MJListen
{
	public override void OnTrigger()
	{
		base.OnTrigger();
		AudioType._1055_地板碎裂.Play(base.transform);
		Invoke("FloorSplit", 1f);
	}

	public void FloorSplit()
	{
		Rigidbody[] componentsInChildren = GetComponentsInChildren<Rigidbody>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			componentsInChildren[i].isKinematic = false;
		}
	}
}
public class FantasyRoom_2Furniture : MonoBehaviour
{
	public bool shrink;

	public bool up;

	public float time;

	public Vector3 pos;

	public Vector3 origin;

	public Rigidbody rigi;

	private void Start()
	{
		rigi = GetComponent<Rigidbody>();
	}

	private void Update()
	{
		if (up)
		{
			rigi.velocity = new Vector3(UnityEngine.Random.Range(5f, 10f) / 100f, UnityEngine.Random.Range(5f, 10f) / 100f, UnityEngine.Random.Range(5f, 10f) / 100f);
			rigi.angularVelocity = Vector3.one * 0.03f;
			rigi.isKinematic = false;
			up = false;
		}
	}
}
public class FantasyRoom_2GhostPicture : EasyVRInteractionBase
{
	public int timer;

	public override void RayEnter()
	{
		timer = 0;
		UnityEngine.Debug.Log(">>>Enter");
	}

	public override void RayStay()
	{
		timer++;
		if (timer == 100)
		{
			GetComponent<Animator>().enabled = true;
		}
	}
}
public class FantasyRoom_2SmallCandle : MonoBehaviour
{
	public ItemType macthItemType;

	public GameObject fire;

	public FantasyRoom_2Candles fantasyRoom_2Candles;

	public AudioType audioType;

	public SubtitleType subtitleType;

	private void OnTriggerEnter(Collider other)
	{
		if (other.CompareTag(TagType.TaskItem.ToString()) && other.GetComponent<TouchBase>().GetItemType() == macthItemType && !fire.activeSelf)
		{
			fire.SetActive(value: true);
			FantasyRoom_2Candles.litCandle.Invoke(base.name.GetItemType());
			AudioType._13111_点燃蜡烛.Play();
			MonoSingleton<SubtitleManager>.Instance.Play(subtitleType.GetHashCode(), base.gameObject.transform.position);
		}
		_ = fantasyRoom_2Candles.litSmallCandleCount;
		_ = 3;
	}
}
public class FantasyRoom_2Smallkey : MonoBehaviour
{
	private void Start()
	{
		EventManager.AddListener(MJFSM.MJEvents._0_Process, delegate(MJFSM.Process x)
		{
			if (x == MJFSM.Process._1001优先级一)
			{
				base.gameObject.SetActive(value: false);
			}
		});
	}

	private void Update()
	{
	}
}
public class FantasyRoom_2WallholePostcard : TriggerListen
{
	public Animator GhostHand;

	public override void OnTrigger()
	{
		base.OnTrigger();
		GetComponent<Animator>().enabled = true;
	}

	public void ShowHand()
	{
		GhostHand.gameObject.SetActive(value: true);
	}
}
public class FantasyRoom_2WindowGhost : MJListen
{
	public GameObject _collider;

	public override void Init()
	{
		base.Init();
		_collider.SetActive(value: false);
	}

	public override void OnTrigger()
	{
		base.OnTrigger();
		_collider.SetActive(value: true);
		Animator[] componentsInChildren = GetComponentsInChildren<Animator>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			componentsInChildren[i].enabled = true;
		}
	}
}
public class FantasyRoomDollSittingwavinglegs : TriggerListen
{
	public override void OnTrigger()
	{
		GetComponent<Animator>().enabled = true;
	}
}
public class FantasyRoomDoor : MJListen
{
	public AudioType BGM;

	private Vector3 originAngle;

	public override void Init()
	{
		base.Init();
		originAngle = base.transform.localEulerAngles;
	}

	private void Update()
	{
	}

	public override void OnTrigger()
	{
		base.OnTrigger();
		AudioType._1012_古宅门自动关闭.Play();
		if (BGM != 0)
		{
			MJBGM.SetBGMEvent.Invoke(BGM);
		}
		GetComponent<DoorInfo>().SetAngle(0f, AudioType._1012_古宅门自动关闭.Length());
		if (isOnce)
		{
			GetComponent<Collider>().enabled = false;
		}
	}
}
public class FantasyRoomExploredGlass : TriggerListen
{
}
public class FantasyRoomFemaleGhostWindow : MJListen
{
	public GameObject[] chidren;

	public override void OnTrigger()
	{
		base.OnTrigger();
		GameObject[] array = chidren;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetActive(value: true);
		}
		this.AttachTimer(3f, delegate
		{
			GameObject[] array2 = chidren;
			foreach (GameObject gameObject in array2)
			{
				if (gameObject.name != "Audio Source")
				{
					gameObject.SetActive(value: false);
				}
			}
		});
	}
}
public class FantasyRoomFlashlight : MonoBehaviour
{
	private void Start()
	{
		EventManager.AddListener("手电筒", delegate(bool b)
		{
			base.gameObject.SetActive(b);
		});
	}
}
public class FantasyRoomIronDoorInfo : MJListen
{
	public override void OnTrigger()
	{
		base.OnTrigger();
		AudioType._1011_密码铁门自动关闭.Play(base.transform);
		base.transform.TweenLocalRotation(Vector3.zero, AudioType._1011_密码铁门自动关闭.Length());
	}
}
public class FantasyRoomMirror2 : EasyVRInteractionBase
{
	public VideoClip videoClip;

	public Transform pos;

	public bool once = true;

	public void OnTouch()
	{
		if (ItemType._130003_物品_幻室_陈旧的钥匙.GetItemInfo().isHave && once)
		{
			once = false;
		}
		UnityEngine.Debug.Log("Ontouch");
	}

	private void Invoke()
	{
		MonoSingleton<GlobalManager>.Instance.CurrentScene = MJFSM.SceneType.兰登卧室;
	}
}
public class FantasyRoom_1_Balloon4 : MJListen
{
	public Animator woodHorse;

	public override void OnTrigger()
	{
		base.OnTrigger();
		this.AttachTimer(5f, delegate
		{
			AudioType._12003_Lilith用手搓气球的音效.Play(base.transform, 20f);
		});
		this.AttachTimer(19f, delegate
		{
			woodHorse.enabled = true;
		});
		this.AttachTimer(25f, delegate
		{
			woodHorse.enabled = false;
			woodHorse.GetComponent<AudioSource>().enabled = false;
		});
	}
}
public class FantasyRoom_1_BirthdaySong : MonoBehaviour
{
	public void Play()
	{
		MonoSingleton<SubtitleManager>.Instance.Play(SubtitleType._1002_古宅1_走廊开门后);
	}
}
public class FantasyRoom_1_LivingRoomDoor : MJListen
{
	public bool flag;

	public AudioSource cutleryAudio;

	public DoorInfo doorInfo;

	public GameObject gril;

	public override void Init()
	{
		base.Init();
		doorInfo = GameObject.Find("Rdoor").GetComponent<DoorInfo>();
	}

	public override void OnTrigger()
	{
		if (ItemType._130023_物品_幻室__圣嘉恩秘闻Ⅶ_.GetItemInfo().isHave)
		{
			base.OnTrigger();
			GetComponent<Animator>().enabled = true;
			doorInfo.SetAngle(-30f, 1.32f);
			cutleryAudio.enabled = true;
			GetComponentInChildren<Light>().enabled = true;
			gril.SetActive(value: true);
		}
		else if (MonoSingleton<PlayerInfo>.Instance.rightTouch.selectedInteractionBase != null && MonoSingleton<PlayerInfo>.Instance.rightTouch.selectedInteractionBase.GetItemType() == ItemType._130023_物品_幻室__圣嘉恩秘闻Ⅶ_)
		{
			base.OnTrigger();
			GetComponent<Animator>().enabled = true;
			doorInfo.SetAngle(-30f, 1.32f);
			cutleryAudio.enabled = true;
			GetComponentInChildren<Light>().enabled = true;
			gril.SetActive(value: true);
		}
	}

	public void GrilAnimatorOver()
	{
		flag = true;
	}
}
public class FantasyRoom_1_Wardrobe : MonoBehaviour
{
	public void Close()
	{
		this.AttachTimer(2f, delegate
		{
			UnityEngine.Debug.Log("Over");
			GetComponent<Animator>().enabled = true;
		});
	}
}
public class FantasyRoom_1Book : GeneralColliderDetectionBase
{
	public override void OnTrigger()
	{
		base.OnTrigger();
		GetComponent<MeshRenderer>().enabled = true;
		EventsCentral.FantasyRoom.Book.Invoke();
		AudioType._1068_把书放进机关.Play(base.transform);
	}
}
public class FantasyRoom_1BookLevelInfo : MonoBehaviour
{
	public int bookCount;

	public Transform drawer;

	public GameObject tvPuppet;

	public GameObject rockingChair;

	private void Start()
	{
		EventsCentral.FantasyRoom.Book.AddListener(AddBook);
	}

	private void OnDestroy()
	{
		EventsCentral.FantasyRoom.Book.RemoveAllListeners();
	}

	private void AddBook()
	{
		bookCount++;
		if (bookCount != 4)
		{
			return;
		}
		drawer.GetComponent<Animator>().enabled = true;
		tvPuppet.SetActive(value: true);
		Bookcase.bookFinish = true;
		rockingChair.GetComponent<Animator>().enabled = false;
		foreach (Transform item in rockingChair.transform)
		{
			item.gameObject.SetActive(value: false);
		}
	}

	private void Update()
	{
	}
}
public class FantasyRoom_1DoorGirl : MJListen
{
	public override void Init()
	{
		foreach (Transform item in base.transform)
		{
			item.gameObject.SetActive(value: false);
		}
	}

	public override void OnTrigger()
	{
		if (ItemType._130023_物品_幻室__圣嘉恩秘闻Ⅶ_.GetItemInfo().isHave)
		{
			UnityEngine.Debug.Log(">>" + _name);
			base.OnTrigger();
			GetComponent<AnimatorPlayerInfo>().PlayAnim();
			foreach (Transform item in base.transform)
			{
				item.gameObject.SetActive(value: true);
			}
			Invoke("Init", 2.5f);
		}
		else
		{
			if (!(MonoSingleton<PlayerInfo>.Instance.rightTouch.selectedInteractionBase != null) || MonoSingleton<PlayerInfo>.Instance.rightTouch.selectedInteractionBase.GetItemType() != ItemType._130023_物品_幻室__圣嘉恩秘闻Ⅶ_)
			{
				return;
			}
			base.OnTrigger();
			GetComponent<AnimatorPlayerInfo>().PlayAnim();
			foreach (Transform item2 in base.transform)
			{
				item2.gameObject.SetActive(value: true);
			}
			Invoke("Init", 2.5f);
		}
	}
}
public class FantasyRoom_1SmallRoomDoor2UnLock : MonoBehaviour
{
	public ItemType macthItemType;

	private void Start()
	{
		if (macthItemType == ItemType.None)
		{
			UnityEngine.Debug.LogError(base.name + " macthItemType 不能为None");
		}
		if (GetComponent<Collider>() == null)
		{
			UnityEngine.Debug.LogError(base.name + " 没有Collider");
		}
		else if (!GetComponent<Collider>().isTrigger)
		{
			UnityEngine.Debug.LogError(base.name + " 没有设置Trigger");
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.CompareTag(TagType.TaskItem.ToString()) && other.GetComponent<TouchBase>().GetItemType() == macthItemType)
		{
			GetComponentInParent<DoorController>().UnLock();
			other.GetComponentInParent<EasyVRHandInfo>().DelectSelectedInHand();
		}
	}
}
public class FantasyRoom_1SmallRoomDoor4 : MonoBehaviour
{
	public bool doorIsOpen;

	public int openDoorCount;

	public bool door1;

	public bool door3;

	public bool Door1
	{
		get
		{
			return door1;
		}
		set
		{
			door1 = value;
			OpenDoor();
		}
	}

	public bool Door3
	{
		get
		{
			return door3;
		}
		set
		{
			door3 = value;
			OpenDoor();
		}
	}

	private void OpenDoor()
	{
		if (Door3 && Door1 && !doorIsOpen)
		{
			base.transform.TweenLocalRotationY(70f, AudioType._1032_突然打开的4号门.Length());
			AudioType._1032_突然打开的4号门.Play(base.transform);
			doorIsOpen = true;
		}
	}
}
public class FantasyRoom_1_Cake : MJListen
{
	public override void OnTrigger()
	{
		base.OnTrigger();
		this.AttachTimer(1.6f, delegate
		{
			ParticleSystem[] componentsInChildren = GetComponentsInChildren<ParticleSystem>();
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				componentsInChildren[i].gameObject.SetActive(value: false);
			}
		});
		AudioType._1076_吹灭蜡烛.Play(base.transform);
	}
}
public class FantasyRoom_1_SmallRoomDoor3 : MonoBehaviour
{
	public FantasyRoom_1SmallRoomDoor4 door4;

	public void Open()
	{
		door4.Door3 = true;
	}
}
public class FantasyRoom_2Candles : MonoBehaviour
{
	public static Signal<ItemType> litCandle = new Signal<ItemType>();

	public int litSmallCandleCount;

	public GameObject[] prayModels;

	public GameObject[] scatteredModels;

	private void Start()
	{
		litCandle.AddListener(OnLitCandle);
	}

	private void OnDestroy()
	{
		litCandle.RemoveAllListeners();
	}

	private void OnLitCandle(ItemType obj)
	{
		litSmallCandleCount++;
		Puppet.puppetSignal.Invoke(litSmallCandleCount);
		if (litSmallCandleCount == 3)
		{
			GetComponentInChildren<FantasyRoom_2BlackHole>().Run();
			Animator[] componentsInChildren = GetComponentsInChildren<Animator>();
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				componentsInChildren[i].Play("Down");
			}
		}
		RoomLight.roomLightSignal.Invoke(t1: false);
		this.AttachTimer(2f, delegate
		{
			RoomLight.roomLightSignal.Invoke(t1: true);
		});
	}
}
public class FantasyRoom_2Manager : MonoSingleton<FantasyRoom_2Manager>
{
	public enum Process
	{
		None,
		_1_手下落,
		_2_黑洞出现_法阵激活,
		_3_女神蜡烛出现,
		_4_出现女鬼
	}

	public static Signal<Process> SetProcess = new Signal<Process>();

	private Process myProcess;

	public Process MyProcess
	{
		get
		{
			return myProcess;
		}
		set
		{
			myProcess = value;
			SetProcess.Invoke(value);
		}
	}
}
public class FantsyRoomKnifeAndFolk : MJListen
{
	public Animator laughter;

	public override void Init()
	{
		foreach (Transform item in base.transform)
		{
			EFramework.Unity.Tools.Timer.Register(float.Parse(item.name.Substring(0, 2)) / 20f, delegate
			{
				item.GetComponent<Animator>().enabled = true;
			});
		}
		EventsCentral.OpenDoor.AddListener(OpenDoor);
		void OpenDoor(string name)
		{
			if (name == "131409_古宅1-大门")
			{
				GetComponent<AudioSource>().enabled = true;
				MonoSingleton<SubtitleManager>.Instance.Play(SubtitleType._1002_古宅1_走廊开门后);
			}
		}
	}

	public override void OnTrigger()
	{
		base.OnTrigger();
		Animator[] componentsInChildren = GetComponentsInChildren<Animator>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			componentsInChildren[i].enabled = false;
		}
		Rigidbody[] componentsInChildren2 = GetComponentsInChildren<Rigidbody>();
		foreach (Rigidbody obj in componentsInChildren2)
		{
			obj.useGravity = true;
			obj.isKinematic = false;
		}
		GetComponent<AudioSource>().enabled = false;
		AudioType._1025_刀叉掉落.Play(base.transform);
	}
}
public class GlobalManager : MonoSingleton<GlobalManager>
{
	public LanguageType language;

	public HmdType hmdType;

	public bool showLogo = true;

	public bool canPlayGame = true;

	[SerializeField]
	private MJFSM.SceneType currentScene;

	[SerializeField]
	private MJFSM.Process currentProcess;

	[SerializeField]
	private MJFSM.UIPanelType currentUI;

	public MJFSM.SceneType CurrentScene
	{
		get
		{
			return currentScene;
		}
		set
		{
			UnityEngine.Debug.LogError(">>>>scene:" + value);
			currentScene = value;
			EventsCentral.Scene.ChangScene.InvokeSafe(value);
			_ = MonoSingleton<PlayerPrefsGame>.Instance.isLoad;
		}
	}

	public MJFSM.Process CurrentProcess
	{
		get
		{
			return currentProcess;
		}
		set
		{
			currentProcess = value;
			EventManager.SendEvent(MJFSM.MJEvents._0_Process, value);
			EventManager.SendEvent(value);
		}
	}

	public MJFSM.UIPanelType CurrentUI
	{
		get
		{
			return currentUI;
		}
		set
		{
			UnityEngine.Debug.Log("发送:" + value);
			if (value == MJFSM.UIPanelType.None || value == MJFSM.UIPanelType.教学)
			{
				MonoSingleton<PlayerInfo>.Instance.showRay = false;
			}
			else
			{
				MonoSingleton<PlayerInfo>.Instance.showRay = true;
			}
			if (value == currentUI)
			{
				value = MJFSM.UIPanelType.None;
			}
			currentUI = value;
			EventsCentral.UI._Invoke_开启界面.Invoke(currentUI);
		}
	}

	private void Start()
	{
		UnityEngine.Object.DontDestroyOnLoad(this);
	}
}
public enum HmdType
{
	None,
	vive,
	vive_pro,
	indexhmd,
	rift
}
public class InitScenePos : MonoBehaviour
{
	private void Awake()
	{
		SceneManager.sceneLoaded += SceneManager_sceneLoaded;
	}

	private void SceneManager_sceneLoaded(Scene arg0, LoadSceneMode arg1)
	{
		Invoke("InitPos", 0.1f);
		SceneManager.sceneLoaded -= SceneManager_sceneLoaded;
	}

	public void InitPos()
	{
		if (MonoSingleton<PlayerPrefsGame>.Instance.isLoad)
		{
			MonoSingleton<PlayerPrefsGame>.Instance.Load();
			MonoBehaviour.print("进入古宅1");
		}
		else
		{
			UnityEngine.Debug.Log("重置位置" + base.name);
			MonoSingleton<PlayerInfo>.Instance.SetPos(base.transform);
		}
	}
}
public class FantasyRoomIronDoorLockInfo : EasyVRInteractionBase
{
	private bool isOpen;

	public static Signal openTheDoor = new Signal();

	private void Start()
	{
		openTheDoor.AddListener(OpenIronDoor);
		EventManager.AddListener(MJFSM.UIPanelType.密码锁, OnUIShow);
	}

	private void OnUIShow()
	{
		GetComponent<Collider>().enabled = !MonoSingleton<UIManager>.Instance.IsShow;
	}

	public override void PressDown()
	{
		UnityEngine.Debug.Log(">>>>>>>>>>>点击密码盘");
		if (!isOpen)
		{
			MonoSingleton<GlobalManager>.Instance.CurrentUI = MJFSM.UIPanelType.密码锁;
		}
	}

	private void OpenIronDoor()
	{
		base.transform.TweenLocalRotation(Vector3.up * 90f, AudioType._1020_打开密码铁门.Length());
		MonoSingleton<AudioManager>.Instance.Play(AudioType._1020_打开密码铁门, base.transform.position);
		isOpen = true;
	}
}
public class FantasyRoomTelevision : MJListen
{
	public override void OnTrigger()
	{
		if (ItemType._130022_物品_幻室__圣嘉恩秘闻Ⅴ_.GetItemInfo().isHave)
		{
			base.OnTrigger();
			GetComponent<Animator>().enabled = true;
		}
	}
}
public class KeyBind : MonoSingleton<KeyBind>
{
	public bool AddItemToBackpack;

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.M))
		{
			MonoSingleton<GlobalManager>.Instance.CurrentUI = MJFSM.UIPanelType.密码锁;
		}
	}
}
public class Lighter : TaskItem
{
	public override void PressDown()
	{
		base.PressDown();
		GetComponentInChildren<Animator>().enabled = true;
	}

	public override void PressUp()
	{
		GetComponentInChildren<Animator>().Play("Close Lighter");
		Invoke("InvokeFunction", 0.5f);
	}

	public void InvokeFunction()
	{
		base.PressUp();
	}
}
public class MJBGM : MonoBehaviour
{
	public static Signal<AudioType> SetBGMEvent = new Signal<AudioType>();

	private void Start()
	{
		SetBGMEvent.AddListener(SetBGM);
	}

	private void SetBGM(AudioType obj)
	{
		if (GetComponent<AudioSource>().clip != MonoSingleton<AudioManager>.Instance.audioDict[obj.GetHashCode()].clip)
		{
			GetComponent<AudioSource>().clip = MonoSingleton<AudioManager>.Instance.audioDict[obj.GetHashCode()].clip;
			GetComponent<AudioSource>().Play();
		}
	}
}
public class MJFSM
{
	public enum MJEvents
	{
		_0_Process,
		_0_Scene,
		_1_切换场景,
		_1_交换手柄,
		_1_拾取物品,
		_2_播放全景视频,
		_2_互动碰撞检测
	}

	public enum UIPanelType
	{
		None,
		Logo,
		加载界面,
		背包,
		线索,
		密码锁,
		手提箱密码锁,
		教学,
		黑屏过渡,
		设置界面,
		开始界面,
		协议
	}

	public enum Process
	{
		None,
		_0001游戏启动,
		_0002加载模块,
		_0003加载数据,
		_0004数据加载完成,
		_0100进入场景,
		_0200注册事件,
		_0300初始化关卡,
		_1000开始游戏,
		_1001优先级一,
		_1002优先级二,
		_1003优先级三,
		_1004优先级四
	}

	public enum SceneType
	{
		Init,
		Login,
		新手教程,
		古宅,
		兰登卧室,
		酒店大厅,
		酒店客房
	}
}
public enum OperationType
{
	_0_物品,
	_1_线索,
	_2_检查_手柄_文字,
	_3_检查_射线_文字_static,
	_4_交互,
	_5_普通
}
public enum Events
{
	Hotel_电流接通 = 1101
}
public enum ColliderDetectionEvents
{
	酒店大厅_电梯门
}
public enum TriggerType
{
	None,
	Enter,
	Stay,
	Exit
}
public enum TagType
{
	Player,
	PlayerHead,
	PlayerHand,
	TaskItem
}
public class MagicCircle : MonoBehaviour
{
	public Color color = new Color(1f, 0f, 1f, 1f);

	[Range(0f, 1f)]
	public float minBrightness;

	[Range(0f, 1f)]
	public float maxBrightness = 0.5f;

	[Range(0.2f, 30f)]
	public float rate = 1f;

	[Tooltip("勾选此项则启动时自动开始闪烁")]
	[SerializeField]
	private bool _autoStart;

	private float _h;

	private float _s;

	private float _v;

	private float _deltaBrightness;

	private Renderer _renderer;

	private Material _material;

	private readonly string _keyword = "_EMISSION";

	private readonly string _colorName = "_EmissionColor";

	private Coroutine _glinting;

	private void Start()
	{
		EventsCentral.FantasyRoom.EnableBlackHole.AddListener(delegate
		{
			maxBrightness = 1f;
			StartGlinting();
		});
		_renderer = base.gameObject.GetComponent<Renderer>();
		_material = _renderer.material;
		if (_autoStart)
		{
			StartGlinting();
		}
	}

	private void OnValidate()
	{
		if (minBrightness < 0f || minBrightness > 1f)
		{
			minBrightness = 0f;
			UnityEngine.Debug.LogError("最低亮度超出取值范围[0, 1]，已重置为0。");
		}
		if (maxBrightness < 0f || maxBrightness > 1f)
		{
			maxBrightness = 1f;
			UnityEngine.Debug.LogError("最高亮度超出取值范围[0, 1]，已重置为1。");
		}
		if (minBrightness >= maxBrightness)
		{
			minBrightness = 0f;
			maxBrightness = 1f;
			UnityEngine.Debug.LogError("最低亮度[MinBrightness]必须低于最高亮度[MaxBrightness]，已分别重置为0/1！");
		}
		if (rate < 0.2f || rate > 30f)
		{
			rate = 1f;
			UnityEngine.Debug.LogError("闪烁频率超出取值范围[0.2, 30.0]，已重置为1.0。");
		}
		_deltaBrightness = maxBrightness - minBrightness;
		float V = 0f;
		Color.RGBToHSV(color, out _h, out _s, out V);
	}

	public void StartGlinting()
	{
		_material.EnableKeyword(_keyword);
		if (_glinting != null)
		{
			StopCoroutine(_glinting);
		}
		_glinting = StartCoroutine(IEGlinting());
	}

	public void StopGlinting()
	{
		_material.DisableKeyword(_keyword);
		if (_glinting != null)
		{
			StopCoroutine(_glinting);
		}
	}

	private IEnumerator IEGlinting()
	{
		Color.RGBToHSV(color, out _h, out _s, out _v);
		_v = minBrightness;
		_deltaBrightness = maxBrightness - minBrightness;
		bool increase = true;
		while (true)
		{
			if (increase)
			{
				_v += _deltaBrightness * Time.deltaTime * rate;
				increase = _v <= maxBrightness;
			}
			else
			{
				_v -= _deltaBrightness * Time.deltaTime * rate;
				increase = _v <= minBrightness;
			}
			_material.SetColor(_colorName, Color.HSVToRGB(_h, _s, _v));
			yield return null;
		}
	}
}
public class Process_Manager : MonoSingleton<Process_Manager>
{
	public bool JumpScene;

	public MJFSM.SceneType sceneType;

	public MJFSM.Process process
	{
		get
		{
			return MonoSingleton<GlobalManager>.Instance.CurrentProcess;
		}
		set
		{
			MonoSingleton<GlobalManager>.Instance.CurrentProcess = value;
		}
	}

	private void Awake()
	{
		StartCoroutine(Process());
		EventManager.AddListener(MJFSM.MJEvents._0_Process, delegate(MJFSM.Process x)
		{
			if (x == MJFSM.Process._0004数据加载完成 && JumpScene)
			{
				SceneManager.LoadSceneAsync(sceneType.GetHashCode(), LoadSceneMode.Additive);
			}
			if (x == MJFSM.Process._0004数据加载完成 && !JumpScene)
			{
				StartCoroutine(Scene());
				UnityEngine.Debug.LogError("++++++++++++++++++++++++");
			}
		});
	}

	private IEnumerator Process()
	{
		process = MJFSM.Process._0001游戏启动;
		yield return new WaitForSeconds(0.01f);
		process = MJFSM.Process._0002加载模块;
		yield return new WaitForSeconds(0.01f);
		process = MJFSM.Process._0003加载数据;
	}

	public void StartSceneProcess()
	{
		StartCoroutine(Scene());
		MonoSingleton<PlayerInfo>.Instance.SetEasyVRController(move: true, left: true, right: true);
	}

	private IEnumerator Scene()
	{
		for (int i = 5; i <= 12; i++)
		{
			yield return new WaitForSeconds(0.01f);
			process = (MJFSM.Process)i;
			UnityEngine.Debug.LogError(process);
		}
	}
}
public class InputConvert : MonoSingleton<InputConvert>
{
	public void RayIn(RaycastHit hit)
	{
		hit.transform.GetComponent<TouchBase>()?.RayEnter();
	}

	public void Click(Transform lastHit)
	{
		MonoBehaviour.print("OnClick2");
		lastHit.GetComponent<TouchBase>()?.PressDown();
	}

	public void RayOut(Transform lastHit)
	{
		lastHit.transform.GetComponent<TouchBase>()?.RayExit();
	}
}
public class SceneInit : MonoBehaviour
{
	private void Awake()
	{
		MonoSingleton<Process_Manager>.Instance.StartSceneProcess();
		MonoSingleton<BackpackManager>.Instance.InitBackpackArray();
		MonoSingleton<PlayerInfo>.Instance.canOpenUI = true;
	}
}
public class Tools
{
	public static int Name2Int(string name)
	{
		if (int.TryParse(name.Substring(0, 6), out var result))
		{
			return result;
		}
		return 0;
	}
}
public class CursorInfo : MonoBehaviour
{
	private SpriteRenderer spriteRenderer;

	private void Start()
	{
		spriteRenderer = GetComponent<SpriteRenderer>();
		spriteRenderer.enabled = false;
		EventManager.AddListener((TaskItemType)Tools.Name2Int(base.name), Hide);
	}

	private void Hide()
	{
		base.gameObject.SetActive(value: false);
	}

	public void Show()
	{
		spriteRenderer.enabled = true;
	}

	private void Update()
	{
		base.transform.LookAt(MonoSingleton<PlayerInfo>.Instance.EasyVRHead.transform);
		spriteRenderer.enabled = Vector3.Distance(base.transform.position, MonoSingleton<PlayerInfo>.Instance.GetEasyVRHeadPos()) <= MonoSingleton<PlayerInfo>.Instance.radius;
	}
}
public class UICameraFollow : MonoBehaviour
{
	public float smooth = 2f;

	private void Start()
	{
		base.transform.Rotate(0f, 180f, 0f);
	}

	private void FixedUpdate()
	{
	}
}
public class UIManager : MonoSingleton<UIManager>
{
	public Dictionary<UITextType, UITextInfo> UIDict = new Dictionary<UITextType, UITextInfo>();

	public List<UITextInfo> uITextInfos = new List<UITextInfo>();

	public bool isShow;

	public bool IsShow => MonoSingleton<GlobalManager>.Instance.CurrentUI != MJFSM.UIPanelType.None;

	private void Start()
	{
	}

	private void Update()
	{
		if ((MonoSingleton<PlayerInfo>.Instance.rightController.BPressDown || MonoSingleton<PlayerInfo>.Instance.leftController.BPressDown) && MonoSingleton<PlayerInfo>.Instance.canOpenUI)
		{
			MonoSingleton<GlobalManager>.Instance.CurrentUI = MJFSM.UIPanelType.背包;
			UnityEngine.Debug.Log("b");
		}
	}
}
public class FantansyRoomPhotoTipsWindow : WindowInfoBase
{
	[SerializeField]
	private Text content;

	[SerializeField]
	private Image image;

	private TaskItemType itemType;

	private void Start()
	{
		itemType = (TaskItemType)Tools.Name2Int(base.name);
		EventManager.AddListener(itemType, Show);
		Hide();
	}

	public override void Show()
	{
		base.gameObject.SetActive(value: true);
		Invoke("Hide", 3f);
	}
}
public class FantasyRoomLockWindow : UIPanelBase
{
	public int inputNum;

	private void OnEnable()
	{
		inputNum = 0;
	}

	public void Input(int number)
	{
		inputNum = inputNum * 10 + number;
		if (inputNum > 999)
		{
			if (8624 == inputNum || inputNum == 3721)
			{
				FantasyRoomIronDoorLockInfo.openTheDoor.Invoke();
				MonoSingleton<GlobalManager>.Instance.CurrentUI = MJFSM.UIPanelType.None;
			}
			else
			{
				inputNum = 0;
			}
		}
	}
}
public class WindowInfoBase : MonoBehaviour
{
	public virtual void Show()
	{
		base.gameObject.SetActive(value: true);
	}

	public virtual void Hide()
	{
		base.gameObject.SetActive(value: false);
	}
}
public class EasterEgg : MonoBehaviour
{
	private void OnTriggerEnter(Collider other)
	{
		if (other.gameObject.CompareTag("Player"))
		{
			GetComponent<AudioSource>().Play();
			GetComponent<Collider>().enabled = false;
		}
	}
}
public class BirthCertificateClue : ClueItem
{
	public VideoClip clip;

	public Transform pos;

	public DoorInfo officeDoorInfo;

	public GameObject oldHouse3Dolls;

	public GameObject BGM;

	public Transform Pos360;

	public override void GetItemSignal(ItemType obj)
	{
		UnityEngine.Debug.Log("Test" + obj);
		if (obj == ItemType._150103_线索_幻室_莉莉丝的出生证明 && !MonoSingleton<PlayerPrefsGame>.Instance.isLoad)
		{
			MonoBehaviour.print("拿到出生证明");
			BGM.SetActive(value: false);
			BGM.GetComponent<AudioSource>().clip = MonoSingleton<AudioManager>.Instance.audioDict[AudioType._14006_监狱的阴风BGM.GetHashCode()].clip;
			MonoSingleton<PlayerInfo>.Instance.AttachTimer(1f, delegate
			{
				MonoSingleton<OverallViewManager>.Instance.Play(clip, autoClose: true, loop: false);
				MonoBehaviour.print("进入全景");
			});
			MonoSingleton<PlayerInfo>.Instance.AttachTimer(4f, delegate
			{
				MonoSingleton<SubtitleManager>.Instance.Play(1255, Pos360.position);
			});
			MonoSingleton<PlayerInfo>.Instance.AttachTimer((float)(clip.length + 1.0), delegate
			{
				MonoSingleton<PlayerInfo>.Instance.SetPos(pos.position);
				BGM.SetActive(value: true);
				oldHouse3Dolls.SetActive(value: true);
			});
			MJButton.canOpen = true;
			officeDoorInfo.enabled = true;
			Faucet.faucetSignal.Invoke();
			MonoSingleton<PlayerInfo>.Instance.gameObject.GetComponent<AudioSource>().clip = MonoSingleton<AudioManager>.Instance.audioDict[AudioType._90031_玩家拎油灯走在水泥地.GetHashCode()].clip;
		}
	}
}
public class Butcher : MonoBehaviour
{
	public GameObject obj;

	public GameObject cam;

	private void Start()
	{
		base.transform.parent.LookAt(MonoSingleton<PlayerInfo>.Instance.GetBodyPosition);
		UnityEngine.Debug.Log(MonoSingleton<PlayerInfo>.Instance.transform.position);
		base.transform.eulerAngles.X(0f).Z(0f);
		this.AttachTimer(4f, delegate
		{
			MonoSingleton<PlayerInfo>.Instance.SetPos(cam.transform.position);
			obj.SetActive(value: true);
			MonoSingleton<PlayerInfo>.Instance.SetEasyVRController(move: false, left: false, right: false);
			base.gameObject.SetActive(value: false);
		});
	}
}
public class Butcher2 : MonoBehaviour
{
	public Camera cam;

	public GameObject landon;

	private void Start()
	{
		this.AttachTimer(6f, delegate
		{
		});
		this.AttachTimer(7.7f, delegate
		{
			MonoSingleton<PlayerInfo>.Instance.SetSpeed(0f);
			MonoSingleton<PlayerInfo>.Instance.transform.localRotation = Quaternion.Euler(MonoSingleton<PlayerInfo>.Instance.transform.rotation.x, 130f, MonoSingleton<PlayerInfo>.Instance.transform.rotation.z);
			Camera.main.nearClipPlane = 0.25f;
		});
		this.AttachTimer(21.25f, delegate
		{
			base.gameObject.SetActive(value: false);
		});
	}
}
public class FantasyRoom3DungeonCorpse : MonoBehaviour
{
	public static Signal<GameObject> CorpseParts = new Signal<GameObject>();

	[Tooltip("完好的尸体")]
	public GameObject goodCorpse;

	private void Start()
	{
		CorpseParts.AddListener(CorpsePart);
	}

	public void OnDestroy()
	{
		CorpseParts.RemoveAllListeners();
	}

	private void CorpsePart(GameObject part)
	{
		UnityEngine.Debug.Log(part.name.Substring(part.name.Length - 1));
		int num = int.Parse(part.name.Substring(part.name.Length - 1));
		string text = part.name.Substring(0, part.name.Length - 1);
		UnityEngine.Debug.Log(num + "    前缀:" + text);
		part.GetComponent<Rigidbody>().isKinematic = false;
		part.GetComponent<Collider>().enabled = true;
		part.transform.parent = base.transform.root;
	}
}
public class Knife : NormalItem
{
	private void Update()
	{
		if (Input.GetKeyUp(KeyCode.Space))
		{
			base.transform.DOMoveY(11f, 2f);
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.name == "Trigger")
		{
			FantasyRoom3DungeonCorpse.CorpseParts.InvokeSafe(other.transform.parent.gameObject);
			MonoSingleton<AudioManager>.Instance.Play(14001 + UnityEngine.Random.Range(0, 2));
		}
	}
}
public class Scale : MonoBehaviour
{
	public GameObject mercuryColumn;

	public GameObject room2Door;

	public float weight;

	public bool isOpen;

	private Dictionary<string, float> scaleDict = new Dictionary<string, float>();

	public ScriptPlayerPrefs scriptPlayerPrefs;

	public float shakeStrength = 1f;

	private void Start()
	{
		EventsCentral.PickupItem.AddListener(PickupItem);
		scriptPlayerPrefs = GetComponent<ScriptPlayerPrefs>();
	}

	private void OnDestroy()
	{
		EventsCentral.PickupItem.RemoveAllListeners();
	}

	private void PickupItem(TouchBase obj)
	{
		if (scaleDict.ContainsKey(obj.name))
		{
			weight -= scaleDict[obj.name];
			scaleDict.Remove(obj.name);
			Shake();
		}
	}

	private void OnTriggerStay(Collider other)
	{
	}

	private void OnCollisionEnter(Collision collision)
	{
		if (collision.transform.CompareTag("NormalItem"))
		{
			Shake();
			collision.rigidbody.isKinematic = true;
			EventManager.SendEvent("ScaleCursor.MoveTo");
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.transform.CompareTag("NormalItem") && !scaleDict.ContainsKey(other.name) && MonoSingleton<PlayerInfo>.Instance.rightController.TriggerPressUp)
		{
			scaleDict.Add(other.name, other.attachedRigidbody.mass * 10f);
			weight += other.attachedRigidbody.mass * 10f;
			if (weight >= 30f && !isOpen)
			{
				isOpen = true;
				AudioType._14005_地牢1的门打开的声音.Play();
				UnityEngine.Debug.Log("开门");
				room2Door.GetComponent<DoorInfo>().enabled = true;
				room2Door.GetComponent<DoorInfo>().SetAngle(40f, AudioType._14005_地牢1的门打开的声音.Length());
				scriptPlayerPrefs.isFinish = true;
				scriptPlayerPrefs.Save();
			}
		}
	}

	private void Shake()
	{
		base.transform.DOLocalRotate(weight / 10f * Vector3.right, 0.2f).OnComplete(delegate
		{
			base.transform.DOShakeRotation(2f, Vector3.right * shakeStrength);
			AudioType._14004_秤盘上升下降的声音.Play();
		});
	}

	public void Finish()
	{
		room2Door.GetComponent<DoorInfo>().enabled = true;
		room2Door.GetComponent<DoorInfo>().SetAngle(40f, 0.5f);
	}
}
public class ScaleCursor : MonoBehaviour
{
	public float min = 0.00743f;

	public float max = 0.0923f;

	public bool Sync;

	public Transform scale;

	[EFramework.Core.RegisterCommand(null)]
	public void MoveTo()
	{
		Sync = true;
		UnityEngine.Debug.Log(Sync);
		this.AttachTimer(2f, delegate
		{
			Sync = false;
			UnityEngine.Debug.Log(Sync);
		});
	}

	private void Update()
	{
		base.transform.DOLocalMoveZ(Mathf.Lerp(min, max, Mathf.Clamp01(scale.localEulerAngles.x / 5f)), 0f);
	}
}
public class DungeonHallwayDoor_2 : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
	}
}
public class CameraTest : MonoBehaviour
{
	private Vector3 origin;

	private void Start()
	{
		origin = base.transform.localPosition;
		Random();
	}

	public void Random()
	{
		Vector3 vector = new Vector3(UnityEngine.Random.Range(0f, 10f) / 10f, UnityEngine.Random.Range(0f, 10f) / 10f, UnityEngine.Random.Range(0f, 10f) / 10f);
		float duration = UnityEngine.Random.Range(0f, 1f) / 10f;
		base.transform.DOLocalMove(origin + vector, duration).OnComplete(Random);
	}
}
public class HandTest : MonoBehaviour
{
	private void Start()
	{
		base.transform.DOMoveZ(base.transform.position.z + 1f, 5f).SetLoops(-1);
	}
}
public class HeadFollow : MonoBehaviour
{
	public Transform hand;

	public Vector3 offsetPos;

	public Vector3 originPos;

	public Vector3 offsetRot;

	public Vector3 originRot;

	public Transform cmr;

	private void Start()
	{
		cmr = Camera.main.transform;
		originPos = cmr.localPosition;
		originRot = cmr.localRotation.eulerAngles;
		MonoSingleton<PlayerInfo>.Instance.enabled = false;
	}

	private void LateUpdate()
	{
		base.transform.position = Vector3.zero;
		base.transform.eulerAngles = hand.rotation.eulerAngles - cmr.localRotation.eulerAngles + originRot + offsetRot;
		base.transform.position = hand.position - cmr.localPosition + originPos + offsetPos;
	}
}
public class BackUp : MonoBehaviour
{
	public Transform initPos;

	public Color color;

	public void Back()
	{
		MonoSingleton<PlayerInfo>.Instance.SpeedMoveTo(initPos.position, 2f, canMove: false);
		MonoSingleton<EasyVRScreenFade>.Instance.FadeOpen(1f, color);
		this.AttachTimer(7f, delegate
		{
			MonoSingleton<EasyVRScreenFade>.Instance.FadeClose(2f, color);
			MonoSingleton<PlayerInfo>.Instance.SetCanMove(state: true);
		});
		MonoBehaviour.print("后退");
	}
}
public class LilithBody : MonoBehaviour
{
	private void Start()
	{
		this.AttachTimer(16.25f, ActiveRigibody);
	}

	public void ActiveRigibody()
	{
		Rigidbody[] componentsInChildren = GetComponentsInChildren<Rigidbody>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			componentsInChildren[i].isKinematic = false;
		}
	}
}
public class LookLilithRoom : MonoBehaviour
{
	private void Start()
	{
		base.transform.DOLocalMoveZ(0.05f, 3f).OnComplete(delegate
		{
			UnityEngine.Object.Destroy(base.gameObject, 9.16f);
		});
	}
}
public class ToyCar : MonoBehaviour
{
	private void Start()
	{
		this.AttachTimer(10.16f, delegate
		{
			GetComponent<PlayableDirector>().enabled = true;
		});
	}
}
public class FantasyRoom3_LilithRoomMirror : MonoBehaviour
{
	public bool canTrigger;

	public void Update()
	{
		if (MonoSingleton<RayTrigger>.Instance.outGameobject == base.gameObject && canTrigger)
		{
			GetComponent<PlayableDirector>().enabled = true;
		}
	}
}
public class DungeonHallwayDoor_1 : MonoBehaviour
{
	public void Open()
	{
	}
}
public class ScareFace : MonoBehaviour
{
	public Transform door;

	private void Start()
	{
		MonoBehaviour.print("车厢2开门");
		MonoSingleton<PlayerInfo>.Instance.rightTouch.selectedObj = null;
		MonoSingleton<PlayerInfo>.Instance.rightTouch.selectedInteractionBase = null;
		door.DOMoveX(door.GetComponent<Drawer>().originPos.x, 0.3f).SetDelay(1f).OnComplete(delegate
		{
			door.gameObject.layer = 0;
			door.gameObject.GetComponent<Drawer>().enabled = false;
		});
	}

	private void Update()
	{
		if (door.GetComponent<Drawer>().drawerPosX - door.GetComponent<Drawer>().originPos.x > 0.2f)
		{
			base.transform.GetChild(1).gameObject.SetActive(value: true);
		}
	}
}
public class FantasyRoom3Test : MonoBehaviour
{
	public Transform pos;

	private void Start()
	{
		TestManager.AddTest("传送到轮盘Pos", delegate
		{
			MonoSingleton<PlayerInfo>.Instance.SetPos(pos.position);
		});
		TestManager.AddTest("传送到出生证明", delegate
		{
			MonoSingleton<PlayerInfo>.Instance.SetPos(base.transform.GetChild(0).position);
		});
	}
}
public class TrainDoor : Drawer
{
	public override void Init()
	{
		base.Init();
		distanceLimit = 0.78f;
		openAuido = AudioType._14013_打开车厢门;
		closeAudio = AudioType._14014_关闭车厢门;
	}
}
public class TrainRun : MonoBehaviour
{
	private void Start()
	{
		Run();
	}

	public void Run()
	{
		base.transform.DOShakeRotation(1f, 2f, 1, 9f);
		this.AttachTimer(UnityEngine.Random.Range(10, 20), Run);
	}
}
public class WheelOrganLevel : MonoBehaviour
{
	public Transform pos;

	public Transform[] objs;

	private float faultToleranceValues = 0.2f;

	public UnityEvent trainLight;

	public UnityEvent LoadPlayerPrefs;

	public float time = 1f;

	public Transform origin;

	public GameObject dungeonBGM;

	public GameObject oldHouse3Dolls;

	public ScriptPlayerPrefs scriptPlayerPrefs;

	public void Start()
	{
		scriptPlayerPrefs = GetComponent<ScriptPlayerPrefs>();
		if (PlayerPrefs.GetString(base.gameObject.name + "事件完成状态") == "完成" && MonoSingleton<BackpackManager>.Instance.GetItemIsHave(ItemType._150103_线索_幻室_莉莉丝的出生证明))
		{
			MJButton.canOpen = true;
			LoadPlayerPrefs.Invoke();
		}
	}

	public void OnDestroy()
	{
		trainLight.RemoveAllListeners();
		LoadPlayerPrefs.RemoveAllListeners();
	}

	private void Update()
	{
		if (Input.GetKeyUp(KeyCode.P))
		{
			Jump();
		}
	}

	internal void WheelCheck()
	{
		if (Vector3.Distance(objs[0].position, objs[1].position) + Vector3.Distance(objs[1].position, objs[2].position) + Vector3.Distance(objs[2].position, objs[3].position) <= faultToleranceValues)
		{
			UnityEngine.Debug.Log("转盘判断进入");
			MonoSingleton<EasyVRScreenFade>.Instance.FadeOpen(0.5f);
			MonoSingleton<PlayerInfo>.Instance.canInput = false;
			Invoke("Jump", 0.5f);
		}
	}

	public void Jump()
	{
		MonoBehaviour.print("跳");
		MonoSingleton<PlayerInfo>.Instance.SetPos(pos);
		trainLight.Invoke();
		MonoSingleton<EasyVRScreenFade>.Instance.FadeClose(0.5f);
		dungeonBGM.GetComponent<AudioSource>().clip = MonoSingleton<AudioManager>.Instance.audioDict[AudioType._14015_火车运行的声音.GetHashCode()].clip;
		MonoSingleton<PlayerInfo>.Instance.gameObject.GetComponent<AudioSource>().clip = MonoSingleton<AudioManager>.Instance.audioDict[AudioType._90032_玩家拎油灯走在地毯.GetHashCode()].clip;
		MonoSingleton<PlayerInfo>.Instance.canInput = true;
		scriptPlayerPrefs.isFinish = true;
		scriptPlayerPrefs.Save();
	}
}
public class WheelOrganRotate : MonoBehaviour
{
	public int index;

	public float angle = 45f;

	public AudioType audioType = AudioType._14008_转动第一轮盘;

	private void Start()
	{
		audioType = (AudioType)(14007 + base.name.SuffixToInt(1));
		Rotate(playAudio: false);
		UnityEngine.Debug.LogError(base.name + "   len:" + base.name.Length + "   ");
		UnityEngine.Debug.LogError(base.name.SuffixToInt(1));
	}

	public void Add()
	{
		index++;
		Rotate();
	}

	public void Rotate(bool playAudio = true)
	{
		base.transform.TweenLocalRotationY((float)index % (360f / angle) * angle, playAudio ? audioType.Length() : 0f).SetOnComplete(delegate
		{
			GetComponentInParent<WheelOrganLevel>().WheelCheck();
		});
		MonoSingleton<AudioManager>.Instance.Play(audioType, base.transform.position);
	}
}
public class AchievementCanUnlock : MonoSingleton<AchievementCanUnlock>
{
	public bool canUnlock = true;

	public GameObject steamAchievement;

	public void Start()
	{
		if (canUnlock)
		{
			steamAchievement.SetActive(value: true);
		}
		else
		{
			steamAchievement.SetActive(value: false);
		}
	}
}
public class ChangeFOV : MonoBehaviour
{
	public EasyVRHandController leftHand;

	public EasyVRHandController rightHand;

	public Text text;

	private void Update()
	{
		if (MonoSingleton<PlayerInfo>.Instance.rightController.APressDown)
		{
			GetComponent<Camera>().fieldOfView -= 1f;
			text.text = GetComponent<Camera>().fieldOfView.ToString();
		}
		if (MonoSingleton<PlayerInfo>.Instance.rightController.GripPressDown)
		{
			GetComponent<Camera>().fieldOfView += 1f;
			text.text = GetComponent<Camera>().fieldOfView.ToString();
		}
		if (Input.GetKeyDown(KeyCode.I))
		{
			GetComponent<Camera>().fieldOfView -= 1f;
		}
		if (Input.GetKeyDown(KeyCode.O))
		{
			GetComponent<Camera>().fieldOfView += 1f;
		}
	}
}
public class CloseBlackCanvasInvoke : MonoBehaviour
{
	private void Start()
	{
		BlackCanva.BlackCanvasSignal.Invoke();
	}
}
public class ClueNumList : MonoSingleton<ClueNumList>
{
	public List<int> clueNumList;
}
public class CtrlPlayableDirectorEnable : MonoBehaviour
{
	public void Start()
	{
	}

	public void CloseEnable()
	{
		GetComponent<PlayableDirector>().enabled = false;
	}

	public void ClearAnimator()
	{
		GetComponent<Animator>().runtimeAnimatorController = null;
	}
}
public class EquipmentImageChange : MonoBehaviour
{
	public Sprite htcImage;

	public Sprite oculusImage;

	public Sprite indexImage;

	public List<Sprite> picoSprite;

	private void Start()
	{
		if (SystemInfo.deviceModel.Contains("Neo 3"))
		{
			GetComponent<Image>().sprite = picoSprite[0];
			GetComponent<Image>().SetNativeSize();
			base.transform.GetChild(0).transform.position = base.transform.GetChild(1).transform.position;
		}
		else
		{
			GetComponent<Image>().sprite = picoSprite[1];
			GetComponent<Image>().SetNativeSize();
		}
	}
}
public class BlackCanva : MonoSingleton<BlackCanva>
{
	public static Signal BlackCanvasSignal = new Signal();

	public MJFSM.UIPanelType myType;

	public bool isBreathing;

	public bool canShow = true;

	private void Start()
	{
		BlackCanvasSignal.AddListener(CloseBlackCanvas);
	}

	private void CloseBlackCanvas()
	{
		foreach (Transform item in base.transform)
		{
			UnityEngine.Debug.LogError(item.name);
			item.gameObject.SetActive(value: false);
			MonoBehaviour.print("取消黑屏");
		}
	}

	private void Update()
	{
		Show();
	}

	public void Show()
	{
		if (MonoSingleton<GlobalManager>.Instance.CurrentScene != MJFSM.SceneType.新手教程)
		{
			return;
		}
		if (canShow && MonoSingleton<GlobalManager>.Instance.CurrentUI == MJFSM.UIPanelType.黑屏过渡 && !isBreathing)
		{
			canShow = false;
			MonoSingleton<SubtitleManager>.Instance.Play(9201);
			base.transform.GetChild(0).gameObject.SetActive(value: true);
			this.AttachTimer(23f, delegate
			{
				base.transform.GetChild(0).GetChild(0).gameObject.SetActive(value: true);
			});
		}
		if (isBreathing)
		{
			base.transform.GetChild(0).gameObject.SetActive(value: false);
		}
	}
}
public class Bookcase : CheckStaticItem
{
	[SerializeField]
	private int num;

	[SerializeField]
	private bool timeStart;

	[SerializeField]
	private float CD;

	public static bool bookFinish;

	public bool playSubtitle;

	public override void Init()
	{
		UnityEngine.Debug.LogError(base.name);
		itemType = (ItemType)Tools.Name2Int(base.name);
	}

	private void Update()
	{
		if (timeStart)
		{
			CD -= Time.deltaTime;
		}
	}

	public override void ShowText()
	{
		num++;
		if (num == 1)
		{
			MonoSingleton<SubtitleManager>.Instance.Play(1043);
			MonoSingleton<AudioManager>.Instance.Play(AudioType._90005_提示音的音效, MonoSingleton<PlayerInfo>.Instance.GetEasyVRHeadPos());
			this.AttachTimer(4f, delegate
			{
				playSubtitle = true;
			});
		}
		if (num < 2 || !(CD <= 0f) || bookFinish)
		{
			return;
		}
		if (MonoSingleton<GlobalManager>.Instance.language == LanguageType.中文)
		{
			if (playSubtitle)
			{
				MonoSingleton<SubtitleManager>.Instance.Play(1044);
			}
			MonoBehaviour.print("播放1044");
		}
		else if (playSubtitle)
		{
			MonoSingleton<SubtitleManager>.Instance.Play(1044);
		}
		MonoSingleton<AudioManager>.Instance.Play(AudioType._90005_提示音的音效, MonoSingleton<PlayerInfo>.Instance.GetEasyVRHeadPos());
		CD = 120f;
		timeStart = true;
	}
}
public class ClimbTheStairs : MJListen
{
	public float speed = 0.9f;

	public AudioClip[] walkClip;

	public override void OnTrigger()
	{
		base.OnTrigger();
		MonoSingleton<PlayerInfo>.Instance.gameObject.GetComponent<JoyStickMovement2>().Speed = speed;
		MonoSingleton<PlayerInfo>.Instance.gameObject.GetComponent<AudioSource>().clip = walkClip[1];
	}

	public override void ExitTrigger()
	{
		base.ExitTrigger();
		MonoBehaviour.print("退出楼梯");
		MonoSingleton<PlayerInfo>.Instance.gameObject.GetComponent<JoyStickMovement2>().Speed = 1f;
		MonoSingleton<PlayerInfo>.Instance.gameObject.GetComponent<AudioSource>().clip = walkClip[0];
	}
}
public class DeathBox : MonoBehaviour
{
	public Transform originTransform;

	public void OnTriggerEnter(Collider collision)
	{
		if (collision.gameObject.CompareTag("Player"))
		{
			UnityEngine.Debug.Log("传送");
			try
			{
				TeleportByPlayerPrefs();
			}
			catch (Exception)
			{
				Teleport(originTransform);
				throw;
			}
		}
	}

	public void Teleport(Transform transform)
	{
		MonoSingleton<PlayerInfo>.Instance.SetPos(transform);
	}

	public void TeleportByPlayerPrefs()
	{
		MonoSingleton<PlayerInfo>.Instance.SetPos(new Vector3(PlayerPrefs.GetFloat("x"), PlayerPrefs.GetFloat("y"), PlayerPrefs.GetFloat("z")));
	}
}
public enum DoorType
{
	None,
	冰箱,
	铁门
}
public class GlassBall : MonoBehaviour
{
	private Rigidbody rb;

	public float speed;

	private Vector3 direction;

	private void Start()
	{
		rb = GetComponent<Rigidbody>();
	}

	public void RollUseForce()
	{
		rb.AddForce(base.transform.forward * speed);
		MonoBehaviour.print("滚动");
	}

	public void RollUseSpeed()
	{
		base.transform.Translate(Vector3.forward * speed * Time.deltaTime);
		MonoBehaviour.print("滚动");
	}

	public void RollUseVelocity()
	{
		direction = new Vector3(0.01f, 0f, 0f);
		rb.velocity = speed * direction;
	}
}
public enum DrawerObjType
{
	None,
	鬼手
}
public class Filter : MonoBehaviour
{
	public FilterType currentFilter;
}
public enum FilterType
{
	None,
	古宅正常,
	古宅1回忆,
	古宅2回忆,
	古宅3回忆,
	古宅1鬼镜,
	古宅2鬼镜,
	鬼宅3鬼镜
}
public class FilterAnimatorControl : MonoBehaviour
{
	public FilterType filterType;

	private void Update()
	{
		if (base.transform.parent.GetComponent<Filter>().currentFilter == filterType)
		{
			if (!GetComponent<Animator>().enabled)
			{
				GetComponent<Animator>().enabled = true;
			}
			else if (GetComponent<PlayableDirector>() != null)
			{
				GetComponent<PlayableDirector>().enabled = true;
			}
		}
		else if (GetComponent<Animator>().enabled)
		{
			GetComponent<Animator>().enabled = false;
		}
	}
}
public class GhostHand : MonoBehaviour
{
	public void RearwardMovement()
	{
		GetComponent<Animator>().enabled = true;
		MonoSingleton<AudioManager>.Instance.Play(AudioType._12042_抽屉里的鬼手音效, base.transform.position);
	}
}
public class JohnPhoto : ClueItem
{
	public override void PressDown()
	{
		base.PressDown();
		AudioType._12072_拿到琼恩照片.Play();
	}
}
public class MosquitoSound : MonoBehaviour
{
	public DoorInfo doorInfo;

	private AudioSource audioSource;

	public float volume;

	private float time;

	private void Start()
	{
		audioSource = GetComponent<AudioSource>();
	}

	private void Update()
	{
		if (doorInfo.min != 0f)
		{
			audioSource.volume = Mathf.Clamp(doorInfo.angle / doorInfo.min, 0f, 0.3f);
			volume = audioSource.volume;
		}
		if (doorInfo.isOpen)
		{
			time += 1f * Time.deltaTime;
		}
		else
		{
			time = 0f;
		}
		if (time >= 30f)
		{
			volume = 0f;
		}
	}
}
public class ObjectActive : MonoBehaviour
{
	public DoorInfo doorInfo;

	public Drawer drawer;

	private void Start()
	{
		EventManager.AddListener<MJFSM.Process>(MJFSM.MJEvents._0_Process, StartHideObject);
	}

	public void StartHideObject(MJFSM.Process x)
	{
		if (x != MJFSM.Process._1001优先级一)
		{
			return;
		}
		base.gameObject.GetComponent<BoxCollider>().enabled = false;
		GetComponentInChildren<ArrowLookCamera>()?.Hide();
		foreach (Transform item in base.gameObject.transform)
		{
			item.gameObject.SetActive(value: false);
			MonoBehaviour.print("隐藏三角");
		}
	}

	private void OnDestroy()
	{
		EventManager.RemoveListener<MJFSM.Process>(MJFSM.MJEvents._0_Process, StartHideObject);
	}

	private void Update()
	{
		if (doorInfo != null && doorInfo.isOpen)
		{
			base.gameObject.GetComponent<Collider>().enabled = true;
			base.transform.GetChild(0).gameObject.SetActive(value: true);
		}
		else if (doorInfo != null && !doorInfo.isOpen)
		{
			base.gameObject.GetComponent<Collider>().enabled = false;
			GetComponentInChildren<ArrowLookCamera>()?.Hide();
		}
		if (drawer != null && drawer.open)
		{
			base.gameObject.GetComponent<Collider>().enabled = true;
			base.transform.GetChild(0).gameObject.SetActive(value: true);
		}
		else if (drawer != null && !drawer.open)
		{
			base.gameObject.GetComponent<Collider>().enabled = false;
			GetComponentInChildren<ArrowLookCamera>()?.Hide();
		}
	}
}
public class ClueItemList : MonoSingleton<ClueItemList>
{
	public List<ItemType> clueItemList;
}
public class CluePlayerPrefsSave : MonoBehaviour
{
	public MonoBehaviour mono;

	public bool isHave;

	public void Start()
	{
		if (MonoSingleton<PlayerPrefsGame>.Instance.isLoad)
		{
			this.AttachTimer(0.5f, Load);
		}
	}

	public void Save()
	{
		if (isHave)
		{
			PlayerPrefs.SetString(base.gameObject.name + "这个线索是否被拾取过", "是");
			MonoBehaviour.print("存档场景线索:" + base.gameObject.GetComponent<ClueItem>().info.id);
		}
		else
		{
			PlayerPrefs.SetString(base.gameObject.name + "这个线索是否被拾取过", "否");
		}
	}

	public void Load()
	{
		if (PlayerPrefs.GetString(base.gameObject.GetComponent<ClueItem>().info.id.ToString() + "这个线索是否被拾取过") == "是")
		{
			isHave = true;
		}
		else
		{
			isHave = false;
		}
		if (isHave)
		{
			mono.Invoke("IsHave", 0f);
		}
		MonoBehaviour.print("存档读取场景线索:" + base.gameObject.GetComponent<ClueItem>().info.id.ToString() + "状态:" + PlayerPrefs.GetString(base.gameObject.GetComponent<ClueItem>().info.id.ToString() + "这个线索是否被拾取过"));
	}
}
public class GOPlayerPrefsSave : MonoBehaviour
{
	private bool isDestory;

	private void Start()
	{
		if (MonoSingleton<PlayerPrefsGame>.Instance.isLoad)
		{
			if (PlayerPrefs.GetInt("IsDestory") == 1)
			{
				base.gameObject.SetActive(value: false);
			}
			LoadGOInfo();
		}
	}

	private void OnDestroy()
	{
		isDestory = true;
		PlayerPrefs.SetInt("IsDestory", 1);
	}

	public void LoadGOInfo()
	{
		LoadPos();
		LoadRotation();
	}

	public void LoadPos()
	{
		base.transform.position = new Vector3(PlayerPrefs.GetFloat("PosX" + base.name), PlayerPrefs.GetFloat("PosY" + base.name), PlayerPrefs.GetFloat("PosZ" + base.name));
	}

	public void LoadRotation()
	{
		base.transform.localEulerAngles = new Vector3(PlayerPrefs.GetFloat("RotationX" + base.name), PlayerPrefs.GetFloat("RotationY" + base.name), PlayerPrefs.GetFloat("RotationZ" + base.name));
	}

	public void SaveGOInfo()
	{
		SavePos();
		SaveRotation();
	}

	public void SavePos()
	{
		PlayerPrefs.SetFloat("PosX" + base.name, base.transform.position.x);
		PlayerPrefs.SetFloat("PosY" + base.name, base.transform.position.y);
		PlayerPrefs.SetFloat("PosZ" + base.name, base.transform.position.z);
	}

	public void SaveRotation()
	{
		PlayerPrefs.SetFloat("RotationX" + base.name, base.transform.localEulerAngles.x);
		PlayerPrefs.SetFloat("RotationY" + base.name, base.transform.localEulerAngles.y);
		PlayerPrefs.SetFloat("RotationZ" + base.name, base.transform.localEulerAngles.z);
	}
}
public class NormalItemList : MonoSingleton<NormalItemList>
{
	public List<GameObject> itemList;

	private void Start()
	{
		GameObject[] array = GameObject.FindGameObjectsWithTag("NormalItem");
		foreach (GameObject gameObject in array)
		{
			itemList.Add(gameObject);
			if (gameObject.GetComponent<GOPlayerPrefsSave>() == null)
			{
				gameObject.AddComponent<GOPlayerPrefsSave>();
			}
		}
		if (MonoSingleton<PlayerPrefsGame>.Instance.isLoad)
		{
			for (int j = 0; j < itemList.Count; j++)
			{
				itemList[j].GetComponent<GOPlayerPrefsSave>().LoadGOInfo();
			}
		}
	}

	public void SaveGOInfo()
	{
		SavePos();
		SaveRotation();
	}

	public void SavePos()
	{
		for (int i = 0; i < itemList.Count; i++)
		{
			PlayerPrefs.SetFloat("GOPosX" + i, itemList[i].transform.position.x);
			PlayerPrefs.SetFloat("GOPosY" + i, itemList[i].transform.position.y);
			PlayerPrefs.SetFloat("GOPosZ" + i, itemList[i].transform.position.z);
		}
	}

	public void SaveRotation()
	{
		PlayerPrefs.SetFloat("RotationX" + base.name, base.transform.localEulerAngles.x);
		PlayerPrefs.SetFloat("RotationY" + base.name, base.transform.localEulerAngles.y);
		PlayerPrefs.SetFloat("RotationZ" + base.name, base.transform.localEulerAngles.z);
	}
}
public class PlayerPrefsGame : MonoSingleton<PlayerPrefsGame>
{
	private int i;

	public bool isLoad;

	public ClueUIPanel clueUIPanel;

	public void Save(bool CanSavePos = true)
	{
		if (CanSavePos)
		{
			SavePos();
		}
		SaveScene();
		SaveItem();
		SaveClue();
		SaveSceneTaskItem();
		SaveSceneClueItem();
		if (MonoSingleton<GlobalManager>.Instance.language == LanguageType.中文)
		{
			EventsCentral.Tips.Invoke("游戏保存中");
		}
		else if (MonoSingleton<GlobalManager>.Instance.language == LanguageType.English)
		{
			EventsCentral.Tips.Invoke("Saving");
		}
		else if (MonoSingleton<GlobalManager>.Instance.language == LanguageType.西班牙语)
		{
			EventsCentral.Tips.Invoke("juego guardado");
		}
		else if (MonoSingleton<GlobalManager>.Instance.language == LanguageType.意大利语)
		{
			EventsCentral.Tips.Invoke("salvataggio del gioco");
		}
		else if (MonoSingleton<GlobalManager>.Instance.language == LanguageType.德语)
		{
			EventsCentral.Tips.Invoke("Spiel speichern");
		}
		else if (MonoSingleton<GlobalManager>.Instance.language == LanguageType.日语)
		{
			EventsCentral.Tips.Invoke("ゲームセーブ");
		}
		else if (MonoSingleton<GlobalManager>.Instance.language == LanguageType.韩语)
		{
			EventsCentral.Tips.Invoke("게임 저장 중");
		}
		GameObject[] array = GameObject.FindGameObjectsWithTag("TriggerEvent");
		foreach (GameObject gameObject in array)
		{
			if (gameObject.GetComponent<TriggerEventPlayerPres>() != null)
			{
				gameObject.GetComponent<TriggerEventPlayerPres>().SaveTriggerEventInfo();
				MonoBehaviour.print("保存事件:" + gameObject.name);
			}
		}
		PlayerPrefs.SetInt("存档", 1);
		PlayerPrefs.Save();
	}

	public void SavePos()
	{
		PlayerPrefs.SetFloat("x", MonoSingleton<PlayerInfo>.Instance.transform.position.x);
		PlayerPrefs.SetFloat("y", MonoSingleton<PlayerInfo>.Instance.transform.position.y);
		PlayerPrefs.SetFloat("z", MonoSingleton<PlayerInfo>.Instance.transform.position.z);
		UnityEngine.Debug.Log(base.transform.position.x + "_" + base.transform.position.y + "_" + base.transform.position.z);
	}

	public void SaveItem()
	{
		this.i = 0;
		ItemInfo[] backpack = MonoSingleton<BackpackManager>.Instance.backpack;
		foreach (ItemInfo itemInfo in backpack)
		{
			this.i++;
			if (itemInfo != null)
			{
				if (itemInfo.id == ItemType.None)
				{
					break;
				}
				PlayerPrefs.SetFloat("item" + this.i, itemInfo.id.GetHashCode());
				MonoBehaviour.print("存档保存物品:" + this.i + itemInfo.id);
			}
			else
			{
				PlayerPrefs.DeleteKey("item" + this.i);
			}
		}
		if (MonoSingleton<PlayerInfo>.Instance.rightTouch.selectedObj != null && MonoSingleton<PlayerInfo>.Instance.rightTouch.selectedInteractionBase.GetItemType().GetItemInfo() != null)
		{
			PlayerPrefs.SetFloat("手中物品", MonoSingleton<PlayerInfo>.Instance.rightTouch.selectedInteractionBase.GetItemType().GetItemInfo().id.GetHashCode());
		}
		MonoBehaviour.print("存档保存手中物品:" + (ItemType)PlayerPrefs.GetFloat("手中物品"));
	}

	public void SaveSceneTaskItem()
	{
		if (MonoSingleton<TaskItemList>.Instance.taskItemList != null)
		{
			for (int i = 0; i < MonoSingleton<TaskItemList>.Instance.taskItemList.Count; i++)
			{
				PlayerPrefs.SetString(MonoSingleton<TaskItemList>.Instance.taskItemList[i].ToString() + "这个物品是否被拾取过", "是");
				MonoBehaviour.print("存档场景物品：" + MonoSingleton<TaskItemList>.Instance.taskItemList[i]);
			}
		}
	}

	public void SaveClue()
	{
		this.i = 0;
		foreach (KeyValuePair<ItemType, ItemInfo> item in MonoSingleton<BackpackManager>.Instance.ClueDict)
		{
			this.i++;
			if (item.Key.GetItemInfo().isHave)
			{
				PlayerPrefs.SetInt("clue" + this.i, item.Key.GetHashCode());
				MonoBehaviour.print("保存线索:" + this.i + item.Key.GetHashCode());
				if (item.Value.read)
				{
					PlayerPrefs.SetInt("ClueRead" + this.i, 1);
				}
				else
				{
					PlayerPrefs.SetInt("ClueRead" + this.i, 0);
				}
				MonoBehaviour.print("存档保存ClueRead" + this.i + ":" + PlayerPrefs.GetInt("ClueRead" + this.i));
			}
			else
			{
				PlayerPrefs.SetInt("clue" + this.i, ItemType.None.GetHashCode());
			}
		}
		MonoBehaviour.print("num" + this.i);
		PlayerPrefs.SetInt("ClueUIPanelItemsCount", clueUIPanel.items.Count);
		MonoBehaviour.print("存档保存未读线索列表长度为：" + clueUIPanel.items.Count);
		if (clueUIPanel.items.Count != 0)
		{
			for (int i = 0; i < clueUIPanel.items.Count; i++)
			{
				PlayerPrefs.SetInt("ClueUIPanelItems" + i, clueUIPanel.items[i].GetHashCode());
				MonoBehaviour.print("存档保存未读线索为：" + clueUIPanel.items[i]);
			}
		}
	}

	public void SaveSceneClueItem()
	{
		if (MonoSingleton<ClueItemList>.Instance.clueItemList != null)
		{
			for (int i = 0; i < MonoSingleton<ClueItemList>.Instance.clueItemList.Count; i++)
			{
				PlayerPrefs.SetString(MonoSingleton<ClueItemList>.Instance.clueItemList[i].ToString() + "这个线索是否被拾取过", "是");
				MonoBehaviour.print("存档场景线索:" + MonoSingleton<ClueItemList>.Instance.clueItemList[i]);
			}
		}
	}

	public void SaveScene()
	{
		PlayerPrefs.SetInt("scene", MonoSingleton<GlobalManager>.Instance.CurrentScene.GetHashCode());
		MonoBehaviour.print((MJFSM.SceneType)MonoSingleton<GlobalManager>.Instance.CurrentScene.GetHashCode());
	}

	public void Load()
	{
		LoadPlayerPos();
		ItemInfo[] backpack = MonoSingleton<BackpackManager>.Instance.backpack;
		foreach (ItemInfo itemInfo in backpack)
		{
			if (itemInfo != null)
			{
				itemInfo.isHave = false;
			}
		}
		foreach (ItemInfo value in MonoSingleton<BackpackManager>.Instance.ClueDict.Values)
		{
			if (value != null)
			{
				value.isHave = false;
				value.read = false;
			}
		}
		LoadItem();
		LoadClue();
		MonoBehaviour.print("加载存档点:" + PlayerPrefs.GetInt("存档点"));
	}

	public void LoadScene()
	{
		isLoad = true;
		MonoBehaviour.print("存档读取场景:" + (MJFSM.SceneType)PlayerPrefs.GetInt("scene"));
		MonoSingleton<GlobalManager>.Instance.CurrentScene = (MJFSM.SceneType)PlayerPrefs.GetInt("scene");
		MonoBehaviour.print("加载存档场景");
	}

	public void LoadPlayerPos()
	{
		MonoSingleton<PlayerInfo>.Instance.SetPos(new Vector3(PlayerPrefs.GetFloat("x"), PlayerPrefs.GetFloat("y"), PlayerPrefs.GetFloat("z")));
		UnityEngine.Debug.Log(PlayerPrefs.GetFloat("x") + "_" + PlayerPrefs.GetFloat("y") + "_" + PlayerPrefs.GetFloat("z"));
		MonoBehaviour.print("存档加载玩家位置");
	}

	public void LoadItem()
	{
		this.i = 0;
		ItemInfo[] backpack = MonoSingleton<BackpackManager>.Instance.backpack;
		for (int i = 0; i < backpack.Length; i++)
		{
			_ = backpack[i];
			this.i++;
			MonoSingleton<BackpackManager>.Instance.AddItem((ItemType)PlayerPrefs.GetFloat("item" + this.i));
			MonoBehaviour.print("存档添加物品:" + (ItemType)PlayerPrefs.GetFloat("item" + this.i));
		}
		MonoBehaviour.print("存档读取手中物品:" + (ItemType)PlayerPrefs.GetFloat("手中物品"));
		if ((int)PlayerPrefs.GetFloat("手中物品") != 0)
		{
			MonoSingleton<BackpackManager>.Instance.AddItem((ItemType)PlayerPrefs.GetFloat("手中物品"));
		}
	}

	public void LoadClue()
	{
		i = 0;
		clueUIPanel.redPoint.enabled = false;
		foreach (KeyValuePair<ItemType, ItemInfo> item in MonoSingleton<BackpackManager>.Instance.ClueDict)
		{
			i++;
			MonoSingleton<BackpackManager>.Instance.AddItem((ItemType)PlayerPrefs.GetInt("clue" + i));
			MonoBehaviour.print("存档读取线索：" + i + (ItemType)PlayerPrefs.GetInt("clue" + i));
			if (MonoSingleton<BackpackManager>.Instance.GetItemIsHave(item.Key))
			{
				if (PlayerPrefs.GetInt("ClueRead" + i) == 1)
				{
					item.Value.read = true;
					clueUIPanel.redPoint.enabled = false;
					clueUIPanel.items.Remove(item.Key);
				}
				else
				{
					item.Value.read = false;
					if (item.Key != 0)
					{
						clueUIPanel.redPoint.enabled = true;
					}
				}
			}
			MonoBehaviour.print("存档读取ClueRead" + i + ":" + item.Value.read);
		}
		MonoBehaviour.print("存档读取未读线索列表长度为：" + PlayerPrefs.GetInt("ClueUIPanelItemsCount"));
		PlayerPrefs.GetInt("ClueUIPanelItemsCount");
	}

	public void Clear()
	{
		PlayerPrefs.DeleteAll();
	}
}
public class PlayerPrefsSaveListen : MJListen
{
	public int index;

	public override void OnTrigger()
	{
		base.OnTrigger();
		if (PlayerPrefs.GetInt("存档点") != index)
		{
			SaveGame();
			MonoBehaviour.print("保存");
		}
	}

	public override void StayTrigger()
	{
		base.StayTrigger();
		if (PlayerPrefs.GetInt("存档点") != index)
		{
			SaveGame();
			MonoBehaviour.print("保存");
		}
	}

	public void SaveGame()
	{
		if (!MonoSingleton<PlayerPrefsGame>.Instance.isLoad)
		{
			MonoSingleton<PlayerPrefsGame>.Instance.Save(CanSavePos: false);
			PlayerPrefs.SetInt("存档点", index);
			PlayerPrefs.SetFloat("x", base.transform.position.x);
			PlayerPrefs.SetFloat("y", base.transform.position.y);
			PlayerPrefs.SetFloat("z", base.transform.position.z);
			MonoBehaviour.print("保存存档点:" + index);
		}
	}

	public void LoadGame()
	{
		PlayerPrefs.GetInt("存档点");
		MonoSingleton<PlayerPrefsGame>.Instance.Load();
	}
}
public class ScriptPlayerPrefs : MonoBehaviour
{
	public MonoBehaviour mono;

	public bool isFinish;

	public void Start()
	{
		if (MonoSingleton<PlayerPrefsGame>.Instance.isLoad)
		{
			Load();
			if (isFinish)
			{
				mono.Invoke("Finish", 0f);
			}
		}
	}

	public void Save()
	{
		if (isFinish)
		{
			PlayerPrefs.SetString(base.gameObject.name + "事件完成状态", "完成");
		}
		else
		{
			PlayerPrefs.SetString(base.gameObject.name + "事件完成状态", "未完成");
		}
	}

	public void Load()
	{
		if (PlayerPrefs.GetString(base.gameObject.name + "事件完成状态") == "完成")
		{
			isFinish = true;
		}
		else
		{
			isFinish = false;
		}
	}
}
public class TaskItemList : MonoSingleton<TaskItemList>
{
	public List<ItemType> taskItemList;
}
public class TaskItemPlayerPrefs : MonoBehaviour
{
	public MonoBehaviour mono;

	public bool isHave;

	public void Start()
	{
		if (MonoSingleton<PlayerPrefsGame>.Instance.isLoad)
		{
			this.AttachTimer(0.8f, Load);
		}
	}

	public void Save()
	{
		if (isHave)
		{
			PlayerPrefs.SetString(base.gameObject.GetComponent<TaskItem>().info.id.ToString() + "这个物品是否被拾取过", "是");
		}
		else
		{
			PlayerPrefs.SetString(base.gameObject.GetComponent<TaskItem>().info.id.ToString() + "这个物品是否被拾取过", "否");
		}
	}

	public void Load()
	{
		if (PlayerPrefs.GetString(base.gameObject.GetComponent<TaskItem>().info.id.ToString() + "这个物品是否被拾取过") == "是")
		{
			isHave = true;
		}
		else
		{
			isHave = false;
		}
		if (isHave)
		{
			mono.Invoke("IsHave", 0f);
		}
		MonoBehaviour.print("存档读取场景物品:" + base.gameObject.GetComponent<TaskItem>().info.id.ToString() + "状态:" + PlayerPrefs.GetString(base.gameObject.GetComponent<TaskItem>().info.id.ToString() + "这个物品是否被拾取过"));
	}
}
public class TriggerEventData
{
	public string name;

	public bool isTrigger;

	public bool timeLineActiveState;
}
public class TriggerEventList : MonoSingleton<TriggerEventList>
{
	public List<TriggerEventData> triggerEventsList;

	public List<GameObject> triggerEventGOList;

	public List<GameObject> isTriggerGoList;

	public void Start()
	{
		GameObject[] array = GameObject.FindGameObjectsWithTag("TriggerEvent");
		foreach (GameObject gameObject in array)
		{
			triggerEventGOList.Add(gameObject);
			if (gameObject.GetComponent<TriggerEventPlayerPres>() == null)
			{
				gameObject.AddComponent<TriggerEventPlayerPres>();
			}
		}
	}
}
public class TriggerEventPlayerPres : MonoBehaviour
{
	public bool isTriggered;

	public GameObject triggerBox;

	public void Start()
	{
		UnityEngine.Debug.Log("isload" + MonoSingleton<PlayerPrefsGame>.Instance.isLoad);
		if (MonoSingleton<PlayerPrefsGame>.Instance.isLoad)
		{
			EventManager.AddListener(MJFSM.Process._1004优先级四, LoadTriggerEventInfo);
			MonoBehaviour.print("执行加载事件状态");
		}
	}

	private void OnDestroy()
	{
		EventManager.RemoveListener(MJFSM.Process._1004优先级四, LoadTriggerEventInfo);
	}

	public void LoadTriggerEventInfo()
	{
		LoadIsTriggered();
		LoadTime();
		LoadActive();
		MonoBehaviour.print("打开女鬼");
		MonoSingleton<PlayerPrefsGame>.Instance.isLoad = false;
	}

	public void LoadActive()
	{
		if (GetComponent<PlayableDirector>() != null)
		{
			if (PlayerPrefs.GetInt("Active" + base.name) == 1)
			{
				GetComponent<PlayableDirector>().enabled = true;
				GetComponent<PlayableDirector>().Play();
			}
			else
			{
				GetComponent<PlayableDirector>().enabled = false;
			}
		}
	}

	public void LoadTime()
	{
		if (GetComponent<PlayableDirector>() != null)
		{
			GetComponent<PlayableDirector>().initialTime = PlayerPrefs.GetFloat("InitialTime" + base.name);
			MonoBehaviour.print("存档Time:" + PlayerPrefs.GetFloat("InitialTime" + base.name) + base.gameObject.name);
		}
	}

	public void LoadIsTriggered()
	{
		if (PlayerPrefs.GetInt("IsTriggered" + base.name) == 1)
		{
			isTriggered = true;
			if (triggerBox != null)
			{
				triggerBox.GetComponent<Collider>().enabled = false;
			}
			else
			{
				UnityEngine.Debug.LogError("这个物体上的triggerBox为空:" + base.name);
			}
		}
		else
		{
			isTriggered = false;
		}
	}

	public void SaveTriggerEventInfo()
	{
		SaveTime();
		SaveActive();
		SaveIsTriggered();
	}

	public void SaveActive()
	{
		if (GetComponent<PlayableDirector>() != null)
		{
			if (GetComponent<PlayableDirector>().enabled)
			{
				PlayerPrefs.SetInt("Active" + base.name, 1);
			}
			else
			{
				PlayerPrefs.SetInt("Active" + base.name, 0);
			}
			PlayerPrefs.Save();
		}
	}

	public void SaveTime()
	{
		if (GetComponent<PlayableDirector>() != null)
		{
			PlayerPrefs.SetFloat("InitialTime" + base.name, (float)GetComponent<PlayableDirector>().time);
			MonoBehaviour.print("存档保存TimeLine时间:" + (float)GetComponent<PlayableDirector>().time + " TimeLine名字:" + base.name);
			PlayerPrefs.Save();
		}
	}

	public void SaveIsTriggered()
	{
		if (isTriggered)
		{
			PlayerPrefs.SetInt("IsTriggered" + base.name, 1);
		}
		else
		{
			PlayerPrefs.SetInt("IsTriggered" + base.name, 0);
		}
	}
}
public class PostProcessInfo : MonoBehaviour
{
	public FilterInfo[] filterInfos;

	public PostProcessVolume postprocess;

	public Animator animator;

	public bool isBreathing;

	public int breathingNum;

	public MJFilter Filter;

	private bool closeEye = true;

	private bool openEye;

	private float postExposureValue = -14f;

	private void Start()
	{
		postprocess = GetComponent<PostProcessVolume>();
		animator = GetComponent<Animator>();
		EventsCentral.EnbledPostProcess.AddListener(delegate(bool x)
		{
			postprocess.profile.GetSetting<Bloom>().active = x;
		});
	}

	public void ChangeFilter(MJFilter filter)
	{
		postprocess.profile = filterInfos[filter.GetHashCode()].processProfile;
		if (filter != 0)
		{
			animator.Play(filterInfos[filter.GetHashCode()].animationClip.name);
		}
	}
}
[Serializable]
public class FilterInfo
{
	public MJFilter type;

	public PostProcessProfile processProfile;

	public AnimationClip animationClip;
}
public enum MJFilter
{
	None,
	回忆滤镜
}
public class RayTrigger : MonoSingleton<RayTrigger>
{
	private RaycastHit hit;

	private Ray ray;

	public GameObject outGameobject;

	private void Start()
	{
	}

	private void Update()
	{
		ray.direction = base.transform.forward;
		ray.origin = base.transform.position;
		if (Physics.Raycast(ray, out hit, 4.5f))
		{
			outGameobject = hit.collider.gameObject;
		}
		UnityEngine.Debug.DrawLine(ray.origin, base.transform.forward, Color.yellow);
	}
}
public class RefrigeratorDoor : DoorInfo
{
	public override void OpenDoor()
	{
		AudioType._12044_开冰箱门的音效.Play(base.transform, 20f);
	}

	public override void CloseDoor()
	{
		AudioType._12045_关冰箱门的音效.Play(base.transform, 20f);
	}
}
public class RockingChair : MJListen
{
	public override void OnTrigger()
	{
		if (ItemType._130022_物品_幻室__圣嘉恩秘闻Ⅴ_.GetItemInfo().isHave)
		{
			base.OnTrigger();
			GetComponent<Animator>().enabled = true;
			GetComponent<AudioSource>().enabled = true;
		}
		else if (MonoSingleton<PlayerInfo>.Instance.rightTouch.selectedInteractionBase != null && MonoSingleton<PlayerInfo>.Instance.rightTouch.selectedInteractionBase.GetItemType() == ItemType._130022_物品_幻室__圣嘉恩秘闻Ⅴ_)
		{
			base.OnTrigger();
			GetComponent<Animator>().enabled = true;
			GetComponent<AudioSource>().enabled = true;
		}
	}

	public void CanMoveToTrue()
	{
		MonoSingleton<PlayerInfo>.Instance.CanMove = true;
	}

	public void CanMoveToFalse()
	{
		MonoSingleton<PlayerInfo>.Instance.CanMove = false;
	}
}
public class ConfirmButton : EasyVRInteractionBase
{
	public LanguageSetting languageSetting;

	public ResolutionSetting resolutionSetting;

	public override void PressDown()
	{
		base.PressDown();
		Confirm();
	}

	public void Confirm()
	{
		Screen.SetResolution(resolutionSetting.width, resolutionSetting.height, fullscreen: true);
		if (languageSetting.index == 0)
		{
			MonoSingleton<GlobalManager>.Instance.language = LanguageType.中文;
			MonoSingleton<UIManager>.Instance.UIDict.Clear();
			MonoSingleton<BackpackManager>.Instance.ClueDict.Clear();
			MonoSingleton<BackpackManager>.Instance.DataDict.Clear();
			MonoSingleton<AudioManager>.Instance.audioDict.Clear();
			MonoSingleton<SubtitleManager>.Instance.subtitleDict.Clear();
			MonoSingleton<ReadData>.Instance.StartCoroutine(MonoSingleton<ReadData>.Instance.LoadData());
		}
		else
		{
			MonoSingleton<GlobalManager>.Instance.language = LanguageType.English;
			MonoSingleton<UIManager>.Instance.UIDict.Clear();
			MonoSingleton<BackpackManager>.Instance.ClueDict.Clear();
			MonoSingleton<BackpackManager>.Instance.DataDict.Clear();
			MonoSingleton<AudioManager>.Instance.audioDict.Clear();
			MonoSingleton<SubtitleManager>.Instance.subtitleDict.Clear();
			MonoSingleton<ReadData>.Instance.StartCoroutine(MonoSingleton<ReadData>.Instance.LoadData());
		}
	}
}
public class DisplayIndexButton : EasyVRInteractionBase
{
	public DisplayModeSetting displayModeSetting;

	public int displayModeNum;

	private void Start()
	{
		displayModeSetting = GetComponentInParent<DisplayModeSetting>();
		displayModeNum = displayModeSetting.displayModeNum;
	}

	public override void PressDown()
	{
		base.PressDown();
		GetComponent<Button>().onClick.Invoke();
		if (displayModeSetting.index == 0)
		{
			displayModeSetting.fullScreen = true;
		}
		if (displayModeSetting.index == 1)
		{
			displayModeSetting.fullScreen = false;
		}
	}

	public void ButtonLeft()
	{
		displayModeSetting.index--;
		if (displayModeSetting.index < 0)
		{
			displayModeSetting.index = displayModeNum - 1;
		}
	}

	public void ButtonRight()
	{
		displayModeSetting.index++;
		if (displayModeSetting.index > displayModeNum - 1)
		{
			displayModeSetting.index = 0;
		}
	}
}
public class DisplayMode : MonoBehaviour
{
	public bool fullScreen;

	public int displayModeNum;

	public int index;
}
public class DisplayModeSetting : MonoBehaviour
{
	public bool fullScreen;

	public int displayModeNum;

	public int index;
}
public class LanguageIndexButton : EasyVRInteractionBase
{
	public LanguageSetting languageSetting;

	public int languageNum;

	public void Start()
	{
		languageSetting = GetComponentInParent<LanguageSetting>();
		languageNum = languageSetting.languageNum;
	}

	public override void PressDown()
	{
		base.PressDown();
		GetComponent<Button>().onClick.Invoke();
	}

	public void ButtonLeft()
	{
		languageSetting.index--;
		if (languageSetting.index < 0)
		{
			languageSetting.index = languageNum - 1;
		}
		if (MonoSingleton<GlobalManager>.Instance.language == LanguageType.中文)
		{
			if (languageSetting.index == 0)
			{
				languageSetting.languageText.text = "中文";
			}
			else
			{
				languageSetting.languageText.text = "英文";
			}
		}
		else if (languageSetting.index == 0)
		{
			languageSetting.languageText.text = "Chinese";
		}
		else
		{
			languageSetting.languageText.text = "English";
		}
	}

	public void ButtonRight()
	{
		languageSetting.index++;
		if (languageSetting.index > languageNum - 1)
		{
			languageSetting.index = 0;
		}
		if (MonoSingleton<GlobalManager>.Instance.language == LanguageType.中文)
		{
			if (languageSetting.index == 0)
			{
				languageSetting.languageText.text = "中文";
			}
			else if (languageSetting.index == 1)
			{
				languageSetting.languageText.text = "英文";
			}
		}
		else if (MonoSingleton<GlobalManager>.Instance.language == LanguageType.English)
		{
			if (languageSetting.index == 0)
			{
				languageSetting.languageText.text = "Chinese";
			}
			else if (languageSetting.index == 1)
			{
				languageSetting.languageText.text = "English";
			}
		}
	}
}
public class LanguageSetting : MonoBehaviour
{
	public Text languageText;

	public int languageNum = 2;

	public int index;

	public void Start()
	{
		if (MonoSingleton<GlobalManager>.Instance.language == LanguageType.中文)
		{
			index = 0;
		}
		else
		{
			index = 1;
		}
		if (index == 0)
		{
			languageText.text = "中文";
		}
		else
		{
			languageText.text = "English";
		}
	}
}
public class Settings : MonoSingleton<Settings>
{
	public int soundVolume;

	public int operation;

	public int language;

	public int handedness;

	public int grab;

	public int backpack;

	public void Submit()
	{
		MonoSingleton<GlobalManager>.Instance.language = (LanguageType)(language % LanguageType.Length.GetHashCode());
	}
}
public class SettingsItemInfoBase : MonoBehaviour
{
	public int current;

	public Text content;

	public virtual void TurnPage(int num)
	{
	}
}
public class SettingsItemTurnPage : EasyVRInteractionBase
{
	public int num;

	public override void PressDown()
	{
		base.PressDown();
		GetComponentInParent<SettingsItemInfoBase>().TurnPage(num);
	}
}
public class SettingsLanguageItemInfo : SettingsItemInfoBase
{
	public override void TurnPage(int num)
	{
		base.TurnPage(num);
		content.text = ((LanguageType)(current % LanguageType.Length.GetHashCode())).ToString();
	}
}
public class ResolutionIndexButton : EasyVRInteractionBase
{
	public ResolutionSetting resolutionSetting;

	public int resolutionNum;

	public void Start()
	{
		resolutionSetting = GetComponentInParent<ResolutionSetting>();
		resolutionNum = resolutionSetting.resolutionNum;
	}

	public override void PressDown()
	{
		base.PressDown();
		GetComponent<Button>().onClick.Invoke();
		if (resolutionSetting.index == 0)
		{
			resolutionSetting.resolutionText.text = "1920*1080";
			resolutionSetting.width = 1902;
			resolutionSetting.height = 1080;
		}
		if (resolutionSetting.index == 1)
		{
			resolutionSetting.resolutionText.text = "1280*720";
			resolutionSetting.width = 1280;
			resolutionSetting.height = 720;
		}
	}

	public void ButtonLeft()
	{
		resolutionSetting.index--;
		if (resolutionSetting.index < 0)
		{
			resolutionSetting.index = resolutionNum - 1;
		}
	}

	public void ButtonRight()
	{
		resolutionSetting.index++;
		if (resolutionSetting.index > resolutionNum - 1)
		{
			resolutionSetting.index = 0;
		}
	}
}
public class ResolutionSetting : MonoBehaviour
{
	public Text resolutionText;

	public int resolutionNum;

	public int index;

	public int width;

	public int height;
}
public class ShowLogo : MonoBehaviour
{
	private void Start()
	{
		if (MonoSingleton<GlobalManager>.Instance.showLogo)
		{
			GetComponent<VideoPlayer>().enabled = true;
		}
		else
		{
			GetComponent<VideoPlayer>().enabled = false;
		}
		this.AttachTimer(22f, delegate
		{
			MonoSingleton<GlobalManager>.Instance.showLogo = false;
		});
	}

	private void Update()
	{
	}
}
public class FantasyRoom1GlobalSignal : GlobalManager
{
	public void EnterFantasyRoom2()
	{
		MonoSingleton<GlobalManager>.Instance.CurrentScene = MJFSM.SceneType.兰登卧室;
	}
}
public class GlobalSignal : MonoBehaviour
{
	public PostProcessVolume processVolume;

	public PostProcessProfile[] processProfile;

	private GameObject oilLamp;

	private GameObject BlackCanvas;

	public GameObject BloodCanvas;

	public Transform overVideoPos;

	private void Start()
	{
		processVolume = GameObject.FindGameObjectWithTag("PostProcess").GetComponent<PostProcessVolume>();
		oilLamp = GameObject.FindGameObjectWithTag("OilLamp");
		BlackCanvas = GameObject.Find("BlackCanva");
		BloodCanvas = GameObject.Find("BloodCanvas");
		UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
	}

	public void OpenMemory(string filterType)
	{
		processVolume.profile = processProfile[0];
		if (filterType == "古宅1回忆滤镜")
		{
			if (MonoSingleton<UsePostProcess>.Instance.canUsePostProcess)
			{
				processVolume.gameObject.GetComponent<Filter>().currentFilter = FilterType.古宅1回忆;
			}
			else
			{
				MonoSingleton<UsePostProcess>.Instance.ball.GetComponent<MeshRenderer>().material = MonoSingleton<UsePostProcess>.Instance.memoryMaterial;
				MonoSingleton<UsePostProcess>.Instance.ball.GetComponent<MeshRenderer>().enabled = true;
				MonoSingleton<UsePostProcess>.Instance.cameraRT.targetTexture = MonoSingleton<UsePostProcess>.Instance.rt;
			}
		}
		if (filterType == "古宅2回忆滤镜")
		{
			if (MonoSingleton<UsePostProcess>.Instance.canUsePostProcess)
			{
				processVolume.gameObject.GetComponent<Filter>().currentFilter = FilterType.古宅1回忆;
			}
			else
			{
				MonoSingleton<UsePostProcess>.Instance.ball.GetComponent<MeshRenderer>().material = MonoSingleton<UsePostProcess>.Instance.memoryMaterial;
				MonoSingleton<UsePostProcess>.Instance.ball.GetComponent<MeshRenderer>().enabled = true;
				MonoSingleton<UsePostProcess>.Instance.cameraRT.targetTexture = MonoSingleton<UsePostProcess>.Instance.rt;
			}
		}
		if (filterType == "古宅3回忆滤镜")
		{
			if (MonoSingleton<UsePostProcess>.Instance.canUsePostProcess)
			{
				processVolume.gameObject.GetComponent<Filter>().currentFilter = FilterType.古宅1回忆;
				return;
			}
			MonoSingleton<UsePostProcess>.Instance.ball.GetComponent<MeshRenderer>().material = MonoSingleton<UsePostProcess>.Instance.memoryMaterial;
			MonoSingleton<UsePostProcess>.Instance.ball.GetComponent<MeshRenderer>().enabled = true;
			MonoSingleton<UsePostProcess>.Instance.cameraRT.targetTexture = MonoSingleton<UsePostProcess>.Instance.rt;
		}
	}

	public void OpenNormal()
	{
		if (MonoSingleton<UsePostProcess>.Instance.canUsePostProcess)
		{
			processVolume.gameObject.GetComponent<Filter>().currentFilter = FilterType.古宅正常;
			processVolume.profile = processProfile[1];
		}
		else
		{
			MonoSingleton<UsePostProcess>.Instance.ball.GetComponent<MeshRenderer>().enabled = false;
			MonoSingleton<UsePostProcess>.Instance.cameraRT.targetTexture = null;
		}
	}

	public void OpenGhost(string filterType)
	{
		processVolume.profile = processProfile[2];
		if (filterType == "古宅1鬼镜")
		{
			if (MonoSingleton<UsePostProcess>.Instance.canUsePostProcess)
			{
				processVolume.gameObject.GetComponent<Filter>().currentFilter = FilterType.古宅1鬼镜;
			}
			else
			{
				MonoSingleton<UsePostProcess>.Instance.ball.GetComponent<MeshRenderer>().material = MonoSingleton<UsePostProcess>.Instance.ghostMaterial;
				MonoSingleton<UsePostProcess>.Instance.ball.GetComponent<MeshRenderer>().enabled = true;
				MonoSingleton<UsePostProcess>.Instance.cameraRT.targetTexture = MonoSingleton<UsePostProcess>.Instance.rt;
			}
		}
		if (filterType == "古宅2鬼镜")
		{
			if (MonoSingleton<UsePostProcess>.Instance.canUsePostProcess)
			{
				processVolume.gameObject.GetComponent<Filter>().currentFilter = FilterType.古宅1鬼镜;
			}
			else
			{
				MonoSingleton<UsePostProcess>.Instance.ball.GetComponent<MeshRenderer>().material = MonoSingleton<UsePostProcess>.Instance.ghostMaterial;
				MonoSingleton<UsePostProcess>.Instance.ball.GetComponent<MeshRenderer>().enabled = true;
				MonoSingleton<UsePostProcess>.Instance.cameraRT.targetTexture = MonoSingleton<UsePostProcess>.Instance.rt;
			}
		}
		if (filterType == "古宅3鬼镜")
		{
			if (MonoSingleton<UsePostProcess>.Instance.canUsePostProcess)
			{
				processVolume.gameObject.GetComponent<Filter>().currentFilter = FilterType.古宅1鬼镜;
				return;
			}
			MonoSingleton<UsePostProcess>.Instance.ball.GetComponent<MeshRenderer>().material = MonoSingleton<UsePostProcess>.Instance.ghostMaterial;
			MonoSingleton<UsePostProcess>.Instance.ball.GetComponent<MeshRenderer>().enabled = true;
			MonoSingleton<UsePostProcess>.Instance.cameraRT.targetTexture = MonoSingleton<UsePostProcess>.Instance.rt;
		}
	}

	public void Rotate90()
	{
		base.transform.rotation = Quaternion.Euler(0f, 90f, 0f);
	}

	public void Rotate0()
	{
		base.transform.rotation = Quaternion.Euler(0f, 0f, 0f);
	}

	public void OpenOilLight()
	{
	}

	public void CloseOilLight()
	{
	}

	public void ShowBlackCanvas()
	{
		BlackCanvas.transform.GetChild(2).gameObject.SetActive(value: true);
	}

	public void ShowScreenFadeOpen()
	{
		MonoSingleton<EasyVRScreenFade>.Instance.FadeOpen();
	}

	public void ShowScreenFadeClose()
	{
		MonoSingleton<EasyVRScreenFade>.Instance.FadeClose();
	}

	public void AttachTimerShowBlackCanvas(float time)
	{
		this.AttachTimer(time, delegate
		{
			BlackCanvas.transform.GetChild(2).gameObject.SetActive(value: true);
		});
	}

	public void HideBlackCanvas()
	{
		BlackCanvas.transform.GetChild(2).gameObject.SetActive(value: false);
	}

	public void ShowBloodCanvas()
	{
		BloodCanvas.transform.GetChild(0).gameObject.SetActive(value: true);
		UnityEngine.Debug.Log("打开按钮");
	}

	public void HideBloodCanvas()
	{
		BloodCanvas.transform.GetChild(0).gameObject.SetActive(value: false);
		UnityEngine.Debug.Log("关闭按钮");
	}

	public void SpeedToNormal()
	{
		MonoSingleton<PlayerInfo>.Instance.CanMove = true;
		MonoSingleton<PlayerInfo>.Instance.SetSpeed(1f);
		MonoBehaviour.print("恢复速度");
	}

	public void SpeedToZero()
	{
		MonoSingleton<PlayerInfo>.Instance.CanMove = false;
	}

	public void PlayLilithCallOverSubtitle()
	{
	}

	public void PlayOverVideo()
	{
		MonoSingleton<OverallViewManager>.Instance.Play(3, autoClose: false, loop: false);
		this.AttachTimer((float)MonoSingleton<OverallViewManager>.Instance.videoClips[3].length, delegate
		{
			MonoSingleton<PlayerInfo>.Instance.SetEasyVRController(move: false, left: true, right: true);
			MonoSingleton<OverallViewManager>.Instance.transform.GetChild(0).gameObject.SetActive(value: true);
			MonoSingleton<PlayerInfo>.Instance.showRay = true;
		});
	}

	public void LoadLogin()
	{
		MonoSingleton<GlobalManager>.Instance.CurrentScene = MJFSM.SceneType.Login;
	}

	public void SaveGame()
	{
		MonoSingleton<PlayerPrefsGame>.Instance.Save();
	}

	public void EnterFantasyRoom2()
	{
		_ = MonoSingleton<AchievementCanUnlock>.Instance.canUnlock;
		MonoSingleton<GlobalManager>.Instance.CurrentScene = MJFSM.SceneType.兰登卧室;
	}

	public void OverVideoPause()
	{
	}
}
public class ObjectSignal : MonoBehaviour
{
	public void Rotate90()
	{
		base.transform.localRotation = Quaternion.Euler(0f, 90f, 0f);
	}

	public void Rotate0()
	{
		base.transform.localRotation = Quaternion.Euler(0f, 0f, 0f);
	}

	public void SoundRecorderLightBlink(GameObject soundRecorder)
	{
		soundRecorder.GetComponent<Animator>().SetBool("Up", value: true);
		soundRecorder.GetComponent<Animator>().SetBool("Press", value: false);
	}

	public void SoundRecorderLightDontBlink()
	{
		GetComponent<Animator>().SetTrigger("DontBlink");
	}

	public void LilithSongOver()
	{
		GetComponent<MuMaListen>().lilithSong.Stop();
		MonoSingleton<AudioManager>.Instance.Play(AudioType._12064_木马消失的音效);
		MonoSingleton<AudioManager>.Instance.Play(90013);
	}
}
[Serializable]
public class SubtitleInfo
{
	public int id;

	public string eventName;

	public string text;

	public string audioName;

	public int time;

	public AudioClip audioClip;
}
public class SubtitleManager : MonoSingleton<SubtitleManager>
{
	public Dictionary<int, SubtitleInfo> subtitleDict = new Dictionary<int, SubtitleInfo>();

	public SubtitleInfo[] subtitleInfos;

	private void Start()
	{
		MonoBehaviour.print("字典转数组");
		this.AttachTimer(3f, delegate
		{
			subtitleInfos = subtitleDict.Values.ToArray();
		});
	}

	public void Play(int id, Vector3 pos, float volume = 1f)
	{
		SubtitleUIPanel.subtitleUI.Invoke(id, subtitleDict[id].time);
		AudioSource.PlayClipAtPoint(subtitleDict[id].audioClip, pos, volume);
		if (id > 1200)
		{
			StartCoroutine(Continuous(id, pos, subtitleDict[id].audioClip.length));
		}
	}

	public void AttachTimerPlay(int id, Vector3 pos, float time)
	{
		this.AttachTimer(time, delegate
		{
			SubtitleUIPanel.subtitleUI.Invoke(id, subtitleDict[id].time);
		});
		AudioSource.PlayClipAtPoint(subtitleDict[id].audioClip, pos);
		if (id > 1200)
		{
			StartCoroutine(Continuous(id, pos, subtitleDict[id].audioClip.length));
		}
	}

	public void AttachTimerPlay(int id, float time)
	{
		AttachTimerPlay(id, MonoSingleton<PlayerInfo>.Instance.EasyVRHead.transform.position, time);
	}

	public void Play(int id)
	{
		Play(id, MonoSingleton<PlayerInfo>.Instance.EasyVRHead.transform.position);
	}

	public void Play(int id, float volume)
	{
		Play(id, MonoSingleton<PlayerInfo>.Instance.EasyVRHead.transform.position, volume);
	}

	public void Play(SubtitleType subtitleType)
	{
		Play(subtitleType.GetHashCode());
	}

	public void Play(SubtitleType subtitleType, Vector3 pos)
	{
		Play(subtitleType.GetHashCode(), pos);
	}

	public void Play(SubtitleType subtitleType, Transform transform)
	{
		Play(subtitleType.GetHashCode(), transform.position);
	}

	public void Update()
	{
	}

	private IEnumerator Continuous(int id, Vector3 pos, float time)
	{
		yield return new WaitForSeconds(time);
		id++;
		if (subtitleDict.ContainsKey(id))
		{
			Play(id, pos);
		}
	}
}
public class SubtitleTrigger : MonoBehaviour
{
	public SubtitleType subtitleType;

	private bool once;

	private void Start()
	{
		if (MonoSingleton<PlayerPrefsGame>.Instance.isLoad)
		{
			return;
		}
		EventManager.AddListener(MJFSM.Process._1001优先级一, delegate
		{
			if (!once)
			{
				MonoSingleton<SubtitleManager>.Instance.Play(subtitleType);
				MJBGM.SetBGMEvent.Invoke(AudioType._1051_老宅1的背景音效);
				once = true;
			}
		});
	}
}
public class SubtitleUIPanel : MonoBehaviour
{
	public static Signal<int, float> subtitleUI = new Signal<int, float>();

	private Text subtitleText;

	private void Start()
	{
		subtitleText = base.transform.GetChild(0).GetComponent<Text>();
		subtitleUI.AddListener(ShowUI);
	}

	private void ShowUI(int id, float audioLenth)
	{
		subtitleText.gameObject.SetActive(value: true);
		subtitleText.text = MonoSingleton<SubtitleManager>.Instance.subtitleDict[id].text;
		if (audioLenth != 0f)
		{
			Invoke("Hide", audioLenth);
		}
		else
		{
			Invoke("Hide", MonoSingleton<SubtitleManager>.Instance.subtitleDict[id].audioClip.length);
		}
	}

	private void Hide()
	{
		subtitleText.gameObject.SetActive(value: false);
	}
}
public class TakeAfterEvents : MJListen
{
	public void RockingChair(GameObject obj)
	{
		obj.GetComponent<Animator>().enabled = true;
	}

	public void RockingChair()
	{
		GetComponent<Animator>().enabled = true;
	}
}
public class BreakingVase : MonoBehaviour
{
	public Rigidbody[] rigidbodies;

	private Vector3 otherVelocity;

	private void Start()
	{
		TeachingProcess.smashedVase = false;
		rigidbodies = GetComponentsInChildren<Rigidbody>();
	}

	private void OnTriggerEnter(Collider other)
	{
		if (!(other.gameObject.GetComponent<TaskItem>() != null) || other.gameObject.GetComponent<TaskItem>().info.id != ItemType._110000_物品_新手教学_榔头)
		{
			return;
		}
		GetComponent<BoxCollider>().isTrigger = true;
		Rigidbody[] array = rigidbodies;
		foreach (Rigidbody rigidbody in array)
		{
			rigidbody.isKinematic = false;
			if (!TeachingProcess.smashedVase)
			{
				AudioType._1043_砸碎花瓶.Play(MonoSingleton<PlayerInfo>.Instance.EasyVRHead.transform);
				TeachingProcess.smashedVase = true;
			}
		}
	}
}
public class DeskTrigger : MonoBehaviour
{
	private void OnTriggerEnter(Collider other)
	{
		if (other.gameObject.tag == "Player")
		{
			EventManager.SendEvent("教学", TeachType.拾取物品, param2: true);
		}
	}
}
public class GuidanceText : MonoBehaviour
{
	[SerializeField]
	public MJFSM.SceneType sceneType;

	public GameObject guidanceText;

	private bool isTraining;

	private void Start()
	{
		EventManager.AddListener(MJFSM.Process._1004优先级四, delegate
		{
			GuidanceState();
		});
	}

	public void GuidanceState()
	{
		if (MonoSingleton<GlobalManager>.Instance.CurrentScene == sceneType)
		{
			guidanceText.SetActive(value: true);
			isTraining = false;
		}
		else if (MonoSingleton<GlobalManager>.Instance.CurrentScene != sceneType)
		{
			guidanceText.SetActive(value: false);
			isTraining = true;
		}
	}
}
public class ImageBlink : MonoBehaviour
{
	private bool blink = true;

	private void Update()
	{
		if (blink)
		{
			blink = false;
			StartCoroutine(Blink(0.5f));
		}
	}

	private IEnumerator Blink(float time)
	{
		yield return new WaitForSeconds(time);
		base.gameObject.GetComponent<Image>().enabled = !base.gameObject.GetComponent<Image>().enabled;
		blink = true;
	}
}
public class TableTrigger : MonoBehaviour
{
	private void OnTriggerEnter(Collider other)
	{
		_ = other.gameObject.tag == "Player";
	}
}
public class TeachingProcess : MonoBehaviour
{
	public static TeachType teachType;

	private float moveTime;

	public static Signal<TeachType, bool> training = new Signal<TeachType, bool>();

	public GameObject _light;

	public GameObject report;

	[Tooltip("锤子")]
	public GameObject hammer;

	public static bool smashedVase;

	public VideoClip videoClip;

	public Transform pos360;

	private bool 结束;

	private bool isBreathing;

	public AudioSource audio_di;

	private void Awake()
	{
	}

	private void Start()
	{
		Init();
	}

	private void OnDestroy()
	{
		training.RemoveAllListeners();
	}

	private void Init()
	{
		_ = SceneManager.GetActiveScene().buildIndex;
		_ = 1;
		MonoSingleton<PlayerInfo>.Instance.SetEasyVRController(move: true, left: true, right: true);
		report.transform.GetChild(0).gameObject.SetActive(value: false);
		teachType = TeachType.移动教学;
		MonoSingleton<BlackCanva>.Instance.canShow = true;
		MonoSingleton<BlackCanva>.Instance.isBreathing = false;
	}

	private void Update()
	{
		if (teachType == TeachType.开关手电 && MonoSingleton<PlayerInfo>.Instance.leftController.GripPressDown)
		{
			training.InvokeSafe(TeachType.开关手电, t2: false);
			training.InvokeSafe(TeachType.移动教学, t2: true);
			teachType++;
		}
		if (teachType == TeachType.移动教学 && (MonoSingleton<PlayerInfo>.Instance.rightController.JoyStickAxis.sqrMagnitude > 0.1f || MonoSingleton<PlayerInfo>.Instance.leftController.JoyStickAxis.sqrMagnitude > 0.1f))
		{
			moveTime += 1f * Time.deltaTime;
			if (moveTime >= 1f)
			{
				training.InvokeSafe(TeachType.移动教学, t2: false);
				training.InvokeSafe(TeachType.拾取物品, t2: true);
				teachType++;
			}
		}
		if (teachType == TeachType.拾取物品)
		{
			if (MonoSingleton<PlayerInfo>.Instance.rightTouch.selectedObj == null)
			{
				if (hammer != null)
				{
					hammer.transform.GetChild(0).gameObject.SetActive(value: true);
					hammer.layer = 9;
				}
			}
			else
			{
				MonoSingleton<PlayerInfo>.Instance.rightTouch.selectedObj.transform.GetChild(0).gameObject.SetActive(value: false);
			}
			if ((MonoSingleton<PlayerInfo>.Instance.rightController.TriggerPressed || MonoSingleton<PlayerInfo>.Instance.leftController.TriggerPressed) && MonoSingleton<PlayerInfo>.Instance.rightTouch.selectedObj != null && MonoSingleton<PlayerInfo>.Instance.rightTouch.selectedInteractionBase.GetItemType() == ItemType._110000_物品_新手教学_榔头)
			{
				training.InvokeSafe(TeachType.拾取物品, t2: false);
				training.InvokeSafe(TeachType.打开背包, t2: true);
				teachType++;
			}
		}
		if (teachType == TeachType.打开背包 && MonoSingleton<GlobalManager>.Instance.CurrentUI == MJFSM.UIPanelType.背包)
		{
			training.InvokeSafe(TeachType.打开背包, t2: false);
			training.InvokeSafe(TeachType.取出锤子, t2: true);
			teachType++;
		}
		if (teachType == TeachType.取出锤子 && MonoSingleton<PlayerInfo>.Instance.rightTouch.selectedObj != null && MonoSingleton<PlayerInfo>.Instance.rightTouch.selectedInteractionBase.GetItemType() == ItemType._110000_物品_新手教学_榔头)
		{
			training.InvokeSafe(TeachType.取出锤子, t2: false);
			training.InvokeSafe(TeachType.去砸花瓶, t2: true);
			teachType++;
			MonoBehaviour.print("拿出锤子");
		}
		if (teachType == TeachType.去砸花瓶)
		{
			_light.SetActive(value: true);
			if (smashedVase)
			{
				training.InvokeSafe(TeachType.去砸花瓶, t2: false);
				training.InvokeSafe(TeachType.拿照片, t2: true);
				MonoSingleton<BackpackManager>.Instance.RemoveItem(ItemType._110000_物品_新手教学_榔头);
				teachType++;
			}
		}
		if (teachType == TeachType.拿照片)
		{
			_ = MonoSingleton<PlayerInfo>.Instance.rightTouch.selectedObj == null;
			if (report != null)
			{
				report.transform.GetChild(0).gameObject.SetActive(value: true);
			}
			if (!report.GetComponent<ClueItem>().enabled)
			{
				report.GetComponent<ClueItem>().enabled = true;
			}
			report.layer = 9;
			report.GetComponent<BoxCollider>().enabled = true;
			if (MonoSingleton<PlayerInfo>.Instance.rightTouch.selectedInteractionBase != null && MonoSingleton<PlayerInfo>.Instance.rightTouch.selectedInteractionBase.name == "110101")
			{
				MonoSingleton<PlayerInfo>.Instance.rightTouch.selectedObj.transform.GetChild(0).gameObject.SetActive(value: false);
				if (teachType != TeachType.结束)
				{
					StartCoroutine(EnterNextTeach());
				}
			}
		}
		if (teachType == TeachType.结束)
		{
			StartCoroutine(teachingOver());
		}
	}

	private IEnumerator EnterNextTeach()
	{
		yield return new WaitForSeconds(2f);
		teachType = TeachType.结束;
		MonoBehaviour.print("进入结束环节");
	}

	private IEnumerator HideUI(TeachType teachType, float time)
	{
		yield return new WaitForSeconds(time);
		training.InvokeSafe(teachType, t2: false);
	}

	private IEnumerator teachingOver()
	{
		if (!结束)
		{
			结束 = true;
			training.InvokeSafe(TeachType.拿照片, t2: false);
			training.InvokeSafe(TeachType.结束, t2: true);
			MonoSingleton<GlobalManager>.Instance.CurrentUI = MJFSM.UIPanelType.黑屏过渡;
			MonoSingleton<PlayerInfo>.Instance.SetEasyVRController(move: false, left: false, right: false);
			yield return new WaitForSeconds(23f);
			audio_di.Play();
			Quaternion playerRotation = Quaternion.Euler(0f, 0f, 0f);
			MonoSingleton<PlayerInfo>.Instance.SetPos(MonoSingleton<PlayerInfo>.Instance.transform.position, playerRotation);
			yield return new WaitForSeconds(8f);
			MonoSingleton<OverallViewManager>.Instance.Play(2);
			yield return new WaitForSeconds(1f);
			audio_di.Stop();
			MonoSingleton<BlackCanva>.Instance.isBreathing = true;
			MonoSingleton<SubtitleManager>.Instance.Play(SubtitleType._9208_ICU_护士_他大出血了_需要手术);
			StartCoroutine(LoadFantasy());
		}
	}

	private IEnumerator LoadFantasy()
	{
		yield return new WaitForSeconds((float)videoClip.length);
		MonoSingleton<GlobalManager>.Instance.CurrentScene = MJFSM.SceneType.古宅;
	}
}
public enum TeachType
{
	开关手电,
	移动教学,
	拾取物品,
	打开背包,
	取出锤子,
	去砸花瓶,
	拿照片,
	结束,
	None
}
public class TrainingSession : MonoSingleton<TrainingSession>
{
	public Image[] teachingImage;

	public Text guidanceText;

	public GameObject BlackCanvas;

	private void Start()
	{
		Init();
		EventManager.AddListener(MJFSM.Process._1004优先级四, delegate
		{
			if (MonoSingleton<GlobalManager>.Instance.CurrentScene == MJFSM.SceneType.新手教程)
			{
				Init();
				MonoSingleton<GlobalManager>.Instance.CurrentUI = MJFSM.UIPanelType.教学;
				BlackCanvas.SetActive(value: true);
				Show();
				MonoBehaviour.print("新手教学监听优先四");
			}
		});
	}

	public void Init()
	{
		List<Image> list = new List<Image>();
		foreach (Transform item in base.transform)
		{
			list.Add(item.GetComponent<Image>());
		}
		teachingImage = list.ToArray();
		for (int i = 0; i < teachingImage.Length; i++)
		{
			teachingImage[i].gameObject.SetActive(value: false);
		}
	}

	public void Show()
	{
		guidanceText = base.transform.parent.Find("guidanceText").GetComponent<Text>();
		TeachingProcess.training += new Action<TeachType, bool>(Teaching);
		if (TeachingProcess.teachType == TeachType.移动教学)
		{
			TeachingProcess.training.InvokeSafe(TeachType.移动教学, t2: true);
			UnityEngine.Debug.Log("移动教学开始");
		}
		guidanceText.gameObject.SetActive(value: true);
	}

	public void Teaching(TeachType teachType, bool state)
	{
		if (teachingImage[teachType.GetHashCode()] != null)
		{
			teachingImage[teachType.GetHashCode()].gameObject.SetActive(state);
		}
		if (!state)
		{
			return;
		}
		switch (teachType)
		{
		case TeachType.开关手电:
			if (MonoSingleton<GlobalManager>.Instance.language == LanguageType.中文)
			{
				guidanceText.text = "欢迎进入迷禁的教学阶段\n现在你的手上有个油灯，按下左手柄侧边键可点燃或熄灭";
			}
			else if (MonoSingleton<GlobalManager>.Instance.language == LanguageType.English)
			{
				guidanceText.text = "Welcome to the tutorial of the Fog of Cage\nNow you have a lamp on your hand.\nClick the Grab Button on your left hand\nto turn on or turn off the lamp.";
			}
			else if (MonoSingleton<GlobalManager>.Instance.language == LanguageType.西班牙语)
			{
				guidanceText.text = "Empuje el joystick para moverse, trate de llegar a la mesa";
			}
			else if (MonoSingleton<GlobalManager>.Instance.language == LanguageType.意大利语)
			{
				guidanceText.text = "Spingere il bar a dondolo a muoversi e provare a camminare verso il tavolo";
			}
			else if (MonoSingleton<GlobalManager>.Instance.language == LanguageType.德语)
			{
				guidanceText.text = "Drücken Sie den Joystick, um sich zu bewegen, und versuchen Sie, zum Tisch zu gehen";
			}
			else if (MonoSingleton<GlobalManager>.Instance.language == LanguageType.日语)
			{
				guidanceText.text = "ロッカーを押して移動し、テーブルのそばまで歩いてみようとする";
			}
			else if (MonoSingleton<GlobalManager>.Instance.language == LanguageType.韩语)
			{
				guidanceText.text = "왼쪽 레버를 움직여 이동하고 탁상 옆에 걸어가려 한다";
			}
			break;
		case TeachType.移动教学:
			if (MonoSingleton<GlobalManager>.Instance.language == LanguageType.中文)
			{
				guidanceText.text = "推动左摇杆进行移动，尝试走到桌边";
			}
			else if (MonoSingleton<GlobalManager>.Instance.language == LanguageType.English)
			{
				guidanceText.text = "Try to push the left Move Button to get to the table.";
			}
			else if (MonoSingleton<GlobalManager>.Instance.language == LanguageType.西班牙语)
			{
				guidanceText.text = "Empuje el joystick izquierdo para moverse, trate de caminar hacia la mesa";
			}
			else if (MonoSingleton<GlobalManager>.Instance.language == LanguageType.意大利语)
			{
				guidanceText.text = "Spingi la levetta sinistra per muoverti, prova a camminare verso il tavolo";
			}
			else if (MonoSingleton<GlobalManager>.Instance.language == LanguageType.德语)
			{
				guidanceText.text = "Drücken Sie den linken Stick, um sich zu bewegen, und versuchen Sie, zum Tisch zu gehen";
			}
			else if (MonoSingleton<GlobalManager>.Instance.language == LanguageType.日语)
			{
				guidanceText.text = "左スティックを押して移動し、テーブルまで歩いてみてください";
			}
			else if (MonoSingleton<GlobalManager>.Instance.language == LanguageType.韩语)
			{
				guidanceText.text = "왼쪽 레버를 움직여 이동하고 탁상 옆에 걸어가려 한다";
			}
			break;
		case TeachType.拾取物品:
			if (MonoSingleton<GlobalManager>.Instance.language == LanguageType.中文)
			{
				guidanceText.text = "按扳机键可拿起桌上的锤子或者拿起磁带放入录音机中";
			}
			else if (MonoSingleton<GlobalManager>.Instance.language == LanguageType.English)
			{
				guidanceText.text = "Hold the Trigger to pick up the hammer on the table\nand then put the tape into the tape recorder";
			}
			else if (MonoSingleton<GlobalManager>.Instance.language == LanguageType.西班牙语)
			{
				guidanceText.text = "Mantenga presionado el gatillo para levantar un martillo en el escritorio o levante una cinta y póngala en la grabadora";
			}
			else if (MonoSingleton<GlobalManager>.Instance.language == LanguageType.意大利语)
			{
				guidanceText.text = "Tieni premuto il grilletto per prendere un martello sulla scrivania o prendi un nastro e mettilo nel registratore";
			}
			else if (MonoSingleton<GlobalManager>.Instance.language == LanguageType.德语)
			{
				guidanceText.text = "Halten Sie den Auslöser gedrückt, um einen Hammer vom Schreibtisch aufzuheben, oder nehmen Sie eine Kassette und legen Sie sie in den Rekorder";
			}
			else if (MonoSingleton<GlobalManager>.Instance.language == LanguageType.日语)
			{
				guidanceText.text = "引き金のボタンを押すと机の上のハンマーを取ったりテープを取ってテープレコーダーの中に入れることができる";
			}
			else if (MonoSingleton<GlobalManager>.Instance.language == LanguageType.韩语)
			{
				guidanceText.text = "방아쇠 버튼을 누르면 탁상 위 망치를 들거나 테이프를 녹음기에 넣는다";
			}
			break;
		case TeachType.打开背包:
			if (MonoSingleton<GlobalManager>.Instance.language == LanguageType.中文)
			{
				guidanceText.text = "按下右手柄B键打开背包,再次按下关闭背包";
			}
			else if (MonoSingleton<GlobalManager>.Instance.language == LanguageType.English)
			{
				guidanceText.text = "Press the B Button on your right hand\nto open the backpack.\nRelease the button to close the backpack.";
			}
			else if (MonoSingleton<GlobalManager>.Instance.language == LanguageType.西班牙语)
			{
				guidanceText.text = "Presione el botón B en el mango derecho para abrir la mochila, presione el botón B nuevamente para cerrar la mochila";
			}
			else if (MonoSingleton<GlobalManager>.Instance.language == LanguageType.意大利语)
			{
				guidanceText.text = "Premi il pulsante B sulla maniglia destra per aprire lo zaino, premi nuovamente il pulsante B per chiudere lo zaino";
			}
			else if (MonoSingleton<GlobalManager>.Instance.language == LanguageType.德语)
			{
				guidanceText.text = "Drücken Sie die B-Taste am rechten Griff, um den Rucksack zu öffnen, drücken Sie die B-Taste erneut, um den Rucksack zu schließen";
			}
			else if (MonoSingleton<GlobalManager>.Instance.language == LanguageType.日语)
			{
				guidanceText.text = "右ハンドルのBボタンを押してバックパックを開き、もう一度Bボタンを押してバックパックを閉じます";
			}
			else if (MonoSingleton<GlobalManager>.Instance.language == LanguageType.韩语)
			{
				guidanceText.text = "오른쪽 핸들B버튼을 누르면 가방을 열고, 다시 B버튼을 누르면 가방을 닫는다";
			}
			break;
		case TeachType.取出锤子:
			if (MonoSingleton<GlobalManager>.Instance.language == LanguageType.中文)
			{
				guidanceText.text = "选中道具，按下扳机键取出道具";
			}
			else if (MonoSingleton<GlobalManager>.Instance.language == LanguageType.English)
			{
				guidanceText.text = "Select the hammer in your backpack \nand then hold the Trigger to take it out of your backpack.";
			}
			else if (MonoSingleton<GlobalManager>.Instance.language == LanguageType.西班牙语)
			{
				guidanceText.text = "Seleccione el elemento, presione el botón disparador para eliminar el elemento";
			}
			else if (MonoSingleton<GlobalManager>.Instance.language == LanguageType.意大利语)
			{
				guidanceText.text = "Selezionare l'elemento, premere il pulsante di attivazione per rimuovere l'elemento";
			}
			else if (MonoSingleton<GlobalManager>.Instance.language == LanguageType.德语)
			{
				guidanceText.text = "Wählen Sie das Element aus und drücken Sie die Auslösetaste, um das Element zu entfernen";
			}
			else if (MonoSingleton<GlobalManager>.Instance.language == LanguageType.日语)
			{
				guidanceText.text = "アイテムを選択し、トリガーボタンを押してアイテムを削除します";
			}
			else if (MonoSingleton<GlobalManager>.Instance.language == LanguageType.韩语)
			{
				guidanceText.text = "아이템을 선정하고 방아쇠 버튼을 누르면 아이템을 꺼낸다";
			}
			break;
		case TeachType.去砸花瓶:
			if (MonoSingleton<GlobalManager>.Instance.language == LanguageType.中文)
			{
				guidanceText.text = "用锤子砸下花瓶试试吧";
			}
			else if (MonoSingleton<GlobalManager>.Instance.language == LanguageType.English)
			{
				guidanceText.text = "Try to use the hammer to smash the bottle";
			}
			else if (MonoSingleton<GlobalManager>.Instance.language == LanguageType.西班牙语)
			{
				guidanceText.text = "Intenta golpear el jarrón con un martillo.";
			}
			else if (MonoSingleton<GlobalManager>.Instance.language == LanguageType.意大利语)
			{
				guidanceText.text = "Prova a colpire il vaso con un martello";
			}
			else if (MonoSingleton<GlobalManager>.Instance.language == LanguageType.德语)
			{
				guidanceText.text = "Versuchen Sie, mit einem Hammer auf die Vase zu schlagen";
			}
			else if (MonoSingleton<GlobalManager>.Instance.language == LanguageType.日语)
			{
				guidanceText.text = "花瓶をハンマーで叩いてみてください";
			}
			else if (MonoSingleton<GlobalManager>.Instance.language == LanguageType.韩语)
			{
				guidanceText.text = "망치로 꽃병을 깨다";
			}
			break;
		case TeachType.拿照片:
			if (MonoSingleton<GlobalManager>.Instance.language == LanguageType.中文)
			{
				guidanceText.text = "去拾取桌子上的照片";
			}
			else if (MonoSingleton<GlobalManager>.Instance.language == LanguageType.English)
			{
				guidanceText.text = "Go pick up the photo on the table.";
			}
			else if (MonoSingleton<GlobalManager>.Instance.language == LanguageType.西班牙语)
			{
				guidanceText.text = "para recoger la imagen en la mesa";
			}
			else if (MonoSingleton<GlobalManager>.Instance.language == LanguageType.意大利语)
			{
				guidanceText.text = "per prendere l'immagine sul tavolo";
			}
			else if (MonoSingleton<GlobalManager>.Instance.language == LanguageType.德语)
			{
				guidanceText.text = "um das Bild auf dem Tisch aufzuheben";
			}
			else if (MonoSingleton<GlobalManager>.Instance.language == LanguageType.日语)
			{
				guidanceText.text = "テーブルの上の写真を拾うために";
			}
			else if (MonoSingleton<GlobalManager>.Instance.language == LanguageType.韩语)
			{
				guidanceText.text = "탁상 위 사진을 줃다";
			}
			break;
		case TeachType.结束:
			guidanceText.gameObject.SetActive(value: false);
			MonoBehaviour.print("进入结束流程");
			break;
		}
	}
}
public class TypewriterEffect : MonoBehaviour
{
	public float charsPerSecond = 0.2f;

	private string words;

	private bool isActive;

	private float timer;

	private Text myText;

	private int currentPos;

	private int finishNum;

	private void Awake()
	{
	}

	private void Start()
	{
		timer = 0f;
		isActive = true;
		charsPerSecond = Mathf.Max(0.2f, charsPerSecond);
		myText = GetComponent<Text>();
		if (MonoSingleton<GlobalManager>.Instance.language == LanguageType.中文)
		{
			words = "滴——";
		}
		else
		{
			words = "di——";
		}
		myText.text = "";
	}

	private void Update()
	{
		OnStartWriter();
	}

	public void StartEffect()
	{
		isActive = true;
	}

	private void OnStartWriter()
	{
		if (!isActive)
		{
			return;
		}
		timer += Time.deltaTime;
		if (timer >= charsPerSecond)
		{
			timer = 0f;
			currentPos++;
			myText.text = words.Substring(0, currentPos);
			if (currentPos >= words.Length)
			{
				OnFinish();
			}
		}
	}

	private void OnFinish()
	{
		isActive = false;
		timer = 0f;
		currentPos = 0;
		myText.text = words;
		finishNum++;
		if (finishNum < 5)
		{
			StartEffect();
		}
		else
		{
			myText.text = null;
		}
	}
}
public class ListenAudioPos : MonoSingleton<ListenAudioPos>
{
	private AudioSource audioSource;

	private void Start()
	{
		audioSource = GetComponent<AudioSource>();
	}

	public bool Play(Transform trans, AudioClip clip)
	{
		if (audioSource.isPlaying)
		{
			return false;
		}
		base.transform.position = trans.position;
		audioSource.clip = clip;
		audioSource.Play();
		return true;
	}
}
public class LuYinJiListen : ObjectListen
{
	public AudioSource soundRecordSong;

	public AudioSource lilithSong;

	public SoundRecorder soundRecorder;

	public override void EventTrigger()
	{
		soundRecorder = GetComponent<SoundRecorder>();
		soundRecorder.canPlay = false;
		GetComponent<Animator>().SetBool("Press", value: true);
		MonoSingleton<AudioManager>.Instance.Play(90012);
		soundRecordSong.Play();
		lilithSong.volume = 0f;
		lilithSong.Play();
		MonoBehaviour.print("播放童谣");
	}
}
public class MoXiangKuangListen : ObjectListen
{
	public override void EventTrigger()
	{
		_ = MonoSingleton<PlayerPrefsGame>.Instance.isLoad;
		MonoSingleton<PlayerInfo>.Instance.SpeedMoveTo(targetPos.position, 0.7f, canMove: false);
		UnityEngine.Debug.Log("进入摸相框");
	}
}
public class MuMaListen : ObjectListen
{
	public AudioSource soundRecordSong;

	public AudioSource lilithSong;

	public SoundRecorder soundRecorder;

	public override void EventTrigger()
	{
		lilithSong.volume = 1f;
		soundRecordSong.Stop();
		MonoSingleton<PlayerInfo>.Instance.CanMove = false;
		soundRecorder.canPlay = true;
		UnityEngine.Debug.Log("进入木马");
	}
}
public class ObjectListen : UniversalListen
{
	public AudioSource BGM;

	public AudioClip[] BGMClip;

	public DoorInfo doorInfo;

	public override void OnTrigger()
	{
		base.OnTrigger();
		if (GetComponent<TriggerEventPlayerPres>() != null)
		{
			GetComponent<TriggerEventPlayerPres>().isTriggered = true;
		}
		EventTrigger();
		switch (triggerObj)
		{
		case TriggerObj.扑面杀:
			GameObject.FindGameObjectWithTag("Player").GetComponent<JoyStickMovement2>().SpeedMoveTo(targetPos.position, 0.5f);
			break;
		case TriggerObj.打雷:
			doorInfo.SetAngle(0f, 1f);
			MonoBehaviour.print("客厅门旋转度" + doorInfo.transform.rotation.ToString());
			break;
		case TriggerObj.摇椅:
			if (MonoSingleton<BackpackManager>.Instance.GetItemIsHave(ItemType._130024_物品_幻室__嘉达尔的宝藏Ⅰ_))
			{
				GetComponent<Animator>().SetTrigger("摇椅");
			}
			break;
		case TriggerObj.走廊尽头红灯:
			BGM.clip = BGMClip[1];
			break;
		case TriggerObj.钟:
		case TriggerObj.木马:
		case TriggerObj.气球:
		case TriggerObj.衣柜:
		case TriggerObj.敲门:
		case TriggerObj.频闪1:
		case TriggerObj.摸相框:
		case TriggerObj.录音机:
		case TriggerObj.TV:
		case TriggerObj.电话铃:
		case TriggerObj.古宅2_圣嘉恩手:
		case TriggerObj.古宅2_屠夫:
		case TriggerObj.通用:
		case TriggerObj.古宅2圣嘉恩:
			break;
		}
	}

	public virtual void EventTrigger()
	{
	}
}
public enum TriggerObj
{
	钟,
	木马,
	气球,
	衣柜,
	敲门,
	频闪1,
	扑面杀,
	摸相框,
	打雷,
	摇椅,
	走廊尽头红灯,
	录音机,
	TV,
	电话铃,
	古宅2_圣嘉恩手,
	古宅2_屠夫,
	通用,
	古宅2圣嘉恩
}
public class UniversalListen : MJListen
{
	public TriggerObj triggerObj;

	public AudioType audioClip;

	private AudioClip clip;

	public Transform targetPos;

	public override void Init()
	{
		base.Init();
	}

	public override void OnTrigger()
	{
		base.OnTrigger();
		MonoBehaviour.print("进入");
		if (audioClip != 0)
		{
			clip = MonoSingleton<AudioManager>.Instance.audioDict[audioClip.GetHashCode()].clip;
		}
		else
		{
			clip = null;
		}
		if (GetComponent<PlayableDirector>() != null)
		{
			GetComponent<PlayableDirector>().enabled = true;
		}
		else
		{
			if (clip != null && MonoSingleton<ListenAudioPos>.Instance.Play(base.transform, clip))
			{
				MonoSingleton<ListenAudioPos>.Instance.Play(base.transform, clip);
				MonoBehaviour.print("播放声音");
			}
			GetComponent<Animator>().enabled = true;
		}
		if (GetComponent<TriggerEventPlayerPres>() != null)
		{
			GetComponent<TriggerEventPlayerPres>().isTriggered = true;
		}
	}

	private void CanMove()
	{
		MonoSingleton<PlayerInfo>.Instance.CanMove = !MonoSingleton<PlayerInfo>.Instance.CanMove;
	}
}
public class Wardrobe : MJListen
{
	public override void OnTrigger()
	{
		if (ItemType._130023_物品_幻室__圣嘉恩秘闻Ⅶ_.GetItemInfo().isHave)
		{
			UnityEngine.Debug.Log(">>" + _name);
			base.OnTrigger();
			GetComponent<PlayableDirector>().enabled = true;
		}
		else if (MonoSingleton<PlayerInfo>.Instance.rightTouch.selectedInteractionBase != null && MonoSingleton<PlayerInfo>.Instance.rightTouch.selectedInteractionBase.GetItemType() == ItemType._130023_物品_幻室__圣嘉恩秘闻Ⅶ_)
		{
			base.OnTrigger();
			GetComponent<PlayableDirector>().enabled = true;
		}
	}
}
public class WomenGhost : MonoBehaviour
{
	public bool canKill;

	public GameObject player;

	private void Start()
	{
		player = GameObject.FindGameObjectWithTag("Player");
	}

	private void Update()
	{
		if (canKill && Vector3.Distance(base.transform.position, player.transform.position) < 1f)
		{
			MonoBehaviour.print("游戏结束");
		}
	}

	public void PlayLilithCallOverSubtitle()
	{
	}
}
public class AlchemyBasin : MonoBehaviour
{
	public List<GameObject> materials = new List<GameObject>();

	public List<ItemType> materialsType = new List<ItemType>();

	public List<ItemType> materialsEnterType = new List<ItemType>();

	private GameObject material;

	public Animator fire;

	public GameObject puppet;

	public GameObject water;

	public GameObject dogWater;

	[Tooltip("药剂位置")]
	public Transform medicamentPos;

	public DoorInfo door;

	private int index;

	public ScriptPlayerPrefs scriptPlayerPrefs;

	public ItemType GOType;

	public TouchBase tmp;

	private void Start()
	{
		materialsEnterType.Add(ItemType._140002_物品_幻室_蝙蝠的干尸);
		materialsEnterType.Add(ItemType._140003_物品_幻室_掰下来的树枝);
		materialsEnterType.Add(ItemType._140004_物品_幻室_神秘的金属);
		materialsEnterType.Add(ItemType._140005_物品_幻室_试剂);
		scriptPlayerPrefs = GetComponent<ScriptPlayerPrefs>();
		TestManager.AddTest("CanInput", delegate
		{
			MonoSingleton<PlayerInfo>.Instance.canInput = true;
		});
	}

	private void OnTriggerEnter(Collider other)
	{
		UnityEngine.Debug.Log("触发器" + other.name);
		if (other.CompareTag(TagType.TaskItem.ToString()))
		{
			UnityEngine.Debug.Log("task" + other.name);
			UnityEngine.Debug.Log(other.TryGetComponent<TouchBase>(out tmp));
			if (other.TryGetComponent<TouchBase>(out tmp) && tmp.info.id - 140002 <= (ItemType)3 && tmp.info.id - 140002 >= ItemType.None)
			{
				GOType = tmp.info.id;
				MonoSingleton<PlayerInfo>.Instance.rightTouch.DelectSelectedAndRemoveInfoInBackpack();
				AddMaterial();
				MonoBehaviour.print("删除手中材料");
			}
		}
	}

	public void AddMaterial()
	{
		if (GOType != 0)
		{
			materialsType.Add(GOType);
			fire.SetTrigger(materialsType.Count.ToString());
			UnityEngine.Debug.Log(materialsType.Count);
			if (materialsType.Count != 0 && materialsType.Count <= 3)
			{
				AudioType._13042_炼金盆火焰爆炸.Play();
			}
			else
			{
				AudioType._13041_放入最后一个材料火焰变大光罩消失.Play();
			}
			if (materialsType.Count == 4)
			{
				_ = MonoSingleton<AchievementCanUnlock>.Instance.canUnlock;
				puppet.SetActive(value: true);
				water.SetActive(value: true);
				dogWater.SetActive(value: true);
				AudioType._13025_合成狂化药剂的声音.Play();
				materials.Clear();
				materialsType.Clear();
				door.SetAngle(0f, 1f);
				door.enabled = false;
				scriptPlayerPrefs.isFinish = true;
				MonoSingleton<PlayerPrefsGame>.Instance.Save();
				scriptPlayerPrefs.Save();
			}
			GOType = ItemType.None;
		}
	}

	public void Finish()
	{
		puppet.SetActive(value: true);
		water.SetActive(value: true);
		dogWater.SetActive(value: true);
		materials.Clear();
		materialsType.Clear();
		door.SetAngle(0f, 1f);
		door.enabled = false;
		base.gameObject.SetActive(value: false);
	}
}
public class AlchemyLandonPuppet : MonoBehaviour
{
	public void OnTriggerEnter(Collider other)
	{
		if (other.CompareTag("Ground"))
		{
			AudioType._13120_玩偶倒下.Play(0.05f);
		}
	}
}
public class AlchemyWater : GeneralColliderDetectionBase
{
	public override void OnTrigger()
	{
		this.AttachTimer(0.2f, delegate
		{
			base.OnTrigger();
		});
		MonoSingleton<BackpackManager>.Instance.AddItem(ItemType._140006_物品_幻室_狂化药剂);
		base.gameObject.GetComponent<Animator>().enabled = true;
		AudioType._13056_把狂化药剂倒入瓶中然后收入背包.Play();
	}
}
public class DogBowl : GeneralColliderDetectionBase
{
	public GameObject bookcaseLeft;

	public FantasyRoom2Bookcase bookcaseFR2;

	public GameObject water;

	public AudioSource audioSourceDog;

	public override void OnTrigger()
	{
		base.OnTrigger();
		OpenDoor1();
	}

	private void Start()
	{
		TestManager.AddTest("跳过喂狗", OpenDoor);
		TestManager.AddTest("允许移动", delegate
		{
			MonoSingleton<PlayerInfo>.Instance.CanMove = true;
		});
	}

	public void OpenDoor1()
	{
		this.AttachTimer(0.2f, delegate
		{
			MonoSingleton<BackpackManager>.Instance.RemoveItem(ItemType._140006_物品_幻室_狂化药剂);
		});
		water.gameObject.SetActive(value: true);
		AudioType._13055_倒狂化药剂.Play();
		bookcaseLeft.GetComponent<PlayableDirector>().enabled = true;
		audioSourceDog.enabled = true;
		MonoSingleton<PlayerInfo>.Instance.SetSpeed(0f);
		bookcaseFR2.canTrigger = true;
	}

	public void OpenDoor()
	{
		MonoSingleton<BackpackManager>.Instance.RemoveItem(ItemType._140006_物品_幻室_狂化药剂);
		MonoSingleton<PlayerInfo>.Instance.rightTouch.selectedObj = null;
		MonoSingleton<PlayerInfo>.Instance.rightTouch.selectedInteractionBase = null;
		water.gameObject.SetActive(value: true);
		AudioType._13055_倒狂化药剂.Play();
		audioSourceDog.enabled = true;
		MonoSingleton<PlayerInfo>.Instance.SetSpeed(0f);
		bookcaseFR2.canTrigger = true;
	}
}
public class DogEvent : MonoBehaviour
{
	public GameObject dog;

	public void DogLookPlayer()
	{
		dog.transform.LookAt(MonoSingleton<PlayerInfo>.Instance.GetEasyVRHeadPos(), Vector3.up);
		MonoBehaviour.print("狗转身");
	}

	public void DogCanMove()
	{
		dog.GetComponent<DogMove>().enabled = true;
	}
}
public class DogMove : MonoBehaviour
{
	public float runSpeed0 = 2f;

	public float turnSpeed0 = 2f;

	public float runSpeed1 = 2f;

	public float turnSpeed1 = 2f;

	public Transform[] point;

	private Animator animator;

	public bool moveStart;

	public bool lookAtStart;

	public Transform TF;

	public bool isHeadPos;

	public bool runOrAttack;

	public Transform FogTF;

	public float percentDisToDog;

	public float distance = 4f;

	public float currentDis;

	private bool tempBool = true;

	private int i;

	public void Start()
	{
		base.transform.position = new Vector3(0f, 0.3f, 0f);
		base.transform.DOMove(point[0].position, runSpeed0).OnComplete(delegate
		{
			lookAtStart = true;
			MonoBehaviour.print("到达点0");
		});
		base.transform.DORotate(point[0].rotation.eulerAngles, turnSpeed0);
		animator = GetComponent<Animator>();
	}

	private void Update()
	{
		if (lookAtStart)
		{
			base.transform.DOLookAt(IsHeadOrCameraPos(isHeadPos), turnSpeed1, AxisConstraint.Y).OnComplete(delegate
			{
				animator.SetBool("runOrAttack", value: false);
				MonoBehaviour.print("转向完成开始跑");
			});
			this.AttachTimer(2.25f, delegate
			{
				moveStart = true;
				if (i == 0)
				{
					AudioType._13032_狗咬人.Play();
					i++;
				}
			});
			this.AttachTimer(3f, delegate
			{
				lookAtStart = false;
			});
		}
		if (moveStart)
		{
			base.transform.Translate(Vector3.forward * runSpeed1 * Time.deltaTime);
		}
		currentDis = Vector3.Distance(base.transform.position, MonoSingleton<PlayerInfo>.Instance.GetEasyVRHeadPos());
		if (Vector3.Distance(base.transform.position, MonoSingleton<PlayerInfo>.Instance.GetEasyVRHeadPos()) < distance && moveStart)
		{
			animator.SetBool("runOrAttack", value: true);
			MonoBehaviour.print("扑");
		}
	}

	public void RunOrAttackTrigger()
	{
		animator.SetBool("runOrAttack", runOrAttack);
	}

	private bool SetFogPos(bool isSet)
	{
		if (isSet)
		{
			Vector3 position = default(Vector3);
			position.x = Mathf.Lerp(base.transform.position.x, MonoSingleton<PlayerInfo>.Instance.GetEasyVRHeadPos().x, percentDisToDog);
			position.y = Mathf.Lerp(base.transform.position.y, MonoSingleton<PlayerInfo>.Instance.GetEasyVRHeadPos().y, percentDisToDog);
			position.z = Mathf.Lerp(base.transform.position.z, MonoSingleton<PlayerInfo>.Instance.GetEasyVRHeadPos().z, percentDisToDog);
			FogTF.position = position;
			isSet = false;
			return false;
		}
		return false;
	}

	private Vector3 IsHeadOrCameraPos(bool isHead)
	{
		if (isHead)
		{
			return MonoSingleton<PlayerInfo>.Instance.GetEasyVRHeadPos();
		}
		return TF.position;
	}
}
public class FantasyRoom2Bookcase : MonoBehaviour
{
	public bool canTrigger;

	public AudioSource audioSourceDog;

	public GameObject bookcaseLeft2;

	private void Start()
	{
	}

	private void Update()
	{
		if (canTrigger && MonoSingleton<RayTrigger>.Instance.outGameobject == base.gameObject)
		{
			bookcaseLeft2.GetComponent<PlayableDirector>().enabled = false;
			GetComponent<PlayableDirector>().enabled = true;
			GetComponent<Collider>().enabled = false;
			audioSourceDog.enabled = false;
			MonoBehaviour.print("看见书柜");
		}
	}
}
public class FireDisappear : MonoBehaviour
{
	public GameObject sphere;

	public void SphereDisappear()
	{
		sphere.SetActive(value: false);
		GetComponent<Light>().enabled = false;
	}
}
public class LanternFire : MonoBehaviour
{
	public GameObject oil;

	public void OnTriggerEnter(Collider other)
	{
		if (other.CompareTag("Ground"))
		{
			GetComponent<PlayableDirector>().enabled = true;
			oil.transform.position = new Vector3(base.transform.position.x, oil.transform.position.y, base.transform.position.z);
			oil.SetActive(value: true);
		}
	}
}
public class Scatteredpuppetparts : MonoBehaviour
{
	public enum Axis
	{
		x,
		y,
		z
	}

	public Axis axis;

	public static Signal puppetSignal = new Signal();

	public bool canAddForce;

	public float force;

	private void Start()
	{
		puppetSignal.AddListener(AddForce);
	}

	private void OnDestroy()
	{
		puppetSignal.RemoveAllListeners();
	}

	public void AddForce()
	{
		if (canAddForce)
		{
			if (axis == Axis.x)
			{
				GetComponent<Rigidbody>().AddRelativeForce(force, 0f, 0f);
			}
			if (axis == Axis.y)
			{
				GetComponent<Rigidbody>().AddRelativeForce(0f, force, 0f);
			}
			if (axis == Axis.z)
			{
				GetComponent<Rigidbody>().AddRelativeForce(0f, 0f, force);
			}
			canAddForce = false;
		}
	}
}
public class BloodDestory : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
	}
}
public class AlisaFindOilLight : MJListen
{
	public GameObject ailsa;

	public override void OnTrigger()
	{
		if (ItemType._140003_物品_幻室_掰下来的树枝.GetItemInfo().isHave)
		{
			base.OnTrigger();
			AlisaOilLightPutout.oilLightSignal.Invoke();
			ailsa.SetActive(value: true);
		}
		else if (MonoSingleton<PlayerInfo>.Instance.rightTouch.selectedInteractionBase != null && MonoSingleton<PlayerInfo>.Instance.rightTouch.selectedInteractionBase.GetItemType() == ItemType._140003_物品_幻室_掰下来的树枝)
		{
			base.OnTrigger();
			AlisaOilLightPutout.oilLightSignal.Invoke();
			ailsa.SetActive(value: true);
		}
	}
}
public class ChangeMaterials : MonoBehaviour
{
	[SerializeField]
	public Material material;

	[SerializeField]
	private Material originMaterial;

	private void Awake()
	{
		originMaterial = GetComponent<MeshRenderer>().material;
	}

	private void OnEnable()
	{
		GetComponent<MeshRenderer>().material = material;
		this.AttachTimer((float)int.Parse(base.name) * 0.5f, Change);
	}

	public void Change()
	{
		GetComponent<MeshRenderer>().material = originMaterial;
	}
}
public class DistributionBox : MonoBehaviour
{
	public int count;

	public GameObject colliderObj;

	public GameObject light;

	public PlaySubtitle1009 PlaySubtitle1009;

	public GameObject vfx;

	public ScriptPlayerPrefs scriptPlayerPrefs;

	public GameObject[] capacitance;

	public void ActiveSocket()
	{
		count++;
		if (count >= 3)
		{
			AudioType._13053_通电后的音效.Play();
			Finish();
			MonoSingleton<PlayerPrefsGame>.Instance.Save();
			scriptPlayerPrefs.Save();
		}
		UnityEngine.Debug.Log(count);
	}

	public void Finish()
	{
		colliderObj.SetActive(value: true);
		light.SetActive(value: true);
		EventManager.SendEvent("TimeLine 0 (Electric Switch)Enter");
		CorridorLight.corridorLightSignal.Invoke("走廊射灯开");
		TieRod.makeUsea = true;
		PlaySubtitle1009.canPlay = true;
		vfx.SetActive(value: true);
		scriptPlayerPrefs.isFinish = true;
		for (int i = 0; i < capacitance.Length; i++)
		{
			capacitance[i].SetActive(value: true);
		}
	}

	public void Start()
	{
		scriptPlayerPrefs = GetComponent<ScriptPlayerPrefs>();
	}
}
public class DistributionBoxSocket : GeneralColliderDetectionBase
{
	public override void OnTrigger()
	{
		base.OnTrigger();
		base.transform.GetChild(0).gameObject.SetActive(value: true);
		GetComponentInParent<DistributionBox>().ActiveSocket();
		AudioType._13052_插入电容.Play();
	}

	public void Test()
	{
		UnityEngine.Debug.Log("Test");
		base.transform.GetChild(0).gameObject.SetActive(value: true);
		GetComponentInParent<DistributionBox>().ActiveSocket();
	}
}
public class DistributionLight : MonoBehaviour
{
	public GameObject lamp;

	private Light lightObj;

	private void Start()
	{
		lightObj = GetComponent<Light>();
		EventManager.AddListener("配电箱完成", Active);
		lightObj.gameObject.SetActive(value: false);
		lamp?.GetComponent<MeshRenderer>().material.DisableKeyword("_EMISSION");
	}

	private void Active()
	{
		lightObj.gameObject.SetActive(value: true);
		lamp?.GetComponent<MeshRenderer>().material.EnableKeyword("_EMISSION");
	}
}
public class CorridorDoor : MJListen
{
	public GameObject door;

	public override void OnTrigger()
	{
		if (TieRod.finished)
		{
			base.OnTrigger();
			door.GetComponent<PlayableDirector>().enabled = true;
		}
	}
}
public class CorridorLight : MonoBehaviour
{
	public static Signal<string> corridorLightSignal = new Signal<string>();

	public Material shelfEmission;

	public GameObject shootLight;

	private void Start()
	{
		corridorLightSignal.AddListener(OpenLight);
		base.gameObject.SetActive(value: false);
		shelfEmission.DisableKeyword("_EMISSION");
	}

	public void OnDestroy()
	{
		corridorLightSignal.RemoveAllListeners();
	}

	private void OpenLight(string obj)
	{
		if (obj == "走廊射灯开" && (PlayerPrefs.GetString(shootLight.name + "事件完成状态") != "完成" || !MonoSingleton<PlayerPrefsGame>.Instance.isLoad))
		{
			base.gameObject.SetActive(value: true);
			shelfEmission.EnableKeyword("_EMISSION");
		}
	}
}
public class GreenPlants : TaskItem
{
	public GameObject SJE;

	public GameObject SJETrigger;

	private static int num;

	public override void PressDown()
	{
		base.PressDown();
		if (num == 0)
		{
			CreatSphere.serve = true;
			SJE.SetActive(value: true);
			SJETrigger.SetActive(value: true);
			MonoBehaviour.print("发射皮球");
			num++;
		}
	}
}
public class CreatSphere : MJListen
{
	public Transform point;

	public GameObject sphere;

	private float t = 3f;

	public float cd;

	public float num;

	public GameObject puppet;

	public bool isEnd;

	public static bool serve;

	public void Update()
	{
		if (!isEnd && serve)
		{
			t += Time.deltaTime;
			if (t >= cd)
			{
				UnityEngine.Object.Instantiate(sphere, point.position, point.rotation);
				t = 0f;
			}
		}
	}

	public override void OnTrigger()
	{
		if (ItemType._140003_物品_幻室_掰下来的树枝.GetItemInfo().isHave)
		{
			base.OnTrigger();
			serve = false;
			puppet.SetActive(value: true);
			isEnd = true;
		}
		else if (MonoSingleton<PlayerInfo>.Instance.rightTouch.selectedInteractionBase != null && MonoSingleton<PlayerInfo>.Instance.rightTouch.selectedInteractionBase.GetItemType() == ItemType._140003_物品_幻室_掰下来的树枝)
		{
			base.OnTrigger();
			serve = false;
			puppet.SetActive(value: true);
			isEnd = true;
		}
	}

	public void InstantiateSphere()
	{
		if (num < 3f)
		{
			UnityEngine.Object.Instantiate(sphere, point.position, point.rotation);
			num += 1f;
		}
		else
		{
			CancelInvoke("InstantiateSphere");
			puppet.SetActive(value: true);
		}
		MonoBehaviour.print("num:" + num);
	}
}
public class LilithSphere : MonoBehaviour
{
	private float t;

	public float disappearTime = 1f;

	private void Start()
	{
		GetComponent<Rigidbody>().AddForce(Vector3.left * 500f);
		GetComponent<Rigidbody>().AddForce(Vector3.up * 200f);
		this.AttachTimer(disappearTime, delegate
		{
			UnityEngine.Object.Destroy(base.gameObject);
		});
	}

	public void OnCollisionEnter(Collision collision)
	{
		AudioType._13086_皮球.Play();
	}
}
public class SphereAudio : MonoBehaviour
{
	public void OnCollisionEnter(Collision collision)
	{
		AudioType._13086_皮球.Play(20f);
	}
}
public class ShootLIghts : MonoBehaviour
{
	public int[] tmp = new int[4];

	public static Signal<int, int> listen = new Signal<int, int>();

	public Material shelfEmission;

	public GameObject[] lights;

	public bool isFinish;

	public ScriptPlayerPrefs scriptPlayerPrefs;

	private void Start()
	{
		listen.AddListener(Listen);
		scriptPlayerPrefs = GetComponent<ScriptPlayerPrefs>();
		if (PlayerPrefs.GetString(base.gameObject.name + "事件完成状态") == "完成")
		{
			isFinish = true;
		}
		if (isFinish)
		{
			for (int i = 0; i < lights.Length; i++)
			{
				lights[i].SetActive(value: false);
				MonoBehaviour.print("射灯完成");
			}
			MonoBehaviour.print("射灯完成1");
		}
	}

	public void OnDestroy()
	{
		listen.RemoveAllListeners();
	}

	public void Listen(int obj, int index)
	{
		tmp[obj] = index;
		int num = 0;
		int[] array = tmp;
		foreach (int num2 in array)
		{
			num += num2;
		}
		bool flag = false;
		if (num == 0 && !flag)
		{
			UnityEngine.Debug.Log("Timeline 1 (Door open)");
			GetComponentInParent<PlayableDirector>().enabled = true;
			flag = true;
			TieRod.makeUsea = false;
			TieRod.finished = true;
			shelfEmission.DisableKeyword("_EMISSION");
			MonoSingleton<PlayerInfo>.Instance.rightTouch.selectedObj = null;
			scriptPlayerPrefs.isFinish = true;
			MonoSingleton<PlayerPrefsGame>.Instance.Save();
			scriptPlayerPrefs.Save();
		}
	}

	public void Finish()
	{
		scriptPlayerPrefs.isFinish = true;
		TieRod.makeUsea = false;
		TieRod.finished = true;
		shelfEmission.DisableKeyword("_EMISSION");
	}
}
public class ShootLight : MonoBehaviour
{
	public static Signal<int> ShootLightRotate = new Signal<int>();

	public int index;

	public int id;

	public float angle = 20f;

	public int step = 1;

	private void Start()
	{
		Rotate();
		ShootLightRotate += new Action<int>(Add);
	}

	public void OnDestroy()
	{
		ShootLightRotate.RemoveAllListeners();
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.Space))
		{
			Add(int.Parse(base.name));
		}
	}

	public void Add(int id)
	{
		UnityEngine.Debug.Log(id);
		if (this.id == id || this.id == id + 1)
		{
			index += step;
			index %= 4;
			Rotate();
		}
		ShootLIghts.listen.Invoke(this.id, index);
	}

	public void Rotate()
	{
		base.transform.DOLocalRotate(Vector3.right * index * angle, 1f);
		AudioType._13051_顶灯转动.Play(0.5f);
	}
}
public class TieRod : RotationBase
{
	public int id;

	public static bool makeUsea;

	public static bool finished;

	private int i;

	public bool isBackMin = true;

	public override void Init()
	{
		base.Init();
		maxAngleEvent.AddListener(Open);
		minAngleEvent.AddListener(Close);
	}

	private void Close()
	{
		AudioType._13050_拉动射灯把手.Play();
	}

	private void Open()
	{
		AudioType._13050_拉动射灯把手.Play();
		if (makeUsea)
		{
			ShootLight.ShootLightRotate.Invoke(id);
		}
		if (finished)
		{
			base.PressUp();
			SetAngle(isBackMin ? min : max, 0.5f);
			i++;
		}
	}

	public override void PressUp()
	{
		if (!finished)
		{
			base.PressUp();
			SetAngle(isBackMin ? min : max, 0.5f);
		}
	}
}
public class PlaySubtitle1008 : PlayTriggerSubtitle
{
	public GameObject distribution;

	public bool isFinish;

	private void Start()
	{
		this.AttachTimer(0.5f, delegate
		{
			isFinish = distribution.GetComponent<ScriptPlayerPrefs>().isFinish;
		});
	}

	public override void StayTrigger()
	{
		if (MonoSingleton<RayTrigger>.Instance.outGameobject == distribution && !isFinish)
		{
			base.StayTrigger();
			PlaySubtitle();
		}
	}
}
public class PlaySubtitle1009 : PlayTriggerSubtitle
{
	public bool canPlay;

	public override void OnTrigger()
	{
		if (canPlay)
		{
			base.OnTrigger();
			PlaySubtitle();
		}
	}
}
public class GetFormula : TaskItem
{
	public List<GameObject> materials;

	public static int num;

	public override void Init()
	{
		base.Init();
		for (int i = 0; i < materials.Count; i++)
		{
			materials[i].layer = 0;
			materials[i].transform.GetChild(0).gameObject.SetActive(value: false);
		}
	}

	public override void GetItemSignal(ItemType obj)
	{
		if (obj != ItemType._140007_物品_幻室_炼金配方表)
		{
			return;
		}
		for (int i = 0; i < materials.Count; i++)
		{
			if (materials[i] != null)
			{
				if (materials[i].GetComponent<TaskItem>().info.id != ItemType._140002_物品_幻室_蝙蝠的干尸)
				{
					materials[i].layer = 9;
				}
				else
				{
					Bat.batSignal.Invoke("蝙蝠");
				}
				materials[i].transform.GetChild(0).gameObject.SetActive(value: true);
			}
		}
		if (num == 0)
		{
			MonoSingleton<SubtitleManager>.Instance.Play(1047, 0.5f);
			num++;
		}
		MonoBehaviour.print("拿到炼金配方表");
	}
}
public class GlassBurst : MonoBehaviour
{
	public void Burst()
	{
		GetComponent<PlayableDirector>().enabled = true;
	}
}
public class InversionEvent : MJListen
{
	[Tooltip("房间方向，ture为正，false为反")]
	public bool roomDirection;

	public override void OnTrigger()
	{
		InversionVariation.InversionSignal.Invoke(roomDirection);
	}
}
public class PlayBlink : MonoBehaviour
{
	public GameObject BlackCanvas;

	private void Start()
	{
		BlackCanvas = GameObject.Find("BlackCanva");
		BlackCanvas.transform.GetChild(1).gameObject.SetActive(value: true);
		BlackCanvas.GetComponentInChildren<Blink_Image>().breathingNum = 0;
	}

	private void Update()
	{
		if (BlackCanvas.GetComponentInChildren<Blink_Image>().breathingNum <= 2)
		{
			BlackCanvas.GetComponentInChildren<Blink_Image>().Blink();
		}
		else
		{
			BlackCanvas.GetComponentInChildren<Blink_Image>().Y = 0.5f;
		}
	}
}
public class FantasyRoom2GlobalSignal : GlobalSignal
{
	public void PlaySubtitle1003(Transform transform)
	{
		if (transform != null)
		{
			MonoSingleton<SubtitleManager>.Instance.Play(1003, transform.position);
		}
	}

	public void PlaySubtitle1004(Transform transform)
	{
		if (transform != null)
		{
			MonoSingleton<SubtitleManager>.Instance.Play(1004, transform.position);
		}
	}

	public void PlaySubtitle1301(Transform transform)
	{
		if (transform != null)
		{
			MonoSingleton<SubtitleManager>.Instance.Play(1301, transform.position);
		}
	}

	public void PlaySubtitle1010(Transform transform)
	{
		if (transform != null)
		{
			MonoSingleton<SubtitleManager>.Instance.Play(1010, transform.position);
		}
	}

	public void PlaySubtitle1048()
	{
		MonoSingleton<SubtitleManager>.Instance.Play(1048);
	}

	public void PlaySubtitle1014()
	{
		MonoSingleton<SubtitleManager>.Instance.Play(1014);
	}

	public void LoadSceneFantasyroom3()
	{
		_ = MonoSingleton<AchievementCanUnlock>.Instance.canUnlock;
		TieRod.finished = false;
		MonoSingleton<GlobalManager>.Instance.CurrentScene = MJFSM.SceneType.酒店大厅;
		UnityEngine.Debug.Log("——————————————跳转到古宅3");
	}

	public void PlayDrop360Video(VideoClip clip)
	{
		MonoSingleton<OverallViewManager>.Instance.Play(clip);
		this.AttachTimer((float)clip.length, delegate
		{
			LoadSceneFantasyroom3();
		});
	}
}
public class FantasyRoom3GlobalSignal : GlobalSignal
{
	public AudioSource BGM;

	public AudioClip BGMClip;

	public void PlaySubtitle(int id)
	{
		MonoSingleton<SubtitleManager>.Instance.Play(id);
	}

	public void PlaySubtitle1050()
	{
		MonoSingleton<SubtitleManager>.Instance.Play(1050);
	}

	public void PlaySubtitle1501()
	{
		MonoSingleton<SubtitleManager>.Instance.AttachTimerPlay(1501, 1f);
	}

	public void PlaySubtitle1256()
	{
		MonoSingleton<SubtitleManager>.Instance.Play(1256);
	}

	public void PlaySubtitle1106()
	{
		MonoSingleton<SubtitleManager>.Instance.Play(1106);
	}

	public void PlaySubtitle1054()
	{
		MonoSingleton<SubtitleManager>.Instance.Play(1054);
	}

	public void PlaySubtitle1801()
	{
		MonoSingleton<SubtitleManager>.Instance.Play(1801);
	}

	public void PlaySubtitle1210()
	{
		MonoSingleton<SubtitleManager>.Instance.Play(1210);
	}

	public void Play360Video(VideoClip clip)
	{
		MonoSingleton<OverallViewManager>.Instance.Play(clip, autoClose: false, loop: false);
		this.AttachTimer((float)clip.length + 0.5f, delegate
		{
			Play360VideoPaintedEggshell(5);
			PlaySubtitle1801();
		});
	}

	public void Play360VideoPaintedEggshell(int num)
	{
		MonoSingleton<OverallViewManager>.Instance.Play(num, autoClose: false, loop: false);
		this.AttachTimer(49f, delegate
		{
			ProductionPersonnelList.productionPersonnelListSignal.Invoke();
			BGM.clip = BGMClip;
			BGM.Play();
			BGM.loop = true;
			_ = MonoSingleton<AchievementCanUnlock>.Instance.canUnlock;
		});
	}
}
public class InversionDrawingRoom : InversionVariation
{
	public GameObject[] upRoomGO;

	public GameObject[] downRoomGO;

	public override void Inversion(bool obj)
	{
		if (obj)
		{
			for (int i = 0; i < upRoomGO.Length; i++)
			{
				upRoomGO[i].SetActive(value: true);
			}
			for (int j = 0; j < downRoomGO.Length; j++)
			{
				downRoomGO[j].SetActive(value: false);
			}
		}
		else
		{
			for (int k = 0; k < upRoomGO.Length; k++)
			{
				upRoomGO[k].SetActive(value: false);
			}
			for (int l = 0; l < downRoomGO.Length; l++)
			{
				downRoomGO[l].SetActive(value: true);
			}
		}
	}
}
public class InversionFire : InversionVariation
{
	private new void Start()
	{
	}

	public override void Inversion(bool obj)
	{
		if (obj)
		{
			base.transform.GetChild(0).gameObject.SetActive(value: false);
		}
		else
		{
			base.transform.GetChild(0).gameObject.SetActive(value: true);
		}
	}
}
public class InversionPaint : InversionVariation
{
	public override void Inversion(bool obj)
	{
		if (obj)
		{
			base.gameObject.transform.GetChild(0).gameObject.SetActive(value: false);
			GetComponent<BoxCollider>().enabled = true;
		}
		else
		{
			base.gameObject.transform.GetChild(0).gameObject.SetActive(value: true);
			GetComponent<BoxCollider>().enabled = false;
		}
	}
}
public class InversionRoom : InversionVariation
{
	public GameObject Room;

	public Transform normalRoom;

	public Transform mirrorRoom;

	public override void Inversion(bool obj)
	{
		if (obj)
		{
			Room.transform.position = normalRoom.position;
			Room.transform.localScale = new Vector3(1f, 1f, 1f);
		}
		else
		{
			Room.transform.position = mirrorRoom.position;
			Room.transform.localScale = new Vector3(-1f, -1f, 1f);
		}
	}
}
public class InversionVariation : MonoBehaviour
{
	public static Signal<bool> InversionSignal = new Signal<bool>();

	private bool testBool = true;

	public void Start()
	{
		InversionSignal.AddListener(Inversion);
	}

	public void Update()
	{
		if (Input.GetKeyDown(KeyCode.F))
		{
			testBool = !testBool;
			Inversion(testBool);
		}
	}

	public virtual void Inversion(bool obj)
	{
	}
}
public class BottleEye : MonoBehaviour
{
	public GameObject eyeParent;

	public List<Transform> eyeList;

	public static Signal eyeSignal = new Signal();

	private bool lookStart;

	private float time;

	private void Start()
	{
		eyeParent = GameObject.Find("eye");
		foreach (Transform item in eyeParent.transform)
		{
			eyeList.Add(item);
		}
		eyeSignal.AddListener(EyeLookPlayer);
	}

	private void EyeLookPlayer()
	{
		for (int i = 0; i < eyeList.Count; i++)
		{
			eyeList[i].DOLookAt(MonoSingleton<PlayerInfo>.Instance.GetEasyVRHeadPos(), 0.5f, AxisConstraint.Y);
		}
		lookStart = true;
	}

	public void OnTriggerStay(Collider other)
	{
		if (lookStart && other.CompareTag("Player"))
		{
			for (int i = 0; i < eyeList.Count; i++)
			{
				eyeList[i].LookAt(MonoSingleton<PlayerInfo>.Instance.GetEasyVRHeadPos(), Vector3.up);
			}
		}
	}

	public void OnTriggerExit(Collider other)
	{
		if (other.CompareTag("Player"))
		{
			for (int i = 0; i < eyeList.Count; i++)
			{
				eyeList[i].rotation = Quaternion.Euler(0f, 0f, 0f);
			}
		}
	}
}
public class Corpse : MonoBehaviour
{
	public GameObject Blood;

	public void OnTriggerEnter(Collider other)
	{
		if (other.CompareTag("Knife"))
		{
			UnityEngine.Object.Instantiate(Blood, base.transform).transform.position = other.transform.position;
			MonoBehaviour.print("刀的方向:" + other.transform.rotation.ToString());
		}
	}
}
public class EyeKnife : SmallHandItem
{
	public override void PressDown()
	{
		base.PressDown();
		BottleEye.eyeSignal.Invoke();
	}
}
public class HangedManKinfe : MonoBehaviour
{
	public GameObject blood;

	private void OnCollisionEnter(Collision collision)
	{
		if (collision.gameObject.CompareTag("HangedMan"))
		{
			blood.SetActive(value: true);
			blood.transform.parent.position = collision.GetContact(0).point;
			this.AttachTimer(0.5f, delegate
			{
				blood.SetActive(value: false);
			});
		}
	}
}
public class HangingDeadKey : TaskItem
{
	[Tooltip("尸体")]
	public GameObject corpse;

	public override void GetItemSignal(ItemType obj)
	{
	}
}
public class PhonographRocker : MonoBehaviour
{
	public void Start()
	{
		base.transform.DOLocalRotate(Vector3.up * 4f * 360f, 5f).SetDelay(1f).OnComplete(delegate
		{
			MonoBehaviour.print("播放留声机声音");
		});
	}
}
public class PhonographRockerTaskItem : TaskItem
{
	public GameObject hangingDead;

	public bool playAudio;

	public static bool canSetMove = true;

	public override void GetItemSignal(ItemType obj)
	{
		_ = 140008;
	}

	public override void PressDown()
	{
		base.Rigibody.isKinematic = true;
		if (handInfo != null)
		{
			base.transform.SetParent(handInfo.transform);
			base.transform.localPosition = Vector3.zero;
			base.transform.localRotation = Quaternion.identity;
		}
		GetComponentInChildren<ArrowLookCamera>()?.Hide();
		PlayTakeAudio();
		base.transform.localPosition = Vector3.zero;
		base.transform.localRotation = Quaternion.Euler(Vector3.zero);
		EventsCentral._拾取物品.InvokeSafe(info.id);
		if (canSetMove)
		{
			MonoSingleton<PlayerInfo>.Instance.SetCanMove(state: false, 3f);
			canSetMove = false;
		}
		if (playAudio)
		{
			hangingDead.GetComponent<PlayableDirector>().enabled = true;
			playAudio = false;
		}
	}
}
public class PhonographTrigger : MonoBehaviour
{
	public GameObject rocker;

	public void OnTriggerEnter(Collider other)
	{
		if (MonoSingleton<PlayerInfo>.Instance.rightTouch.selectedObj.GetComponent<TaskItem>().info.id == ItemType._140008_物品_幻室_摇杆)
		{
			MonoSingleton<PlayerInfo>.Instance.rightTouch.DelectSelectedInHand();
			rocker.SetActive(value: true);
			GetComponent<PlayableDirector>().enabled = true;
		}
	}
}
public class PlayDropVideo : MonoBehaviour
{
	public VideoClip clip;

	public FantasyRoom2GlobalSignal room2GlobalSignal;

	public void PlayDrop360Video()
	{
		MonoSingleton<OverallViewManager>.Instance.Play(clip);
		this.AttachTimer((float)clip.length, delegate
		{
			room2GlobalSignal.LoadSceneFantasyroom3();
		});
	}

	public void OnTriggerEnter(Collider other)
	{
		PlayDrop360Video();
	}
}
public class WatchButcher : ObjectListen
{
	public DoorInfo killRoomDoor;

	public GameObject butcherLight;

	public override void EventTrigger()
	{
		killRoomDoor.enabled = true;
		MonoBehaviour.print("开铁门");
	}
}
public class AlisaOilLight : MJListen
{
	public GameObject alisa;

	public override void OnTrigger()
	{
		if (MonoSingleton<BackpackManager>.Instance.GetItemIsHave(ItemType._140007_物品_幻室_炼金配方表))
		{
			base.OnTrigger();
			alisa.SetActive(value: true);
		}
	}
}
public class AlisaOilLightPutout : MonoBehaviour
{
	public static Signal oilLightSignal = new Signal();

	private bool canInvoke = true;

	private void Start()
	{
		GetComponent<MeshRenderer>().materials[1] = UnityEngine.Object.Instantiate(GetComponent<MeshRenderer>().materials[1]);
		oilLightSignal.AddListener(AttachTimerOilLightPutout);
	}

	private void OnDestroy()
	{
		oilLightSignal.RemoveAllListeners();
	}

	private void OilLightPutout()
	{
		GetComponentInParent<PlayableDirector>().enabled = false;
		GetComponent<MeshRenderer>().materials[1].DisableKeyword("_EMISSION");
		GetComponentInChildren<Light>().enabled = false;
	}

	public void AttachTimerOilLightPutout()
	{
		MonoSingleton<SubtitleManager>.Instance.Play(1401);
		this.AttachTimer(6.8f, OilLightPutout);
		oilLightSignal.RemoveAllListeners();
	}
}
public class Bat : MonoBehaviour
{
	public static Signal<string> batSignal = new Signal<string>();

	public bool bottleBroken;

	private void Start()
	{
		batSignal.AddListener(BatState);
	}

	private void BatState(string obj)
	{
		if (obj == "蝙蝠" && bottleBroken && MonoSingleton<BackpackManager>.Instance.GetItemIsHave(ItemType._140007_物品_幻室_炼金配方表))
		{
			base.gameObject.layer = 9;
			base.transform.GetChild(0).gameObject.SetActive(value: true);
		}
	}
}
public class BatAndBottleParent : NormalItem
{
	public override void PressUp()
	{
		handInfo.RemoveSelectedInHand();
		base.transform.SetParent(null);
		ThrowObject();
		base.Rigibody.useGravity = true;
		base.Rigibody.isKinematic = false;
	}
}
public class BatBottle : BrokenBottle
{
	public GameObject bat;

	public override void OtherFunction()
	{
		base.transform.parent.gameObject.layer = 0;
		bat.GetComponent<Bat>().bottleBroken = true;
		bat.transform.SetParent(base.transform.parent.parent);
		Bat.batSignal.Invoke("蝙蝠");
		GetComponentInParent<Rigidbody>().isKinematic = true;
		GetComponentInParent<Collider>().enabled = false;
	}
}
public class LobbyWardrobeDoor : DoorInfo
{
	public override void PressDown()
	{
		if (canOpen)
		{
			inHand = true;
			UnityEngine.Debug.LogError(base.transform.GetChild(0).gameObject.activeSelf);
			if (doorType == DoorType.None)
			{
				AudioType._90001_拧动门把手的音效.Play(base.transform);
			}
			if (doorType == DoorType.铁门)
			{
				AudioType._90036_铁把手.Play(base.transform);
			}
		}
		if (!base.enabled && canPlaySubtitle)
		{
			MonoSingleton<SubtitleManager>.Instance.Play(1040);
			canPlaySubtitle = false;
			this.AttachTimer(MonoSingleton<SubtitleManager>.Instance.subtitleInfos[1040].audioClip.length, delegate
			{
				canPlaySubtitle = true;
			});
		}
		Scatteredpuppetparts.puppetSignal.Invoke();
	}

	public override void PressUp()
	{
		if (!canOpen)
		{
			return;
		}
		inHand = false;
		handInfo.RemoveSelectedInHand();
		if (doorType == DoorType.None)
		{
			AudioType._90002_松开门把手的音效.Play(base.transform);
		}
		if (doorType == DoorType.铁门)
		{
			AudioType._90033_开铁门.Play(base.transform, 5f);
		}
		if (Mathf.Abs(angle) >= 15f && !isOpen)
		{
			openDoor?.Invoke();
			OpenDoor();
			isOpen = true;
			if (hideGO != null)
			{
				hideGO.GetComponent<Collider>().enabled = true;
				GetComponentInChildren<ArrowLookCamera>()?.Show();
				hideGO.transform.GetChild(0).gameObject.SetActive(value: true);
			}
		}
		if (angle == 0f && isOpen)
		{
			closeDoor?.Invoke();
			CloseDoor();
			isOpen = false;
		}
	}
}
public class MetallicMaterials : TaskItem
{
	public override void GetItemSignal(ItemType obj)
	{
	}
}
public class PuppetDrop : MonoBehaviour
{
	public void OpenRigIsKinematic()
	{
		foreach (Transform item in base.gameObject.transform)
		{
			if (item.GetComponent<Rigidbody>() != null)
			{
				item.GetComponent<Rigidbody>().isKinematic = true;
			}
		}
	}
}
public class RoomLight : MonoBehaviour
{
	public static Signal<bool> roomLightSignal = new Signal<bool>();

	private void Start()
	{
		roomLightSignal.AddListener(LightCtrl);
	}

	private void OnDestroy()
	{
		roomLightSignal.RemoveAllListeners();
	}

	private void LightCtrl(bool obj)
	{
		if (obj)
		{
			GetComponent<Animator>().SetTrigger("开灯");
		}
		else
		{
			GetComponent<Animator>().SetTrigger("关灯");
		}
	}
}
public class SJEMaskTrigger : MonoBehaviour
{
	public GameObject woodeenScreen;

	public GameObject SJE;

	public void OnTriggerStay(Collider other)
	{
		if (MonoSingleton<RayTrigger>.Instance.outGameobject == woodeenScreen)
		{
			SJE.GetComponent<PlayableDirector>().enabled = true;
			MonoSingleton<PlayerInfo>.Instance.SetCanMove(state: false, 2f);
		}
	}
}
public class CloseBookcaseDoor : MJListen
{
	public GameObject bookcase;

	public GameObject bookcaseDoor;

	public override void OnTrigger()
	{
		base.OnTrigger();
		bookcase.GetComponent<PlayableDirector>().enabled = false;
		bookcaseDoor.GetComponent<Animator>().SetTrigger("关门");
		AudioType._13045_关书柜门.Play();
	}
}
public class Fantasyroom2IronDoor : MonoBehaviour
{
	private TaskItem item;

	public Transform pos;

	private void OnTriggerExit(Collider other)
	{
	}

	private void OnTriggerEnter(Collider other)
	{
		MonoBehaviour.print(other.name + ">>>>>>>>>>>");
		if (!other.CompareTag(TagType.TaskItem.ToString()) || !other.TryGetComponent<TaskItem>(out item))
		{
			return;
		}
		MonoBehaviour.print("获得到taskitem");
		if (item.info.id == ItemType._140010_物品_幻室_铁门的大钥匙)
		{
			MonoBehaviour.print("是钥匙");
			MonoSingleton<PlayerInfo>.Instance.SpeedMoveTo(pos.position, 0.1f, canMove: false);
			this.AttachTimer(3f, delegate
			{
				MonoSingleton<PlayerInfo>.Instance.SetCanMove(state: true);
			});
			GetComponentInParent<PlayableDirector>().enabled = true;
			MonoSingleton<PlayerInfo>.Instance.rightTouch.DelectSelectedInHand();
			AudioType._12040_钥匙打开门锁的音效.Play();
			MonoBehaviour.print("开锁");
		}
	}
}
public class HangPainting : MonoBehaviour
{
	public DoorInfo doorInfo;

	private void Start()
	{
	}

	public void OnTriggerEnter(Collider other)
	{
		if (other.GetComponent<TaskItem>() != null && other.GetComponent<TaskItem>().GetItemType() == ItemType._140001_查看_幻室_凯瑟琳的画)
		{
			base.transform.GetChild(0).gameObject.SetActive(value: true);
			UnityEngine.Object.Destroy(MonoSingleton<PlayerInfo>.Instance.rightTouch.selectedObj);
			MonoSingleton<BackpackManager>.Instance.RemoveItem(ItemType._140001_查看_幻室_凯瑟琳的画);
			doorInfo.enabled = true;
			doorInfo.SetAngle(-30f, 1.32f);
		}
	}
}
public class PaintingTaskItem : TaskItem
{
	public override void PressDown()
	{
		base.PressDown();
		GetComponent<Animator>().enabled = true;
	}
}
public class AlisaPuppet : Puppet
{
	public override void puppetEvent(int obj)
	{
		if (obj == 1)
		{
			base.gameObject.GetComponent<Animator>().SetTrigger("站立");
		}
		_ = 2;
	}
}
public class LandonPuppet : Puppet
{
	private bool LookStart;

	public void Update()
	{
		if (LookStart)
		{
			base.transform.LookAt(MonoSingleton<PlayerInfo>.Instance.transform);
		}
	}

	public override void puppetEvent(int obj)
	{
		if (obj == 1)
		{
			base.gameObject.GetComponent<Animator>().SetTrigger("站立");
		}
		if (obj == 2)
		{
			base.gameObject.GetComponent<Animator>().SetTrigger("行走");
		}
		if (obj == 3)
		{
			base.gameObject.GetComponent<Animator>().SetTrigger("阻止");
			LookStart = true;
		}
	}
}
public class LilithPuppet : Puppet
{
	public override void puppetEvent(int obj)
	{
		if (obj == 1)
		{
			base.gameObject.SetActive(value: false);
			scatteredPuppet.SetActive(value: true);
		}
	}
}
public class LindaPuppet : Puppet
{
	public override void puppetEvent(int obj)
	{
		if (obj == 1)
		{
			base.gameObject.GetComponent<Animator>().SetTrigger("站立");
		}
		if (obj == 2)
		{
			base.gameObject.GetComponent<Animator>().SetTrigger("行走");
		}
		if (obj == 3)
		{
			base.gameObject.SetActive(value: false);
			scatteredPuppet.SetActive(value: true);
		}
	}
}
public class Puppet : MonoBehaviour
{
	public static Signal<int> puppetSignal = new Signal<int>();

	public GameObject scatteredPuppet;

	public void Start()
	{
		puppetSignal.AddListener(puppetEvent);
	}

	public virtual void puppetEvent(int obj)
	{
		MonoBehaviour.print("ľż");
	}
}
public class RoomMemory : MJListen
{
	public override void OnTrigger()
	{
	}
}
public class SecretMesageClue : ClueItem
{
	[Tooltip("尸体")]
	public GameObject key;

	public override void GetItemSignal(ItemType obj)
	{
		if (obj == ItemType._140100_线索_幻室_密信)
		{
			key.SetActive(value: true);
		}
	}
}
public class SmallHandItem : NormalItem
{
	public override void PressUp()
	{
		base.PressUp();
	}

	public override void PressDown()
	{
		base.Rigibody.isKinematic = true;
		if (handInfo != null)
		{
			base.transform.SetParent(handInfo.transform);
			base.transform.localPosition = Vector3.zero;
			base.transform.localRotation = Quaternion.identity;
		}
		GetComponentInChildren<ArrowLookCamera>()?.Hide();
		AudioType._1001_捡取非特定物品.Play(base.transform, 5f);
	}
}
public class FR2Test : MonoBehaviour
{
	private void Start()
	{
		TestManager.AddTest("传送到炼金台", delegate
		{
			MonoSingleton<PlayerInfo>.Instance.SetPos(base.transform.GetChild(0));
		});
		TestManager.AddTest("传送到地牢", delegate
		{
			MonoSingleton<PlayerInfo>.Instance.SetPos(base.transform.GetChild(1).position);
		});
		TestManager.AddTest("传送到打火机", delegate
		{
			MonoSingleton<PlayerInfo>.Instance.SetPos(base.transform.GetChild(2).position);
		});
	}
}
public class TestAudio : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.M))
		{
			AudioType._13042_炼金盆火焰爆炸.Play();
		}
	}
}
public class medicament : TaskItem
{
	public GameObject water;

	public override void PressDown()
	{
		base.PressDown();
		water.SetActive(value: false);
	}
}
public class AudioSourcePauseToPlay : MonoBehaviour
{
	public void AudioSourcePlay()
	{
		GetComponent<AudioSource>().Play();
	}

	public void SubtitlePlay1610()
	{
		MonoSingleton<SubtitleManager>.Instance.Play(1610);
	}
}
public class BlackCanvasAlpha : MonoBehaviour
{
	public GameObject blackCanvas;

	public GameObject AlisaHand;

	public bool start;

	private float a;

	private void Start()
	{
		blackCanvas.SetActive(value: true);
	}

	private void Update()
	{
		blackCanvas.GetComponent<Image>().color = new Color(0f, 0f, 0f, a / 255f);
		if (start)
		{
			if (a > 0f)
			{
				a -= 20f * Time.deltaTime;
			}
			if (a <= 200f)
			{
				AlisaHand.GetComponent<PlayableDirector>().enabled = true;
			}
		}
	}
}
public class FantasyRoom3LandonHeadCamera : MonoBehaviour
{
	private void Update()
	{
		base.transform.SetPositionAndRotation(MonoSingleton<PlayerInfo>.Instance.EasyVRHead.transform.position, MonoSingleton<PlayerInfo>.Instance.EasyVRHead.transform.rotation);
	}
}
public class LookBedRoom : MonoBehaviour
{
	public GameObject window;

	public GameObject lilith;

	public void OnTriggerStay(Collider other)
	{
		if (MonoSingleton<RayTrigger>.Instance.outGameobject == window)
		{
			lilith.GetComponent<AudioSource>().Pause();
			lilith.GetComponent<PlayableDirector>().enabled = true;
		}
	}
}
public class BrokeLimbs : NormalItem
{
	public override void PressUp()
	{
		base.PressUp();
		SceneManager.MoveGameObjectToScene(base.gameObject, SceneManager.GetSceneByName("FantasyRoom3_Dungeon"));
	}
}
public class CorridorCar : MonoBehaviour
{
	public GameObject pickupTruck;

	public void OnTriggerEnter(Collider other)
	{
		if (other.CompareTag("Player"))
		{
			pickupTruck.SetActive(value: true);
		}
	}
}
public class PlayerWalkAudioInit : MonoBehaviour
{
	public MJFSM.SceneType sceneType;

	public void Start()
	{
		if (sceneType == MJFSM.SceneType.酒店大厅)
		{
			MonoSingleton<PlayerInfo>.Instance.gameObject.GetComponent<AudioSource>().clip = MonoSingleton<AudioManager>.Instance.audioDict[AudioType._90031_玩家拎油灯走在水泥地.GetHashCode()].clip;
		}
	}
}
public class TrainWomenActive : MonoBehaviour
{
	public bool canOpen;

	public void OnTriggerStay(Collider other)
	{
		if (MonoSingleton<PlayerInfo>.Instance.rightController.TriggerPressDown && canOpen)
		{
			GetComponent<PlayableDirector>().enabled = true;
		}
	}

	public void CanOpen()
	{
		canOpen = true;
	}
}
public class Dungeon1TieRod : RotationBase
{
	public GameObject women;

	public int num;

	public GameObject women1;

	public GameObject womenLight;

	public GameObject womenLightParent;

	public GameObject lightModel;

	public GameObject LampGym;

	public GameObject sparkEffect;

	public AudioClip audioClip;

	public static bool finished;

	public bool isBackMin = true;

	public override void Init()
	{
		base.Init();
		maxAngleEvent.AddListener(Open);
		minAngleEvent.AddListener(Close);
	}

	private void Open()
	{
		AudioType._13050_拉动射灯把手.Play();
	}

	private void Close()
	{
		AudioType._13050_拉动射灯把手.Play();
		women.GetComponent<AudioSource>().enabled = false;
		this.AttachTimer(4f, delegate
		{
			women.GetComponent<AudioSource>().enabled = true;
		});
		if (!women.GetComponent<PlayableDirector>().enabled)
		{
			women.GetComponent<Animator>().enabled = true;
			women.GetComponent<AudioSource>().enabled = true;
			women.GetComponent<PlayableDirector>().enabled = true;
		}
		if (num < 3 && women.GetComponent<PlayableDirector>().state != PlayState.Playing)
		{
			women.GetComponent<PlayableDirector>().Play();
			num++;
		}
		if (num == 3)
		{
			AudioSource.PlayClipAtPoint(audioClip, base.transform.position);
			womenLight.SetActive(value: false);
			women.SetActive(value: false);
			lightModel.GetComponent<MeshRenderer>().material.DisableKeyword("_EMISSION");
			LampGym.GetComponent<MeshRenderer>().material.DisableKeyword("_EMISSION");
			this.AttachTimer(0f, delegate
			{
				women1.SetActive(value: true);
			});
			this.AttachTimer(5f, delegate
			{
				womenLightParent.GetComponent<PlayableDirector>().enabled = true;
				lightModel.GetComponent<MeshRenderer>().material.EnableKeyword("_EMISSION");
				LampGym.GetComponent<MeshRenderer>().material.EnableKeyword("_EMISSION");
			});
			num++;
		}
	}

	public override void PressUp()
	{
		if (!finished)
		{
			base.PressUp();
			SetAngle(isBackMin ? min : max, 0.5f);
		}
	}
}
public class Faucet : MonoBehaviour
{
	public static Signal faucetSignal = new Signal();

	public GameObject waterTrigger;

	public GameObject waterFaucet;

	public GameObject waterPool;

	public GameObject image;

	public void Start()
	{
		faucetSignal.AddListener(OpenWater);
	}

	private void OnDestroy()
	{
		faucetSignal.RemoveAllListeners();
	}

	private void OpenWater()
	{
		waterFaucet.SetActive(value: true);
		waterPool.SetActive(value: true);
		image.SetActive(value: true);
		GetComponent<Collider>().enabled = true;
	}

	public void WaterDisappear()
	{
		waterTrigger.GetComponent<PlayableDirector>().enabled = true;
	}

	public void OnTriggerStay(Collider other)
	{
		if (MonoSingleton<PlayerInfo>.Instance.rightController.TriggerPressDown)
		{
			WaterDisappear();
		}
	}
}
public class PlaySubtitle1051 : PlayTriggerSubtitle
{
	public GameObject roulette;

	public override void StayTrigger()
	{
		if (MonoSingleton<RayTrigger>.Instance.outGameobject == roulette)
		{
			base.StayTrigger();
			MonoSingleton<SubtitleManager>.Instance.Play(1051);
		}
	}
}
public class Frag : MonoBehaviour
{
	private void Start()
	{
		Invoke("FragCollider", 0.5f);
	}

	public void FragCollider()
	{
		GetComponent<Collider>().enabled = false;
		GetComponent<Rigidbody>().isKinematic = true;
	}
}
public class NewBehaviourScript : MonoBehaviour
{
	private void Start()
	{
	}
}
public class ObjectRotation : MonoBehaviour
{
	private void Start()
	{
		base.transform.rotation = MonoSingleton<PlayerInfo>.Instance.EasyVRHead.transform.rotation;
		base.transform.rotation = Quaternion.Euler(0f, base.transform.rotation.eulerAngles.y, 0f);
	}
}
public class PXRSystem : MonoBehaviour
{
	public Text device;

	private void Awake()
	{
		PXR_System.InitSystemService(base.gameObject.name);
		PXR_System.BindSystemService();
	}

	private void Start()
	{
		device.text = Application.systemLanguage.ToString();
	}

	private void OnDestory()
	{
		PXR_System.UnBindSystemService();
	}

	private void BoolCallback(string value)
	{
		if (PXR_Plugin.System.BoolCallback != null)
		{
			PXR_Plugin.System.BoolCallback(bool.Parse(value));
		}
		PXR_Plugin.System.BoolCallback = null;
	}

	private void IntCallback(string value)
	{
		if (PXR_Plugin.System.IntCallback != null)
		{
			PXR_Plugin.System.IntCallback(int.Parse(value));
		}
		PXR_Plugin.System.IntCallback = null;
	}

	private void LongCallback(string value)
	{
		if (PXR_Plugin.System.LongCallback != null)
		{
			PXR_Plugin.System.LongCallback(int.Parse(value));
		}
		PXR_Plugin.System.LongCallback = null;
	}

	private void StringCallback(string value)
	{
		if (PXR_Plugin.System.StringCallback != null)
		{
			PXR_Plugin.System.StringCallback(value);
		}
		PXR_Plugin.System.StringCallback = null;
	}

	public void toBServiceBind(string s)
	{
		UnityEngine.Debug.Log("Bind success.");
	}
}
public class PlayTapeNumList : MonoSingleton<PlayTapeNumList>
{
	public List<int> playTapeNumList;
}
public class PlayTriggerSubtitle : MJListen
{
	public SubtitleType subtitleType;

	public Transform subtitleAudioTF;

	public virtual void PlaySubtitle()
	{
		if (subtitleAudioTF != null)
		{
			MonoSingleton<SubtitleManager>.Instance.Play(subtitleType.GetHashCode(), subtitleAudioTF.position);
		}
		else
		{
			MonoSingleton<SubtitleManager>.Instance.Play(subtitleType.GetHashCode());
		}
	}
}
public class ProductionPersonnelList : MonoBehaviour
{
	public static Signal productionPersonnelListSignal = new Signal();

	public void Start()
	{
		productionPersonnelListSignal.AddListener(show);
	}

	private void show()
	{
		base.transform.GetChild(0).gameObject.SetActive(value: true);
		this.AttachTimer(22f, delegate
		{
			MonoSingleton<PlayerInfo>.Instance.canOpenUI = false;
			MonoSingleton<PlayerInfo>.Instance.showRay = true;
			MonoSingleton<OverallViewManager>.Instance.Play(1, autoClose: false);
			MonoSingleton<OverallViewManager>.Instance.transform.GetChild(1).GetChild(0).gameObject.SetActive(value: true);
			MonoSingleton<OverallViewManager>.Instance.transform.GetChild(1).gameObject.SetActive(value: true);
			MonoSingleton<PlayerInfo>.Instance.SetEasyVRController(move: false, left: false, right: true);
			base.gameObject.SetActive(value: false);
			MonoSingleton<GlobalManager>.Instance.CurrentUI = MJFSM.UIPanelType.None;
		});
	}
}
public class UsePostProcess : MonoSingleton<UsePostProcess>
{
	public bool canUsePostProcess;

	public GameObject postProcessVolume;

	public GameObject ball;

	public Material memoryMaterial;

	public Material ghostMaterial;

	public Camera cameraRT;

	public RenderTexture rt;

	private void Start()
	{
		if (canUsePostProcess)
		{
			cameraRT.targetTexture = null;
			cameraRT.GetComponent<PostProcessLayer>().enabled = true;
			postProcessVolume.GetComponent<PostProcessVolume>().enabled = true;
			ball.SetActive(value: false);
		}
		else
		{
			cameraRT.targetTexture = null;
			cameraRT.GetComponent<PostProcessLayer>().enabled = false;
			postProcessVolume.GetComponent<PostProcessVolume>().enabled = false;
			ball.SetActive(value: true);
		}
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.K))
		{
			MonoSingleton<GlobalManager>.Instance.CurrentScene = MJFSM.SceneType.兰登卧室;
		}
	}
}
public class pinshan1 : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
	}
}
public class AnimatorController : MonoBehaviour
{
	private void Start()
	{
		GetComponent<Animator>().enabled = true;
	}
}
public class NumberPadInfo : MonoBehaviour
{
	public Transform[] pads;

	public int leftCount = 3;

	public int rightCount = 2;

	public LR lr;

	public GameObject door;

	public static Signal<LR> pullRod = new Signal<LR>();

	public int lAngle;

	public int rAngle;

	private void Start()
	{
		pullRod.AddListener(PullRod);
	}

	private void Update()
	{
		if (lr == LR.left && lAngle <= leftCount * 90)
		{
			pads[0].Rotate(Vector3.right);
			pads[3].Rotate(Vector3.right);
			pads[4].Rotate(Vector3.right);
			lAngle++;
		}
		if (lr == LR.right && rAngle <= rightCount * 90)
		{
			pads[0].Rotate(-Vector3.right);
			pads[1].Rotate(-Vector3.right);
			pads[2].Rotate(-Vector3.right);
			rAngle++;
		}
		if (leftCount % 4 == 0 && rightCount % 4 == 0)
		{
			OpenDoor();
		}
	}

	private void OpenDoor()
	{
		door.transform.GetChild(0).TweenLocalPositionX(-0.79f, 1f);
		door.transform.GetChild(1).TweenLocalPositionX(0.79f, 1f);
		base.gameObject.TweenAnchoredPositionX(1f, 1f).SetFrom(0f);
		base.enabled = false;
	}

	private void PullRod(LR obj)
	{
		lr = obj;
		switch (obj)
		{
		case LR.left:
			leftCount++;
			break;
		case LR.right:
			rightCount++;
			break;
		}
	}
}
public enum LR
{
	None,
	left,
	right
}
public class NumberPadRod : RotationBase
{
	public LR lr;

	private bool pull = true;

	public override void Pressed()
	{
		base.Pressed();
		if (angle >= 90f && pull)
		{
			NumberPadInfo.pullRod.InvokeSafe(lr);
			pull = false;
		}
	}

	public override void PressUp()
	{
		base.PressUp();
		UnityEngine.Debug.Log("UP");
		base.transform.TweenLocalRotation(new Vector3(0f, 0f, 60f), 1f);
		pull = true;
	}
}
public class CheckstandInfo : MonoBehaviour
{
	public Transform drawer;

	private void Start()
	{
		EventsCentral.Hotel.PowerConnected += new Action(PowerConnected);
	}

	private void PowerConnected()
	{
		MonoSingleton<DelayTime>.Instance.InvokeAfterSecond(delegate
		{
			MonoSingleton<AudioManager>.Instance.Play(1106, base.transform.position);
			drawer.TweenLocalRotation(drawer.localPosition + Vector3.forward * 0.2f, MonoSingleton<AudioManager>.Instance.GetAudioLength(1106));
			ArrowLookCamera[] componentsInChildren = GetComponentsInChildren<ArrowLookCamera>();
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				componentsInChildren[i].Show();
			}
			UnityEngine.Debug.Log("taideng");
		}, 1.1f);
	}
}
public class HotelElectricalLift : GeneralColliderDetectionBase
{
	public GameObject lightObj;

	private void Start()
	{
		EventsCentral.Hotel.PowerConnected += new Action(PowerConnected);
	}

	private void PowerConnected()
	{
		MonoSingleton<AudioManager>.Instance.Play(1105, base.transform.position);
		lightObj.GetComponent<MeshRenderer>().material.EnableKeyword("_EMISSION");
	}
}
public class TableLamp : MonoBehaviour
{
	public GameObject lightObj;

	private void Start()
	{
		EventsCentral.Hotel.PowerConnected += new Action(PowerConnected);
	}

	private void PowerConnected()
	{
		MonoSingleton<DelayTime>.Instance.InvokeAfterSecond(delegate
		{
			lightObj.SetActive(value: true);
			MonoSingleton<AudioManager>.Instance.Play(1107, base.transform.position);
			GetComponent<MeshRenderer>().material.EnableKeyword("_EMISSION");
		}, 0.5f);
	}
}
public class CatherineRoomDoor : EasyVRInteractionBase
{
	public Light doorLight;

	private IEnumerator Light()
	{
		GetComponent<Collider>().enabled = false;
		for (int i = 0; i < 5; i++)
		{
			yield return new WaitForSeconds(0.1f);
			doorLight.gameObject.SetActive(!doorLight.gameObject.activeSelf);
		}
		EventManager.SendEvent(MJFSM.MJEvents._1_切换场景, MJFSM.SceneType.古宅);
		UnityEngine.Debug.Log("切换场景");
	}
}
public class SceneDoor : EasyVRInteractionBase
{
	public override void PressDown()
	{
		MonoSingleton<GlobalManager>.Instance.CurrentScene = MJFSM.SceneType.酒店大厅;
	}
}
public class LoadingSceneInit : MonoBehaviour
{
	private void Awake()
	{
		MonoSingleton<PlayerInfo>.Instance.SetEasyVRController(move: false, left: false, right: false);
		MonoSingleton<PlayerInfo>.Instance.canInput = false;
	}
}
public class ContinueGameButtonUI : UIButtonBase
{
	public Image hover;

	public Text content;

	public override void OnRender()
	{
		Normal();
		isSelected = false;
		if (!PlayerPrefs.HasKey("存档"))
		{
			content.color = new Color(20f / 51f, 20f / 51f, 20f / 51f);
		}
	}

	public override void Normal()
	{
		if (PlayerPrefs.HasKey("存档"))
		{
			content.fontSize = 24;
			hover.color = Color.clear;
			content.color = new Color(64f / 85f, 64f / 85f, 64f / 85f, 1f);
		}
	}

	public override void Hover()
	{
		if (PlayerPrefs.HasKey("存档"))
		{
			content.fontSize = 24;
			hover.color = Color.white;
			content.color = new Color(64f / 85f, 64f / 85f, 64f / 85f, 1f);
		}
	}

	public override void PressDown()
	{
		if (PlayerPrefs.HasKey("存档"))
		{
			content.fontSize = 30;
			hover.color = Color.white;
			content.color = Color.white;
			base.PressDown();
		}
	}

	public override void Selected()
	{
		if (PlayerPrefs.HasKey("存档"))
		{
			base.Selected();
		}
	}

	public override void OnClick()
	{
		base.OnClick();
		MonoSingleton<OverallViewManager>.Instance.NewStop();
		MonoSingleton<PlayerPrefsGame>.Instance.LoadScene();
	}

	public override void Init()
	{
		base.Init();
		content = base.transform.Find("Text").GetComponent<Text>();
		hover = base.transform.Find("Image").GetComponent<Image>();
		if (!PlayerPrefs.HasKey("存档") || !MonoSingleton<GlobalManager>.Instance.canPlayGame)
		{
			GetComponentInChildren<Text>().color = new Color(20f / 51f, 20f / 51f, 20f / 51f);
		}
	}
}
public class GameQuitButtonUI : UIButtonBase
{
	public Image hover;

	public Text content;

	public override void Normal()
	{
		content.fontSize = 24;
		hover.color = Color.clear;
		content.color = new Color(64f / 85f, 64f / 85f, 64f / 85f, 1f);
	}

	public override void Hover()
	{
		content.fontSize = 24;
		hover.color = Color.white;
		content.color = new Color(64f / 85f, 64f / 85f, 64f / 85f, 1f);
	}

	public override void PressDown()
	{
		content.fontSize = 30;
		hover.color = Color.white;
		content.color = Color.white;
		base.PressDown();
	}

	public override void Init()
	{
		base.Init();
		content = base.transform.Find("Text").GetComponent<Text>();
		hover = base.transform.Find("Image").GetComponent<Image>();
	}

	public override void OnClick()
	{
		AudioType._20002_选中按钮.Play();
		Application.Quit();
	}
}
public class GameSettingButtonUI : UIButtonBase
{
	public Image hover;

	public Text content;

	public override void Normal()
	{
		content.fontSize = 24;
		hover.color = Color.clear;
		content.color = new Color(64f / 85f, 64f / 85f, 64f / 85f, 1f);
	}

	public override void Hover()
	{
		content.fontSize = 24;
		hover.color = Color.white;
		content.color = new Color(64f / 85f, 64f / 85f, 64f / 85f, 1f);
	}

	public override void PressDown()
	{
		content.fontSize = 30;
		hover.color = Color.white;
		content.color = Color.white;
		base.PressDown();
	}

	public override void OnClick()
	{
		AudioType._20002_选中按钮.Play();
		MonoSingleton<GlobalManager>.Instance.CurrentUI = MJFSM.UIPanelType.设置界面;
	}

	public override void Init()
	{
		content = base.transform.Find("Text").GetComponent<Text>();
		hover = base.transform.Find("Image").GetComponent<Image>();
		base.Init();
	}
}
public class Login360Follw : MonoBehaviour
{
	public VideoClip bg2;

	private VideoPlayer player;

	private void Start()
	{
		player = GetComponent<VideoPlayer>();
		EventsCentral.EnbledPostProcess?.Invoke(t1: false);
		MonoSingleton<PlayerInfo>.Instance.SetEasyVRController(move: false, left: false, right: false);
		if (MonoSingleton<GlobalManager>.Instance.showLogo)
		{
			this.AttachTimer(22f, Change);
		}
		else
		{
			Change();
		}
	}

	private void Update()
	{
		base.transform.position = MonoSingleton<PlayerInfo>.Instance.GetEasyVRHeadPos();
	}

	public void Change()
	{
		player.clip = bg2;
		player.isLooping = true;
		MonoSingleton<GlobalManager>.Instance.CurrentUI = MJFSM.UIPanelType.Logo;
		base.transform.GetChild(0).gameObject.SetActive(value: true);
		MonoSingleton<PlayerInfo>.Instance.SetEasyVRController(move: false, left: false, right: true);
		MonoSingleton<GlobalManager>.Instance.showLogo = false;
	}
}
public class NewGameButtonUI : UIButtonBase
{
	public Image hover;

	public Text content;

	public ClueUIPanel clueUIPanel;

	public override void OnRender()
	{
		Normal();
		isSelected = false;
	}

	public override void Normal()
	{
		content.fontSize = 24;
		hover.color = Color.clear;
		content.color = new Color(64f / 85f, 64f / 85f, 64f / 85f, 1f);
	}

	public override void Hover()
	{
		content.fontSize = 24;
		hover.color = Color.white;
		content.color = new Color(64f / 85f, 64f / 85f, 64f / 85f, 1f);
	}

	public override void PressDown()
	{
		content.fontSize = 30;
		hover.color = Color.white;
		content.color = Color.white;
		base.PressDown();
	}

	public override void OnClick()
	{
		UnityEngine.Debug.Log("PressDown");
		base.OnClick();
		AudioType._20002_选中按钮.Play();
		MonoSingleton<GlobalManager>.Instance.CurrentScene = MJFSM.SceneType.新手教程;
		EventsCentral.EnbledPostProcess?.Invoke(t1: true);
		MonoSingleton<OverallViewManager>.Instance.NewStop();
		MonoSingleton<PlayerPrefsGame>.Instance.Clear();
		foreach (ItemInfo value in MonoSingleton<BackpackManager>.Instance.ClueDict.Values)
		{
			if (value != null)
			{
				value.isHave = false;
				value.read = false;
			}
		}
		MonoSingleton<TaskItemList>.Instance.taskItemList = new List<ItemType>();
		MonoSingleton<ClueItemList>.Instance.clueItemList = new List<ItemType>();
		clueUIPanel.redPoint.enabled = false;
	}

	public override void Init()
	{
		base.Init();
		content = base.transform.Find("Text").GetComponent<Text>();
		hover = base.transform.Find("Image").GetComponent<Image>();
		if (!MonoSingleton<GlobalManager>.Instance.canPlayGame)
		{
			GetComponentInChildren<Text>().color = new Color(20f / 51f, 20f / 51f, 20f / 51f);
		}
	}
}
public class AudioManager : MonoSingleton<AudioManager>
{
	public Dictionary<int, AudioInfo> audioDict = new Dictionary<int, AudioInfo>();

	public List<AudioType> 拿锅;

	public List<AudioType> 扔锅;

	public List<AudioType> 拿书;

	public List<AudioType> 扔书;

	public List<AudioType> 拿纸;

	public List<AudioType> 扔纸;

	public List<AudioType> 拿小瓷器;

	public List<AudioType> 扔小瓷器;

	public List<AudioType> 拿玩具;

	public List<AudioType> 扔玩具;

	public List<AudioType> 拿瓶子;

	public List<AudioType> 拿调味品;

	public List<AudioType> 扔调味品;

	public List<AudioType> 闹钟掉落;

	public void Play(ItemType item, float value = 10f)
	{
		Play(item, Vector3.zero, value);
	}

	public void Play(AudioType type, float value = 10f)
	{
		UnityEngine.Debug.Log("Play:>>>>" + type);
		Play(type.GetHashCode(), Vector3.zero, value);
	}

	public void Play(AudioType type, Vector3 pos, float value = 10f)
	{
		UnityEngine.Debug.Log("Play:>>>>" + type);
		Play(type.GetHashCode(), pos, value);
	}

	public void Play(ItemType itemType, Vector3 pos, float value = 10f)
	{
		if (audioDict.ContainsKey(itemType.GetHashCode()))
		{
			Play(MonoSingleton<BackpackManager>.Instance.DataDict[itemType].audioId, pos, value);
		}
		else
		{
			UnityEngine.Debug.LogError("没有这个:" + itemType);
		}
	}

	public void Play(int id)
	{
		Play(id, Vector3.zero);
	}

	public void Play(int id, Vector3 pos, float value = 10f)
	{
		if (id != 0)
		{
			if (audioDict.ContainsKey(id))
			{
				AudioSource.PlayClipAtPoint(audioDict[id].clip, pos, value * Singleton<Config>.Instance.SoundVolume);
				return;
			}
			AudioType audioType = (AudioType)id;
			UnityEngine.Debug.LogError("没有这个:" + audioType);
		}
	}

	public float GetAudioLength(int id)
	{
		return audioDict[id].clip.length;
	}
}
public class ArrowLookCamera : MonoBehaviour
{
	private int tmp;

	private MeshRenderer render;

	public Vector3 target;

	private void Start()
	{
		render = GetComponentInChildren<MeshRenderer>();
	}

	private void FixedUpdate()
	{
		if (!(MonoSingleton<PlayerInfo>.Instance.EasyVRHead != null))
		{
			return;
		}
		target = new Vector3(MonoSingleton<PlayerInfo>.Instance.EasyVRHead.transform.position.x, base.transform.position.y, MonoSingleton<PlayerInfo>.Instance.EasyVRHead.transform.position.z);
		UnityEngine.Debug.DrawLine(base.transform.position, target);
		base.transform.LookAt(target);
		if (tmp == 10)
		{
			if (Vector3.Distance(base.transform.position, MonoSingleton<PlayerInfo>.Instance.EasyVRHead.transform.position) <= MonoSingleton<PlayerInfo>.Instance.radius)
			{
				render.enabled = true;
			}
			else
			{
				render.enabled = false;
			}
			tmp = 0;
		}
		tmp++;
	}

	public void Hide()
	{
		base.gameObject.SetActive(value: false);
	}

	public void Show()
	{
		base.gameObject.SetActive(value: true);
	}
}
public class AsyncLoadScene : UIPanelBase
{
	public Slider slider;

	private AsyncOperation mAsyncOperation;

	private MJFSM.SceneType sceneType;

	private bool isLoading;

	public int currentScene;

	public float value;

	public float speed = 0.01f;

	public float Length;

	public override void Init()
	{
		base.Init();
		EventsCentral.Scene.ChangScene += new Action<MJFSM.SceneType>(LoadScene);
		SceneManager.sceneLoaded += SceneManager_sceneLoaded;
		Application.backgroundLoadingPriority = UnityEngine.ThreadPriority.Low;
	}

	private void SceneManager_sceneLoaded(Scene arg0, LoadSceneMode arg1)
	{
		UnityEngine.Debug.Log(arg0.name);
		MonoSingleton<PlayerInfo>.Instance.canInput = true;
		EventsCentral.Scene.ChangedCurrentScene.InvokeSafe(sceneType);
	}

	private void Update()
	{
		if (isLoading)
		{
			value = Mathf.Clamp(value + speed, 0f, Length);
			UpdateSlider();
		}
	}

	public void LoadScene(MJFSM.SceneType scene)
	{
		UnityEngine.Debug.Log("scene" + scene);
		sceneType = scene;
		MonoSingleton<GlobalManager>.Instance.CurrentUI = MJFSM.UIPanelType.加载界面;
		StartCoroutine(LoadSceneAsync(scene.GetHashCode()));
	}

	private IEnumerator LoadSceneAsync(int sceneIndex)
	{
		isLoading = true;
		SceneManager.LoadScene("Loading", LoadSceneMode.Additive);
		Length = 0.5f;
		yield return GC();
		if (currentScene != 0)
		{
			yield return SceneManager.UnloadSceneAsync(currentScene);
		}
		currentScene = sceneIndex;
		Length = 1f;
		yield return GC();
		Length = 2.1f;
		mAsyncOperation = SceneManager.LoadSceneAsync(sceneIndex, LoadSceneMode.Additive);
		mAsyncOperation.allowSceneActivation = false;
		while (mAsyncOperation.progress < 0.9f)
		{
			yield return null;
		}
		Length = 3f;
		yield return new WaitForSeconds(0.2f);
		Length = 3.5f;
		Length = 4f;
		yield return new WaitForSeconds(0.2f);
		Length = 5f;
		UnityEngine.Debug.Log("3Loading");
		while (value != 5f)
		{
			yield return null;
		}
		Length = 0f;
		value = 0f;
		slider.value = 0f;
		isLoading = false;
		SceneManager.UnloadSceneAsync("Loading");
		yield return ShowScene();
		mAsyncOperation = null;
		MonoSingleton<GlobalManager>.Instance.CurrentUI = MJFSM.UIPanelType.None;
	}

	public bool GC()
	{
		MonoSingleton<PoolManager>.Instance.ClearAudioPools();
		UnityEngine.Object[] array = Resources.FindObjectsOfTypeAll<Material>();
		UnityEngine.Object[] array2 = array;
		for (int i = 0; i < array2.Length; i++)
		{
			array2[i] = null;
		}
		array = Resources.FindObjectsOfTypeAll<Texture>();
		UnityEngine.Object[] array3 = array;
		for (int j = 0; j < array3.Length; j++)
		{
			array3[j] = null;
		}
		Resources.UnloadUnusedAssets();
		System.GC.Collect();
		System.GC.WaitForPendingFinalizers();
		System.GC.Collect();
		return true;
	}

	public bool ShowScene()
	{
		mAsyncOperation.allowSceneActivation = true;
		return true;
	}

	private void UpdateSlider()
	{
		if (mAsyncOperation != null)
		{
			slider.value = value / 5f;
		}
	}

	public override void Show()
	{
		base.transform.GetChild(0).gameObject.SetActive(value: true);
	}

	public override void Hide()
	{
		base.transform.GetChild(0).gameObject.SetActive(value: false);
	}
}
public class LoadScene : MonoSingleton<LoadScene>
{
	public static string sceneName;

	public static int sceneIndex;

	public static bool byName;

	public static bool byIndex;

	public void LoadSceneByName(string name)
	{
		byName = true;
		sceneName = name;
		SceneManager.LoadSceneAsync("TestLoading");
	}

	public void LoadSceneByID(int index)
	{
		byIndex = true;
		sceneIndex = index;
		SceneManager.LoadSceneAsync("TestLoading");
	}
}
public class DelayTime : MonoSingleton<DelayTime>
{
	private double currentTime;

	private Dictionary<double, Action> actionDict = new Dictionary<double, Action>();

	public void InvokeAfterSecond(Action action, float delayTime)
	{
		UnityEngine.Debug.Log(Math.Round(currentTime + (double)delayTime, 2));
		actionDict.Add(Math.Round(currentTime + (double)delayTime, 2), action);
	}

	public void InvokeStepSecond(Action action, float delayTime)
	{
	}

	public void Update()
	{
		currentTime = Math.Round(Time.time, 2);
		if (actionDict.ContainsKey(currentTime))
		{
			actionDict[currentTime]();
			actionDict.Remove(currentTime);
		}
	}
}
public class EventsCentral
{
	public class MainPanel
	{
		public static Signal _开启开始界面 = new Signal();

		public static Signal _关闭开始界面 = new Signal();
	}

	public class Backpack
	{
		public static Signal _开启背包 = new Signal();

		public static Signal _关闭背包 = new Signal();

		public static Signal<string> _悬停物品 = new Signal<string>();

		public static Signal<ItemType> _添加物品到背包 = new Signal<ItemType>();

		public static Signal<ItemType> _取出物品 = new Signal<ItemType>();
	}

	public class Clue
	{
		public static Signal<ItemType> _选中线索 = new Signal<ItemType>();
	}

	public class System
	{
		public static Signal<float> 音量调节 = new Signal<float>();

		public static Signal<int> 切换语言 = new Signal<int>();

		public static Signal 语言切换完成 = new Signal();
	}

	public class Hotel
	{
		public static Signal PowerConnected = new Signal();
	}

	public class Scene
	{
		public static Signal<MJFSM.SceneType> ChangScene = new Signal<MJFSM.SceneType>();

		public static Signal<MJFSM.SceneType> ChangedCurrentScene = new Signal<MJFSM.SceneType>();
	}

	public class UI
	{
		public static Signal<MJFSM.UIPanelType> Refresh = new Signal<MJFSM.UIPanelType>();

		public static Signal<MJFSM.UIPanelType> _Invoke_开启界面 = new Signal<MJFSM.UIPanelType>();

		public static Signal<MJFSM.UIPanelType> _Callback_开启界面 = new Signal<MJFSM.UIPanelType>();

		public static Signal<MJFSM.UIPanelType> _关闭界面 = new Signal<MJFSM.UIPanelType>();

		public static Signal _关闭所有界面 = new Signal();

		public static Signal<string> Tips = new Signal<string>();

		public static Signal<MJFSM.UIPanelType, ItemType> SelectedUIButton = new Signal<MJFSM.UIPanelType, ItemType>();

		public static Signal<string> SelectedBackpackItemUI = new Signal<string>();
	}

	public class FantasyRoom
	{
		public static Signal Book = new Signal();

		public static Signal EnableBlackHole = new Signal();
	}

	public static Signal<TouchBase> PickupItem = new Signal<TouchBase>();

	public static Signal<TouchBase> ReleaseItem = new Signal<TouchBase>();

	public static Signal<ItemType> RemoveItemEvent = new Signal<ItemType>();

	public static Signal<VideoClip, Transform, Transform> Player360Video = new Signal<VideoClip, Transform, Transform>();

	public static Signal Pause360Video = new Signal();

	public static Signal<ItemType> RaySelected = new Signal<ItemType>();

	public static Signal<string, TriggerType> BoxTrigger = new Signal<string, TriggerType>();

	public static Signal<string> Tips = new Signal<string>();

	public static Signal<string> OpenDoor = new Signal<string>();

	public static Signal<bool> EnbledPostProcess = new Signal<bool>();

	public static Signal<ItemType> _拾取物品 = new Signal<ItemType>();
}
public class GeneralColliderDetectionBase : MonoBehaviour
{
	public ItemType macthItemType;

	internal TouchBase touchBase;

	private void OnTriggerEnter(Collider other)
	{
		if (other.CompareTag(TagType.TaskItem.ToString()) && other.TryGetComponent<TouchBase>(out touchBase) && touchBase.info.id == macthItemType)
		{
			OnTrigger();
		}
	}

	public virtual void OnTrigger()
	{
		MonoSingleton<PlayerInfo>.Instance.rightTouch.DelectSelectedAndRemoveInfoInBackpack();
	}
}
[Serializable]
public class AudioInfo
{
	public int ID;

	public string Name;

	public AudioClip clip
	{
		get
		{
			UnityEngine.Debug.Log(Name);
			return MonoSingleton<PoolManager>.Instance.GetAudioClip(Name);
		}
	}
}
public interface ILock
{
	void UnLock();
}
public class TouchBase : EasyVRTouchBase
{
	public ItemInfo info;

	public override void Init()
	{
		base.Init();
		if (base.gameObject.layer == LayerMask.NameToLayer("Untagged"))
		{
			UnityEngine.Debug.LogError(base.name + " LayerMask需要设置");
		}
		if (!GetComponent<Collider>())
		{
			UnityEngine.Debug.LogError(base.name + "需要设置碰撞");
		}
		if (CompareTag("TaskItem") || CompareTag("ClueItem") || CompareTag("CheckItem") || CompareTag("CheckStaticItem"))
		{
			info = MonoSingleton<BackpackManager>.Instance.GetItemInfo(this.GetItemType());
		}
		EventsCentral.Backpack._添加物品到背包.AddListener(GetItemSignal);
	}

	private void OnDestroy()
	{
		EventsCentral.Backpack._添加物品到背包.RemoveListener(GetItemSignal);
	}

	public virtual void GetItemSignal(ItemType obj)
	{
	}

	public override void OnBodyTriggerEnterVoid()
	{
		base.OnBodyTriggerEnterVoid();
	}

	public override void OnBodyTriggerExit(object obj)
	{
		base.OnBodyTriggerExit(obj);
	}

	public override void PressDown()
	{
		base.PressDown();
		PlayTakeAudio();
		EventsCentral.PickupItem.InvokeSafe(this);
	}

	public virtual void PlayTakeAudio()
	{
		if (info.audioId != 0)
		{
			MonoSingleton<AudioManager>.Instance.Play(info.audioId, base.transform.position, 5f);
			MonoBehaviour.print("check>>>>>>>>>>>>>>>>");
		}
		else
		{
			AudioType._1001_捡取非特定物品.Play(base.transform, 5f);
		}
	}

	public virtual void PlayThrowAudio()
	{
	}

	public override void PressUp()
	{
		base.PressUp();
	}

	public void Recycle()
	{
		MonoSingleton<PoolManager>.Instance.RecycleTouchBase(this);
	}
}
public class ContraryDrawer : Drawer
{
	public override void PressedDrawer()
	{
		if (isPositive)
		{
			clampX = Mathf.Clamp(base.transform.position.x, originPos.x, originPos.x + distanceLimit);
			clampY = Mathf.Clamp(base.transform.position.y, originPos.y, originPos.y + distanceLimit);
			clampZ = Mathf.Clamp(base.transform.position.z, originPos.z, originPos.z + distanceLimit);
		}
		else
		{
			clampX = Mathf.Clamp(base.transform.position.x, originPos.x + distanceLimit, originPos.x);
			clampY = Mathf.Clamp(base.transform.position.y, originPos.y + distanceLimit, originPos.y);
			clampZ = Mathf.Clamp(base.transform.position.z, originPos.z + distanceLimit, originPos.z);
		}
		base.transform.position = new Vector3((moveDirection == MoveDirectionType.x) ? clampX : base.transform.position.x, (moveDirection == MoveDirectionType.y) ? clampY : base.transform.position.y, (moveDirection == MoveDirectionType.z) ? clampZ : base.transform.position.z);
		switch (moveDirection)
		{
		case MoveDirectionType.x:
			if (Mathf.Approximately(drawerPosX, endPosX) && !open)
			{
				MonoSingleton<AudioManager>.Instance.Play(AudioType._12008_打开抽屉音效, base.transform.position, 20f);
				open = true;
			}
			if (base.transform.position.x == originPos.x && open)
			{
				MonoSingleton<AudioManager>.Instance.Play(AudioType._12009_关闭抽屉音效, base.transform.position, 20f);
				open = false;
			}
			break;
		case MoveDirectionType.y:
			if ((float)(int)base.transform.position.y >= (float)(int)originPos.y + distanceLimit && moveDirection == MoveDirectionType.y && !open)
			{
				MonoSingleton<AudioManager>.Instance.Play(AudioType._12008_打开抽屉音效, base.transform.position, 20f);
				open = true;
			}
			if (base.transform.position.y == originPos.y && moveDirection == MoveDirectionType.y && open)
			{
				MonoSingleton<AudioManager>.Instance.Play(AudioType._12009_关闭抽屉音效, base.transform.position, 20f);
				open = false;
			}
			break;
		case MoveDirectionType.z:
			if (drawerPosZ <= endPosZ && !open)
			{
				MonoSingleton<AudioManager>.Instance.Play(AudioType._12008_打开抽屉音效, base.transform.position, 20f);
				open = true;
			}
			if (base.transform.position.z == originPos.z && open)
			{
				MonoSingleton<AudioManager>.Instance.Play(AudioType._12009_关闭抽屉音效, base.transform.position, 20f);
				open = false;
			}
			break;
		}
	}
}
public class Drawer : MoveBase
{
	[Tooltip("初始坐标")]
	public Vector3 originPos;

	[Tooltip("结束位置Z轴")]
	public float endPosZ;

	[Tooltip("结束位置X轴")]
	public float endPosX;

	[Tooltip("允许抽屉拉动的距离")]
	public float distanceLimit = 0.1f;

	[Tooltip("判断抽屉是否打开")]
	public bool open;

	public float openPosZ;

	public float openPosX;

	[Tooltip("抽屉当前位置Z轴")]
	public float drawerPosZ;

	[Tooltip("抽屉当前位置X轴")]
	public float drawerPosX;

	public UnityEvent openDrawer;

	[Tooltip("抽屉里是否有需要隐藏的东西")]
	public GameObject hideGO;

	[Tooltip("抽屉内东西的类型")]
	public DrawerObjType drawerObjType;

	[Tooltip("判断distanceLimit的值是否为正，正=true，负=false")]
	public bool isPositive = true;

	public bool needPressUp;

	private bool inHand;

	public bool needCancleCollider = true;

	[Tooltip("有些抽屉轴是反的，所以可能他的距离值是正/负，但算法与正常相反，结果要相减/相加")]
	public bool needAddDistanceLimit;

	public float clampX;

	public float clampY;

	public float clampZ;

	internal AudioType openAuido = AudioType._12008_打开抽屉音效;

	internal AudioType closeAudio = AudioType._12009_关闭抽屉音效;

	private void Start()
	{
		if (distanceLimit > 0f)
		{
			isPositive = true;
		}
		else
		{
			isPositive = false;
		}
		if (needAddDistanceLimit)
		{
			isPositive = true;
		}
		originPos = base.transform.position;
		if (isPositive)
		{
			endPosZ = base.transform.position.z + distanceLimit;
			endPosX = base.transform.position.x + distanceLimit;
		}
		else
		{
			if (moveDirection == MoveDirectionType.x)
			{
				if (base.transform.position.x > 0f)
				{
					endPosX = base.transform.position.x - distanceLimit;
				}
				else
				{
					endPosX = base.transform.position.x + distanceLimit;
				}
			}
			endPosZ = base.transform.position.z - distanceLimit;
		}
		if (hideGO != null)
		{
			hideGO.GetComponent<Collider>().enabled = false;
			hideGO.GetComponentInChildren<ArrowLookCamera>()?.Hide();
		}
	}

	private void Update()
	{
		if (inHand)
		{
			Pressed();
		}
		drawerPosZ = base.transform.position.z;
		drawerPosX = base.transform.position.x;
	}

	public override void PressDown()
	{
		base.PressDown();
		inHand = true;
		MonoBehaviour.print(moveDirection.ToString() + ">>>>>>>>>>>>>");
	}

	public override void PressUp()
	{
		inHand = false;
		handInfo.RemoveSelectedInHand();
	}

	public override void Pressed()
	{
		base.Pressed();
		PressedDrawer();
	}

	public virtual void PressedDrawer()
	{
		if (distanceLimit > 0f)
		{
			clampX = Mathf.Clamp(base.transform.position.x, originPos.x, originPos.x + distanceLimit);
			clampY = Mathf.Clamp(base.transform.position.y, originPos.y, originPos.y + distanceLimit);
			clampZ = Mathf.Clamp(base.transform.position.z, originPos.z, originPos.z + distanceLimit);
		}
		else if (distanceLimit < 0f)
		{
			clampX = Mathf.Clamp(base.transform.position.x, originPos.x + distanceLimit, originPos.x);
			clampY = Mathf.Clamp(base.transform.position.y, originPos.y + distanceLimit, originPos.y);
			clampZ = Mathf.Clamp(base.transform.position.z, originPos.z + distanceLimit, originPos.z);
		}
		base.transform.position = new Vector3((moveDirection == MoveDirectionType.x) ? clampX : base.transform.position.x, (moveDirection == MoveDirectionType.y) ? clampY : base.transform.position.y, (moveDirection == MoveDirectionType.z) ? clampZ : base.transform.position.z);
		switch (moveDirection)
		{
		case MoveDirectionType.x:
			if (Mathf.Approximately(drawerPosX, endPosX) && !open)
			{
				MonoSingleton<AudioManager>.Instance.Play(openAuido, base.transform.position, 20f);
				open = true;
				openDrawer.Invoke();
				if (hideGO != null)
				{
					hideGO.GetComponent<Collider>().enabled = true;
					hideGO.GetComponentInChildren<ArrowLookCamera>()?.Show();
					MonoBehaviour.print("显示三角");
					hideGO.transform.GetChild(0).gameObject.SetActive(value: true);
				}
				if (needPressUp)
				{
					base.PressUp();
				}
			}
			if (Mathf.Approximately(drawerPosX, originPos.x) && open)
			{
				MonoSingleton<AudioManager>.Instance.Play(closeAudio, base.transform.position, 20f);
				open = false;
			}
			break;
		case MoveDirectionType.y:
			if ((float)(int)base.transform.position.y >= (float)(int)originPos.y + distanceLimit && moveDirection == MoveDirectionType.y && !open)
			{
				MonoSingleton<AudioManager>.Instance.Play(AudioType._12008_打开抽屉音效, base.transform.position, 20f);
				open = true;
			}
			if (base.transform.position.y == originPos.y && moveDirection == MoveDirectionType.y && open)
			{
				MonoSingleton<AudioManager>.Instance.Play(AudioType._12009_关闭抽屉音效, base.transform.position, 20f);
				open = false;
			}
			break;
		case MoveDirectionType.z:
			if (Mathf.Approximately(drawerPosZ, endPosZ) && !open)
			{
				MonoSingleton<AudioManager>.Instance.Play(AudioType._12008_打开抽屉音效, base.transform.position, 20f);
				open = true;
				openDrawer.Invoke();
				if (hideGO != null)
				{
					hideGO.GetComponent<Collider>().enabled = true;
					hideGO.GetComponentInChildren<ArrowLookCamera>()?.Show();
					MonoBehaviour.print("显示三角");
					hideGO.transform.GetChild(0).gameObject.SetActive(value: true);
				}
				if (needPressUp)
				{
					base.PressUp();
				}
			}
			if (Mathf.Approximately(drawerPosZ, originPos.z) && open)
			{
				MonoSingleton<AudioManager>.Instance.Play(AudioType._12009_关闭抽屉音效, base.transform.position, 20f);
				open = false;
			}
			break;
		}
		if (needCancleCollider)
		{
			GetComponent<Collider>().isTrigger = true;
		}
	}
}
public class DoorInfo : RotationBase
{
	public DoorType doorType;

	public UnityEvent openDoor;

	public UnityEvent closeDoor;

	public bool isOpen;

	public bool canOpen = true;

	public bool canPlaySubtitle = true;

	public GameObject hideGO;

	public override void Init()
	{
		base.Init();
		angle2IntEvent.AddListener(GetAngle);
		if (hideGO != null)
		{
			hideGO.GetComponent<Collider>().enabled = false;
			hideGO.GetComponentInChildren<ArrowLookCamera>()?.Hide();
		}
	}

	public override void PressDown()
	{
		if (canOpen)
		{
			base.PressDown();
			UnityEngine.Debug.LogError(base.transform.GetChild(0).gameObject.activeSelf);
			if (doorType == DoorType.None)
			{
				AudioType._90001_拧动门把手的音效.Play(base.transform);
			}
			if (doorType == DoorType.铁门)
			{
				AudioType._90036_铁把手.Play(base.transform);
			}
		}
		if (!base.enabled && canPlaySubtitle)
		{
			MonoSingleton<SubtitleManager>.Instance.Play(1040);
			canPlaySubtitle = false;
			this.AttachTimer(MonoSingleton<SubtitleManager>.Instance.subtitleInfos[1040].audioClip.length, delegate
			{
				canPlaySubtitle = true;
			});
		}
	}

	public override void PressUp()
	{
		if (!canOpen)
		{
			return;
		}
		base.PressUp();
		if (doorType == DoorType.None)
		{
			AudioType._90002_松开门把手的音效.Play(base.transform);
		}
		if (doorType == DoorType.铁门)
		{
			AudioType._90033_开铁门.Play(base.transform, 5f);
		}
		if (Mathf.Abs(angle) >= 15f && !isOpen)
		{
			openDoor?.Invoke();
			OpenDoor();
			isOpen = true;
			if (hideGO != null)
			{
				hideGO.GetComponent<Collider>().enabled = true;
				GetComponentInChildren<ArrowLookCamera>()?.Show();
				hideGO.transform.GetChild(0).gameObject.SetActive(value: true);
			}
		}
		if (angle == 0f && isOpen)
		{
			closeDoor?.Invoke();
			CloseDoor();
			isOpen = false;
		}
	}

	private void GetAngle(int arg0)
	{
		angle = arg0;
	}

	public virtual void OpenDoor()
	{
		if (doorType == DoorType.None)
		{
			AudioType._1083_拉开走廊门.Play(base.transform, 5f);
		}
		if (doorType == DoorType.铁门)
		{
			AudioType._90033_开铁门.Play(base.transform, 5f);
		}
	}

	public virtual void CloseDoor()
	{
		if (doorType == DoorType.None)
		{
			AudioType._1083_拉开走廊门.Play(base.transform, 5f);
		}
		if (doorType == DoorType.铁门)
		{
			AudioType._90033_开铁门.Play(base.transform, 5f);
		}
	}
}
public class ThrowableInfo : MonoBehaviour
{
}
public class CheckItem : TouchBase
{
	public override void PressDown()
	{
		base.PressDown();
		GetComponentInChildren<ArrowLookCamera>()?.Hide();
		if (info.id != 0)
		{
			EventsCentral.Tips.Invoke(info.contentText);
		}
	}
}
public class CheckStaticItem : MJListen
{
	public ItemType itemType;

	public bool textShow;

	private void OnBecameVisible()
	{
	}

	private void OnBecameInvisible()
	{
	}

	public override void Init()
	{
		UnityEngine.Debug.LogError(base.name);
		base.Init();
		itemType = (ItemType)Tools.Name2Int(base.name);
		if (base.transform.childCount > 0)
		{
			base.transform.GetChild(0).gameObject.SetActive(value: false);
		}
	}

	public override void OnTrigger()
	{
		base.OnTrigger();
		ShowText();
	}

	public override void ExitTrigger()
	{
		base.ExitTrigger();
	}

	public virtual void ShowText()
	{
		base.transform.GetChild(0).gameObject.SetActive(value: true);
		textShow = true;
		MonoSingleton<AudioManager>.Instance.Play(AudioType._90005_提示音的音效, MonoSingleton<PlayerInfo>.Instance.GetEasyVRHeadPos());
	}
}
public class ClueItem : TouchBase
{
	public CluePlayerPrefsSave cluePlayerPrefsSave;

	public override void Init()
	{
		base.Init();
		if (GetComponent<CluePlayerPrefsSave>() != null)
		{
			cluePlayerPrefsSave = GetComponent<CluePlayerPrefsSave>();
		}
	}

	public override void PressDown()
	{
		base.PressDown();
		GetComponentInChildren<ArrowLookCamera>()?.Hide();
		if (cluePlayerPrefsSave != null)
		{
			cluePlayerPrefsSave.isHave = true;
			MonoSingleton<ClueItemList>.Instance.clueItemList.Add(info.id);
			MonoBehaviour.print("检查添加列表线索ID:" + info.id);
		}
	}

	public override void PressUp()
	{
		MonoSingleton<BackpackManager>.Instance.AddItem(info.id);
		AudioType._1002_打开或收入背包_所有.Play();
		if (info.id != 0)
		{
			EventsCentral.Tips.Invoke(UITextType._100017_获得.GetString() + ": " + info.itemName);
		}
		handInfo.DelectSelectedInHand();
		UnityEngine.Debug.Log("加入线索");
	}

	public void IsHave()
	{
		base.gameObject.SetActive(value: false);
		MonoBehaviour.print("存档开始隐藏线索:" + info.id);
	}
}
public class CupboardItem : MJListen
{
	public ItemType itemType;

	[SerializeField]
	private int num;

	[SerializeField]
	private bool timeStart;

	[SerializeField]
	private float CD;

	public static bool bookFinish;

	public TextMesh content;

	public bool isLook;

	public int i;

	public override void Init()
	{
		base.Init();
		try
		{
			itemType = (ItemType)Tools.Name2Int(base.name);
		}
		finally
		{
			itemType = ItemType.None;
			if (base.transform.childCount > 0)
			{
				content = base.transform.GetChild(0).GetComponent<TextMesh>();
			}
			content.gameObject.SetActive(value: false);
		}
	}

	public void Update()
	{
		if (timeStart)
		{
			CD -= Time.deltaTime;
		}
	}

	public override void OnTrigger()
	{
		base.OnTrigger();
		if (itemType == ItemType._130346_查看_幻室_书架)
		{
			num++;
			if (num == 1)
			{
				if (i == 0)
				{
					EventsCentral.Tips.Invoke(itemType.GetItemInfo().contentText);
					MonoSingleton<AudioManager>.Instance.Play(AudioType._90005_提示音的音效, MonoSingleton<PlayerInfo>.Instance.GetEasyVRHeadPos());
					i++;
				}
				MonoBehaviour.print("显示文字");
			}
			if (num >= 2 && CD <= 0f && !bookFinish)
			{
				if (i == 0)
				{
					EventsCentral.Tips.Invoke("书架上的书好像是以什么顺序排列着");
					MonoSingleton<AudioManager>.Instance.Play(AudioType._90005_提示音的音效, MonoSingleton<PlayerInfo>.Instance.GetEasyVRHeadPos());
					i++;
				}
				CD = 120f;
				timeStart = true;
			}
		}
		UnityEngine.Debug.Log(">>>" + itemType);
	}

	public override void StayTrigger()
	{
		base.StayTrigger();
		if (MonoSingleton<RayTrigger>.Instance.outGameobject == base.gameObject && itemType != ItemType._130346_查看_幻室_书架)
		{
			base.transform.GetChild(0).gameObject.SetActive(value: true);
			if (i == 0)
			{
				i++;
				MonoSingleton<AudioManager>.Instance.Play(AudioType._90005_提示音的音效, MonoSingleton<PlayerInfo>.Instance.GetEasyVRHeadPos());
				MonoBehaviour.print("显示文字");
			}
			isLook = true;
		}
	}

	public override void ExitTrigger()
	{
		base.ExitTrigger();
		if (base.transform.GetChild(0).gameObject != null)
		{
			base.transform.GetChild(0).gameObject.SetActive(value: false);
			isLook = false;
		}
		i = 0;
	}
}
[RequireComponent(typeof(Rigidbody))]
public class NormalItem : TouchBase
{
	public Martials martials;

	public AudioType takeAudioType = AudioType._1001_捡取非特定物品;

	public AudioType throwAudioType = AudioType._1001_捡取非特定物品;

	private Transform parent;

	public int value = 2;

	public override void Init()
	{
		parent = base.transform.parent;
		base.Init();
		if (martials == Martials.锅)
		{
			if (MonoSingleton<AudioManager>.Instance.拿锅 != null)
			{
				takeAudioType = MonoSingleton<AudioManager>.Instance.拿锅[UnityEngine.Random.Range(0, MonoSingleton<AudioManager>.Instance.拿锅.Count)];
			}
			if (MonoSingleton<AudioManager>.Instance.扔锅 != null)
			{
				throwAudioType = MonoSingleton<AudioManager>.Instance.扔锅[UnityEngine.Random.Range(0, MonoSingleton<AudioManager>.Instance.扔锅.Count)];
			}
		}
		if (martials == Martials.小瓷器)
		{
			_ = MonoSingleton<AudioManager>.Instance.拿小瓷器;
			if (MonoSingleton<AudioManager>.Instance.扔小瓷器 != null)
			{
				throwAudioType = MonoSingleton<AudioManager>.Instance.扔小瓷器[UnityEngine.Random.Range(0, MonoSingleton<AudioManager>.Instance.扔小瓷器.Count)];
			}
		}
		if (martials == Martials.书)
		{
			if (MonoSingleton<AudioManager>.Instance.拿书 != null)
			{
				takeAudioType = MonoSingleton<AudioManager>.Instance.拿书[UnityEngine.Random.Range(0, MonoSingleton<AudioManager>.Instance.拿书.Count)];
			}
			_ = MonoSingleton<AudioManager>.Instance.扔书;
		}
		if (martials == Martials.瓶子 && MonoSingleton<AudioManager>.Instance.拿瓶子 != null)
		{
			takeAudioType = MonoSingleton<AudioManager>.Instance.拿瓶子[UnityEngine.Random.Range(0, MonoSingleton<AudioManager>.Instance.拿瓶子.Count)];
		}
		if (martials == Martials.玩具)
		{
			_ = MonoSingleton<AudioManager>.Instance.拿玩具;
			if (MonoSingleton<AudioManager>.Instance.扔玩具 != null)
			{
				throwAudioType = MonoSingleton<AudioManager>.Instance.扔玩具[UnityEngine.Random.Range(0, MonoSingleton<AudioManager>.Instance.扔玩具.Count)];
			}
		}
		if (martials == Martials.调味品)
		{
			if (MonoSingleton<AudioManager>.Instance.拿调味品 != null)
			{
				takeAudioType = MonoSingleton<AudioManager>.Instance.拿调味品[UnityEngine.Random.Range(0, MonoSingleton<AudioManager>.Instance.拿调味品.Count)];
			}
			if (MonoSingleton<AudioManager>.Instance.扔调味品 != null)
			{
				throwAudioType = MonoSingleton<AudioManager>.Instance.扔调味品[UnityEngine.Random.Range(0, MonoSingleton<AudioManager>.Instance.扔调味品.Count)];
			}
		}
		if (martials == Martials.闹钟 && MonoSingleton<AudioManager>.Instance.闹钟掉落 != null)
		{
			throwAudioType = MonoSingleton<AudioManager>.Instance.扔调味品[UnityEngine.Random.Range(0, MonoSingleton<AudioManager>.Instance.闹钟掉落.Count)];
		}
	}

	public override void PlayTakeAudio()
	{
		takeAudioType.Play(base.transform);
	}

	public override void PressUp()
	{
		base.PressUp();
	}

	public void OnCollisionEnter(Collision collision)
	{
		if (collision.gameObject.CompareTag("Ground"))
		{
			throwAudioType.Play(base.transform, 10f + base.Rigibody.maxAngularVelocity * (float)value);
		}
	}
}
public enum Martials
{
	None,
	锅,
	书,
	纸张,
	磁带,
	玩具,
	重物,
	小瓷器,
	大瓷器,
	瓶子,
	Clock,
	Pack,
	Frame,
	调味品,
	闹钟
}
public class TaskItem : TouchBase
{
	public bool isHave;

	public TaskItemPlayerPrefs taskItemPlayerPrefs;

	private bool enablePressUp = true;

	public override void Init()
	{
		base.Init();
		if (GetComponent<TaskItemPlayerPrefs>() != null)
		{
			taskItemPlayerPrefs = GetComponent<TaskItemPlayerPrefs>();
		}
	}

	public override void PressDown()
	{
		base.PressDown();
		EventsCentral._拾取物品.InvokeSafe(info.id);
		GetComponentInChildren<ArrowLookCamera>()?.Hide();
		handInfo.OnGrabbing(this);
		if (taskItemPlayerPrefs != null)
		{
			taskItemPlayerPrefs.isHave = true;
			MonoSingleton<TaskItemList>.Instance.taskItemList.Add(info.id);
		}
	}

	public override void PressUp()
	{
		MonoSingleton<BackpackManager>.Instance.AddItem(this.GetItemType());
		AudioType._1002_打开或收入背包_所有.Play();
		handInfo.DelectSelectedInHand();
	}

	public void EnablePressUp(bool state)
	{
		enablePressUp = state;
	}

	public void IsHave()
	{
		base.gameObject.SetActive(value: false);
		MonoBehaviour.print("存档开始隐藏物品:" + base.gameObject.name);
	}
}
public class MessageWindow : MonoSingleton<MessageWindow>
{
	private Text tipsText;

	private void Start()
	{
		EventsCentral.Tips.AddListener(ShowMessage);
		tipsText = GetComponent<Text>();
		tipsText.enabled = false;
	}

	private void ShowMessage(string msg)
	{
		tipsText.enabled = true;
		tipsText.text = msg;
		this.AttachTimer(2f, delegate
		{
			tipsText.enabled = false;
		});
	}
}
public class BackpackTitleText : MonoBehaviour
{
	private Text titleText;

	private Image titleBG;

	private ItemType type;

	private void Start()
	{
		EventsCentral.UI.SelectedBackpackItemUI.AddListener(SetTitleText);
		titleText = GetComponentInChildren<Text>();
		titleBG = GetComponentInChildren<Image>();
		titleText.text = string.Empty;
		titleBG.enabled = false;
	}

	public void SetTitleText(string title)
	{
		if (title == "" || title == string.Empty)
		{
			titleBG.enabled = false;
		}
		else
		{
			titleBG.enabled = true;
		}
		titleText.text = title;
	}
}
public interface IUIEvent
{
	void OnShow();

	void OnEnter();

	void OnExit();

	void OnClick();
}
public class BadgeRotate : MonoBehaviour
{
	private void Update()
	{
		base.transform.Rotate(Vector3.forward * 3f);
	}
}
public class LoadSceneManager
{
	public static string TargetScene;

	public static void LoadSkip(string sceneName)
	{
		TargetScene = sceneName;
		SceneManager.LoadScene(TargetScene);
	}
}
public class SkipTargetScene : MonoBehaviour
{
	public string nextSceneid;

	private AsyncOperation async;

	public int toprogressValue;

	public int progressValue;

	private void Start()
	{
		Resources.UnloadUnusedAssets();
		GC.Collect();
		Application.backgroundLoadingPriority = UnityEngine.ThreadPriority.Low;
		nextSceneid = LoadSceneManager.TargetScene;
		if (async == null)
		{
			UnityEngine.Debug.Log("开始跳转场景");
			StartCoroutine(LoadSceneView());
		}
	}

	private void SkipScene()
	{
		_ = LoadSceneManager.TargetScene;
	}

	public IEnumerator LoadSceneView()
	{
		yield return new WaitForSeconds(0.1f);
		yield return new WaitForEndOfFrame();
		async = SceneManager.LoadSceneAsync(nextSceneid);
		async.allowSceneActivation = false;
		progressValue = 0;
		toprogressValue = 0;
		while (async.progress < 0.9f)
		{
			toprogressValue = (int)(async.progress * 100f);
			while (progressValue < toprogressValue)
			{
				progressValue++;
				yield return new WaitForEndOfFrame();
			}
		}
		toprogressValue = 100;
		while (progressValue < toprogressValue)
		{
			progressValue++;
			yield return new WaitForEndOfFrame();
		}
		yield return new WaitForEndOfFrame();
		async.allowSceneActivation = true;
	}
}
[DisallowMultipleComponent]
public class Outline : MonoBehaviour
{
	public enum Mode
	{
		OutlineAll,
		OutlineVisible,
		OutlineHidden,
		OutlineAndSilhouette,
		SilhouetteOnly
	}

	[Serializable]
	private class ListVector3
	{
		public List<Vector3> data;
	}

	private static HashSet<Mesh> registeredMeshes = new HashSet<Mesh>();

	[SerializeField]
	private Mode outlineMode;

	[SerializeField]
	private Color outlineColor = Color.white;

	[SerializeField]
	[Range(0f, 10f)]
	private float outlineWidth = 2f;

	[Header("Optional")]
	[SerializeField]
	[Tooltip("Precompute enabled: Per-vertex calculations are performed in the editor and serialized with the object. Precompute disabled: Per-vertex calculations are performed at runtime in Awake(). This may cause a pause for large meshes.")]
	private bool precomputeOutline;

	[SerializeField]
	[HideInInspector]
	private List<Mesh> bakeKeys = new List<Mesh>();

	[SerializeField]
	[HideInInspector]
	private List<ListVector3> bakeValues = new List<ListVector3>();

	private Renderer[] renderers;

	private Material outlineMaskMaterial;

	private Material outlineFillMaterial;

	private bool needsUpdate;

	public Mode OutlineMode
	{
		get
		{
			return outlineMode;
		}
		set
		{
			outlineMode = value;
			needsUpdate = true;
		}
	}

	public Color OutlineColor
	{
		get
		{
			return outlineColor;
		}
		set
		{
			outlineColor = value;
			needsUpdate = true;
		}
	}

	public float OutlineWidth
	{
		get
		{
			return outlineWidth;
		}
		set
		{
			outlineWidth = value;
			needsUpdate = true;
		}
	}

	private void Awake()
	{
		renderers = GetComponentsInChildren<Renderer>();
		outlineMaskMaterial = UnityEngine.Object.Instantiate(Resources.Load<Material>("Materials/OutlineMask"));
		outlineFillMaterial = UnityEngine.Object.Instantiate(Resources.Load<Material>("Materials/OutlineFill"));
		outlineMaskMaterial.name = "OutlineMask (Instance)";
		outlineFillMaterial.name = "OutlineFill (Instance)";
		LoadSmoothNormals();
		needsUpdate = true;
	}

	private void OnEnable()
	{
		Renderer[] array = renderers;
		foreach (Renderer obj in array)
		{
			List<Material> list = obj.sharedMaterials.ToList();
			list.Add(outlineMaskMaterial);
			list.Add(outlineFillMaterial);
			obj.materials = list.ToArray();
		}
	}

	private void OnValidate()
	{
		needsUpdate = true;
		if ((!precomputeOutline && bakeKeys.Count != 0) || bakeKeys.Count != bakeValues.Count)
		{
			bakeKeys.Clear();
			bakeValues.Clear();
		}
		if (precomputeOutline && bakeKeys.Count == 0)
		{
			Bake();
		}
	}

	private void Update()
	{
		if (needsUpdate)
		{
			needsUpdate = false;
			UpdateMaterialProperties();
		}
	}

	private void OnDisable()
	{
		Renderer[] array = renderers;
		foreach (Renderer obj in array)
		{
			List<Material> list = obj.sharedMaterials.ToList();
			list.Remove(outlineMaskMaterial);
			list.Remove(outlineFillMaterial);
			obj.materials = list.ToArray();
		}
	}

	private void OnDestroy()
	{
		UnityEngine.Object.Destroy(outlineMaskMaterial);
		UnityEngine.Object.Destroy(outlineFillMaterial);
	}

	private void Bake()
	{
		HashSet<Mesh> hashSet = new HashSet<Mesh>();
		MeshFilter[] componentsInChildren = GetComponentsInChildren<MeshFilter>();
		foreach (MeshFilter meshFilter in componentsInChildren)
		{
			if (hashSet.Add(meshFilter.sharedMesh))
			{
				List<Vector3> data = SmoothNormals(meshFilter.sharedMesh);
				bakeKeys.Add(meshFilter.sharedMesh);
				bakeValues.Add(new ListVector3
				{
					data = data
				});
			}
		}
	}

	private void LoadSmoothNormals()
	{
		MeshFilter[] componentsInChildren = GetComponentsInChildren<MeshFilter>();
		foreach (MeshFilter meshFilter in componentsInChildren)
		{
			if (registeredMeshes.Add(meshFilter.sharedMesh))
			{
				int num = bakeKeys.IndexOf(meshFilter.sharedMesh);
				List<Vector3> uvs = ((num >= 0) ? bakeValues[num].data : SmoothNormals(meshFilter.sharedMesh));
				meshFilter.sharedMesh.SetUVs(3, uvs);
			}
		}
		SkinnedMeshRenderer[] componentsInChildren2 = GetComponentsInChildren<SkinnedMeshRenderer>();
		foreach (SkinnedMeshRenderer skinnedMeshRenderer in componentsInChildren2)
		{
			if (registeredMeshes.Add(skinnedMeshRenderer.sharedMesh))
			{
				skinnedMeshRenderer.sharedMesh.uv4 = new Vector2[skinnedMeshRenderer.sharedMesh.vertexCount];
			}
		}
	}

	private List<Vector3> SmoothNormals(Mesh mesh)
	{
		IEnumerable<IGrouping<Vector3, KeyValuePair<Vector3, int>>> enumerable = from pair in mesh.vertices.Select((Vector3 vertex, int index) => new KeyValuePair<Vector3, int>(vertex, index))
			group pair by pair.Key;
		List<Vector3> list = new List<Vector3>(mesh.normals);
		foreach (IGrouping<Vector3, KeyValuePair<Vector3, int>> item in enumerable)
		{
			if (item.Count() == 1)
			{
				continue;
			}
			Vector3 zero = Vector3.zero;
			foreach (KeyValuePair<Vector3, int> item2 in item)
			{
				zero += mesh.normals[item2.Value];
			}
			zero.Normalize();
			foreach (KeyValuePair<Vector3, int> item3 in item)
			{
				list[item3.Value] = zero;
			}
		}
		return list;
	}

	private void UpdateMaterialProperties()
	{
		outlineFillMaterial.SetColor("_OutlineColor", outlineColor);
		switch (outlineMode)
		{
		case Mode.OutlineAll:
			outlineMaskMaterial.SetFloat("_ZTest", 8f);
			outlineFillMaterial.SetFloat("_ZTest", 8f);
			outlineFillMaterial.SetFloat("_OutlineWidth", outlineWidth);
			break;
		case Mode.OutlineVisible:
			outlineMaskMaterial.SetFloat("_ZTest", 8f);
			outlineFillMaterial.SetFloat("_ZTest", 4f);
			outlineFillMaterial.SetFloat("_OutlineWidth", outlineWidth);
			break;
		case Mode.OutlineHidden:
			outlineMaskMaterial.SetFloat("_ZTest", 8f);
			outlineFillMaterial.SetFloat("_ZTest", 5f);
			outlineFillMaterial.SetFloat("_OutlineWidth", outlineWidth);
			break;
		case Mode.OutlineAndSilhouette:
			outlineMaskMaterial.SetFloat("_ZTest", 4f);
			outlineFillMaterial.SetFloat("_ZTest", 8f);
			outlineFillMaterial.SetFloat("_OutlineWidth", outlineWidth);
			break;
		case Mode.SilhouetteOnly:
			outlineMaskMaterial.SetFloat("_ZTest", 4f);
			outlineFillMaterial.SetFloat("_ZTest", 5f);
			outlineFillMaterial.SetFloat("_OutlineWidth", 0f);
			break;
		}
	}
}
public class CameraHigh : MonoBehaviour
{
	public float high01;

	public Transform floor;

	private void Start()
	{
	}

	private void Update()
	{
		base.transform.position = new Vector3(base.transform.position.x, floor.transform.position.y + high01, base.transform.position.z);
	}
}
public class PlayJaneAnimation : MonoBehaviour
{
	public Animator animator;

	public void Play(string animationName)
	{
		animator.Play(animationName);
		MonoBehaviour.print("run" + animationName);
	}

	public void SetTrigger(string name)
	{
		animator.SetTrigger(name);
		MonoBehaviour.print("run" + name);
	}
}
public class CameraMovement : MonoBehaviour
{
	public float sensitivity = 10f;

	private Camera cam;

	private GameObject heldObject;

	private Vector2 mouseMove;

	private float fov = 60f;

	private void Start()
	{
		cam = GetComponent<Camera>();
		Cursor.lockState = CursorLockMode.Locked;
		Cursor.visible = false;
	}

	private void Update()
	{
		if (!Input.GetButton("Fire1"))
		{
			base.transform.Rotate((0f - Input.GetAxis("Mouse Y")) * sensitivity, 0f, 0f);
			base.transform.parent.Rotate(0f, Input.GetAxis("Mouse X") * sensitivity, 0f);
		}
		bool flag = false;
		if (Physics.Raycast(base.transform.position, base.transform.forward, out var hitInfo, 4f) && Input.GetKeyDown(KeyCode.E) && heldObject == null && hitInfo.transform.tag == "Pickup")
		{
			heldObject = hitInfo.transform.gameObject;
			heldObject.GetComponent<Rigidbody>().isKinematic = true;
			flag = true;
		}
		if (heldObject != null && !flag && Input.GetKeyDown(KeyCode.E))
		{
			if (heldObject.GetComponent<Rigidbody>() != null)
			{
				heldObject.GetComponent<Rigidbody>().isKinematic = false;
			}
			Liquid component = heldObject.GetComponent<Liquid>();
			if (component != null)
			{
				ReflectionProbe component2 = component.GetComponent<ReflectionProbe>();
				if (component2 != null)
				{
					component2.mode = ReflectionProbeMode.Realtime;
					component2.refreshMode = ReflectionProbeRefreshMode.OnAwake;
					component2.timeSlicingMode = ReflectionProbeTimeSlicingMode.IndividualFaces;
				}
			}
			if (heldObject.transform.childCount > 0)
			{
				component = heldObject.transform.GetChild(0).GetComponent<Liquid>();
				if (component != null)
				{
					ReflectionProbe component3 = component.GetComponent<ReflectionProbe>();
					if (component3 != null)
					{
						component3.mode = ReflectionProbeMode.Realtime;
						component3.refreshMode = ReflectionProbeRefreshMode.OnAwake;
						component3.timeSlicingMode = ReflectionProbeTimeSlicingMode.IndividualFaces;
					}
				}
			}
			heldObject = null;
		}
		if (heldObject != null)
		{
			heldObject.transform.position = Vector3.Lerp(heldObject.transform.position, base.transform.position + base.transform.forward * 2f, Time.deltaTime * (Vector3.Distance(heldObject.transform.position, base.transform.position + base.transform.forward * 2f) + 1f) * 10f);
			if (Input.GetButton("Fire1"))
			{
				mouseMove = Vector2.Lerp(mouseMove, new Vector2(Input.GetAxis("Mouse X"), Input.GetAxis("Mouse Y")) * sensitivity, Time.deltaTime * 10f);
			}
			else
			{
				mouseMove = Vector2.Lerp(mouseMove, Vector2.zero, Time.deltaTime * 10f);
			}
			heldObject.transform.Rotate(base.transform.forward, 0f - mouseMove.x, Space.World);
			heldObject.transform.Rotate(base.transform.right, mouseMove.y, Space.World);
			Liquid component4 = heldObject.GetComponent<Liquid>();
			if (component4 != null)
			{
				ReflectionProbe component5 = component4.GetComponent<ReflectionProbe>();
				if (component5 != null)
				{
					component5.mode = ReflectionProbeMode.Realtime;
					component5.refreshMode = ReflectionProbeRefreshMode.EveryFrame;
					component5.timeSlicingMode = ReflectionProbeTimeSlicingMode.NoTimeSlicing;
				}
			}
			if (heldObject.transform.childCount > 0)
			{
				component4 = heldObject.transform.GetChild(0).GetComponent<Liquid>();
				if (component4 != null)
				{
					ReflectionProbe component6 = component4.GetComponent<ReflectionProbe>();
					if (component6 != null)
					{
						component6.mode = ReflectionProbeMode.Realtime;
						component6.refreshMode = ReflectionProbeRefreshMode.EveryFrame;
						component6.timeSlicingMode = ReflectionProbeTimeSlicingMode.NoTimeSlicing;
					}
				}
			}
			fov = 40f;
		}
		else
		{
			fov = 60f;
		}
		cam.fieldOfView = Mathf.Lerp(cam.fieldOfView, fov, Time.deltaTime * 5f);
	}
}
public class PlayerMovement : MonoBehaviour
{
	public float moveSpeed = 10f;

	private CharacterController cc;

	private void Start()
	{
		cc = GetComponent<CharacterController>();
	}

	private void Update()
	{
		cc.Move((base.transform.forward * Input.GetAxisRaw("Vertical") + base.transform.right * Input.GetAxisRaw("Horizontal")).normalized * moveSpeed * Time.deltaTime);
		if (!cc.isGrounded)
		{
			cc.Move(Vector3.up * Time.deltaTime * Physics.gravity.y);
		}
	}
}
public class Liquid : MonoBehaviour
{
	private Material material;

	private MeshRenderer meshRenderer;

	private Vector3 prevPos;

	private Quaternion prevRot;

	private Vector3 velocity;

	private Vector3 lerpedVelocity;

	private Vector3 prevVelocity;

	private Vector3 velocityVelocity;

	private Vector3 angVelocity;

	private Vector3 lerpedAngVelocity;

	private Vector3 wobble;

	private Vector3 wobbleAmt;

	private Vector3 lerpedWobble;

	private float wobbleOffset;

	private float foam;

	private float waveIntensity = 0.85f;

	private float volume;

	private float wavesMult = 1f;

	public Vector3 planePosition;

	public LayerMask probeMask = -1;

	public bool dynamicReflections;

	public bool debugMode;

	public Mesh volumeMesh;

	private void Start()
	{
		material = GetComponent<MeshRenderer>().material;
		meshRenderer = GetComponent<MeshRenderer>();
		if (volumeMesh == null)
		{
			volumeMesh = GetComponent<MeshFilter>().sharedMesh;
		}
		wobbleAmt = Vector3.zero;
		wobbleOffset = (float)Math.PI;
		prevPos = base.transform.position;
		prevRot = base.transform.rotation;
		wavesMult = 1f;
		volume = VolumeOfMesh(volumeMesh);
	}

	private void Update()
	{
		wobbleOffset = Time.time * 0.5f;
		float num = meshRenderer.bounds.max.y - meshRenderer.bounds.min.y;
		lerpedVelocity = Vector3.Lerp(lerpedVelocity, -velocityVelocity, Time.deltaTime * 20f);
		Vector3 vector = -Vector3.Lerp(lerpedVelocity, -Vector3.up, 0.5f);
		vector = Quaternion.Euler(0f, 180f, 0f) * vector;
		Quaternion quaternion = base.transform.rotation * Quaternion.Inverse(prevRot);
		prevRot = base.transform.rotation;
		quaternion.ToAngleAxis(out var angle, out var axis);
		if (angle > 180f)
		{
			angle -= 360f;
		}
		angVelocity = 0.015707962f * angle * axis.normalized;
		lerpedAngVelocity = Vector3.Lerp(lerpedAngVelocity, angVelocity, Time.deltaTime * 5f);
		lerpedAngVelocity = Vector3.Lerp(lerpedAngVelocity, -Vector3.up, 0.5f);
		lerpedAngVelocity = Quaternion.Euler(0f, 180f, 0f) * lerpedAngVelocity;
		wobbleAmt = Vector3.Lerp(wobbleAmt, Vector3.zero, Time.deltaTime * 0.8f);
		float num2 = Mathf.Pow(volume * 0.001f, 0.25f);
		wobble = new Vector3(wobbleAmt.x, 1f, wobbleAmt.z);
		lerpedWobble = Vector3.Lerp(lerpedWobble, wobble, Time.deltaTime * 5f);
		float value = Vector3.Angle(Vector3.up, vector);
		if (debugMode)
		{
			UnityEngine.Debug.DrawRay(base.transform.position + Vector3.up * 2f, Vector3.up, Color.green);
			UnityEngine.Debug.DrawRay(base.transform.position + Vector3.up * 2f, vector, Color.blue);
		}
		value = Mathf.Clamp(value, 0f, 90f) * 0f;
		Vector2 vector2 = (1f - value) * new Vector2(Mathf.Sin((Time.time + wobbleOffset) / num2), Mathf.Sin(Time.time / num2));
		wobble.x *= vector2.x;
		wobble.z *= vector2.y;
		wobble.x += vector.x * 0.25f;
		wobble.z += vector.z * 0.25f;
		Vector3 center = meshRenderer.bounds.center;
		Plane plane = new Plane(wobble.normalized, center + new Vector3(planePosition.x, num * planePosition.y, planePosition.z));
		Vector4 value2 = new Vector4(plane.normal.x, plane.normal.y, plane.normal.z, plane.distance);
		foam = Mathf.Lerp(foam, velocityVelocity.sqrMagnitude, Time.deltaTime * 0.5f);
		foam = Mathf.Clamp(foam, 0f, 1f);
		material.SetVector("_Plane", value2);
		material.SetVector("_PlanePos", planePosition);
		material.SetFloat("_BoundsL", meshRenderer.bounds.min.y);
		material.SetFloat("_BoundsH", meshRenderer.bounds.max.y);
		material.SetFloat("_BoundsX", meshRenderer.bounds.max.x - meshRenderer.bounds.min.x);
		material.SetFloat("_BoundsZ", meshRenderer.bounds.max.z - meshRenderer.bounds.min.z);
		wavesMult = Mathf.Lerp(wavesMult, Mathf.Pow(Mathf.Sqrt(wobbleAmt.magnitude * 1.25f) * 0.5f + 1f, 3.5f), Time.deltaTime * 2f);
		material.SetFloat("_WavesMult", wavesMult);
		material.SetFloat("_MeshScale", num2 * 3f);
		material.SetFloat("_Foam", foam);
		wobbleAmt.x += vector.x * 0.5f + velocity.y * 0.0005f;
		wobbleAmt.y += velocity.y * 0.02f;
		wobbleAmt.z += vector.z * 0.5f + velocity.y * 0.0005f;
		wobbleAmt.x += lerpedAngVelocity.z * 10f;
		wobbleAmt.z += lerpedAngVelocity.x * 10f;
		wobbleAmt.x = Mathf.Clamp(wobbleAmt.x, 0f - waveIntensity, waveIntensity);
		wobbleAmt.y = Mathf.Clamp(wobbleAmt.y, 0f - waveIntensity, waveIntensity);
		wobbleAmt.z = Mathf.Clamp(wobbleAmt.z, 0f - waveIntensity, waveIntensity);
	}

	private void FixedUpdate()
	{
		velocity = (base.transform.position - prevPos) * 50f;
		velocityVelocity = Vector3.Lerp(velocityVelocity, prevVelocity - velocity, Time.fixedDeltaTime);
		prevPos = base.transform.position;
		prevVelocity = velocity;
	}

	private Matrix4x4 GetRootTransformationMatrix(Transform trans)
	{
		Matrix4x4 result = Matrix4x4.TRS(trans.position, trans.rotation, trans.localScale);
		while (trans.parent != null)
		{
			trans = trans.parent;
			result.SetColumn(0, result.GetColumn(0) * trans.localScale.x);
			result.SetColumn(1, result.GetColumn(1) * trans.localScale.y);
			result.SetColumn(2, result.GetColumn(2) * trans.localScale.z);
		}
		return result;
	}

	private float SignedVolumeOfTriangle(Vector3 p1, Vector3 p2, Vector3 p3)
	{
		float num = p3.x * p2.y * p1.z;
		float num2 = p2.x * p3.y * p1.z;
		float num3 = p3.x * p1.y * p2.z;
		float num4 = p1.x * p3.y * p2.z;
		float num5 = p2.x * p1.y * p3.z;
		float num6 = p1.x * p2.y * p3.z;
		return 1f / 6f * (0f - num + num2 + num3 - num4 - num5 + num6);
	}

	private float VolumeOfMesh(Mesh mesh)
	{
		float num = 0f;
		Vector3[] vertices = mesh.vertices;
		Matrix4x4 rootTransformationMatrix = GetRootTransformationMatrix(base.transform);
		for (int i = 0; i < vertices.Length; i++)
		{
			vertices[i] = rootTransformationMatrix.MultiplyPoint3x4(vertices[i]);
		}
		int[] triangles = mesh.triangles;
		for (int j = 0; j < mesh.triangles.Length; j += 3)
		{
			Vector3 vector = vertices[triangles[j]];
			Vector3 vector2 = vertices[triangles[j + 1]];
			Vector3 vector3 = vertices[triangles[j + 2]];
			if (debugMode)
			{
				UnityEngine.Debug.DrawLine(vector, vector2);
				UnityEngine.Debug.DrawLine(vector2, vector3);
				UnityEngine.Debug.DrawLine(vector3, vector);
			}
			num += SignedVolumeOfTriangle(vector, vector2, vector3);
		}
		return Mathf.Abs(num);
	}

	public void RecalculateVolume()
	{
		Mesh sharedMesh = GetComponent<MeshFilter>().sharedMesh;
		volume = VolumeOfMesh(sharedMesh);
	}
}
public enum EyeState
{
	苏醒,
	睁眼,
	闭眼
}
public class Blink_Image : MonoBehaviour
{
	public EyeState eyeState;

	private Material material;

	private float X = 0.3f;

	private float Z;

	private float W;

	[SerializeField]
	[Range(0f, 0.5f)]
	public float Y = 0.5f;

	private Vector4 vector4;

	public int breathingNum;

	private void Start()
	{
		material = GetComponent<Image>().material;
		vector4.x = X;
		Y = Mathf.Clamp(Y, 0f, 0.5f);
	}

	private void Update()
	{
		vector4.y = Y;
		material.SetVector("_Param", vector4);
		if (GetComponentInParent<BlackCanva>().isBreathing)
		{
			Blink();
			if (breathingNum == 2)
			{
				Y = 0f;
				eyeState = EyeState.苏醒;
				GetComponentInParent<BlackCanva>().isBreathing = false;
			}
		}
		if (MonoSingleton<GlobalManager>.Instance.CurrentScene != MJFSM.SceneType.古宅 || !base.gameObject.activeSelf)
		{
			return;
		}
		foreach (Transform item in base.transform.parent)
		{
			UnityEngine.Debug.Log("Name: " + item.name + "   Active: " + item.gameObject.activeSelf);
			item.gameObject.SetActive(value: false);
		}
		base.gameObject.SetActive(value: false);
	}

	public void Blink()
	{
		if (eyeState == EyeState.苏醒)
		{
			Y = 0f;
			eyeState = EyeState.闭眼;
		}
		if (eyeState == EyeState.闭眼)
		{
			Y += 0.1f * Time.deltaTime;
			if (Y >= 0.3f)
			{
				eyeState = EyeState.睁眼;
			}
		}
		if (eyeState == EyeState.睁眼)
		{
			Y -= 0.1f * Time.deltaTime;
			if (Y <= 0f)
			{
				eyeState = EyeState.闭眼;
				breathingNum++;
			}
		}
	}
}
public class BodyCollider0 : MonoBehaviour
{
	private CapsuleCollider capCollider;

	private void Start()
	{
		capCollider = GetComponent<CapsuleCollider>();
	}

	private void FixedUpdate()
	{
		base.transform.position = MonoSingleton<PlayerInfo>.Instance.EasyVRHead.transform.position;
		capCollider.height = Vector3.Distance(MonoSingleton<PlayerInfo>.Instance.EasyVRHead.transform.position, MonoSingleton<PlayerInfo>.Instance.transform.position);
	}
}
public class EnterPassword : EasyVRInteractionBase
{
	public GameObject[] slot;

	private string password;

	public string inputPassword;

	public GameObject suitcase;

	private void Start()
	{
		suitcase = GameObject.Find("Suitcase_02");
		password = "370595";
	}

	public void CheckPass()
	{
		for (int i = 0; i < slot.Length; i++)
		{
			inputPassword += slot[i].GetComponent<NumberMove>().num;
		}
		if (inputPassword == password)
		{
			MonoBehaviour.print("解锁成功");
			MonoSingleton<GlobalManager>.Instance.CurrentUI = MJFSM.UIPanelType.None;
			suitcase.GetComponent<Animator>().SetBool("open", value: true);
		}
		else
		{
			MonoBehaviour.print("密码错误");
			inputPassword = null;
		}
	}

	public override void RayStay()
	{
		if (handInfo.handController.TriggerPressDown)
		{
			CheckPass();
		}
	}
}
public class HotellJoy : JoyMoveBase
{
	public GameObject[] passwordTurntable;

	public bool angleRight;

	private Vector3 startLocalPos;

	private void Start()
	{
		dis = 0.3f;
		moveDirection = MoveDirectionType.y;
		startPos = base.transform.position;
		startLocalPos = new Vector3(base.transform.localPosition.x, base.transform.localPosition.y + 0.1f, base.transform.localPosition.z);
		startRota = Quaternion.Euler(-90f, 0f, 0f);
		endPos = new Vector3(base.transform.position.x, base.transform.position.y - dis, base.transform.position.z);
	}

	private void Update()
	{
		if (base.transform.position.y - endPos.y <= 0.15f)
		{
			if (!pullPullRod)
			{
				pullPullRod = true;
			}
		}
		else if (pullPullRod)
		{
			pullPullRod = false;
		}
		PasswordTurntableRun();
	}

	public override void Pressed()
	{
		float x = -90f / (startPos.y - endPos.y) * (base.transform.position.y - endPos.y);
		base.transform.localRotation = Quaternion.Euler(x, 0f, 0f);
	}

	public override void PressUp()
	{
		if (base.transform.localPosition.y > -0.37f)
		{
			base.transform.position = startPos;
			float x = -90f / (startPos.y - endPos.y) * (base.transform.position.y - endPos.y);
			base.transform.localRotation = Quaternion.Euler(x, 0f, 0f);
		}
	}

	public void PasswordTurntableRun()
	{
		if (!pullPullRod)
		{
			return;
		}
		Vector3 euler = new Vector3(xValue, 90f, -90f);
		for (int i = 0; i < passwordTurntable.Length; i++)
		{
			passwordTurntable[i].transform.localRotation = Quaternion.Slerp(passwordTurntable[i].transform.localRotation, Quaternion.Euler(euler), Time.deltaTime);
			if (Quaternion.Angle(passwordTurntable[i].transform.localRotation, Quaternion.Euler(euler)) < 1f)
			{
				passwordTurntable[i].transform.localRotation = Quaternion.Euler(euler);
				base.transform.position = startPos;
				base.transform.localRotation = startRota;
				xValue += 90f;
				if (passwordTurntable[i].transform.localEulerAngles == new Vector3(270f, 0f, 0f))
				{
					angleRight = true;
				}
				else
				{
					angleRight = false;
				}
			}
		}
	}
}
public class PasswordTurntableID : MonoBehaviour
{
	public int code;

	private void Start()
	{
		code = 0;
	}

	private void Update()
	{
		if (code >= 4)
		{
			code = 0;
		}
	}
}
public class PasswordTurntableManager : MonoBehaviour
{
	public HotellJoy leftJoy;

	public HotellJoy rightJoy;

	public GameObject elevatorDoor;

	public bool elevatorDoorState;

	private void Start()
	{
		elevatorDoorState = false;
	}

	private void Update()
	{
		if (!elevatorDoorState && leftJoy.angleRight && rightJoy.angleRight)
		{
			elevatorDoor.GetComponent<Animator>().SetBool("open", value: true);
			elevatorDoorState = true;
		}
	}
}
public class BrokenBottle : MonoBehaviour
{
	public GameObject frag;

	public void OnTriggerEnter(Collider other)
	{
		if (other.CompareTag("Ground"))
		{
			GameObject fragObj = UnityEngine.Object.Instantiate(frag, base.transform.position, base.transform.rotation);
			AudioType._1208_杯子摔碎.Play();
			base.gameObject.SetActive(value: false);
			OtherFunction();
			this.AttachTimer(2f, delegate
			{
				fragObj.SetActive(value: false);
			});
		}
	}

	public virtual void OtherFunction()
	{
	}
}
public class JigsawPuzzle : EasyVRInteractionBase
{
	public int flag;

	public GameObject CodePaper;

	public override void PressDown()
	{
		base.transform.Rotate(new Vector3(base.transform.localRotation.x, base.transform.localRotation.y, base.transform.localRotation.z + 90f));
		flag++;
		Check();
	}

	private bool Getflag()
	{
		foreach (Transform item in base.transform.parent)
		{
			if (item.GetComponent<JigsawPuzzle>().flag % 4 != 0)
			{
				return false;
			}
		}
		return true;
	}

	private void Check()
	{
		if (Getflag())
		{
			CodePaper.GetComponent<Animator>().SetBool("play", value: true);
			MonoBehaviour.print("OK");
		}
	}
}
public class bottle : MonoBehaviour
{
	public GameObject Camera;

	private void Start()
	{
		Camera = MonoSingleton<PlayerInfo>.Instance.EasyVRHead.gameObject;
	}

	private void OnCollisionEnter(Collision collision)
	{
		if (collision.gameObject.name == "ground")
		{
			MonoBehaviour.print("接触地面，瓶子摔碎");
			MonoSingleton<AudioManager>.Instance.Play(AudioType._1206_电话铃声响);
			StartCoroutine("EnterIllusion");
		}
	}

	private IEnumerator EnterIllusion()
	{
		yield return new WaitForSeconds(1f);
		yield return new WaitForSeconds(1.5f);
	}
}
public class ground : MonoBehaviour
{
	public GameObject frag;

	private void OnTriggerEnter(Collider other)
	{
		if (other.CompareTag("Pickup"))
		{
			UnityEngine.Object.Instantiate(frag, other.transform.position, Quaternion.identity);
			AudioType._1208_杯子摔碎.Play();
			UnityEngine.Object.Destroy(other);
		}
	}
}
public class HotelRoomTrigger : MonoBehaviour
{
	public GameObject bedroomDoor;

	public GameObject womenGhost;

	private void OnTriggerEnter(Collider other)
	{
		if (other.gameObject.tag == "Player")
		{
			StartCoroutine(CloseDoor());
		}
	}

	private IEnumerator CloseDoor()
	{
		yield return new WaitForSeconds(1f);
		MonoBehaviour.print("123");
		bedroomDoor.GetComponent<Animator>().SetBool("close", value: true);
		yield return new WaitForSeconds(3f);
		UnityEngine.Object.Destroy(womenGhost);
	}
}
public class JoyMoveBase : MoveBase
{
	protected Vector3 startPos;

	protected Quaternion startRota;

	protected Vector3 endPos;

	public float dis;

	protected bool pullPullRod;

	protected float xValue;

	public Vector3 offset;

	public float Dire => moveDirection switch
	{
		MoveDirectionType.x => base.transform.position.x, 
		MoveDirectionType.y => base.transform.position.y, 
		MoveDirectionType.z => base.transform.position.z, 
		_ => 0f, 
	};

	public override void PressDown()
	{
		offset = handInfo.transform.position - base.transform.position;
	}

	public override void Pressed()
	{
	}
}
public class SJETest : MonoBehaviour
{
	public Transform pos;

	public GameObject SJE;

	public GameObject SJETrigger;

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.H))
		{
			MonoSingleton<PlayerInfo>.Instance.SetPos(pos);
			MonoSingleton<BackpackManager>.Instance.AddItem(ItemType._140003_物品_幻室_掰下来的树枝);
			SJE.SetActive(value: true);
			SJETrigger.SetActive(value: true);
		}
	}
}
public class ShengJiaen_Trigger : MonoBehaviour
{
	public Transform endPos;

	public VideoClip videoClip;

	private void OnTriggerEnter(Collider other)
	{
		if (other.CompareTag("Player"))
		{
			endPos = other.transform;
			EventManager.SendEvent(MJFSM.MJEvents._2_播放全景视频, new VideoInfo(videoClip, -90f, 0f, 180f), endPos.position);
			MonoBehaviour.print("触发");
		}
	}
}
public class StairsRay : MonoBehaviour
{
	private Ray ray;

	private RaycastHit hit;

	private Vector3 initialHeight;

	private float realTimeHeight;

	private float altitude;

	public GameObject player;

	private void Start()
	{
		ray = default(Ray);
		initialHeight = base.transform.position;
	}

	private void Update()
	{
		ray.direction = base.transform.forward;
		ray.origin = base.transform.position;
		if (Physics.Raycast(ray, out hit))
		{
			player.transform.position = new Vector3(player.transform.position.x, hit.transform.position.y + 0.4f, player.transform.position.z);
			_ = hit.transform.position.y;
			_ = player.transform.position.y;
			if (player.transform.position.y > hit.transform.position.y)
			{
				MonoBehaviour.print("1233123213");
			}
		}
	}
}
internal class MoveController
{
}
public class NumberMove : MonoBehaviour
{
	public Sprite[] numSprite;

	public Image[] numImage;

	public Transform moveObj;

	public Transform targetPos;

	public Transform upPos;

	public Transform middlePos;

	public Transform downPos;

	public bool ifMoving;

	public int num;

	private float moveSpeed = 3f;

	private void Start()
	{
		numImage[1].sprite = numSprite[num];
	}

	private void Update()
	{
		if (ifMoving)
		{
			moveObj.position = Vector3.Lerp(moveObj.position, targetPos.position, moveSpeed * Time.deltaTime);
			if (Vector3.Distance(moveObj.position, targetPos.position) < 0.05f)
			{
				moveObj.position = targetPos.position;
				ifMoving = false;
				numImage[1].sprite = numSprite[num];
				moveObj.position = middlePos.position;
			}
		}
	}
}
public class OpenPasswordTest : EasyVRInteractionBase
{
	private bool opened;

	private void Start()
	{
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.S))
		{
			MonoSingleton<GlobalManager>.Instance.CurrentUI = MJFSM.UIPanelType.手提箱密码锁;
			MonoBehaviour.print(base.name);
		}
	}

	public override void PressDown()
	{
		if (!opened)
		{
			MonoSingleton<GlobalManager>.Instance.CurrentUI = MJFSM.UIPanelType.手提箱密码锁;
			opened = true;
		}
	}
}
public class SuitcasePassword : MonoSingleton<SuitcasePassword>
{
	public GameObject[] textObjNows;

	public GameObject[] textObjNews;

	public Transform[] up;

	public Transform[] middle;

	public Transform[] down;

	public string password;

	private Text textNow;

	private Text textNew;

	private NumberMove moveNow;

	private NumberMove moveNew;

	private bool ifShowing;

	private int inputPassword;

	public int suitcasePasswod;

	public void Input(int num)
	{
		inputPassword = inputPassword * 10 + num;
		if (suitcasePasswod == inputPassword)
		{
			MonoBehaviour.print("解锁");
		}
	}
}
public class SuitcasePasswordDown : EasyVRInteractionBase
{
	public NumberMove numMove;

	public void PageDown()
	{
		if (!numMove.ifMoving)
		{
			numMove.num--;
			if (numMove.num < 0)
			{
				numMove.num = 9;
			}
		}
		numMove.targetPos = numMove.downPos;
		numMove.numImage[0].sprite = numMove.numSprite[numMove.num];
		numMove.ifMoving = true;
	}

	public override void RayStay()
	{
		if (handInfo.handController.TriggerPressDown)
		{
			PageDown();
		}
	}
}
public class SuitcasePasswordUP : EasyVRInteractionBase
{
	public NumberMove numMove;

	public void PageUp()
	{
		if (!numMove.ifMoving)
		{
			numMove.num++;
			if (numMove.num > 9)
			{
				numMove.num = 0;
			}
		}
		numMove.targetPos = numMove.upPos;
		numMove.numImage[numMove.numImage.Length - 1].sprite = numMove.numSprite[numMove.num];
		numMove.ifMoving = true;
	}

	public override void RayStay()
	{
		if (handInfo.handController.TriggerPressDown)
		{
			PageUp();
		}
	}
}
public class SoundRecorder : MonoBehaviour
{
	[Serializable]
	public class RecorderEvent : UnityEvent<ItemType>
	{
	}

	private SubtitleType subtitleType;

	public Animator animator;

	public static bool isPlayOver;

	private ItemType otherType;

	[SerializeField]
	private ItemType recordType;

	public RecorderEvent playStart;

	public RecorderEvent playOver;

	public GameObject redLight;

	public float time;

	public bool canPlay = true;

	private void Start()
	{
		animator = GetComponent<Animator>();
	}

	private void OnTriggerEnter(Collider other)
	{
		MonoBehaviour.print(other.name + ">>>>>>>>>>>>>>>");
		if (canPlay)
		{
			if (!other.CompareTag("Tape"))
			{
				return;
			}
			canPlay = false;
			time = 0f;
			recordType = other.GetComponent<Tape>().info.id;
			animator.SetBool("Up", value: false);
			animator.SetBool("Down", value: true);
			StartCoroutine(RecordPress());
			MonoSingleton<AudioManager>.Instance.Play(AudioType._1077_录音机按下播放开关, MonoSingleton<PlayerInfo>.Instance.GetEasyVRHeadPos());
			subtitleType = other.GetComponent<Tape>().subtitleType;
			if (subtitleType != 0)
			{
				MonoSingleton<SubtitleManager>.Instance.Play(subtitleType.GetHashCode());
				for (int i = subtitleType.GetHashCode(); MonoSingleton<SubtitleManager>.Instance.subtitleDict.ContainsKey(i); i++)
				{
					time += MonoSingleton<SubtitleManager>.Instance.subtitleDict[i].audioClip.length;
				}
				MonoSingleton<PlayerInfo>.Instance.SetSpeed(0f);
			}
			otherType = other.GetComponent<Tape>().clueType;
			MonoSingleton<BackpackManager>.Instance.RemoveItem(recordType);
			other.GetComponentInParent<EasyVRHandInfo>().DelectSelectedInHand();
			Invoke("RecordUp", time);
		}
		else if (MonoSingleton<GlobalManager>.Instance.language == LanguageType.中文)
		{
			EventsCentral.Tips.Invoke("录音机正在工作");
		}
		else if (MonoSingleton<GlobalManager>.Instance.language == LanguageType.English)
		{
			EventsCentral.Tips.Invoke("The recorder is working");
		}
		else if (MonoSingleton<GlobalManager>.Instance.language == LanguageType.西班牙语)
		{
			EventsCentral.Tips.Invoke("la grabadora está funcionando");
		}
		else if (MonoSingleton<GlobalManager>.Instance.language == LanguageType.意大利语)
		{
			EventsCentral.Tips.Invoke("il registratore funziona");
		}
		else if (MonoSingleton<GlobalManager>.Instance.language == LanguageType.德语)
		{
			EventsCentral.Tips.Invoke("Rekorder funktioniert");
		}
		else if (MonoSingleton<GlobalManager>.Instance.language == LanguageType.日语)
		{
			EventsCentral.Tips.Invoke("レコーダーが動作しています");
		}
		else if (MonoSingleton<GlobalManager>.Instance.language == LanguageType.韩语)
		{
			EventsCentral.Tips.Invoke("녹음기 근무 중");
		}
	}

	private IEnumerator RecordPress()
	{
		yield return new WaitForSeconds(0.2f);
		animator.SetBool("Down", value: false);
		animator.SetBool("Press", value: true);
		InvokePlayStart();
	}

	private void RecordUp()
	{
		animator.SetBool("Press", value: false);
		animator.SetBool("Up", value: true);
		MonoSingleton<AudioManager>.Instance.Play(AudioType._1077_录音机按下播放开关, MonoSingleton<PlayerInfo>.Instance.GetEasyVRHeadPos());
		MonoSingleton<PlayerInfo>.Instance.SetSpeed(1f);
		if (otherType != 0)
		{
			MonoSingleton<BackpackManager>.Instance.AddItem(otherType);
			MonoSingleton<ClueItemList>.Instance.clueItemList.Add(otherType);
			AudioType._1002_打开或收入背包_所有.Play();
			EventsCentral.Tips.Invoke(UITextType._100017_获得.GetString() + ": " + otherType.GetItemInfo().itemName);
			UnityEngine.Debug.Log("加入线索");
			canPlay = true;
		}
		InvokePlayOver();
	}

	public void InvokePlayOver()
	{
		playOver.Invoke(recordType);
	}

	public void InvokePlayStart()
	{
		playStart.Invoke(recordType);
	}

	private void Update()
	{
		if (GetComponent<Animator>().GetBool("Press"))
		{
			redLight.GetComponent<Animator>().SetTrigger("DontBlink");
		}
		else if (GetComponent<Animator>().GetBool("Up"))
		{
			redLight.GetComponent<Animator>().SetTrigger("Blink");
		}
	}
}
public class Tape : TaskItem
{
	public SubtitleType subtitleType;

	public ItemType clueType;
}
public class TapeTest : MonoBehaviour
{
	private void Start()
	{
	}
}
public class TestMoveTo : MonoBehaviour
{
}
public class test_CharactMove : MonoBehaviour
{
	private CharacterController characterController;

	private float playerSpeed = 2f;

	private Vector3 playerVelocity;

	private float gravityValue = -9.81f;

	private void Start()
	{
		characterController = GetComponent<CharacterController>();
	}

	private void Update()
	{
		Vector3 vector = new Vector3(Input.GetAxis("Horizontal"), 0f, Input.GetAxis("Vertical"));
		characterController.Move(vector * Time.deltaTime * playerSpeed);
		if (vector != Vector3.zero)
		{
			base.gameObject.transform.forward = vector;
		}
		playerVelocity.y += gravityValue * Time.deltaTime;
		characterController.Move(playerVelocity * Time.deltaTime);
	}
}
public class test_JoyMove : MoveBase
{
	private Vector3 startPos;

	private Vector3 endPos;

	public float dire;

	private bool pullPullRod;

	public GameObject[] passwordTurntable;

	private float xValue;

	public Vector3 offset;

	public float Dire => moveDirection switch
	{
		MoveDirectionType.x => base.transform.position.x, 
		MoveDirectionType.y => base.transform.position.y, 
		MoveDirectionType.z => base.transform.position.z, 
		_ => 0f, 
	};

	private void Start()
	{
		startPos = base.transform.position;
		endPos = new Vector3(base.transform.position.x, base.transform.position.y - 0.3f, base.transform.position.z);
	}

	private void Update()
	{
		float x = -90f / (startPos.y - endPos.y) * (base.transform.position.y - endPos.y);
		UnityEngine.Debug.Log(base.transform.position.y - endPos.y + ">>>>>dis");
		base.transform.localRotation = Quaternion.Euler(x, 0f, 0f);
		if (base.transform.position.y - endPos.y <= 0.15f)
		{
			UnityEngine.Debug.Log("转动轮盘");
			if (!pullPullRod)
			{
				pullPullRod = true;
			}
		}
		else if (pullPullRod)
		{
			pullPullRod = false;
		}
		if (!pullPullRod)
		{
			return;
		}
		UnityEngine.Debug.Log("开始转动");
		Vector3 euler = new Vector3(xValue, 90f, -90f);
		for (int i = 0; i < passwordTurntable.Length; i++)
		{
			passwordTurntable[i].transform.localRotation = Quaternion.Slerp(passwordTurntable[i].transform.localRotation, Quaternion.Euler(euler), Time.deltaTime);
			if (Quaternion.Angle(passwordTurntable[i].transform.localRotation, Quaternion.Euler(euler)) < 1f)
			{
				passwordTurntable[i].transform.localRotation = Quaternion.Euler(euler);
				base.transform.position = startPos;
				xValue += 90f;
			}
		}
	}

	public override void PressDown()
	{
		offset = handInfo.handController.transform.position - base.transform.position;
		if (handInfo.handController.name == "Right")
		{
			handInfo.handController.transform.Find("right control03").gameObject.SetActive(value: false);
		}
		else
		{
			handInfo.handController.transform.Find("left control03").gameObject.SetActive(value: false);
		}
	}

	public override void PressUp()
	{
		if (handInfo.handController.name == "Right")
		{
			handInfo.handController.transform.Find("right control03").gameObject.SetActive(value: true);
		}
		else
		{
			handInfo.handController.transform.Find("left control03").gameObject.SetActive(value: true);
		}
	}

	public override void Pressed()
	{
	}
}
public class test_OilLamp : MonoBehaviour
{
	private void Start()
	{
	}

	private void FixedUpdate()
	{
		base.transform.rotation = Quaternion.Euler(base.transform.parent.rotation.x * -1f, base.transform.rotation.y, base.transform.rotation.z);
	}
}
public class LightRange : MonoBehaviour
{
	public Collider[] objects;

	private float range;

	private void Start()
	{
		range = GetComponent<Light>().range;
		objects = Physics.OverlapSphere(base.transform.position, range);
	}

	private void Update()
	{
		if (Input.GetKeyUp(KeyCode.M))
		{
			Collider[] array = objects;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].gameObject.SetActive(value: true);
			}
		}
		if (Input.GetKeyUp(KeyCode.N))
		{
			Collider[] array = objects;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].gameObject.SetActive(value: false);
			}
		}
	}
}
public class AnimatorPlayerInfo : MonoBehaviour
{
	public UnityEvent PlayStart;

	public UnityEvent PlayEnd;

	private Animator animator;

	private void Start()
	{
		animator = GetComponent<Animator>();
	}

	public void AnimStart()
	{
		PlayStart?.Invoke();
	}

	public void AnimEnd()
	{
		PlayEnd?.Invoke();
	}

	public void PlayAnim(string name = "")
	{
		animator.enabled = true;
		if (!string.IsNullOrEmpty(name))
		{
			animator.Play(name);
		}
		AnimStart();
		UnityEngine.Debug.Log(animator.GetCurrentAnimatorStateInfo(0).length);
		this.AttachTimer(animator.GetCurrentAnimatorStateInfo(0).length, AnimEnd);
	}
}
public class AudioPlayerInfo : MonoBehaviour
{
}
public class MJButton : MonoBehaviour
{
	private string str = "index_dist_end";

	public float openValue = 0.2f;

	[Tooltip("是否回弹")]
	public bool springback = true;

	[SerializeField]
	private Vector3 origin;

	private float offset;

	public AudioClip clip;

	private bool played;

	public GameObject blueLight;

	private Transform hand;

	public static bool canOpen;

	private void Start()
	{
		origin = base.transform.localPosition;
	}

	private void Update()
	{
	}

	private void OnTriggerEnter(Collider other)
	{
		UnityEngine.Debug.Log(other.name);
		if (other.name == str)
		{
			hand = other.transform;
			offset = (base.transform.InverseTransformDirection(other.transform.localPosition) - base.transform.localPosition).y;
		}
	}

	private void OnTriggerStay(Collider other)
	{
		if (!(other.name == str))
		{
			return;
		}
		base.transform.position = other.transform.position;
		base.transform.localPosition = new Vector3(origin.x, Mathf.Clamp(base.transform.localPosition.y + offset, 0f, 0.9f), origin.z);
		if (base.transform.localPosition.y != 0.9f || played)
		{
			return;
		}
		AudioSource.PlayClipAtPoint(clip, base.transform.position);
		if (canOpen)
		{
			EventManager.SendEvent("PasswordPad", base.name.SuffixToInt(1));
			blueLight.GetComponent<MeshRenderer>().material.EnableKeyword("_EMISSION");
			this.AttachTimer(0.2f, delegate
			{
				blueLight.GetComponent<MeshRenderer>().material.DisableKeyword("_EMISSION");
			});
		}
		played = true;
	}

	private void OnTriggerExit(Collider other)
	{
		if (!(other.name == str))
		{
			return;
		}
		origin = Vector3.zero;
		if (springback)
		{
			base.transform.DOLocalMoveY(0f, 0.3f).OnComplete(delegate
			{
				played = false;
			});
		}
	}
}
[RequireComponent(typeof(BoxCollider))]
public class MJButtonRange : MonoBehaviour
{
	private void Start()
	{
		if (!GetComponent<Collider>().isTrigger)
		{
			UnityEngine.Debug.LogError("ButtonRange 碰撞需要设置成触发器");
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.name == "Grab_Hand_1")
		{
			other.GetComponentInParent<EasyVRHandInfo>().PostureType = HandPostureType.指向;
		}
	}

	private void OnTriggerExit(Collider other)
	{
		if (other.name == "Grab_Hand_1")
		{
			other.GetComponentInParent<EasyVRHandInfo>().PostureType = HandPostureType.舒展;
		}
	}
}
public class PasswordPad : MonoBehaviour
{
	public int sum;

	public Transform door;

	public GameObject redLight;

	private Color color;

	private Material material;

	public ScriptPlayerPrefs scriptPlayerPrefs;

	private void Start()
	{
		scriptPlayerPrefs = GetComponent<ScriptPlayerPrefs>();
		EventManager.AddListener<int>("PasswordPad", InputPassword);
		material = redLight.GetComponent<MeshRenderer>().material;
		color = material.color;
	}

	private void InputPassword(int id)
	{
		sum = sum * 10 + id;
		if (sum == 1423)
		{
			AudioType._14007_打开通往走廊的密码门.Play();
			door.DOLocalRotate(Vector3.up * -270f, AudioType._14007_打开通往走廊的密码门.Length());
			material.color = Color.green;
			UnityEngine.Debug.Log(material.color);
			material.EnableKeyword("_EMISSION");
			material.SetColor("_EmissionColor", Color.green);
			this.AttachTimer(0.2f, delegate
			{
				material.DisableKeyword("_EMISSION");
				material.color = color;
			});
			scriptPlayerPrefs.isFinish = true;
			scriptPlayerPrefs.Save();
			AudioType._14035_四位密码输入正确.Play();
		}
		if (sum >= 1111 && sum != 1423)
		{
			material.color = Color.red;
			material.EnableKeyword("_EMISSION");
			material.SetColor("_EmissionColor", Color.red);
			this.AttachTimer(0.2f, delegate
			{
				material.DisableKeyword("_EMISSION");
				material.color = color;
			});
			sum = 0;
			AudioType._14034_四位密码输入错误.Play();
		}
	}

	public void Finish()
	{
		door.DOLocalRotate(Vector3.up * -270f, 0f);
		MonoBehaviour.print("开门");
	}
}
public class ColliderFollow : MonoBehaviour
{
	public GameObject headObj;

	public GameObject bodyObj;

	private CapsuleCollider headCol;

	private CapsuleCollider bodyCol;

	private void Start()
	{
		headCol = base.gameObject.AddComponent<CapsuleCollider>();
		bodyCol = base.gameObject.AddComponent<CapsuleCollider>();
		headCol.center = headObj.GetComponent<CapsuleCollider>().center;
		headCol.radius = headObj.GetComponent<CapsuleCollider>().radius;
		headCol.height = headObj.GetComponent<CapsuleCollider>().height;
		bodyCol.center = bodyObj.GetComponent<CapsuleCollider>().center;
		bodyCol.radius = bodyObj.GetComponent<CapsuleCollider>().radius;
		bodyCol.height = bodyObj.GetComponent<CapsuleCollider>().height;
	}

	private void FixedUpdate()
	{
		if ((0 + 1) % 10 == 0)
		{
			headCol.center = headObj.GetComponent<CapsuleCollider>().center;
			bodyCol.center = bodyObj.GetComponent<CapsuleCollider>().center;
		}
	}
}
public class DoorController : MJListen
{
	public bool doorIsOpen;

	public DoorInfo doorInfo;

	public override void Init()
	{
		doorInfo = GetComponent<DoorInfo>();
	}

	public override void OnTrigger()
	{
		base.OnTrigger();
		Close();
	}

	public void UnLock()
	{
		UnityEngine.Debug.Log(">>>UnLock");
		AudioType._12040_钥匙打开门锁的音效.Play();
		doorInfo.enabled = true;
	}

	public void Close()
	{
		AudioType._1012_古宅门自动关闭.Play(base.transform, 30f);
		doorInfo.SetAngle(0f, AudioType._1012_古宅门自动关闭.Length());
		GetComponent<BoxCollider>().isTrigger = false;
		doorInfo.canOpen = false;
		doorInfo.enabled = false;
		base.enabled = false;
		base.gameObject.layer = 0;
	}
}
public enum AudioType
{
	None = 0,
	_1001_捡取非特定物品 = 1001,
	_1002_打开或收入背包_所有 = 1002,
	_1003_拿起体检报告 = 1003,
	_1004_拉开抽屉 = 1004,
	_1005_拿起和母亲的合照 = 1005,
	_1006_打开兰登的房门 = 1006,
	_1007_打开橱柜门 = 1007,
	_1008_打开古宅的门 = 1008,
	_1009_走廊上滚出的皮球 = 1009,
	_1010_打不开的门 = 1010,
	_1011_密码铁门自动关闭 = 1011,
	_1012_古宅门自动关闭 = 1012,
	_1013_密码铁门关闭后放的音效 = 1013,
	_1014_走廊上触发女孩跟在我身后 = 1014,
	_1015_出厨房闪现出的娃娃 = 1015,
	_1016_老宅3的背景音效 = 1016,
	_1017_老宅的脚步声 = 1017,
	_1018_墙上的画突然变鬼脸 = 1018,
	_1019_打开凯瑟琳房的铁箱 = 1019,
	_1020_打开密码铁门 = 1020,
	_1021_打开厨房的橱柜 = 1021,
	_1022_按密码键的音效 = 1022,
	_1023_把熊放下的声音 = 1023,
	_1024_餐具自动运行 = 1024,
	_1025_刀叉掉落 = 1025,
	_1026_自动打开的抽屉 = 1026,
	_1027_被黑洞吸入 = 1027,
	_1028_恐怖玩偶探头看你 = 1028,
	_1029_放完书自动打开的抽屉 = 1029,
	_1030_拿到钥匙 = 1030,
	_1031_打开锅盖苍翼飞舞 = 1031,
	_1032_突然打开的4号门 = 1032,
	_1033_打火机 = 1033,
	_1034_女鬼出现进入画中 = 1034,
	_1035_虫子在画框上爬 = 1035,
	_1036_大黑手突然伸出吓玩家 = 1036,
	_1037_急速下降到底部 = 1037,
	_1038_地狱般的走廊 = 1038,
	_1039_撕海报 = 1039,
	_1040_玻璃窗爆裂 = 1040,
	_1041_玩偶的笑声 = 1041,
	_1042_窗户里出现的女鬼 = 1042,
	_1043_砸碎花瓶 = 1043,
	_1044_画框燃烧木框掉落 = 1044,
	_1045_女巫叹息 = 1045,
	_1046_女巫爆裂 = 1046,
	_1047_画框单独燃烧 = 1047,
	_1048_木框单独掉落 = 1048,
	_1049_女鬼走向壁画 = 1049,
	_1050_诡异悬浮 = 1050,
	_1051_老宅1的背景音效 = 1051,
	_1052_老宅2的背景音效 = 1052,
	_1053_大厅关门 = 1053,
	_1054_吓人的铁窗女鬼 = 1054,
	_1055_地板碎裂 = 1055,
	_1056_下降的风声 = 1056,
	_1057_天使蜡烛 = 1057,
	_1058_坠落到地上 = 1058,
	_1059_关上打火机 = 1059,
	_1060_点燃蜡烛 = 1060,
	_1061_打开打火机盖子 = 1061,
	_1062_滑动打火机滚轮 = 1062,
	_1063_掀开锅盖 = 1063,
	_1064_女鬼爆裂前的铺垫1 = 1064,
	_1065_女鬼爆裂前的铺垫2 = 1065,
	_1066_古宅拉动机关 = 1066,
	_1067_琳达和莉莉斯的笑声 = 1067,
	_1068_把书放进机关 = 1068,
	_1069_为什么我在这里 = 1069,
	_1070_生日歌 = 1070,
	_1071_该死的_又来了 = 1071,
	_1072_嘘_他来了 = 1072,
	_1073_和我一起玩吧 = 1073,
	_1074_留下来陪我吧 = 1074,
	_1075_艾丽莎女鬼说话 = 1075,
	_1076_吹灭蜡烛 = 1076,
	_1077_录音机按下播放开关 = 1077,
	_1078_录音机播放循环音效 = 1078,
	_1079_古宅3走廊尽头 = 1079,
	_1080_古宅2的哭声 = 1080,
	_1081_录音机播放结束音效 = 1081,
	_1082_开关手电筒 = 1082,
	_1083_拉开走廊门 = 1083,
	_1101_酒店脚步声 = 1101,
	_1102_打开变电箱锁 = 1102,
	_1103_打开变电箱门 = 1103,
	_1104_插入熔断 = 1104,
	_1105_电梯启动 = 1105,
	_1106_自动打开房卡盒 = 1106,
	_1107_打开台灯和房卡盒 = 1107,
	_1108_灯上的死尸摇晃 = 1108,
	_1109_拉动开关 = 1109,
	_1110_机关转动 = 1110,
	_1111_二楼的机关锁打开 = 1111,
	_1112_拿起便签 = 1112,
	_1113_石柱上的女人尖叫 = 1113,
	_1114_二楼的机关锁打开门自动打开 = 1114,
	_1115_刷电梯卡的滴声 = 1115,
	_1200_打开冰箱 = 1200,
	_1201_打开手提箱 = 1201,
	_1202_转动拼图方块 = 1202,
	_1203_倒入酒戒指落下 = 1203,
	_1204_得到戒指 = 1204,
	_1205_得到文件 = 1205,
	_1206_电话铃声响 = 1206,
	_1207_打开窗帘 = 1207,
	_1208_杯子摔碎 = 1208,
	_1209_酒店房间背景声效 = 1209,
	_1210_酒店背景音效 = 1210,
	_1211_看到房里像似妈妈的鬼 = 1211,
	_1212_打开窗帘开关 = 1212,
	_1213_快死的侍卫 = 1213,
	_90001_拧动门把手的音效 = 90001,
	_90002_松开门把手的音效 = 90002,
	_90003_打开手电筒的音效 = 90003,
	_90004_关闭手电筒的音效 = 90004,
	_90005_提示音的音效 = 90005,
	_90006_走在木头上的音效 = 90006,
	_90007_手持油灯行走 = 90007,
	_90008_吹灭油灯的音效 = 90008,
	_90009_点燃油灯的音效 = 90009,
	_90010_拿起磁带的音效 = 90010,
	_90011_上楼梯的音效 = 90011,
	_90012_打开录音机 = 90012,
	_90013_关闭录音机 = 90013,
	_90014_走在水泥地上的音效 = 90014,
	_90015_Landan说门被锁上了 = 90015,
	_90016_Landan幻室一Alyssa挂油灯的时候说不是我 = 90016,
	_90017_Landan说这是Lilith送我的13岁生日礼物 = 90017,
	_90018_Landan说书架上好像少了几本书 = 90018,
	_90019_Landan说书架上的书好像是按某种顺序排列的 = 90019,
	_90020_Landan说好像少了几个电容 = 90020,
	_90021_Landan说灯的方向有点奇怪 = 90021,
	_90022_Landan说我得找到这些材料 = 90022,
	_90023_Landan说卢克叔叔 = 90023,
	_90024_Landan说砍下自己的肉 = 90024,
	_90025_Landan说这刀为了Lilith = 90025,
	_90026_Landan说轮盘好像被人动过 = 90026,
	_90027_Landan说谁在那儿 = 90027,
	_90028_Landan说什么声音 = 90028,
	_90029_Landan说我能去找Lilith玩吗 = 90029,
	_90030_玩家走在地毯上 = 90030,
	_90031_玩家拎油灯走在水泥地 = 90031,
	_90032_玩家拎油灯走在地毯 = 90032,
	_90033_开铁门 = 90033,
	_90034_切场景 = 90034,
	_90035_Landan说妈妈 = 90035,
	_90036_铁把手 = 90036,
	_90037_拿起菜刀 = 90037,
	_90038_放下菜刀 = 90038,
	_20001_主菜单点击 = 20001,
	_20002_选中按钮 = 20002,
	_20003_主菜单点击2 = 20003,
	_20004_主菜单BGM = 20004,
	_12001_木马摇摆的音效 = 12001,
	_12002_敲门声后Lilith的笑声 = 12002,
	_12003_Lilith用手搓气球的音效 = 12003,
	_12004_衣柜门突然关闭的音效 = 12004,
	_12005_恐怖的敲门音效 = 12005,
	_12006_慢慢的开木门音效 = 12006,
	_12007_尝试开上锁的门的音效 = 12007,
	_12008_打开抽屉音效 = 12008,
	_12009_关闭抽屉音效 = 12009,
	_12010_玻璃碎掉 = 12010,
	_12011_锅子掉地上音效 = 12011,
	_12012_屠夫在楼上行走的音效 = 12012,
	_12013_摇晃有液体的玻璃瓶的音效 = 12013,
	_12014_飞机掉到地上的音效 = 12014,
	_12015_雷声1的音效 = 12015,
	_12016_雷声2的音效 = 12016,
	_12017_雷声3的音效 = 12017,
	_12018_下雨声1的音效 = 12018,
	_12019_拿起书1的音效 = 12019,
	_12020_拿起纸质物品1的音效 = 12020,
	_12021_拿起纸质物品2的音效 = 12021,
	_12022_拿起书2的音效 = 12022,
	_12023_拿起重物的音效 = 12023,
	_12024_拿起磁带的音效 = 12024,
	_12025_小瓷器摔碎的音效 = 12025,
	_12026_大瓷器摔碎的音效 = 12026,
	_12027_拿起锅1的音效 = 12027,
	_12028_拿起锅2的音效 = 12028,
	_12029_拿起锅3的音效 = 12029,
	_12030_拉开抽屉的第二个音效 = 12030,
	_12031_瓶子掉落碎掉的音效 = 12031,
	_12032_下雨声2的音效 = 12032,
	_12033_蚊虫飞的音效 = 12033,
	_12034_灯泡频闪1 = 12034,
	_12035_灯泡频闪2_摸油画 = 12035,
	_12036_三次雷电的声效 = 12036,
	_12037_时钟秒针 = 12037,
	_12038_Alyssa摸相框时的BGM = 12038,
	_12039_带时钟滴答声的BGM = 12039,
	_12040_钥匙打开门锁的音效 = 12040,
	_12041_Alyssa耳边说YouWillDie = 12041,
	_12042_抽屉里的鬼手音效 = 12042,
	_12043_拿纸质物品的音效 = 12043,
	_12044_开冰箱门的音效 = 12044,
	_12045_关冰箱门的音效 = 12045,
	_12046_童谣录音机板 = 12046,
	_12047_摇椅的音效 = 12047,
	_12048_上楼梯的音效 = 12048,
	_12049_带雨声的恐怖BGM = 12049,
	_12050_Alyssa咆哮 = 12050,
	_12051_电视雪花屏 = 12051,
	_12052_打开电视 = 12052,
	_12053_Alyssa摸相框新BGM = 12053,
	_12054_生日场景BGM = 12054,
	_12055_Lilith笑着跑开的音效 = 12055,
	_12056_柜子倒下的音效 = 12056,
	_12057_Lilith妈妈找你的电话的音效 = 12057,
	_12058_Lilith推开门跑开的音效 = 12058,
	_12059_LIlith跑向电话机的音效 = 12059,
	_12060_走廊恐怖BGM = 12060,
	_12061_Lilith哼唱童谣的音效 = 12061,
	_12062_调味品落地 = 12062,
	_12063_拿起调味品 = 12063,
	_12064_木马消失的音效 = 12064,
	_12065_闹钟掉落 = 12065,
	_12066_警官1他叫什么名字 = 12066,
	_12067_警官2Landan = 12067,
	_12068_警官1他的家属呢 = 12068,
	_12069_警官2Alyssa = 12069,
	_12070_警官1他们已经死了 = 12070,
	_12071_警官2嗯 = 12071,
	_12072_拿到琼恩照片 = 12072,
	_13001_鬼手配音 = 13001,
	_13002_玻璃龟裂声音 = 13002,
	_13003_玻璃爆炸声音 = 13003,
	_13004_狗撞门循环 = 13004,
	_13005_电话忙音嘟嘟嘟 = 13005,
	_13006_走下楼梯的声音 = 13006,
	_13007_撞书柜一 = 13007,
	_13008_撞书柜二 = 13008,
	_13009_升起火焰的声音 = 13009,
	_13010_留声机抽屉打开 = 13010,
	_13011_钥匙插入屠宰室大门 = 13011,
	_13012_摘取树叶的声音 = 13012,
	_13013_屠夫出现在铁门前 = 13013,
	_13014_风声 = 13014,
	_13015_掉书一 = 13015,
	_13016_掉书二 = 13016,
	_13017_掉书三 = 13017,
	_13018_掉书四 = 13018,
	_13019_黑洞出现以及吸入东西的声音 = 13019,
	_13020_掉书五 = 13020,
	_13021_狗叫声 = 13021,
	_13022_火焰的声音 = 13022,
	_13023_Alyssa说这是她第一次旅行 = 13023,
	_13024_关书柜门 = 13024,
	_13025_合成狂化药剂的声音 = 13025,
	_13026_往食盆里倒药剂的声音 = 13026,
	_13027_狗叫_撞书柜_消失 = 13027,
	_13028_留声机的声音 = 13028,
	_13029_掉书六 = 13029,
	_13030_屠夫砍尸体的声音 = 13030,
	_13031_屠夫的脚步声 = 13031,
	_13032_狗咬人 = 13032,
	_13033_机关的声音 = 13033,
	_13034_地板突然往下打开的声音 = 13034,
	_13035_屠夫关铁门的的声音 = 13035,
	_13036_Landan开场的喘息声 = 13036,
	_13037_拿下留声机把手 = 13037,
	_13038_屠夫切肉然后离开的音效 = 13038,
	_13039_屠宰室内滴水声 = 13039,
	_13040_屠宰室内的苍蝇声 = 13040,
	_13041_放入最后一个材料火焰变大光罩消失 = 13041,
	_13042_炼金盆火焰爆炸 = 13042,
	_13043_炼金盆火焰燃烧 = 13043,
	_13044_倒药剂 = 13044,
	_13045_关书柜门 = 13045,
	_13046_Lilith追皮球 = 13046,
	_13047_Alyssa说Lilith去把灯打开 = 13047,
	_13048_玩家坠落 = 13048,
	_13049_Alyssa说Lilith去把蜡烛点上 = 13049,
	_13050_拉动射灯把手 = 13050,
	_13051_顶灯转动 = 13051,
	_13052_插入电容 = 13052,
	_13053_通电后的音效 = 13053,
	_13054_油灯掉到地上 = 13054,
	_13055_倒狂化药剂 = 13055,
	_13056_把狂化药剂倒入瓶中然后收入背包 = 13056,
	_13057_Lilith被点燃蜡烛后说的话 = 13057,
	_13058_Alyssa被点燃蜡烛后说的话 = 13058,
	_13059_Landan被点燃蜡烛后说的话 = 13059,
	_13060_三支蜡烛点燃后John说的话 = 13060,
	_13061_Alyssa放下油灯 = 13061,
	_13062_留声机结束 = 13062,
	_13063_顶灯照到Alyssa = 13063,
	_13064_拉电闸的声音 = 13064,
	_13065_四盏顶灯关闭的声音 = 13065,
	_13066_第一扇玻璃爆开 = 13066,
	_13067_第二扇玻璃爆开 = 13067,
	_13068_第三扇玻璃爆开 = 13068,
	_13069_闪电 = 13069,
	_13070_Alyssa说我已经把他们送上火车了 = 13070,
	_13071_Alyssa说这都是你的错 = 13071,
	_13072_电话铃加接电话 = 13072,
	_13073_Alyssa开客厅门 = 13073,
	_13074_解锁客厅门 = 13074,
	_13075_留声机 = 13075,
	_13076_尸体掉落 = 13076,
	_13077_Alyssa在地板上走带着油灯 = 13077,
	_13078_Alyssa放油灯 = 13078,
	_13079_Alyssa不带油灯走路 = 13079,
	_13080_Alyssa说这也是她的最后一次旅行 = 13080,
	_13081_Alyssa说这都是因为你 = 13081,
	_13082_玩家说我需要去找到电容 = 13082,
	_13083_玩家说我需要去调整射灯位置 = 13083,
	_13084_Alyssa说我的油灯呢 = 13084,
	_13085_Alyssa说噢在这呢 = 13085,
	_13086_皮球 = 13086,
	_13087_Alyssa喊Landan = 13087,
	_13088_狗叫一 = 13088,
	_13089_狗叫二 = 13089,
	_13090_狗叫三 = 13090,
	_13091_小雷 = 13091,
	_13092_忙音 = 13092,
	_13093_恶狗咆哮 = 13093,
	_13094_从机关掉落至幻室3 = 13094,
	_13095_留声机开始 = 13095,
	_13096_磁带1琼恩凯瑟琳教主 = 13096,
	_13097_磁带2琼恩画像我已经送来了 = 13097,
	_13098_磁带3琼恩繁荣永驻 = 13098,
	_13099_磁带4琼恩在所不惜 = 13099,
	_13100_磁带5琼恩意外发生 = 13100,
	_13101_磁带6琼恩送Landan见你 = 13101,
	_13102_打电话Alyssa出现 = 13102,
	_13103_屠夫呼吸 = 13103,
	_13104_磁带7琼恩当上教皇 = 13104,
	_13105_磁带三敲门 = 13105,
	_13106_磁带三进来 = 13106,
	_13107_磁带三命案 = 13107,
	_13108_磁带三Alyssa = 13108,
	_13109_磁带三圣嘉恩 = 13109,
	_13110_磁带三化学实验 = 13110,
	_13111_点燃蜡烛 = 13111,
	_13112_磁带三Luke消失 = 13112,
	_13113_磁带三结案 = 13113,
	_13114_磁带三但是 = 13114,
	_13115_磁带三让他们收队 = 13115,
	_13116_磁带三好吧 = 13116,
	_13117_磁带三按电话 = 13117,
	_13118_磁带三接Catherine = 13118,
	_13119_圣嘉恩倒下 = 13119,
	_13120_玩偶倒下 = 13120,
	_14001_切肉的声音1 = 14001,
	_14002_切肉的声音2 = 14002,
	_14003_切肉的声音3 = 14003,
	_14004_秤盘上升下降的声音 = 14004,
	_14005_地牢1的门打开的声音 = 14005,
	_14006_监狱的阴风BGM = 14006,
	_14007_打开通往走廊的密码门 = 14007,
	_14008_转动第一轮盘 = 14008,
	_14009_转动第二轮盘 = 14009,
	_14010_转动第三轮盘 = 14010,
	_14011_转动第四轮盘 = 14011,
	_14012_鬼手破门音效 = 14012,
	_14013_打开车厢门 = 14013,
	_14014_关闭车厢门 = 14014,
	_14015_火车运行的声音 = 14015,
	_14016_火车鸣笛 = 14016,
	_14017_屠夫行走加砍头 = 14017,
	_14018_玩家倒地 = 14018,
	_14019_Alyssa给玩家穿衣服 = 14019,
	_14020_镜子晃动 = 14020,
	_14021_Landan尖叫 = 14021,
	_14022_Lilith在火车里的对话 = 14022,
	_14023_地牢转场到火车 = 14023,
	_14024_火车驶过身边 = 14024,
	_14025_Lilith在走廊哼唱童谣 = 14025,
	_14026_Lilith在卧室唱童谣 = 14026,
	_14027_拉动机关 = 14027,
	_14028_Landan结尾心跳声 = 14028,
	_14029_小汽车开过来的声音 = 14029,
	_14030_Alyssa看看新衣服好看吗 = 14030,
	_14031_火车车厢里的女人出现然后关门 = 14031,
	_14032_按按钮 = 14032,
	_14033_Lilith的木偶散落到地上 = 14033,
	_14034_四位密码输入错误 = 14034,
	_14035_四位密码输入正确 = 14035,
	_14036_鬼手抓Lilith火焰扑脸 = 14036,
	_14037_兰登手中的油灯掉落 = 14037,
	_14038_火车里的火 = 14038,
	_14039_屠夫插头加穿衣服 = 14039,
	_14040_鬼手抓Lilith然后缩回门里 = 14040,
	_14041_Landan被屠夫砍头后脖子飙血 = 14041,
	_14042_Catherine叫Landan出去 = 14042,
	_14043_John问Lilith = 14043,
	_14044_电椅电女人 = 14044,
	_14045_电椅开关失效 = 14045,
	_14046_火车车厢变灯 = 14046,
	_14047_打开水龙头 = 14047,
	_14048_关闭水龙头 = 14048,
	_14049_水流声 = 14049,
	_14050_灯照到女囚 = 14050,
	_14051_Lilith说Landan救我 = 14051,
	_14052_Lilith看到大手后的惊呼 = 14052,
	_14053_鬼手的声音 = 14053,
	_14054_女囚哭声 = 14054,
	_14055_女囚尖叫声 = 14055,
	_14056_Lilith童谣一 = 14056,
	_14057_Lilith童谣二 = 14057,
	_14058_Lilith童谣三 = 14058,
	_14059_Lilith童谣四 = 14059,
	_14060_Lilith童谣五 = 14060,
	_14061_Lilith童谣六 = 14061,
	_14062_抽屉1 = 14062,
	_14063_抽屉2 = 14063,
	_14064_抽屉3 = 14064,
	_14065_抽屉4 = 14065,
	_14066_抽屉5 = 14066,
	_14067_抽屉6 = 14067,
	_14068_抽屉7 = 14068,
	_14069_女囚头顶的摇摆灯 = 14069,
	_14070_女囚抓监狱的栏杆 = 14070,
	_14071_女囚喘气 = 14071,
	_14072_女囚尖叫声 = 14072,
	_14073_琼恩今年圣女人选 = 14073,
	_14074_磁带四不能对我 = 14074,
	_14075_磁带四怎么带走 = 14075,
	_14076_磁带四被迫的 = 14076,
	_14077_磁带四怎么带走 = 14077,
	_14078_磁带四琼恩的命令 = 14078,
	_14079_手下说抓住莉莉丝了 = 14079,
	_14080_最后的全景视频的音频 = 14080,
	_14081_办公室背景音乐 = 14081,
	_14082_办公室吊灯 = 14082,
	_14083_玩偶 = 14083,
	_15001_警探一他叫什么 = 15001,
	_15002_警探二兰登 = 15002,
	_15003_警探一兰登那他的家人呢 = 15003,
	_15004_警探二阿里萨 = 15004,
	_15005_警探一不是几年前死了吗 = 15005,
	_15006_警探二嗯 = 15006,
	_15007_警探一还有救吗 = 15007,
	_15008_陈大师尽力 = 15008,
	_15009_警探一安排离开 = 15009,
	_15010_陈大师感谢 = 15010,
	_16011_老人将军 = 16011
}
public enum ItemType
{
	None = 0,
	_110000_物品_新手教学_榔头 = 110000,
	_110001_物品_新手教学_录音带 = 110001,
	_130021_物品_幻室__圣嘉恩秘闻Ⅲ_ = 130021,
	_130022_物品_幻室__圣嘉恩秘闻Ⅴ_ = 130022,
	_130023_物品_幻室__圣嘉恩秘闻Ⅶ_ = 130023,
	_130024_物品_幻室__嘉达尔的宝藏Ⅰ_ = 130024,
	_131025_物品_幻室_一把细长的钥匙 = 131025,
	_130346_查看_幻室_书架 = 130346,
	_130244_查看_幻室_1号门 = 130244,
	_130003_物品_幻室_陈旧的钥匙 = 130003,
	_130238_查看_幻室_家庭合照 = 130238,
	_130047_物品_幻室_录音带Ⅰ = 130047,
	_132351_查看_幻室_阿丽莎一家三口的照片 = 132351,
	_132302_查看_幻室_莉莉丝和兰登的合照 = 132302,
	_132352_查看_幻室_凯瑟琳的画像 = 132352,
	_132353_查看_幻室_卢克和莉莉丝的合照 = 132353,
	_132354_查看_幻室_信 = 132354,
	_132355_查看_幻室_卢克的奖状 = 132355,
	_130240_查看_幻室_凯瑟琳和兰登的合照 = 130240,
	_140001_查看_幻室_凯瑟琳的画 = 140001,
	_140002_物品_幻室_蝙蝠的干尸 = 140002,
	_140003_物品_幻室_掰下来的树枝 = 140003,
	_140004_物品_幻室_神秘的金属 = 140004,
	_140005_物品_幻室_试剂 = 140005,
	_131026_物品_幻室_打火机 = 131026,
	_140006_物品_幻室_狂化药剂 = 140006,
	_140007_物品_幻室_炼金配方表 = 140007,
	_140008_物品_幻室_摇杆 = 140008,
	_130049_物品_幻室_录音带Ⅲ = 130049,
	_140010_物品_幻室_铁门的大钥匙 = 140010,
	_140012_物品_幻室_录音带Ⅳ = 140012,
	_152201_交互_幻室_菜刀 = 152201,
	_152202_交互_幻室_尸体的左大腿 = 152202,
	_152203_交互_幻室_尸体的左小腿 = 152203,
	_152204_交互_幻室_尸体的左腿 = 152204,
	_152205_交互_幻室_尸体的右大腿 = 152205,
	_152206_交互_幻室_尸体的右小腿 = 152206,
	_152207_交互_幻室_尸体的右腿 = 152207,
	_152208_交互_幻室_尸体的左大臂 = 152208,
	_152209_交互_幻室_尸体的左小臂 = 152209,
	_152210_交互_幻室_尸体的左臂 = 152210,
	_152211_交互_幻室_尸体的右大臂 = 152211,
	_152212_交互_幻室_尸体的右小臂 = 152212,
	_152213_交互_幻室_尸体的右臂 = 152213,
	_130048_物品_幻室_录音带Ⅱ = 130048,
	_152020_物品_幻室_空的药剂瓶 = 152020,
	_152021_物品_幻室_红色的电容 = 152021,
	_152022_物品_幻室_绿色的电容 = 152022,
	_152023_物品_幻室_蓝色的电容 = 152023,
	_110101_线索_新手教学_模糊的照片 = 110101,
	_130100_线索_幻室__圣女传说_ = 130100,
	_130101_线索_幻室_一张画 = 130101,
	_130102_线索_幻室_破旧的生日贺卡 = 130102,
	_130103_线索_幻室_致凯瑟琳的信 = 130103,
	_130104_线索_幻室_录音带Ⅰ = 130104,
	_130105_线索_幻室__圣嘉恩秘闻_下_ = 130105,
	_130106_线索_幻室__凤凰城_ = 130106,
	_130107_线索_幻室__圣嘉恩海事_ = 130107,
	_130108_线索_幻室_致凯瑟琳的信 = 130108,
	_130109_线索_幻室_录音带Ⅱ = 130109,
	_130110_线索_幻室__圣嘉恩秘闻_上_ = 130110,
	_130111_线索_幻室_录音带Ⅲ = 130111,
	_130112_线索_幻室_嘉恩之戒的传说 = 130112,
	_130113_线索_幻室_琼恩的相片 = 130113,
	_130114_线索_幻室_电视里的声音 = 130114,
	_130115_线索_幻室_变形金刚 = 130115,
	_130116_线索_幻室_虚假的神迹 = 130116,
	_130117_线索_幻室_一张旧报纸 = 130117,
	_140100_线索_幻室_密信 = 140100,
	_140101_线索_幻室_教皇的匕首 = 140101,
	_140102_线索_幻室__圣嘉恩的起源_ = 140102,
	_140103_线索_幻室_古旧的炼金笔记 = 140103,
	_140104_线索_幻室_被裁剪下来的报纸 = 140104,
	_140105_线索_幻室_信徒的笔记 = 140105,
	_140106_线索_幻室_主教的笔记 = 140106,
	_140107_线索_幻室_处刑人的手套 = 140107,
	_140108_线索_幻室_肮脏的送货单 = 140108,
	_140109_线索_幻室_圣嘉恩的面具 = 140109,
	_150100_线索_幻室_兰登和莉莉丝的车票 = 150100,
	_150101_线索_幻室_日记 = 150101,
	_150102_线索_幻室_破损的学生证 = 150102,
	_150103_线索_幻室_莉莉丝的出生证明 = 150103,
	_150104_线索_幻室_莉莉丝本人的照片 = 150104,
	_150105_线索_幻室_字迹潦草的笔记 = 150105,
	_150106_线索_幻室_乌鸦戒指 = 150106,
	_150107_线索_幻室_狂人的遗书 = 150107,
	_150108_线索_幻室_遗落的搜捕密令 = 150108,
	_150109_线索_幻室_兰登的奖状 = 150109,
	_150110_线索_幻室_录音带Ⅳ = 150110
}
public enum SubtitleType
{
	None = 0,
	_1001_古宅1_走廊 = 1001,
	_1002_古宅1_走廊开门后 = 1002,
	_1203_古宅1_四门小房间1 = 1203,
	_1204_古宅1_四门小房间2 = 1204,
	_1005_古宅2_女鬼出现 = 1005,
	_1006_古宅3_走廊 = 1006,
	_1007_古宅3_摸镜子 = 1007,
	_1208_古宅1_琳达的录音带1_1 = 1208,
	_1209_古宅1_琳达的录音带1_2 = 1209,
	_1210_古宅1_琳达的录音带1_3 = 1210,
	_1212_古宅2_琳达的录音带2_1 = 1212,
	_1213_古宅2_琳达的录音带2_2 = 1213,
	_1214_古宅2_琳达的录音带2_3 = 1214,
	_1216_古宅3_琳达的录音带3_1 = 1216,
	_1217_古宅3_琳达的录音带3_2 = 1217,
	_1218_古宅3_琳达的录音带3_3 = 1218,
	_1201_教学版录音带 = 1201,
	_1040_Landan_门被锁上了 = 1040,
	_1041_Landan_摸相框_不是我 = 1041,
	_1042_Landan_这是Lilith送我的13岁生日礼物 = 1042,
	_1043_Landan_书架上好像少了几本书 = 1043,
	_1044_Landan_书好像是按照某种顺序排列的 = 1044,
	_1045_Landan_好像少了几个电容 = 1045,
	_1046_Landan_灯的方向好像有些奇怪 = 1046,
	_1047_Landan_看来我得找齐上面这些材料了 = 1047,
	_1048_Landan_Luke叔叔 = 1048,
	_1049_Landan_砍肉 = 1049,
	_1050_Landan_这一刀是为了Lilith = 1050,
	_1051_Landan_圆盘的方向被打乱了 = 1051,
	_1052_Landan_谁在那儿 = 1052,
	_1053_Landan_什么声音 = 1053,
	_1220_古宅1_走廊开始1 = 1220,
	_1221_古宅1_走廊开始2 = 1221,
	_1003_幻室2_Lilith来帮妈妈挂画 = 1003,
	_1004_幻室2_Lilith去把顶灯打开 = 1004,
	_1301_幻室2_Alyssa打电话1 = 1301,
	_1302_幻室2_Alyssa打电话2 = 1302,
	_1303_幻室2_Alyssa打电话3 = 1303,
	_1304_幻室2_Alyssa打电话4 = 1304,
	_1305_幻室2_Alyssa打电话5 = 1305,
	_1010_幻室2_Alyssa孩子们点蜡烛 = 1010,
	_1011_幻室2_点燃Lilith蜡烛 = 1011,
	_1012_幻室2_点燃Landan蜡烛 = 1012,
	_1013_幻室2_点燃Alyssa蜡烛 = 1013,
	_1014_幻室2_三支蜡烛都点燃后 = 1014,
	_1401_幻室2_Alyssa我的油灯呢 = 1401,
	_1402_幻室2_Alyssa哦在这呢 = 1402,
	_1410_幻室2_磁带三一 = 1410,
	_1411_幻室2_磁带三二 = 1411,
	_1412_幻室2_磁带三三 = 1412,
	_1413_幻室2_磁带三四 = 1413,
	_1414_幻室2_磁带三五 = 1414,
	_1415_幻室2_磁带三六 = 1415,
	_1416_幻室2_磁带三七 = 1416,
	_1417_幻室2_磁带三八 = 1417,
	_1418_幻室2_磁带三九 = 1418,
	_1419_幻室2_磁带三十 = 1419,
	_1420_幻室2_磁带三十一 = 1420,
	_1421_幻室2_磁带三十二 = 1421,
	_1422_幻室2_磁带三十三 = 1422,
	_1501_幻室3_Lilith马上就要到站 = 1501,
	_1502_幻室3_Lilith倒吸冷气 = 1502,
	_1503_幻室3_LilithLandan救我 = 1503,
	_1504_火车车厢_John手下 = 1504,
	_1255_幻室3_John圣女人选 = 1255,
	_1256_幻室3_Catherine有事要谈 = 1256,
	_1257_Landan_我能去Luke叔叔家找Lilith玩吗 = 1257,
	_1258_幻室3_John莉莉丝 = 1258,
	_1601_幻室2_磁带琼恩凯瑟琳教主 = 1601,
	_1602_幻室2_磁带琼恩画像我给你送来了 = 1602,
	_1603_幻室2_磁带琼恩希望您永披 = 1603,
	_1604_幻室2_磁带琼恩在所不惜 = 1604,
	_1605_幻室2_磁带琼恩意外发生 = 1605,
	_1606_幻室2_磁带琼恩辅佐兰登 = 1606,
	_1607_幻室2_磁带琼恩当上教皇 = 1607,
	_1610_幻室3_Lilith童谣一 = 1610,
	_1611_幻室3_Lilith童谣二 = 1611,
	_1612_幻室3_Lilith童谣三 = 1612,
	_1613_幻室3_Lilith童谣四 = 1613,
	_1614_幻室3_Lilith童谣五 = 1614,
	_1615_幻室3_Lilith童谣六 = 1615,
	_1620_幻室3_磁带四一 = 1620,
	_1621_幻室3_磁带四二 = 1621,
	_1622_幻室3_磁带四三 = 1622,
	_1623_幻室3_磁带四四 = 1623,
	_1624_幻室3_磁带四五 = 1624,
	_9201_ICU_警探一 = 9201,
	_9202_ICU_警员一 = 9202,
	_9203_ICU_警探二 = 9203,
	_9204_ICU_警员二 = 9204,
	_9205_ICU_警探三 = 9205,
	_9206_ICU_警员三 = 9206,
	_9208_ICU_护士_他大出血了_需要手术 = 9208,
	_9209_ICU_兰登_我在哪儿_你们要干嘛 = 9209,
	_9210_ICU_兰登_妈妈 = 9210,
	_9211_ICU_护士_躺好_别乱动 = 9211,
	_1801_结尾彩蛋_警探一 = 1801,
	_1802_结尾彩蛋_陈师傅一 = 1802,
	_1803_结尾彩蛋_警探二 = 1803,
	_1804_结尾彩蛋_陈师傅二 = 1804,
	_1105_结尾彩蛋_路人 = 1105,
	_1106_Alyssa新衣服 = 1106
}
public enum UITextType
{
	None = 0,
	_100000_背包 = 100000,
	_100001_线索 = 100001,
	_100002_菜单 = 100002,
	_100003_设置 = 100003,
	_100004_音量 = 100004,
	_100005_转向方式 = 100005,
	_100006_摇杆 = 100006,
	_100007_自由 = 100007,
	_100008_语言 = 100008,
	_100009_简体中文 = 100009,
	_100010_英语 = 100010,
	_100011_教程 = 100011,
	_100012_关于 = 100012,
	_100013_开始游戏 = 100013,
	_100014_继续游戏 = 100014,
	_100015_设置 = 100015,
	_100016_退出游戏 = 100016,
	_100017_获得 = 100017,
	_100018_返回主菜单 = 100018,
	_100019_将会丢失保存点后的所有进度 = 100019,
	_100020_确认 = 100020,
	_100021_免责声明 = 100021,
	_100022_本游戏是基于虚拟现实为载体的恐怖游戏 = 100022,
	_100023_本人已仔细阅读并理解上述声明的全部内容 = 100023,
	_100024_警告 = 100024,
	_100025_取消 = 100025,
	_200001_我和琳达以前经常在一起玩 = 200001,
	_200002_凯瑟琳的画像 = 200002,
	_200003_上面好像少了几本书 = 200003,
	_200004_莉莉丝一家三口的照片 = 200004,
	_200005_这是我和莉莉丝的合照 = 200005,
	_200006_这是卢克叔叔和莉莉丝 = 200006,
	_200007_妈妈的画像 = 200007,
	_200008_圣主_维克托_I = 200008,
	_200009_圣主_亚历山大_II = 200009,
	_200010_圣主_利奥_IV = 200010,
	_200011_圣主_凯瑟琳_ = 200011,
	_300001_选项建 = 300001,
	_300002_视角转向 = 300002,
	_300003_拾取 = 300003,
	_300004_人物移动 = 300004
}
public enum LanguageType
{
	English,
	中文,
	西班牙语,
	意大利语,
	德语,
	日语,
	韩语,
	Length
}
public class UITextBinding : MonoBehaviour
{
	public UITextType textType;

	private void Start()
	{
		EventsCentral.System.语言切换完成.AddListener(OnEnable);
		EventManager.AddListener(MJFSM.Process._0004数据加载完成, OnEnable);
	}

	private void OnEnable()
	{
		if (MonoSingleton<UIManager>.Instance.UIDict.Count > 0)
		{
			if ((bool)GetComponent<Text>())
			{
				GetComponent<Text>().text = MonoSingleton<UIManager>.Instance.UIDict[textType].text;
			}
			if ((bool)GetComponent<TextMesh>())
			{
				GetComponent<TextMesh>().text = MonoSingleton<UIManager>.Instance.UIDict[textType].text;
			}
		}
	}

	private void OnDestroy()
	{
		EventsCentral.System.语言切换完成.RemoveListener(OnEnable);
	}
}
[Serializable]
public class UITextInfo
{
	public int id;

	public UITextType textType;

	public string text;
}
public class Lock : MonoBehaviour
{
	public bool openLock;

	private void Update()
	{
		if (openLock)
		{
			UnityEngine.Debug.Log("锁消失");
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		UnityEngine.Debug.Log(other.name);
		if (other.gameObject.GetComponent<TaskItem>() != null && other.gameObject.GetComponent<TaskItem>().GetItemType() == ItemType._130003_物品_幻室_陈旧的钥匙)
		{
			UnityEngine.Debug.Log("开锁成功");
			openLock = true;
		}
	}
}
public static class ExtensionDynamicObjBase
{
	public static ItemType GetItemType(this EasyVRInteractionBase dynamicObj)
	{
		if (int.TryParse(dynamicObj.name.Substring(0, 6), out var result))
		{
			return (ItemType)result;
		}
		UnityEngine.Debug.LogError(">" + dynamicObj.name + "  无法转换到ItemType,请检查命名是否正确!");
		return ItemType.None;
	}

	public static ItemType GetItemType(this string str)
	{
		if (int.TryParse(str.Substring(0, 6), out var result))
		{
			return (ItemType)result;
		}
		UnityEngine.Debug.LogError(">" + str + "  无法转换到ItemType,请检查命名是否正确!");
		return ItemType.None;
	}

	public static OperationType GetOperationType(this ItemType type)
	{
		return (OperationType)(type.GetHashCode() / 100 % 10);
	}

	public static bool AddToBackpack(this ItemType type)
	{
		return MonoSingleton<BackpackManager>.Instance.AddItem(type);
	}

	public static bool RemoveFromBackpack(this ItemType type)
	{
		return MonoSingleton<BackpackManager>.Instance.RemoveItem(type);
	}

	public static ItemInfo GetItemInfo(this ItemType type)
	{
		return MonoSingleton<BackpackManager>.Instance.GetItemInfo(type);
	}

	public static void Play(this AudioType type, float value = 10f)
	{
		MonoSingleton<AudioManager>.Instance.Play(type, MonoSingleton<PlayerInfo>.Instance.GetEasyVRHeadPos(), value);
	}

	public static void Play(this AudioType type, Transform trans, float value = 10f)
	{
		MonoSingleton<AudioManager>.Instance.Play(type, trans.position, value);
	}

	public static float Length(this AudioType type)
	{
		return MonoSingleton<AudioManager>.Instance.GetAudioLength(type.GetHashCode());
	}

	public static string GetString(this UITextType type)
	{
		return MonoSingleton<UIManager>.Instance.UIDict[type].text;
	}
}
public class MJEventListen : MonoBehaviour
{
	public string EventStr;

	public bool useSelfName = true;

	private void Start()
	{
		if (string.IsNullOrEmpty(EventStr))
		{
			EventStr = (useSelfName ? base.name : base.transform.parent.name);
		}
		EventManager.AddListener(EventStr, OnEventTrigger);
		Init();
		UnityEngine.Debug.Log(">>> " + EventStr);
	}

	public virtual void Init()
	{
	}

	public virtual void OnEventTrigger()
	{
		throw new NotImplementedException();
	}
}
public class MJGameObjectActiveListen : MJEventListen
{
	public override void Init()
	{
		base.Init();
		UnityEngine.Debug.Log(">>>  " + EventStr);
		base.gameObject.SetActive(value: false);
	}

	public override void OnEventTrigger()
	{
		base.OnEventTrigger();
		base.gameObject.SetActive(value: true);
	}
}
public class MJUnityEventTriggerBase : MonoBehaviour
{
	public bool once = true;

	public UnityEvent unityEvent;

	private bool canRun = true;

	private void Start()
	{
		Init();
	}

	public virtual void Init()
	{
	}

	private void OnTriggerEnter(Collider other)
	{
		UnityEngine.Debug.Log("Trigger0");
		if (other.CompareTag("Player") && canRun)
		{
			UnityEngine.Debug.Log("Trigger1");
			if (once)
			{
				canRun = false;
			}
			OnTrigger();
		}
	}

	public virtual void OnTrigger()
	{
		UnityEngine.Debug.Log("Listen");
		unityEvent.Invoke();
	}
}
public class MJUnityEventTriggerCanmove : MJUnityEventTriggerBase
{
	public float timer = -1f;

	public override void OnTrigger()
	{
		base.OnTrigger();
		MonoSingleton<PlayerInfo>.Instance.SetCanMove(state: false, timer);
	}
}
public class MJAnimatorListen : MJListen
{
	public override void OnTrigger()
	{
		base.OnTrigger();
		GetComponentInChildren<Animator>().enabled = true;
	}
}
public class MJAudioListen : MJListen
{
	public bool audioOpen;

	public bool animatorOpen;

	public bool activeOpen;

	public AudioSource audioSource;

	public Animator animator;

	public GameObject active;

	public AudioType audioType;

	public override void Init()
	{
		base.Init();
		if (audioOpen && audioSource == null && GetComponent<AudioSource>() != null)
		{
			audioSource = GetComponent<AudioSource>();
		}
		if (animatorOpen && animator == null && GetComponent<Animator>() != null)
		{
			animator = GetComponent<Animator>();
		}
	}

	public override void OnTrigger()
	{
		base.OnTrigger();
		if (audioType != 0)
		{
			audioType.Play(base.transform);
		}
		if (activeOpen)
		{
			active?.SetActive(value: true);
		}
		if (audioOpen)
		{
			audioSource?.Play();
		}
		if (animatorOpen)
		{
			animator.enabled = true;
		}
	}
}
public class MJGameObjectListen : MJListen
{
	public override void Init()
	{
		base.Init();
		base.gameObject.SetActive(value: false);
	}

	public override void OnTrigger()
	{
		base.OnTrigger();
		base.gameObject.SetActive(value: true);
	}
}
public class MJListen : MonoBehaviour
{
	public string _name;

	public bool isOnce = true;

	public bool useSelfName;

	private void Start()
	{
		UnityEngine.Debug.Log(base.name);
		if (string.IsNullOrEmpty(_name))
		{
			_name = (useSelfName ? base.name : base.transform.parent.name);
		}
		EventManager.AddListener(_name + "Enter", OnTrigger);
		EventManager.AddListener(_name + "Stay", StayTrigger);
		EventManager.AddListener(_name + "Exit", ExitTrigger);
		Init();
	}

	public virtual void Init()
	{
	}

	public virtual void OnTrigger()
	{
		UnityEngine.Debug.Log("监听到了进入");
		if (isOnce)
		{
			EventManager.RemoveListener(_name + "Enter", OnTrigger);
		}
	}

	public virtual void StayTrigger()
	{
		if (isOnce)
		{
			EventManager.RemoveListener(_name + "Stay", StayTrigger);
		}
	}

	public virtual void ExitTrigger()
	{
		if (isOnce)
		{
			EventManager.RemoveListener(_name + "Exit", ExitTrigger);
		}
	}

	public void OnDestroy()
	{
		EventManager.RemoveListener(_name + "Enter", OnTrigger);
		EventManager.RemoveListener(_name + "Exit", ExitTrigger);
		EventManager.RemoveListener(_name + "Stay", StayTrigger);
	}
}
public class MJManager : MonoSingleton<MJManager>
{
	public List<Transform> processTranList;

	private List<MJProcess> process = new List<MJProcess>();

	private void Start()
	{
	}
}
[Serializable]
public class MJProcess
{
	public string _name;

	public List<MJTrigger> trigger;

	public List<MJListen> listen;
}
public class MJTrigger : MonoBehaviour
{
	public string _name;

	public bool useSelfName;

	public static void OnTrigger(string _name)
	{
		EventManager.SendEvent(_name);
	}

	public static void ExitTrigger(string _name)
	{
		EventManager.SendEvent(_name);
	}

	private void Start()
	{
		if (string.IsNullOrEmpty(_name))
		{
			_name = (useSelfName ? base.name : base.transform.parent.name);
		}
		Init();
	}

	public virtual void Init()
	{
	}

	public virtual void OnTrigger()
	{
		EventManager.SendEvent(_name + "Enter");
	}

	public virtual void StayTrigger()
	{
		EventManager.SendEvent(_name + "Stay");
	}

	public virtual void ExitTrigger()
	{
		EventManager.SendEvent(_name + "Exit");
	}
}
public class SoundVolumeController : MonoBehaviour
{
	private AudioSource audioSource;

	private float originVolume;

	private void Start()
	{
		EventsCentral.System.音量调节.AddListener(SetSoundVolume);
		audioSource = GetComponent<AudioSource>();
		originVolume = audioSource.volume;
	}

	private void SetSoundVolume(float volume)
	{
		audioSource.volume = originVolume * volume;
	}
}
public class FantasyRoom1Test : MonoBehaviour
{
	private void Start()
	{
		TestManager.AddTest("传送到书籍", delegate
		{
			MonoSingleton<PlayerInfo>.Instance.SetPos(base.transform.GetChild(0));
		});
		TestManager.AddTest("Rotate 02", delegate
		{
			MonoSingleton<PlayerInfo>.Instance.SetPos(base.transform.GetChild(1));
		});
		TestManager.AddTest("Rotate 03", delegate
		{
			MonoSingleton<PlayerInfo>.Instance.SetPos(base.transform.GetChild(2));
		});
		TestManager.AddTest("添加出生证明", delegate
		{
			MonoSingleton<BackpackManager>.Instance.AddItem(ItemType._150103_线索_幻室_莉莉丝的出生证明);
		});
	}
}
public class MouseRay : MonoBehaviour
{
	public Transform dot;

	public Transform start;

	public GameObject rayLine;

	public Transform currentTarget;

	public Transform lastTarget;

	public float length = 4f;

	public LayerMask layer;

	private Ray ray;

	private RaycastHit hit;

	private EasyVRHandController handController;

	private void Start()
	{
	}

	private void Update()
	{
		ray.direction = base.transform.forward - base.transform.up * 0.25f;
		ray.origin = start.position;
		if (!Physics.Raycast(ray, out hit, length, layer))
		{
			return;
		}
		currentTarget = hit.transform;
		if (lastTarget == null || lastTarget != currentTarget)
		{
			if (lastTarget != null)
			{
				lastTarget.GetComponent<EasyVRInteractionBase>()?.SetHandInfo(null);
				lastTarget.GetComponent<EasyVRInteractionBase>()?.RayExit();
			}
			lastTarget = currentTarget;
			currentTarget.GetComponent<EasyVRInteractionBase>()?.RayEnter();
		}
		if (lastTarget == currentTarget)
		{
			lastTarget.GetComponent<EasyVRInteractionBase>()?.RayStay();
			if (handController.TriggerPressDown)
			{
				lastTarget.GetComponent<EasyVRInteractionBase>()?.PressDown();
			}
			if (handController.TriggerPressUp)
			{
				lastTarget.GetComponent<EasyVRInteractionBase>()?.PressUp();
			}
		}
	}
}
public class MJPosTrigger : MJTrigger
{
	public TagType tagType;

	public TriggerType triggerType = TriggerType.Enter;

	public override void Init()
	{
		Check();
	}

	public void Check()
	{
		if (GetComponent<Collider>() == null)
		{
			UnityEngine.Debug.LogError("需要添加碰撞:" + base.name);
		}
		if (!GetComponent<Collider>().isTrigger)
		{
			UnityEngine.Debug.LogError("需要勾选IsTrigger" + base.name);
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.CompareTag(tagType.ToString()))
		{
			OnTrigger();
		}
	}

	private void OnTriggerStay(Collider other)
	{
		if (other.CompareTag(tagType.ToString()) && triggerType == TriggerType.Stay)
		{
			StayTrigger();
		}
	}

	private void OnTriggerExit(Collider other)
	{
		if (other.CompareTag(tagType.ToString()))
		{
			ExitTrigger();
		}
	}
}
public class MJPosTriggerCanMove : MJPosTrigger
{
	public bool CanMove;

	[Tooltip("时间,-1是没有计时")]
	public float timer = -1f;

	public override void OnTrigger()
	{
		MonoSingleton<PlayerInfo>.Instance.SetCanMove(CanMove, timer);
		CanMove = true;
		base.OnTrigger();
	}
}
public class MJPosTriggerSubtitle : MJTrigger
{
	public TagType tagType;

	public TriggerType triggerType = TriggerType.Enter;

	public SubtitleType subtitleType;

	public bool Once = true;

	private int count;

	public override void Init()
	{
		Check();
	}

	public void Check()
	{
		if (GetComponent<Collider>() == null)
		{
			UnityEngine.Debug.LogError("需要添加碰撞:" + base.name);
		}
		if (!GetComponent<Collider>().isTrigger)
		{
			UnityEngine.Debug.LogError("需要勾选IsTrigger" + base.name);
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.CompareTag(tagType.ToString()) && triggerType == TriggerType.Enter && (!Once || count < 1))
		{
			UnityEngine.Debug.Log("Pos >> " + _name);
			MonoSingleton<SubtitleManager>.Instance.Play(subtitleType);
			count++;
		}
	}

	private void OnTriggerStay(Collider other)
	{
	}

	private void OnTriggerExit(Collider other)
	{
		if (other.CompareTag(tagType.ToString()) && triggerType == TriggerType.Exit && (!Once || count < 1))
		{
			MonoSingleton<SubtitleManager>.Instance.Play(subtitleType);
			count++;
		}
	}
}
public class ProcessTriggerBase : MonoBehaviour
{
	public TagType tagType;

	private void Start()
	{
		Check();
	}

	public void Check()
	{
		if (GetComponent<Collider>() == null)
		{
			UnityEngine.Debug.LogError("需要添加碰撞:" + base.name);
		}
		if (!GetComponent<Collider>().isTrigger)
		{
			UnityEngine.Debug.LogError("需要勾选IsTrigger" + base.name);
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		other.CompareTag(tagType.ToString());
	}

	private void OnTriggerStay(Collider other)
	{
	}

	private void OnTriggerExit(Collider other)
	{
		other.CompareTag(tagType.ToString());
	}
}
public class TriggerBase : MonoBehaviour
{
	public TagType tagType;

	private void Start()
	{
		Check();
	}

	public void Check()
	{
		if (GetComponent<Collider>() == null)
		{
			UnityEngine.Debug.LogError("需要添加碰撞:" + base.name);
		}
		if (!GetComponent<Collider>().isTrigger)
		{
			UnityEngine.Debug.LogError("需要勾选IsTrigger" + base.name);
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.CompareTag(tagType.ToString()))
		{
			EventsCentral.BoxTrigger.Invoke(base.name, TriggerType.Enter);
			UnityEngine.Debug.Log(">>>>>>" + base.name);
		}
	}

	private void OnTriggerStay(Collider other)
	{
	}

	private void OnTriggerExit(Collider other)
	{
		if (other.CompareTag(tagType.ToString()))
		{
			EventsCentral.BoxTrigger.Invoke(base.name, TriggerType.Exit);
		}
	}
}
public class TriggerListen : MonoBehaviour
{
	public bool onlyOne = true;

	public MJPosTrigger trigger;

	public TriggerType triggerType = TriggerType.Enter;

	public bool startCloseSelf;

	public bool endCloseSelf;

	private void Start()
	{
		EventsCentral.BoxTrigger.AddListener(PlayAnim);
		Init();
		base.gameObject.SetActive(!startCloseSelf);
	}

	public virtual void Init()
	{
	}

	private void PlayAnim(string arg1, TriggerType arg2)
	{
		UnityEngine.Debug.Log("----------start----------");
		UnityEngine.Debug.Log(base.name);
		UnityEngine.Debug.Log(trigger.name);
		UnityEngine.Debug.Log(arg1);
		UnityEngine.Debug.Log(arg2);
		UnityEngine.Debug.Log("-----------end---------");
		try
		{
			UnityEngine.Debug.Log(trigger.name);
			UnityEngine.Debug.Log(base.name);
		}
		catch (Exception ex)
		{
			UnityEngine.Debug.Log("catch " + base.name + "  " + ex.ToString());
		}
		if (arg1 == trigger.name && arg2 == triggerType && onlyOne)
		{
			OnTrigger();
			onlyOne = false;
		}
	}

	public virtual void OnTrigger()
	{
		base.gameObject.SetActive(value: true);
		GetComponent<Animator>().enabled = true;
		this.AttachTimer(GetComponent<Animator>().GetCurrentAnimatorStateInfo(0).length, delegate
		{
			base.gameObject.SetActive(!endCloseSelf);
		});
	}
}
public class LogoPanel : UIPanelBase
{
	public override void Init()
	{
		myType = MJFSM.UIPanelType.Logo;
		EventsCentral.UI._Invoke_开启界面 += new Action<MJFSM.UIPanelType>(ShowPanel);
	}
}
public class SettingUIPanel : UIPanelBase
{
	public override void Init()
	{
		base.gameObject.SetActive(value: false);
		EventsCentral.UI._Invoke_开启界面 += new Action<MJFSM.UIPanelType>(ShowPanel);
		Terminal.Shell.AddCommand("open.panelui", Show);
	}

	public override void Show()
	{
		base.Show();
		AudioType._1002_打开或收入背包_所有.Play(base.transform, 6f);
		Terminal.Shell.RunCommand("open.panelui " + MJFSM.UIPanelType.设置界面.GetHashCode());
	}

	public override void Hide()
	{
		base.Hide();
	}

	private void Show(CommandArg[] obj)
	{
		UnityEngine.Debug.Log(">>>>>>>>>Show");
		if (obj[0].Int == 9)
		{
			base.transform.GetChild(0).gameObject.SetActive(value: true);
		}
		else
		{
			base.transform.GetChild(0).gameObject.SetActive(value: false);
		}
	}
}
public class TestButton : UIButtonBase
{
	public override void OnClick()
	{
		EventManager.SendEvent("TestMode", base.name);
		base.OnClick();
	}
}
public class TestPanel : MonoBehaviour
{
	private void Start()
	{
		EventManager.AddListener<string>("TestMode", ButtonListener);
		base.gameObject.SetActive(value: false);
	}

	private void ButtonListener(string obj)
	{
		switch (obj)
		{
		default:
			_ = obj == "show";
			break;
		case "open":
			base.gameObject.SetActive(value: true);
			break;
		case "close":
			base.gameObject.SetActive(value: false);
			break;
		}
	}
}
public class UIButtonByCommand : UIButtonBase
{
	private Text text;

	public override void Init()
	{
		base.Init();
		text = GetComponentInChildren<Text>();
	}
}
public class Zombie : MonoBehaviour
{
	public Transform targetpos;

	private NavMeshAgent nav;

	private Animator anim;

	private int i;

	private void Start()
	{
		anim = GetComponent<Animator>();
		nav = GetComponent<NavMeshAgent>();
		anim.SetBool("walk", value: true);
		nav.SetDestination(targetpos.position);
	}

	private void Update()
	{
		i++;
		if (i % 10 == 0)
		{
			nav.SetDestination(targetpos.position);
		}
		if (Vector3.Distance(base.transform.position, targetpos.position) < 1f)
		{
			anim.SetBool("attack", value: true);
		}
		else
		{
			anim.SetBool("walk", value: true);
		}
	}
}
public class ddd : MonoBehaviour
{
	private void OnTriggerStay(Collider other)
	{
		UnityEngine.Debug.Log(other.name);
	}
}
public class SteamAchievement : MonoSingleton<SteamAchievement>
{
}
[DisallowMultipleComponent]
public class SteamManager : MonoBehaviour
{
	public static bool Initialized => false;
}
public class TestFeetPos : MonoBehaviour
{
	public GameObject feet;

	public GameObject body;

	public CharacterController characterController;

	private void Start()
	{
		feet = base.transform.GetChild(0).gameObject;
		body = base.transform.GetChild(1).gameObject;
		characterController = MonoSingleton<PlayerInfo>.Instance.GetComponent<CharacterController>();
	}

	private void Update()
	{
		feet.transform.localPosition = MonoSingleton<PlayerInfo>.Instance.feetLocalPositionGuess;
		body.transform.localPosition = characterController.center;
	}
}
public class 批量改门Layer和Tag : MonoBehaviour
{
	[Button(null, EButtonEnableMode.Always)]
	public void ChangeLayerTag()
	{
		RotationBase[] componentsInChildren = GetComponentsInChildren<RotationBase>();
		foreach (RotationBase rotationBase in componentsInChildren)
		{
			if (TryGetComponent<Rigidbody>(out var _))
			{
				UnityEngine.Debug.Log(rotationBase.name);
			}
		}
		MoveBase[] componentsInChildren2 = GetComponentsInChildren<MoveBase>();
		foreach (MoveBase moveBase in componentsInChildren2)
		{
			if (TryGetComponent<Rigidbody>(out var _))
			{
				UnityEngine.Debug.Log(moveBase.name);
			}
			UnityEngine.Debug.Log(moveBase.name);
		}
	}
}
public class 批量添加音量控制 : MonoBehaviour
{
	private SoundVolumeController tmp;

	private AudioSource tmp1;

	[Button(null, EButtonEnableMode.Always)]
	public void Add()
	{
		AudioSource[] componentsInChildren = GetComponentsInChildren<AudioSource>();
		foreach (AudioSource audioSource in componentsInChildren)
		{
			if (!audioSource.gameObject.GetComponent<SoundVolumeController>())
			{
				audioSource.gameObject.AddComponent<SoundVolumeController>();
				UnityEngine.Debug.Log(audioSource.name + "已添加");
			}
		}
	}
}
public class ChatController : MonoBehaviour
{
	public TMP_InputField TMP_ChatInput;

	public TMP_Text TMP_ChatOutput;

	public Scrollbar ChatScrollbar;

	private void OnEnable()
	{
		TMP_ChatInput.onSubmit.AddListener(AddToChatOutput);
	}

	private void OnDisable()
	{
		TMP_ChatInput.onSubmit.RemoveListener(AddToChatOutput);
	}

	private void AddToChatOutput(string newText)
	{
		TMP_ChatInput.text = string.Empty;
		DateTime now = DateTime.Now;
		TMP_Text tMP_ChatOutput = TMP_ChatOutput;
		tMP_ChatOutput.text = tMP_ChatOutput.text + "[<#FFFF80>" + now.Hour.ToString("d2") + ":" + now.Minute.ToString("d2") + ":" + now.Second.ToString("d2") + "</color>] " + newText + "\n";
		TMP_ChatInput.ActivateInputField();
		ChatScrollbar.value = 0f;
	}
}
public class DropdownSample : MonoBehaviour
{
	[SerializeField]
	private TextMeshProUGUI text;

	[SerializeField]
	private TMP_Dropdown dropdownWithoutPlaceholder;

	[SerializeField]
	private TMP_Dropdown dropdownWithPlaceholder;

	public void OnButtonClick()
	{
		text.text = ((dropdownWithPlaceholder.value > -1) ? ("Selected values:\n" + dropdownWithoutPlaceholder.value + " - " + dropdownWithPlaceholder.value) : "Error: Please make a selection");
	}
}
public class EnvMapAnimator : MonoBehaviour
{
	public Vector3 RotationSpeeds;

	private TMP_Text m_textMeshPro;

	private Material m_material;

	private void Awake()
	{
		m_textMeshPro = GetComponent<TMP_Text>();
		m_material = m_textMeshPro.fontSharedMaterial;
	}

	private IEnumerator Start()
	{
		Matrix4x4 matrix = default(Matrix4x4);
		while (true)
		{
			matrix.SetTRS(Vector3.zero, Quaternion.Euler(Time.time * RotationSpeeds.x, Time.time * RotationSpeeds.y, Time.time * RotationSpeeds.z), Vector3.one);
			m_material.SetMatrix("_EnvMatrix", matrix);
			yield return null;
		}
	}
}
public class Agreement : UIPanelBase
{
	public Toggle toggle;

	public bool once = true;

	public override void Init()
	{
		base.Init();
	}

	public override void Show()
	{
		base.transform.GetChild(0).gameObject.SetActive(value: true);
	}

	public override void Hide()
	{
		base.transform.GetChild(0).gameObject.SetActive(value: false);
		UnityEngine.Debug.Log("关闭");
	}
}
public class AgreementButton : UIButtonBase
{
	public Image checkmark;

	public Text label;

	public bool once = true;

	public override void Init()
	{
		base.Init();
	}

	public override void Normal()
	{
		label.color = new Color(0.6431373f, 0.6431373f, 0.6431373f, 1f);
	}

	public override void Hover()
	{
		label.color = Color.white;
	}

	public override void OnClick()
	{
		UnityEngine.Debug.Log("Click");
		if (once)
		{
			checkmark.color = Color.white;
			Invoke("Hide", 0.5f);
			once = false;
		}
	}

	private void Hide()
	{
		base.transform.parent.gameObject.SetActive(value: false);
	}
}
public class BackgroundUIPanel : MonoBehaviour
{
	private void Start()
	{
		EventsCentral.UI._Invoke_开启界面.AddListener(OpenUI);
		OpenUI(MJFSM.UIPanelType.None);
	}

	private void OpenUI(MJFSM.UIPanelType type)
	{
		if ((uint)(type - 3) <= 1u || type == MJFSM.UIPanelType.设置界面)
		{
			UnityEngine.Debug.Log("设置界面" + type);
			base.transform.GetChild(0).gameObject.SetActive(value: true);
		}
		else
		{
			UnityEngine.Debug.Log("other" + type);
			base.transform.GetChild(0).gameObject.SetActive(value: false);
		}
	}
}
public class BackpackItemButton : UIButtonBase
{
	public ItemInfo myInfo;

	public Image itemImage;

	public BackpackUIPanel backpackUIPanel;

	private Queue<EasyVRInteractionBase> easyVRInteractions = new Queue<EasyVRInteractionBase>();

	public override void Init()
	{
		base.Init();
		itemImage = base.transform.GetChild(0).GetComponent<Image>();
		backpackUIPanel = GetComponentInParent<BackpackUIPanel>();
		EventsCentral.Backpack._添加物品到背包.AddListener(delegate
		{
			OnRender();
		});
	}

	public override void OnRender()
	{
		Normal();
		myInfo = MonoSingleton<BackpackManager>.Instance.backpack[int.Parse(base.name)];
		if (myInfo == null || myInfo.id == ItemType.None || !myInfo.isHave)
		{
			itemImage.enabled = false;
			return;
		}
		itemImage.sprite = MonoSingleton<PoolManager>.Instance.GetItemSprite(myInfo.id);
		itemImage.enabled = true;
	}

	public override void Normal()
	{
		imageComponent.color = Color.clear;
		backpackUIPanel.SetTitle(string.Empty);
		Select(state: false);
	}

	public override void Hover()
	{
		imageComponent.color = Color.white;
		if (myInfo != null && myInfo.id != 0)
		{
			backpackUIPanel.SetTitle(myInfo.itemName);
			Select(state: true);
		}
	}

	public void Select(bool state)
	{
		if (state)
		{
			EventsCentral.RaySelected.Invoke(myInfo.id);
		}
		else
		{
			EventsCentral.RaySelected.Invoke(ItemType.None);
		}
	}

	public override void Selected()
	{
		OnClick();
	}

	public override void PressDown()
	{
		if (myInfo != null && myInfo.id != 0)
		{
			MonoSingleton<BackpackManager>.Instance.RemoveItem(myInfo.id);
			MonoSingleton<GlobalManager>.Instance.CurrentUI = MJFSM.UIPanelType.None;
		}
	}
}
public class BackpackTitle : MonoBehaviour
{
	private Text title;

	private Image image;

	private Color color;

	private void Awake()
	{
		title = GetComponentInChildren<Text>();
		image = GetComponent<Image>();
		color = image.color;
		EventsCentral.Backpack._悬停物品.AddListener(ChangeTitle);
	}

	private void OnEnable()
	{
		ChangeTitle("");
	}

	private void ChangeTitle(string obj)
	{
		title.text = obj;
		image.color = (string.IsNullOrEmpty(obj) ? Color.clear : color);
	}
}
public class BackpackUIPanel : UIPanelBase
{
	public GameObject titleObj;

	public Text title;

	public void SetTitle(string titleStr)
	{
		if (titleStr == "" || titleStr == string.Empty)
		{
			titleObj.SetActive(value: false);
			return;
		}
		titleObj.SetActive(value: true);
		title.text = titleStr;
	}

	public override void Show()
	{
		base.transform.GetChild(0).gameObject.SetActive(value: true);
		AudioType._1002_打开或收入背包_所有.Play(base.transform, 6f);
	}

	public override void Hide()
	{
		base.transform.GetChild(0).gameObject.SetActive(value: false);
		AudioType._1002_打开或收入背包_所有.Play(base.transform, 6f);
	}

	public override void Init()
	{
		myType = MJFSM.UIPanelType.背包;
		base.Init();
	}
}
public class ArrowUI : UIButtonBase
{
}
public class ClueContent : MonoBehaviour
{
	public Image clueImg;

	public Text content;

	private void Start()
	{
		clueImg = GetComponentInChildren<Image>();
		content = GetComponentInChildren<Text>();
	}

	private void SelectedClue(ItemType obj)
	{
		clueImg.sprite = MonoSingleton<PoolManager>.Instance.GetItemSprite(obj);
		content.text = MonoSingleton<BackpackManager>.Instance.ClueDict[obj].contentText;
	}
}
public class ClueItemInfoUI : UIButtonBase
{
	public ItemInfo itemInfo = new ItemInfo();

	public Image blackImg;

	public Image redPointImg;

	public Text itemNameText;

	public Image redBGImg;

	private ClueItemUIContainer container;

	public override void OnRender()
	{
		int num = container.pageIndex * 10 + int.Parse(base.name);
		if (num < MonoSingleton<BackpackManager>.Instance.clueLst.Count)
		{
			ItemType key = MonoSingleton<BackpackManager>.Instance.clueLst[num];
			itemInfo = MonoSingleton<BackpackManager>.Instance.ClueDict[key];
			itemNameText.text = itemInfo.itemName;
			Normal();
		}
	}

	public override void Init()
	{
		container = GetComponentInParent<ClueItemUIContainer>();
		EventsCentral.Clue._选中线索.AddListener(delegate(ItemType type)
		{
			if (type != itemInfo.id || itemInfo.id == ItemType.None || !itemInfo.isHave)
			{
				isSelected = false;
				Normal();
			}
		});
		OnRender();
	}

	public override void Normal()
	{
		blackImg.color = (itemInfo.isHave ? Color.clear : Color.white);
		if (itemInfo.isHave)
		{
			redPointImg.color = (itemInfo.read ? Color.clear : Color.red);
		}
		else
		{
			redPointImg.color = Color.clear;
		}
		itemNameText.color = new Color(64f / 85f, 64f / 85f, 64f / 85f);
		itemNameText.fontSize = 30;
		redBGImg.color = Color.clear;
	}

	public override void Hover()
	{
		blackImg.color = (itemInfo.isHave ? Color.clear : Color.white);
		if (itemInfo.isHave)
		{
			redPointImg.color = (itemInfo.read ? Color.clear : Color.red);
			itemNameText.color = Color.white;
			itemNameText.fontSize = 30;
		}
		else
		{
			redPointImg.color = Color.clear;
		}
		redBGImg.color = Color.clear;
	}

	public override void Selected()
	{
		if (itemInfo.isHave)
		{
			blackImg.color = (itemInfo.isHave ? Color.clear : Color.white);
			redPointImg.color = Color.clear;
			redBGImg.color = new Color(1f, 1f, 1f, 0.5f);
			itemNameText.color = Color.white;
			itemNameText.fontSize = 40;
			isSelected = true;
			OnClick();
		}
	}

	public override void OnClick()
	{
		if (itemInfo.isHave)
		{
			itemInfo.read = true;
		}
		EventsCentral.Clue._选中线索.Invoke(itemInfo.id);
	}
}
public class ClueItemUIContainer : MonoBehaviour
{
	public int pageIndex;

	[SerializeReference]
	private int max = -1;

	private ClueItemInfoUI[] itemInfoUIArray;

	private void OnEnable()
	{
		if (max <= 1)
		{
			max = (MonoSingleton<BackpackManager>.Instance.clueLst.Count - 1) / 10;
			itemInfoUIArray = GetComponentsInChildren<ClueItemInfoUI>();
		}
	}

	public void Up()
	{
		pageIndex = Mathf.Clamp(pageIndex - 1, 0, max);
		for (int i = 0; i < itemInfoUIArray.Length; i++)
		{
			itemInfoUIArray[i].OnRender();
		}
	}

	public void Down()
	{
		pageIndex = Mathf.Clamp(pageIndex + 1, 0, max);
		for (int i = 0; i < itemInfoUIArray.Length; i++)
		{
			itemInfoUIArray[i].OnRender();
		}
	}
}
public class ClueUIPanel : UIPanelBase
{
	public Image redPoint;

	public Image clueImg;

	public Text clueContent;

	public List<ItemType> items = new List<ItemType>();

	public override void Show()
	{
		SelectedItem(ItemType.None);
		base.transform.GetChild(0).gameObject.SetActive(value: true);
	}

	public override void Hide()
	{
		base.transform.GetChild(0).gameObject.SetActive(value: false);
	}

	public override void Init()
	{
		EventsCentral.Clue._选中线索.AddListener(SelectedItem);
		EventsCentral.Backpack._添加物品到背包.AddListener(AddToItems);
		base.Init();
	}

	private void AddToItems(ItemType obj)
	{
		if (obj.GetOperationType() == OperationType._1_线索 && !items.Contains(obj) && !MonoSingleton<BackpackManager>.Instance.ClueDict[obj].read)
		{
			redPoint.enabled = true;
			items.Add(obj);
			MonoBehaviour.print(obj.ToString() + "此线索没有读过");
		}
	}

	public void SelectedItem(ItemType type)
	{
		if (type == ItemType.None)
		{
			clueImg.enabled = false;
			clueContent.enabled = false;
			return;
		}
		if (items.Contains(type))
		{
			items.Remove(type);
			if (items.Count == 0)
			{
				redPoint.enabled = false;
			}
		}
		clueImg.enabled = true;
		clueContent.enabled = true;
		clueImg.sprite = MonoSingleton<BackpackManager>.Instance.ClueDict[type].GetItemImage();
		clueContent.text = MonoSingleton<BackpackManager>.Instance.ClueDict[type].contentText;
	}
}
public class AboutUI : MonoBehaviour
{
	private Tween tween;

	private void Start()
	{
		tween = base.transform.DOLocalMoveY(1060f, 20f);
	}

	private void OnEnable()
	{
		tween.Restart();
		base.transform.localPosition = new Vector3(-12f, -1142f, 0f);
		TweenExtensions.Play(tween);
	}
}
public class BackToStartPanel : MenuPanelButton
{
	public override void OnClick()
	{
		MonoSingleton<PlayerInfo>.Instance.canOpenUI = false;
		MonoSingleton<PlayerInfo>.Instance.showRay = true;
		MonoSingleton<OverallViewManager>.Instance.Play(1, autoClose: false);
		MonoSingleton<OverallViewManager>.Instance.transform.GetChild(1).gameObject.SetActive(value: true);
		MonoSingleton<OverallViewManager>.Instance.transform.GetChild(1).GetChild(0).gameObject.SetActive(value: true);
		MonoSingleton<PlayerInfo>.Instance.SetEasyVRController(move: false, left: false, right: true);
		MonoSingleton<GlobalManager>.Instance.CurrentUI = MJFSM.UIPanelType.None;
		base.transform.parent.gameObject.SetActive(value: false);
		foreach (ItemInfo value in MonoSingleton<BackpackManager>.Instance.ClueDict.Values)
		{
			if (value != null)
			{
				value.isHave = false;
				value.read = false;
			}
		}
		if (MonoSingleton<TrainingSession>.Instance.guidanceText != null)
		{
			MonoSingleton<TrainingSession>.Instance.guidanceText.GetComponent<Text>().text = null;
		}
		MonoSingleton<PlayerPrefsGame>.Instance.clueUIPanel.items.Clear();
	}
}
public class SetActiveButton : MenuPanelButton
{
	public GameObject obj;

	public bool state;

	public override void OnClick()
	{
		obj.SetActive(state);
	}
}
public class MenuPanelButton : UIButtonBase
{
	public Image hover;

	public Text text;

	public MenuUIPanel.MenuUIPanelType myType;

	public override void Init()
	{
		base.Init();
		MenuUIPanel.OpenMenuUIPanel.AddListener(delegate(MenuUIPanel.MenuUIPanelType obj)
		{
			if (obj == myType)
			{
				text.color = Color.white;
				text.fontSize = 40;
				hover.color = new Color(1f, 1f, 1f, 0.5f);
				isSelected = true;
			}
			else
			{
				Normal();
				isSelected = false;
			}
		});
	}

	public override void Normal()
	{
		text.color = new Color(64f / 85f, 64f / 85f, 64f / 85f, 1f);
		text.fontSize = 35;
		hover.color = Color.clear;
	}

	public override void Hover()
	{
		text.color = Color.white;
		text.fontSize = 35;
		hover.color = new Color(1f, 1f, 1f, 0.5f);
	}

	public override void Selected()
	{
		text.color = Color.white;
		text.fontSize = 40;
		hover.color = new Color(1f, 1f, 1f, 0.5f);
		base.Selected();
	}

	public override void OnClick()
	{
		MenuUIPanel.OpenMenuUIPanel.InvokeSafe(myType);
	}
}
public class MenuSubUIPanel : MonoBehaviour
{
	public MenuUIPanel.MenuUIPanelType myType;

	private void Start()
	{
		MenuUIPanel.OpenMenuUIPanel.AddListener(OpenUI);
	}

	private void OpenUI(MenuUIPanel.MenuUIPanelType obj)
	{
		base.transform.GetChild(0).gameObject.SetActive(obj == myType);
	}
}
public class MenuUIPanel : UIPanelBase
{
	public enum MenuUIPanelType
	{
		设置,
		教程,
		关于,
		返回主菜单
	}

	public static Signal<MenuUIPanelType> OpenMenuUIPanel = new Signal<MenuUIPanelType>();

	public override void Show()
	{
		base.transform.GetChild(0).gameObject.SetActive(value: true);
		OpenMenuUIPanel.InvokeSafe(MenuUIPanelType.设置);
	}

	public override void Hide()
	{
		base.transform.GetChild(0).gameObject.SetActive(value: false);
	}

	public override void Init()
	{
		base.Init();
	}
}
public class GeneralModeUI : MonoBehaviour
{
	public Text Text;

	public string[] Operationgs;

	public int id;

	private void Start()
	{
		Init();
	}

	public virtual void Init()
	{
		SetOperatingMode();
	}

	public void Left()
	{
		id--;
		SetOperatingMode();
	}

	public void Right()
	{
		id++;
		SetOperatingMode();
	}

	public virtual void SetOperatingMode()
	{
		Text.text = Operationgs[id];
	}
}
public class Language : GeneralModeUI
{
	private int index;

	public override void Init()
	{
	}

	public override void SetOperatingMode()
	{
		index = Mathf.Abs(id % LanguageType.Length.GetHashCode());
		if (MonoSingleton<GlobalManager>.Instance.language != (LanguageType)index)
		{
			MonoSingleton<GlobalManager>.Instance.language = (LanguageType)index;
			EventsCentral.System.切换语言.Invoke(index);
			if (MonoSingleton<GlobalManager>.Instance.CurrentScene == MJFSM.SceneType.新手教程)
			{
				TeachingProcess.training.InvokeSafe(TeachingProcess.teachType, t2: true);
			}
		}
	}
}
public class RotationTypeUI : GeneralModeUI
{
	private int index;

	public override void SetOperatingMode()
	{
		MonoSingleton<Settings>.Instance.operation = (index = Mathf.Abs(id % LanguageType.Length.GetHashCode()));
	}
}
public class SoundVolumeUI : MonoBehaviour
{
	public int soundVolume = 7;

	private Image[] images;

	public Sprite empty;

	public Sprite volume;

	public Transform Container;

	private void Start()
	{
		images = Container.GetComponentsInChildren<Image>();
		SetSoundVolume();
	}

	public void Plus()
	{
		soundVolume = Mathf.Clamp(soundVolume + 1, 0, 10);
		SetSoundVolume();
	}

	public void Minus()
	{
		soundVolume = Mathf.Clamp(soundVolume - 1, 0, 10);
		SetSoundVolume();
	}

	private void SetSoundVolume()
	{
		for (int i = 0; i < images.Length; i++)
		{
			if (i < soundVolume)
			{
				images[i].sprite = volume;
			}
			else
			{
				images[i].sprite = empty;
			}
		}
		Singleton<Config>.Instance.SoundVolume = (float)soundVolume * 0.1f;
		EventsCentral.System.音量调节.Invoke((float)soundVolume * 0.1f);
	}
}
public class MainPanelUI : UIPanelBase
{
	public override void ShowPanel(MJFSM.UIPanelType type)
	{
		if (type == myType || type == MJFSM.UIPanelType.背包 || type == MJFSM.UIPanelType.线索 || type == MJFSM.UIPanelType.设置界面)
		{
			Show();
		}
		else
		{
			Hide();
		}
	}
}
public class UIPanelBase : MonoBehaviour
{
	public MJFSM.UIPanelType myType;

	private void Start()
	{
		Init();
	}

	public virtual void ShowPanel(MJFSM.UIPanelType type)
	{
		if (type == myType)
		{
			Show();
		}
		else
		{
			Hide();
		}
	}

	public void HidePanel(MJFSM.UIPanelType type)
	{
		if (type == myType)
		{
			Hide();
		}
	}

	public virtual void Init()
	{
		EventsCentral.UI._Invoke_开启界面 += new Action<MJFSM.UIPanelType>(ShowPanel);
		EventsCentral.UI._关闭界面 += new Action<MJFSM.UIPanelType>(HidePanel);
		Hide();
	}

	public virtual void Show()
	{
		base.gameObject.SetActive(value: true);
		EventsCentral.UI._Callback_开启界面.InvokeSafe(myType);
	}

	public virtual void Hide()
	{
		base.gameObject.SetActive(value: false);
	}
}
public class TabButton : UIButtonBase
{
	public MJFSM.UIPanelType myType;

	public Text tabText;

	public Color normalColor = new Color(64f / 85f, 64f / 85f, 64f / 85f, 1f);

	public override void Init()
	{
		tabText = GetComponentInChildren<Text>();
		EventsCentral.UI._Invoke_开启界面.AddListener(ChangePage);
	}

	public override void Normal()
	{
		SetText(35, normalColor);
	}

	public override void Hover()
	{
		if (!isSelected)
		{
			SetText(35, Color.white);
		}
	}

	public override void Selected()
	{
		if (!isSelected)
		{
			SetText(40, Color.white);
		}
		isSelected = true;
		OnClick();
	}

	public override void OnClick()
	{
		onClick.Invoke();
		EventsCentral.UI._Invoke_开启界面.Invoke(myType);
	}

	public void ChangePage(MJFSM.UIPanelType panelType)
	{
		if (panelType != myType)
		{
			Normal();
			isSelected = false;
			return;
		}
		if (!isSelected)
		{
			SetText(40, Color.white);
		}
		isSelected = true;
	}

	public void SetText(int size, Color color)
	{
		tabText.fontSize = size;
		tabText.color = color;
	}
}
public class TabUI : UIPanelBase
{
	public override void Init()
	{
		EventsCentral.Backpack._关闭背包.AddListener(Hide);
		EventsCentral.Backpack._开启背包.AddListener(Show);
		base.Init();
	}
}
public class Tips : MonoBehaviour
{
	private Text tipsText;

	private int cd;

	private void Start()
	{
		tipsText = GetComponent<Text>();
		EventsCentral.Tips.AddListener(delegate(string msg)
		{
			tipsText.enabled = true;
			tipsText.text = msg;
			Invoke("AutoClose", 2f);
		});
		AutoClose();
	}

	private void AutoClose()
	{
		tipsText.enabled = false;
	}
}
public class UIButtonBase : MonoBehaviour, IPointerEnterHandler, IEventSystemHandler, IPointerExitHandler, IPointerDownHandler, IPointerClickHandler
{
	public Sprite normalSprite;

	public Sprite hoverSprite;

	public Sprite selectedSprite;

	public bool isSelected;

	internal Image imageComponent;

	public UnityEvent onClick;

	private void Awake()
	{
		Init();
	}

	public virtual void Init()
	{
		imageComponent = GetComponent<Image>();
	}

	private void OnEnable()
	{
		OnRender();
	}

	public virtual void Normal()
	{
		imageComponent.sprite = normalSprite;
	}

	public virtual void Hover()
	{
		if (hoverSprite != null)
		{
			imageComponent.sprite = hoverSprite;
		}
	}

	public virtual void Selected()
	{
		if (selectedSprite != null)
		{
			imageComponent.sprite = selectedSprite;
		}
		isSelected = true;
		OnClick();
	}

	public virtual void OnClick()
	{
		UnityEngine.Debug.Log("点击" + base.name);
		onClick.Invoke();
	}

	public virtual void OnRender()
	{
	}

	public virtual void PressDown()
	{
	}

	public void OnPointerEnter(PointerEventData eventData)
	{
		if (!isSelected)
		{
			Hover();
		}
	}

	public void OnPointerExit(PointerEventData eventData)
	{
		if (!isSelected)
		{
			Normal();
		}
	}

	public void OnPointerClick(PointerEventData eventData)
	{
		Selected();
	}

	public void OnPointerDown(PointerEventData eventData)
	{
		PressDown();
	}
}
public class UIBase : MonoBehaviour
{
}
public class AmbsionicsFilter : MonoBehaviour
{
	public bool filter;

	public int m_sampleRate;

	public int m_sampleDepth;

	public float gain;

	public int channels1;

	private void Start()
	{
	}

	private void Update()
	{
	}

	private void OnAudioFilterRead(float[] data, int channels)
	{
		for (int i = 0; i < data.Length; i += 4)
		{
			float num = data[i];
			float num2 = data[i + 1];
			float num3 = data[i + 2];
			float num4 = data[i + 3];
			float num5 = 0.5f * (num + num3 + num2 + num4);
			float num6 = 0.5f * (num - num3 + (num2 - num4));
			float num7 = 0.5f * (num - num4 - (num2 - num3));
			float num8 = 0.5f * (num - num3 + (num4 - num2));
			data[i] = num5;
			data[i + 1] = num7;
			data[i + 2] = num8;
			data[i + 3] = num6;
		}
	}
}
public class CameraCutSequences : MonoBehaviour
{
	public GameObject camGobject;

	private void Start()
	{
	}

	private void Update()
	{
		camGobject = Camera.main.gameObject;
		base.gameObject.transform.position = Camera.main.gameObject.transform.position;
		base.gameObject.transform.rotation = Camera.main.gameObject.transform.rotation;
	}
}
public class MouseControlVR : MonoBehaviour
{
	public float mouseSensitivity = 100f;

	public float clampAngle = 80f;

	private float rotY;

	private float rotX;

	private void Start()
	{
		Vector3 eulerAngles = base.transform.localRotation.eulerAngles;
		rotY = eulerAngles.y;
		rotX = eulerAngles.x;
	}

	private void Update()
	{
		if (Input.GetMouseButton(0))
		{
			float axis = Input.GetAxis("Mouse X");
			float num = 0f - Input.GetAxis("Mouse Y");
			rotY += axis * mouseSensitivity * Time.deltaTime;
			rotX += num * mouseSensitivity * Time.deltaTime;
			rotX = Mathf.Clamp(rotX, 0f - clampAngle, clampAngle);
			Quaternion rotation = Quaternion.Euler(rotX, rotY, 0f);
			base.transform.rotation = rotation;
		}
	}
}
public class WriteEXR : MonoBehaviour
{
	public RenderTexture rt;

	public RenderTexture unfilteredRt;

	public int HRes;

	public int WRes;

	public Texture2D screenShot;

	private Color[] EXRArray;

	public bool render;

	private Material VRAA;

	private void Start()
	{
		rt = new RenderTexture(512, 512, 0, RenderTextureFormat.DefaultHDR, RenderTextureReadWrite.Linear);
		Resources.Load("Materials/VRAA");
		screenShot = new Texture2D(512, 512, TextureFormat.RGBAHalf, mipChain: false);
	}

	private void Update()
	{
		if (render)
		{
			VideoRenderPrepare();
			screenShot = GetVideoScreenshot();
			EXRArray = screenShot.GetPixels(0, 0, 512, 512);
			global::MiniEXR.MiniEXR.MiniEXRWrite(string.Concat(Application.dataPath + "\\VRPanorama\\StreamingAssets\\", "/Test.exr"), Convert.ToUInt16(HRes), Convert.ToUInt16(WRes), EXRArray);
			render = false;
		}
	}

	public void VideoRenderPrepare()
	{
		VRAA = Resources.Load("Materials/VRAA") as Material;
		unfilteredRt = new RenderTexture(512, 512, 0, RenderTextureFormat.DefaultHDR, RenderTextureReadWrite.Default);
		rt = new RenderTexture(512, 512, 0, RenderTextureFormat.Default, RenderTextureReadWrite.Default);
		screenShot = new Texture2D(512, 512, TextureFormat.ARGB32, mipChain: false);
	}

	public Texture2D GetVideoScreenshot()
	{
		Camera main = Camera.main;
		if (main == null)
		{
			UnityEngine.Debug.LogError("There are no cameras with MAIN CAMERA tag in scene. Please assign MAIN CAMERA tag to your camera");
		}
		main.targetTexture = unfilteredRt;
		main.Render();
		RenderTexture.active = unfilteredRt;
		VRAA.mainTexture = unfilteredRt;
		VRAA.SetInt("_U", 1024);
		VRAA.SetInt("_V", 1024);
		Graphics.Blit(unfilteredRt, rt, VRAA, -1);
		screenShot.ReadPixels(new Rect(0f, 0f, 512f, 512f), 0, 0);
		return screenShot;
	}
}
public class StereoPanorama : MonoBehaviour
{
	public GameObject mappingSphere;

	public GameObject eyeCamera;

	private void Start()
	{
		mappingSphere = base.gameObject;
	}

	private void Update()
	{
		mappingSphere.transform.position = eyeCamera.transform.position;
	}
}
public class HideRig : MonoBehaviour
{
	private Camera cam;

	private VRCapture VRcap;

	private GameObject rig;

	private GameObject[] rigObjects;

	private int iterations = 10;

	private int i;

	private void Start()
	{
		VRcap = base.gameObject.GetComponent<VRCapture>();
	}

	private void Update()
	{
		if (this.i < iterations)
		{
			cam = GetComponent<Camera>();
			cam.cullingMask |= 1024;
			rig = VRcap.renderPanorama;
			rigObjects = rig.transform.GetComponentsInChildren<GameObject>();
			GameObject[] array = rigObjects;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].layer = 10;
			}
			this.i++;
		}
	}
}
namespace MiniEXR
{
	internal static class HalfHelper
	{
		private static uint[] mantissaTable = GenerateMantissaTable();

		private static uint[] exponentTable = GenerateExponentTable();

		private static ushort[] offsetTable = GenerateOffsetTable();

		private static ushort[] baseTable = GenerateBaseTable();

		private static sbyte[] shiftTable = GenerateShiftTable();

		private static uint ConvertMantissa(int i)
		{
			uint num = (uint)(i << 13);
			uint num2 = 0u;
			while ((num & 0x800000) == 0)
			{
				num2 -= 8388608;
				num <<= 1;
			}
			num &= 0xFF7FFFFFu;
			num2 += 947912704;
			return num | num2;
		}

		private static uint[] GenerateMantissaTable()
		{
			uint[] array = new uint[2048];
			array[0] = 0u;
			for (int i = 1; i < 1024; i++)
			{
				array[i] = ConvertMantissa(i);
			}
			for (int j = 1024; j < 2048; j++)
			{
				array[j] = (uint)(939524096 + (j - 1024 << 13));
			}
			return array;
		}

		private static uint[] GenerateExponentTable()
		{
			uint[] array = new uint[64];
			array[0] = 0u;
			for (int i = 1; i < 31; i++)
			{
				array[i] = (uint)(i << 23);
			}
			array[31] = 1199570944u;
			array[32] = 2147483648u;
			for (int j = 33; j < 63; j++)
			{
				array[j] = (uint)(2147483648u + (j - 32 << 23));
			}
			array[63] = 3347054592u;
			return array;
		}

		private static ushort[] GenerateOffsetTable()
		{
			ushort[] array = new ushort[64];
			array[0] = 0;
			for (int i = 1; i < 32; i++)
			{
				array[i] = 1024;
			}
			array[32] = 0;
			for (int j = 33; j < 64; j++)
			{
				array[j] = 1024;
			}
			return array;
		}

		private static ushort[] GenerateBaseTable()
		{
			ushort[] array = new ushort[512];
			for (int i = 0; i < 256; i++)
			{
				sbyte b = (sbyte)(127 - i);
				if (b > 24)
				{
					array[i | 0] = 0;
					array[i | 0x100] = 32768;
				}
				else if (b > 14)
				{
					array[i | 0] = (ushort)(1024 >> 18 + b);
					array[i | 0x100] = (ushort)((uint)(1024 >> 18 + b) | 0x8000u);
				}
				else if (b >= -15)
				{
					array[i | 0] = (ushort)(15 - b << 10);
					array[i | 0x100] = (ushort)((uint)(15 - b << 10) | 0x8000u);
				}
				else if (b > sbyte.MinValue)
				{
					array[i | 0] = 31744;
					array[i | 0x100] = 64512;
				}
				else
				{
					array[i | 0] = 31744;
					array[i | 0x100] = 64512;
				}
			}
			return array;
		}

		private static sbyte[] GenerateShiftTable()
		{
			sbyte[] array = new sbyte[512];
			for (int i = 0; i < 256; i++)
			{
				sbyte b = (sbyte)(127 - i);
				if (b > 24)
				{
					array[i | 0] = 24;
					array[i | 0x100] = 24;
				}
				else if (b > 14)
				{
					array[i | 0] = (sbyte)(b - 1);
					array[i | 0x100] = (sbyte)(b - 1);
				}
				else if (b >= -15)
				{
					array[i | 0] = 13;
					array[i | 0x100] = 13;
				}
				else if (b > sbyte.MinValue)
				{
					array[i | 0] = 24;
					array[i | 0x100] = 24;
				}
				else
				{
					array[i | 0] = 13;
					array[i | 0x100] = 13;
				}
			}
			return array;
		}

		public static float HalfToSingle(ushort half)
		{
			return BitConverter.ToSingle(BitConverter.GetBytes(mantissaTable[offsetTable[half >> 10] + (half & 0x3FF)] + exponentTable[half >> 10]), 0);
		}

		public static ushort SingleToHalf(float single)
		{
			uint num = BitConverter.ToUInt32(BitConverter.GetBytes(single), 0);
			return (ushort)(baseTable[(num >> 23) & 0x1FF] + ((num & 0x7FFFFF) >> (int)shiftTable[num >> 23]));
		}
	}
	public static class MiniEXR
	{
		public static void MiniEXRWrite(string _filePath, uint _width, uint _height, uint _channels, float[] _rgbaArray)
		{
			File.WriteAllBytes(_filePath, MiniEXRWrite(_width, _height, _channels, _rgbaArray));
		}

		public static void MiniEXRWrite(string _filePath, uint _width, uint _height, Color[] _colorArray)
		{
			File.WriteAllBytes(_filePath, MiniEXRWrite(_width, _height, _colorArray));
		}

		public static byte[] MiniEXRWrite(uint _width, uint _height, Color[] _colorArray)
		{
			float[] array = new float[_colorArray.Length * 3];
			for (int i = 0; i < _colorArray.Length; i++)
			{
				array[i * 3] = _colorArray[i].r;
				array[i * 3 + 1] = _colorArray[i].g;
				array[i * 3 + 2] = _colorArray[i].b;
			}
			return MiniEXRWrite(_width, _height, 3u, array);
		}

		public static byte[] MiniEXRWrite(uint _width, uint _height, uint _channels, float[] _rgbaArray)
		{
			uint num = _width - 1;
			uint num2 = _height - 1;
			byte[] obj = new byte[313]
			{
				118, 47, 49, 1, 2, 0, 0, 0, 99, 104,
				97, 110, 110, 101, 108, 115, 0, 99, 104, 108,
				105, 115, 116, 0, 55, 0, 0, 0, 66, 0,
				1, 0, 0, 0, 0, 0, 0, 0, 1, 0,
				0, 0, 1, 0, 0, 0, 71, 0, 1, 0,
				0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
				1, 0, 0, 0, 82, 0, 1, 0, 0, 0,
				0, 0, 0, 0, 1, 0, 0, 0, 1, 0,
				0, 0, 0, 99, 111, 109, 112, 114, 101, 115,
				115, 105, 111, 110, 0, 99, 111, 109, 112, 114,
				101, 115, 115, 105, 111, 110, 0, 1, 0, 0,
				0, 0, 100, 97, 116, 97, 87, 105, 110, 100,
				111, 119, 0, 98, 111, 120, 50, 105, 0, 16,
				0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
				0, 0, 0, 0, 0, 0, 0, 0, 0, 100,
				105, 115, 112, 108, 97, 121, 87, 105, 110, 100,
				111, 119, 0, 98, 111, 120, 50, 105, 0, 16,
				0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
				0, 0, 0, 0, 0, 0, 0, 0, 0, 108,
				105, 110, 101, 79, 114, 100, 101, 114, 0, 108,
				105, 110, 101, 79, 114, 100, 101, 114, 0, 1,
				0, 0, 0, 0, 112, 105, 120, 101, 108, 65,
				115, 112, 101, 99, 116, 82, 97, 116, 105, 111,
				0, 102, 108, 111, 97, 116, 0, 4, 0, 0,
				0, 0, 0, 128, 63, 115, 99, 114, 101, 101,
				110, 87, 105, 110, 100, 111, 119, 67, 101, 110,
				116, 101, 114, 0, 118, 50, 102, 0, 8, 0,
				0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
				115, 99, 114, 101, 101, 110, 87, 105, 110, 100,
				111, 119, 87, 105, 100, 116, 104, 0, 102, 108,
				111, 97, 116, 0, 4, 0, 0, 0, 0, 0,
				128, 63, 0
			};
			obj[141] = (byte)(num & 0xFFu);
			obj[142] = (byte)((num >> 8) & 0xFFu);
			obj[143] = (byte)((num >> 16) & 0xFFu);
			obj[144] = (byte)((num >> 24) & 0xFFu);
			obj[145] = (byte)(num2 & 0xFFu);
			obj[146] = (byte)((num2 >> 8) & 0xFFu);
			obj[147] = (byte)((num2 >> 16) & 0xFFu);
			obj[148] = (byte)((num2 >> 24) & 0xFFu);
			obj[181] = (byte)(num & 0xFFu);
			obj[182] = (byte)((num >> 8) & 0xFFu);
			obj[183] = (byte)((num >> 16) & 0xFFu);
			obj[184] = (byte)((num >> 24) & 0xFFu);
			obj[185] = (byte)(num2 & 0xFFu);
			obj[186] = (byte)((num2 >> 8) & 0xFFu);
			obj[187] = (byte)((num2 >> 16) & 0xFFu);
			obj[188] = (byte)((num2 >> 24) & 0xFFu);
			byte[] array = obj;
			uint num3 = (uint)array.Length;
			uint num4 = 8 * _height;
			uint num5 = _width * 3 * 2;
			uint num6 = num5 + 8;
			byte[] array2 = new byte[num3 + num4 + _height * num6];
			int num7 = 0;
			for (int i = 0; i < num3; i++)
			{
				array2[num7] = array[i];
				num7++;
			}
			uint num8 = num3 + num4;
			for (int j = 0; j < _height; j++)
			{
				array2[num7++] = (byte)(num8 & 0xFFu);
				array2[num7++] = (byte)((num8 >> 8) & 0xFFu);
				array2[num7++] = (byte)((num8 >> 16) & 0xFFu);
				array2[num7++] = (byte)((num8 >> 24) & 0xFFu);
				array2[num7++] = 0;
				array2[num7++] = 0;
				array2[num7++] = 0;
				array2[num7++] = 0;
				num8 += num6;
			}
			ushort[] array3 = new ushort[_rgbaArray.Length];
			for (int k = 0; k < _rgbaArray.Length; k++)
			{
				_rgbaArray[k] = Mathf.Pow(_rgbaArray[k], 2.2f);
				array3[k] = HalfHelper.SingleToHalf(_rgbaArray[k]);
			}
			uint num9 = 0u;
			for (int l = 0; l < _height; l++)
			{
				array2[num7++] = (byte)((uint)l & 0xFFu);
				array2[num7++] = (byte)((uint)(l >> 8) & 0xFFu);
				array2[num7++] = (byte)((uint)(l >> 16) & 0xFFu);
				array2[num7++] = (byte)((uint)(l >> 24) & 0xFFu);
				array2[num7++] = (byte)(num5 & 0xFFu);
				array2[num7++] = (byte)((num5 >> 8) & 0xFFu);
				array2[num7++] = (byte)((num5 >> 16) & 0xFFu);
				array2[num7++] = (byte)((num5 >> 24) & 0xFFu);
				uint num10 = num9;
				for (int m = 0; m < _width; m++)
				{
					byte[] bytes = BitConverter.GetBytes(array3[num10 + 2]);
					array2[num7++] = bytes[0];
					array2[num7++] = bytes[1];
					num10 += _channels;
				}
				num10 = num9;
				for (int n = 0; n < _width; n++)
				{
					byte[] bytes2 = BitConverter.GetBytes(array3[num10 + 1]);
					array2[num7++] = bytes2[0];
					array2[num7++] = bytes2[1];
					num10 += _channels;
				}
				num10 = num9;
				for (int num11 = 0; num11 < _width; num11++)
				{
					byte[] bytes3 = BitConverter.GetBytes(array3[num10]);
					array2[num7++] = bytes3[0];
					array2[num7++] = bytes3[1];
					num10 += _channels;
				}
				num9 += _width * _channels;
			}
			return array2;
		}
	}
}
namespace VRPanorama
{
	public class AudioSyncWithVRCapture : MonoBehaviour
	{
		public bool triggerAudio = true;

		private void Start()
		{
		}

		private void LateUpdate()
		{
			if (triggerAudio)
			{
				GetComponent<AudioSource>().Play();
			}
			triggerAudio = false;
		}
	}
	[RequireComponent(typeof(Camera))]
	[AddComponentMenu("FFmpegOut/Camera Capture")]
	public class CameraCapture : MonoBehaviour
	{
		public bool _setResolution = true;

		public int _width = 1280;

		public int _height = 720;

		public int _frameRate = 30;

		public bool _allowSlowDown = true;

		public FFmpegPipe.Preset _preset;

		public float _startTime;

		public float _recordLength = 5f;

		[SerializeField]
		[HideInInspector]
		private Shader _shader;

		private Material _material;

		private FFmpegPipe _pipe;

		private float _elapsed;

		private RenderTexture _tempTarget;

		private GameObject _tempBlitter;

		private static int _activePipeCount;

		private void OnValidate()
		{
			_startTime = Mathf.Max(_startTime, 0f);
			_recordLength = Mathf.Max(_recordLength, 0.01f);
		}

		private void OnEnable()
		{
			if (!FFmpegConfig.CheckAvailable)
			{
				UnityEngine.Debug.LogError("ffmpeg isn't configured right, if you are using MAC OSX, please check your credentials");
				base.enabled = false;
			}
		}

		private void OnDisable()
		{
			if (_pipe != null)
			{
				ClosePipe();
			}
		}

		private void OnDestroy()
		{
			if (_pipe != null)
			{
				ClosePipe();
			}
		}

		private void Start()
		{
			_material = new Material(_shader);
		}

		private void Update()
		{
			_elapsed += Time.deltaTime;
			if (_startTime <= _elapsed && _elapsed < _startTime + _recordLength)
			{
				if (_pipe == null)
				{
					OpenPipe();
				}
			}
			else if (_pipe != null)
			{
				ClosePipe();
			}
		}

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (_pipe != null)
			{
				RenderTexture temporary = RenderTexture.GetTemporary(source.width, source.height);
				Graphics.Blit(source, temporary, _material, 0);
				Texture2D texture2D = new Texture2D(source.width, source.height, TextureFormat.RGBA32, mipChain: false);
				texture2D.ReadPixels(new Rect(0f, 0f, source.width, source.height), 0, 0, recalculateMipMaps: false);
				texture2D.Apply();
				_pipe.Write(texture2D.GetRawTextureData());
				UnityEngine.Object.Destroy(texture2D);
				RenderTexture.ReleaseTemporary(temporary);
			}
			Graphics.Blit(source, destination);
		}

		private void OpenPipe()
		{
			if (_pipe != null)
			{
				return;
			}
			Camera component = GetComponent<Camera>();
			int width = _width;
			int height = _height;
			if (_setResolution)
			{
				_tempTarget = RenderTexture.GetTemporary(width, height, 24);
				component.targetTexture = _tempTarget;
				_tempBlitter = Blitter.CreateGameObject(component);
			}
			else
			{
				width = component.pixelWidth;
				height = component.pixelHeight;
			}
			_pipe = new FFmpegPipe(base.name, width, height, _frameRate, _preset);
			_activePipeCount++;
			if (_activePipeCount == 1)
			{
				if (_allowSlowDown)
				{
					Time.captureFramerate = _frameRate;
				}
				else
				{
					Application.targetFrameRate = _frameRate;
				}
			}
			UnityEngine.Debug.Log("Capture started (" + _pipe.Filename + ")");
		}

		private void ClosePipe()
		{
			Camera component = GetComponent<Camera>();
			if (_tempBlitter != null)
			{
				UnityEngine.Object.Destroy(_tempBlitter);
				_tempBlitter = null;
			}
			if (_tempTarget != null && _tempTarget == component.targetTexture)
			{
				component.targetTexture = null;
				RenderTexture.ReleaseTemporary(_tempTarget);
				_tempTarget = null;
			}
			if (_pipe == null)
			{
				return;
			}
			UnityEngine.Debug.Log("Capture ended (" + _pipe.Filename + ")");
			_pipe.Close();
			_activePipeCount--;
			if (!string.IsNullOrEmpty(_pipe.Error))
			{
				UnityEngine.Debug.LogWarning("ffmpeg returned with a warning or an error message. See the following lines for details:\n" + _pipe.Error);
			}
			_pipe = null;
			if (_activePipeCount == 0)
			{
				if (_allowSlowDown)
				{
					Time.captureFramerate = 0;
				}
				else
				{
					Application.targetFrameRate = -1;
				}
			}
		}
	}
	internal static class FFmpegConfig
	{
		public static string BinaryPath
		{
			get
			{
				string text = Application.dataPath + "\\VRPanorama\\StreamingAssets\\";
				if (Application.platform == RuntimePlatform.OSXPlayer || Application.platform == RuntimePlatform.OSXEditor)
				{
					return text + "ffmpeg";
				}
				if (Application.platform == RuntimePlatform.LinuxPlayer || Application.platform == RuntimePlatform.LinuxEditor)
				{
					return text + "ffmpeg";
				}
				UnityEngine.Debug.Log(text + "ffmpeg.exe");
				return text + "ffmpeg.exe";
			}
		}

		public static bool CheckAvailable => File.Exists(BinaryPath);
	}
	public class FFmpegPipe
	{
		public enum Preset
		{
			ProRes422,
			ProRes4444,
			H264Default,
			H264Lossless420,
			H264Lossless444,
			VP8Default
		}

		private Process _subprocess;

		private BinaryWriter _stdin;

		private static string[] _suffixes = new string[6] { ".mp4", ".mp4", ".mp4", ".mov", ".mov", ".webm" };

		private static string[] _options = new string[6] { "-pix_fmt yuv420p", "-pix_fmt yuv420p -preset ultrafast -crf 0", "-pix_fmt yuv444p -preset ultrafast -crf 0", "-c:v prores_ks -pix_fmt yuv422p10le", "-c:v prores_ks -pix_fmt yuva444p10le", "-c:v libvpx -pix_fmt yuv420p" };

		public string Filename { get; private set; }

		public string Error { get; private set; }

		public FFmpegPipe(string name, int width, int height, int framerate, Preset preset)
		{
			name += DateTime.Now.ToString(" yyyy MMdd HHmmss");
			Filename = name.Replace(" ", "_") + GetSuffix(preset);
			string text = "-y -f rawvideo -vcodec rawvideo -pixel_format rgba";
			text += " -colorspace bt709";
			text = text + " -video_size " + width + "x" + height;
			text = text + " -framerate " + framerate;
			text = text + " -loglevel warning -i - " + GetOptions(preset);
			text = text + " " + Filename;
			_subprocess = Process.Start(new ProcessStartInfo(FFmpegConfig.BinaryPath, text)
			{
				UseShellExecute = false,
				CreateNoWindow = true,
				RedirectStandardInput = true,
				RedirectStandardOutput = true,
				RedirectStandardError = true
			});
			_stdin = new BinaryWriter(_subprocess.StandardInput.BaseStream);
		}

		public void Write(byte[] data)
		{
			if (_subprocess != null)
			{
				_stdin.Write(data);
				_stdin.Flush();
			}
		}

		public void Close()
		{
			if (_subprocess != null)
			{
				_subprocess.StandardInput.Close();
				_subprocess.WaitForExit();
				StreamReader standardError = _subprocess.StandardError;
				Error = standardError.ReadToEnd();
				_subprocess.Close();
				_subprocess.Dispose();
				standardError.Close();
				standardError.Dispose();
				_subprocess = null;
				_stdin = null;
			}
		}

		private static string GetSuffix(Preset preset)
		{
			return _suffixes[(int)preset];
		}

		private static string GetOptions(Preset preset)
		{
			return _options[(int)preset];
		}
	}
	[RequireComponent(typeof(Camera))]
	internal class Blitter : MonoBehaviour
	{
		private static Type[] _blitterComponents = new Type[2]
		{
			typeof(Camera),
			typeof(Blitter)
		};

		private RenderTexture _sourceTexture;

		public static GameObject CreateGameObject(Camera originalCamera)
		{
			GameObject obj = new GameObject("Blitter", _blitterComponents)
			{
				hideFlags = HideFlags.HideInHierarchy
			};
			Camera component = obj.GetComponent<Camera>();
			component.cullingMask = 0;
			component.targetDisplay = originalCamera.targetDisplay;
			obj.GetComponent<Blitter>()._sourceTexture = originalCamera.targetTexture;
			return obj;
		}

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			Graphics.Blit(_sourceTexture, destination);
		}
	}
	public class VRBuilderScript : MonoBehaviour
	{
		public GameObject obj;

		public Vector3 spawnPoint;

		public void BuildObject()
		{
			UnityEngine.Object.Instantiate(obj, spawnPoint, Quaternion.identity);
		}
	}
	[RequireComponent(typeof(VRCapture))]
	public class VRCompositor : MonoBehaviour
	{
		private RenderTexture thisRT;

		private Camera camVR;

		public Camera[] cameraLayers;

		private void Awake()
		{
			camVR = base.gameObject.GetComponent<Camera>();
			for (int i = 0; i < cameraLayers.Length; i++)
			{
				cameraLayers[i].fieldOfView = 100f;
				cameraLayers[i].renderingPath = RenderingPath.DeferredShading;
			}
		}

		private void Update()
		{
			thisRT = camVR.targetTexture;
			for (int i = 0; i < cameraLayers.Length; i++)
			{
				cameraLayers[i].targetTexture = thisRT;
				cameraLayers[i].Render();
			}
		}
	}
	public class VRPanoInterface : MonoBehaviour
	{
		public float progressInd;

		public string timeCounterText;

		public Image texLoader;

		public Text timeCounter;

		public int width;

		public int height;

		public GameObject PanoramaCam;

		public GameObject hQCam;

		public bool rt;

		public bool mono;

		public bool sbs;

		public GameObject quadR;

		public GameObject quadL;

		public GameObject hQPlane;

		public bool hQ;

		public int step;

		private void Start()
		{
		}

		private void Update()
		{
			if (!rt)
			{
				texLoader.fillAmount = progressInd;
				timeCounter.text = timeCounterText;
				PanoramaCam.transform.localScale = new Vector3(1f / (float)height * (float)width, 1f, 2f);
			}
			if (sbs && !mono && rt)
			{
				PanoramaCam.transform.localScale = new Vector3(1f / (float)height * (float)width, 1f, 1f);
				quadR.transform.localPosition = new Vector3(-0.5f, 0f, 1.5f);
				quadL.transform.localPosition = new Vector3(0.5f, 0f, 1.5f);
			}
			if (!sbs && !mono && rt)
			{
				PanoramaCam.transform.localScale = new Vector3(0.5f / (float)height * (float)width, 0.5f, 1f);
				quadR.transform.localPosition = new Vector3(0f, 0.5f, 1.5f);
				quadL.transform.localPosition = new Vector3(0f, -0.5f, 1.5f);
			}
			if (mono && rt)
			{
				PanoramaCam.transform.localScale = new Vector3(1f / (float)height * (float)width, 1f, 1f);
			}
			if (hQ)
			{
				hQPlane.SetActive(value: true);
			}
			else if (!rt && hQPlane != null)
			{
				hQPlane.SetActive(value: false);
			}
		}
	}
	public class VRPanoramaAttribute : PropertyAttribute
	{
	}
	public class VideoSync : MonoBehaviour
	{
		private VideoPlayer videoPlayer;

		private void Awake()
		{
			videoPlayer = GetComponent<VideoPlayer>();
		}

		private void Start()
		{
			videoPlayer.Play();
			videoPlayer.Pause();
			StartCoroutine(SyncVideo());
		}

		private IEnumerator SyncVideo()
		{
			while (true)
			{
				yield return new WaitForEndOfFrame();
				videoPlayer.StepForward();
				videoPlayer.Pause();
			}
		}
	}
	[RequireComponent(typeof(AudioListener))]
	[RequireComponent(typeof(Camera))]
	public class VRCapture : MonoBehaviour
	{
		public enum VRModeList
		{
			EquidistantStereo,
			EquidistantStereoSBS,
			EquidistantMono,
			VideoCapture
		}

		public enum VRCaptureList
		{
			AnimationCapture,
			StillImage,
			VRPanoramaRT
		}

		public enum VRCaptureAngle
		{
			_360,
			_180
		}

		public enum VRFormatList
		{
			JPG,
			PNG,
			EXR_HDRI,
			Direct
		}

		private FFmpegPipe.Preset _preset;

		public int cubemapSize = 128;

		public bool oneFacePerFrame;

		public Camera cubeCam;

		private RenderTexture rtex;

		private RenderTexture rtexr;

		public bool captureAudio;

		public float volume = 1f;

		public bool mute = true;

		private float remainingTime;

		private int minutesRemain;

		private int secondsRemain;

		public bool alignPanoramaWithHorizont = true;

		private Material VRAA;

		private RenderTexture unfilteredRt;

		private GameObject rig;

		private GameObject cam;

		private GameObject panoramaCam;

		private string timestamp = "";

		private RenderTexture flTex;

		private RenderTexture frTex;

		private RenderTexture llTex;

		private RenderTexture lrTex;

		private RenderTexture rlTex;

		private RenderTexture rrTex;

		private RenderTexture dlTex;

		private RenderTexture drTex;

		private RenderTexture blTex;

		private RenderTexture brTex;

		private RenderTexture tlTex;

		private RenderTexture trTex;

		private RenderTexture tlxTex;

		private RenderTexture trxTex;

		private RenderTexture dlxTex;

		private RenderTexture drxTex;

		private Material FL;

		private Material FR;

		private Material LL;

		private Material LR;

		private Material RL;

		private Material RR;

		private Material DL;

		private Material DR;

		private Material BL;

		private Material BR;

		private Material TL;

		private Material TR;

		private Material DLX;

		private Material DRX;

		private Material TLX;

		private Material TRX;

		private Material HQMat;

		private RenderTexture rt;

		private Texture2D screenShot;

		private Texture2D screenShotHQ;

		public Camera camLL;

		public Camera camRL;

		public Camera camTL;

		public Camera camBL;

		public Camera camFL;

		public Camera camDL;

		public Camera camLR;

		public Camera camRR;

		public Camera camTR;

		public Camera camBR;

		public Camera camFR;

		public Camera camDR;

		public Camera camDRX;

		public Camera camDLX;

		public Camera camTRX;

		public Camera camTLX;

		private GameObject cloneCamLL;

		private GameObject cloneCamRL;

		private GameObject cloneCamTL;

		private GameObject cloneCamBL;

		private GameObject cloneCamFL;

		private GameObject cloneCamDL;

		private GameObject cloneCamLR;

		private GameObject cloneCamRR;

		private GameObject cloneCamTR;

		private GameObject cloneCamBR;

		private GameObject cloneCamFR;

		private GameObject cloneCamDR;

		private GameObject cloneCamDRX;

		private GameObject cloneCamDLX;

		private GameObject cloneCamTRX;

		private GameObject cloneCamTLX;

		private GameObject camll;

		private GameObject camrl;

		private GameObject camfl;

		private GameObject camtl;

		private GameObject cambl;

		private GameObject camdl;

		private bool waitRenderFinish;

		public GameObject renderPanorama;

		public int StartFrame;

		public VRModeList panoramaType = VRModeList.EquidistantMono;

		public VRCaptureList captureType;

		public VRCaptureAngle captureAngle;

		public bool RT2Video;

		public VRFormatList ImageFormatType;

		public string Folder = "VR_Sequence";

		public KeyCode captureKey = KeyCode.Space;

		public int FPS = 25;

		private Color[] EXRArray;

		public int resolution = 2048;

		public int resolutionH = 2048;

		public int step;

		public int NumberOfFramesToRender = 100;

		public int renderFromFrame = 1;

		[VRPanorama]
		public string sequenceLength;

		public float IPDistance = 0.066f;

		public float EnvironmentDistance = 2f;

		public float restoreFOV;

		public bool openDestinationFolder = true;

		public bool ambisonicsSupportTest;

		public string fullPath;

		public bool customPath;

		public string customPathFolder = "C:/";

		public bool encodeToMp4 = true;

		public int Mp4Bitrate = 20000;

		public int jpgQuality = 100;

		[Header("RenderTime/Quality Optimization")]
		[Range(1f, 16f)]
		public int renderQuality = 16;

		public string formatString;

		private int qualityTemp;

		public bool mailme;

		public string _mailto = "name@domain.com";

		public string _pass;

		public string _mailfrom = "name@gmail.com";

		public string _prefix = "img";

		private TextureFormat texFormat;

		private RenderTextureFormat renderTexFormat;

		[VRPanorama]
		public string RenderInfo = " ";

		public int bufferSize;

		public int numBuffers;

		private int outputRate = 48000;

		private int headerSize = 44;

		public bool recOutput;

		public bool depth = true;

		public int depthBufferSize;

		public bool ambisonics;

		public bool disableTracking = true;

		private FileStream fileStream;

		public ushort achannels;

		public bool hQ;

		public int steps = 10;

		public bool useAlpha;

		public float smoothing = 1f;

		public bool playPanorama;

		private GameObject vrPlayer;

		private VideoPlayer videoObject;

		private Material videoMat;

		public CameraCapture camCaptureComponent;

		public bool recordRT;

		public int videoLenght = 1;

		private void OnDestroy()
		{
			PlayerPrefs.SetInt("VRPlayer", 0);
		}

		private void Start()
		{
			if (PlayerPrefs.GetInt("VRPlayer", 0) == 0)
			{
				playPanorama = false;
			}
			if (playPanorama)
			{
				if (customPath)
				{
					fullPath = customPathFolder + Folder + "/";
				}
				if (!customPath)
				{
					fullPath = Path.GetFullPath($"{Folder}/");
				}
				vrPlayer = (GameObject)UnityEngine.Object.Instantiate(Resources.Load("VRVideoPlayerRig"));
				videoObject = vrPlayer.GetComponent<VideoPlayer>();
				videoObject.url = "file://" + fullPath + Folder + "_360_TB.mp4";
				UnityEngine.Debug.Log("file://" + fullPath + Folder + "_360_TB.mp4");
				videoMat = vrPlayer.GetComponent<MeshRenderer>().sharedMaterial;
				videoMat.SetTexture("_MainTex", videoObject.targetMaterialRenderer.material.mainTexture);
			}
			else
			{
				if (panoramaType == VRModeList.EquidistantMono)
				{
					hQ = false;
				}
				if (customPath)
				{
					fullPath = customPathFolder + Folder + "/";
				}
				if (!customPath)
				{
					fullPath = Path.GetFullPath($"{Folder}/");
				}
				Application.runInBackground = true;
				StartFrame = Time.frameCount;
				if (disableTracking)
				{
					base.gameObject.GetComponent<Camera>().stereoTargetEye = StereoTargetEyeMask.None;
				}
				if (mute)
				{
					AudioListener.volume = 0f;
				}
				if (depth)
				{
					depthBufferSize = 24;
				}
				else
				{
					depthBufferSize = 0;
				}
				if (captureType == VRCaptureList.AnimationCapture || captureType == VRCaptureList.VRPanoramaRT)
				{
					if (captureAudio)
					{
						if (AudioSettings.speakerMode == AudioSpeakerMode.Quad)
						{
							ambisonicsSupportTest = true;
						}
						if (AudioSettings.speakerMode == AudioSpeakerMode.Mono)
						{
							achannels = 1;
						}
						else if (AudioSettings.speakerMode == AudioSpeakerMode.Stereo)
						{
							achannels = 2;
						}
						else if (AudioSettings.speakerMode == AudioSpeakerMode.Quad)
						{
							achannels = 4;
						}
						else if (AudioSettings.speakerMode == AudioSpeakerMode.Surround)
						{
							achannels = 5;
						}
						else if (AudioSettings.speakerMode == AudioSpeakerMode.Mode5point1)
						{
							achannels = 6;
						}
						else if (AudioSettings.speakerMode == AudioSpeakerMode.Mode7point1)
						{
							achannels = 8;
						}
						UnityEngine.Debug.Log("channels" + (int)AudioSettings.speakerMode + achannels);
						outputRate = AudioSettings.outputSampleRate;
						AudioSettings.GetDSPBufferSize(out bufferSize, out numBuffers);
						AudioListener.volume = volume;
						Directory.CreateDirectory(fullPath);
						StartWriting(fullPath + "/" + Folder + ".wav");
						recOutput = true;
						MonoBehaviour.print("rec start");
					}
					else if (panoramaType == VRModeList.VideoCapture)
					{
						VideoRenderPrepare();
					}
					else
					{
						PreparePano();
						RenderPano();
					}
				}
			}
			if (recordRT)
			{
				camCaptureComponent = panoramaCam.GetComponent<CameraCapture>();
				camCaptureComponent.enabled = true;
				camCaptureComponent._setResolution = true;
				camCaptureComponent._width = resolution;
				camCaptureComponent._height = resolutionH;
				camCaptureComponent._frameRate = FPS;
				camCaptureComponent._recordLength = videoLenght;
			}
		}

		public void RenderPano()
		{
			if (panoramaType == VRModeList.EquidistantStereo || panoramaType == VRModeList.EquidistantStereoSBS)
			{
				screenShot = new Texture2D(resolution, resolutionH, texFormat, mipChain: false);
				if (hQ)
				{
					screenShotHQ = new Texture2D(resolution, resolutionH, texFormat, mipChain: false);
				}
			}
			else
			{
				screenShot = new Texture2D(resolution, resolutionH, texFormat, mipChain: false);
			}
			float value = resolutionH;
			float value2 = resolution;
			flTex = RenderTexture.GetTemporary(qualityTemp, qualityTemp, depthBufferSize, renderTexFormat);
			llTex = RenderTexture.GetTemporary(qualityTemp, qualityTemp, depthBufferSize, renderTexFormat);
			rlTex = RenderTexture.GetTemporary(qualityTemp, qualityTemp, depthBufferSize, renderTexFormat);
			dlTex = RenderTexture.GetTemporary(qualityTemp, qualityTemp, depthBufferSize, renderTexFormat);
			blTex = RenderTexture.GetTemporary(qualityTemp, qualityTemp, depthBufferSize, renderTexFormat);
			tlTex = RenderTexture.GetTemporary(qualityTemp, qualityTemp, depthBufferSize, renderTexFormat);
			FL = Resources.Load("RTs/Materials/FL") as Material;
			FR = Resources.Load("RTs/Materials/FR") as Material;
			LL = Resources.Load("RTs/Materials/LL") as Material;
			LR = Resources.Load("RTs/Materials/LR") as Material;
			RL = Resources.Load("RTs/Materials/RL") as Material;
			RR = Resources.Load("RTs/Materials/RR") as Material;
			DL = Resources.Load("RTs/Materials/DL") as Material;
			DR = Resources.Load("RTs/Materials/DR") as Material;
			BL = Resources.Load("RTs/Materials/BL") as Material;
			BR = Resources.Load("RTs/Materials/BR") as Material;
			TL = Resources.Load("RTs/Materials/TL") as Material;
			TR = Resources.Load("RTs/Materials/TR") as Material;
			HQMat = Resources.Load("RTs/Materials/hQScanline") as Material;
			camLL.targetTexture = llTex;
			camRL.targetTexture = rlTex;
			camTL.targetTexture = tlTex;
			if (captureAngle == VRCaptureAngle._360)
			{
				camBL.targetTexture = blTex;
			}
			camFL.targetTexture = flTex;
			camDL.targetTexture = dlTex;
			FL.SetFloat("_U", value);
			FR.SetFloat("_U", value);
			LL.SetFloat("_U", value);
			LR.SetFloat("_U", value);
			RL.SetFloat("_U", value);
			RR.SetFloat("_U", value);
			DL.SetFloat("_U", value);
			DR.SetFloat("_U", value);
			BL.SetFloat("_U", value);
			BR.SetFloat("_U", value);
			TL.SetFloat("_U", value);
			TR.SetFloat("_U", value);
			FL.SetFloat("_V", value2);
			FR.SetFloat("_V", value2);
			LL.SetFloat("_V", value2);
			LR.SetFloat("_V", value2);
			RL.SetFloat("_V", value2);
			RR.SetFloat("_V", value2);
			DL.SetFloat("_V", value2);
			DR.SetFloat("_V", value2);
			BL.SetFloat("_V", value2);
			BR.SetFloat("_V", value2);
			TL.SetFloat("_V", value2);
			TR.SetFloat("_V", value2);
			if (panoramaType == VRModeList.EquidistantStereo || panoramaType == VRModeList.EquidistantStereoSBS)
			{
				dlxTex = RenderTexture.GetTemporary(qualityTemp, qualityTemp, depthBufferSize, renderTexFormat);
				drxTex = RenderTexture.GetTemporary(qualityTemp, qualityTemp, depthBufferSize, renderTexFormat);
				tlxTex = RenderTexture.GetTemporary(qualityTemp, qualityTemp, depthBufferSize, renderTexFormat);
				trxTex = RenderTexture.GetTemporary(qualityTemp, qualityTemp, depthBufferSize, renderTexFormat);
				frTex = RenderTexture.GetTemporary(qualityTemp, qualityTemp, depthBufferSize, renderTexFormat);
				lrTex = RenderTexture.GetTemporary(qualityTemp, qualityTemp, depthBufferSize, renderTexFormat);
				rrTex = RenderTexture.GetTemporary(qualityTemp, qualityTemp, depthBufferSize, renderTexFormat);
				drTex = RenderTexture.GetTemporary(qualityTemp, qualityTemp, depthBufferSize, renderTexFormat);
				trTex = RenderTexture.GetTemporary(qualityTemp, qualityTemp, depthBufferSize, renderTexFormat);
				if (captureAngle == VRCaptureAngle._360)
				{
					brTex = RenderTexture.GetTemporary(qualityTemp, qualityTemp, depthBufferSize, renderTexFormat);
				}
				FL.SetTexture("_Main", flTex);
				FR.SetTexture("_Main", frTex);
				LL.SetTexture("_Main", llTex);
				LR.SetTexture("_Main", lrTex);
				RL.SetTexture("_Main", rlTex);
				RR.SetTexture("_Main", rrTex);
				DL.SetTexture("_Main", dlTex);
				DR.SetTexture("_Main", drTex);
				if (captureAngle == VRCaptureAngle._360)
				{
					BL.SetTexture("_Main", blTex);
					BR.SetTexture("_Main", brTex);
				}
				TL.SetTexture("_Main", tlTex);
				TR.SetTexture("_Main", trTex);
				TL.SetTexture("_MainR", trTex);
				TR.SetTexture("_MainR", tlTex);
				DL.SetTexture("_MainR", drTex);
				DR.SetTexture("_MainR", dlTex);
				TL.SetTexture("_MainX", trxTex);
				TR.SetTexture("_MainX", tlxTex);
				TL.SetTexture("_MainRX", tlxTex);
				TR.SetTexture("_MainRX", trxTex);
				DL.SetTexture("_MainX", dlxTex);
				DR.SetTexture("_MainX", drxTex);
				DL.SetTexture("_MainRX", drxTex);
				DR.SetTexture("_MainRX", dlxTex);
				camLR.targetTexture = lrTex;
				camRR.targetTexture = rrTex;
				camTR.targetTexture = trTex;
				if (captureAngle == VRCaptureAngle._360)
				{
					camBR.targetTexture = brTex;
				}
				camFR.targetTexture = frTex;
				camDR.targetTexture = drTex;
				camDRX.targetTexture = drxTex;
				camDLX.targetTexture = dlxTex;
				camTRX.targetTexture = trxTex;
				camTLX.targetTexture = tlxTex;
			}
			else
			{
				FL.SetTexture("_Main", flTex);
				FR.SetTexture("_Main", flTex);
				LL.SetTexture("_Main", llTex);
				LR.SetTexture("_Main", llTex);
				RL.SetTexture("_Main", rlTex);
				RR.SetTexture("_Main", rlTex);
				DL.SetTexture("_Main", dlTex);
				DR.SetTexture("_Main", dlTex);
				if (captureAngle == VRCaptureAngle._360)
				{
					BL.SetTexture("_Main", blTex);
					BR.SetTexture("_Main", blTex);
				}
				TL.SetTexture("_Main", tlTex);
				TR.SetTexture("_Main", tlTex);
				TL.SetTexture("_MainR", tlTex);
				DL.SetTexture("_MainR", dlTex);
				TL.SetTexture("_MainX", tlTex);
				TL.SetTexture("_MainRX", tlTex);
				DL.SetTexture("_MainX", dlTex);
				DL.SetTexture("_MainRX", dlTex);
				TR.SetTexture("_MainR", tlTex);
				DR.SetTexture("_MainR", dlTex);
				TR.SetTexture("_MainX", tlTex);
				TR.SetTexture("_MainRX", tlTex);
				DR.SetTexture("_MainX", dlTex);
				DR.SetTexture("_MainRX", dlTex);
			}
			if (Application.isPlaying && captureType != VRCaptureList.VRPanoramaRT)
			{
				Time.captureFramerate = FPS;
				Directory.CreateDirectory(fullPath);
			}
		}

		private void Update()
		{
			if (playPanorama)
			{
				playPanorama = true;
				videoMat.SetTexture("_MainTex", videoObject.texture);
			}
			else
			{
				if (captureType != 0 && captureType != VRCaptureList.VRPanoramaRT)
				{
					return;
				}
				if (panoramaType == VRModeList.EquidistantStereo || panoramaType == VRModeList.EquidistantStereoSBS)
				{
					cloneCamFL.transform.LookAt(camfl.transform.position + camfl.transform.forward * EnvironmentDistance, camfl.transform.up);
					cloneCamFR.transform.LookAt(camfl.transform.position + camfl.transform.forward * EnvironmentDistance, camfl.transform.up);
					cloneCamLL.transform.LookAt(camll.transform.position + camll.transform.forward * EnvironmentDistance, camll.transform.up);
					cloneCamLR.transform.LookAt(camll.transform.position + camll.transform.forward * EnvironmentDistance, camll.transform.up);
					cloneCamRL.transform.LookAt(camrl.transform.position + camrl.transform.forward * EnvironmentDistance, camrl.transform.up);
					cloneCamRR.transform.LookAt(camrl.transform.position + camrl.transform.forward * EnvironmentDistance, camrl.transform.up);
					if (captureAngle == VRCaptureAngle._360)
					{
						cloneCamBL.transform.LookAt(cambl.transform.position + cambl.transform.forward * EnvironmentDistance, cambl.transform.up);
						cloneCamBR.transform.LookAt(cambl.transform.position + cambl.transform.forward * EnvironmentDistance, cambl.transform.up);
					}
					cloneCamTL.transform.LookAt(camtl.transform.position + camtl.transform.forward * EnvironmentDistance, camtl.transform.up);
					cloneCamTR.transform.LookAt(camtl.transform.position + camtl.transform.forward * EnvironmentDistance, camtl.transform.up);
					cloneCamDL.transform.LookAt(camdl.transform.position + camdl.transform.forward * EnvironmentDistance, camdl.transform.up);
					cloneCamDR.transform.LookAt(camdl.transform.position + camdl.transform.forward * EnvironmentDistance, camdl.transform.up);
					cloneCamTLX.transform.LookAt(camtl.transform.position + camtl.transform.forward * EnvironmentDistance, camtl.transform.up);
					cloneCamTRX.transform.LookAt(camtl.transform.position + camtl.transform.forward * EnvironmentDistance, camtl.transform.up);
					cloneCamDLX.transform.LookAt(camdl.transform.position + camdl.transform.forward * EnvironmentDistance, camdl.transform.up);
					cloneCamDRX.transform.LookAt(camdl.transform.position + camdl.transform.forward * EnvironmentDistance, camdl.transform.up);
				}
				if (!captureAudio && Time.frameCount - StartFrame == NumberOfFramesToRender - 2)
				{
					_ = mailme;
				}
				if (Input.GetKeyDown(KeyCode.Escape))
				{
					MonoBehaviour.print("Render Aborted");
					base.gameObject.GetComponent<VRCapture>().enabled = false;
					UnityEngine.Object.Destroy(renderPanorama);
					UnityEngine.Object.Destroy(panoramaCam);
					UnityEngine.Object.Destroy(rig);
					Time.captureFramerate = 0;
				}
			}
		}

		private void LateUpdate()
		{
			if (hQ && captureType == VRCaptureList.VRPanoramaRT)
			{
				screenShot = GetScreenshotHQ(eye: true);
			}
			if (playPanorama)
			{
				playPanorama = true;
				return;
			}
			if (captureType == VRCaptureList.AnimationCapture || captureType == VRCaptureList.VRPanoramaRT)
			{
				if (captureAudio)
				{
					if (Time.timeSinceLevelLoad > (float)(NumberOfFramesToRender / FPS))
					{
						recOutput = false;
						WriteHeader();
						QuitEditor();
					}
					return;
				}
				if (panoramaType == VRModeList.VideoCapture)
				{
					RenderVideo();
					return;
				}
				if (alignPanoramaWithHorizont)
				{
					Vector3 euler = new Vector3(0f, base.gameObject.transform.rotation.eulerAngles.y, 0f);
					base.gameObject.transform.rotation = Quaternion.Euler(euler);
				}
				if (captureType != VRCaptureList.VRPanoramaRT)
				{
					RenderVRPanorama();
					CounterPost();
				}
				return;
			}
			if (Input.GetKeyDown(captureKey) && !waitRenderFinish)
			{
				step = 1;
			}
			NumberOfFramesToRender = 1000000000;
			if (step == 3)
			{
				UnityEngine.Object.Destroy(renderPanorama);
				UnityEngine.Object.Destroy(panoramaCam);
				UnityEngine.Object.Destroy(rig);
				UnityEngine.Object.Destroy(flTex);
				UnityEngine.Object.Destroy(llTex);
				UnityEngine.Object.Destroy(rlTex);
				UnityEngine.Object.Destroy(dlTex);
				UnityEngine.Object.Destroy(blTex);
				UnityEngine.Object.Destroy(tlTex);
				UnityEngine.Object.Destroy(rt);
				UnityEngine.Object.Destroy(screenShot);
				UnityEngine.Object.Destroy(screenShotHQ);
				if (panoramaType == VRModeList.EquidistantStereo || panoramaType == VRModeList.EquidistantStereoSBS)
				{
					UnityEngine.Object.Destroy(tlxTex);
					UnityEngine.Object.Destroy(trxTex);
					UnityEngine.Object.Destroy(dlxTex);
					UnityEngine.Object.Destroy(drxTex);
					UnityEngine.Object.Destroy(frTex);
					UnityEngine.Object.Destroy(lrTex);
					UnityEngine.Object.Destroy(rrTex);
					UnityEngine.Object.Destroy(drTex);
					if (captureAngle == VRCaptureAngle._360)
					{
						UnityEngine.Object.Destroy(brTex);
						UnityEngine.Object.Destroy(trTex);
					}
				}
				cam.GetComponent<Camera>().fieldOfView = restoreFOV;
				string text = Application.dataPath + "\\VRPanorama\\StreamingAssets\\";
				Process process = new Process();
				process.StartInfo.FileName = text + "exiftool";
				process.StartInfo.Arguments = "-overwrite_original -ProjectionType=\"equirectangular\" \"" + fullPath + string.Format(_prefix + "{1:D05}" + timestamp + ".jpg", Folder, Time.frameCount - StartFrame - 2) + "\"";
				process.StartInfo.UseShellExecute = false;
				process.StartInfo.CreateNoWindow = true;
				process.StartInfo.RedirectStandardOutput = true;
				process.Start();
				UnityEngine.Debug.Log(process.StandardOutput.ReadToEnd());
				process.WaitForExit();
				step = 0;
				waitRenderFinish = false;
			}
			if (step == 2)
			{
				if (alignPanoramaWithHorizont)
				{
					Vector3 euler2 = new Vector3(0f, base.gameObject.transform.rotation.eulerAngles.y, 0f);
					base.gameObject.transform.rotation = Quaternion.Euler(euler2);
				}
				RenderVRPanorama();
				MonoBehaviour.print("Panorama Captured");
				Time.captureFramerate = 0;
				step = 3;
			}
			if (step == 1)
			{
				waitRenderFinish = true;
				PreparePano();
				RenderPano();
				step++;
			}
		}

		public void RenderVRPanorama()
		{
			if (captureType != VRCaptureList.VRPanoramaRT && Time.frameCount - StartFrame < NumberOfFramesToRender && Time.frameCount - StartFrame > 0 && Time.frameCount - StartFrame > renderFromFrame)
			{
				SaveScreenshot();
			}
		}

		public void RenderVideo()
		{
			float num = (float)NumberOfFramesToRender / (float)FPS;
			int num2 = (int)num / 60;
			int num3 = (int)num % 60;
			sequenceLength = num2 + " min. " + num3 + " sec. ";
			if (Time.frameCount - StartFrame < NumberOfFramesToRender)
			{
				RenderInfo = "Rendering";
				if (Time.frameCount - StartFrame > 0)
				{
					SaveScreenshotVideo();
				}
				remainingTime = Time.realtimeSinceStartup / (float)(Time.frameCount - StartFrame) * (float)(NumberOfFramesToRender - (Time.frameCount - StartFrame));
				minutesRemain = (int)remainingTime / 60;
				secondsRemain = (int)remainingTime % 60;
				return;
			}
			ClearBar();
			if (openDestinationFolder)
			{
				Process.Start(new ProcessStartInfo
				{
					FileName = fullPath,
					UseShellExecute = true,
					Verb = "open"
				});
			}
			if (encodeToMp4)
			{
				string text = Application.dataPath + "\\VRPanorama\\StreamingAssets\\";
				if (File.Exists(fullPath + Folder + ".wav"))
				{
					Process.Start(text + "ffmpeg", " -f image2 -framerate " + FPS + " -i \"" + fullPath + _prefix + "%05d" + formatString + " -i \"" + fullPath + Folder + ".wav\" -r " + FPS + " -vcodec libx264 -y -pix_fmt yuv420p -b:v " + Mp4Bitrate + "k -c:a aac -strict experimental -b:a 192k -shortest  \"" + fullPath + Folder + ".mp4\"");
				}
				else
				{
					Process.Start(text + "ffmpeg", " -f image2 -framerate " + FPS + " -i \"" + fullPath + _prefix + "%05d" + formatString + " -r " + FPS + " -vcodec libx264 -y -pix_fmt yuv420p -b:v " + Mp4Bitrate + "k \"" + fullPath + Folder + ".mp4\"");
				}
			}
			QuitEditor();
		}

		private Texture2D FlipTexture(Texture2D original)
		{
			Texture2D texture2D = new Texture2D(original.width, original.height, TextureFormat.RGBAHalf, mipChain: false);
			int width = original.width;
			int height = original.height;
			for (int i = 0; i < width; i++)
			{
				for (int j = 0; j < height; j++)
				{
					texture2D.SetPixel(i, height - j - 1, original.GetPixel(i, j));
				}
			}
			texture2D.Apply();
			return texture2D;
		}

		public void SaveScreenshot()
		{
			if (ImageFormatType == VRFormatList.JPG)
			{
				if (captureType == VRCaptureList.StillImage)
				{
					timestamp = DateTime.Now.Ticks + "Screenshot";
				}
				string filePathd = string.Format(fullPath + _prefix + "{1:D05}" + timestamp + ".jpg", Folder, Time.frameCount - StartFrame - 1);
				formatString = ".jpg\"";
				if (hQ)
				{
					screenShot = GetScreenshotHQ(eye: true);
				}
				else
				{
					screenShot = GetScreenshot(eye: true);
				}
				StartCoroutine(SaveFileJPG(filePathd, screenShot, jpgQuality));
			}
			else if (ImageFormatType == VRFormatList.PNG)
			{
				if (hQ)
				{
					screenShot = GetScreenshotHQ(eye: true);
				}
				else
				{
					screenShot = GetScreenshot(eye: true);
				}
				if (captureType == VRCaptureList.StillImage)
				{
					timestamp = DateTime.Now.Ticks + "Screenshot";
				}
				string filePathd2 = string.Format(fullPath + _prefix + "{1:D05}" + timestamp + ".png", Folder, Time.frameCount - StartFrame - 1);
				formatString = ".png\"";
				StartCoroutine(SaveFilePNG(filePathd2, screenShot));
			}
			else if (ImageFormatType == VRFormatList.Direct)
			{
				if (hQ)
				{
					screenShot = GetScreenshotHQ(eye: true);
				}
				else
				{
					screenShot = GetScreenshot(eye: true);
				}
				if (captureType == VRCaptureList.StillImage)
				{
					timestamp = DateTime.Now.Ticks + "Screenshot";
				}
				string.Format(fullPath + _prefix + "{1:D05}" + timestamp + ".png", Folder, Time.frameCount - StartFrame - 1);
				formatString = ".png\"";
			}
			else if (ImageFormatType == VRFormatList.EXR_HDRI)
			{
				if (hQ)
				{
					screenShot = GetScreenshotHQ(eye: true);
				}
				else
				{
					screenShot = GetScreenshot(eye: true);
				}
				if (captureType == VRCaptureList.StillImage)
				{
					timestamp = DateTime.Now.Ticks + "Screenshot";
				}
				string filePathd3 = string.Format(fullPath + _prefix + "{1:D05}" + timestamp + ".exr", Folder, Time.frameCount - StartFrame - 1);
				formatString = ".exr\"";
				StartCoroutine(SaveFileEXRNew(filePathd3, screenShot));
			}
		}

		private static IEnumerator SaveFileJPG(string filePathd, Texture2D SShot, int jpg)
		{
			yield return null;
			byte[] bytes = SShot.EncodeToJPG(jpg);
			File.WriteAllBytes(filePathd, bytes);
		}

		private static IEnumerator SaveFilePNG(string filePathd, Texture2D SShot)
		{
			yield return null;
			byte[] bytes = SShot.EncodeToPNG();
			File.WriteAllBytes(filePathd, bytes);
		}

		private static IEnumerator SaveFileEXRNew(string filePathd, Texture2D SShot)
		{
			yield return null;
			byte[] bytes = SShot.EncodeToEXR();
			File.WriteAllBytes(filePathd, bytes);
		}

		private static IEnumerator SaveFileEXR(string filePathd, Texture2D SShot)
		{
			yield return null;
			byte[] bytes = SShot.EncodeToPNG();
			File.WriteAllBytes(filePathd, bytes);
		}

		public Texture2D GetScreenshot(bool eye)
		{
			if (panoramaType == VRModeList.EquidistantStereo || panoramaType == VRModeList.EquidistantStereoSBS)
			{
				if (panoramaType == VRModeList.EquidistantStereo)
				{
					rt = RenderTexture.GetTemporary(resolution, resolutionH / 2, 0, renderTexFormat);
				}
				if (panoramaType == VRModeList.EquidistantStereoSBS)
				{
					rt = RenderTexture.GetTemporary(resolution / 2, resolutionH, 0, renderTexFormat);
				}
			}
			else
			{
				rt = RenderTexture.GetTemporary(resolution, resolutionH, 0, renderTexFormat);
			}
			if (eye)
			{
				if (panoramaType == VRModeList.EquidistantStereo)
				{
					GameObject.Find("QuadL").transform.localPosition = new Vector3(0f, 0f, 1.5f);
					GameObject.Find("QuadR").transform.localPosition = new Vector3(0f, 0f, 6.5f);
				}
				if (panoramaType == VRModeList.EquidistantStereoSBS)
				{
					GameObject.Find("QuadL").transform.localPosition = new Vector3(0f, 0f, 6.5f);
					GameObject.Find("QuadR").transform.localPosition = new Vector3(0f, 0f, 1.5f);
				}
			}
			Camera component = panoramaCam.GetComponent<Camera>();
			component.targetTexture = rt;
			component.Render();
			RenderTexture.active = rt;
			if (panoramaType == VRModeList.EquidistantStereo || panoramaType == VRModeList.EquidistantStereoSBS)
			{
				if (panoramaType == VRModeList.EquidistantStereo)
				{
					screenShot.ReadPixels(new Rect(0f, 0f, resolution, resolutionH / 2), 0, 0);
				}
				if (panoramaType == VRModeList.EquidistantStereoSBS)
				{
					screenShot.ReadPixels(new Rect(0f, 0f, resolution / 2, resolutionH), 0, 0);
				}
				if (panoramaType == VRModeList.EquidistantStereo)
				{
					GameObject.Find("QuadR").transform.localPosition = new Vector3(0f, 0f, 1.5f);
					GameObject.Find("QuadL").transform.localPosition = new Vector3(0f, 0f, 6.5f);
				}
				if (panoramaType == VRModeList.EquidistantStereoSBS)
				{
					GameObject.Find("QuadR").transform.localPosition = new Vector3(0f, 0f, 6.5f);
					GameObject.Find("QuadL").transform.localPosition = new Vector3(0f, 0f, 1.5f);
				}
				component.targetTexture = rt;
				component.Render();
				RenderTexture.active = rt;
				if (panoramaType == VRModeList.EquidistantStereo)
				{
					screenShot.ReadPixels(new Rect(0f, 0f, resolution, resolutionH / 2), 0, resolutionH / 2);
				}
				if (panoramaType == VRModeList.EquidistantStereoSBS)
				{
					screenShot.ReadPixels(new Rect(0f, 0f, resolution, resolutionH), resolution / 2, 0);
				}
				RenderTexture.active = null;
				component.targetTexture = null;
				RenderTexture.ReleaseTemporary(rt);
			}
			else
			{
				screenShot.ReadPixels(new Rect(0f, 0f, resolution, resolutionH), 0, 0);
				RenderTexture.active = null;
				component.targetTexture = null;
				RenderTexture.ReleaseTemporary(rt);
			}
			return screenShot;
		}

		public Texture2D GetScreenshotHQ(bool eye)
		{
			Shader.SetGlobalFloat("hQSteps", steps);
			RenderTexture temporary = RenderTexture.GetTemporary(resolution, resolutionH, 0, renderTexFormat);
			Vector3 position = base.gameObject.transform.position;
			Quaternion rotation = base.gameObject.transform.rotation;
			if (hQ)
			{
				Shader.SetGlobalFloat("scanlineSoft", smoothing);
				if (panoramaType == VRModeList.EquidistantStereo || panoramaType == VRModeList.EquidistantStereoSBS)
				{
					if (panoramaType == VRModeList.EquidistantStereo)
					{
						rt = RenderTexture.GetTemporary(resolution, resolutionH / 2, 0, renderTexFormat);
						Shader.SetGlobalFloat("sbs", 1f);
					}
					if (panoramaType == VRModeList.EquidistantStereoSBS)
					{
						rt = RenderTexture.GetTemporary(resolution / 2, resolutionH, 0, renderTexFormat);
						Shader.SetGlobalFloat("sbs", 2f);
					}
				}
				else
				{
					rt = RenderTexture.GetTemporary(resolution, resolutionH, 0, renderTexFormat);
				}
				Camera component = panoramaCam.GetComponent<Camera>();
				Camera component2 = GameObject.Find("CameraHQ").GetComponent<Camera>();
				for (int i = 0; i < steps; i++)
				{
					base.gameObject.transform.Rotate(0f, 360f / (float)steps / 4f, 0f);
					camLL.Render();
					camRL.Render();
					camTL.Render();
					camBL.Render();
					camFL.Render();
					camDL.Render();
					camLR.Render();
					camRR.Render();
					camTR.Render();
					camBR.Render();
					camFR.Render();
					camDR.Render();
					camDRX.Render();
					camDLX.Render();
					camTRX.Render();
					camTLX.Render();
					if (panoramaType == VRModeList.EquidistantStereo)
					{
						GameObject.Find("QuadR").transform.localPosition = new Vector3(0f, 0f, 1.5f);
						GameObject.Find("QuadL").transform.localPosition = new Vector3(0f, 0f, 6.5f);
					}
					if (panoramaType == VRModeList.EquidistantStereoSBS)
					{
						GameObject.Find("QuadR").transform.localPosition = new Vector3(0f, 0f, 6.5f);
						GameObject.Find("QuadL").transform.localPosition = new Vector3(0f, 0f, 1.5f);
					}
					if (eye)
					{
						if (panoramaType == VRModeList.EquidistantStereo)
						{
							GameObject.Find("QuadR").transform.localPosition = new Vector3(0.25f / (float)steps * (float)i, 0f, 1.5f);
							GameObject.Find("QuadL").transform.localPosition = new Vector3(0.25f / (float)steps * (float)i, 0f, 6.5f);
						}
						if (panoramaType == VRModeList.EquidistantStereoSBS)
						{
							GameObject.Find("QuadL").transform.localPosition = new Vector3(0.25f / (float)steps * (float)i, 0f, 6.5f);
							GameObject.Find("QuadR").transform.localPosition = new Vector3(0.25f / (float)steps * (float)i, 0f, 1.5f);
						}
					}
					component.targetTexture = rt;
					component.Render();
					RenderTexture.active = rt;
					if (panoramaType == VRModeList.EquidistantStereo || panoramaType == VRModeList.EquidistantStereoSBS)
					{
						if (panoramaType == VRModeList.EquidistantStereo)
						{
							screenShot.ReadPixels(new Rect(0f, 0f, resolution, resolutionH / 2), 0, 0);
						}
						if (panoramaType == VRModeList.EquidistantStereoSBS)
						{
							screenShot.ReadPixels(new Rect(0f, 0f, resolution / 2, resolutionH), 0, 0);
						}
						GameObject.Find("QuadL").transform.localPosition = new Vector3(0.25f / (float)steps * (float)i, 0f, 1.5f);
						GameObject.Find("QuadR").transform.localPosition = new Vector3(0.25f / (float)steps * (float)i, 0f, 6.5f);
						component.targetTexture = rt;
						component.Render();
						RenderTexture.active = rt;
						if (panoramaType == VRModeList.EquidistantStereo)
						{
							screenShot.ReadPixels(new Rect(0f, 0f, resolution, resolutionH), 0, resolutionH / 2);
						}
						if (panoramaType == VRModeList.EquidistantStereoSBS)
						{
							screenShot.ReadPixels(new Rect(0f, 0f, resolution, resolutionH), resolution / 2, 0);
						}
						screenShot.Apply();
						Shader.SetGlobalFloat("hQStep", steps - i);
						HQMat.SetTexture("_Main", screenShot);
						component2.targetTexture = temporary;
						RenderTexture.active = temporary;
						component2.Render();
						component.targetTexture = null;
						component2.targetTexture = null;
					}
				}
			}
			base.gameObject.transform.position = position;
			base.gameObject.transform.rotation = rotation;
			screenShotHQ.ReadPixels(new Rect(0f, 0f, resolution, resolutionH), 0, 0);
			RenderTexture.active = null;
			RenderTexture.ReleaseTemporary(rt);
			RenderTexture.ReleaseTemporary(temporary);
			return screenShotHQ;
		}

		public void SendEmail()
		{
			MailMessage mailMessage = new MailMessage();
			mailMessage.From = new MailAddress(_mailfrom);
			mailMessage.To.Add(_mailto);
			mailMessage.Subject = "VR Panorama Rendered";
			mailMessage.Body = "Congratulations, VR panorama has finished rendering panorama named" + Folder;
			SmtpClient obj = new SmtpClient("smtp.gmail.com")
			{
				Port = 587,
				Credentials = new NetworkCredential(_mailfrom, _pass),
				EnableSsl = true
			};
			ServicePointManager.ServerCertificateValidationCallback = (object s, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors) => true;
			obj.Send(mailMessage);
			UnityEngine.Debug.Log("Mail sent");
		}

		public Texture2D GetVideoScreenshot()
		{
			Camera main = Camera.main;
			if (main == null)
			{
				UnityEngine.Debug.LogError("There are no cameras with MAIN CAMERA tag in scene. Please assign MAIN CAMERA tag to your camera");
			}
			main.targetTexture = unfilteredRt;
			main.Render();
			RenderTexture.active = unfilteredRt;
			VRAA.mainTexture = unfilteredRt;
			VRAA.SetInt("_U", resolution * 2);
			VRAA.SetInt("_V", resolutionH * 2);
			Graphics.Blit(unfilteredRt, rt, VRAA, -1);
			screenShot.ReadPixels(new Rect(0f, 0f, resolution, resolutionH), 0, 0);
			return screenShot;
		}

		public void VideoRenderPrepare()
		{
			VRAA = Resources.Load("Materials/VRAA") as Material;
			unfilteredRt = new RenderTexture(resolution * 4 / 32 * renderQuality, resolutionH * 4 / 32 * renderQuality, 24, RenderTextureFormat.DefaultHDR, RenderTextureReadWrite.Default);
			if (ImageFormatType == VRFormatList.EXR_HDRI)
			{
				rt = new RenderTexture(resolution, resolutionH, 0, RenderTextureFormat.DefaultHDR, RenderTextureReadWrite.Linear);
				screenShot = new Texture2D(resolution, resolutionH, TextureFormat.RGBAHalf, mipChain: false);
			}
			else
			{
				rt = new RenderTexture(resolution, resolutionH, 0, RenderTextureFormat.Default, RenderTextureReadWrite.Default);
				screenShot = new Texture2D(resolution, resolutionH, TextureFormat.ARGB32, mipChain: false);
			}
			if (Application.isPlaying && captureType != VRCaptureList.VRPanoramaRT)
			{
				Time.captureFramerate = FPS;
				Directory.CreateDirectory(fullPath);
			}
			else
			{
				ClearBar();
			}
		}

		public void SaveScreenshotVideo()
		{
			Texture2D videoScreenshot = GetVideoScreenshot();
			if (ImageFormatType == VRFormatList.JPG)
			{
				byte[] bytes = videoScreenshot.EncodeToJPG(jpgQuality);
				string text = string.Format(fullPath + _prefix + "{1:D05}.jpg", Folder, Time.frameCount - StartFrame - 1);
				formatString = ".jpg\"";
				MonoBehaviour.print(text);
				File.WriteAllBytes(text, bytes);
			}
			else if (ImageFormatType == VRFormatList.PNG)
			{
				byte[] bytes2 = videoScreenshot.EncodeToPNG();
				string path = string.Format(fullPath + _prefix + "{1:D05}.png", Folder, Time.frameCount - StartFrame - 1);
				formatString = ".png\"";
				File.WriteAllBytes(path, bytes2);
			}
			else if (ImageFormatType == VRFormatList.EXR_HDRI)
			{
				Texture2D texture2D = FlipTexture(videoScreenshot);
				EXRArray = texture2D.GetPixels(0, 0, resolution, resolutionH);
				global::MiniEXR.MiniEXR.MiniEXRWrite(string.Format(fullPath + _prefix + "{1:D05}.exr", Folder, Time.frameCount - StartFrame - 1), Convert.ToUInt32(resolution), Convert.ToUInt32(resolutionH), EXRArray);
			}
		}

		public void RenderStaticVRPanorama()
		{
			SaveScreenshot();
		}

		public void CounterPost()
		{
			float num = (float)NumberOfFramesToRender / (float)FPS;
			int num2 = (int)num / 60;
			int num3 = (int)num % 60;
			sequenceLength = num2 + " min. " + num3 + " sec. ";
			if (Time.frameCount - StartFrame >= NumberOfFramesToRender)
			{
				return;
			}
			remainingTime = Time.realtimeSinceStartup / (float)(Time.frameCount - StartFrame) * (float)(NumberOfFramesToRender - (Time.frameCount - StartFrame));
			minutesRemain = (int)remainingTime / 60;
			secondsRemain = (int)remainingTime % 60;
			VRPanoInterface component = renderPanorama.GetComponent<VRPanoInterface>();
			component.progressInd = (float)(Time.frameCount - StartFrame) / (float)NumberOfFramesToRender;
			component.timeCounterText = " Remaining time: " + minutesRemain + " min. " + secondsRemain + " sec.";
			component.height = resolutionH;
			component.width = resolution;
			if (panoramaType == VRModeList.EquidistantStereo)
			{
				component.height = resolutionH / 2;
				component.width = resolution;
			}
			if (panoramaType == VRModeList.EquidistantStereoSBS)
			{
				component.height = resolutionH;
				component.width = resolution / 2;
			}
			if (openDestinationFolder)
			{
				Process.Start(new ProcessStartInfo
				{
					FileName = fullPath,
					UseShellExecute = true,
					Verb = "open"
				});
			}
			if (encodeToMp4)
			{
				string text = Application.dataPath + "\\VRPanorama\\StreamingAssets\\";
				UnityEngine.Debug.Log(text);
				string text2 = "_360";
				if (panoramaType == VRModeList.EquidistantStereo)
				{
					text2 = "_360_TB";
				}
				if (panoramaType == VRModeList.EquidistantStereoSBS)
				{
					text2 = "_360_SBS";
				}
				if (File.Exists(fullPath + Folder + ".wav"))
				{
					Process.Start(text + "ffmpeg", " -f image2 -framerate " + FPS + " -i \"" + fullPath + _prefix + "%05d" + formatString + " -i \"" + fullPath + Folder + ".wav\" -r " + FPS + " -vcodec libx264 -y -pix_fmt yuv420p -b:v " + Mp4Bitrate + "k -c:a aac -strict experimental -b:a 192k -shortest  \"" + fullPath + Folder + text2 + ".mp4\"");
				}
				else
				{
					Process.Start(text + "ffmpeg", " -f image2 -framerate " + FPS + " -i \"" + fullPath + _prefix + "%05d" + formatString + " -r " + FPS + " -vcodec libx264 -y -pix_fmt yuv420p -b:v " + Mp4Bitrate + "k \"" + fullPath + Folder + text2 + ".mp4\"");
				}
			}
			if (mailme)
			{
				SendEmail();
			}
			UnityEngine.Debug.Log(Time.realtimeSinceStartup);
			QuitEditor();
		}

		public void QuitEditor()
		{
		}

		public void ClearBar()
		{
		}

		private void StartWriting(string name)
		{
			fileStream = new FileStream(name, FileMode.Create);
			byte value = 0;
			for (int i = 0; i < headerSize; i++)
			{
				fileStream.WriteByte(value);
			}
		}

		private void OnAudioFilterRead(float[] data, int channels)
		{
			if (!recOutput)
			{
				return;
			}
			if (ambisonics && ambisonicsSupportTest)
			{
				for (int i = 0; i < data.Length; i += 4)
				{
					float num = data[i];
					float num2 = data[i + 1];
					float num3 = data[i + 2];
					float num4 = data[i + 3];
					float num5 = 0.5f * (num + num3 + num2 + num4);
					float num6 = 0.5f * (num - num3 + (num2 - num4));
					float num7 = 0.5f * (num - num4 - (num2 - num3));
					float num8 = 0.5f * (num - num3 + (num4 - num2));
					data[i] = num5;
					data[i + 1] = num7;
					data[i + 2] = num8;
					data[i + 3] = num6;
				}
			}
			ConvertAndWrite(data);
		}

		private void ConvertAndWrite(float[] dataSource)
		{
			short[] array = new short[dataSource.Length];
			byte[] array2 = new byte[dataSource.Length * 2];
			int num = 32767;
			for (int i = 0; i < dataSource.Length; i++)
			{
				array[i] = (short)(dataSource[i] * (float)num);
				_ = new byte[2];
				BitConverter.GetBytes(array[i]).CopyTo(array2, i * 2);
			}
			fileStream.Write(array2, 0, array2.Length);
		}

		private void WriteHeader()
		{
			fileStream.Seek(0L, SeekOrigin.Begin);
			byte[] bytes = Encoding.UTF8.GetBytes("RIFF");
			fileStream.Write(bytes, 0, 4);
			byte[] bytes2 = BitConverter.GetBytes(fileStream.Length - 8);
			fileStream.Write(bytes2, 0, 4);
			byte[] bytes3 = Encoding.UTF8.GetBytes("WAVE");
			fileStream.Write(bytes3, 0, 4);
			byte[] bytes4 = Encoding.UTF8.GetBytes("fmt ");
			fileStream.Write(bytes4, 0, 4);
			byte[] bytes5 = BitConverter.GetBytes(16);
			fileStream.Write(bytes5, 0, 4);
			ushort value = achannels;
			byte[] bytes6 = BitConverter.GetBytes((ushort)1);
			fileStream.Write(bytes6, 0, 2);
			byte[] bytes7 = BitConverter.GetBytes(value);
			fileStream.Write(bytes7, 0, 2);
			byte[] bytes8 = BitConverter.GetBytes(outputRate);
			fileStream.Write(bytes8, 0, 4);
			byte[] bytes9 = BitConverter.GetBytes(outputRate * 2 * achannels);
			fileStream.Write(bytes9, 0, 4);
			byte[] bytes10 = BitConverter.GetBytes((ushort)(achannels + achannels));
			fileStream.Write(bytes10, 0, 2);
			byte[] bytes11 = BitConverter.GetBytes((ushort)16);
			fileStream.Write(bytes11, 0, 2);
			byte[] bytes12 = Encoding.UTF8.GetBytes("data");
			fileStream.Write(bytes12, 0, 4);
			byte[] bytes13 = BitConverter.GetBytes(fileStream.Length - headerSize);
			fileStream.Write(bytes13, 0, 4);
			fileStream.Close();
		}

		private void OnGUI()
		{
			if (rt != null)
			{
				GUI.DrawTexture(new Rect(0f, 0f, 300f, 300f), rt, ScaleMode.ScaleToFit, alphaBlend: false, 0f);
			}
		}

		public void PreparePano()
		{
			if (ImageFormatType == VRFormatList.EXR_HDRI)
			{
				texFormat = TextureFormat.RGBAHalf;
				renderTexFormat = RenderTextureFormat.DefaultHDR;
			}
			else if (!useAlpha)
			{
				texFormat = TextureFormat.RGB24;
			}
			else
			{
				texFormat = TextureFormat.ARGB32;
			}
			qualityTemp = resolution / 32 * renderQuality;
			rig = (GameObject)UnityEngine.Object.Instantiate(Resources.Load("Rig"));
			rig.name = "Rig";
			rig.transform.SetParent(base.transform, worldPositionStays: false);
			cam = base.gameObject;
			restoreFOV = cam.GetComponent<Camera>().fieldOfView;
			cam.GetComponent<Camera>().fieldOfView = 100f;
			cam.GetComponent<Camera>().cullingMask = -2049;
			float num = 0f - IPDistance;
			camll = GameObject.Find("Rig/Left");
			camrl = GameObject.Find("Rig/Right");
			camfl = GameObject.Find("Rig/Front");
			camtl = GameObject.Find("Rig/Top");
			cambl = GameObject.Find("Rig/Back");
			camdl = GameObject.Find("Rig/Down");
			cloneCamLL = UnityEngine.Object.Instantiate(cam);
			UnityEngine.Object.Destroy(cloneCamLL.GetComponent(typeof(Animator)));
			UnityEngine.Object.Destroy(cloneCamLL.GetComponent(typeof(Animation)));
			UnityEngine.Object.Destroy(cloneCamLL.GetComponent(typeof(VRCapture)));
			UnityEngine.Object.Destroy(cloneCamLL.GetComponent(typeof(AudioListener)));
			cloneCamRL = UnityEngine.Object.Instantiate(cam);
			UnityEngine.Object.Destroy(cloneCamRL.GetComponent(typeof(Animator)));
			UnityEngine.Object.Destroy(cloneCamRL.GetComponent(typeof(Animation)));
			UnityEngine.Object.Destroy(cloneCamRL.GetComponent(typeof(VRCapture)));
			UnityEngine.Object.Destroy(cloneCamRL.GetComponent(typeof(AudioListener)));
			cloneCamTL = UnityEngine.Object.Instantiate(cam);
			UnityEngine.Object.Destroy(cloneCamTL.GetComponent(typeof(Animator)));
			UnityEngine.Object.Destroy(cloneCamTL.GetComponent(typeof(Animation)));
			UnityEngine.Object.Destroy(cloneCamTL.GetComponent(typeof(VRCapture)));
			UnityEngine.Object.Destroy(cloneCamTL.GetComponent(typeof(AudioListener)));
			if (captureAngle == VRCaptureAngle._360)
			{
				cloneCamBL = UnityEngine.Object.Instantiate(cam);
				UnityEngine.Object.Destroy(cloneCamBL.GetComponent(typeof(Animator)));
				UnityEngine.Object.Destroy(cloneCamBL.GetComponent(typeof(Animation)));
				UnityEngine.Object.Destroy(cloneCamBL.GetComponent(typeof(VRCapture)));
				UnityEngine.Object.Destroy(cloneCamBL.GetComponent(typeof(AudioListener)));
			}
			cloneCamFL = UnityEngine.Object.Instantiate(cam);
			UnityEngine.Object.Destroy(cloneCamFL.GetComponent(typeof(Animator)));
			UnityEngine.Object.Destroy(cloneCamFL.GetComponent(typeof(Animation)));
			UnityEngine.Object.Destroy(cloneCamFL.GetComponent(typeof(VRCapture)));
			UnityEngine.Object.Destroy(cloneCamFL.GetComponent(typeof(AudioListener)));
			cloneCamDL = UnityEngine.Object.Instantiate(cam);
			UnityEngine.Object.Destroy(cloneCamDL.GetComponent(typeof(Animator)));
			UnityEngine.Object.Destroy(cloneCamDL.GetComponent(typeof(Animation)));
			UnityEngine.Object.Destroy(cloneCamDL.GetComponent(typeof(VRCapture)));
			UnityEngine.Object.Destroy(cloneCamDL.GetComponent(typeof(AudioListener)));
			if (panoramaType == VRModeList.EquidistantStereo || panoramaType == VRModeList.EquidistantStereoSBS)
			{
				cloneCamLR = UnityEngine.Object.Instantiate(cam);
				UnityEngine.Object.Destroy(cloneCamLR.GetComponent(typeof(Animator)));
				UnityEngine.Object.Destroy(cloneCamLR.GetComponent(typeof(Animation)));
				UnityEngine.Object.Destroy(cloneCamLR.GetComponent(typeof(VRCapture)));
				UnityEngine.Object.Destroy(cloneCamLR.GetComponent(typeof(AudioListener)));
				cloneCamRR = UnityEngine.Object.Instantiate(cam);
				UnityEngine.Object.Destroy(cloneCamRR.GetComponent(typeof(Animator)));
				UnityEngine.Object.Destroy(cloneCamRR.GetComponent(typeof(Animation)));
				UnityEngine.Object.Destroy(cloneCamRR.GetComponent(typeof(VRCapture)));
				UnityEngine.Object.Destroy(cloneCamRR.GetComponent(typeof(AudioListener)));
				cloneCamTR = UnityEngine.Object.Instantiate(cam);
				UnityEngine.Object.Destroy(cloneCamTR.GetComponent(typeof(Animator)));
				UnityEngine.Object.Destroy(cloneCamTR.GetComponent(typeof(Animation)));
				UnityEngine.Object.Destroy(cloneCamTR.GetComponent(typeof(VRCapture)));
				UnityEngine.Object.Destroy(cloneCamTR.GetComponent(typeof(AudioListener)));
				if (captureAngle == VRCaptureAngle._360)
				{
					cloneCamBR = UnityEngine.Object.Instantiate(cam);
					UnityEngine.Object.Destroy(cloneCamBR.GetComponent(typeof(Animator)));
					UnityEngine.Object.Destroy(cloneCamBR.GetComponent(typeof(Animation)));
					UnityEngine.Object.Destroy(cloneCamBR.GetComponent(typeof(VRCapture)));
					UnityEngine.Object.Destroy(cloneCamBR.GetComponent(typeof(AudioListener)));
				}
				cloneCamFR = UnityEngine.Object.Instantiate(cam);
				UnityEngine.Object.Destroy(cloneCamFR.GetComponent(typeof(Animator)));
				UnityEngine.Object.Destroy(cloneCamFR.GetComponent(typeof(Animation)));
				UnityEngine.Object.Destroy(cloneCamFR.GetComponent(typeof(VRCapture)));
				UnityEngine.Object.Destroy(cloneCamFR.GetComponent(typeof(AudioListener)));
				cloneCamDR = UnityEngine.Object.Instantiate(cam);
				UnityEngine.Object.Destroy(cloneCamDR.GetComponent(typeof(Animator)));
				UnityEngine.Object.Destroy(cloneCamDR.GetComponent(typeof(Animation)));
				UnityEngine.Object.Destroy(cloneCamDR.GetComponent(typeof(VRCapture)));
				UnityEngine.Object.Destroy(cloneCamDR.GetComponent(typeof(AudioListener)));
				cloneCamDRX = UnityEngine.Object.Instantiate(cam);
				UnityEngine.Object.Destroy(cloneCamDRX.GetComponent(typeof(Animator)));
				UnityEngine.Object.Destroy(cloneCamDRX.GetComponent(typeof(Animation)));
				UnityEngine.Object.Destroy(cloneCamDRX.GetComponent(typeof(VRCapture)));
				UnityEngine.Object.Destroy(cloneCamDRX.GetComponent(typeof(AudioListener)));
				cloneCamDLX = UnityEngine.Object.Instantiate(cam);
				UnityEngine.Object.Destroy(cloneCamDLX.GetComponent(typeof(Animator)));
				UnityEngine.Object.Destroy(cloneCamDLX.GetComponent(typeof(Animation)));
				UnityEngine.Object.Destroy(cloneCamDLX.GetComponent(typeof(VRCapture)));
				UnityEngine.Object.Destroy(cloneCamDLX.GetComponent(typeof(AudioListener)));
				cloneCamTRX = UnityEngine.Object.Instantiate(cam);
				UnityEngine.Object.Destroy(cloneCamTRX.GetComponent(typeof(Animator)));
				UnityEngine.Object.Destroy(cloneCamTRX.GetComponent(typeof(Animation)));
				UnityEngine.Object.Destroy(cloneCamTRX.GetComponent(typeof(VRCapture)));
				UnityEngine.Object.Destroy(cloneCamTRX.GetComponent(typeof(AudioListener)));
				cloneCamTLX = UnityEngine.Object.Instantiate(cam);
				UnityEngine.Object.Destroy(cloneCamTLX.GetComponent(typeof(Animator)));
				UnityEngine.Object.Destroy(cloneCamTLX.GetComponent(typeof(Animation)));
				UnityEngine.Object.Destroy(cloneCamTLX.GetComponent(typeof(VRCapture)));
				UnityEngine.Object.Destroy(cloneCamTLX.GetComponent(typeof(AudioListener)));
			}
			camLL = cloneCamLL.GetComponent<Camera>();
			camRL = cloneCamRL.GetComponent<Camera>();
			camTL = cloneCamTL.GetComponent<Camera>();
			if (captureAngle == VRCaptureAngle._360)
			{
				camBL = cloneCamBL.GetComponent<Camera>();
			}
			camFL = cloneCamFL.GetComponent<Camera>();
			camDL = cloneCamDL.GetComponent<Camera>();
			if (panoramaType == VRModeList.EquidistantStereo || panoramaType == VRModeList.EquidistantStereoSBS)
			{
				camLR = cloneCamLR.GetComponent<Camera>();
				camRR = cloneCamRR.GetComponent<Camera>();
				camTR = cloneCamTR.GetComponent<Camera>();
				if (captureAngle == VRCaptureAngle._360)
				{
					camBR = cloneCamBR.GetComponent<Camera>();
				}
				camFR = cloneCamFR.GetComponent<Camera>();
				camDR = cloneCamDR.GetComponent<Camera>();
				camDRX = cloneCamDRX.GetComponent<Camera>();
				camDLX = cloneCamDLX.GetComponent<Camera>();
				camTRX = cloneCamTRX.GetComponent<Camera>();
				camTLX = cloneCamTLX.GetComponent<Camera>();
			}
			cloneCamLL.transform.SetParent(camll.transform, worldPositionStays: false);
			cloneCamRL.transform.SetParent(camrl.transform, worldPositionStays: false);
			cloneCamTL.transform.SetParent(camtl.transform, worldPositionStays: false);
			if (captureAngle == VRCaptureAngle._360)
			{
				cloneCamBL.transform.SetParent(cambl.transform, worldPositionStays: false);
			}
			cloneCamFL.transform.SetParent(camfl.transform, worldPositionStays: false);
			cloneCamDL.transform.SetParent(camdl.transform, worldPositionStays: false);
			if (panoramaType == VRModeList.EquidistantStereo || panoramaType == VRModeList.EquidistantStereoSBS)
			{
				cloneCamTLX.transform.SetParent(camtl.transform, worldPositionStays: false);
				cloneCamDLX.transform.SetParent(camdl.transform, worldPositionStays: false);
			}
			if (panoramaType == VRModeList.EquidistantMono)
			{
				num = 0f;
			}
			Vector3 vector = new Vector3(num, 0f, 0f);
			Vector3 vector2 = new Vector3(0f, num, 0f);
			cloneCamLL.transform.localPosition = -vector / 2f;
			cloneCamRL.transform.localPosition = -vector / 2f;
			cloneCamTL.transform.localPosition = -vector / 2f * -1f;
			if (captureAngle == VRCaptureAngle._360)
			{
				cloneCamBL.transform.localPosition = -vector / 2f;
			}
			cloneCamFL.transform.localPosition = -vector / 2f;
			cloneCamDL.transform.localPosition = -vector / 2f;
			if (panoramaType == VRModeList.EquidistantStereo || panoramaType == VRModeList.EquidistantStereoSBS)
			{
				cloneCamLR.transform.SetParent(camll.transform, worldPositionStays: false);
				cloneCamLR.transform.localPosition = vector / 2f;
				cloneCamRR.transform.SetParent(camrl.transform, worldPositionStays: false);
				cloneCamRR.transform.localPosition = vector / 2f;
				cloneCamTR.transform.SetParent(camtl.transform, worldPositionStays: false);
				cloneCamTR.transform.localPosition = vector / 2f * -1f;
				if (captureAngle == VRCaptureAngle._360)
				{
					cloneCamBR.transform.SetParent(cambl.transform, worldPositionStays: false);
					cloneCamBR.transform.localPosition = vector / 2f;
				}
				cloneCamFR.transform.SetParent(camfl.transform, worldPositionStays: false);
				cloneCamFR.transform.localPosition = vector / 2f;
				cloneCamDR.transform.SetParent(camdl.transform, worldPositionStays: false);
				cloneCamDR.transform.localPosition = vector / 2f;
				cloneCamDLX.transform.localPosition = -vector2 / 2f;
				cloneCamTLX.transform.localPosition = -vector2 / 2f;
				cloneCamTRX.transform.SetParent(camtl.transform, worldPositionStays: false);
				cloneCamTRX.transform.localPosition = vector2 / 2f;
				cloneCamDRX.transform.SetParent(camdl.transform, worldPositionStays: false);
				cloneCamDRX.transform.localPosition = vector2 / 2f;
			}
			if (captureType == VRCaptureList.VRPanoramaRT)
			{
				if (captureAngle == VRCaptureAngle._360)
				{
					renderPanorama = (GameObject)UnityEngine.Object.Instantiate(Resources.Load("360UnwrappedRT2"));
				}
				else
				{
					renderPanorama = (GameObject)UnityEngine.Object.Instantiate(Resources.Load("180UnwrappedRT2"));
				}
			}
			else if (captureAngle == VRCaptureAngle._360)
			{
				renderPanorama = (GameObject)UnityEngine.Object.Instantiate(Resources.Load("360Unwrapped"));
			}
			else
			{
				renderPanorama = (GameObject)UnityEngine.Object.Instantiate(Resources.Load("180Unwrapped"));
			}
			panoramaCam = GameObject.Find("PanoramaCamera");
			VRPanoInterface component = renderPanorama.GetComponent<VRPanoInterface>();
			component.height = resolutionH;
			component.width = resolution;
			if (captureType == VRCaptureList.VRPanoramaRT)
			{
				if (panoramaType == VRModeList.EquidistantMono)
				{
					component.mono = true;
				}
				if (panoramaType == VRModeList.EquidistantStereoSBS)
				{
					component.sbs = true;
				}
			}
			if (panoramaType == VRModeList.EquidistantStereo)
			{
				component.height = resolutionH / 2;
				component.width = resolution;
			}
			if (panoramaType == VRModeList.EquidistantStereoSBS)
			{
				component.height = resolutionH;
				component.width = resolution / 2;
			}
			if (panoramaType == VRModeList.EquidistantStereo || panoramaType == VRModeList.EquidistantStereoSBS)
			{
				cloneCamFL.transform.LookAt(camfl.transform.position + camfl.transform.forward * EnvironmentDistance, camfl.transform.up);
				cloneCamFR.transform.LookAt(camfl.transform.position + camfl.transform.forward * EnvironmentDistance, camfl.transform.up);
				cloneCamLL.transform.LookAt(camll.transform.position + camll.transform.forward * EnvironmentDistance, camll.transform.up);
				cloneCamLR.transform.LookAt(camll.transform.position + camll.transform.forward * EnvironmentDistance, camll.transform.up);
				cloneCamRL.transform.LookAt(camrl.transform.position + camrl.transform.forward * EnvironmentDistance, camrl.transform.up);
				cloneCamRR.transform.LookAt(camrl.transform.position + camrl.transform.forward * EnvironmentDistance, camrl.transform.up);
				if (captureAngle == VRCaptureAngle._360)
				{
					cloneCamBL.transform.LookAt(cambl.transform.position + cambl.transform.forward * EnvironmentDistance, cambl.transform.up);
					cloneCamBR.transform.LookAt(cambl.transform.position + cambl.transform.forward * EnvironmentDistance, cambl.transform.up);
				}
				cloneCamTL.transform.LookAt(camtl.transform.position + camtl.transform.forward * EnvironmentDistance, camtl.transform.up);
				cloneCamTR.transform.LookAt(camtl.transform.position + camtl.transform.forward * EnvironmentDistance, camtl.transform.up);
				cloneCamDL.transform.LookAt(camdl.transform.position + camdl.transform.forward * EnvironmentDistance, camdl.transform.up);
				cloneCamDR.transform.LookAt(camdl.transform.position + camdl.transform.forward * EnvironmentDistance, camdl.transform.up);
				cloneCamTLX.transform.LookAt(camtl.transform.position + camtl.transform.forward * EnvironmentDistance, camtl.transform.up);
				cloneCamTRX.transform.LookAt(camtl.transform.position + camtl.transform.forward * EnvironmentDistance, camtl.transform.up);
				cloneCamDLX.transform.LookAt(camdl.transform.position + camdl.transform.forward * EnvironmentDistance, camdl.transform.up);
				cloneCamDRX.transform.LookAt(camdl.transform.position + camdl.transform.forward * EnvironmentDistance, camdl.transform.up);
			}
			if (panoramaType == VRModeList.EquidistantMono)
			{
				EnvironmentDistance = 10000f;
				cloneCamFL.transform.LookAt(camfl.transform.position + camfl.transform.forward * EnvironmentDistance, camfl.transform.up);
				cloneCamLL.transform.LookAt(camll.transform.position + camll.transform.forward * EnvironmentDistance, camll.transform.up);
				cloneCamRL.transform.LookAt(camrl.transform.position + camrl.transform.forward * EnvironmentDistance, camrl.transform.up);
				if (captureAngle == VRCaptureAngle._360)
				{
					cloneCamBL.transform.LookAt(cambl.transform.position + cambl.transform.forward * EnvironmentDistance, cambl.transform.up);
				}
				cloneCamTL.transform.LookAt(camtl.transform.position + camtl.transform.forward * EnvironmentDistance, camtl.transform.up);
				cloneCamDL.transform.LookAt(camdl.transform.position + camdl.transform.forward * EnvironmentDistance, camdl.transform.up);
			}
		}
	}
}
namespace TMPro
{
	[Serializable]
	public class TMP_DigitValidator : TMP_InputValidator
	{
		public override char Validate(ref string text, ref int pos, char ch)
		{
			if (ch >= '0' && ch <= '9')
			{
				text += ch;
				pos++;
				return ch;
			}
			return '\0';
		}
	}
	[Serializable]
	public class TMP_PhoneNumberValidator : TMP_InputValidator
	{
		public override char Validate(ref string text, ref int pos, char ch)
		{
			UnityEngine.Debug.Log("Trying to validate...");
			if (ch < '0' && ch > '9')
			{
				return '\0';
			}
			int length = text.Length;
			for (int i = 0; i < length + 1; i++)
			{
				switch (i)
				{
				case 0:
					if (i == length)
					{
						text = "(" + ch;
					}
					pos = 2;
					break;
				case 1:
					if (i == length)
					{
						text += ch;
					}
					pos = 2;
					break;
				case 2:
					if (i == length)
					{
						text += ch;
					}
					pos = 3;
					break;
				case 3:
					if (i == length)
					{
						text = text + ch + ") ";
					}
					pos = 6;
					break;
				case 4:
					if (i == length)
					{
						text = text + ") " + ch;
					}
					pos = 7;
					break;
				case 5:
					if (i == length)
					{
						text = text + " " + ch;
					}
					pos = 7;
					break;
				case 6:
					if (i == length)
					{
						text += ch;
					}
					pos = 7;
					break;
				case 7:
					if (i == length)
					{
						text += ch;
					}
					pos = 8;
					break;
				case 8:
					if (i == length)
					{
						text = text + ch + "-";
					}
					pos = 10;
					break;
				case 9:
					if (i == length)
					{
						text = text + "-" + ch;
					}
					pos = 11;
					break;
				case 10:
					if (i == length)
					{
						text += ch;
					}
					pos = 11;
					break;
				case 11:
					if (i == length)
					{
						text += ch;
					}
					pos = 12;
					break;
				case 12:
					if (i == length)
					{
						text += ch;
					}
					pos = 13;
					break;
				case 13:
					if (i == length)
					{
						text += ch;
					}
					pos = 14;
					break;
				}
			}
			return ch;
		}
	}
	public class TMP_TextEventHandler : MonoBehaviour, IPointerEnterHandler, IEventSystemHandler, IPointerExitHandler
	{
		[Serializable]
		public class CharacterSelectionEvent : UnityEvent<char, int>
		{
		}

		[Serializable]
		public class SpriteSelectionEvent : UnityEvent<char, int>
		{
		}

		[Serializable]
		public class WordSelectionEvent : UnityEvent<string, int, int>
		{
		}

		[Serializable]
		public class LineSelectionEvent : UnityEvent<string, int, int>
		{
		}

		[Serializable]
		public class LinkSelectionEvent : UnityEvent<string, string, int>
		{
		}

		[SerializeField]
		private CharacterSelectionEvent m_OnCharacterSelection = new CharacterSelectionEvent();

		[SerializeField]
		private SpriteSelectionEvent m_OnSpriteSelection = new SpriteSelectionEvent();

		[SerializeField]
		private WordSelectionEvent m_OnWordSelection = new WordSelectionEvent();

		[SerializeField]
		private LineSelectionEvent m_OnLineSelection = new LineSelectionEvent();

		[SerializeField]
		private LinkSelectionEvent m_OnLinkSelection = new LinkSelectionEvent();

		private TMP_Text m_TextComponent;

		private Camera m_Camera;

		private Canvas m_Canvas;

		private int m_selectedLink = -1;

		private int m_lastCharIndex = -1;

		private int m_lastWordIndex = -1;

		private int m_lastLineIndex = -1;

		public CharacterSelectionEvent onCharacterSelection
		{
			get
			{
				return m_OnCharacterSelection;
			}
			set
			{
				m_OnCharacterSelection = value;
			}
		}

		public SpriteSelectionEvent onSpriteSelection
		{
			get
			{
				return m_OnSpriteSelection;
			}
			set
			{
				m_OnSpriteSelection = value;
			}
		}

		public WordSelectionEvent onWordSelection
		{
			get
			{
				return m_OnWordSelection;
			}
			set
			{
				m_OnWordSelection = value;
			}
		}

		public LineSelectionEvent onLineSelection
		{
			get
			{
				return m_OnLineSelection;
			}
			set
			{
				m_OnLineSelection = value;
			}
		}

		public LinkSelectionEvent onLinkSelection
		{
			get
			{
				return m_OnLinkSelection;
			}
			set
			{
				m_OnLinkSelection = value;
			}
		}

		private void Awake()
		{
			m_TextComponent = base.gameObject.GetComponent<TMP_Text>();
			if (m_TextComponent.GetType() == typeof(TextMeshProUGUI))
			{
				m_Canvas = base.gameObject.GetComponentInParent<Canvas>();
				if (m_Canvas != null)
				{
					if (m_Canvas.renderMode == RenderMode.ScreenSpaceOverlay)
					{
						m_Camera = null;
					}
					else
					{
						m_Camera = m_Canvas.worldCamera;
					}
				}
			}
			else
			{
				m_Camera = Camera.main;
			}
		}

		private void LateUpdate()
		{
			if (!TMP_TextUtilities.IsIntersectingRectTransform(m_TextComponent.rectTransform, Input.mousePosition, m_Camera))
			{
				return;
			}
			int num = TMP_TextUtilities.FindIntersectingCharacter(m_TextComponent, Input.mousePosition, m_Camera, visibleOnly: true);
			if (num != -1 && num != m_lastCharIndex)
			{
				m_lastCharIndex = num;
				switch (m_TextComponent.textInfo.characterInfo[num].elementType)
				{
				case TMP_TextElementType.Character:
					SendOnCharacterSelection(m_TextComponent.textInfo.characterInfo[num].character, num);
					break;
				case TMP_TextElementType.Sprite:
					SendOnSpriteSelection(m_TextComponent.textInfo.characterInfo[num].character, num);
					break;
				}
			}
			int num2 = TMP_TextUtilities.FindIntersectingWord(m_TextComponent, Input.mousePosition, m_Camera);
			if (num2 != -1 && num2 != m_lastWordIndex)
			{
				m_lastWordIndex = num2;
				TMP_WordInfo tMP_WordInfo = m_TextComponent.textInfo.wordInfo[num2];
				SendOnWordSelection(tMP_WordInfo.GetWord(), tMP_WordInfo.firstCharacterIndex, tMP_WordInfo.characterCount);
			}
			int num3 = TMP_TextUtilities.FindIntersectingLine(m_TextComponent, Input.mousePosition, m_Camera);
			if (num3 != -1 && num3 != m_lastLineIndex)
			{
				m_lastLineIndex = num3;
				TMP_LineInfo tMP_LineInfo = m_TextComponent.textInfo.lineInfo[num3];
				char[] array = new char[tMP_LineInfo.characterCount];
				for (int i = 0; i < tMP_LineInfo.characterCount && i < m_TextComponent.textInfo.characterInfo.Length; i++)
				{
					array[i] = m_TextComponent.textInfo.characterInfo[i + tMP_LineInfo.firstCharacterIndex].character;
				}
				string line = new string(array);
				SendOnLineSelection(line, tMP_LineInfo.firstCharacterIndex, tMP_LineInfo.characterCount);
			}
			int num4 = TMP_TextUtilities.FindIntersectingLink(m_TextComponent, Input.mousePosition, m_Camera);
			if (num4 != -1 && num4 != m_selectedLink)
			{
				m_selectedLink = num4;
				TMP_LinkInfo tMP_LinkInfo = m_TextComponent.textInfo.linkInfo[num4];
				SendOnLinkSelection(tMP_LinkInfo.GetLinkID(), tMP_LinkInfo.GetLinkText(), num4);
			}
		}

		public void OnPointerEnter(PointerEventData eventData)
		{
		}

		public void OnPointerExit(PointerEventData eventData)
		{
		}

		private void SendOnCharacterSelection(char character, int characterIndex)
		{
			if (onCharacterSelection != null)
			{
				onCharacterSelection.Invoke(character, characterIndex);
			}
		}

		private void SendOnSpriteSelection(char character, int characterIndex)
		{
			if (onSpriteSelection != null)
			{
				onSpriteSelection.Invoke(character, characterIndex);
			}
		}

		private void SendOnWordSelection(string word, int charIndex, int length)
		{
			if (onWordSelection != null)
			{
				onWordSelection.Invoke(word, charIndex, length);
			}
		}

		private void SendOnLineSelection(string line, int charIndex, int length)
		{
			if (onLineSelection != null)
			{
				onLineSelection.Invoke(line, charIndex, length);
			}
		}

		private void SendOnLinkSelection(string linkID, string linkText, int linkIndex)
		{
			if (onLinkSelection != null)
			{
				onLinkSelection.Invoke(linkID, linkText, linkIndex);
			}
		}
	}
}
namespace TMPro.Examples
{
	public class Benchmark01 : MonoBehaviour
	{
		public int BenchmarkType;

		public TMP_FontAsset TMProFont;

		public Font TextMeshFont;

		private TextMeshPro m_textMeshPro;

		private TextContainer m_textContainer;

		private TextMesh m_textMesh;

		private const string label01 = "The <#0050FF>count is: </color>{0}";

		private const string label02 = "The <color=#0050FF>count is: </color>";

		private Material m_material01;

		private Material m_material02;

		private IEnumerator Start()
		{
			if (BenchmarkType == 0)
			{
				m_textMeshPro = base.gameObject.AddComponent<TextMeshPro>();
				m_textMeshPro.autoSizeTextContainer = true;
				if (TMProFont != null)
				{
					m_textMeshPro.font = TMProFont;
				}
				m_textMeshPro.fontSize = 48f;
				m_textMeshPro.alignment = TextAlignmentOptions.Center;
				m_textMeshPro.extraPadding = true;
				m_textMeshPro.enableWordWrapping = false;
				m_material01 = m_textMeshPro.font.material;
				m_material02 = Resources.Load<Material>("Fonts & Materials/LiberationSans SDF - Drop Shadow");
			}
			else if (BenchmarkType == 1)
			{
				m_textMesh = base.gameObject.AddComponent<TextMesh>();
				if (TextMeshFont != null)
				{
					m_textMesh.font = TextMeshFont;
					m_textMesh.GetComponent<Renderer>().sharedMaterial = m_textMesh.font.material;
				}
				else
				{
					m_textMesh.font = Resources.Load("Fonts/ARIAL", typeof(Font)) as Font;
					m_textMesh.GetComponent<Renderer>().sharedMaterial = m_textMesh.font.material;
				}
				m_textMesh.fontSize = 48;
				m_textMesh.anchor = TextAnchor.MiddleCenter;
			}
			for (int i = 0; i <= 1000000; i++)
			{
				if (BenchmarkType == 0)
				{
					m_textMeshPro.SetText("The <#0050FF>count is: </color>{0}", i % 1000);
					if (i % 1000 == 999)
					{
						TextMeshPro textMeshPro = m_textMeshPro;
						Material fontSharedMaterial;
						if (!(m_textMeshPro.fontSharedMaterial == m_material01))
						{
							Material material2 = (m_textMeshPro.fontSharedMaterial = m_material01);
							fontSharedMaterial = material2;
						}
						else
						{
							Material material2 = (m_textMeshPro.fontSharedMaterial = m_material02);
							fontSharedMaterial = material2;
						}
						textMeshPro.fontSharedMaterial = fontSharedMaterial;
					}
				}
				else if (BenchmarkType == 1)
				{
					m_textMesh.text = "The <color=#0050FF>count is: </color>" + i % 1000;
				}
				yield return null;
			}
			yield return null;
		}
	}
	public class Benchmark01_UGUI : MonoBehaviour
	{
		public int BenchmarkType;

		public Canvas canvas;

		public TMP_FontAsset TMProFont;

		public Font TextMeshFont;

		private TextMeshProUGUI m_textMeshPro;

		private Text m_textMesh;

		private const string label01 = "The <#0050FF>count is: </color>";

		private const string label02 = "The <color=#0050FF>count is: </color>";

		private Material m_material01;

		private Material m_material02;

		private IEnumerator Start()
		{
			if (BenchmarkType == 0)
			{
				m_textMeshPro = base.gameObject.AddComponent<TextMeshProUGUI>();
				if (TMProFont != null)
				{
					m_textMeshPro.font = TMProFont;
				}
				m_textMeshPro.fontSize = 48f;
				m_textMeshPro.alignment = TextAlignmentOptions.Center;
				m_textMeshPro.extraPadding = true;
				m_material01 = m_textMeshPro.font.material;
				m_material02 = Resources.Load<Material>("Fonts & Materials/LiberationSans SDF - BEVEL");
			}
			else if (BenchmarkType == 1)
			{
				m_textMesh = base.gameObject.AddComponent<Text>();
				if (TextMeshFont != null)
				{
					m_textMesh.font = TextMeshFont;
				}
				m_textMesh.fontSize = 48;
				m_textMesh.alignment = TextAnchor.MiddleCenter;
			}
			for (int i = 0; i <= 1000000; i++)
			{
				if (BenchmarkType == 0)
				{
					m_textMeshPro.text = "The <#0050FF>count is: </color>" + i % 1000;
					if (i % 1000 == 999)
					{
						TextMeshProUGUI textMeshPro = m_textMeshPro;
						Material fontSharedMaterial;
						if (!(m_textMeshPro.fontSharedMaterial == m_material01))
						{
							Material material2 = (m_textMeshPro.fontSharedMaterial = m_material01);
							fontSharedMaterial = material2;
						}
						else
						{
							Material material2 = (m_textMeshPro.fontSharedMaterial = m_material02);
							fontSharedMaterial = material2;
						}
						textMeshPro.fontSharedMaterial = fontSharedMaterial;
					}
				}
				else if (BenchmarkType == 1)
				{
					m_textMesh.text = "The <color=#0050FF>count is: </color>" + i % 1000;
				}
				yield return null;
			}
			yield return null;
		}
	}
	public class Benchmark02 : MonoBehaviour
	{
		public int SpawnType;

		public int NumberOfNPC = 12;

		private TextMeshProFloatingText floatingText_Script;

		private void Start()
		{
			for (int i = 0; i < NumberOfNPC; i++)
			{
				if (SpawnType == 0)
				{
					GameObject gameObject = new GameObject();
					gameObject.transform.position = new Vector3(UnityEngine.Random.Range(-95f, 95f), 0.25f, UnityEngine.Random.Range(-95f, 95f));
					TextMeshPro textMeshPro = gameObject.AddComponent<TextMeshPro>();
					textMeshPro.autoSizeTextContainer = true;
					textMeshPro.rectTransform.pivot = new Vector2(0.5f, 0f);
					textMeshPro.alignment = TextAlignmentOptions.Bottom;
					textMeshPro.fontSize = 96f;
					textMeshPro.enableKerning = false;
					textMeshPro.color = new Color32(byte.MaxValue, byte.MaxValue, 0, byte.MaxValue);
					textMeshPro.text = "!";
					textMeshPro.isTextObjectScaleStatic = true;
					floatingText_Script = gameObject.AddComponent<TextMeshProFloatingText>();
					floatingText_Script.SpawnType = 0;
				}
				else if (SpawnType == 1)
				{
					GameObject gameObject2 = new GameObject();
					gameObject2.transform.position = new Vector3(UnityEngine.Random.Range(-95f, 95f), 0.25f, UnityEngine.Random.Range(-95f, 95f));
					TextMesh textMesh = gameObject2.AddComponent<TextMesh>();
					textMesh.font = Resources.Load<Font>("Fonts/ARIAL");
					textMesh.GetComponent<Renderer>().sharedMaterial = textMesh.font.material;
					textMesh.anchor = TextAnchor.LowerCenter;
					textMesh.fontSize = 96;
					textMesh.color = new Color32(byte.MaxValue, byte.MaxValue, 0, byte.MaxValue);
					textMesh.text = "!";
					floatingText_Script = gameObject2.AddComponent<TextMeshProFloatingText>();
					floatingText_Script.SpawnType = 1;
				}
				else if (SpawnType == 2)
				{
					GameObject gameObject3 = new GameObject();
					gameObject3.AddComponent<Canvas>().worldCamera = Camera.main;
					gameObject3.transform.localScale = new Vector3(0.1f, 0.1f, 0.1f);
					gameObject3.transform.position = new Vector3(UnityEngine.Random.Range(-95f, 95f), 5f, UnityEngine.Random.Range(-95f, 95f));
					TextMeshProUGUI textMeshProUGUI = new GameObject().AddComponent<TextMeshProUGUI>();
					textMeshProUGUI.rectTransform.SetParent(gameObject3.transform, worldPositionStays: false);
					textMeshProUGUI.color = new Color32(byte.MaxValue, byte.MaxValue, 0, byte.MaxValue);
					textMeshProUGUI.alignment = TextAlignmentOptions.Bottom;
					textMeshProUGUI.fontSize = 96f;
					textMeshProUGUI.text = "!";
					floatingText_Script = gameObject3.AddComponent<TextMeshProFloatingText>();
					floatingText_Script.SpawnType = 0;
				}
			}
		}
	}
	public class Benchmark03 : MonoBehaviour
	{
		public enum BenchmarkType
		{
			TMP_SDF_MOBILE,
			TMP_SDF__MOBILE_SSD,
			TMP_SDF,
			TMP_BITMAP_MOBILE,
			TEXTMESH_BITMAP
		}

		public int NumberOfSamples = 100;

		public BenchmarkType Benchmark;

		public Font SourceFontFile;

		private void Awake()
		{
		}

		private void Start()
		{
			TMP_FontAsset tMP_FontAsset = null;
			switch (Benchmark)
			{
			case BenchmarkType.TMP_SDF_MOBILE:
				tMP_FontAsset = TMP_FontAsset.CreateFontAsset(SourceFontFile, 90, 9, GlyphRenderMode.SDFAA, 256, 256);
				break;
			case BenchmarkType.TMP_SDF__MOBILE_SSD:
				tMP_FontAsset = TMP_FontAsset.CreateFontAsset(SourceFontFile, 90, 9, GlyphRenderMode.SDFAA, 256, 256);
				tMP_FontAsset.material.shader = Shader.Find("TextMeshPro/Mobile/Distance Field SSD");
				break;
			case BenchmarkType.TMP_SDF:
				tMP_FontAsset = TMP_FontAsset.CreateFontAsset(SourceFontFile, 90, 9, GlyphRenderMode.SDFAA, 256, 256);
				tMP_FontAsset.material.shader = Shader.Find("TextMeshPro/Distance Field");
				break;
			case BenchmarkType.TMP_BITMAP_MOBILE:
				tMP_FontAsset = TMP_FontAsset.CreateFontAsset(SourceFontFile, 90, 9, GlyphRenderMode.SMOOTH, 256, 256);
				break;
			}
			for (int i = 0; i < NumberOfSamples; i++)
			{
				switch (Benchmark)
				{
				case BenchmarkType.TMP_SDF_MOBILE:
				case BenchmarkType.TMP_SDF__MOBILE_SSD:
				case BenchmarkType.TMP_SDF:
				case BenchmarkType.TMP_BITMAP_MOBILE:
				{
					GameObject obj2 = new GameObject();
					obj2.transform.position = new Vector3(0f, 1.2f, 0f);
					TextMeshPro textMeshPro = obj2.AddComponent<TextMeshPro>();
					textMeshPro.font = tMP_FontAsset;
					textMeshPro.fontSize = 128f;
					textMeshPro.text = "@";
					textMeshPro.alignment = TextAlignmentOptions.Center;
					textMeshPro.color = new Color32(byte.MaxValue, byte.MaxValue, 0, byte.MaxValue);
					if (Benchmark == BenchmarkType.TMP_BITMAP_MOBILE)
					{
						textMeshPro.fontSize = 132f;
					}
					break;
				}
				case BenchmarkType.TEXTMESH_BITMAP:
				{
					GameObject obj = new GameObject();
					obj.transform.position = new Vector3(0f, 1.2f, 0f);
					TextMesh textMesh = obj.AddComponent<TextMesh>();
					textMesh.GetComponent<Renderer>().sharedMaterial = SourceFontFile.material;
					textMesh.font = SourceFontFile;
					textMesh.anchor = TextAnchor.MiddleCenter;
					textMesh.fontSize = 130;
					textMesh.color = new Color32(byte.MaxValue, byte.MaxValue, 0, byte.MaxValue);
					textMesh.text = "@";
					break;
				}
				}
			}
		}
	}
	public class Benchmark04 : MonoBehaviour
	{
		public int SpawnType;

		public int MinPointSize = 12;

		public int MaxPointSize = 64;

		public int Steps = 4;

		private Transform m_Transform;

		private void Start()
		{
			m_Transform = base.transform;
			float num = 0f;
			float num3 = (Camera.main.orthographicSize = Screen.height / 2);
			float num4 = num3;
			float num5 = (float)Screen.width / (float)Screen.height;
			for (int i = MinPointSize; i <= MaxPointSize; i += Steps)
			{
				if (SpawnType == 0)
				{
					GameObject gameObject = new GameObject("Text - " + i + " Pts");
					if (num > num4 * 2f)
					{
						break;
					}
					gameObject.transform.position = m_Transform.position + new Vector3(num5 * (0f - num4) * 0.975f, num4 * 0.975f - num, 0f);
					TextMeshPro textMeshPro = gameObject.AddComponent<TextMeshPro>();
					textMeshPro.rectTransform.pivot = new Vector2(0f, 0.5f);
					textMeshPro.enableWordWrapping = false;
					textMeshPro.extraPadding = true;
					textMeshPro.isOrthographic = true;
					textMeshPro.fontSize = i;
					textMeshPro.text = i + " pts - Lorem ipsum dolor sit...";
					textMeshPro.color = new Color32(byte.MaxValue, byte.MaxValue, byte.MaxValue, byte.MaxValue);
					num += (float)i;
				}
			}
		}
	}
	public class CameraController : MonoBehaviour
	{
		public enum CameraModes
		{
			Follow,
			Isometric,
			Free
		}

		private Transform cameraTransform;

		private Transform dummyTarget;

		public Transform CameraTarget;

		public float FollowDistance = 30f;

		public float MaxFollowDistance = 100f;

		public float MinFollowDistance = 2f;

		public float ElevationAngle = 30f;

		public float MaxElevationAngle = 85f;

		public float MinElevationAngle;

		public float OrbitalAngle;

		public CameraModes CameraMode;

		public bool MovementSmoothing = true;

		public bool RotationSmoothing;

		private bool previousSmoothing;

		public float MovementSmoothingValue = 25f;

		public float RotationSmoothingValue = 5f;

		public float MoveSensitivity = 2f;

		private Vector3 currentVelocity = Vector3.zero;

		private Vector3 desiredPosition;

		private float mouseX;

		private float mouseY;

		private Vector3 moveVector;

		private float mouseWheel;

		private const string event_SmoothingValue = "Slider - Smoothing Value";

		private const string event_FollowDistance = "Slider - Camera Zoom";

		private void Awake()
		{
			if (QualitySettings.vSyncCount > 0)
			{
				Application.targetFrameRate = 60;
			}
			else
			{
				Application.targetFrameRate = -1;
			}
			if (Application.platform == RuntimePlatform.IPhonePlayer || Application.platform == RuntimePlatform.Android)
			{
				Input.simulateMouseWithTouches = false;
			}
			cameraTransform = base.transform;
			previousSmoothing = MovementSmoothing;
		}

		private void Start()
		{
			if (CameraTarget == null)
			{
				dummyTarget = new GameObject("Camera Target").transform;
				CameraTarget = dummyTarget;
			}
		}

		private void LateUpdate()
		{
			GetPlayerInput();
			if (CameraTarget != null)
			{
				if (CameraMode == CameraModes.Isometric)
				{
					desiredPosition = CameraTarget.position + Quaternion.Euler(ElevationAngle, OrbitalAngle, 0f) * new Vector3(0f, 0f, 0f - FollowDistance);
				}
				else if (CameraMode == CameraModes.Follow)
				{
					desiredPosition = CameraTarget.position + CameraTarget.TransformDirection(Quaternion.Euler(ElevationAngle, OrbitalAngle, 0f) * new Vector3(0f, 0f, 0f - FollowDistance));
				}
				if (MovementSmoothing)
				{
					cameraTransform.position = Vector3.SmoothDamp(cameraTransform.position, desiredPosition, ref currentVelocity, MovementSmoothingValue * Time.fixedDeltaTime);
				}
				else
				{
					cameraTransform.position = desiredPosition;
				}
				if (RotationSmoothing)
				{
					cameraTransform.rotation = Quaternion.Lerp(cameraTransform.rotation, Quaternion.LookRotation(CameraTarget.position - cameraTransform.position), RotationSmoothingValue * Time.deltaTime);
				}
				else
				{
					cameraTransform.LookAt(CameraTarget);
				}
			}
		}

		private void GetPlayerInput()
		{
			moveVector = Vector3.zero;
			mouseWheel = Input.GetAxis("Mouse ScrollWheel");
			float num = Input.touchCount;
			if (Input.GetKey(KeyCode.LeftShift) || Input.GetKey(KeyCode.RightShift) || num > 0f)
			{
				mouseWheel *= 10f;
				if (Input.GetKeyDown(KeyCode.I))
				{
					CameraMode = CameraModes.Isometric;
				}
				if (Input.GetKeyDown(KeyCode.F))
				{
					CameraMode = CameraModes.Follow;
				}
				if (Input.GetKeyDown(KeyCode.S))
				{
					MovementSmoothing = !MovementSmoothing;
				}
				if (Input.GetMouseButton(1))
				{
					mouseY = Input.GetAxis("Mouse Y");
					mouseX = Input.GetAxis("Mouse X");
					if (mouseY > 0.01f || mouseY < -0.01f)
					{
						ElevationAngle -= mouseY * MoveSensitivity;
						ElevationAngle = Mathf.Clamp(ElevationAngle, MinElevationAngle, MaxElevationAngle);
					}
					if (mouseX > 0.01f || mouseX < -0.01f)
					{
						OrbitalAngle += mouseX * MoveSensitivity;
						if (OrbitalAngle > 360f)
						{
							OrbitalAngle -= 360f;
						}
						if (OrbitalAngle < 0f)
						{
							OrbitalAngle += 360f;
						}
					}
				}
				if (num == 1f && Input.GetTouch(0).phase == TouchPhase.Moved)
				{
					Vector2 deltaPosition = Input.GetTouch(0).deltaPosition;
					if (deltaPosition.y > 0.01f || deltaPosition.y < -0.01f)
					{
						ElevationAngle -= deltaPosition.y * 0.1f;
						ElevationAngle = Mathf.Clamp(ElevationAngle, MinElevationAngle, MaxElevationAngle);
					}
					if (deltaPosition.x > 0.01f || deltaPosition.x < -0.01f)
					{
						OrbitalAngle += deltaPosition.x * 0.1f;
						if (OrbitalAngle > 360f)
						{
							OrbitalAngle -= 360f;
						}
						if (OrbitalAngle < 0f)
						{
							OrbitalAngle += 360f;
						}
					}
				}
				if (Input.GetMouseButton(0) && Physics.Raycast(Camera.main.ScreenPointToRay(Input.mousePosition), out var hitInfo, 300f, 23552))
				{
					if (hitInfo.transform == CameraTarget)
					{
						OrbitalAngle = 0f;
					}
					else
					{
						CameraTarget = hitInfo.transform;
						OrbitalAngle = 0f;
						MovementSmoothing = previousSmoothing;
					}
				}
				if (Input.GetMouseButton(2))
				{
					if (dummyTarget == null)
					{
						dummyTarget = new GameObject("Camera Target").transform;
						dummyTarget.position = CameraTarget.position;
						dummyTarget.rotation = CameraTarget.rotation;
						CameraTarget = dummyTarget;
						previousSmoothing = MovementSmoothing;
						MovementSmoothing = false;
					}
					else if (dummyTarget != CameraTarget)
					{
						dummyTarget.position = CameraTarget.position;
						dummyTarget.rotation = CameraTarget.rotation;
						CameraTarget = dummyTarget;
						previousSmoothing = MovementSmoothing;
						MovementSmoothing = false;
					}
					mouseY = Input.GetAxis("Mouse Y");
					mouseX = Input.GetAxis("Mouse X");
					moveVector = cameraTransform.TransformDirection(mouseX, mouseY, 0f);
					dummyTarget.Translate(-moveVector, Space.World);
				}
			}
			if (num == 2f)
			{
				Touch touch = Input.GetTouch(0);
				Touch touch2 = Input.GetTouch(1);
				Vector2 vector = touch.position - touch.deltaPosition;
				Vector2 vector2 = touch2.position - touch2.deltaPosition;
				float magnitude = (vector - vector2).magnitude;
				float magnitude2 = (touch.position - touch2.position).magnitude;
				float num2 = magnitude - magnitude2;
				if (num2 > 0.01f || num2 < -0.01f)
				{
					FollowDistance += num2 * 0.25f;
					FollowDistance = Mathf.Clamp(FollowDistance, MinFollowDistance, MaxFollowDistance);
				}
			}
			if (mouseWheel < -0.01f || mouseWheel > 0.01f)
			{
				FollowDistance -= mouseWheel * 5f;
				FollowDistance = Mathf.Clamp(FollowDistance, MinFollowDistance, MaxFollowDistance);
			}
		}
	}
	public class ObjectSpin : MonoBehaviour
	{
		public enum MotionType
		{
			Rotation,
			BackAndForth,
			Translation
		}

		public float SpinSpeed = 5f;

		public int RotationRange = 15;

		private Transform m_transform;

		private float m_time;

		private Vector3 m_prevPOS;

		private Vector3 m_initial_Rotation;

		private Vector3 m_initial_Position;

		private Color32 m_lightColor;

		private int frames;

		public MotionType Motion;

		private void Awake()
		{
			m_transform = base.transform;
			m_initial_Rotation = m_transform.rotation.eulerAngles;
			m_initial_Position = m_transform.position;
			Light component = GetComponent<Light>();
			m_lightColor = ((component != null) ? component.color : Color.black);
		}

		private void Update()
		{
			if (Motion == MotionType.Rotation)
			{
				m_transform.Rotate(0f, SpinSpeed * Time.deltaTime, 0f);
				return;
			}
			if (Motion == MotionType.BackAndForth)
			{
				m_time += SpinSpeed * Time.deltaTime;
				m_transform.rotation = Quaternion.Euler(m_initial_Rotation.x, Mathf.Sin(m_time) * (float)RotationRange + m_initial_Rotation.y, m_initial_Rotation.z);
				return;
			}
			m_time += SpinSpeed * Time.deltaTime;
			float x = 15f * Mathf.Cos(m_time * 0.95f);
			float z = 10f;
			float y = 0f;
			m_transform.position = m_initial_Position + new Vector3(x, y, z);
			m_prevPOS = m_transform.position;
			frames++;
		}
	}
	public class ShaderPropAnimator : MonoBehaviour
	{
		private Renderer m_Renderer;

		private Material m_Material;

		public AnimationCurve GlowCurve;

		public float m_frame;

		private void Awake()
		{
			m_Renderer = GetComponent<Renderer>();
			m_Material = m_Renderer.material;
		}

		private void Start()
		{
			StartCoroutine(AnimateProperties());
		}

		private IEnumerator AnimateProperties()
		{
			m_frame = UnityEngine.Random.Range(0f, 1f);
			while (true)
			{
				float value = GlowCurve.Evaluate(m_frame);
				m_Material.SetFloat(ShaderUtilities.ID_GlowPower, value);
				m_frame += Time.deltaTime * UnityEngine.Random.Range(0.2f, 0.3f);
				yield return new WaitForEndOfFrame();
			}
		}
	}
	public class SimpleScript : MonoBehaviour
	{
		private TextMeshPro m_textMeshPro;

		private const string label = "The <#0050FF>count is: </color>{0:2}";

		private float m_frame;

		private void Start()
		{
			m_textMeshPro = base.gameObject.AddComponent<TextMeshPro>();
			m_textMeshPro.autoSizeTextContainer = true;
			m_textMeshPro.fontSize = 48f;
			m_textMeshPro.alignment = TextAlignmentOptions.Center;
			m_textMeshPro.enableWordWrapping = false;
		}

		private void Update()
		{
			m_textMeshPro.SetText("The <#0050FF>count is: </color>{0:2}", m_frame % 1000f);
			m_frame += 1f * Time.deltaTime;
		}
	}
	public class SkewTextExample : MonoBehaviour
	{
		private TMP_Text m_TextComponent;

		public AnimationCurve VertexCurve = new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(0.25f, 2f), new Keyframe(0.5f, 0f), new Keyframe(0.75f, 2f), new Keyframe(1f, 0f));

		public float CurveScale = 1f;

		public float ShearAmount = 1f;

		private void Awake()
		{
			m_TextComponent = base.gameObject.GetComponent<TMP_Text>();
		}

		private void Start()
		{
			StartCoroutine(WarpText());
		}

		private AnimationCurve CopyAnimationCurve(AnimationCurve curve)
		{
			return new AnimationCurve
			{
				keys = curve.keys
			};
		}

		private IEnumerator WarpText()
		{
			VertexCurve.preWrapMode = WrapMode.Once;
			VertexCurve.postWrapMode = WrapMode.Once;
			m_TextComponent.havePropertiesChanged = true;
			CurveScale *= 10f;
			float old_CurveScale = CurveScale;
			float old_ShearValue = ShearAmount;
			AnimationCurve old_curve = CopyAnimationCurve(VertexCurve);
			while (true)
			{
				if (!m_TextComponent.havePropertiesChanged && old_CurveScale == CurveScale && old_curve.keys[1].value == VertexCurve.keys[1].value && old_ShearValue == ShearAmount)
				{
					yield return null;
					continue;
				}
				old_CurveScale = CurveScale;
				old_curve = CopyAnimationCurve(VertexCurve);
				old_ShearValue = ShearAmount;
				m_TextComponent.ForceMeshUpdate();
				TMP_TextInfo textInfo = m_TextComponent.textInfo;
				int characterCount = textInfo.characterCount;
				if (characterCount == 0)
				{
					continue;
				}
				float x = m_TextComponent.bounds.min.x;
				float x2 = m_TextComponent.bounds.max.x;
				for (int i = 0; i < characterCount; i++)
				{
					if (textInfo.characterInfo[i].isVisible)
					{
						int vertexIndex = textInfo.characterInfo[i].vertexIndex;
						int materialReferenceIndex = textInfo.characterInfo[i].materialReferenceIndex;
						Vector3[] vertices = textInfo.meshInfo[materialReferenceIndex].vertices;
						Vector3 vector = new Vector2((vertices[vertexIndex].x + vertices[vertexIndex + 2].x) / 2f, textInfo.characterInfo[i].baseLine);
						vertices[vertexIndex] += -vector;
						vertices[vertexIndex + 1] += -vector;
						vertices[vertexIndex + 2] += -vector;
						vertices[vertexIndex + 3] += -vector;
						float num = ShearAmount * 0.01f;
						Vector3 vector2 = new Vector3(num * (textInfo.characterInfo[i].topRight.y - textInfo.characterInfo[i].baseLine), 0f, 0f);
						Vector3 vector3 = new Vector3(num * (textInfo.characterInfo[i].baseLine - textInfo.characterInfo[i].bottomRight.y), 0f, 0f);
						vertices[vertexIndex] += -vector3;
						vertices[vertexIndex + 1] += vector2;
						vertices[vertexIndex + 2] += vector2;
						vertices[vertexIndex + 3] += -vector3;
						float num2 = (vector.x - x) / (x2 - x);
						float num3 = num2 + 0.0001f;
						float y = VertexCurve.Evaluate(num2) * CurveScale;
						float y2 = VertexCurve.Evaluate(num3) * CurveScale;
						Vector3 lhs = new Vector3(1f, 0f, 0f);
						Vector3 rhs = new Vector3(num3 * (x2 - x) + x, y2) - new Vector3(vector.x, y);
						float num4 = Mathf.Acos(Vector3.Dot(lhs, rhs.normalized)) * 57.29578f;
						float z = ((Vector3.Cross(lhs, rhs).z > 0f) ? num4 : (360f - num4));
						Matrix4x4 matrix4x = Matrix4x4.TRS(new Vector3(0f, y, 0f), Quaternion.Euler(0f, 0f, z), Vector3.one);
						vertices[vertexIndex] = matrix4x.MultiplyPoint3x4(vertices[vertexIndex]);
						vertices[vertexIndex + 1] = matrix4x.MultiplyPoint3x4(vertices[vertexIndex + 1]);
						vertices[vertexIndex + 2] = matrix4x.MultiplyPoint3x4(vertices[vertexIndex + 2]);
						vertices[vertexIndex + 3] = matrix4x.MultiplyPoint3x4(vertices[vertexIndex + 3]);
						vertices[vertexIndex] += vector;
						vertices[vertexIndex + 1] += vector;
						vertices[vertexIndex + 2] += vector;
						vertices[vertexIndex + 3] += vector;
					}
				}
				m_TextComponent.UpdateVertexData();
				yield return null;
			}
		}
	}
	public class TMP_ExampleScript_01 : MonoBehaviour
	{
		public enum objectType
		{
			TextMeshPro,
			TextMeshProUGUI
		}

		public objectType ObjectType;

		public bool isStatic;

		private TMP_Text m_text;

		private const string k_label = "The count is <#0080ff>{0}</color>";

		private int count;

		private void Awake()
		{
			if (ObjectType == objectType.TextMeshPro)
			{
				m_text = GetComponent<TextMeshPro>() ?? base.gameObject.AddComponent<TextMeshPro>();
			}
			else
			{
				m_text = GetComponent<TextMeshProUGUI>() ?? base.gameObject.AddComponent<TextMeshProUGUI>();
			}
			m_text.font = Resources.Load<TMP_FontAsset>("Fonts & Materials/Anton SDF");
			m_text.fontSharedMaterial = Resources.Load<Material>("Fonts & Materials/Anton SDF - Drop Shadow");
			m_text.fontSize = 120f;
			m_text.text = "A <#0080ff>simple</color> line of text.";
			Vector2 preferredValues = m_text.GetPreferredValues(float.PositiveInfinity, float.PositiveInfinity);
			m_text.rectTransform.sizeDelta = new Vector2(preferredValues.x, preferredValues.y);
		}

		private void Update()
		{
			if (!isStatic)
			{
				m_text.SetText("The count is <#0080ff>{0}</color>", count % 1000);
				count++;
			}
		}
	}
	public class TMP_FrameRateCounter : MonoBehaviour
	{
		public enum FpsCounterAnchorPositions
		{
			TopLeft,
			BottomLeft,
			TopRight,
			BottomRight
		}

		public float UpdateInterval = 5f;

		private float m_LastInterval;

		private int m_Frames;

		public FpsCounterAnchorPositions AnchorPosition = FpsCounterAnchorPositions.TopRight;

		private string htmlColorTag;

		private const string fpsLabel = "{0:2}</color> <#8080ff>FPS \n<#FF8000>{1:2} <#8080ff>MS";

		private TextMeshPro m_TextMeshPro;

		private Transform m_frameCounter_transform;

		private Camera m_camera;

		private FpsCounterAnchorPositions last_AnchorPosition;

		private void Awake()
		{
			if (base.enabled)
			{
				m_camera = Camera.main;
				Application.targetFrameRate = 9999;
				GameObject gameObject = new GameObject("Frame Counter");
				m_TextMeshPro = gameObject.AddComponent<TextMeshPro>();
				m_TextMeshPro.font = Resources.Load<TMP_FontAsset>("Fonts & Materials/LiberationSans SDF");
				m_TextMeshPro.fontSharedMaterial = Resources.Load<Material>("Fonts & Materials/LiberationSans SDF - Overlay");
				m_frameCounter_transform = gameObject.transform;
				m_frameCounter_transform.SetParent(m_camera.transform);
				m_frameCounter_transform.localRotation = Quaternion.identity;
				m_TextMeshPro.enableWordWrapping = false;
				m_TextMeshPro.fontSize = 24f;
				Set_FrameCounter_Position(AnchorPosition);
				last_AnchorPosition = AnchorPosition;
			}
		}

		private void Start()
		{
			m_LastInterval = Time.realtimeSinceStartup;
			m_Frames = 0;
		}

		private void Update()
		{
			if (AnchorPosition != last_AnchorPosition)
			{
				Set_FrameCounter_Position(AnchorPosition);
			}
			last_AnchorPosition = AnchorPosition;
			m_Frames++;
			float realtimeSinceStartup = Time.realtimeSinceStartup;
			if (realtimeSinceStartup > m_LastInterval + UpdateInterval)
			{
				float num = (float)m_Frames / (realtimeSinceStartup - m_LastInterval);
				float arg = 1000f / Mathf.Max(num, 1E-05f);
				if (num < 30f)
				{
					htmlColorTag = "<color=yellow>";
				}
				else if (num < 10f)
				{
					htmlColorTag = "<color=red>";
				}
				else
				{
					htmlColorTag = "<color=green>";
				}
				m_TextMeshPro.SetText(htmlColorTag + "{0:2}</color> <#8080ff>FPS \n<#FF8000>{1:2} <#8080ff>MS", num, arg);
				m_Frames = 0;
				m_LastInterval = realtimeSinceStartup;
			}
		}

		private void Set_FrameCounter_Position(FpsCounterAnchorPositions anchor_position)
		{
			m_TextMeshPro.margin = new Vector4(1f, 1f, 1f, 1f);
			switch (anchor_position)
			{
			case FpsCounterAnchorPositions.TopLeft:
				m_TextMeshPro.alignment = TextAlignmentOptions.TopLeft;
				m_TextMeshPro.rectTransform.pivot = new Vector2(0f, 1f);
				m_frameCounter_transform.position = m_camera.ViewportToWorldPoint(new Vector3(0f, 1f, 100f));
				break;
			case FpsCounterAnchorPositions.BottomLeft:
				m_TextMeshPro.alignment = TextAlignmentOptions.BottomLeft;
				m_TextMeshPro.rectTransform.pivot = new Vector2(0f, 0f);
				m_frameCounter_transform.position = m_camera.ViewportToWorldPoint(new Vector3(0f, 0f, 100f));
				break;
			case FpsCounterAnchorPositions.TopRight:
				m_TextMeshPro.alignment = TextAlignmentOptions.TopRight;
				m_TextMeshPro.rectTransform.pivot = new Vector2(1f, 1f);
				m_frameCounter_transform.position = m_camera.ViewportToWorldPoint(new Vector3(1f, 1f, 100f));
				break;
			case FpsCounterAnchorPositions.BottomRight:
				m_TextMeshPro.alignment = TextAlignmentOptions.BottomRight;
				m_TextMeshPro.rectTransform.pivot = new Vector2(1f, 0f);
				m_frameCounter_transform.position = m_camera.ViewportToWorldPoint(new Vector3(1f, 0f, 100f));
				break;
			}
		}
	}
	public class TMP_TextEventCheck : MonoBehaviour
	{
		public TMP_TextEventHandler TextEventHandler;

		private TMP_Text m_TextComponent;

		private void OnEnable()
		{
			if (TextEventHandler != null)
			{
				m_TextComponent = TextEventHandler.GetComponent<TMP_Text>();
				TextEventHandler.onCharacterSelection.AddListener(OnCharacterSelection);
				TextEventHandler.onSpriteSelection.AddListener(OnSpriteSelection);
				TextEventHandler.onWordSelection.AddListener(OnWordSelection);
				TextEventHandler.onLineSelection.AddListener(OnLineSelection);
				TextEventHandler.onLinkSelection.AddListener(OnLinkSelection);
			}
		}

		private void OnDisable()
		{
			if (TextEventHandler != null)
			{
				TextEventHandler.onCharacterSelection.RemoveListener(OnCharacterSelection);
				TextEventHandler.onSpriteSelection.RemoveListener(OnSpriteSelection);
				TextEventHandler.onWordSelection.RemoveListener(OnWordSelection);
				TextEventHandler.onLineSelection.RemoveListener(OnLineSelection);
				TextEventHandler.onLinkSelection.RemoveListener(OnLinkSelection);
			}
		}

		private void OnCharacterSelection(char c, int index)
		{
			UnityEngine.Debug.Log("Character [" + c + "] at Index: " + index + " has been selected.");
		}

		private void OnSpriteSelection(char c, int index)
		{
			UnityEngine.Debug.Log("Sprite [" + c + "] at Index: " + index + " has been selected.");
		}

		private void OnWordSelection(string word, int firstCharacterIndex, int length)
		{
			UnityEngine.Debug.Log("Word [" + word + "] with first character index of " + firstCharacterIndex + " and length of " + length + " has been selected.");
		}

		private void OnLineSelection(string lineText, int firstCharacterIndex, int length)
		{
			UnityEngine.Debug.Log("Line [" + lineText + "] with first character index of " + firstCharacterIndex + " and length of " + length + " has been selected.");
		}

		private void OnLinkSelection(string linkID, string linkText, int linkIndex)
		{
			if (m_TextComponent != null)
			{
				_ = ref m_TextComponent.textInfo.linkInfo[linkIndex];
			}
			UnityEngine.Debug.Log("Link Index: " + linkIndex + " with ID [" + linkID + "] and Text \"" + linkText + "\" has been selected.");
		}
	}
	public class TMP_TextInfoDebugTool : MonoBehaviour
	{
	}
	public class TMP_TextSelector_A : MonoBehaviour, IPointerEnterHandler, IEventSystemHandler, IPointerExitHandler
	{
		private TextMeshPro m_TextMeshPro;

		private Camera m_Camera;

		private bool m_isHoveringObject;

		private int m_selectedLink = -1;

		private int m_lastCharIndex = -1;

		private int m_lastWordIndex = -1;

		private void Awake()
		{
			m_TextMeshPro = base.gameObject.GetComponent<TextMeshPro>();
			m_Camera = Camera.main;
			m_TextMeshPro.ForceMeshUpdate();
		}

		private void LateUpdate()
		{
			m_isHoveringObject = false;
			if (TMP_TextUtilities.IsIntersectingRectTransform(m_TextMeshPro.rectTransform, Input.mousePosition, Camera.main))
			{
				m_isHoveringObject = true;
			}
			if (!m_isHoveringObject)
			{
				return;
			}
			int num = TMP_TextUtilities.FindIntersectingCharacter(m_TextMeshPro, Input.mousePosition, Camera.main, visibleOnly: true);
			if (num != -1 && num != m_lastCharIndex && (Input.GetKey(KeyCode.LeftShift) || Input.GetKey(KeyCode.RightShift)))
			{
				m_lastCharIndex = num;
				int materialReferenceIndex = m_TextMeshPro.textInfo.characterInfo[num].materialReferenceIndex;
				int vertexIndex = m_TextMeshPro.textInfo.characterInfo[num].vertexIndex;
				Color32 color = new Color32((byte)UnityEngine.Random.Range(0, 255), (byte)UnityEngine.Random.Range(0, 255), (byte)UnityEngine.Random.Range(0, 255), byte.MaxValue);
				Color32[] colors = m_TextMeshPro.textInfo.meshInfo[materialReferenceIndex].colors32;
				colors[vertexIndex] = color;
				colors[vertexIndex + 1] = color;
				colors[vertexIndex + 2] = color;
				colors[vertexIndex + 3] = color;
				m_TextMeshPro.textInfo.meshInfo[materialReferenceIndex].mesh.colors32 = colors;
			}
			int num2 = TMP_TextUtilities.FindIntersectingLink(m_TextMeshPro, Input.mousePosition, m_Camera);
			if ((num2 == -1 && m_selectedLink != -1) || num2 != m_selectedLink)
			{
				m_selectedLink = -1;
			}
			if (num2 != -1 && num2 != m_selectedLink)
			{
				m_selectedLink = num2;
				TMP_LinkInfo tMP_LinkInfo = m_TextMeshPro.textInfo.linkInfo[num2];
				RectTransformUtility.ScreenPointToWorldPointInRectangle(m_TextMeshPro.rectTransform, Input.mousePosition, m_Camera, out var _);
				string linkID = tMP_LinkInfo.GetLinkID();
				if (linkID != null && !(linkID == "id_01"))
				{
					_ = linkID == "id_02";
				}
			}
			int num3 = TMP_TextUtilities.FindIntersectingWord(m_TextMeshPro, Input.mousePosition, Camera.main);
			if (num3 != -1 && num3 != m_lastWordIndex)
			{
				m_lastWordIndex = num3;
				TMP_WordInfo tMP_WordInfo = m_TextMeshPro.textInfo.wordInfo[num3];
				Vector3 position = m_TextMeshPro.transform.TransformPoint(m_TextMeshPro.textInfo.characterInfo[tMP_WordInfo.firstCharacterIndex].bottomLeft);
				position = Camera.main.WorldToScreenPoint(position);
				Color32[] colors2 = m_TextMeshPro.textInfo.meshInfo[0].colors32;
				Color32 color2 = new Color32((byte)UnityEngine.Random.Range(0, 255), (byte)UnityEngine.Random.Range(0, 255), (byte)UnityEngine.Random.Range(0, 255), byte.MaxValue);
				for (int i = 0; i < tMP_WordInfo.characterCount; i++)
				{
					int vertexIndex2 = m_TextMeshPro.textInfo.characterInfo[tMP_WordInfo.firstCharacterIndex + i].vertexIndex;
					colors2[vertexIndex2] = color2;
					colors2[vertexIndex2 + 1] = color2;
					colors2[vertexIndex2 + 2] = color2;
					colors2[vertexIndex2 + 3] = color2;
				}
				m_TextMeshPro.mesh.colors32 = colors2;
			}
		}

		public void OnPointerEnter(PointerEventData eventData)
		{
			UnityEngine.Debug.Log("OnPointerEnter()");
			m_isHoveringObject = true;
		}

		public void OnPointerExit(PointerEventData eventData)
		{
			UnityEngine.Debug.Log("OnPointerExit()");
			m_isHoveringObject = false;
		}
	}
	public class TMP_TextSelector_B : MonoBehaviour, IPointerEnterHandler, IEventSystemHandler, IPointerExitHandler, IPointerClickHandler, IPointerUpHandler
	{
		public RectTransform TextPopup_Prefab_01;

		private RectTransform m_TextPopup_RectTransform;

		private TextMeshProUGUI m_TextPopup_TMPComponent;

		private const string k_LinkText = "You have selected link <#ffff00>";

		private const string k_WordText = "Word Index: <#ffff00>";

		private TextMeshProUGUI m_TextMeshPro;

		private Canvas m_Canvas;

		private Camera m_Camera;

		private bool isHoveringObject;

		private int m_selectedWord = -1;

		private int m_selectedLink = -1;

		private int m_lastIndex = -1;

		private Matrix4x4 m_matrix;

		private TMP_MeshInfo[] m_cachedMeshInfoVertexData;

		private void Awake()
		{
			m_TextMeshPro = base.gameObject.GetComponent<TextMeshProUGUI>();
			m_Canvas = base.gameObject.GetComponentInParent<Canvas>();
			if (m_Canvas.renderMode == RenderMode.ScreenSpaceOverlay)
			{
				m_Camera = null;
			}
			else
			{
				m_Camera = m_Canvas.worldCamera;
			}
			m_TextPopup_RectTransform = UnityEngine.Object.Instantiate(TextPopup_Prefab_01);
			m_TextPopup_RectTransform.SetParent(m_Canvas.transform, worldPositionStays: false);
			m_TextPopup_TMPComponent = m_TextPopup_RectTransform.GetComponentInChildren<TextMeshProUGUI>();
			m_TextPopup_RectTransform.gameObject.SetActive(value: false);
		}

		private void OnEnable()
		{
			TMPro_EventManager.TEXT_CHANGED_EVENT.Add(ON_TEXT_CHANGED);
		}

		private void OnDisable()
		{
			TMPro_EventManager.TEXT_CHANGED_EVENT.Remove(ON_TEXT_CHANGED);
		}

		private void ON_TEXT_CHANGED(UnityEngine.Object obj)
		{
			if (obj == m_TextMeshPro)
			{
				m_cachedMeshInfoVertexData = m_TextMeshPro.textInfo.CopyMeshInfoVertexData();
			}
		}

		private void LateUpdate()
		{
			if (isHoveringObject)
			{
				int num = TMP_TextUtilities.FindIntersectingCharacter(m_TextMeshPro, Input.mousePosition, m_Camera, visibleOnly: true);
				if (num == -1 || num != m_lastIndex)
				{
					RestoreCachedVertexAttributes(m_lastIndex);
					m_lastIndex = -1;
				}
				if (num != -1 && num != m_lastIndex && (Input.GetKey(KeyCode.LeftShift) || Input.GetKey(KeyCode.RightShift)))
				{
					m_lastIndex = num;
					int materialReferenceIndex = m_TextMeshPro.textInfo.characterInfo[num].materialReferenceIndex;
					int vertexIndex = m_TextMeshPro.textInfo.characterInfo[num].vertexIndex;
					Vector3[] vertices = m_TextMeshPro.textInfo.meshInfo[materialReferenceIndex].vertices;
					Vector3 vector = (Vector2)((vertices[vertexIndex] + vertices[vertexIndex + 2]) / 2f);
					vertices[vertexIndex] -= vector;
					vertices[vertexIndex + 1] -= vector;
					vertices[vertexIndex + 2] -= vector;
					vertices[vertexIndex + 3] -= vector;
					float num2 = 1.5f;
					m_matrix = Matrix4x4.TRS(Vector3.zero, Quaternion.identity, Vector3.one * num2);
					vertices[vertexIndex] = m_matrix.MultiplyPoint3x4(vertices[vertexIndex]);
					vertices[vertexIndex + 1] = m_matrix.MultiplyPoint3x4(vertices[vertexIndex + 1]);
					vertices[vertexIndex + 2] = m_matrix.MultiplyPoint3x4(vertices[vertexIndex + 2]);
					vertices[vertexIndex + 3] = m_matrix.MultiplyPoint3x4(vertices[vertexIndex + 3]);
					vertices[vertexIndex] += vector;
					vertices[vertexIndex + 1] += vector;
					vertices[vertexIndex + 2] += vector;
					vertices[vertexIndex + 3] += vector;
					Color32 color = new Color32(byte.MaxValue, byte.MaxValue, 192, byte.MaxValue);
					Color32[] colors = m_TextMeshPro.textInfo.meshInfo[materialReferenceIndex].colors32;
					colors[vertexIndex] = color;
					colors[vertexIndex + 1] = color;
					colors[vertexIndex + 2] = color;
					colors[vertexIndex + 3] = color;
					TMP_MeshInfo tMP_MeshInfo = m_TextMeshPro.textInfo.meshInfo[materialReferenceIndex];
					int dst = vertices.Length - 4;
					tMP_MeshInfo.SwapVertexData(vertexIndex, dst);
					m_TextMeshPro.UpdateVertexData(TMP_VertexDataUpdateFlags.All);
				}
				int num3 = TMP_TextUtilities.FindIntersectingWord(m_TextMeshPro, Input.mousePosition, m_Camera);
				if (m_TextPopup_RectTransform != null && m_selectedWord != -1 && (num3 == -1 || num3 != m_selectedWord))
				{
					TMP_WordInfo tMP_WordInfo = m_TextMeshPro.textInfo.wordInfo[m_selectedWord];
					for (int i = 0; i < tMP_WordInfo.characterCount; i++)
					{
						int num4 = tMP_WordInfo.firstCharacterIndex + i;
						int materialReferenceIndex2 = m_TextMeshPro.textInfo.characterInfo[num4].materialReferenceIndex;
						int vertexIndex2 = m_TextMeshPro.textInfo.characterInfo[num4].vertexIndex;
						Color32[] colors2 = m_TextMeshPro.textInfo.meshInfo[materialReferenceIndex2].colors32;
						colors2[vertexIndex2 + 3] = (colors2[vertexIndex2 + 2] = (colors2[vertexIndex2 + 1] = (colors2[vertexIndex2] = colors2[vertexIndex2].Tint(1.33333f))));
					}
					m_TextMeshPro.UpdateVertexData(TMP_VertexDataUpdateFlags.All);
					m_selectedWord = -1;
				}
				if (num3 != -1 && num3 != m_selectedWord && !Input.GetKey(KeyCode.LeftShift) && !Input.GetKey(KeyCode.RightShift))
				{
					m_selectedWord = num3;
					TMP_WordInfo tMP_WordInfo2 = m_TextMeshPro.textInfo.wordInfo[num3];
					for (int j = 0; j < tMP_WordInfo2.characterCount; j++)
					{
						int num5 = tMP_WordInfo2.firstCharacterIndex + j;
						int materialReferenceIndex3 = m_TextMeshPro.textInfo.characterInfo[num5].materialReferenceIndex;
						int vertexIndex3 = m_TextMeshPro.textInfo.characterInfo[num5].vertexIndex;
						Color32[] colors3 = m_TextMeshPro.textInfo.meshInfo[materialReferenceIndex3].colors32;
						colors3[vertexIndex3 + 3] = (colors3[vertexIndex3 + 2] = (colors3[vertexIndex3 + 1] = (colors3[vertexIndex3] = colors3[vertexIndex3].Tint(0.75f))));
					}
					m_TextMeshPro.UpdateVertexData(TMP_VertexDataUpdateFlags.All);
				}
				int num6 = TMP_TextUtilities.FindIntersectingLink(m_TextMeshPro, Input.mousePosition, m_Camera);
				if ((num6 == -1 && m_selectedLink != -1) || num6 != m_selectedLink)
				{
					m_TextPopup_RectTransform.gameObject.SetActive(value: false);
					m_selectedLink = -1;
				}
				if (num6 != -1 && num6 != m_selectedLink)
				{
					m_selectedLink = num6;
					TMP_LinkInfo tMP_LinkInfo = m_TextMeshPro.textInfo.linkInfo[num6];
					RectTransformUtility.ScreenPointToWorldPointInRectangle(m_TextMeshPro.rectTransform, Input.mousePosition, m_Camera, out var worldPoint);
					switch (tMP_LinkInfo.GetLinkID())
					{
					case "id_01":
						m_TextPopup_RectTransform.position = worldPoint;
						m_TextPopup_RectTransform.gameObject.SetActive(value: true);
						m_TextPopup_TMPComponent.text = "You have selected link <#ffff00> ID 01";
						break;
					case "id_02":
						m_TextPopup_RectTransform.position = worldPoint;
						m_TextPopup_RectTransform.gameObject.SetActive(value: true);
						m_TextPopup_TMPComponent.text = "You have selected link <#ffff00> ID 02";
						break;
					}
				}
			}
			else if (m_lastIndex != -1)
			{
				RestoreCachedVertexAttributes(m_lastIndex);
				m_lastIndex = -1;
			}
		}

		public void OnPointerEnter(PointerEventData eventData)
		{
			isHoveringObject = true;
		}

		public void OnPointerExit(PointerEventData eventData)
		{
			isHoveringObject = false;
		}

		public void OnPointerClick(PointerEventData eventData)
		{
		}

		public void OnPointerUp(PointerEventData eventData)
		{
		}

		private void RestoreCachedVertexAttributes(int index)
		{
			if (index != -1 && index <= m_TextMeshPro.textInfo.characterCount - 1)
			{
				int materialReferenceIndex = m_TextMeshPro.textInfo.characterInfo[index].materialReferenceIndex;
				int vertexIndex = m_TextMeshPro.textInfo.characterInfo[index].vertexIndex;
				Vector3[] vertices = m_cachedMeshInfoVertexData[materialReferenceIndex].vertices;
				Vector3[] vertices2 = m_TextMeshPro.textInfo.meshInfo[materialReferenceIndex].vertices;
				vertices2[vertexIndex] = vertices[vertexIndex];
				vertices2[vertexIndex + 1] = vertices[vertexIndex + 1];
				vertices2[vertexIndex + 2] = vertices[vertexIndex + 2];
				vertices2[vertexIndex + 3] = vertices[vertexIndex + 3];
				Color32[] colors = m_TextMeshPro.textInfo.meshInfo[materialReferenceIndex].colors32;
				Color32[] colors2 = m_cachedMeshInfoVertexData[materialReferenceIndex].colors32;
				colors[vertexIndex] = colors2[vertexIndex];
				colors[vertexIndex + 1] = colors2[vertexIndex + 1];
				colors[vertexIndex + 2] = colors2[vertexIndex + 2];
				colors[vertexIndex + 3] = colors2[vertexIndex + 3];
				Vector2[] uvs = m_cachedMeshInfoVertexData[materialReferenceIndex].uvs0;
				Vector2[] uvs2 = m_TextMeshPro.textInfo.meshInfo[materialReferenceIndex].uvs0;
				uvs2[vertexIndex] = uvs[vertexIndex];
				uvs2[vertexIndex + 1] = uvs[vertexIndex + 1];
				uvs2[vertexIndex + 2] = uvs[vertexIndex + 2];
				uvs2[vertexIndex + 3] = uvs[vertexIndex + 3];
				Vector2[] uvs3 = m_cachedMeshInfoVertexData[materialReferenceIndex].uvs2;
				Vector2[] uvs4 = m_TextMeshPro.textInfo.meshInfo[materialReferenceIndex].uvs2;
				uvs4[vertexIndex] = uvs3[vertexIndex];
				uvs4[vertexIndex + 1] = uvs3[vertexIndex + 1];
				uvs4[vertexIndex + 2] = uvs3[vertexIndex + 2];
				uvs4[vertexIndex + 3] = uvs3[vertexIndex + 3];
				int num = (vertices.Length / 4 - 1) * 4;
				vertices2[num] = vertices[num];
				vertices2[num + 1] = vertices[num + 1];
				vertices2[num + 2] = vertices[num + 2];
				vertices2[num + 3] = vertices[num + 3];
				colors2 = m_cachedMeshInfoVertexData[materialReferenceIndex].colors32;
				Color32[] colors3 = m_TextMeshPro.textInfo.meshInfo[materialReferenceIndex].colors32;
				colors3[num] = colors2[num];
				colors3[num + 1] = colors2[num + 1];
				colors3[num + 2] = colors2[num + 2];
				colors3[num + 3] = colors2[num + 3];
				uvs = m_cachedMeshInfoVertexData[materialReferenceIndex].uvs0;
				Vector2[] uvs5 = m_TextMeshPro.textInfo.meshInfo[materialReferenceIndex].uvs0;
				uvs5[num] = uvs[num];
				uvs5[num + 1] = uvs[num + 1];
				uvs5[num + 2] = uvs[num + 2];
				uvs5[num + 3] = uvs[num + 3];
				uvs3 = m_cachedMeshInfoVertexData[materialReferenceIndex].uvs2;
				Vector2[] uvs6 = m_TextMeshPro.textInfo.meshInfo[materialReferenceIndex].uvs2;
				uvs6[num] = uvs3[num];
				uvs6[num + 1] = uvs3[num + 1];
				uvs6[num + 2] = uvs3[num + 2];
				uvs6[num + 3] = uvs3[num + 3];
				m_TextMeshPro.UpdateVertexData(TMP_VertexDataUpdateFlags.All);
			}
		}
	}
	public class TMP_UiFrameRateCounter : MonoBehaviour
	{
		public enum FpsCounterAnchorPositions
		{
			TopLeft,
			BottomLeft,
			TopRight,
			BottomRight
		}

		public float UpdateInterval = 5f;

		private float m_LastInterval;

		private int m_Frames;

		public FpsCounterAnchorPositions AnchorPosition = FpsCounterAnchorPositions.TopRight;

		private string htmlColorTag;

		private const string fpsLabel = "{0:2}</color> <#8080ff>FPS \n<#FF8000>{1:2} <#8080ff>MS";

		private TextMeshProUGUI m_TextMeshPro;

		private RectTransform m_frameCounter_transform;

		private FpsCounterAnchorPositions last_AnchorPosition;

		private void Awake()
		{
			if (base.enabled)
			{
				Application.targetFrameRate = 1000;
				GameObject gameObject = new GameObject("Frame Counter");
				m_frameCounter_transform = gameObject.AddComponent<RectTransform>();
				m_frameCounter_transform.SetParent(base.transform, worldPositionStays: false);
				m_TextMeshPro = gameObject.AddComponent<TextMeshProUGUI>();
				m_TextMeshPro.font = Resources.Load<TMP_FontAsset>("Fonts & Materials/LiberationSans SDF");
				m_TextMeshPro.fontSharedMaterial = Resources.Load<Material>("Fonts & Materials/LiberationSans SDF - Overlay");
				m_TextMeshPro.enableWordWrapping = false;
				m_TextMeshPro.fontSize = 36f;
				m_TextMeshPro.isOverlay = true;
				Set_FrameCounter_Position(AnchorPosition);
				last_AnchorPosition = AnchorPosition;
			}
		}

		private void Start()
		{
			m_LastInterval = Time.realtimeSinceStartup;
			m_Frames = 0;
		}

		private void Update()
		{
			if (AnchorPosition != last_AnchorPosition)
			{
				Set_FrameCounter_Position(AnchorPosition);
			}
			last_AnchorPosition = AnchorPosition;
			m_Frames++;
			float realtimeSinceStartup = Time.realtimeSinceStartup;
			if (realtimeSinceStartup > m_LastInterval + UpdateInterval)
			{
				float num = (float)m_Frames / (realtimeSinceStartup - m_LastInterval);
				float arg = 1000f / Mathf.Max(num, 1E-05f);
				if (num < 30f)
				{
					htmlColorTag = "<color=yellow>";
				}
				else if (num < 10f)
				{
					htmlColorTag = "<color=red>";
				}
				else
				{
					htmlColorTag = "<color=green>";
				}
				m_TextMeshPro.SetText(htmlColorTag + "{0:2}</color> <#8080ff>FPS \n<#FF8000>{1:2} <#8080ff>MS", num, arg);
				m_Frames = 0;
				m_LastInterval = realtimeSinceStartup;
			}
		}

		private void Set_FrameCounter_Position(FpsCounterAnchorPositions anchor_position)
		{
			switch (anchor_position)
			{
			case FpsCounterAnchorPositions.TopLeft:
				m_TextMeshPro.alignment = TextAlignmentOptions.TopLeft;
				m_frameCounter_transform.pivot = new Vector2(0f, 1f);
				m_frameCounter_transform.anchorMin = new Vector2(0.01f, 0.99f);
				m_frameCounter_transform.anchorMax = new Vector2(0.01f, 0.99f);
				m_frameCounter_transform.anchoredPosition = new Vector2(0f, 1f);
				break;
			case FpsCounterAnchorPositions.BottomLeft:
				m_TextMeshPro.alignment = TextAlignmentOptions.BottomLeft;
				m_frameCounter_transform.pivot = new Vector2(0f, 0f);
				m_frameCounter_transform.anchorMin = new Vector2(0.01f, 0.01f);
				m_frameCounter_transform.anchorMax = new Vector2(0.01f, 0.01f);
				m_frameCounter_transform.anchoredPosition = new Vector2(0f, 0f);
				break;
			case FpsCounterAnchorPositions.TopRight:
				m_TextMeshPro.alignment = TextAlignmentOptions.TopRight;
				m_frameCounter_transform.pivot = new Vector2(1f, 1f);
				m_frameCounter_transform.anchorMin = new Vector2(0.99f, 0.99f);
				m_frameCounter_transform.anchorMax = new Vector2(0.99f, 0.99f);
				m_frameCounter_transform.anchoredPosition = new Vector2(1f, 1f);
				break;
			case FpsCounterAnchorPositions.BottomRight:
				m_TextMeshPro.alignment = TextAlignmentOptions.BottomRight;
				m_frameCounter_transform.pivot = new Vector2(1f, 0f);
				m_frameCounter_transform.anchorMin = new Vector2(0.99f, 0.01f);
				m_frameCounter_transform.anchorMax = new Vector2(0.99f, 0.01f);
				m_frameCounter_transform.anchoredPosition = new Vector2(1f, 0f);
				break;
			}
		}
	}
	public class TMPro_InstructionOverlay : MonoBehaviour
	{
		public enum FpsCounterAnchorPositions
		{
			TopLeft,
			BottomLeft,
			TopRight,
			BottomRight
		}

		public FpsCounterAnchorPositions AnchorPosition = FpsCounterAnchorPositions.BottomLeft;

		private const string instructions = "Camera Control - <#ffff00>Shift + RMB\n</color>Zoom - <#ffff00>Mouse wheel.";

		private TextMeshPro m_TextMeshPro;

		private TextContainer m_textContainer;

		private Transform m_frameCounter_transform;

		private Camera m_camera;

		private void Awake()
		{
			if (base.enabled)
			{
				m_camera = Camera.main;
				GameObject gameObject = new GameObject("Frame Counter");
				m_frameCounter_transform = gameObject.transform;
				m_frameCounter_transform.parent = m_camera.transform;
				m_frameCounter_transform.localRotation = Quaternion.identity;
				m_TextMeshPro = gameObject.AddComponent<TextMeshPro>();
				m_TextMeshPro.font = Resources.Load<TMP_FontAsset>("Fonts & Materials/LiberationSans SDF");
				m_TextMeshPro.fontSharedMaterial = Resources.Load<Material>("Fonts & Materials/LiberationSans SDF - Overlay");
				m_TextMeshPro.fontSize = 30f;
				m_TextMeshPro.isOverlay = true;
				m_textContainer = gameObject.GetComponent<TextContainer>();
				Set_FrameCounter_Position(AnchorPosition);
				m_TextMeshPro.text = "Camera Control - <#ffff00>Shift + RMB\n</color>Zoom - <#ffff00>Mouse wheel.";
			}
		}

		private void Set_FrameCounter_Position(FpsCounterAnchorPositions anchor_position)
		{
			switch (anchor_position)
			{
			case FpsCounterAnchorPositions.TopLeft:
				m_textContainer.anchorPosition = TextContainerAnchors.TopLeft;
				m_frameCounter_transform.position = m_camera.ViewportToWorldPoint(new Vector3(0f, 1f, 100f));
				break;
			case FpsCounterAnchorPositions.BottomLeft:
				m_textContainer.anchorPosition = TextContainerAnchors.BottomLeft;
				m_frameCounter_transform.position = m_camera.ViewportToWorldPoint(new Vector3(0f, 0f, 100f));
				break;
			case FpsCounterAnchorPositions.TopRight:
				m_textContainer.anchorPosition = TextContainerAnchors.TopRight;
				m_frameCounter_transform.position = m_camera.ViewportToWorldPoint(new Vector3(1f, 1f, 100f));
				break;
			case FpsCounterAnchorPositions.BottomRight:
				m_textContainer.anchorPosition = TextContainerAnchors.BottomRight;
				m_frameCounter_transform.position = m_camera.ViewportToWorldPoint(new Vector3(1f, 0f, 100f));
				break;
			}
		}
	}
	public class TeleType : MonoBehaviour
	{
		private string label01 = "Example <sprite=2> of using <sprite=7> <#ffa000>Graphics Inline</color> <sprite=5> with Text in <font=\"Bangers SDF\" material=\"Bangers SDF - Drop Shadow\">TextMesh<#40a0ff>Pro</color></font><sprite=0> and Unity<sprite=1>";

		private string label02 = "Example <sprite=2> of using <sprite=7> <#ffa000>Graphics Inline</color> <sprite=5> with Text in <font=\"Bangers SDF\" material=\"Bangers SDF - Drop Shadow\">TextMesh<#40a0ff>Pro</color></font><sprite=0> and Unity<sprite=2>";

		private TMP_Text m_textMeshPro;

		private void Awake()
		{
			m_textMeshPro = GetComponent<TMP_Text>();
			m_textMeshPro.text = label01;
			m_textMeshPro.enableWordWrapping = true;
			m_textMeshPro.alignment = TextAlignmentOptions.Top;
		}

		private IEnumerator Start()
		{
			m_textMeshPro.ForceMeshUpdate();
			int totalVisibleCharacters = m_textMeshPro.textInfo.characterCount;
			int counter = 0;
			while (true)
			{
				int num = counter % (totalVisibleCharacters + 1);
				m_textMeshPro.maxVisibleCharacters = num;
				if (num >= totalVisibleCharacters)
				{
					yield return new WaitForSeconds(1f);
					m_textMeshPro.text = label02;
					yield return new WaitForSeconds(1f);
					m_textMeshPro.text = label01;
					yield return new WaitForSeconds(1f);
				}
				counter++;
				yield return new WaitForSeconds(0.05f);
			}
		}
	}
	public class TextConsoleSimulator : MonoBehaviour
	{
		private TMP_Text m_TextComponent;

		private bool hasTextChanged;

		private void Awake()
		{
			m_TextComponent = base.gameObject.GetComponent<TMP_Text>();
		}

		private void Start()
		{
			StartCoroutine(RevealCharacters(m_TextComponent));
		}

		private void OnEnable()
		{
			TMPro_EventManager.TEXT_CHANGED_EVENT.Add(ON_TEXT_CHANGED);
		}

		private void OnDisable()
		{
			TMPro_EventManager.TEXT_CHANGED_EVENT.Remove(ON_TEXT_CHANGED);
		}

		private void ON_TEXT_CHANGED(UnityEngine.Object obj)
		{
			hasTextChanged = true;
		}

		private IEnumerator RevealCharacters(TMP_Text textComponent)
		{
			textComponent.ForceMeshUpdate();
			TMP_TextInfo textInfo = textComponent.textInfo;
			int totalVisibleCharacters = textInfo.characterCount;
			int visibleCount = 0;
			while (true)
			{
				if (hasTextChanged)
				{
					totalVisibleCharacters = textInfo.characterCount;
					hasTextChanged = false;
				}
				if (visibleCount > totalVisibleCharacters)
				{
					yield return new WaitForSeconds(1f);
					visibleCount = 0;
				}
				textComponent.maxVisibleCharacters = visibleCount;
				visibleCount++;
				yield return null;
			}
		}

		private IEnumerator RevealWords(TMP_Text textComponent)
		{
			textComponent.ForceMeshUpdate();
			int totalWordCount = textComponent.textInfo.wordCount;
			int totalVisibleCharacters = textComponent.textInfo.characterCount;
			int counter = 0;
			int visibleCount = 0;
			while (true)
			{
				int num = counter % (totalWordCount + 1);
				if (num == 0)
				{
					visibleCount = 0;
				}
				else if (num < totalWordCount)
				{
					visibleCount = textComponent.textInfo.wordInfo[num - 1].lastCharacterIndex + 1;
				}
				else if (num == totalWordCount)
				{
					visibleCount = totalVisibleCharacters;
				}
				textComponent.maxVisibleCharacters = visibleCount;
				if (visibleCount >= totalVisibleCharacters)
				{
					yield return new WaitForSeconds(1f);
				}
				counter++;
				yield return new WaitForSeconds(0.1f);
			}
		}
	}
	public class TextMeshProFloatingText : MonoBehaviour
	{
		public Font TheFont;

		private GameObject m_floatingText;

		private TextMeshPro m_textMeshPro;

		private TextMesh m_textMesh;

		private Transform m_transform;

		private Transform m_floatingText_Transform;

		private Transform m_cameraTransform;

		private Vector3 lastPOS = Vector3.zero;

		private Quaternion lastRotation = Quaternion.identity;

		public int SpawnType;

		private void Awake()
		{
			m_transform = base.transform;
			m_floatingText = new GameObject(base.name + " floating text");
			m_cameraTransform = Camera.main.transform;
		}

		private void Start()
		{
			if (SpawnType == 0)
			{
				m_textMeshPro = m_floatingText.AddComponent<TextMeshPro>();
				m_textMeshPro.rectTransform.sizeDelta = new Vector2(3f, 3f);
				m_floatingText_Transform = m_floatingText.transform;
				m_floatingText_Transform.position = m_transform.position + new Vector3(0f, 15f, 0f);
				m_textMeshPro.alignment = TextAlignmentOptions.Center;
				m_textMeshPro.color = new Color32((byte)UnityEngine.Random.Range(0, 255), (byte)UnityEngine.Random.Range(0, 255), (byte)UnityEngine.Random.Range(0, 255), byte.MaxValue);
				m_textMeshPro.fontSize = 24f;
				m_textMeshPro.enableKerning = false;
				m_textMeshPro.text = string.Empty;
				m_textMeshPro.isTextObjectScaleStatic = true;
				StartCoroutine(DisplayTextMeshProFloatingText());
			}
			else if (SpawnType == 1)
			{
				m_floatingText_Transform = m_floatingText.transform;
				m_floatingText_Transform.position = m_transform.position + new Vector3(0f, 15f, 0f);
				m_textMesh = m_floatingText.AddComponent<TextMesh>();
				m_textMesh.font = Resources.Load<Font>("Fonts/ARIAL");
				m_textMesh.GetComponent<Renderer>().sharedMaterial = m_textMesh.font.material;
				m_textMesh.color = new Color32((byte)UnityEngine.Random.Range(0, 255), (byte)UnityEngine.Random.Range(0, 255), (byte)UnityEngine.Random.Range(0, 255), byte.MaxValue);
				m_textMesh.anchor = TextAnchor.LowerCenter;
				m_textMesh.fontSize = 24;
				StartCoroutine(DisplayTextMeshFloatingText());
			}
			else
			{
				_ = SpawnType;
				_ = 2;
			}
		}

		public IEnumerator DisplayTextMeshProFloatingText()
		{
			float CountDuration = 2f;
			float starting_Count = UnityEngine.Random.Range(5f, 20f);
			float current_Count = starting_Count;
			Vector3 start_pos = m_floatingText_Transform.position;
			Color32 start_color = m_textMeshPro.color;
			float alpha = 255f;
			float fadeDuration = 3f / starting_Count * CountDuration;
			while (current_Count > 0f)
			{
				current_Count -= Time.deltaTime / CountDuration * starting_Count;
				if (current_Count <= 3f)
				{
					alpha = Mathf.Clamp(alpha - Time.deltaTime / fadeDuration * 255f, 0f, 255f);
				}
				m_textMeshPro.text = ((int)current_Count).ToString();
				m_textMeshPro.color = new Color32(start_color.r, start_color.g, start_color.b, (byte)alpha);
				m_floatingText_Transform.position += new Vector3(0f, starting_Count * Time.deltaTime, 0f);
				if (!lastPOS.Compare(m_cameraTransform.position, 1000) || !lastRotation.Compare(m_cameraTransform.rotation, 1000))
				{
					lastPOS = m_cameraTransform.position;
					lastRotation = m_cameraTransform.rotation;
					m_floatingText_Transform.rotation = lastRotation;
					Vector3 vector = m_transform.position - lastPOS;
					m_transform.forward = new Vector3(vector.x, 0f, vector.z);
				}
				yield return new WaitForEndOfFrame();
			}
			yield return new WaitForSeconds(UnityEngine.Random.Range(0.1f, 1f));
			m_floatingText_Transform.position = start_pos;
			StartCoroutine(DisplayTextMeshProFloatingText());
		}

		public IEnumerator DisplayTextMeshFloatingText()
		{
			float CountDuration = 2f;
			float starting_Count = UnityEngine.Random.Range(5f, 20f);
			float current_Count = starting_Count;
			Vector3 start_pos = m_floatingText_Transform.position;
			Color32 start_color = m_textMesh.color;
			float alpha = 255f;
			float fadeDuration = 3f / starting_Count * CountDuration;
			while (current_Count > 0f)
			{
				current_Count -= Time.deltaTime / CountDuration * starting_Count;
				if (current_Count <= 3f)
				{
					alpha = Mathf.Clamp(alpha - Time.deltaTime / fadeDuration * 255f, 0f, 255f);
				}
				m_textMesh.text = ((int)current_Count).ToString();
				m_textMesh.color = new Color32(start_color.r, start_color.g, start_color.b, (byte)alpha);
				m_floatingText_Transform.position += new Vector3(0f, starting_Count * Time.deltaTime, 0f);
				if (!lastPOS.Compare(m_cameraTransform.position, 1000) || !lastRotation.Compare(m_cameraTransform.rotation, 1000))
				{
					lastPOS = m_cameraTransform.position;
					lastRotation = m_cameraTransform.rotation;
					m_floatingText_Transform.rotation = lastRotation;
					Vector3 vector = m_transform.position - lastPOS;
					m_transform.forward = new Vector3(vector.x, 0f, vector.z);
				}
				yield return new WaitForEndOfFrame();
			}
			yield return new WaitForSeconds(UnityEngine.Random.Range(0.1f, 1f));
			m_floatingText_Transform.position = start_pos;
			StartCoroutine(DisplayTextMeshFloatingText());
		}
	}
	public class TextMeshSpawner : MonoBehaviour
	{
		public int SpawnType;

		public int NumberOfNPC = 12;

		public Font TheFont;

		private TextMeshProFloatingText floatingText_Script;

		private void Awake()
		{
		}

		private void Start()
		{
			for (int i = 0; i < NumberOfNPC; i++)
			{
				if (SpawnType == 0)
				{
					GameObject gameObject = new GameObject();
					gameObject.transform.position = new Vector3(UnityEngine.Random.Range(-95f, 95f), 0.5f, UnityEngine.Random.Range(-95f, 95f));
					TextMeshPro textMeshPro = gameObject.AddComponent<TextMeshPro>();
					textMeshPro.fontSize = 96f;
					textMeshPro.text = "!";
					textMeshPro.color = new Color32(byte.MaxValue, byte.MaxValue, 0, byte.MaxValue);
					floatingText_Script = gameObject.AddComponent<TextMeshProFloatingText>();
					floatingText_Script.SpawnType = 0;
				}
				else
				{
					GameObject gameObject2 = new GameObject();
					gameObject2.transform.position = new Vector3(UnityEngine.Random.Range(-95f, 95f), 0.5f, UnityEngine.Random.Range(-95f, 95f));
					TextMesh textMesh = gameObject2.AddComponent<TextMesh>();
					textMesh.GetComponent<Renderer>().sharedMaterial = TheFont.material;
					textMesh.font = TheFont;
					textMesh.anchor = TextAnchor.LowerCenter;
					textMesh.fontSize = 96;
					textMesh.color = new Color32(byte.MaxValue, byte.MaxValue, 0, byte.MaxValue);
					textMesh.text = "!";
					floatingText_Script = gameObject2.AddComponent<TextMeshProFloatingText>();
					floatingText_Script.SpawnType = 1;
				}
			}
		}
	}
	public class VertexColorCycler : MonoBehaviour
	{
		private TMP_Text m_TextComponent;

		private void Awake()
		{
			m_TextComponent = GetComponent<TMP_Text>();
		}

		private void Start()
		{
			StartCoroutine(AnimateVertexColors());
		}

		private IEnumerator AnimateVertexColors()
		{
			m_TextComponent.ForceMeshUpdate();
			TMP_TextInfo textInfo = m_TextComponent.textInfo;
			int currentCharacter = 0;
			_ = (Color32)m_TextComponent.color;
			while (true)
			{
				int characterCount = textInfo.characterCount;
				if (characterCount == 0)
				{
					yield return new WaitForSeconds(0.25f);
					continue;
				}
				int materialReferenceIndex = textInfo.characterInfo[currentCharacter].materialReferenceIndex;
				Color32[] colors = textInfo.meshInfo[materialReferenceIndex].colors32;
				int vertexIndex = textInfo.characterInfo[currentCharacter].vertexIndex;
				if (textInfo.characterInfo[currentCharacter].isVisible)
				{
					colors[vertexIndex + 3] = (colors[vertexIndex + 2] = (colors[vertexIndex + 1] = (colors[vertexIndex] = new Color32((byte)UnityEngine.Random.Range(0, 255), (byte)UnityEngine.Random.Range(0, 255), (byte)UnityEngine.Random.Range(0, 255), byte.MaxValue))));
					m_TextComponent.UpdateVertexData(TMP_VertexDataUpdateFlags.Colors32);
				}
				currentCharacter = (currentCharacter + 1) % characterCount;
				yield return new WaitForSeconds(0.05f);
			}
		}
	}
	public class VertexJitter : MonoBehaviour
	{
		private struct VertexAnim
		{
			public float angleRange;

			public float angle;

			public float speed;
		}

		public float AngleMultiplier = 1f;

		public float SpeedMultiplier = 1f;

		public float CurveScale = 1f;

		private TMP_Text m_TextComponent;

		private bool hasTextChanged;

		private void Awake()
		{
			m_TextComponent = GetComponent<TMP_Text>();
		}

		private void OnEnable()
		{
			TMPro_EventManager.TEXT_CHANGED_EVENT.Add(ON_TEXT_CHANGED);
		}

		private void OnDisable()
		{
			TMPro_EventManager.TEXT_CHANGED_EVENT.Remove(ON_TEXT_CHANGED);
		}

		private void Start()
		{
			StartCoroutine(AnimateVertexColors());
		}

		private void ON_TEXT_CHANGED(UnityEngine.Object obj)
		{
			if (obj == m_TextComponent)
			{
				hasTextChanged = true;
			}
		}

		private IEnumerator AnimateVertexColors()
		{
			m_TextComponent.ForceMeshUpdate();
			TMP_TextInfo textInfo = m_TextComponent.textInfo;
			int loopCount = 0;
			hasTextChanged = true;
			VertexAnim[] vertexAnim = new VertexAnim[1024];
			for (int i = 0; i < 1024; i++)
			{
				vertexAnim[i].angleRange = UnityEngine.Random.Range(10f, 25f);
				vertexAnim[i].speed = UnityEngine.Random.Range(1f, 3f);
			}
			TMP_MeshInfo[] cachedMeshInfo = textInfo.CopyMeshInfoVertexData();
			while (true)
			{
				if (hasTextChanged)
				{
					cachedMeshInfo = textInfo.CopyMeshInfoVertexData();
					hasTextChanged = false;
				}
				int characterCount = textInfo.characterCount;
				if (characterCount == 0)
				{
					yield return new WaitForSeconds(0.25f);
					continue;
				}
				for (int j = 0; j < characterCount; j++)
				{
					if (textInfo.characterInfo[j].isVisible)
					{
						VertexAnim vertexAnim2 = vertexAnim[j];
						int materialReferenceIndex = textInfo.characterInfo[j].materialReferenceIndex;
						int vertexIndex = textInfo.characterInfo[j].vertexIndex;
						Vector3[] vertices = cachedMeshInfo[materialReferenceIndex].vertices;
						Vector3 vector = (Vector2)((vertices[vertexIndex] + vertices[vertexIndex + 2]) / 2f);
						Vector3[] vertices2 = textInfo.meshInfo[materialReferenceIndex].vertices;
						vertices2[vertexIndex] = vertices[vertexIndex] - vector;
						vertices2[vertexIndex + 1] = vertices[vertexIndex + 1] - vector;
						vertices2[vertexIndex + 2] = vertices[vertexIndex + 2] - vector;
						vertices2[vertexIndex + 3] = vertices[vertexIndex + 3] - vector;
						vertexAnim2.angle = Mathf.SmoothStep(0f - vertexAnim2.angleRange, vertexAnim2.angleRange, Mathf.PingPong((float)loopCount / 25f * vertexAnim2.speed, 1f));
						Matrix4x4 matrix4x = Matrix4x4.TRS(new Vector3(UnityEngine.Random.Range(-0.25f, 0.25f), UnityEngine.Random.Range(-0.25f, 0.25f), 0f) * CurveScale, Quaternion.Euler(0f, 0f, UnityEngine.Random.Range(-5f, 5f) * AngleMultiplier), Vector3.one);
						vertices2[vertexIndex] = matrix4x.MultiplyPoint3x4(vertices2[vertexIndex]);
						vertices2[vertexIndex + 1] = matrix4x.MultiplyPoint3x4(vertices2[vertexIndex + 1]);
						vertices2[vertexIndex + 2] = matrix4x.MultiplyPoint3x4(vertices2[vertexIndex + 2]);
						vertices2[vertexIndex + 3] = matrix4x.MultiplyPoint3x4(vertices2[vertexIndex + 3]);
						vertices2[vertexIndex] += vector;
						vertices2[vertexIndex + 1] += vector;
						vertices2[vertexIndex + 2] += vector;
						vertices2[vertexIndex + 3] += vector;
						vertexAnim[j] = vertexAnim2;
					}
				}
				for (int k = 0; k < textInfo.meshInfo.Length; k++)
				{
					textInfo.meshInfo[k].mesh.vertices = textInfo.meshInfo[k].vertices;
					m_TextComponent.UpdateGeometry(textInfo.meshInfo[k].mesh, k);
				}
				loopCount++;
				yield return new WaitForSeconds(0.1f);
			}
		}
	}
	public class VertexShakeA : MonoBehaviour
	{
		public float AngleMultiplier = 1f;

		public float SpeedMultiplier = 1f;

		public float ScaleMultiplier = 1f;

		public float RotationMultiplier = 1f;

		private TMP_Text m_TextComponent;

		private bool hasTextChanged;

		private void Awake()
		{
			m_TextComponent = GetComponent<TMP_Text>();
		}

		private void OnEnable()
		{
			TMPro_EventManager.TEXT_CHANGED_EVENT.Add(ON_TEXT_CHANGED);
		}

		private void OnDisable()
		{
			TMPro_EventManager.TEXT_CHANGED_EVENT.Remove(ON_TEXT_CHANGED);
		}

		private void Start()
		{
			StartCoroutine(AnimateVertexColors());
		}

		private void ON_TEXT_CHANGED(UnityEngine.Object obj)
		{
			if ((bool)(obj = m_TextComponent))
			{
				hasTextChanged = true;
			}
		}

		private IEnumerator AnimateVertexColors()
		{
			m_TextComponent.ForceMeshUpdate();
			TMP_TextInfo textInfo = m_TextComponent.textInfo;
			Vector3[][] copyOfVertices = new Vector3[0][];
			hasTextChanged = true;
			while (true)
			{
				if (hasTextChanged)
				{
					if (copyOfVertices.Length < textInfo.meshInfo.Length)
					{
						copyOfVertices = new Vector3[textInfo.meshInfo.Length][];
					}
					for (int i = 0; i < textInfo.meshInfo.Length; i++)
					{
						int num = textInfo.meshInfo[i].vertices.Length;
						copyOfVertices[i] = new Vector3[num];
					}
					hasTextChanged = false;
				}
				if (textInfo.characterCount == 0)
				{
					yield return new WaitForSeconds(0.25f);
					continue;
				}
				int lineCount = textInfo.lineCount;
				for (int j = 0; j < lineCount; j++)
				{
					int firstCharacterIndex = textInfo.lineInfo[j].firstCharacterIndex;
					int lastCharacterIndex = textInfo.lineInfo[j].lastCharacterIndex;
					Vector3 vector = (textInfo.characterInfo[firstCharacterIndex].bottomLeft + textInfo.characterInfo[lastCharacterIndex].topRight) / 2f;
					Quaternion q = Quaternion.Euler(0f, 0f, UnityEngine.Random.Range(-0.25f, 0.25f) * RotationMultiplier);
					for (int k = firstCharacterIndex; k <= lastCharacterIndex; k++)
					{
						if (textInfo.characterInfo[k].isVisible)
						{
							int materialReferenceIndex = textInfo.characterInfo[k].materialReferenceIndex;
							int vertexIndex = textInfo.characterInfo[k].vertexIndex;
							Vector3[] vertices = textInfo.meshInfo[materialReferenceIndex].vertices;
							copyOfVertices[materialReferenceIndex][vertexIndex] = vertices[vertexIndex] - vector;
							copyOfVertices[materialReferenceIndex][vertexIndex + 1] = vertices[vertexIndex + 1] - vector;
							copyOfVertices[materialReferenceIndex][vertexIndex + 2] = vertices[vertexIndex + 2] - vector;
							copyOfVertices[materialReferenceIndex][vertexIndex + 3] = vertices[vertexIndex + 3] - vector;
							float num2 = UnityEngine.Random.Range(0.995f - 0.001f * ScaleMultiplier, 1.005f + 0.001f * ScaleMultiplier);
							Matrix4x4 matrix4x = Matrix4x4.TRS(Vector3.one, q, Vector3.one * num2);
							copyOfVertices[materialReferenceIndex][vertexIndex] = matrix4x.MultiplyPoint3x4(copyOfVertices[materialReferenceIndex][vertexIndex]);
							copyOfVertices[materialReferenceIndex][vertexIndex + 1] = matrix4x.MultiplyPoint3x4(copyOfVertices[materialReferenceIndex][vertexIndex + 1]);
							copyOfVertices[materialReferenceIndex][vertexIndex + 2] = matrix4x.MultiplyPoint3x4(copyOfVertices[materialReferenceIndex][vertexIndex + 2]);
							copyOfVertices[materialReferenceIndex][vertexIndex + 3] = matrix4x.MultiplyPoint3x4(copyOfVertices[materialReferenceIndex][vertexIndex + 3]);
							copyOfVertices[materialReferenceIndex][vertexIndex] += vector;
							copyOfVertices[materialReferenceIndex][vertexIndex + 1] += vector;
							copyOfVertices[materialReferenceIndex][vertexIndex + 2] += vector;
							copyOfVertices[materialReferenceIndex][vertexIndex + 3] += vector;
						}
					}
				}
				for (int l = 0; l < textInfo.meshInfo.Length; l++)
				{
					textInfo.meshInfo[l].mesh.vertices = copyOfVertices[l];
					m_TextComponent.UpdateGeometry(textInfo.meshInfo[l].mesh, l);
				}
				yield return new WaitForSeconds(0.1f);
			}
		}
	}
	public class VertexShakeB : MonoBehaviour
	{
		public float AngleMultiplier = 1f;

		public float SpeedMultiplier = 1f;

		public float CurveScale = 1f;

		private TMP_Text m_TextComponent;

		private bool hasTextChanged;

		private void Awake()
		{
			m_TextComponent = GetComponent<TMP_Text>();
		}

		private void OnEnable()
		{
			TMPro_EventManager.TEXT_CHANGED_EVENT.Add(ON_TEXT_CHANGED);
		}

		private void OnDisable()
		{
			TMPro_EventManager.TEXT_CHANGED_EVENT.Remove(ON_TEXT_CHANGED);
		}

		private void Start()
		{
			StartCoroutine(AnimateVertexColors());
		}

		private void ON_TEXT_CHANGED(UnityEngine.Object obj)
		{
			if ((bool)(obj = m_TextComponent))
			{
				hasTextChanged = true;
			}
		}

		private IEnumerator AnimateVertexColors()
		{
			m_TextComponent.ForceMeshUpdate();
			TMP_TextInfo textInfo = m_TextComponent.textInfo;
			Vector3[][] copyOfVertices = new Vector3[0][];
			hasTextChanged = true;
			while (true)
			{
				if (hasTextChanged)
				{
					if (copyOfVertices.Length < textInfo.meshInfo.Length)
					{
						copyOfVertices = new Vector3[textInfo.meshInfo.Length][];
					}
					for (int i = 0; i < textInfo.meshInfo.Length; i++)
					{
						int num = textInfo.meshInfo[i].vertices.Length;
						copyOfVertices[i] = new Vector3[num];
					}
					hasTextChanged = false;
				}
				if (textInfo.characterCount == 0)
				{
					yield return new WaitForSeconds(0.25f);
					continue;
				}
				int lineCount = textInfo.lineCount;
				for (int j = 0; j < lineCount; j++)
				{
					int firstCharacterIndex = textInfo.lineInfo[j].firstCharacterIndex;
					int lastCharacterIndex = textInfo.lineInfo[j].lastCharacterIndex;
					Vector3 vector = (textInfo.characterInfo[firstCharacterIndex].bottomLeft + textInfo.characterInfo[lastCharacterIndex].topRight) / 2f;
					Quaternion q = Quaternion.Euler(0f, 0f, UnityEngine.Random.Range(-0.25f, 0.25f));
					for (int k = firstCharacterIndex; k <= lastCharacterIndex; k++)
					{
						if (textInfo.characterInfo[k].isVisible)
						{
							int materialReferenceIndex = textInfo.characterInfo[k].materialReferenceIndex;
							int vertexIndex = textInfo.characterInfo[k].vertexIndex;
							Vector3[] vertices = textInfo.meshInfo[materialReferenceIndex].vertices;
							Vector3 vector2 = (vertices[vertexIndex] + vertices[vertexIndex + 2]) / 2f;
							copyOfVertices[materialReferenceIndex][vertexIndex] = vertices[vertexIndex] - vector2;
							copyOfVertices[materialReferenceIndex][vertexIndex + 1] = vertices[vertexIndex + 1] - vector2;
							copyOfVertices[materialReferenceIndex][vertexIndex + 2] = vertices[vertexIndex + 2] - vector2;
							copyOfVertices[materialReferenceIndex][vertexIndex + 3] = vertices[vertexIndex + 3] - vector2;
							float num2 = UnityEngine.Random.Range(0.95f, 1.05f);
							Matrix4x4 matrix4x = Matrix4x4.TRS(Vector3.one, Quaternion.identity, Vector3.one * num2);
							copyOfVertices[materialReferenceIndex][vertexIndex] = matrix4x.MultiplyPoint3x4(copyOfVertices[materialReferenceIndex][vertexIndex]);
							copyOfVertices[materialReferenceIndex][vertexIndex + 1] = matrix4x.MultiplyPoint3x4(copyOfVertices[materialReferenceIndex][vertexIndex + 1]);
							copyOfVertices[materialReferenceIndex][vertexIndex + 2] = matrix4x.MultiplyPoint3x4(copyOfVertices[materialReferenceIndex][vertexIndex + 2]);
							copyOfVertices[materialReferenceIndex][vertexIndex + 3] = matrix4x.MultiplyPoint3x4(copyOfVertices[materialReferenceIndex][vertexIndex + 3]);
							copyOfVertices[materialReferenceIndex][vertexIndex] += vector2;
							copyOfVertices[materialReferenceIndex][vertexIndex + 1] += vector2;
							copyOfVertices[materialReferenceIndex][vertexIndex + 2] += vector2;
							copyOfVertices[materialReferenceIndex][vertexIndex + 3] += vector2;
							copyOfVertices[materialReferenceIndex][vertexIndex] -= vector;
							copyOfVertices[materialReferenceIndex][vertexIndex + 1] -= vector;
							copyOfVertices[materialReferenceIndex][vertexIndex + 2] -= vector;
							copyOfVertices[materialReferenceIndex][vertexIndex + 3] -= vector;
							matrix4x = Matrix4x4.TRS(Vector3.one, q, Vector3.one);
							copyOfVertices[materialReferenceIndex][vertexIndex] = matrix4x.MultiplyPoint3x4(copyOfVertices[materialReferenceIndex][vertexIndex]);
							copyOfVertices[materialReferenceIndex][vertexIndex + 1] = matrix4x.MultiplyPoint3x4(copyOfVertices[materialReferenceIndex][vertexIndex + 1]);
							copyOfVertices[materialReferenceIndex][vertexIndex + 2] = matrix4x.MultiplyPoint3x4(copyOfVertices[materialReferenceIndex][vertexIndex + 2]);
							copyOfVertices[materialReferenceIndex][vertexIndex + 3] = matrix4x.MultiplyPoint3x4(copyOfVertices[materialReferenceIndex][vertexIndex + 3]);
							copyOfVertices[materialReferenceIndex][vertexIndex] += vector;
							copyOfVertices[materialReferenceIndex][vertexIndex + 1] += vector;
							copyOfVertices[materialReferenceIndex][vertexIndex + 2] += vector;
							copyOfVertices[materialReferenceIndex][vertexIndex + 3] += vector;
						}
					}
				}
				for (int l = 0; l < textInfo.meshInfo.Length; l++)
				{
					textInfo.meshInfo[l].mesh.vertices = copyOfVertices[l];
					m_TextComponent.UpdateGeometry(textInfo.meshInfo[l].mesh, l);
				}
				yield return new WaitForSeconds(0.1f);
			}
		}
	}
	public class VertexZoom : MonoBehaviour
	{
		public float AngleMultiplier = 1f;

		public float SpeedMultiplier = 1f;

		public float CurveScale = 1f;

		private TMP_Text m_TextComponent;

		private bool hasTextChanged;

		private void Awake()
		{
			m_TextComponent = GetComponent<TMP_Text>();
		}

		private void OnEnable()
		{
			TMPro_EventManager.TEXT_CHANGED_EVENT.Add(ON_TEXT_CHANGED);
		}

		private void OnDisable()
		{
			TMPro_EventManager.TEXT_CHANGED_EVENT.Remove(ON_TEXT_CHANGED);
		}

		private void Start()
		{
			StartCoroutine(AnimateVertexColors());
		}

		private void ON_TEXT_CHANGED(UnityEngine.Object obj)
		{
			if (obj == m_TextComponent)
			{
				hasTextChanged = true;
			}
		}

		private IEnumerator AnimateVertexColors()
		{
			m_TextComponent.ForceMeshUpdate();
			TMP_TextInfo textInfo = m_TextComponent.textInfo;
			TMP_MeshInfo[] cachedMeshInfoVertexData = textInfo.CopyMeshInfoVertexData();
			List<float> modifiedCharScale = new List<float>();
			List<int> scaleSortingOrder = new List<int>();
			hasTextChanged = true;
			while (true)
			{
				if (hasTextChanged)
				{
					cachedMeshInfoVertexData = textInfo.CopyMeshInfoVertexData();
					hasTextChanged = false;
				}
				int characterCount = textInfo.characterCount;
				if (characterCount == 0)
				{
					yield return new WaitForSeconds(0.25f);
					continue;
				}
				modifiedCharScale.Clear();
				scaleSortingOrder.Clear();
				for (int i = 0; i < characterCount; i++)
				{
					if (textInfo.characterInfo[i].isVisible)
					{
						int materialReferenceIndex = textInfo.characterInfo[i].materialReferenceIndex;
						int vertexIndex = textInfo.characterInfo[i].vertexIndex;
						Vector3[] vertices = cachedMeshInfoVertexData[materialReferenceIndex].vertices;
						Vector3 vector = (Vector2)((vertices[vertexIndex] + vertices[vertexIndex + 2]) / 2f);
						Vector3[] vertices2 = textInfo.meshInfo[materialReferenceIndex].vertices;
						vertices2[vertexIndex] = vertices[vertexIndex] - vector;
						vertices2[vertexIndex + 1] = vertices[vertexIndex + 1] - vector;
						vertices2[vertexIndex + 2] = vertices[vertexIndex + 2] - vector;
						vertices2[vertexIndex + 3] = vertices[vertexIndex + 3] - vector;
						float num = UnityEngine.Random.Range(1f, 1.5f);
						modifiedCharScale.Add(num);
						scaleSortingOrder.Add(modifiedCharScale.Count - 1);
						Matrix4x4 matrix4x = Matrix4x4.TRS(new Vector3(0f, 0f, 0f), Quaternion.identity, Vector3.one * num);
						vertices2[vertexIndex] = matrix4x.MultiplyPoint3x4(vertices2[vertexIndex]);
						vertices2[vertexIndex + 1] = matrix4x.MultiplyPoint3x4(vertices2[vertexIndex + 1]);
						vertices2[vertexIndex + 2] = matrix4x.MultiplyPoint3x4(vertices2[vertexIndex + 2]);
						vertices2[vertexIndex + 3] = matrix4x.MultiplyPoint3x4(vertices2[vertexIndex + 3]);
						vertices2[vertexIndex] += vector;
						vertices2[vertexIndex + 1] += vector;
						vertices2[vertexIndex + 2] += vector;
						vertices2[vertexIndex + 3] += vector;
						Vector2[] uvs = cachedMeshInfoVertexData[materialReferenceIndex].uvs0;
						Vector2[] uvs2 = textInfo.meshInfo[materialReferenceIndex].uvs0;
						uvs2[vertexIndex] = uvs[vertexIndex];
						uvs2[vertexIndex + 1] = uvs[vertexIndex + 1];
						uvs2[vertexIndex + 2] = uvs[vertexIndex + 2];
						uvs2[vertexIndex + 3] = uvs[vertexIndex + 3];
						Color32[] colors = cachedMeshInfoVertexData[materialReferenceIndex].colors32;
						Color32[] colors2 = textInfo.meshInfo[materialReferenceIndex].colors32;
						colors2[vertexIndex] = colors[vertexIndex];
						colors2[vertexIndex + 1] = colors[vertexIndex + 1];
						colors2[vertexIndex + 2] = colors[vertexIndex + 2];
						colors2[vertexIndex + 3] = colors[vertexIndex + 3];
					}
				}
				for (int j = 0; j < textInfo.meshInfo.Length; j++)
				{
					scaleSortingOrder.Sort((int a, int b) => modifiedCharScale[a].CompareTo(modifiedCharScale[b]));
					textInfo.meshInfo[j].SortGeometry(scaleSortingOrder);
					textInfo.meshInfo[j].mesh.vertices = textInfo.meshInfo[j].vertices;
					textInfo.meshInfo[j].mesh.uv = textInfo.meshInfo[j].uvs0;
					textInfo.meshInfo[j].mesh.colors32 = textInfo.meshInfo[j].colors32;
					m_TextComponent.UpdateGeometry(textInfo.meshInfo[j].mesh, j);
				}
				yield return new WaitForSeconds(0.1f);
			}
		}
	}
	public class WarpTextExample : MonoBehaviour
	{
		private TMP_Text m_TextComponent;

		public AnimationCurve VertexCurve = new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(0.25f, 2f), new Keyframe(0.5f, 0f), new Keyframe(0.75f, 2f), new Keyframe(1f, 0f));

		public float AngleMultiplier = 1f;

		public float SpeedMultiplier = 1f;

		public float CurveScale = 1f;

		private void Awake()
		{
			m_TextComponent = base.gameObject.GetComponent<TMP_Text>();
		}

		private void Start()
		{
			StartCoroutine(WarpText());
		}

		private AnimationCurve CopyAnimationCurve(AnimationCurve curve)
		{
			return new AnimationCurve
			{
				keys = curve.keys
			};
		}

		private IEnumerator WarpText()
		{
			VertexCurve.preWrapMode = WrapMode.Once;
			VertexCurve.postWrapMode = WrapMode.Once;
			m_TextComponent.havePropertiesChanged = true;
			CurveScale *= 10f;
			float old_CurveScale = CurveScale;
			AnimationCurve old_curve = CopyAnimationCurve(VertexCurve);
			while (true)
			{
				if (!m_TextComponent.havePropertiesChanged && old_CurveScale == CurveScale && old_curve.keys[1].value == VertexCurve.keys[1].value)
				{
					yield return null;
					continue;
				}
				old_CurveScale = CurveScale;
				old_curve = CopyAnimationCurve(VertexCurve);
				m_TextComponent.ForceMeshUpdate();
				TMP_TextInfo textInfo = m_TextComponent.textInfo;
				int characterCount = textInfo.characterCount;
				if (characterCount == 0)
				{
					continue;
				}
				float x = m_TextComponent.bounds.min.x;
				float x2 = m_TextComponent.bounds.max.x;
				for (int i = 0; i < characterCount; i++)
				{
					if (textInfo.characterInfo[i].isVisible)
					{
						int vertexIndex = textInfo.characterInfo[i].vertexIndex;
						int materialReferenceIndex = textInfo.characterInfo[i].materialReferenceIndex;
						Vector3[] vertices = textInfo.meshInfo[materialReferenceIndex].vertices;
						Vector3 vector = new Vector2((vertices[vertexIndex].x + vertices[vertexIndex + 2].x) / 2f, textInfo.characterInfo[i].baseLine);
						vertices[vertexIndex] += -vector;
						vertices[vertexIndex + 1] += -vector;
						vertices[vertexIndex + 2] += -vector;
						vertices[vertexIndex + 3] += -vector;
						float num = (vector.x - x) / (x2 - x);
						float num2 = num + 0.0001f;
						float y = VertexCurve.Evaluate(num) * CurveScale;
						float y2 = VertexCurve.Evaluate(num2) * CurveScale;
						Vector3 lhs = new Vector3(1f, 0f, 0f);
						Vector3 rhs = new Vector3(num2 * (x2 - x) + x, y2) - new Vector3(vector.x, y);
						float num3 = Mathf.Acos(Vector3.Dot(lhs, rhs.normalized)) * 57.29578f;
						float z = ((Vector3.Cross(lhs, rhs).z > 0f) ? num3 : (360f - num3));
						Matrix4x4 matrix4x = Matrix4x4.TRS(new Vector3(0f, y, 0f), Quaternion.Euler(0f, 0f, z), Vector3.one);
						vertices[vertexIndex] = matrix4x.MultiplyPoint3x4(vertices[vertexIndex]);
						vertices[vertexIndex + 1] = matrix4x.MultiplyPoint3x4(vertices[vertexIndex + 1]);
						vertices[vertexIndex + 2] = matrix4x.MultiplyPoint3x4(vertices[vertexIndex + 2]);
						vertices[vertexIndex + 3] = matrix4x.MultiplyPoint3x4(vertices[vertexIndex + 3]);
						vertices[vertexIndex] += vector;
						vertices[vertexIndex + 1] += vector;
						vertices[vertexIndex + 2] += vector;
						vertices[vertexIndex + 3] += vector;
					}
				}
				m_TextComponent.UpdateVertexData();
				yield return new WaitForSeconds(0.025f);
			}
		}
	}
}
namespace DigitalRuby.ThunderAndLightning
{
	public class DemoConfigureScript : MonoBehaviour
	{
		private const string scriptTemplate = "// Important, make sure this script is assigned properly, or you will get null ref exceptions.\r\n    DigitalRuby.ThunderAndLightning.LightningBoltScript script = gameObject.GetComponent<DigitalRuby.ThunderAndLightning.LightningBoltScript>();\r\n    int count = {0};\r\n    float duration = {1}f;\r\n    float delay = 0.0f;\r\n    int seed = {2};\r\n    System.Random r = new System.Random(seed);\r\n    Vector3 start = new Vector3({3}f, {4}f, {5}f);\r\n    Vector3 end = new Vector3({6}f, {7}f, {8}f);\r\n    int generations = {9};\r\n    float chaosFactor = {10}f;\r\n    float trunkWidth = {11}f;\r\n    float intensity = {12}f;\r\n    float glowIntensity = {13}f;\r\n    float glowWidthMultiplier = {14}f;\r\n    float forkedness = {15}f;\r\n    float singleDuration = Mathf.Max(1.0f / 30.0f, (duration / (float)count));\r\n    float fadePercent = {16}f;\r\n    float growthMultiplier = {17}f;\r\n    System.Collections.Generic.List<LightningBoltParameters> paramList = new System.Collections.Generic.List<LightningBoltParameters>();\r\n    while (count-- > 0)\r\n    {{\r\n        DigitalRuby.ThunderAndLightning.LightningBoltParameters parameters = new DigitalRuby.ThunderAndLightning.LightningBoltParameters\r\n        {{\r\n            Start = start,\r\n            End = end,\r\n            Generations = generations,\r\n            LifeTime = (count == 1 ? singleDuration : (singleDuration * (((float)r.NextDouble() * 0.4f) + 0.8f))),\r\n            Delay = delay,\r\n            ChaosFactor = chaosFactor,\r\n            ChaosFactorForks = chaosFactor,\r\n            TrunkWidth = trunkWidth,\r\n            GlowIntensity = glowIntensity,\r\n            GlowWidthMultiplier = glowWidthMultiplier,\r\n            Forkedness = forkedness,\r\n            Random = r,\r\n            FadePercent = fadePercent, // set to 0 to disable fade in / out\r\n            GrowthMultiplier = growthMultiplier\r\n        }};\r\n        paramList.Add(parameters);\r\n        delay += (singleDuration * (((float)r.NextDouble() * 0.8f) + 0.4f));\r\n    }}\r\n    script.CreateLightningBolts(paramList);\r\n";

		private int lastSeed;

		private Vector3 lastStart;

		private Vector3 lastEnd;

		public LightningBoltScript LightningBoltScript;

		public Slider GenerationsSlider;

		public Slider BoltCountSlider;

		public Slider DurationSlider;

		public Slider ChaosSlider;

		public Slider TrunkWidthSlider;

		public Slider ForkednessSlider;

		public Slider IntensitySlider;

		public Text IntensityValueLabel;

		public Slider GlowIntensitySlider;

		public Slider GlowWidthSlider;

		public Slider FadePercentSlider;

		public Slider GrowthMultiplierSlider;

		public Slider DistanceSlider;

		public Text GenerationsValueLabel;

		public Text BoltCountValueLabel;

		public Text DurationValueLabel;

		public Text ChaosValueLabel;

		public Text TrunkWidthValueLabel;

		public Text ForkednessValueLabel;

		public Text GlowIntensityValueLabel;

		public Text GlowWidthValueLabel;

		public Text FadePercentValueLabel;

		public Text GrowthMultiplierValueLabel;

		public Text DistanceValueLabel;

		public Text SeedLabel;

		public RawImage StartImage;

		public RawImage EndImage;

		public Button CopySeedButton;

		public InputField SeedInputField;

		public Text SpaceBarLabel;

		public Toggle OrthographicToggle;

		public void GenerationsSliderChanged(float value)
		{
			UpdateUI();
		}

		public void BoltCountSliderChanged(float value)
		{
			UpdateUI();
		}

		public void DurationSliderChanged(float value)
		{
			UpdateUI();
		}

		public void LengthSliderValueChanged(float value)
		{
			UpdateUI();
		}

		public void TrunkSliderValueChanged(float value)
		{
			UpdateUI();
		}

		public void IntensitySliderValueChanged(float value)
		{
			UpdateUI();
		}

		public void GlowSliderValueChanged(float value)
		{
			UpdateUI();
		}

		public void FadePercentValueChanged(float value)
		{
			UpdateUI();
		}

		public void GrowthMultiplierValueChanged(float value)
		{
			UpdateUI();
		}

		public void DistanceValueChanged(float value)
		{
			UpdateUI();
		}

		public void StartLightningDrag()
		{
			StartImage.transform.position = Input.mousePosition;
		}

		public void EndLightningDrag()
		{
			EndImage.transform.position = Input.mousePosition;
		}

		public void CreateButtonClicked()
		{
			CallLightning();
		}

		public void OrthographicToggleClicked()
		{
			if (OrthographicToggle.isOn)
			{
				Camera.main.orthographic = true;
				Camera.main.orthographicSize = (float)Camera.main.pixelHeight * 0.5f;
				Camera.main.nearClipPlane = 0f;
			}
			else
			{
				Camera.main.orthographic = false;
				Camera.main.nearClipPlane = 0.01f;
			}
		}

		public void CopyButtonClicked()
		{
			SeedInputField.text = lastSeed.ToString();
			TextEditor textEditor = new TextEditor();
			string text = $"// Important, make sure this script is assigned properly, or you will get null ref exceptions.\r\n    DigitalRuby.ThunderAndLightning.LightningBoltScript script = gameObject.GetComponent<DigitalRuby.ThunderAndLightning.LightningBoltScript>();\r\n    int count = {BoltCountSlider.value};\r\n    float duration = {DurationSlider.value}f;\r\n    float delay = 0.0f;\r\n    int seed = {SeedInputField.text};\r\n    System.Random r = new System.Random(seed);\r\n    Vector3 start = new Vector3({lastStart.x}f, {lastStart.y}f, {lastStart.z}f);\r\n    Vector3 end = new Vector3({lastEnd.x}f, {lastEnd.y}f, {lastEnd.z}f);\r\n    int generations = {GenerationsSlider.value};\r\n    float chaosFactor = {ChaosSlider.value}f;\r\n    float trunkWidth = {TrunkWidthSlider.value}f;\r\n    float intensity = {IntensitySlider.value}f;\r\n    float glowIntensity = {GlowIntensitySlider.value}f;\r\n    float glowWidthMultiplier = {GlowWidthSlider.value}f;\r\n    float forkedness = {ForkednessSlider.value}f;\r\n    float singleDuration = Mathf.Max(1.0f / 30.0f, (duration / (float)count));\r\n    float fadePercent = {FadePercentSlider.value}f;\r\n    float growthMultiplier = {GrowthMultiplierSlider.value}f;\r\n    System.Collections.Generic.List<LightningBoltParameters> paramList = new System.Collections.Generic.List<LightningBoltParameters>();\r\n    while (count-- > 0)\r\n    {{\r\n        DigitalRuby.ThunderAndLightning.LightningBoltParameters parameters = new DigitalRuby.ThunderAndLightning.LightningBoltParameters\r\n        {{\r\n            Start = start,\r\n            End = end,\r\n            Generations = generations,\r\n            LifeTime = (count == 1 ? singleDuration : (singleDuration * (((float)r.NextDouble() * 0.4f) + 0.8f))),\r\n            Delay = delay,\r\n            ChaosFactor = chaosFactor,\r\n            ChaosFactorForks = chaosFactor,\r\n            TrunkWidth = trunkWidth,\r\n            GlowIntensity = glowIntensity,\r\n            GlowWidthMultiplier = glowWidthMultiplier,\r\n            Forkedness = forkedness,\r\n            Random = r,\r\n            FadePercent = fadePercent, // set to 0 to disable fade in / out\r\n            GrowthMultiplier = growthMultiplier\r\n        }};\r\n        paramList.Add(parameters);\r\n        delay += (singleDuration * (((float)r.NextDouble() * 0.8f) + 0.4f));\r\n    }}\r\n    script.CreateLightningBolts(paramList);\r\n";
			textEditor.text = text;
			textEditor.SelectAll();
			textEditor.Copy();
		}

		public void ClearButtonClicked()
		{
			SeedInputField.text = string.Empty;
		}

		private void UpdateUI()
		{
			GenerationsValueLabel.text = GenerationsSlider.value.ToString("0");
			BoltCountValueLabel.text = BoltCountSlider.value.ToString("0");
			DurationValueLabel.text = DurationSlider.value.ToString("0.00");
			ChaosValueLabel.text = ChaosSlider.value.ToString("0.00");
			TrunkWidthValueLabel.text = TrunkWidthSlider.value.ToString("0.00");
			ForkednessValueLabel.text = ForkednessSlider.value.ToString("0.00");
			IntensityValueLabel.text = IntensitySlider.value.ToString("0.00");
			GlowIntensityValueLabel.text = GlowIntensitySlider.value.ToString("0.00");
			GlowWidthValueLabel.text = GlowWidthSlider.value.ToString("0.00");
			FadePercentValueLabel.text = FadePercentSlider.value.ToString("0.00");
			GrowthMultiplierValueLabel.text = GrowthMultiplierSlider.value.ToString("0.00");
			DistanceValueLabel.text = DistanceSlider.value.ToString("0.00");
		}

		private void CallLightning()
		{
			if (SpaceBarLabel != null)
			{
				SpaceBarLabel.CrossFadeColor(new Color(0f, 0f, 0f, 0f), 1f, ignoreTimeScale: true, useAlpha: true);
				SpaceBarLabel = null;
			}
			lastStart = StartImage.transform.position + Camera.main.transform.forward * DistanceSlider.value;
			lastEnd = EndImage.transform.position + Camera.main.transform.forward * DistanceSlider.value;
			lastStart = Camera.main.ScreenToWorldPoint(lastStart);
			lastEnd = Camera.main.ScreenToWorldPoint(lastEnd);
			int num = (int)BoltCountSlider.value;
			float value = DurationSlider.value;
			float num2 = 0f;
			float value2 = ChaosSlider.value;
			float value3 = TrunkWidthSlider.value;
			float value4 = ForkednessSlider.value;
			if (!int.TryParse(SeedInputField.text, out lastSeed))
			{
				lastSeed = UnityEngine.Random.Range(int.MinValue, int.MaxValue);
			}
			System.Random random = new System.Random(lastSeed);
			float num3 = Mathf.Max(1f / 30f, value / (float)num);
			float value5 = FadePercentSlider.value;
			float value6 = GrowthMultiplierSlider.value;
			List<LightningBoltParameters> list = new List<LightningBoltParameters>();
			Stopwatch stopwatch = Stopwatch.StartNew();
			while (num-- > 0)
			{
				LightningBoltParameters item = new LightningBoltParameters
				{
					Start = lastStart,
					End = lastEnd,
					Generations = (int)GenerationsSlider.value,
					LifeTime = ((num == 1) ? num3 : (num3 * ((float)random.NextDouble() * 0.4f + 0.8f))),
					Delay = num2,
					ChaosFactor = value2,
					ChaosFactorForks = value2,
					TrunkWidth = value3,
					Intensity = IntensitySlider.value,
					GlowIntensity = GlowIntensitySlider.value,
					GlowWidthMultiplier = GlowWidthSlider.value,
					Forkedness = value4,
					RandomOverride = random,
					FadePercent = value5,
					GrowthMultiplier = value6
				};
				list.Add(item);
				num2 += num3 * ((float)random.NextDouble() * 0.8f + 0.4f);
			}
			LightningBoltScript.CreateLightningBolts(list);
			stopwatch.Stop();
			UpdateStatusLabel(stopwatch.Elapsed);
		}

		private void UpdateStatusLabel(TimeSpan time)
		{
			SeedLabel.text = "Time to create: " + time.TotalMilliseconds + "ms" + Environment.NewLine + "Seed: " + lastSeed + Environment.NewLine + "Start: " + lastStart.ToString() + Environment.NewLine + "End: " + lastEnd.ToString() + Environment.NewLine + Environment.NewLine + "Use SPACE to create a bolt" + Environment.NewLine + "Drag circle and anchor" + Environment.NewLine + "Type in seed or clear for random" + Environment.NewLine + "Click copy to generate script";
		}

		private void Start()
		{
			UpdateUI();
			UpdateStatusLabel(TimeSpan.Zero);
		}

		private void Update()
		{
			if (!SeedInputField.isFocused && Input.GetKeyDown(KeyCode.Space))
			{
				CallLightning();
			}
		}
	}
	public class DemoMeshScript : MonoBehaviour
	{
	}
	public class DemoPathScript : MonoBehaviour
	{
		public GameObject Crate;

		private void Start()
		{
			Crate.GetComponent<Rigidbody>().angularVelocity = new Vector3(0.2f, 0.3f, 0.4f);
		}
	}
	public class DemoPlayerControllerScript : MonoBehaviour
	{
		public Text SpellLabel;

		public float Speed = 3f;

		public float RotateSpeed = 3f;

		public LightningSpellScript[] Spells;

		private int spellIndex;

		private bool spellMouseButtonDown;

		private GameObject rightHand;

		private void OnCollisionEnter(Collision collision)
		{
			ContactPoint[] contacts = collision.contacts;
			foreach (ContactPoint contactPoint in contacts)
			{
				Rigidbody component = contactPoint.otherCollider.gameObject.GetComponent<Rigidbody>();
				if (component != null)
				{
					component.velocity += base.gameObject.transform.forward * 5f;
				}
			}
		}

		private void Start()
		{
			rightHand = base.gameObject.transform.Find("RightArm").Find("RightHand").gameObject;
			UpdateSpell();
		}

		private void Update()
		{
			if (Input.GetKeyDown(KeyCode.Escape))
			{
				DemoScript.ReloadCurrentScene();
				return;
			}
			CharacterController component = GetComponent<CharacterController>();
			base.transform.Rotate(0f, Input.GetAxis("Horizontal") * RotateSpeed, 0f);
			Vector3 vector = base.transform.TransformDirection(Vector3.forward);
			float num = Speed * Input.GetAxis("Vertical");
			component.SimpleMove(vector * num);
			if (Input.GetKeyDown(KeyCode.Plus) || Input.GetKeyDown(KeyCode.KeypadPlus))
			{
				NextSpell();
			}
			else if (Input.GetKeyDown(KeyCode.Minus) || Input.GetKeyDown(KeyCode.KeypadMinus))
			{
				PreviousSpell();
			}
			LightningSpellScript lightningSpellScript = Spells[spellIndex];
			if (Input.GetButton("Fire1") && (spellMouseButtonDown || !Input.GetMouseButton(0) || GuiElementShouldPassThrough()))
			{
				if (lightningSpellScript.SpellStart != null && lightningSpellScript.SpellStart.GetComponent<Rigidbody>() == null)
				{
					lightningSpellScript.SpellStart.transform.position = rightHand.transform.position;
				}
				if (Input.GetMouseButton(0))
				{
					spellMouseButtonDown = true;
					Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);
					RaycastHit hitInfo;
					Vector3 vector2 = ((!Physics.Raycast(ray, out hitInfo, lightningSpellScript.MaxDistance, lightningSpellScript.CollisionMask)) ? (ray.origin + ray.direction * lightningSpellScript.MaxDistance) : hitInfo.point);
					lightningSpellScript.Direction = (vector2 - lightningSpellScript.SpellStart.transform.position).normalized;
				}
				else
				{
					spellMouseButtonDown = false;
					lightningSpellScript.Direction = base.gameObject.transform.forward;
				}
				lightningSpellScript.CastSpell();
			}
			else
			{
				spellMouseButtonDown = false;
				lightningSpellScript.StopSpell();
			}
		}

		private bool GuiElementShouldPassThrough()
		{
			PointerEventData pointerEventData = new PointerEventData(EventSystem.current);
			pointerEventData.position = Input.mousePosition;
			List<RaycastResult> list = new List<RaycastResult>();
			EventSystem.current.RaycastAll(pointerEventData, list);
			foreach (RaycastResult item in list)
			{
				if (item.gameObject.GetComponent<Button>() != null || (item.gameObject.GetComponent<Text>() == null && item.gameObject.GetComponent<Image>() == null))
				{
					return false;
				}
			}
			return true;
		}

		private void UpdateSpell()
		{
			SpellLabel.text = Spells[spellIndex].name;
			Spells[spellIndex].ActivateSpell();
		}

		private void ChangeSpell(int dir)
		{
			Spells[spellIndex].StopSpell();
			Spells[spellIndex].DeactivateSpell();
			spellIndex += dir;
			if (spellIndex < 0)
			{
				spellIndex = Spells.Length - 1;
			}
			else if (spellIndex >= Spells.Length)
			{
				spellIndex = 0;
			}
			UpdateSpell();
		}

		public void PreviousSpell()
		{
			ChangeSpell(-1);
		}

		public void NextSpell()
		{
			ChangeSpell(1);
		}
	}
	public class DemoScript : MonoBehaviour
	{
		private enum RotationAxes
		{
			MouseXAndY,
			MouseX,
			MouseY
		}

		public ThunderAndLightningScript ThunderAndLightningScript;

		public LightningBoltScript LightningBoltScript;

		public ParticleSystem CloudParticleSystem;

		public float MoveSpeed = 250f;

		public bool EnableMouseLook = true;

		private const float fastCloudSpeed = 50f;

		private float deltaTime;

		private float fpsIncrement;

		private string fpsText;

		private RotationAxes axes;

		private float sensitivityX = 15f;

		private float sensitivityY = 15f;

		private float minimumX = -360f;

		private float maximumX = 360f;

		private float minimumY = -60f;

		private float maximumY = 60f;

		private float rotationX;

		private float rotationY;

		private Quaternion originalRotation;

		private static readonly GUIStyle style = new GUIStyle();

		private void UpdateThunder()
		{
			if (ThunderAndLightningScript != null)
			{
				if (Input.GetKeyDown(KeyCode.Alpha1))
				{
					ThunderAndLightningScript.CallNormalLightning();
				}
				else if (Input.GetKeyDown(KeyCode.Alpha2))
				{
					ThunderAndLightningScript.CallIntenseLightning();
				}
				else if (Input.GetKeyDown(KeyCode.Alpha3) && CloudParticleSystem != null)
				{
					ParticleSystem.MainModule main = CloudParticleSystem.main;
					main.simulationSpeed = ((main.simulationSpeed == 1f) ? 50f : 1f);
				}
			}
		}

		private void UpdateMovement()
		{
			float num = MoveSpeed * LightningBoltScript.DeltaTime;
			if (Input.GetKey(KeyCode.W))
			{
				Camera.main.transform.Translate(0f, 0f, num);
			}
			if (Input.GetKey(KeyCode.S))
			{
				Camera.main.transform.Translate(0f, 0f, 0f - num);
			}
			if (Input.GetKey(KeyCode.A))
			{
				Camera.main.transform.Translate(0f - num, 0f, 0f);
			}
			if (Input.GetKey(KeyCode.D))
			{
				Camera.main.transform.Translate(num, 0f, 0f);
			}
		}

		private void UpdateMouseLook()
		{
			if (EnableMouseLook)
			{
				if (axes == RotationAxes.MouseXAndY)
				{
					rotationX += Input.GetAxis("Mouse X") * sensitivityX;
					rotationY += Input.GetAxis("Mouse Y") * sensitivityY;
					rotationX = ClampAngle(rotationX, minimumX, maximumX);
					rotationY = ClampAngle(rotationY, minimumY, maximumY);
					Quaternion quaternion = Quaternion.AngleAxis(rotationX, Vector3.up);
					Quaternion quaternion2 = Quaternion.AngleAxis(rotationY, -Vector3.right);
					base.transform.localRotation = originalRotation * quaternion * quaternion2;
				}
				else if (axes == RotationAxes.MouseX)
				{
					rotationX += Input.GetAxis("Mouse X") * sensitivityX;
					rotationX = ClampAngle(rotationX, minimumX, maximumX);
					Quaternion quaternion3 = Quaternion.AngleAxis(rotationX, Vector3.up);
					base.transform.localRotation = originalRotation * quaternion3;
				}
				else
				{
					rotationY += Input.GetAxis("Mouse Y") * sensitivityY;
					rotationY = ClampAngle(rotationY, minimumY, maximumY);
					Quaternion quaternion4 = Quaternion.AngleAxis(0f - rotationY, Vector3.right);
					base.transform.localRotation = originalRotation * quaternion4;
				}
			}
		}

		private void UpdateQuality()
		{
			if (Input.GetKeyDown(KeyCode.F1))
			{
				QualitySettings.SetQualityLevel(0);
			}
			else if (Input.GetKeyDown(KeyCode.F2))
			{
				QualitySettings.SetQualityLevel(1);
			}
			else if (Input.GetKeyDown(KeyCode.F3))
			{
				QualitySettings.SetQualityLevel(2);
			}
			else if (Input.GetKeyDown(KeyCode.F4))
			{
				QualitySettings.SetQualityLevel(3);
			}
			else if (Input.GetKeyDown(KeyCode.F5))
			{
				QualitySettings.SetQualityLevel(4);
			}
			else if (Input.GetKeyDown(KeyCode.F6))
			{
				QualitySettings.SetQualityLevel(5);
			}
		}

		private void UpdateOther()
		{
			deltaTime += (LightningBoltScript.DeltaTime - deltaTime) * 0.1f;
			if (Input.GetKeyDown(KeyCode.Escape))
			{
				ReloadCurrentScene();
			}
		}

		private void OnGUI()
		{
			int width = Screen.width;
			int height = Screen.height;
			int num = (int)((float)Screen.height * 0.08f);
			Rect position = new Rect((int)((double)width * 0.01), height - num, width, (int)((double)num * 0.9));
			style.alignment = TextAnchor.LowerLeft;
			style.fontSize = num / 2;
			style.normal.textColor = Color.white;
			if ((fpsIncrement += LightningBoltScript.DeltaTime) > 1f)
			{
				fpsIncrement -= 1f;
				float num2 = deltaTime * 1000f;
				fpsText = string.Format(arg1: 1f / deltaTime, format: "{0:0.0} ms ({1:0.} fps)", arg0: num2);
			}
			GUI.Label(position, fpsText, style);
		}

		private void Update()
		{
			UpdateThunder();
			UpdateMovement();
			UpdateMouseLook();
			UpdateQuality();
			UpdateOther();
		}

		private void Start()
		{
			originalRotation = base.transform.localRotation;
			if (CloudParticleSystem != null)
			{
				ParticleSystem.MainModule main = CloudParticleSystem.main;
				main.simulationSpeed = 50f;
			}
		}

		public static float ClampAngle(float angle, float min, float max)
		{
			if (angle < -360f)
			{
				angle += 360f;
			}
			if (angle > 360f)
			{
				angle -= 360f;
			}
			return Mathf.Clamp(angle, min, max);
		}

		public static void ReloadCurrentScene()
		{
			SceneManager.LoadScene(0, LoadSceneMode.Single);
		}
	}
	public class DemoScript2D : MonoBehaviour
	{
		public GameObject SpriteToRotate;

		public LightningBoltPrefabScriptBase LightningScript;

		private void Start()
		{
		}

		private void Update()
		{
			SpriteToRotate.transform.Rotate(0f, 0f, LightningBoltScript.DeltaTime * 10f);
		}
	}
	public class DemoScriptManualAutomatic : MonoBehaviour
	{
		public GameObject LightningPrefab;

		public Toggle AutomaticToggle;

		public Transform a;

		public Transform b;

		private void Update()
		{
			if (Input.GetMouseButton(0))
			{
				Vector3 vector = Camera.main.ScreenToWorldPoint(Input.mousePosition);
				vector.z = 0f;
				LightningPrefab.GetComponent<LightningBoltPrefabScriptBase>().Trigger(a.position, b.position);
			}
		}

		public void AutomaticToggled()
		{
			LightningPrefab.GetComponent<LightningBoltPrefabScriptBase>().ManualMode = !AutomaticToggle.isOn;
		}

		public void ManualTriggerClicked()
		{
			LightningPrefab.GetComponent<LightningBoltPrefabScriptBase>().Trigger();
		}
	}
	public class DemoScriptMoveRandomly : MonoBehaviour
	{
		private float elapsed = float.MaxValue;

		private Vector3 startStartPos;

		private Vector3 startEndPos;

		private Vector3 endStartPos;

		private Vector3 endEndPos;

		[Tooltip("The transform to move randomly.")]
		public Transform Transform1;

		[Tooltip("The transform to move randomly.")]
		public Transform Transform2;

		[Tooltip("How long until the start and end objects change positions again. Set to 0 to not move the objects.")]
		[Range(0f, 5f)]
		public float MoveTimeSeconds = 1f;

		private void Start()
		{
		}

		private void Update()
		{
			if (!(MoveTimeSeconds <= 0f))
			{
				if (elapsed >= MoveTimeSeconds)
				{
					elapsed = 0f;
					Vector3 vector = Camera.main.ViewportToWorldPoint(new Vector3(0f, 0f, 10f));
					Vector3 vector2 = Camera.main.ViewportToWorldPoint(new Vector3(1f, 1f, 10f));
					startStartPos = Transform1.transform.position;
					endStartPos = Transform2.transform.position;
					startEndPos = new Vector3(UnityEngine.Random.Range(vector.x, vector2.x), UnityEngine.Random.Range(vector.y, vector2.y), 0f);
					endEndPos = new Vector3(UnityEngine.Random.Range(vector.x, vector2.x), UnityEngine.Random.Range(vector.y, vector2.y), 0f);
				}
				elapsed += LightningBoltScript.DeltaTime;
				Transform1.position = Vector3.Lerp(startStartPos, startEndPos, elapsed / MoveTimeSeconds);
				Transform2.position = Vector3.Lerp(endStartPos, endEndPos, elapsed / MoveTimeSeconds);
			}
		}
	}
	public class DemoScriptPrefabTutorial : MonoBehaviour
	{
		public LightningBoltPrefabScript LightningScript;

		private void Start()
		{
		}

		private void Update()
		{
			if (Input.GetKey(KeyCode.Space))
			{
				LightningScript.Trigger();
			}
		}
	}
	public class DemoScriptReloadSceneEsc : MonoBehaviour
	{
		private void Start()
		{
		}

		private void Update()
		{
			if (Input.GetKeyDown(KeyCode.Escape))
			{
				SceneManager.LoadScene(0);
			}
		}
	}
	public class DemoScriptRotate : MonoBehaviour
	{
		public Vector3 Rotation;

		private void Update()
		{
			base.gameObject.transform.Rotate(Rotation * LightningBoltScript.DeltaTime);
		}
	}
	public class DemoScriptTriggerPath : MonoBehaviour
	{
		public LightningSplineScript Script;

		public Toggle SplineToggle;

		private readonly List<Vector3> points = new List<Vector3>();

		private void Start()
		{
			Script.ManualMode = true;
		}

		private void Update()
		{
			if (Input.GetKeyDown(KeyCode.Escape))
			{
				DemoScript.ReloadCurrentScene();
			}
			else if (Input.GetMouseButton(0) && !EventSystem.current.IsPointerOverGameObject())
			{
				Vector3 vector = Camera.main.ScreenToWorldPoint(Input.mousePosition);
				if (Camera.main.orthographic)
				{
					vector.z = 0f;
				}
				if (points.Count == 0 || (points[points.Count - 1] - vector).magnitude > 8f)
				{
					points.Add(vector);
					Script.Trigger(points, SplineToggle.isOn);
				}
			}
		}
	}
	public enum LightningBoltQualitySetting
	{
		UseScript,
		LimitToQualitySetting
	}
	public enum CameraMode
	{
		Auto,
		Perspective,
		OrthographicXY,
		OrthographicXZ,
		Unknown
	}
	public enum LightningCustomTransformState
	{
		Started,
		Executing,
		Ended
	}
	public class LightningCustomTransformStateInfo
	{
		public Vector3 BoltStartPosition;

		public Vector3 BoltEndPosition;

		public Transform Transform;

		public Transform StartTransform;

		public Transform EndTransform;

		public object UserInfo;

		private static readonly List<LightningCustomTransformStateInfo> cache = new List<LightningCustomTransformStateInfo>();

		public LightningCustomTransformState State { get; set; }

		public LightningBoltParameters Parameters { get; set; }

		public static LightningCustomTransformStateInfo GetOrCreateStateInfo()
		{
			if (cache.Count == 0)
			{
				return new LightningCustomTransformStateInfo();
			}
			int index = cache.Count - 1;
			LightningCustomTransformStateInfo result = cache[index];
			cache.RemoveAt(index);
			return result;
		}

		public static void ReturnStateInfoToCache(LightningCustomTransformStateInfo info)
		{
			if (info != null)
			{
				info.Transform = (info.StartTransform = (info.EndTransform = null));
				info.UserInfo = null;
				cache.Add(info);
			}
		}
	}
	[Serializable]
	public class LightningCustomTransformDelegate : UnityEvent<LightningCustomTransformStateInfo>
	{
	}
	[Serializable]
	public class LightningLightParameters
	{
		[Tooltip("Light render mode - leave as auto unless you have special use cases")]
		[HideInInspector]
		public LightRenderMode RenderMode;

		[Tooltip("Color of the light")]
		public Color LightColor = Color.white;

		[Tooltip("What percent of segments should have a light? For performance you may want to keep this small.")]
		[Range(0f, 1f)]
		public float LightPercent = 1E-06f;

		[Tooltip("What percent of lights created should cast shadows?")]
		[Range(0f, 1f)]
		public float LightShadowPercent;

		[Tooltip("Light intensity")]
		[Range(0f, 8f)]
		public float LightIntensity = 0.5f;

		[Tooltip("Bounce intensity")]
		[Range(0f, 8f)]
		public float BounceIntensity;

		[Tooltip("Shadow strength, 0 means all light, 1 means all shadow")]
		[Range(0f, 1f)]
		public float ShadowStrength = 1f;

		[Tooltip("Shadow bias, 0 - 2")]
		[Range(0f, 2f)]
		public float ShadowBias = 0.05f;

		[Tooltip("Shadow normal bias, 0 - 3")]
		[Range(0f, 3f)]
		public float ShadowNormalBias = 0.4f;

		[Tooltip("The range of each light created")]
		public float LightRange;

		[Tooltip("Only light objects that match this layer mask")]
		public LayerMask CullingMask = -1;

		[Tooltip("Offset from camera position when in orthographic mode")]
		[Range(-1000f, 1000f)]
		public float OrthographicOffset;

		[Tooltip("Increase the duration of light fade in compared to the lightning fade.")]
		[Range(0f, 20f)]
		public float FadeInMultiplier = 1f;

		[Tooltip("Increase the duration of light fully lit compared to the lightning fade.")]
		[Range(0f, 20f)]
		public float FadeFullyLitMultiplier = 1f;

		[Tooltip("Increase the duration of light fade out compared to the lightning fade.")]
		[Range(0f, 20f)]
		public float FadeOutMultiplier = 1f;

		public bool HasLight
		{
			get
			{
				if (LightColor.a > 0f && LightIntensity >= 0.01f && LightPercent >= 1E-07f)
				{
					return LightRange > 0.01f;
				}
				return false;
			}
		}
	}
	[Serializable]
	public sealed class LightningBoltParameters
	{
		private static int randomSeed;

		private static readonly List<LightningBoltParameters> cache;

		internal int generationWhereForksStop;

		internal int forkednessCalculated;

		internal LightningBoltQualitySetting quality;

		internal float delaySeconds;

		internal int maxLights;

		public static float Scale;

		public static readonly Dictionary<int, LightningQualityMaximum> QualityMaximums;

		public LightningGenerator Generator;

		public Vector3 Start;

		public Vector3 End;

		public Vector3 StartVariance;

		public Vector3 EndVariance;

		public Action<LightningCustomTransformStateInfo> CustomTransform;

		private int generations;

		public float LifeTime;

		public float Delay;

		public RangeOfFloats DelayRange;

		public float ChaosFactor;

		public float ChaosFactorForks = -1f;

		public float TrunkWidth;

		public float EndWidthMultiplier = 0.5f;

		public float Intensity = 1f;

		public float GlowIntensity;

		public float GlowWidthMultiplier;

		public float Forkedness;

		public int GenerationWhereForksStopSubtractor = 5;

		public Color32 Color = new Color32(byte.MaxValue, byte.MaxValue, byte.MaxValue, byte.MaxValue);

		private System.Random random;

		private System.Random currentRandom;

		private System.Random randomOverride;

		public float FadePercent = 0.15f;

		public float FadeInMultiplier = 1f;

		public float FadeFullyLitMultiplier = 1f;

		public float FadeOutMultiplier = 1f;

		private float growthMultiplier;

		public float ForkLengthMultiplier = 0.6f;

		public float ForkLengthVariance = 0.2f;

		public float ForkEndWidthMultiplier = 1f;

		public LightningLightParameters LightParameters;

		public int SmoothingFactor;

		public int Generations
		{
			get
			{
				return generations;
			}
			set
			{
				int b = Mathf.Clamp(value, 1, 8);
				if (quality == LightningBoltQualitySetting.UseScript)
				{
					generations = b;
					return;
				}
				int qualityLevel = QualitySettings.GetQualityLevel();
				if (QualityMaximums.TryGetValue(qualityLevel, out var value2))
				{
					generations = Mathf.Min(value2.MaximumGenerations, b);
					return;
				}
				generations = b;
				UnityEngine.Debug.LogError("Unable to read lightning quality settings from level " + qualityLevel);
			}
		}

		public System.Random Random
		{
			get
			{
				return currentRandom;
			}
			set
			{
				random = value ?? random;
				currentRandom = randomOverride ?? random;
			}
		}

		public System.Random RandomOverride
		{
			get
			{
				return randomOverride;
			}
			set
			{
				randomOverride = value;
				currentRandom = randomOverride ?? random;
			}
		}

		public float GrowthMultiplier
		{
			get
			{
				return growthMultiplier;
			}
			set
			{
				growthMultiplier = Mathf.Clamp(value, 0f, 0.999f);
			}
		}

		public List<Vector3> Points { get; set; }

		static LightningBoltParameters()
		{
			randomSeed = Environment.TickCount;
			cache = new List<LightningBoltParameters>();
			Scale = 1f;
			QualityMaximums = new Dictionary<int, LightningQualityMaximum>();
			string[] names = QualitySettings.names;
			for (int i = 0; i < names.Length; i++)
			{
				switch (i)
				{
				case 0:
					QualityMaximums[i] = new LightningQualityMaximum
					{
						MaximumGenerations = 3,
						MaximumLightPercent = 0f,
						MaximumShadowPercent = 0f
					};
					break;
				case 1:
					QualityMaximums[i] = new LightningQualityMaximum
					{
						MaximumGenerations = 4,
						MaximumLightPercent = 0f,
						MaximumShadowPercent = 0f
					};
					break;
				case 2:
					QualityMaximums[i] = new LightningQualityMaximum
					{
						MaximumGenerations = 5,
						MaximumLightPercent = 0.1f,
						MaximumShadowPercent = 0f
					};
					break;
				case 3:
					QualityMaximums[i] = new LightningQualityMaximum
					{
						MaximumGenerations = 5,
						MaximumLightPercent = 0.1f,
						MaximumShadowPercent = 0f
					};
					break;
				case 4:
					QualityMaximums[i] = new LightningQualityMaximum
					{
						MaximumGenerations = 6,
						MaximumLightPercent = 0.05f,
						MaximumShadowPercent = 0.1f
					};
					break;
				case 5:
					QualityMaximums[i] = new LightningQualityMaximum
					{
						MaximumGenerations = 7,
						MaximumLightPercent = 0.025f,
						MaximumShadowPercent = 0.05f
					};
					break;
				default:
					QualityMaximums[i] = new LightningQualityMaximum
					{
						MaximumGenerations = 8,
						MaximumLightPercent = 0.025f,
						MaximumShadowPercent = 0.05f
					};
					break;
				}
			}
		}

		public LightningBoltParameters()
		{
			random = (currentRandom = new System.Random(randomSeed++));
			Points = new List<Vector3>();
		}

		public float ForkMultiplier()
		{
			return (float)Random.NextDouble() * ForkLengthVariance + ForkLengthMultiplier;
		}

		public Vector3 ApplyVariance(Vector3 pos, Vector3 variance)
		{
			return new Vector3(pos.x + ((float)Random.NextDouble() * 2f - 1f) * variance.x, pos.y + ((float)Random.NextDouble() * 2f - 1f) * variance.y, pos.z + ((float)Random.NextDouble() * 2f - 1f) * variance.z);
		}

		public void Reset()
		{
			Start = (End = Vector3.zero);
			Generator = null;
			SmoothingFactor = 0;
			RandomOverride = null;
			CustomTransform = null;
			if (Points != null)
			{
				Points.Clear();
			}
		}

		public static LightningBoltParameters GetOrCreateParameters()
		{
			LightningBoltParameters result;
			if (cache.Count == 0)
			{
				result = new LightningBoltParameters();
			}
			else
			{
				int index = cache.Count - 1;
				result = cache[index];
				cache.RemoveAt(index);
			}
			return result;
		}

		public static void ReturnParametersToCache(LightningBoltParameters p)
		{
			if (!cache.Contains(p))
			{
				p.Reset();
				cache.Add(p);
			}
		}
	}
	public class LightningBoltSegmentGroup
	{
		public float LineWidth;

		public int StartIndex;

		public int Generation;

		public float Delay;

		public float PeakStart;

		public float PeakEnd;

		public float LifeTime;

		public float EndWidthMultiplier;

		public Color32 Color;

		public readonly List<LightningBoltSegment> Segments = new List<LightningBoltSegment>();

		public readonly List<Light> Lights = new List<Light>();

		public LightningLightParameters LightParameters;

		public int SegmentCount => Segments.Count - StartIndex;

		public void Reset()
		{
			LightParameters = null;
			Segments.Clear();
			Lights.Clear();
			StartIndex = 0;
		}
	}
	public struct LightningBoltSegment
	{
		public Vector3 Start;

		public Vector3 End;

		public override string ToString()
		{
			return Start.ToString() + ", " + End.ToString();
		}
	}
	public class LightningQualityMaximum
	{
		public int MaximumGenerations { get; set; }

		public float MaximumLightPercent { get; set; }

		public float MaximumShadowPercent { get; set; }
	}
	public class LightningBoltDependencies
	{
		public GameObject Parent;

		public Material LightningMaterialMesh;

		public Material LightningMaterialMeshNoGlow;

		public ParticleSystem OriginParticleSystem;

		public ParticleSystem DestParticleSystem;

		public Vector3 CameraPos;

		public bool CameraIsOrthographic;

		public CameraMode CameraMode;

		public bool UseWorldSpace;

		public float LevelOfDetailDistance;

		public string SortLayerName;

		public int SortOrderInLayer;

		public ICollection<LightningBoltParameters> Parameters;

		public LightningThreadState ThreadState;

		public Func<IEnumerator, Coroutine> StartCoroutine;

		public Action<Light> LightAdded;

		public Action<Light> LightRemoved;

		public Action<LightningBolt> AddActiveBolt;

		public Action<LightningBoltDependencies> ReturnToCache;

		public Action<LightningBoltParameters, Vector3, Vector3> LightningBoltStarted;

		public Action<LightningBoltParameters, Vector3, Vector3> LightningBoltEnded;
	}
	public class LightningBolt
	{
		public class LineRendererMesh
		{
			private const int defaultListCapacity = 2048;

			private static readonly Vector2 uv1 = new Vector2(0f, 0f);

			private static readonly Vector2 uv2 = new Vector2(1f, 0f);

			private static readonly Vector2 uv3 = new Vector2(0f, 1f);

			private static readonly Vector2 uv4 = new Vector2(1f, 1f);

			private readonly List<int> indices = new List<int>(2048);

			private readonly List<Vector3> vertices = new List<Vector3>(2048);

			private readonly List<Vector4> lineDirs = new List<Vector4>(2048);

			private readonly List<Color32> colors = new List<Color32>(2048);

			private readonly List<Vector3> ends = new List<Vector3>(2048);

			private readonly List<Vector4> texCoordsAndGlowModifiers = new List<Vector4>(2048);

			private readonly List<Vector4> fadeLifetimes = new List<Vector4>(2048);

			private const int boundsPadder = 1000000000;

			private int currentBoundsMinX = 1147483647;

			private int currentBoundsMinY = 1147483647;

			private int currentBoundsMinZ = 1147483647;

			private int currentBoundsMaxX = -1147483648;

			private int currentBoundsMaxY = -1147483648;

			private int currentBoundsMaxZ = -1147483648;

			private Mesh mesh;

			private MeshFilter meshFilterGlow;

			private MeshFilter meshFilterBolt;

			private MeshRenderer meshRendererGlow;

			private MeshRenderer meshRendererBolt;

			public GameObject GameObject { get; private set; }

			public Material MaterialGlow
			{
				get
				{
					return meshRendererGlow.sharedMaterial;
				}
				set
				{
					meshRendererGlow.sharedMaterial = value;
				}
			}

			public Material MaterialBolt
			{
				get
				{
					return meshRendererBolt.sharedMaterial;
				}
				set
				{
					meshRendererBolt.sharedMaterial = value;
				}
			}

			public MeshRenderer MeshRendererGlow => meshRendererGlow;

			public MeshRenderer MeshRendererBolt => meshRendererBolt;

			public int Tag { get; set; }

			public Action<LightningCustomTransformStateInfo> CustomTransform { get; set; }

			public Transform Transform { get; private set; }

			public bool Empty => vertices.Count == 0;

			public LineRendererMesh()
			{
				GameObject = new GameObject("LightningBoltMeshRenderer");
				GameObject.SetActive(value: false);
				this.mesh = new Mesh
				{
					name = "ProceduralLightningMesh"
				};
				this.mesh.MarkDynamic();
				GameObject gameObject = new GameObject("LightningBoltMeshRendererGlow");
				gameObject.transform.parent = GameObject.transform;
				GameObject gameObject2 = new GameObject("LightningBoltMeshRendererBolt");
				gameObject2.transform.parent = GameObject.transform;
				meshFilterGlow = gameObject.AddComponent<MeshFilter>();
				meshFilterBolt = gameObject2.AddComponent<MeshFilter>();
				meshFilterGlow.sharedMesh = (meshFilterBolt.sharedMesh = this.mesh);
				meshRendererGlow = gameObject.AddComponent<MeshRenderer>();
				meshRendererBolt = gameObject2.AddComponent<MeshRenderer>();
				meshRendererGlow.shadowCastingMode = (meshRendererBolt.shadowCastingMode = ShadowCastingMode.Off);
				meshRendererGlow.reflectionProbeUsage = (meshRendererBolt.reflectionProbeUsage = ReflectionProbeUsage.Off);
				meshRendererGlow.lightProbeUsage = (meshRendererBolt.lightProbeUsage = LightProbeUsage.Off);
				meshRendererGlow.receiveShadows = (meshRendererBolt.receiveShadows = false);
				Transform = GameObject.GetComponent<Transform>();
			}

			public void PopulateMesh()
			{
				if (vertices.Count == 0)
				{
					mesh.Clear();
				}
				else
				{
					PopulateMeshInternal();
				}
			}

			public bool PrepareForLines(int lineCount)
			{
				int num = lineCount * 4;
				if (vertices.Count + num > 64999)
				{
					return false;
				}
				return true;
			}

			public void BeginLine(Vector3 start, Vector3 end, float radius, Color32 color, float colorIntensity, Vector4 fadeLifeTime, float glowWidthModifier, float glowIntensity)
			{
				Vector4 dir = end - start;
				dir.w = radius;
				AppendLineInternal(ref start, ref end, ref dir, ref dir, ref dir, color, colorIntensity, ref fadeLifeTime, glowWidthModifier, glowIntensity);
			}

			public void AppendLine(Vector3 start, Vector3 end, float radius, Color32 color, float colorIntensity, Vector4 fadeLifeTime, float glowWidthModifier, float glowIntensity)
			{
				Vector4 dir = end - start;
				dir.w = radius;
				Vector4 dirPrev = lineDirs[lineDirs.Count - 3];
				Vector4 dirPrev2 = lineDirs[lineDirs.Count - 1];
				AppendLineInternal(ref start, ref end, ref dir, ref dirPrev, ref dirPrev2, color, colorIntensity, ref fadeLifeTime, glowWidthModifier, glowIntensity);
			}

			public void Reset()
			{
				CustomTransform = null;
				Tag++;
				GameObject.SetActive(value: false);
				mesh.Clear();
				indices.Clear();
				vertices.Clear();
				colors.Clear();
				lineDirs.Clear();
				ends.Clear();
				texCoordsAndGlowModifiers.Clear();
				fadeLifetimes.Clear();
				currentBoundsMaxX = (currentBoundsMaxY = (currentBoundsMaxZ = -1147483648));
				currentBoundsMinX = (currentBoundsMinY = (currentBoundsMinZ = 1147483647));
			}

			private void PopulateMeshInternal()
			{
				GameObject.SetActive(value: true);
				mesh.SetVertices(vertices);
				mesh.SetTangents(lineDirs);
				mesh.SetColors(colors);
				mesh.SetUVs(0, texCoordsAndGlowModifiers);
				mesh.SetUVs(1, fadeLifetimes);
				mesh.SetNormals(ends);
				mesh.SetTriangles(indices, 0);
				Bounds bounds = default(Bounds);
				Vector3 vector = new Vector3(currentBoundsMinX - 2, currentBoundsMinY - 2, currentBoundsMinZ - 2);
				Vector3 vector2 = new Vector3(currentBoundsMaxX + 2, currentBoundsMaxY + 2, currentBoundsMaxZ + 2);
				bounds.center = (vector2 + vector) * 0.5f;
				bounds.size = (vector2 - vector) * 1.2f;
				mesh.bounds = bounds;
			}

			private void UpdateBounds(ref Vector3 point1, ref Vector3 point2)
			{
				int num = (int)point1.x - (int)point2.x;
				num &= num >> 31;
				int num2 = (int)point2.x + num;
				int num3 = (int)point1.x - num;
				num = currentBoundsMinX - num2;
				num &= num >> 31;
				currentBoundsMinX = num2 + num;
				num = currentBoundsMaxX - num3;
				num &= num >> 31;
				currentBoundsMaxX -= num;
				int num4 = (int)point1.y - (int)point2.y;
				num4 &= num4 >> 31;
				int num5 = (int)point2.y + num4;
				int num6 = (int)point1.y - num4;
				num4 = currentBoundsMinY - num5;
				num4 &= num4 >> 31;
				currentBoundsMinY = num5 + num4;
				num4 = currentBoundsMaxY - num6;
				num4 &= num4 >> 31;
				currentBoundsMaxY -= num4;
				int num7 = (int)point1.z - (int)point2.z;
				num7 &= num7 >> 31;
				int num8 = (int)point2.z + num7;
				int num9 = (int)point1.z - num7;
				num7 = currentBoundsMinZ - num8;
				num7 &= num7 >> 31;
				currentBoundsMinZ = num8 + num7;
				num7 = currentBoundsMaxZ - num9;
				num7 &= num7 >> 31;
				currentBoundsMaxZ -= num7;
			}

			private void AddIndices()
			{
				int count = vertices.Count;
				indices.Add(count++);
				indices.Add(count++);
				indices.Add(count);
				indices.Add(count--);
				indices.Add(count);
				indices.Add(count += 2);
			}

			private void AppendLineInternal(ref Vector3 start, ref Vector3 end, ref Vector4 dir, ref Vector4 dirPrev1, ref Vector4 dirPrev2, Color32 color, float colorIntensity, ref Vector4 fadeLifeTime, float glowWidthModifier, float glowIntensity)
			{
				AddIndices();
				color.a = (byte)Mathf.Lerp(0f, 255f, colorIntensity * 0.1f);
				Vector4 item = new Vector4(uv1.x, uv1.y, glowWidthModifier, glowIntensity);
				vertices.Add(start);
				lineDirs.Add(dirPrev1);
				colors.Add(color);
				ends.Add(dir);
				vertices.Add(end);
				lineDirs.Add(dir);
				colors.Add(color);
				ends.Add(dir);
				dir.w = 0f - dir.w;
				vertices.Add(start);
				lineDirs.Add(dirPrev2);
				colors.Add(color);
				ends.Add(dir);
				vertices.Add(end);
				lineDirs.Add(dir);
				colors.Add(color);
				ends.Add(dir);
				texCoordsAndGlowModifiers.Add(item);
				item.x = uv2.x;
				item.y = uv2.y;
				texCoordsAndGlowModifiers.Add(item);
				item.x = uv3.x;
				item.y = uv3.y;
				texCoordsAndGlowModifiers.Add(item);
				item.x = uv4.x;
				item.y = uv4.y;
				texCoordsAndGlowModifiers.Add(item);
				fadeLifetimes.Add(fadeLifeTime);
				fadeLifetimes.Add(fadeLifeTime);
				fadeLifetimes.Add(fadeLifeTime);
				fadeLifetimes.Add(fadeLifeTime);
				UpdateBounds(ref start, ref end);
			}
		}

		public static int MaximumLightCount = 128;

		public static int MaximumLightsPerBatch = 8;

		private DateTime startTimeOffset;

		private LightningBoltDependencies dependencies;

		private float elapsedTime;

		private float lifeTime;

		private float maxLifeTime;

		private bool hasLight;

		private float timeSinceLevelLoad;

		private readonly List<LightningBoltSegmentGroup> segmentGroups = new List<LightningBoltSegmentGroup>();

		private readonly List<LightningBoltSegmentGroup> segmentGroupsWithLight = new List<LightningBoltSegmentGroup>();

		private readonly List<LineRendererMesh> activeLineRenderers = new List<LineRendererMesh>();

		private static int lightCount;

		private static readonly List<LineRendererMesh> lineRendererCache = new List<LineRendererMesh>();

		private static readonly List<LightningBoltSegmentGroup> groupCache = new List<LightningBoltSegmentGroup>();

		private static readonly List<Light> lightCache = new List<Light>();

		public float MinimumDelay { get; private set; }

		public bool HasGlow { get; private set; }

		public bool IsActive => elapsedTime < lifeTime;

		public CameraMode CameraMode { get; private set; }

		public void SetupLightningBolt(LightningBoltDependencies dependencies)
		{
			if (dependencies == null || dependencies.Parameters.Count == 0)
			{
				UnityEngine.Debug.LogError("Lightning bolt dependencies must not be null");
				return;
			}
			if (this.dependencies != null)
			{
				UnityEngine.Debug.LogError("This lightning bolt is already in use!");
				return;
			}
			this.dependencies = dependencies;
			CameraMode = dependencies.CameraMode;
			timeSinceLevelLoad = LightningBoltScript.TimeSinceStart;
			CheckForGlow(dependencies.Parameters);
			MinimumDelay = float.MaxValue;
			if (dependencies.ThreadState != null)
			{
				startTimeOffset = DateTime.UtcNow;
				dependencies.ThreadState.AddActionForBackgroundThread(ProcessAllLightningParameters);
			}
			else
			{
				ProcessAllLightningParameters();
			}
		}

		public bool Update()
		{
			elapsedTime += LightningBoltScript.DeltaTime;
			if (elapsedTime > maxLifeTime)
			{
				return false;
			}
			if (hasLight)
			{
				UpdateLights();
			}
			return true;
		}

		public void Cleanup()
		{
			foreach (LightningBoltSegmentGroup item in segmentGroupsWithLight)
			{
				foreach (Light light in item.Lights)
				{
					CleanupLight(light);
				}
				item.Lights.Clear();
			}
			lock (groupCache)
			{
				foreach (LightningBoltSegmentGroup segmentGroup in segmentGroups)
				{
					groupCache.Add(segmentGroup);
				}
			}
			hasLight = false;
			elapsedTime = 0f;
			lifeTime = 0f;
			maxLifeTime = 0f;
			if (dependencies != null)
			{
				dependencies.ReturnToCache(dependencies);
				dependencies = null;
			}
			foreach (LineRendererMesh activeLineRenderer in activeLineRenderers)
			{
				if (activeLineRenderer != null)
				{
					activeLineRenderer.Reset();
					lineRendererCache.Add(activeLineRenderer);
				}
			}
			segmentGroups.Clear();
			segmentGroupsWithLight.Clear();
			activeLineRenderers.Clear();
		}

		public LightningBoltSegmentGroup AddGroup()
		{
			LightningBoltSegmentGroup lightningBoltSegmentGroup;
			lock (groupCache)
			{
				if (groupCache.Count == 0)
				{
					lightningBoltSegmentGroup = new LightningBoltSegmentGroup();
				}
				else
				{
					int index = groupCache.Count - 1;
					lightningBoltSegmentGroup = groupCache[index];
					lightningBoltSegmentGroup.Reset();
					groupCache.RemoveAt(index);
				}
			}
			segmentGroups.Add(lightningBoltSegmentGroup);
			return lightningBoltSegmentGroup;
		}

		public static void ClearCache()
		{
			foreach (LineRendererMesh item in lineRendererCache)
			{
				if (item != null)
				{
					UnityEngine.Object.Destroy(item.GameObject);
				}
			}
			foreach (Light item2 in lightCache)
			{
				if (item2 != null)
				{
					UnityEngine.Object.Destroy(item2.gameObject);
				}
			}
			lineRendererCache.Clear();
			lightCache.Clear();
			lock (groupCache)
			{
				groupCache.Clear();
			}
		}

		private void CleanupLight(Light l)
		{
			if (l != null)
			{
				dependencies.LightRemoved(l);
				lightCache.Add(l);
				l.gameObject.SetActive(value: false);
				lightCount--;
			}
		}

		private void EnableLineRenderer(LineRendererMesh lineRenderer, int tag)
		{
			if (lineRenderer != null && lineRenderer.GameObject != null && lineRenderer.Tag == tag && IsActive)
			{
				lineRenderer.PopulateMesh();
			}
		}

		private IEnumerator EnableLastRendererCoRoutine()
		{
			LineRendererMesh lineRenderer = activeLineRenderers[activeLineRenderers.Count - 1];
			int tag = ++lineRenderer.Tag;
			yield return new WaitForSecondsLightning(MinimumDelay);
			EnableLineRenderer(lineRenderer, tag);
		}

		private LineRendererMesh GetOrCreateLineRenderer()
		{
			LineRendererMesh lineRendererMesh;
			do
			{
				if (lineRendererCache.Count == 0)
				{
					lineRendererMesh = new LineRendererMesh();
					break;
				}
				int index = lineRendererCache.Count - 1;
				lineRendererMesh = lineRendererCache[index];
				lineRendererCache.RemoveAt(index);
			}
			while (lineRendererMesh == null || lineRendererMesh.Transform == null);
			lineRendererMesh.Transform.parent = null;
			lineRendererMesh.Transform.rotation = Quaternion.identity;
			lineRendererMesh.Transform.localScale = Vector3.one;
			lineRendererMesh.Transform.parent = dependencies.Parent.transform;
			GameObject gameObject = lineRendererMesh.GameObject;
			GameObject gameObject2 = lineRendererMesh.MeshRendererBolt.gameObject;
			int num = (lineRendererMesh.MeshRendererGlow.gameObject.layer = dependencies.Parent.layer);
			int layer2 = (gameObject2.layer = num);
			gameObject.layer = layer2;
			if (dependencies.UseWorldSpace)
			{
				lineRendererMesh.GameObject.transform.position = Vector3.zero;
			}
			else
			{
				lineRendererMesh.GameObject.transform.localPosition = Vector3.zero;
			}
			lineRendererMesh.MaterialGlow = dependencies.LightningMaterialMesh;
			lineRendererMesh.MaterialBolt = dependencies.LightningMaterialMeshNoGlow;
			if (!string.IsNullOrEmpty(dependencies.SortLayerName))
			{
				MeshRenderer meshRendererGlow = lineRendererMesh.MeshRendererGlow;
				string sortingLayerName = (lineRendererMesh.MeshRendererBolt.sortingLayerName = dependencies.SortLayerName);
				meshRendererGlow.sortingLayerName = sortingLayerName;
				MeshRenderer meshRendererGlow2 = lineRendererMesh.MeshRendererGlow;
				layer2 = (lineRendererMesh.MeshRendererBolt.sortingOrder = dependencies.SortOrderInLayer);
				meshRendererGlow2.sortingOrder = layer2;
			}
			else
			{
				MeshRenderer meshRendererGlow3 = lineRendererMesh.MeshRendererGlow;
				string sortingLayerName = (lineRendererMesh.MeshRendererBolt.sortingLayerName = null);
				meshRendererGlow3.sortingLayerName = sortingLayerName;
				MeshRenderer meshRendererGlow4 = lineRendererMesh.MeshRendererGlow;
				layer2 = (lineRendererMesh.MeshRendererBolt.sortingOrder = 0);
				meshRendererGlow4.sortingOrder = layer2;
			}
			activeLineRenderers.Add(lineRendererMesh);
			return lineRendererMesh;
		}

		private void RenderGroup(LightningBoltSegmentGroup group, LightningBoltParameters p)
		{
			if (group.SegmentCount == 0)
			{
				return;
			}
			float num = ((dependencies.ThreadState == null) ? 0f : ((float)(DateTime.UtcNow - startTimeOffset).TotalSeconds));
			float num2 = timeSinceLevelLoad + group.Delay + num;
			Vector4 fadeLifeTime = new Vector4(num2, num2 + group.PeakStart, num2 + group.PeakEnd, num2 + group.LifeTime);
			float num3 = group.LineWidth * 0.5f * LightningBoltParameters.Scale;
			int num4 = group.Segments.Count - group.StartIndex;
			float num5 = (num3 - num3 * group.EndWidthMultiplier) / (float)num4;
			float num6;
			if (p.GrowthMultiplier > 0f)
			{
				num6 = group.LifeTime / (float)num4 * p.GrowthMultiplier;
				num = 0f;
			}
			else
			{
				num6 = 0f;
				num = 0f;
			}
			LineRendererMesh currentLineRenderer = ((activeLineRenderers.Count == 0) ? GetOrCreateLineRenderer() : activeLineRenderers[activeLineRenderers.Count - 1]);
			if (!currentLineRenderer.PrepareForLines(num4))
			{
				if (currentLineRenderer.CustomTransform != null)
				{
					return;
				}
				if (dependencies.ThreadState != null)
				{
					dependencies.ThreadState.AddActionForMainThread(delegate
					{
						EnableCurrentLineRenderer();
						currentLineRenderer = GetOrCreateLineRenderer();
					}, waitForAction: true);
				}
				else
				{
					EnableCurrentLineRenderer();
					currentLineRenderer = GetOrCreateLineRenderer();
				}
			}
			currentLineRenderer.BeginLine(group.Segments[group.StartIndex].Start, group.Segments[group.StartIndex].End, num3, group.Color, p.Intensity, fadeLifeTime, p.GlowWidthMultiplier, p.GlowIntensity);
			for (int i = group.StartIndex + 1; i < group.Segments.Count; i++)
			{
				num3 -= num5;
				if (p.GrowthMultiplier < 1f)
				{
					num += num6;
					fadeLifeTime = new Vector4(num2 + num, num2 + group.PeakStart + num, num2 + group.PeakEnd, num2 + group.LifeTime);
				}
				currentLineRenderer.AppendLine(group.Segments[i].Start, group.Segments[i].End, num3, group.Color, p.Intensity, fadeLifeTime, p.GlowWidthMultiplier, p.GlowIntensity);
			}
		}

		private static IEnumerator NotifyBolt(LightningBoltDependencies dependencies, LightningBoltParameters p, Transform transform, Vector3 start, Vector3 end)
		{
			float delaySeconds = p.delaySeconds;
			float lifeTime = p.LifeTime;
			yield return new WaitForSecondsLightning(delaySeconds);
			if (dependencies.LightningBoltStarted != null)
			{
				dependencies.LightningBoltStarted(p, start, end);
			}
			LightningCustomTransformStateInfo state = ((p.CustomTransform == null) ? null : LightningCustomTransformStateInfo.GetOrCreateStateInfo());
			if (state != null)
			{
				state.Parameters = p;
				state.BoltStartPosition = start;
				state.BoltEndPosition = end;
				state.State = LightningCustomTransformState.Started;
				state.Transform = transform;
				p.CustomTransform(state);
				state.State = LightningCustomTransformState.Executing;
			}
			if (p.CustomTransform == null)
			{
				yield return new WaitForSecondsLightning(lifeTime);
			}
			else
			{
				while (lifeTime > 0f)
				{
					p.CustomTransform(state);
					lifeTime -= LightningBoltScript.DeltaTime;
					yield return null;
				}
			}
			if (p.CustomTransform != null)
			{
				state.State = LightningCustomTransformState.Ended;
				p.CustomTransform(state);
				LightningCustomTransformStateInfo.ReturnStateInfoToCache(state);
			}
			if (dependencies.LightningBoltEnded != null)
			{
				dependencies.LightningBoltEnded(p, start, end);
			}
			LightningBoltParameters.ReturnParametersToCache(p);
		}

		private void ProcessParameters(LightningBoltParameters p, RangeOfFloats delay, LightningBoltDependencies depends)
		{
			MinimumDelay = Mathf.Min(delay.Minimum, MinimumDelay);
			p.delaySeconds = delay.Random(p.Random);
			if (depends.LevelOfDetailDistance > Mathf.Epsilon)
			{
				float num;
				if (p.Points.Count > 1)
				{
					num = Vector3.Distance(depends.CameraPos, p.Points[0]);
					num = Mathf.Min(Vector3.Distance(depends.CameraPos, p.Points[p.Points.Count - 1]));
				}
				else
				{
					num = Vector3.Distance(depends.CameraPos, p.Start);
					num = Mathf.Min(Vector3.Distance(depends.CameraPos, p.End));
				}
				int num2 = Mathf.Min(8, (int)(num / depends.LevelOfDetailDistance));
				p.Generations = Mathf.Max(1, p.Generations - num2);
				p.GenerationWhereForksStopSubtractor = Mathf.Clamp(p.GenerationWhereForksStopSubtractor - num2, 0, 8);
			}
			p.generationWhereForksStop = p.Generations - p.GenerationWhereForksStopSubtractor;
			lifeTime = Mathf.Max(p.LifeTime + p.delaySeconds, lifeTime);
			maxLifeTime = Mathf.Max(lifeTime, maxLifeTime);
			p.forkednessCalculated = (int)Mathf.Ceil(p.Forkedness * (float)p.Generations);
			if (p.Generations > 0)
			{
				p.Generator = p.Generator ?? LightningGenerator.GeneratorInstance;
				p.Generator.GenerateLightningBolt(this, p, out var start, out var end);
				p.Start = start;
				p.End = end;
			}
		}

		private void ProcessAllLightningParameters()
		{
			int maxLights = MaximumLightsPerBatch / dependencies.Parameters.Count;
			RangeOfFloats delay = default(RangeOfFloats);
			List<int> list = new List<int>(dependencies.Parameters.Count + 1);
			int num = 0;
			foreach (LightningBoltParameters parameter in dependencies.Parameters)
			{
				delay.Minimum = parameter.DelayRange.Minimum + parameter.Delay;
				delay.Maximum = parameter.DelayRange.Maximum + parameter.Delay;
				parameter.maxLights = maxLights;
				list.Add(segmentGroups.Count);
				ProcessParameters(parameter, delay, dependencies);
			}
			list.Add(segmentGroups.Count);
			LightningBoltDependencies dependenciesRef = dependencies;
			foreach (LightningBoltParameters parameters in dependenciesRef.Parameters)
			{
				Transform transform = RenderLightningBolt(parameters.quality, parameters.Generations, list[num], list[++num], parameters);
				if (dependenciesRef.ThreadState != null)
				{
					dependenciesRef.ThreadState.AddActionForMainThread(delegate
					{
						dependenciesRef.StartCoroutine(NotifyBolt(dependenciesRef, parameters, transform, parameters.Start, parameters.End));
					});
				}
				else
				{
					dependenciesRef.StartCoroutine(NotifyBolt(dependenciesRef, parameters, transform, parameters.Start, parameters.End));
				}
			}
			if (dependencies.ThreadState != null)
			{
				dependencies.ThreadState.AddActionForMainThread(EnableCurrentLineRendererFromThread);
				return;
			}
			EnableCurrentLineRenderer();
			dependencies.AddActiveBolt(this);
		}

		private void EnableCurrentLineRendererFromThread()
		{
			EnableCurrentLineRenderer();
			dependencies.ThreadState = null;
			dependencies.AddActiveBolt(this);
		}

		private void EnableCurrentLineRenderer()
		{
			if (activeLineRenderers.Count != 0)
			{
				if (MinimumDelay <= 0f)
				{
					EnableLineRenderer(activeLineRenderers[activeLineRenderers.Count - 1], activeLineRenderers[activeLineRenderers.Count - 1].Tag);
				}
				else
				{
					dependencies.StartCoroutine(EnableLastRendererCoRoutine());
				}
			}
		}

		private void RenderParticleSystems(Vector3 start, Vector3 end, float trunkWidth, float lifeTime, float delaySeconds)
		{
			if (trunkWidth > 0f)
			{
				if (dependencies.OriginParticleSystem != null)
				{
					dependencies.StartCoroutine(GenerateParticleCoRoutine(dependencies.OriginParticleSystem, start, delaySeconds));
				}
				if (dependencies.DestParticleSystem != null)
				{
					dependencies.StartCoroutine(GenerateParticleCoRoutine(dependencies.DestParticleSystem, end, delaySeconds + lifeTime * 0.8f));
				}
			}
		}

		private Transform RenderLightningBolt(LightningBoltQualitySetting quality, int generations, int startGroupIndex, int endGroupIndex, LightningBoltParameters parameters)
		{
			if (segmentGroups.Count == 0 || startGroupIndex >= segmentGroups.Count || endGroupIndex > segmentGroups.Count)
			{
				return null;
			}
			Transform result = null;
			LightningLightParameters lp = parameters.LightParameters;
			if (lp != null)
			{
				if (hasLight |= lp.HasLight)
				{
					lp.LightPercent = Mathf.Clamp(lp.LightPercent, Mathf.Epsilon, 1f);
					lp.LightShadowPercent = Mathf.Clamp(lp.LightShadowPercent, 0f, 1f);
				}
				else
				{
					lp = null;
				}
			}
			LightningBoltSegmentGroup lightningBoltSegmentGroup = segmentGroups[startGroupIndex];
			Vector3 start = lightningBoltSegmentGroup.Segments[lightningBoltSegmentGroup.StartIndex].Start;
			Vector3 end = lightningBoltSegmentGroup.Segments[lightningBoltSegmentGroup.StartIndex + lightningBoltSegmentGroup.SegmentCount - 1].End;
			parameters.FadePercent = Mathf.Clamp(parameters.FadePercent, 0f, 0.5f);
			if (parameters.CustomTransform != null)
			{
				LineRendererMesh currentLineRenderer = ((activeLineRenderers.Count == 0 || !activeLineRenderers[activeLineRenderers.Count - 1].Empty) ? null : activeLineRenderers[activeLineRenderers.Count - 1]);
				if (currentLineRenderer == null)
				{
					if (dependencies.ThreadState != null)
					{
						dependencies.ThreadState.AddActionForMainThread(delegate
						{
							EnableCurrentLineRenderer();
							currentLineRenderer = GetOrCreateLineRenderer();
						}, waitForAction: true);
					}
					else
					{
						EnableCurrentLineRenderer();
						currentLineRenderer = GetOrCreateLineRenderer();
					}
				}
				if (currentLineRenderer == null)
				{
					return null;
				}
				currentLineRenderer.CustomTransform = parameters.CustomTransform;
				result = currentLineRenderer.Transform;
			}
			for (int i = startGroupIndex; i < endGroupIndex; i++)
			{
				LightningBoltSegmentGroup lightningBoltSegmentGroup2 = segmentGroups[i];
				lightningBoltSegmentGroup2.Delay = parameters.delaySeconds;
				lightningBoltSegmentGroup2.LifeTime = parameters.LifeTime;
				lightningBoltSegmentGroup2.PeakStart = lightningBoltSegmentGroup2.LifeTime * parameters.FadePercent;
				lightningBoltSegmentGroup2.PeakEnd = lightningBoltSegmentGroup2.LifeTime - lightningBoltSegmentGroup2.PeakStart;
				float num = lightningBoltSegmentGroup2.PeakEnd - lightningBoltSegmentGroup2.PeakStart;
				float num2 = lightningBoltSegmentGroup2.LifeTime - lightningBoltSegmentGroup2.PeakEnd;
				lightningBoltSegmentGroup2.PeakStart *= parameters.FadeInMultiplier;
				lightningBoltSegmentGroup2.PeakEnd = lightningBoltSegmentGroup2.PeakStart + num * parameters.FadeFullyLitMultiplier;
				lightningBoltSegmentGroup2.LifeTime = lightningBoltSegmentGroup2.PeakEnd + num2 * parameters.FadeOutMultiplier;
				lightningBoltSegmentGroup2.LightParameters = lp;
				RenderGroup(lightningBoltSegmentGroup2, parameters);
			}
			if (dependencies.ThreadState != null)
			{
				dependencies.ThreadState.AddActionForMainThread(delegate
				{
					RenderParticleSystems(start, end, parameters.TrunkWidth, parameters.LifeTime, parameters.delaySeconds);
					if (lp != null)
					{
						CreateLightsForGroup(segmentGroups[startGroupIndex], lp, quality, parameters.maxLights);
					}
				});
			}
			else
			{
				RenderParticleSystems(start, end, parameters.TrunkWidth, parameters.LifeTime, parameters.delaySeconds);
				if (lp != null)
				{
					CreateLightsForGroup(segmentGroups[startGroupIndex], lp, quality, parameters.maxLights);
				}
			}
			return result;
		}

		private void CreateLightsForGroup(LightningBoltSegmentGroup group, LightningLightParameters lp, LightningBoltQualitySetting quality, int maxLights)
		{
			if (lightCount == MaximumLightCount || maxLights <= 0)
			{
				return;
			}
			float num = (lifeTime - group.PeakEnd) * lp.FadeOutMultiplier;
			float num2 = (group.PeakEnd - group.PeakStart) * lp.FadeFullyLitMultiplier;
			float num3 = group.PeakStart * lp.FadeInMultiplier + num2 + num;
			maxLifeTime = Mathf.Max(maxLifeTime, group.Delay + num3);
			segmentGroupsWithLight.Add(group);
			int segmentCount = group.SegmentCount;
			float num4;
			float num5;
			if (quality == LightningBoltQualitySetting.LimitToQualitySetting)
			{
				int qualityLevel = QualitySettings.GetQualityLevel();
				if (LightningBoltParameters.QualityMaximums.TryGetValue(qualityLevel, out var value))
				{
					num4 = Mathf.Min(lp.LightPercent, value.MaximumLightPercent);
					num5 = Mathf.Min(lp.LightShadowPercent, value.MaximumShadowPercent);
				}
				else
				{
					UnityEngine.Debug.LogError("Unable to read lightning quality for level " + qualityLevel);
					num4 = lp.LightPercent;
					num5 = lp.LightShadowPercent;
				}
			}
			else
			{
				num4 = lp.LightPercent;
				num5 = lp.LightShadowPercent;
			}
			maxLights = Mathf.Max(1, Mathf.Min(maxLights, (int)((float)segmentCount * num4)));
			int num6 = Mathf.Max(1, segmentCount / maxLights);
			int num7 = maxLights - (int)((float)maxLights * num5);
			int nthShadowCounter = num7;
			for (int i = group.StartIndex + (int)((float)num6 * 0.5f); i < group.Segments.Count && !AddLightToGroup(group, lp, i, num6, num7, ref maxLights, ref nthShadowCounter); i += num6)
			{
			}
		}

		private bool AddLightToGroup(LightningBoltSegmentGroup group, LightningLightParameters lp, int segmentIndex, int nthLight, int nthShadows, ref int maxLights, ref int nthShadowCounter)
		{
			Light orCreateLight = GetOrCreateLight(lp);
			group.Lights.Add(orCreateLight);
			Vector3 vector = (group.Segments[segmentIndex].Start + group.Segments[segmentIndex].End) * 0.5f;
			if (dependencies.CameraIsOrthographic)
			{
				if (dependencies.CameraMode == CameraMode.OrthographicXZ)
				{
					vector.y = dependencies.CameraPos.y + lp.OrthographicOffset;
				}
				else
				{
					vector.z = dependencies.CameraPos.z + lp.OrthographicOffset;
				}
			}
			if (dependencies.UseWorldSpace)
			{
				orCreateLight.gameObject.transform.position = vector;
			}
			else
			{
				orCreateLight.gameObject.transform.localPosition = vector;
			}
			if (lp.LightShadowPercent == 0f || ++nthShadowCounter < nthShadows)
			{
				orCreateLight.shadows = LightShadows.None;
			}
			else
			{
				orCreateLight.shadows = LightShadows.Soft;
				nthShadowCounter = 0;
			}
			if (++lightCount != MaximumLightCount)
			{
				return --maxLights == 0;
			}
			return true;
		}

		private Light GetOrCreateLight(LightningLightParameters lp)
		{
			Light light;
			do
			{
				if (lightCache.Count == 0)
				{
					light = new GameObject("LightningBoltLight").AddComponent<Light>();
					light.type = LightType.Point;
					break;
				}
				light = lightCache[lightCache.Count - 1];
				lightCache.RemoveAt(lightCache.Count - 1);
			}
			while (light == null);
			light.bounceIntensity = lp.BounceIntensity;
			light.shadowNormalBias = lp.ShadowNormalBias;
			light.color = lp.LightColor;
			light.renderMode = lp.RenderMode;
			light.range = lp.LightRange;
			light.shadowStrength = lp.ShadowStrength;
			light.shadowBias = lp.ShadowBias;
			light.intensity = 0f;
			light.gameObject.transform.parent = dependencies.Parent.transform;
			light.gameObject.SetActive(value: true);
			dependencies.LightAdded(light);
			return light;
		}

		private void UpdateLight(LightningLightParameters lp, IEnumerable<Light> lights, float delay, float peakStart, float peakEnd, float lifeTime)
		{
			if (elapsedTime < delay)
			{
				return;
			}
			float num = (lifeTime - peakEnd) * lp.FadeOutMultiplier;
			float num2 = (peakEnd - peakStart) * lp.FadeFullyLitMultiplier;
			peakStart *= lp.FadeInMultiplier;
			peakEnd = peakStart + num2;
			lifeTime = peakEnd + num;
			float num3 = elapsedTime - delay;
			if (num3 >= peakStart)
			{
				if (num3 <= peakEnd)
				{
					foreach (Light light in lights)
					{
						light.intensity = lp.LightIntensity;
					}
					return;
				}
				float t = (num3 - peakEnd) / (lifeTime - peakEnd);
				{
					foreach (Light light2 in lights)
					{
						light2.intensity = Mathf.Lerp(lp.LightIntensity, 0f, t);
					}
					return;
				}
			}
			float t2 = num3 / peakStart;
			foreach (Light light3 in lights)
			{
				light3.intensity = Mathf.Lerp(0f, lp.LightIntensity, t2);
			}
		}

		private void UpdateLights()
		{
			foreach (LightningBoltSegmentGroup item in segmentGroupsWithLight)
			{
				UpdateLight(item.LightParameters, item.Lights, item.Delay, item.PeakStart, item.PeakEnd, item.LifeTime);
			}
		}

		private IEnumerator GenerateParticleCoRoutine(ParticleSystem p, Vector3 pos, float delay)
		{
			yield return new WaitForSecondsLightning(delay);
			p.transform.position = pos;
			if (p.emission.burstCount > 0)
			{
				ParticleSystem.Burst[] array = new ParticleSystem.Burst[p.emission.burstCount];
				p.emission.GetBursts(array);
				int count = UnityEngine.Random.Range(array[0].minCount, array[0].maxCount + 1);
				p.Emit(count);
			}
			else
			{
				ParticleSystem.MinMaxCurve rateOverTime = p.emission.rateOverTime;
				int count = (int)((rateOverTime.constantMax - rateOverTime.constantMin) * 0.5f);
				count = UnityEngine.Random.Range(count, count * 2);
				p.Emit(count);
			}
		}

		private void CheckForGlow(IEnumerable<LightningBoltParameters> parameters)
		{
			foreach (LightningBoltParameters parameter in parameters)
			{
				HasGlow = parameter.GlowIntensity >= Mathf.Epsilon && parameter.GlowWidthMultiplier >= Mathf.Epsilon;
				if (HasGlow)
				{
					break;
				}
			}
		}
	}
	public class LightningThreadState
	{
		private Thread lightningThread;

		private AutoResetEvent lightningThreadEvent = new AutoResetEvent(initialState: false);

		private readonly Queue<Action> actionsForBackgroundThread = new Queue<Action>();

		private readonly Queue<KeyValuePair<Action, ManualResetEvent>> actionsForMainThread = new Queue<KeyValuePair<Action, ManualResetEvent>>();

		public bool Running = true;

		private bool isTerminating;

		private bool UpdateMainThreadActionsOnce()
		{
			KeyValuePair<Action, ManualResetEvent> keyValuePair;
			lock (actionsForMainThread)
			{
				if (actionsForMainThread.Count == 0)
				{
					return false;
				}
				keyValuePair = actionsForMainThread.Dequeue();
			}
			try
			{
				keyValuePair.Key();
			}
			catch
			{
			}
			if (keyValuePair.Value != null)
			{
				keyValuePair.Value.Set();
			}
			return true;
		}

		private void BackgroundThreadMethod()
		{
			Action action = null;
			while (Running)
			{
				try
				{
					if (!lightningThreadEvent.WaitOne(500))
					{
						continue;
					}
					while (true)
					{
						lock (actionsForBackgroundThread)
						{
							if (actionsForBackgroundThread.Count == 0)
							{
								break;
							}
							action = actionsForBackgroundThread.Dequeue();
							goto IL_0051;
						}
						IL_0051:
						action();
					}
				}
				catch (ThreadAbortException)
				{
				}
				catch (Exception ex2)
				{
					UnityEngine.Debug.LogErrorFormat("Lightning thread exception: {0}", ex2);
				}
			}
		}

		public LightningThreadState()
		{
			lightningThread = new Thread(BackgroundThreadMethod)
			{
				IsBackground = true,
				Name = "LightningBoltScriptThread"
			};
			lightningThread.Start();
		}

		public void TerminateAndWaitForEnd()
		{
			isTerminating = true;
			while (true)
			{
				if (UpdateMainThreadActionsOnce())
				{
					continue;
				}
				lock (actionsForBackgroundThread)
				{
					if (actionsForBackgroundThread.Count == 0)
					{
						break;
					}
				}
			}
		}

		public void UpdateMainThreadActions()
		{
			while (UpdateMainThreadActionsOnce())
			{
			}
		}

		public bool AddActionForMainThread(Action action, bool waitForAction = false)
		{
			if (isTerminating)
			{
				return false;
			}
			ManualResetEvent manualResetEvent = (waitForAction ? new ManualResetEvent(initialState: false) : null);
			lock (actionsForMainThread)
			{
				actionsForMainThread.Enqueue(new KeyValuePair<Action, ManualResetEvent>(action, manualResetEvent));
			}
			manualResetEvent?.WaitOne(10000);
			return true;
		}

		public bool AddActionForBackgroundThread(Action action)
		{
			if (isTerminating)
			{
				return false;
			}
			lock (actionsForBackgroundThread)
			{
				actionsForBackgroundThread.Enqueue(action);
			}
			lightningThreadEvent.Set();
			return true;
		}
	}
	public abstract class LightningBoltPathScriptBase : LightningBoltPrefabScriptBase
	{
		[Header("Lightning Path Properties")]
		[Tooltip("The game objects to follow for the lightning path")]
		public List<GameObject> LightningPath;

		private readonly List<GameObject> currentPathObjects = new List<GameObject>();

		protected List<GameObject> GetCurrentPathObjects()
		{
			currentPathObjects.Clear();
			if (LightningPath != null)
			{
				foreach (GameObject item in LightningPath)
				{
					if (item != null && item.activeInHierarchy)
					{
						currentPathObjects.Add(item);
					}
				}
			}
			return currentPathObjects;
		}

		protected override LightningBoltParameters OnCreateParameters()
		{
			LightningBoltParameters lightningBoltParameters = base.OnCreateParameters();
			lightningBoltParameters.Generator = LightningGenerator.GeneratorInstance;
			return lightningBoltParameters;
		}
	}
	public class LightningBoltPathScript : LightningBoltPathScriptBase
	{
		[Tooltip("How fast the lightning moves through the points or objects. 1 is normal speed, 0.01 is slower, so the lightning will move slowly between the points or objects.")]
		[Range(0.01f, 1f)]
		public float Speed = 1f;

		[Tooltip("Repeat when the path completes?")]
		[SingleLineClamp("When each new point is moved to, this can provide a random value to make the movement to the next point appear more staggered or random. Leave as 1 and 1 to have constant speed. Use a higher maximum to create more randomness.", 1.0, 500.0)]
		public RangeOfFloats SpeedIntervalRange = new RangeOfFloats
		{
			Minimum = 1f,
			Maximum = 1f
		};

		[Tooltip("Repeat when the path completes?")]
		public bool Repeat = true;

		private float nextInterval = 1f;

		private int nextIndex;

		private Vector3? lastPoint;

		public override void CreateLightningBolt(LightningBoltParameters parameters)
		{
			Vector3? vector = null;
			List<GameObject> list = GetCurrentPathObjects();
			if (list.Count < 2)
			{
				return;
			}
			if (nextIndex >= list.Count)
			{
				if (!Repeat)
				{
					return;
				}
				if (list[list.Count - 1] == list[0])
				{
					nextIndex = 1;
				}
				else
				{
					nextIndex = 0;
					lastPoint = null;
				}
			}
			try
			{
				if (!lastPoint.HasValue)
				{
					lastPoint = list[nextIndex++].transform.position;
				}
				vector = list[nextIndex].transform.position;
				if (lastPoint.HasValue && vector.HasValue)
				{
					parameters.Start = lastPoint.Value;
					parameters.End = vector.Value;
					base.CreateLightningBolt(parameters);
					if ((nextInterval -= Speed) <= 0f)
					{
						float num = UnityEngine.Random.Range(SpeedIntervalRange.Minimum, SpeedIntervalRange.Maximum);
						nextInterval = num + nextInterval;
						lastPoint = vector;
						nextIndex++;
					}
				}
			}
			catch (NullReferenceException)
			{
			}
		}

		public void Reset()
		{
			lastPoint = null;
			nextIndex = 0;
			nextInterval = 1f;
		}
	}
	public abstract class LightningBoltPrefabScriptBase : LightningBoltScript
	{
		private readonly List<LightningBoltParameters> batchParameters = new List<LightningBoltParameters>();

		private readonly System.Random random = new System.Random();

		[Header("Lightning Spawn Properties")]
		[SingleLineClamp("How long to wait before creating another round of lightning bolts in seconds", 0.001, double.MaxValue)]
		public RangeOfFloats IntervalRange = new RangeOfFloats
		{
			Minimum = 0.05f,
			Maximum = 0.1f
		};

		[SingleLineClamp("How many lightning bolts to emit for each interval", 0.0, 100.0)]
		public RangeOfIntegers CountRange = new RangeOfIntegers
		{
			Minimum = 1,
			Maximum = 1
		};

		[Tooltip("Reduces the probability that additional bolts from CountRange will actually happen (0 - 1).")]
		[Range(0f, 1f)]
		public float CountProbabilityModifier = 1f;

		public RangeOfFloats DelayRange = new RangeOfFloats
		{
			Minimum = 0f,
			Maximum = 0f
		};

		[SingleLineClamp("For each bolt emitted, how long should it stay in seconds", 0.01, 10.0)]
		public RangeOfFloats DurationRange = new RangeOfFloats
		{
			Minimum = 0.06f,
			Maximum = 0.12f
		};

		[Header("Lightning Appearance Properties")]
		[SingleLineClamp("The trunk width range in unity units (x = min, y = max)", 0.0001, 100.0)]
		public RangeOfFloats TrunkWidthRange = new RangeOfFloats
		{
			Minimum = 0.1f,
			Maximum = 0.2f
		};

		[Tooltip("How long (in seconds) this game object should live before destroying itself. Leave as 0 for infinite.")]
		[Range(0f, 1000f)]
		public float LifeTime;

		[Tooltip("Generations (1 - 8, higher makes more detailed but more expensive lightning)")]
		[Range(1f, 8f)]
		public int Generations = 6;

		[Tooltip("The chaos factor that determines how far the lightning main trunk can spread out, higher numbers spread out more. 0 - 1.")]
		[Range(0f, 1f)]
		public float ChaosFactor = 0.075f;

		[Tooltip("The chaos factor that determines how far the forks of the lightning can spread out, higher numbers spread out more. 0 - 1.")]
		[Range(0f, 1f)]
		public float ChaosFactorForks = 0.095f;

		[Tooltip("Intensity of the lightning")]
		[Range(0f, 10f)]
		public float Intensity = 1f;

		[Tooltip("The intensity of the glow")]
		[Range(0f, 10f)]
		public float GlowIntensity = 0.1f;

		[Tooltip("The width multiplier for the glow, 0 - 64")]
		[Range(0f, 64f)]
		public float GlowWidthMultiplier = 4f;

		[Tooltip("What percent of time the lightning should fade in and out. For example, 0.15 fades in 15% of the time and fades out 15% of the time, with full visibility 70% of the time.")]
		[Range(0f, 0.5f)]
		public float FadePercent = 0.15f;

		[Tooltip("Modify the duration of lightning fade in.")]
		[Range(0f, 1f)]
		public float FadeInMultiplier = 1f;

		[Tooltip("Modify the duration of fully lit lightning.")]
		[Range(0f, 1f)]
		public float FadeFullyLitMultiplier = 1f;

		[Tooltip("Modify the duration of lightning fade out.")]
		[Range(0f, 1f)]
		public float FadeOutMultiplier = 1f;

		[Tooltip("0 - 1, how slowly the lightning should grow. 0 for instant, 1 for slow.")]
		[Range(0f, 1f)]
		public float GrowthMultiplier;

		[Tooltip("How much smaller the lightning should get as it goes towards the end of the bolt. For example, 0.5 will make the end 50% the width of the start.")]
		[Range(0f, 10f)]
		public float EndWidthMultiplier = 0.5f;

		[Tooltip("How forked should the lightning be? (0 - 1, 0 for none, 1 for lots of forks)")]
		[Range(0f, 1f)]
		public float Forkedness = 0.25f;

		[Range(0f, 10f)]
		[Tooltip("Minimum distance multiplier for forks")]
		public float ForkLengthMultiplier = 0.6f;

		[Range(0f, 10f)]
		[Tooltip("Fork distance multiplier variance. Random range of 0 to n that is added to Fork Length Multiplier.")]
		public float ForkLengthVariance = 0.2f;

		[Tooltip("Forks have their EndWidthMultiplier multiplied by this value")]
		[Range(0f, 10f)]
		public float ForkEndWidthMultiplier = 1f;

		[Header("Lightning Light Properties")]
		[Tooltip("Light parameters")]
		public LightningLightParameters LightParameters;

		[Tooltip("Maximum number of lights that can be created per batch of lightning")]
		[Range(0f, 64f)]
		public int MaximumLightsPerBatch = 8;

		[Header("Lightning Trigger Type")]
		[Tooltip("Manual or automatic mode. Manual requires that you call the Trigger method in script. Automatic uses the interval to create lightning continuously.")]
		public bool ManualMode;

		[Tooltip("Turns lightning into automatic mode for this number of seconds, then puts it into manual mode.")]
		[Range(0f, 120f)]
		public float AutomaticModeSeconds;

		[Header("Lightning custom transform handler")]
		[Tooltip("Custom handler to modify the transform of each lightning bolt, useful if it will be alive longer than a few frames and needs to scale and rotate based on the position of other objects.")]
		public LightningCustomTransformDelegate CustomTransformHandler;

		private float nextLightningTimestamp;

		private float lifeTimeRemaining;

		public System.Random RandomOverride { get; set; }

		private void CalculateNextLightningTimestamp(float offset)
		{
			nextLightningTimestamp = ((IntervalRange.Minimum == IntervalRange.Maximum) ? IntervalRange.Minimum : (offset + IntervalRange.Random()));
		}

		private void CustomTransform(LightningCustomTransformStateInfo state)
		{
			if (CustomTransformHandler != null)
			{
				CustomTransformHandler.Invoke(state);
			}
		}

		private void CallLightning()
		{
			CallLightning(null, null);
		}

		private void CallLightning(Vector3? start, Vector3? end)
		{
			System.Random r = RandomOverride ?? random;
			int num = CountRange.Random(r);
			for (int i = 0; i < num; i++)
			{
				LightningBoltParameters lightningBoltParameters = CreateParameters();
				if (CountProbabilityModifier >= 0.9999f || i == 0 || (float)lightningBoltParameters.Random.NextDouble() <= CountProbabilityModifier)
				{
					lightningBoltParameters.CustomTransform = ((CustomTransformHandler == null) ? null : new Action<LightningCustomTransformStateInfo>(CustomTransform));
					CreateLightningBolt(lightningBoltParameters);
					if (start.HasValue)
					{
						lightningBoltParameters.Start = start.Value;
					}
					if (end.HasValue)
					{
						lightningBoltParameters.End = end.Value;
					}
				}
				else
				{
					LightningBoltParameters.ReturnParametersToCache(lightningBoltParameters);
				}
			}
			CreateLightningBoltsNow();
		}

		protected void CreateLightningBoltsNow()
		{
			int maximumLightsPerBatch = LightningBolt.MaximumLightsPerBatch;
			LightningBolt.MaximumLightsPerBatch = MaximumLightsPerBatch;
			CreateLightningBolts(batchParameters);
			LightningBolt.MaximumLightsPerBatch = maximumLightsPerBatch;
			batchParameters.Clear();
		}

		protected override void PopulateParameters(LightningBoltParameters parameters)
		{
			base.PopulateParameters(parameters);
			parameters.RandomOverride = RandomOverride;
			float lifeTime = DurationRange.Random(parameters.Random);
			float trunkWidth = TrunkWidthRange.Random(parameters.Random);
			parameters.Generations = Generations;
			parameters.LifeTime = lifeTime;
			parameters.ChaosFactor = ChaosFactor;
			parameters.ChaosFactorForks = ChaosFactorForks;
			parameters.TrunkWidth = trunkWidth;
			parameters.Intensity = Intensity;
			parameters.GlowIntensity = GlowIntensity;
			parameters.GlowWidthMultiplier = GlowWidthMultiplier;
			parameters.Forkedness = Forkedness;
			parameters.ForkLengthMultiplier = ForkLengthMultiplier;
			parameters.ForkLengthVariance = ForkLengthVariance;
			parameters.FadePercent = FadePercent;
			parameters.FadeInMultiplier = FadeInMultiplier;
			parameters.FadeOutMultiplier = FadeOutMultiplier;
			parameters.FadeFullyLitMultiplier = FadeFullyLitMultiplier;
			parameters.GrowthMultiplier = GrowthMultiplier;
			parameters.EndWidthMultiplier = EndWidthMultiplier;
			parameters.ForkEndWidthMultiplier = ForkEndWidthMultiplier;
			parameters.DelayRange = DelayRange;
			parameters.LightParameters = LightParameters;
		}

		protected override void Start()
		{
			base.Start();
			CalculateNextLightningTimestamp(0f);
			lifeTimeRemaining = ((LifeTime <= 0f) ? float.MaxValue : LifeTime);
		}

		protected override void Update()
		{
			base.Update();
			if ((lifeTimeRemaining -= LightningBoltScript.DeltaTime) < 0f)
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
			if ((nextLightningTimestamp -= LightningBoltScript.DeltaTime) <= 0f)
			{
				CalculateNextLightningTimestamp(nextLightningTimestamp);
				if (!ManualMode)
				{
					CallLightning();
				}
			}
			if (AutomaticModeSeconds > 0f)
			{
				AutomaticModeSeconds = Mathf.Max(0f, AutomaticModeSeconds - LightningBoltScript.DeltaTime);
				ManualMode = AutomaticModeSeconds == 0f;
			}
		}

		public override void CreateLightningBolt(LightningBoltParameters p)
		{
			batchParameters.Add(p);
		}

		public void Trigger()
		{
			Trigger(-1f);
		}

		public void Trigger(float seconds)
		{
			CallLightning();
			if (seconds >= 0f)
			{
				AutomaticModeSeconds = Mathf.Max(0f, seconds);
			}
		}

		public void Trigger(Vector3? start, Vector3? end)
		{
			CallLightning(start, end);
		}
	}
	public class LightningBoltPrefabScript : LightningBoltPrefabScriptBase
	{
		[Header("Start/end")]
		[Tooltip("The source game object, can be null")]
		public GameObject Source;

		[Tooltip("The destination game object, can be null")]
		public GameObject Destination;

		[Tooltip("X, Y and Z for variance from the start point. Use positive values.")]
		public Vector3 StartVariance;

		[Tooltip("X, Y and Z for variance from the end point. Use positive values.")]
		public Vector3 EndVariance;

		public override void CreateLightningBolt(LightningBoltParameters parameters)
		{
			parameters.Start = ((Source == null) ? parameters.Start : Source.transform.position);
			parameters.End = ((Destination == null) ? parameters.End : Destination.transform.position);
			parameters.StartVariance = StartVariance;
			parameters.EndVariance = EndVariance;
			base.CreateLightningBolt(parameters);
		}
	}
	public class LightningBoltScript : MonoBehaviour
	{
		[Header("Lightning General Properties")]
		[Tooltip("The camera the lightning should be shown in. Defaults to the current camera, or the main camera if current camera is null. If you are using a different camera, you may want to put the lightning in it's own layer and cull that layer out of any other cameras.")]
		public Camera Camera;

		[Tooltip("Type of camera mode. Auto detects the camera and creates appropriate lightning. Can be overriden to do something more specific regardless of camera.")]
		public CameraMode CameraMode;

		internal CameraMode calculatedCameraMode = CameraMode.Unknown;

		[Tooltip("True if you are using world space coordinates for the lightning bolt, false if you are using coordinates relative to the parent game object.")]
		public bool UseWorldSpace = true;

		[Tooltip("Whether to compensate for the parent transform. Default is false. If true, rotation, scale and position are altered by the parent transform. Use this to fix scaling, rotation and other offset problems with the lightning.")]
		public bool CompensateForParentTransform;

		[Tooltip("Lightning quality setting. This allows setting limits on generations, lights and shadow casting lights based on the global quality setting.")]
		public LightningBoltQualitySetting QualitySetting;

		[Tooltip("Whether to use multi-threaded generation of lightning. Lightning will be delayed by about 1 frame if this is turned on, but this can significantly improve performance.")]
		public bool MultiThreaded;

		[Range(0f, 1000f)]
		[Tooltip("If non-zero, the Camera property is used to get distance of lightning from camera. Lightning generations is reduced for each distance from camera. For example, if LevelOfDetailDistance was 100 and the lightning was 200 away from camera, generations would be reduced by 2, to a minimum of 1.")]
		public float LevelOfDetailDistance;

		[Tooltip("True to use game time, false to use real time")]
		public bool UseGameTime;

		[Header("Lightning 2D Settings")]
		[Tooltip("Sort layer name")]
		public string SortLayerName;

		[Tooltip("Order in sort layer")]
		public int SortOrderInLayer;

		[Header("Lightning Rendering Properties")]
		[Tooltip("Soft particles factor. 0.01 to 3.0 are typical, 100.0 to disable.")]
		[Range(0.01f, 100f)]
		public float SoftParticlesFactor = 3f;

		[Tooltip("The render queue for the lightning. -1 for default.")]
		public int RenderQueue = -1;

		[Tooltip("Lightning material for mesh renderer - glow")]
		public Material LightningMaterialMesh;

		[Tooltip("Lightning material for mesh renderer - bolt")]
		public Material LightningMaterialMeshNoGlow;

		[Tooltip("The texture to use for the lightning bolts, or null for the material default texture.")]
		public Texture2D LightningTexture;

		[Tooltip("The texture to use for the lightning glow, or null for the material default texture.")]
		public Texture2D LightningGlowTexture;

		[Tooltip("Particle system to play at the point of emission (start). 'Emission rate' particles will be emitted all at once.")]
		public ParticleSystem LightningOriginParticleSystem;

		[Tooltip("Particle system to play at the point of impact (end). 'Emission rate' particles will be emitted all at once.")]
		public ParticleSystem LightningDestinationParticleSystem;

		[Tooltip("Tint color for the lightning")]
		public Color LightningTintColor = Color.white;

		[Tooltip("Tint color for the lightning glow")]
		public Color GlowTintColor = new Color(0.1f, 0.2f, 1f, 1f);

		[Tooltip("Source blend mode. Default is SrcAlpha.")]
		public BlendMode SourceBlendMode = BlendMode.SrcAlpha;

		[Tooltip("Destination blend mode. Default is One. For additive blend use One. For alpha blend use OneMinusSrcAlpha.")]
		public BlendMode DestinationBlendMode = BlendMode.One;

		[Header("Lightning Movement Properties")]
		[Tooltip("Jitter multiplier to randomize lightning size. Jitter depends on trunk width and will make the lightning move rapidly and jaggedly, giving a more lively and sometimes cartoony feel. Jitter may be shared with other bolts depending on materials. If you need different jitters for the same material, create a second script object.")]
		public float JitterMultiplier;

		[Tooltip("Built in turbulance based on the direction of each segment. Small values usually work better, like 0.2.")]
		public float Turbulence;

		[Tooltip("Global turbulence velocity for this script")]
		public Vector3 TurbulenceVelocity = Vector3.zero;

		[Tooltip("Cause lightning to flicker, x = min, y = max, z = time multiplier, w = add to intensity")]
		public Vector4 IntensityFlicker = intensityFlickerDefault;

		private static readonly Vector4 intensityFlickerDefault = new Vector4(1f, 1f, 1f, 0f);

		[Tooltip("Lightning intensity flicker lookup texture")]
		public Texture2D IntensityFlickerTexture;

		public static float TimeScale = 1f;

		private static bool needsTimeUpdate = true;

		private Texture2D lastLightningTexture;

		private Texture2D lastLightningGlowTexture;

		private readonly List<LightningBolt> activeBolts = new List<LightningBolt>();

		private readonly LightningBoltParameters[] oneParameterArray = new LightningBoltParameters[1];

		private readonly List<LightningBolt> lightningBoltCache = new List<LightningBolt>();

		private readonly List<LightningBoltDependencies> dependenciesCache = new List<LightningBoltDependencies>();

		private LightningThreadState threadState;

		private static int shaderId_MainTex = int.MinValue;

		private static int shaderId_TintColor;

		private static int shaderId_JitterMultiplier;

		private static int shaderId_Turbulence;

		private static int shaderId_TurbulenceVelocity;

		private static int shaderId_SrcBlendMode;

		private static int shaderId_DstBlendMode;

		private static int shaderId_InvFade;

		private static int shaderId_LightningTime;

		private static int shaderId_IntensityFlicker;

		private static int shaderId_IntensityFlickerTexture;

		public Action<LightningBoltParameters, Vector3, Vector3> LightningStartedCallback { get; set; }

		public Action<LightningBoltParameters, Vector3, Vector3> LightningEndedCallback { get; set; }

		public Action<Light> LightAddedCallback { get; set; }

		public Action<Light> LightRemovedCallback { get; set; }

		public bool HasActiveBolts => activeBolts.Count != 0;

		public static Vector4 TimeVectorSinceStart { get; private set; }

		public static float TimeSinceStart { get; private set; }

		public static float DeltaTime { get; private set; }

		internal Material lightningMaterialMeshInternal { get; private set; }

		internal Material lightningMaterialMeshNoGlowInternal { get; private set; }

		public virtual void CreateLightningBolt(LightningBoltParameters p)
		{
			if (p != null && Camera != null)
			{
				UpdateTexture();
				oneParameterArray[0] = p;
				LightningBolt orCreateLightningBolt = GetOrCreateLightningBolt();
				LightningBoltDependencies dependencies = CreateLightningBoltDependencies(oneParameterArray);
				orCreateLightningBolt.SetupLightningBolt(dependencies);
			}
		}

		public void CreateLightningBolts(ICollection<LightningBoltParameters> parameters)
		{
			if (parameters != null && parameters.Count != 0 && Camera != null)
			{
				UpdateTexture();
				LightningBolt orCreateLightningBolt = GetOrCreateLightningBolt();
				LightningBoltDependencies dependencies = CreateLightningBoltDependencies(parameters);
				orCreateLightningBolt.SetupLightningBolt(dependencies);
			}
		}

		protected virtual void Awake()
		{
			UpdateShaderIds();
		}

		protected virtual void Start()
		{
			UpdateCamera();
			UpdateMaterialsForLastTexture();
			UpdateShaderParameters();
			CheckCompensateForParentTransform();
			SceneManager.sceneLoaded += OnSceneLoaded;
			if (MultiThreaded)
			{
				threadState = new LightningThreadState();
			}
		}

		protected virtual void Update()
		{
			if (needsTimeUpdate)
			{
				needsTimeUpdate = false;
				DeltaTime = (UseGameTime ? Time.deltaTime : Time.unscaledDeltaTime) * TimeScale;
				TimeSinceStart += DeltaTime;
			}
			if (HasActiveBolts)
			{
				UpdateCamera();
				UpdateShaderParameters();
				CheckCompensateForParentTransform();
				UpdateActiveBolts();
				Shader.SetGlobalVector(shaderId_LightningTime, TimeVectorSinceStart = new Vector4(TimeSinceStart * 0.05f, TimeSinceStart, TimeSinceStart * 2f, TimeSinceStart * 3f));
			}
			if (threadState != null)
			{
				threadState.UpdateMainThreadActions();
			}
		}

		protected virtual void LateUpdate()
		{
			needsTimeUpdate = true;
		}

		protected virtual LightningBoltParameters OnCreateParameters()
		{
			return LightningBoltParameters.GetOrCreateParameters();
		}

		protected LightningBoltParameters CreateParameters()
		{
			LightningBoltParameters lightningBoltParameters = OnCreateParameters();
			lightningBoltParameters.quality = QualitySetting;
			PopulateParameters(lightningBoltParameters);
			return lightningBoltParameters;
		}

		protected virtual void PopulateParameters(LightningBoltParameters parameters)
		{
		}

		private Coroutine StartCoroutineWrapper(IEnumerator routine)
		{
			if (base.isActiveAndEnabled)
			{
				return StartCoroutine(routine);
			}
			return null;
		}

		private void OnSceneLoaded(Scene arg0, LoadSceneMode arg1)
		{
			LightningBolt.ClearCache();
		}

		private LightningBoltDependencies CreateLightningBoltDependencies(ICollection<LightningBoltParameters> parameters)
		{
			LightningBoltDependencies lightningBoltDependencies;
			if (dependenciesCache.Count == 0)
			{
				lightningBoltDependencies = new LightningBoltDependencies();
				lightningBoltDependencies.AddActiveBolt = AddActiveBolt;
				lightningBoltDependencies.LightAdded = OnLightAdded;
				lightningBoltDependencies.LightRemoved = OnLightRemoved;
				lightningBoltDependencies.ReturnToCache = ReturnLightningDependenciesToCache;
				lightningBoltDependencies.StartCoroutine = StartCoroutineWrapper;
				lightningBoltDependencies.Parent = base.gameObject;
			}
			else
			{
				int index = dependenciesCache.Count - 1;
				lightningBoltDependencies = dependenciesCache[index];
				dependenciesCache.RemoveAt(index);
			}
			lightningBoltDependencies.CameraPos = Camera.transform.position;
			lightningBoltDependencies.CameraIsOrthographic = Camera.orthographic;
			lightningBoltDependencies.CameraMode = calculatedCameraMode;
			lightningBoltDependencies.LevelOfDetailDistance = LevelOfDetailDistance;
			lightningBoltDependencies.DestParticleSystem = LightningDestinationParticleSystem;
			lightningBoltDependencies.LightningMaterialMesh = lightningMaterialMeshInternal;
			lightningBoltDependencies.LightningMaterialMeshNoGlow = lightningMaterialMeshNoGlowInternal;
			lightningBoltDependencies.OriginParticleSystem = LightningOriginParticleSystem;
			lightningBoltDependencies.SortLayerName = SortLayerName;
			lightningBoltDependencies.SortOrderInLayer = SortOrderInLayer;
			lightningBoltDependencies.UseWorldSpace = UseWorldSpace;
			lightningBoltDependencies.ThreadState = threadState;
			if (threadState != null)
			{
				lightningBoltDependencies.Parameters = new List<LightningBoltParameters>(parameters);
			}
			else
			{
				lightningBoltDependencies.Parameters = parameters;
			}
			lightningBoltDependencies.LightningBoltStarted = LightningStartedCallback;
			lightningBoltDependencies.LightningBoltEnded = LightningEndedCallback;
			return lightningBoltDependencies;
		}

		private void ReturnLightningDependenciesToCache(LightningBoltDependencies d)
		{
			d.Parameters = null;
			d.OriginParticleSystem = null;
			d.DestParticleSystem = null;
			d.LightningMaterialMesh = null;
			d.LightningMaterialMeshNoGlow = null;
			dependenciesCache.Add(d);
		}

		internal void OnLightAdded(Light l)
		{
			if (LightAddedCallback != null)
			{
				LightAddedCallback(l);
			}
		}

		internal void OnLightRemoved(Light l)
		{
			if (LightRemovedCallback != null)
			{
				LightRemovedCallback(l);
			}
		}

		internal void AddActiveBolt(LightningBolt bolt)
		{
			activeBolts.Add(bolt);
		}

		private void UpdateShaderIds()
		{
			if (shaderId_MainTex == int.MinValue)
			{
				shaderId_MainTex = Shader.PropertyToID("_MainTex");
				shaderId_TintColor = Shader.PropertyToID("_TintColor");
				shaderId_JitterMultiplier = Shader.PropertyToID("_JitterMultiplier");
				shaderId_Turbulence = Shader.PropertyToID("_Turbulence");
				shaderId_TurbulenceVelocity = Shader.PropertyToID("_TurbulenceVelocity");
				shaderId_SrcBlendMode = Shader.PropertyToID("_SrcBlendMode");
				shaderId_DstBlendMode = Shader.PropertyToID("_DstBlendMode");
				shaderId_InvFade = Shader.PropertyToID("_InvFade");
				shaderId_LightningTime = Shader.PropertyToID("_LightningTime");
				shaderId_IntensityFlicker = Shader.PropertyToID("_IntensityFlicker");
				shaderId_IntensityFlickerTexture = Shader.PropertyToID("_IntensityFlickerTexture");
			}
		}

		private void UpdateMaterialsForLastTexture()
		{
			if (Application.isPlaying)
			{
				calculatedCameraMode = CameraMode.Unknown;
				lightningMaterialMeshInternal = new Material(LightningMaterialMesh);
				lightningMaterialMeshNoGlowInternal = new Material(LightningMaterialMeshNoGlow);
				if (LightningTexture != null)
				{
					lightningMaterialMeshNoGlowInternal.SetTexture(shaderId_MainTex, LightningTexture);
				}
				if (LightningGlowTexture != null)
				{
					lightningMaterialMeshInternal.SetTexture(shaderId_MainTex, LightningGlowTexture);
				}
				SetupMaterialCamera();
			}
		}

		private void UpdateTexture()
		{
			if (LightningTexture != null && LightningTexture != lastLightningTexture)
			{
				lastLightningTexture = LightningTexture;
				UpdateMaterialsForLastTexture();
			}
			if (LightningGlowTexture != null && LightningGlowTexture != lastLightningGlowTexture)
			{
				lastLightningGlowTexture = LightningGlowTexture;
				UpdateMaterialsForLastTexture();
			}
		}

		private void SetMaterialPerspective()
		{
			if (calculatedCameraMode != CameraMode.Perspective)
			{
				calculatedCameraMode = CameraMode.Perspective;
				lightningMaterialMeshInternal.EnableKeyword("PERSPECTIVE");
				lightningMaterialMeshNoGlowInternal.EnableKeyword("PERSPECTIVE");
				lightningMaterialMeshInternal.DisableKeyword("ORTHOGRAPHIC_XY");
				lightningMaterialMeshNoGlowInternal.DisableKeyword("ORTHOGRAPHIC_XY");
				lightningMaterialMeshInternal.DisableKeyword("ORTHOGRAPHIC_XZ");
				lightningMaterialMeshNoGlowInternal.DisableKeyword("ORTHOGRAPHIC_XZ");
			}
		}

		private void SetMaterialOrthographicXY()
		{
			if (calculatedCameraMode != CameraMode.OrthographicXY)
			{
				calculatedCameraMode = CameraMode.OrthographicXY;
				lightningMaterialMeshInternal.EnableKeyword("ORTHOGRAPHIC_XY");
				lightningMaterialMeshNoGlowInternal.EnableKeyword("ORTHOGRAPHIC_XY");
				lightningMaterialMeshInternal.DisableKeyword("ORTHOGRAPHIC_XZ");
				lightningMaterialMeshNoGlowInternal.DisableKeyword("ORTHOGRAPHIC_XZ");
				lightningMaterialMeshInternal.DisableKeyword("PERSPECTIVE");
				lightningMaterialMeshNoGlowInternal.DisableKeyword("PERSPECTIVE");
			}
		}

		private void SetMaterialOrthographicXZ()
		{
			if (calculatedCameraMode != CameraMode.OrthographicXZ)
			{
				calculatedCameraMode = CameraMode.OrthographicXZ;
				lightningMaterialMeshInternal.EnableKeyword("ORTHOGRAPHIC_XZ");
				lightningMaterialMeshNoGlowInternal.EnableKeyword("ORTHOGRAPHIC_XZ");
				lightningMaterialMeshInternal.DisableKeyword("ORTHOGRAPHIC_XY");
				lightningMaterialMeshNoGlowInternal.DisableKeyword("ORTHOGRAPHIC_XY");
				lightningMaterialMeshInternal.DisableKeyword("PERSPECTIVE");
				lightningMaterialMeshNoGlowInternal.DisableKeyword("PERSPECTIVE");
			}
		}

		private void SetupMaterialCamera()
		{
			if (Camera == null && CameraMode == CameraMode.Auto)
			{
				SetMaterialPerspective();
			}
			else if (CameraMode == CameraMode.Auto)
			{
				if (Camera.orthographic)
				{
					SetMaterialOrthographicXY();
				}
				else
				{
					SetMaterialPerspective();
				}
			}
			else if (CameraMode == CameraMode.Perspective)
			{
				SetMaterialPerspective();
			}
			else if (CameraMode == CameraMode.OrthographicXY)
			{
				SetMaterialOrthographicXY();
			}
			else
			{
				SetMaterialOrthographicXZ();
			}
		}

		private void EnableKeyword(string keyword, bool enable, Material m)
		{
			if (enable)
			{
				m.EnableKeyword(keyword);
			}
			else
			{
				m.DisableKeyword(keyword);
			}
		}

		private void UpdateShaderParameters()
		{
			lightningMaterialMeshInternal.SetColor(shaderId_TintColor, GlowTintColor);
			lightningMaterialMeshInternal.SetFloat(shaderId_JitterMultiplier, JitterMultiplier);
			lightningMaterialMeshInternal.SetFloat(shaderId_Turbulence, Turbulence * LightningBoltParameters.Scale);
			lightningMaterialMeshInternal.SetVector(shaderId_TurbulenceVelocity, TurbulenceVelocity * LightningBoltParameters.Scale);
			lightningMaterialMeshInternal.SetInt(shaderId_SrcBlendMode, (int)SourceBlendMode);
			lightningMaterialMeshInternal.SetInt(shaderId_DstBlendMode, (int)DestinationBlendMode);
			lightningMaterialMeshInternal.renderQueue = RenderQueue;
			lightningMaterialMeshInternal.SetFloat(shaderId_InvFade, SoftParticlesFactor);
			lightningMaterialMeshNoGlowInternal.SetColor(shaderId_TintColor, LightningTintColor);
			lightningMaterialMeshNoGlowInternal.SetFloat(shaderId_JitterMultiplier, JitterMultiplier);
			lightningMaterialMeshNoGlowInternal.SetFloat(shaderId_Turbulence, Turbulence * LightningBoltParameters.Scale);
			lightningMaterialMeshNoGlowInternal.SetVector(shaderId_TurbulenceVelocity, TurbulenceVelocity * LightningBoltParameters.Scale);
			lightningMaterialMeshNoGlowInternal.SetInt(shaderId_SrcBlendMode, (int)SourceBlendMode);
			lightningMaterialMeshNoGlowInternal.SetInt(shaderId_DstBlendMode, (int)DestinationBlendMode);
			lightningMaterialMeshNoGlowInternal.renderQueue = RenderQueue;
			lightningMaterialMeshNoGlowInternal.SetFloat(shaderId_InvFade, SoftParticlesFactor);
			if (IntensityFlicker != intensityFlickerDefault && IntensityFlickerTexture != null)
			{
				lightningMaterialMeshInternal.SetVector(shaderId_IntensityFlicker, IntensityFlicker);
				lightningMaterialMeshInternal.SetTexture(shaderId_IntensityFlickerTexture, IntensityFlickerTexture);
				lightningMaterialMeshNoGlowInternal.SetVector(shaderId_IntensityFlicker, IntensityFlicker);
				lightningMaterialMeshNoGlowInternal.SetTexture(shaderId_IntensityFlickerTexture, IntensityFlickerTexture);
				lightningMaterialMeshInternal.EnableKeyword("INTENSITY_FLICKER");
				lightningMaterialMeshNoGlowInternal.EnableKeyword("INTENSITY_FLICKER");
			}
			else
			{
				lightningMaterialMeshInternal.DisableKeyword("INTENSITY_FLICKER");
				lightningMaterialMeshNoGlowInternal.DisableKeyword("INTENSITY_FLICKER");
			}
			SetupMaterialCamera();
		}

		private void CheckCompensateForParentTransform()
		{
			if (CompensateForParentTransform)
			{
				Transform parent = base.transform.parent;
				if (parent != null)
				{
					base.transform.position = parent.position;
					base.transform.localScale = new Vector3(1f / parent.localScale.x, 1f / parent.localScale.y, 1f / parent.localScale.z);
					base.transform.rotation = parent.rotation;
				}
			}
		}

		private void UpdateCamera()
		{
			Camera = ((!(Camera == null)) ? Camera : ((Camera.current == null) ? Camera.main : Camera.current));
		}

		private LightningBolt GetOrCreateLightningBolt()
		{
			if (lightningBoltCache.Count == 0)
			{
				return new LightningBolt();
			}
			LightningBolt result = lightningBoltCache[lightningBoltCache.Count - 1];
			lightningBoltCache.RemoveAt(lightningBoltCache.Count - 1);
			return result;
		}

		private void UpdateActiveBolts()
		{
			for (int num = activeBolts.Count - 1; num >= 0; num--)
			{
				LightningBolt lightningBolt = activeBolts[num];
				if (!lightningBolt.Update())
				{
					activeBolts.RemoveAt(num);
					lightningBolt.Cleanup();
					lightningBoltCache.Add(lightningBolt);
				}
			}
		}

		private void OnApplicationQuit()
		{
			if (threadState != null)
			{
				threadState.Running = false;
			}
		}

		private void Cleanup()
		{
			foreach (LightningBolt activeBolt in activeBolts)
			{
				activeBolt.Cleanup();
			}
			activeBolts.Clear();
		}

		private void OnDestroy()
		{
			if (threadState != null)
			{
				threadState.TerminateAndWaitForEnd();
			}
			if (lightningMaterialMeshInternal != null)
			{
				UnityEngine.Object.Destroy(lightningMaterialMeshInternal);
			}
			if (lightningMaterialMeshNoGlowInternal != null)
			{
				UnityEngine.Object.Destroy(lightningMaterialMeshNoGlowInternal);
			}
			Cleanup();
		}

		private void OnDisable()
		{
			Cleanup();
		}
	}
	public class WaitForSecondsLightning : CustomYieldInstruction
	{
		private float remaining;

		public override bool keepWaiting
		{
			get
			{
				if (remaining <= 0f)
				{
					return false;
				}
				remaining -= LightningBoltScript.DeltaTime;
				return true;
			}
		}

		public WaitForSecondsLightning(float time)
		{
			remaining = time;
		}
	}
	public class LightningBoltShapeConeScript : LightningBoltPrefabScriptBase
	{
		[Header("Lightning Cone Properties")]
		[Tooltip("Radius at base of cone where lightning can emit from")]
		public float InnerRadius = 0.1f;

		[Tooltip("Radius at outer part of the cone where lightning emits to")]
		public float OuterRadius = 4f;

		[Tooltip("The length of the cone from the center of the inner and outer circle")]
		public float Length = 4f;

		public override void CreateLightningBolt(LightningBoltParameters parameters)
		{
			Vector2 vector = UnityEngine.Random.insideUnitCircle * InnerRadius;
			Vector3 start = base.transform.rotation * new Vector3(vector.x, vector.y, 0f);
			Vector2 vector2 = UnityEngine.Random.insideUnitCircle * OuterRadius;
			Vector3 end = base.transform.rotation * new Vector3(vector2.x, vector2.y, 0f) + base.transform.forward * Length;
			parameters.Start = start;
			parameters.End = end;
			base.CreateLightningBolt(parameters);
		}
	}
	public class LightningBoltShapeSphereScript : LightningBoltPrefabScriptBase
	{
		[Header("Lightning Sphere Properties")]
		[Tooltip("Radius inside the sphere where lightning can emit from")]
		public float InnerRadius = 0.1f;

		[Tooltip("Radius of the sphere")]
		public float Radius = 4f;

		public override void CreateLightningBolt(LightningBoltParameters parameters)
		{
			Vector3 start = UnityEngine.Random.insideUnitSphere * InnerRadius;
			Vector3 end = UnityEngine.Random.onUnitSphere * Radius;
			parameters.Start = start;
			parameters.End = end;
			base.CreateLightningBolt(parameters);
		}
	}
	public class LightningBoltTransformTrackerScript : MonoBehaviour
	{
		[Tooltip("The lightning script to track.")]
		public LightningBoltPrefabScript LightningScript;

		[Tooltip("The transform to track which will be where the bolts are emitted from.")]
		public Transform StartTarget;

		[Tooltip("(Optional) The transform to track which will be where the bolts are emitted to. If no end target is specified, lightning will simply move to stay on top of the start target.")]
		public Transform EndTarget;

		[SingleLine("Scaling limits.")]
		public RangeOfFloats ScaleLimit = new RangeOfFloats
		{
			Minimum = 0.1f,
			Maximum = 10f
		};

		private readonly Dictionary<Transform, LightningCustomTransformStateInfo> transformStartPositions = new Dictionary<Transform, LightningCustomTransformStateInfo>();

		private void Start()
		{
			if (LightningScript != null)
			{
				LightningScript.CustomTransformHandler.RemoveAllListeners();
				LightningScript.CustomTransformHandler.AddListener(CustomTransformHandler);
			}
		}

		private static float AngleBetweenVector2(Vector2 vec1, Vector2 vec2)
		{
			Vector2 normalized = (vec2 - vec1).normalized;
			return Vector2.Angle(Vector2.right, normalized) * Mathf.Sign(vec2.y - vec1.y);
		}

		private static void UpdateTransform(LightningCustomTransformStateInfo state, LightningBoltPrefabScript script, RangeOfFloats scaleLimit)
		{
			if (state.Transform == null || state.StartTransform == null)
			{
				return;
			}
			if (state.EndTransform == null)
			{
				state.Transform.position = state.StartTransform.position - state.BoltStartPosition;
				return;
			}
			Quaternion quaternion;
			if ((script.CameraMode == CameraMode.Auto && script.Camera.orthographic) || script.CameraMode == CameraMode.OrthographicXY)
			{
				float num = AngleBetweenVector2(state.BoltStartPosition, state.BoltEndPosition);
				quaternion = Quaternion.AngleAxis(AngleBetweenVector2(state.StartTransform.position, state.EndTransform.position) - num, Vector3.forward);
			}
			if (script.CameraMode == CameraMode.OrthographicXZ)
			{
				float num2 = AngleBetweenVector2(new Vector2(state.BoltStartPosition.x, state.BoltStartPosition.z), new Vector2(state.BoltEndPosition.x, state.BoltEndPosition.z));
				quaternion = Quaternion.AngleAxis(AngleBetweenVector2(new Vector2(state.StartTransform.position.x, state.StartTransform.position.z), new Vector2(state.EndTransform.position.x, state.EndTransform.position.z)) - num2, Vector3.up);
			}
			else
			{
				Quaternion rotation = Quaternion.LookRotation((state.BoltEndPosition - state.BoltStartPosition).normalized);
				quaternion = Quaternion.LookRotation((state.EndTransform.position - state.StartTransform.position).normalized) * Quaternion.Inverse(rotation);
			}
			state.Transform.rotation = quaternion;
			float num3 = Vector3.Distance(state.BoltStartPosition, state.BoltEndPosition);
			float num4 = Vector3.Distance(state.EndTransform.position, state.StartTransform.position);
			float num5 = Mathf.Clamp((num3 < Mathf.Epsilon) ? 1f : (num4 / num3), scaleLimit.Minimum, scaleLimit.Maximum);
			state.Transform.localScale = new Vector3(num5, num5, num5);
			Vector3 vector = quaternion * (num5 * state.BoltStartPosition);
			state.Transform.position = state.StartTransform.position - vector;
		}

		public void CustomTransformHandler(LightningCustomTransformStateInfo state)
		{
			if (base.enabled)
			{
				if (LightningScript == null)
				{
					UnityEngine.Debug.LogError("LightningScript property must be set to non-null.");
				}
				else if (state.State == LightningCustomTransformState.Executing)
				{
					UpdateTransform(state, LightningScript, ScaleLimit);
				}
				else if (state.State == LightningCustomTransformState.Started)
				{
					state.StartTransform = StartTarget;
					state.EndTransform = EndTarget;
					transformStartPositions[base.transform] = state;
				}
				else
				{
					transformStartPositions.Remove(base.transform);
				}
			}
		}
	}
	[Serializable]
	public struct RangeOfIntegers
	{
		[Tooltip("Minimum value (inclusive)")]
		public int Minimum;

		[Tooltip("Maximum value (inclusive)")]
		public int Maximum;

		public int Random()
		{
			return UnityEngine.Random.Range(Minimum, Maximum + 1);
		}

		public int Random(System.Random r)
		{
			return r.Next(Minimum, Maximum + 1);
		}
	}
	[Serializable]
	public struct RangeOfFloats
	{
		[Tooltip("Minimum value (inclusive)")]
		public float Minimum;

		[Tooltip("Maximum value (inclusive)")]
		public float Maximum;

		public float Random()
		{
			return UnityEngine.Random.Range(Minimum, Maximum);
		}

		public float Random(System.Random r)
		{
			return Minimum + (float)r.NextDouble() * (Maximum - Minimum);
		}
	}
	public class SingleLineAttribute : PropertyAttribute
	{
		public string Tooltip { get; private set; }

		public SingleLineAttribute(string tooltip)
		{
			Tooltip = tooltip;
		}
	}
	public class SingleLineClampAttribute : SingleLineAttribute
	{
		public double MinValue { get; private set; }

		public double MaxValue { get; private set; }

		public SingleLineClampAttribute(string tooltip, double minValue, double maxValue)
			: base(tooltip)
		{
			MinValue = minValue;
			MaxValue = maxValue;
		}
	}
	public class LightningFieldScript : LightningBoltPrefabScriptBase
	{
		[Header("Lightning Field Properties")]
		[Tooltip("The minimum length for a field segment")]
		public float MinimumLength = 0.01f;

		private float minimumLengthSquared;

		[Tooltip("The bounds to put the field in.")]
		public Bounds FieldBounds;

		[Tooltip("Optional light for the lightning field to emit")]
		public Light Light;

		private Vector3 RandomPointInBounds()
		{
			float x = UnityEngine.Random.Range(FieldBounds.min.x, FieldBounds.max.x);
			float y = UnityEngine.Random.Range(FieldBounds.min.y, FieldBounds.max.y);
			float z = UnityEngine.Random.Range(FieldBounds.min.z, FieldBounds.max.z);
			return new Vector3(x, y, z);
		}

		protected override void Start()
		{
			base.Start();
			if (Light != null)
			{
				Light.enabled = false;
			}
		}

		protected override void Update()
		{
			base.Update();
			if (Light != null)
			{
				Light.transform.position = FieldBounds.center;
				Light.intensity = UnityEngine.Random.Range(2.8f, 3.2f);
			}
		}

		public override void CreateLightningBolt(LightningBoltParameters parameters)
		{
			minimumLengthSquared = MinimumLength * MinimumLength;
			for (int i = 0; i < 16; i++)
			{
				parameters.Start = RandomPointInBounds();
				parameters.End = RandomPointInBounds();
				if ((parameters.End - parameters.Start).sqrMagnitude >= minimumLengthSquared)
				{
					break;
				}
			}
			if (Light != null)
			{
				Light.enabled = true;
			}
			base.CreateLightningBolt(parameters);
		}
	}
	public class LightningGenerator
	{
		public static readonly LightningGenerator GeneratorInstance = new LightningGenerator();

		private void GetPerpendicularVector(ref Vector3 directionNormalized, out Vector3 side)
		{
			if (directionNormalized == Vector3.zero)
			{
				side = Vector3.right;
				return;
			}
			float x = directionNormalized.x;
			float y = directionNormalized.y;
			float z = directionNormalized.z;
			float num = Mathf.Abs(x);
			float num2 = Mathf.Abs(y);
			float num3 = Mathf.Abs(z);
			float num4;
			float num5;
			float num6;
			if (num >= num2 && num2 >= num3)
			{
				num4 = 1f;
				num5 = 1f;
				num6 = (0f - (y * num4 + z * num5)) / x;
			}
			else if (num2 >= num3)
			{
				num6 = 1f;
				num5 = 1f;
				num4 = (0f - (x * num6 + z * num5)) / y;
			}
			else
			{
				num6 = 1f;
				num4 = 1f;
				num5 = (0f - (x * num6 + y * num4)) / z;
			}
			side = new Vector3(num6, num4, num5).normalized;
		}

		protected virtual void OnGenerateLightningBolt(LightningBolt bolt, Vector3 start, Vector3 end, LightningBoltParameters parameters)
		{
			GenerateLightningBoltStandard(bolt, start, end, parameters.Generations, parameters.Generations, 0f, parameters);
		}

		public bool ShouldCreateFork(LightningBoltParameters parameters, int generation, int totalGenerations)
		{
			if (generation > parameters.generationWhereForksStop && generation >= totalGenerations - parameters.forkednessCalculated)
			{
				return (float)parameters.Random.NextDouble() < parameters.Forkedness;
			}
			return false;
		}

		public void CreateFork(LightningBolt bolt, LightningBoltParameters parameters, int generation, int totalGenerations, Vector3 start, Vector3 midPoint)
		{
			if (ShouldCreateFork(parameters, generation, totalGenerations))
			{
				Vector3 vector = (midPoint - start) * parameters.ForkMultiplier();
				Vector3 end = midPoint + vector;
				GenerateLightningBoltStandard(bolt, midPoint, end, generation, totalGenerations, 0f, parameters);
			}
		}

		public void GenerateLightningBoltStandard(LightningBolt bolt, Vector3 start, Vector3 end, int generation, int totalGenerations, float offsetAmount, LightningBoltParameters parameters)
		{
			if (generation < 1)
			{
				return;
			}
			LightningBoltSegmentGroup lightningBoltSegmentGroup = bolt.AddGroup();
			lightningBoltSegmentGroup.Segments.Add(new LightningBoltSegment
			{
				Start = start,
				End = end
			});
			float num = (float)generation / (float)totalGenerations;
			num *= num;
			lightningBoltSegmentGroup.LineWidth = parameters.TrunkWidth * num;
			lightningBoltSegmentGroup.Generation = generation;
			lightningBoltSegmentGroup.Color = parameters.Color;
			lightningBoltSegmentGroup.Color.a = (byte)(255f * num);
			lightningBoltSegmentGroup.EndWidthMultiplier = parameters.EndWidthMultiplier * parameters.ForkEndWidthMultiplier;
			if (offsetAmount <= 0f)
			{
				offsetAmount = (end - start).magnitude * ((generation == totalGenerations) ? parameters.ChaosFactor : parameters.ChaosFactorForks);
			}
			while (generation-- > 0)
			{
				int startIndex = lightningBoltSegmentGroup.StartIndex;
				lightningBoltSegmentGroup.StartIndex = lightningBoltSegmentGroup.Segments.Count;
				for (int i = startIndex; i < lightningBoltSegmentGroup.StartIndex; i++)
				{
					start = lightningBoltSegmentGroup.Segments[i].Start;
					end = lightningBoltSegmentGroup.Segments[i].End;
					Vector3 vector = (start + end) * 0.5f;
					RandomVector(bolt, ref start, ref end, offsetAmount, parameters.Random, out var result);
					vector += result;
					lightningBoltSegmentGroup.Segments.Add(new LightningBoltSegment
					{
						Start = start,
						End = vector
					});
					lightningBoltSegmentGroup.Segments.Add(new LightningBoltSegment
					{
						Start = vector,
						End = end
					});
					CreateFork(bolt, parameters, generation, totalGenerations, start, vector);
				}
				offsetAmount *= 0.5f;
			}
		}

		public Vector3 RandomDirection3D(System.Random random)
		{
			float num = 2f * (float)random.NextDouble() - 1f;
			Vector3 result = RandomDirection2D(random) * Mathf.Sqrt(1f - num * num);
			result.z = num;
			return result;
		}

		public Vector3 RandomDirection2D(System.Random random)
		{
			float f = (float)random.NextDouble() * 2f * (float)Math.PI;
			return new Vector3(Mathf.Cos(f), Mathf.Sin(f), 0f);
		}

		public Vector3 RandomDirection2DXZ(System.Random random)
		{
			float f = (float)random.NextDouble() * 2f * (float)Math.PI;
			return new Vector3(Mathf.Cos(f), 0f, Mathf.Sin(f));
		}

		public void RandomVector(LightningBolt bolt, ref Vector3 start, ref Vector3 end, float offsetAmount, System.Random random, out Vector3 result)
		{
			if (bolt.CameraMode == CameraMode.Perspective)
			{
				Vector3 directionNormalized = (end - start).normalized;
				Vector3 side = Vector3.Cross(start, end);
				if (side == Vector3.zero)
				{
					GetPerpendicularVector(ref directionNormalized, out side);
				}
				else
				{
					side.Normalize();
				}
				float num = ((float)random.NextDouble() + 0.1f) * offsetAmount;
				float num2 = (float)random.NextDouble() * (float)Math.PI;
				directionNormalized *= (float)Math.Sin(num2);
				Quaternion quaternion = default(Quaternion);
				quaternion.x = directionNormalized.x;
				quaternion.y = directionNormalized.y;
				quaternion.z = directionNormalized.z;
				quaternion.w = (float)Math.Cos(num2);
				result = quaternion * side * num;
			}
			else if (bolt.CameraMode == CameraMode.OrthographicXY)
			{
				end.z = start.z;
				Vector3 normalized = (end - start).normalized;
				Vector3 vector = new Vector3(0f - normalized.y, normalized.x, 0f);
				float num3 = (float)random.NextDouble() * offsetAmount * 2f - offsetAmount;
				result = vector * num3;
			}
			else
			{
				end.y = start.y;
				Vector3 normalized2 = (end - start).normalized;
				Vector3 vector2 = new Vector3(0f - normalized2.z, 0f, normalized2.x);
				float num4 = (float)random.NextDouble() * offsetAmount * 2f - offsetAmount;
				result = vector2 * num4;
			}
		}

		public void GenerateLightningBolt(LightningBolt bolt, LightningBoltParameters parameters)
		{
			GenerateLightningBolt(bolt, parameters, out var _, out var _);
		}

		public void GenerateLightningBolt(LightningBolt bolt, LightningBoltParameters parameters, out Vector3 start, out Vector3 end)
		{
			start = parameters.ApplyVariance(parameters.Start, parameters.StartVariance);
			end = parameters.ApplyVariance(parameters.End, parameters.EndVariance);
			OnGenerateLightningBolt(bolt, start, end, parameters);
		}
	}
	public class LightningGeneratorPath : LightningGenerator
	{
		public static readonly LightningGeneratorPath PathGeneratorInstance = new LightningGeneratorPath();

		public void GenerateLightningBoltPath(LightningBolt bolt, Vector3 start, Vector3 end, LightningBoltParameters parameters)
		{
			if (parameters.Points.Count < 2)
			{
				UnityEngine.Debug.LogError("Lightning path should have at least two points");
				return;
			}
			int generations = parameters.Generations;
			int totalGenerations = generations;
			float num = ((generations == parameters.Generations) ? parameters.ChaosFactor : parameters.ChaosFactorForks);
			int num2 = parameters.SmoothingFactor - 1;
			LightningBoltSegmentGroup lightningBoltSegmentGroup = bolt.AddGroup();
			lightningBoltSegmentGroup.LineWidth = parameters.TrunkWidth;
			lightningBoltSegmentGroup.Generation = generations--;
			lightningBoltSegmentGroup.EndWidthMultiplier = parameters.EndWidthMultiplier;
			lightningBoltSegmentGroup.Color = parameters.Color;
			parameters.Start = parameters.Points[0] + start;
			parameters.End = parameters.Points[parameters.Points.Count - 1] + end;
			end = parameters.Start;
			for (int i = 1; i < parameters.Points.Count; i++)
			{
				start = end;
				end = parameters.Points[i];
				Vector3 vector = end - start;
				float num3 = PathGenerator.SquareRoot(vector.sqrMagnitude);
				if (num > 0f)
				{
					if (bolt.CameraMode == CameraMode.Perspective)
					{
						end += num3 * num * RandomDirection3D(parameters.Random);
					}
					else if (bolt.CameraMode == CameraMode.OrthographicXY)
					{
						end += num3 * num * RandomDirection2D(parameters.Random);
					}
					else
					{
						end += num3 * num * RandomDirection2DXZ(parameters.Random);
					}
					vector = end - start;
				}
				lightningBoltSegmentGroup.Segments.Add(new LightningBoltSegment
				{
					Start = start,
					End = end
				});
				float offsetAmount = num3 * num;
				RandomVector(bolt, ref start, ref end, offsetAmount, parameters.Random, out var result);
				if (ShouldCreateFork(parameters, generations, totalGenerations))
				{
					Vector3 vector2 = vector * parameters.ForkMultiplier() * num2 * 0.5f;
					Vector3 end2 = end + vector2 + result;
					GenerateLightningBoltStandard(bolt, start, end2, generations, totalGenerations, 0f, parameters);
				}
				if (--num2 == 0)
				{
					num2 = parameters.SmoothingFactor - 1;
				}
			}
		}

		protected override void OnGenerateLightningBolt(LightningBolt bolt, Vector3 start, Vector3 end, LightningBoltParameters parameters)
		{
			GenerateLightningBoltPath(bolt, start, end, parameters);
		}
	}
	public class LightningGizmoScript : MonoBehaviour
	{
	}
	public class LightningLightsabreScript : LightningBoltPrefabScript
	{
		[Header("Lightsabre Properties")]
		[Tooltip("Height of the blade")]
		public float BladeHeight = 19f;

		[Tooltip("How long it takes to turn the lightsabre on and off")]
		public float ActivationTime = 0.5f;

		[Tooltip("Sound to play when the lightsabre turns on")]
		public AudioSource StartSound;

		[Tooltip("Sound to play when the lightsabre turns off")]
		public AudioSource StopSound;

		[Tooltip("Sound to play when the lightsabre stays on")]
		public AudioSource ConstantSound;

		private int state;

		private Vector3 bladeStart;

		private Vector3 bladeDir;

		private float bladeTime;

		private float bladeIntensity;

		protected override void Start()
		{
			base.Start();
		}

		protected override void Update()
		{
			if (state == 2 || state == 3)
			{
				bladeTime += LightningBoltScript.DeltaTime;
				float num = Mathf.Lerp(0.01f, 1f, bladeTime / ActivationTime);
				Vector3 position = bladeStart + bladeDir * num * BladeHeight;
				Destination.transform.position = position;
				GlowIntensity = bladeIntensity * ((state == 3) ? num : (1f - num));
				if (bladeTime >= ActivationTime)
				{
					GlowIntensity = bladeIntensity;
					bladeTime = 0f;
					if (state == 2)
					{
						ManualMode = true;
						state = 0;
					}
					else
					{
						state = 1;
					}
				}
			}
			base.Update();
		}

		public bool TurnOn(bool value)
		{
			if (state == 2 || state == 3 || (state == 1 && value) || (state == 0 && !value))
			{
				return false;
			}
			bladeStart = Destination.transform.position;
			ManualMode = false;
			bladeIntensity = GlowIntensity;
			if (value)
			{
				bladeDir = (Camera.orthographic ? base.transform.up : base.transform.forward);
				state = 3;
				StartSound.Play();
				StopSound.Stop();
				ConstantSound.Play();
			}
			else
			{
				bladeDir = -(Camera.orthographic ? base.transform.up : base.transform.forward);
				state = 2;
				StartSound.Stop();
				StopSound.Play();
				ConstantSound.Stop();
			}
			return true;
		}

		public void TurnOnGUI(bool value)
		{
			TurnOn(value);
		}
	}
	public class LightningMeshSurfaceScript : LightningBoltPrefabScriptBase
	{
		[Header("Lightning Mesh Properties")]
		[Tooltip("The mesh filter. You must assign a mesh filter in order to create lightning on the mesh.")]
		public MeshFilter MeshFilter;

		[Tooltip("The mesh collider. This is used to get random points on the mesh.")]
		public Collider MeshCollider;

		[SingleLine("Random range that the point will offset from the mesh, using the normal of the chosen point to offset")]
		public RangeOfFloats MeshOffsetRange = new RangeOfFloats
		{
			Minimum = 0.5f,
			Maximum = 1f
		};

		[Header("Lightning Path Properties")]
		[SingleLine("Range for points in the lightning path")]
		public RangeOfIntegers PathLengthCount = new RangeOfIntegers
		{
			Minimum = 3,
			Maximum = 6
		};

		[SingleLine("Range for minimum distance between points in the lightning path")]
		public RangeOfFloats MinimumPathDistanceRange = new RangeOfFloats
		{
			Minimum = 0.5f,
			Maximum = 1f
		};

		[Tooltip("The maximum distance between mesh points. When walking the mesh, if a point is greater than this, the path direction is reversed. This tries to avoid paths crossing between mesh points that are not actually physically touching.")]
		public float MaximumPathDistance = 2f;

		private float maximumPathDistanceSquared;

		[Tooltip("Whether to use spline interpolation between the path points. Paths must be at least 4 points long to be splined.")]
		public bool Spline;

		[Tooltip("For spline. the distance hint for each spline segment. Set to <= 0 to use the generations to determine how many spline segments to use. If > 0, it will be divided by Generations before being applied. This value is a guideline and is approximate, and not uniform on the spline.")]
		public float DistancePerSegmentHint;

		private readonly List<Vector3> sourcePoints = new List<Vector3>();

		private Mesh previousMesh;

		private MeshHelper meshHelper;

		private void CheckMesh()
		{
			if (MeshFilter == null || MeshFilter.sharedMesh == null)
			{
				meshHelper = null;
			}
			else if (MeshFilter.sharedMesh != previousMesh)
			{
				previousMesh = MeshFilter.sharedMesh;
				meshHelper = new MeshHelper(previousMesh);
			}
		}

		protected override LightningBoltParameters OnCreateParameters()
		{
			LightningBoltParameters lightningBoltParameters = base.OnCreateParameters();
			lightningBoltParameters.Generator = LightningGeneratorPath.PathGeneratorInstance;
			return lightningBoltParameters;
		}

		protected virtual void PopulateSourcePoints(List<Vector3> points)
		{
			if (meshHelper != null)
			{
				CreateRandomLightningPath(sourcePoints);
			}
		}

		public void CreateRandomLightningPath(List<Vector3> points)
		{
			if (meshHelper == null)
			{
				return;
			}
			RaycastHit hit = default(RaycastHit);
			maximumPathDistanceSquared = MaximumPathDistance * MaximumPathDistance;
			meshHelper.GenerateRandomPoint(ref hit, out var triangleIndex);
			hit.distance = UnityEngine.Random.Range(MeshOffsetRange.Minimum, MeshOffsetRange.Maximum);
			Vector3 vector = hit.point + hit.normal * hit.distance;
			float num = UnityEngine.Random.Range(MinimumPathDistanceRange.Minimum, MinimumPathDistanceRange.Maximum);
			num *= num;
			sourcePoints.Add(MeshFilter.transform.TransformPoint(vector));
			int num2 = ((UnityEngine.Random.Range(0, 1) == 1) ? 3 : (-3));
			int num3 = UnityEngine.Random.Range(PathLengthCount.Minimum, PathLengthCount.Maximum);
			while (num3 != 0)
			{
				triangleIndex += num2;
				if (triangleIndex >= 0 && triangleIndex < meshHelper.Triangles.Length)
				{
					meshHelper.GetRaycastFromTriangleIndex(triangleIndex, ref hit);
					hit.distance = UnityEngine.Random.Range(MeshOffsetRange.Minimum, MeshOffsetRange.Maximum);
					Vector3 vector2 = hit.point + hit.normal * hit.distance;
					float sqrMagnitude = (vector2 - vector).sqrMagnitude;
					if (sqrMagnitude > maximumPathDistanceSquared)
					{
						break;
					}
					if (sqrMagnitude >= num)
					{
						vector = vector2;
						sourcePoints.Add(MeshFilter.transform.TransformPoint(vector2));
						num3--;
						num = UnityEngine.Random.Range(MinimumPathDistanceRange.Minimum, MinimumPathDistanceRange.Maximum);
						num *= num;
					}
				}
				else
				{
					num2 = -num2;
					triangleIndex += num2;
					num3--;
				}
			}
		}

		protected override void Start()
		{
			base.Start();
		}

		protected override void Update()
		{
			CheckMesh();
			base.Update();
		}

		public override void CreateLightningBolt(LightningBoltParameters parameters)
		{
			if (meshHelper == null)
			{
				return;
			}
			int generations = (parameters.Generations = Mathf.Clamp(Generations, 1, 5));
			Generations = generations;
			sourcePoints.Clear();
			PopulateSourcePoints(sourcePoints);
			if (sourcePoints.Count > 1)
			{
				parameters.Points.Clear();
				if (Spline && sourcePoints.Count > 3)
				{
					LightningSplineScript.PopulateSpline(parameters.Points, sourcePoints, Generations, DistancePerSegmentHint, Camera);
					parameters.SmoothingFactor = (parameters.Points.Count - 1) / sourcePoints.Count;
				}
				else
				{
					parameters.Points.AddRange(sourcePoints);
					parameters.SmoothingFactor = 1;
				}
				base.CreateLightningBolt(parameters);
			}
		}
	}
	public class LightningSplineScript : LightningBoltPathScriptBase
	{
		public const int MaxSplineGenerations = 5;

		[Header("Lightning Spline Properties")]
		[Tooltip("The distance hint for each spline segment. Set to <= 0 to use the generations to determine how many spline segments to use. If > 0, it will be divided by Generations before being applied. This value is a guideline and is approximate, and not uniform on the spline.")]
		public float DistancePerSegmentHint;

		private readonly List<Vector3> prevSourcePoints = new List<Vector3>(new Vector3[1] { Vector3.zero });

		private readonly List<Vector3> sourcePoints = new List<Vector3>();

		private List<Vector3> savedSplinePoints = new List<Vector3>();

		private int previousGenerations = -1;

		private float previousDistancePerSegment = -1f;

		private bool SourceChanged()
		{
			if (sourcePoints.Count != prevSourcePoints.Count)
			{
				return true;
			}
			for (int i = 0; i < sourcePoints.Count; i++)
			{
				if (sourcePoints[i] != prevSourcePoints[i])
				{
					return true;
				}
			}
			return false;
		}

		protected override void Start()
		{
			base.Start();
		}

		protected override void Update()
		{
			base.Update();
		}

		public override void CreateLightningBolt(LightningBoltParameters parameters)
		{
			if (LightningPath == null)
			{
				return;
			}
			sourcePoints.Clear();
			try
			{
				foreach (GameObject item in LightningPath)
				{
					if (item != null)
					{
						sourcePoints.Add(item.transform.position);
					}
				}
			}
			catch (NullReferenceException)
			{
				return;
			}
			if (sourcePoints.Count < 4)
			{
				UnityEngine.Debug.LogError("To create spline lightning, you need a lightning path with at least " + 4 + " points.");
				return;
			}
			int generations = (parameters.Generations = Mathf.Clamp(Generations, 1, 5));
			Generations = generations;
			parameters.Points.Clear();
			if (previousGenerations != Generations || previousDistancePerSegment != DistancePerSegmentHint || SourceChanged())
			{
				previousGenerations = Generations;
				previousDistancePerSegment = DistancePerSegmentHint;
				PopulateSpline(parameters.Points, sourcePoints, Generations, DistancePerSegmentHint, Camera);
				prevSourcePoints.Clear();
				prevSourcePoints.AddRange(sourcePoints);
				savedSplinePoints.Clear();
				savedSplinePoints.AddRange(parameters.Points);
			}
			else
			{
				parameters.Points.AddRange(savedSplinePoints);
			}
			parameters.SmoothingFactor = (parameters.Points.Count - 1) / sourcePoints.Count;
			base.CreateLightningBolt(parameters);
		}

		protected override LightningBoltParameters OnCreateParameters()
		{
			LightningBoltParameters orCreateParameters = LightningBoltParameters.GetOrCreateParameters();
			orCreateParameters.Generator = LightningGeneratorPath.PathGeneratorInstance;
			return orCreateParameters;
		}

		public void Trigger(List<Vector3> points, bool spline)
		{
			if (points.Count >= 2)
			{
				Generations = Mathf.Clamp(Generations, 1, 5);
				LightningBoltParameters lightningBoltParameters = CreateParameters();
				lightningBoltParameters.Points.Clear();
				if (spline && points.Count > 3)
				{
					PopulateSpline(lightningBoltParameters.Points, points, Generations, DistancePerSegmentHint, Camera);
					lightningBoltParameters.SmoothingFactor = (lightningBoltParameters.Points.Count - 1) / points.Count;
				}
				else
				{
					lightningBoltParameters.Points.AddRange(points);
					lightningBoltParameters.SmoothingFactor = 1;
				}
				base.CreateLightningBolt(lightningBoltParameters);
				CreateLightningBoltsNow();
			}
		}

		public static void PopulateSpline(List<Vector3> splinePoints, List<Vector3> sourcePoints, int generations, float distancePerSegmentHit, Camera camera)
		{
			splinePoints.Clear();
			PathGenerator.Is2D = camera != null && camera.orthographic;
			if (distancePerSegmentHit > 0f)
			{
				PathGenerator.CreateSplineWithSegmentDistance(splinePoints, sourcePoints, distancePerSegmentHit / (float)generations, closePath: false);
			}
			else
			{
				PathGenerator.CreateSpline(splinePoints, sourcePoints, sourcePoints.Count * generations * generations, closePath: false);
			}
		}
	}
	[RequireComponent(typeof(AudioSource))]
	public class LightningWhipScript : MonoBehaviour
	{
		public AudioClip WhipCrack;

		public AudioClip WhipCrackThunder;

		private AudioSource audioSource;

		private GameObject whipStart;

		private GameObject whipEndStrike;

		private GameObject whipHandle;

		private GameObject whipSpring;

		private Vector2 prevDrag;

		private bool dragging;

		private bool canWhip = true;

		private IEnumerator WhipForward()
		{
			if (!canWhip)
			{
				yield break;
			}
			canWhip = false;
			for (int i = 0; i < whipStart.transform.childCount; i++)
			{
				Rigidbody2D component = whipStart.transform.GetChild(i).gameObject.GetComponent<Rigidbody2D>();
				if (component != null)
				{
					component.drag = 0f;
				}
			}
			audioSource.PlayOneShot(WhipCrack);
			whipSpring.GetComponent<SpringJoint2D>().enabled = true;
			whipSpring.GetComponent<Rigidbody2D>().position = whipHandle.GetComponent<Rigidbody2D>().position + new Vector2(-15f, 5f);
			yield return new WaitForSecondsLightning(0.2f);
			whipSpring.GetComponent<Rigidbody2D>().position = whipHandle.GetComponent<Rigidbody2D>().position + new Vector2(15f, 2.5f);
			yield return new WaitForSecondsLightning(0.15f);
			audioSource.PlayOneShot(WhipCrackThunder, 0.5f);
			yield return new WaitForSecondsLightning(0.15f);
			whipEndStrike.GetComponent<ParticleSystem>().Play();
			whipSpring.GetComponent<SpringJoint2D>().enabled = false;
			yield return new WaitForSecondsLightning(0.65f);
			for (int j = 0; j < whipStart.transform.childCount; j++)
			{
				Rigidbody2D component2 = whipStart.transform.GetChild(j).gameObject.GetComponent<Rigidbody2D>();
				if (component2 != null)
				{
					component2.velocity = Vector2.zero;
					component2.drag = 0.5f;
				}
			}
			canWhip = true;
		}

		private void Start()
		{
			whipStart = GameObject.Find("WhipStart");
			whipEndStrike = GameObject.Find("WhipEndStrike");
			whipHandle = GameObject.Find("WhipHandle");
			whipSpring = GameObject.Find("WhipSpring");
			audioSource = GetComponent<AudioSource>();
		}

		private void Update()
		{
			if (!dragging && Input.GetMouseButtonDown(0))
			{
				Vector2 point = Camera.main.ScreenToWorldPoint(Input.mousePosition);
				Collider2D collider2D = Physics2D.OverlapPoint(point);
				if (collider2D != null && collider2D.gameObject == whipHandle)
				{
					dragging = true;
					prevDrag = point;
				}
			}
			else if (dragging && Input.GetMouseButton(0))
			{
				Vector2 vector = Camera.main.ScreenToWorldPoint(Input.mousePosition);
				Vector2 vector2 = vector - prevDrag;
				Rigidbody2D component = whipHandle.GetComponent<Rigidbody2D>();
				component.MovePosition(component.position + vector2);
				prevDrag = vector;
			}
			else
			{
				dragging = false;
			}
			if (Input.GetKeyDown(KeyCode.Space))
			{
				StartCoroutine(WhipForward());
			}
		}
	}
	public class MeshHelper
	{
		private Mesh mesh;

		private int[] triangles;

		private Vector3[] vertices;

		private Vector3[] normals;

		private float[] normalizedAreaWeights;

		public Mesh Mesh => mesh;

		public int[] Triangles => triangles;

		public Vector3[] Vertices => vertices;

		public Vector3[] Normals => normals;

		public MeshHelper(Mesh mesh)
		{
			this.mesh = mesh;
			triangles = mesh.triangles;
			vertices = mesh.vertices;
			normals = mesh.normals;
			CalculateNormalizedAreaWeights();
		}

		public void GenerateRandomPoint(ref RaycastHit hit, out int triangleIndex)
		{
			triangleIndex = SelectRandomTriangle();
			GetRaycastFromTriangleIndex(triangleIndex, ref hit);
		}

		public void GetRaycastFromTriangleIndex(int triangleIndex, ref RaycastHit hit)
		{
			Vector3 barycentricCoordinate = GenerateRandomBarycentricCoordinates();
			Vector3 vector = vertices[triangles[triangleIndex]];
			Vector3 vector2 = vertices[triangles[triangleIndex + 1]];
			Vector3 vector3 = vertices[triangles[triangleIndex + 2]];
			hit.barycentricCoordinate = barycentricCoordinate;
			hit.point = vector * barycentricCoordinate.x + vector2 * barycentricCoordinate.y + vector3 * barycentricCoordinate.z;
			if (normals == null)
			{
				hit.normal = Vector3.Cross(vector3 - vector2, vector - vector2).normalized;
				return;
			}
			vector = normals[triangles[triangleIndex]];
			vector2 = normals[triangles[triangleIndex + 1]];
			vector3 = normals[triangles[triangleIndex + 2]];
			hit.normal = vector * barycentricCoordinate.x + vector2 * barycentricCoordinate.y + vector3 * barycentricCoordinate.z;
		}

		private float[] CalculateSurfaceAreas(out float totalSurfaceArea)
		{
			int num = 0;
			totalSurfaceArea = 0f;
			float[] array = new float[triangles.Length / 3];
			for (int i = 0; i < triangles.Length; i += 3)
			{
				Vector3 vector = vertices[triangles[i]];
				Vector3 vector2 = vertices[triangles[i + 1]];
				Vector3 vector3 = vertices[triangles[i + 2]];
				float sqrMagnitude = (vector - vector2).sqrMagnitude;
				float sqrMagnitude2 = (vector - vector3).sqrMagnitude;
				float sqrMagnitude3 = (vector2 - vector3).sqrMagnitude;
				float num2 = PathGenerator.SquareRoot((2f * sqrMagnitude * sqrMagnitude2 + 2f * sqrMagnitude2 * sqrMagnitude3 + 2f * sqrMagnitude3 * sqrMagnitude - sqrMagnitude * sqrMagnitude - sqrMagnitude2 * sqrMagnitude2 - sqrMagnitude3 * sqrMagnitude3) / 16f);
				array[num++] = num2;
				totalSurfaceArea += num2;
			}
			return array;
		}

		private void CalculateNormalizedAreaWeights()
		{
			normalizedAreaWeights = CalculateSurfaceAreas(out var totalSurfaceArea);
			if (normalizedAreaWeights.Length != 0)
			{
				float num = 0f;
				for (int i = 0; i < normalizedAreaWeights.Length; i++)
				{
					float num2 = normalizedAreaWeights[i] / totalSurfaceArea;
					normalizedAreaWeights[i] = num;
					num += num2;
				}
			}
		}

		private int SelectRandomTriangle()
		{
			float value = UnityEngine.Random.value;
			int num = 0;
			int num2 = normalizedAreaWeights.Length - 1;
			while (num < num2)
			{
				int num3 = (num + num2) / 2;
				if (normalizedAreaWeights[num3] < value)
				{
					num = num3 + 1;
				}
				else
				{
					num2 = num3;
				}
			}
			return num * 3;
		}

		private Vector3 GenerateRandomBarycentricCoordinates()
		{
			Vector3 vector = new Vector3(UnityEngine.Random.Range(Mathf.Epsilon, 1f), UnityEngine.Random.Range(Mathf.Epsilon, 1f), UnityEngine.Random.Range(Mathf.Epsilon, 1f));
			return vector / (vector.x + vector.y + vector.z);
		}
	}
	public static class PathGenerator
	{
		public const int MinPointsForSpline = 4;

		public static bool Is2D;

		private const float curveMultiplier = 3f;

		private const float splineMultiplier1 = -3f;

		private const float splineMultiplier2 = 3f;

		private const float splineMultiplier3 = 2f;

		private const float splineDistanceClamp = 1f;

		private const float splineEpsilon = 0.0001f;

		public static float SquareRoot(float x)
		{
			return (float)Math.Sqrt(x);
		}

		private static float Distance2D(ref Vector3 point1, ref Vector3 point2)
		{
			float num = point2.x - point1.x;
			float num2 = point2.y - point1.y;
			return SquareRoot(num * num + num2 * num2);
		}

		private static float Distance3D(ref Vector3 point1, ref Vector3 point2)
		{
			float num = point2.x - point1.x;
			float num2 = point2.y - point1.y;
			float num3 = point2.z - point1.z;
			return SquareRoot(num * num + num2 * num2 + num3 * num3);
		}

		private static void GetCurvePoint2D(ref Vector3 start, ref Vector3 end, ref Vector3 ctr1, ref Vector3 ctr2, float t, out Vector3 point)
		{
			float num = t * t;
			float num2 = num * t;
			float num3 = 3f * (ctr1.x - start.x);
			float num4 = 3f * (ctr1.y - start.y);
			float num5 = 3f * (ctr2.x - ctr1.x) - num3;
			float num6 = 3f * (ctr2.y - ctr1.y) - num4;
			float num7 = end.x - start.x - num3 - num5;
			float num8 = end.y - start.y - num4 - num6;
			float x = start.x + num3 * t + num5 * num + num7 * num2;
			float y = start.y + num4 * t + num6 * num + num8 * num2;
			point = new Vector3(x, y, 0f);
		}

		private static void GetCurvePoint3D(ref Vector3 start, ref Vector3 end, ref Vector3 ctr1, ref Vector3 ctr2, float t, out Vector3 point)
		{
			float num = t * t;
			float num2 = num * t;
			float num3 = (ctr1.x - start.x) * 3f;
			float num4 = (ctr1.y - start.y) * 3f;
			float num5 = (ctr1.z - start.z) * 3f;
			float num6 = (ctr2.x - ctr1.x) * 3f - num3;
			float num7 = (ctr2.y - ctr1.y) * 3f - num4;
			float num8 = (ctr2.z - ctr1.z) * 3f - num5;
			float num9 = end.x - start.x - num3 - num6;
			float num10 = end.y - start.y - num4 - num7;
			float num11 = end.z - start.z - num5 - num8;
			float x = start.x + num3 * t + num6 * num + num9 * num2;
			float y = start.y + num4 * t + num7 * num + num10 * num2;
			float z = start.z + num5 * t + num8 * num + num11 * num2;
			point = new Vector3(x, y, z);
		}

		private static void CalculateNonuniformCatmullRom(float p1, float p2, float p3, float p4, float distance1, float distance2, float distance3, out Vector4 point)
		{
			float num = ((p2 - p1) / distance1 - (p3 - p1) / (distance1 + distance2) + (p3 - p2) / distance2) * distance2;
			float num2 = ((p3 - p2) / distance2 - (p4 - p2) / (distance2 + distance3) + (p4 - p3) / distance3) * distance2;
			point = new Vector4(p2, num, -3f * p2 + 3f * p3 - (num2 + 2f * num), num + num2 + (2f * p2 - 2f * p3));
		}

		private static float CalculatePolynomial(ref Vector4 point, float t)
		{
			float num = t * t;
			float num2 = num * t;
			return point.w * num2 + point.z * num + point.y * t + point.x;
		}

		private static void ClampSplineDistances(ref float distance1, ref float distance2, ref float distance3)
		{
			if (distance2 < 0.0001f)
			{
				distance2 = 1f;
			}
			if (distance1 < 0.0001f)
			{
				distance1 = distance2;
			}
			if (distance3 < 0.0001f)
			{
				distance3 = distance2;
			}
		}

		private static void GetSplinePoint2D(ref Vector3 point1, ref Vector3 point2, ref Vector3 point3, ref Vector3 point4, float t, out Vector3 point)
		{
			float distance = Distance2D(ref point1, ref point2);
			float distance2 = Distance2D(ref point2, ref point3);
			float distance3 = Distance2D(ref point3, ref point4);
			ClampSplineDistances(ref distance, ref distance2, ref distance3);
			CalculateNonuniformCatmullRom(point1.x, point2.x, point3.x, point4.x, distance, distance2, distance3, out var point5);
			CalculateNonuniformCatmullRom(point1.y, point2.y, point3.y, point4.y, distance, distance2, distance3, out var point6);
			point = new Vector3(CalculatePolynomial(ref point5, t), CalculatePolynomial(ref point6, t), 0f);
		}

		private static void GetSplinePoint3D(ref Vector3 point1, ref Vector3 point2, ref Vector3 point3, ref Vector3 point4, float t, out Vector3 point)
		{
			float distance = Distance3D(ref point1, ref point2);
			float distance2 = Distance3D(ref point2, ref point3);
			float distance3 = Distance3D(ref point3, ref point4);
			ClampSplineDistances(ref distance, ref distance2, ref distance3);
			CalculateNonuniformCatmullRom(point1.x, point2.x, point3.x, point4.x, distance, distance2, distance3, out var point5);
			CalculateNonuniformCatmullRom(point1.y, point2.y, point3.y, point4.y, distance, distance2, distance3, out var point6);
			CalculateNonuniformCatmullRom(point1.z, point2.z, point3.z, point4.z, distance, distance2, distance3, out var point7);
			point = new Vector3(CalculatePolynomial(ref point5, t), CalculatePolynomial(ref point6, t), CalculatePolynomial(ref point7, t));
		}

		public static float CreateCurve(ICollection<Vector3> path, Vector3 start, Vector3 end, Vector3 ctr1, Vector3 ctr2, int numberOfSegments, float startT)
		{
			numberOfSegments = Math.Min(1024, Math.Max(numberOfSegments, 4));
			float num = 1f / (float)(numberOfSegments + 1);
			float num2;
			Vector3 point;
			if (Is2D)
			{
				for (num2 = startT; num2 <= 1f; num2 += num)
				{
					GetCurvePoint2D(ref start, ref end, ref ctr1, ref ctr2, num2, out point);
					path.Add(point);
				}
			}
			else
			{
				for (num2 = startT; num2 <= 1f; num2 += num)
				{
					GetCurvePoint3D(ref start, ref end, ref ctr1, ref ctr2, num2, out point);
					path.Add(point);
				}
			}
			return num2 - 1f;
		}

		public static bool CreateSpline(ICollection<Vector3> path, IList<Vector3> points, int numberOfSegments, bool closePath)
		{
			if (points.Count < 4)
			{
				return false;
			}
			numberOfSegments = Math.Min(1024, Math.Max(numberOfSegments, 4));
			int num = (closePath ? points.Count : (points.Count - 1));
			int num2 = (closePath ? 1 : 0);
			float num3 = 1f / (float)numberOfSegments * (float)num;
			float num4 = 0f;
			for (int i = 0; i < num; i++)
			{
				int index = ((i == 0) ? (num - num2) : (i - 1));
				int num5 = i + 1;
				int num6 = i + 2;
				if (closePath && num5 > num - 1)
				{
					num5 -= num;
				}
				if (num6 > num - 1)
				{
					num6 = (closePath ? (num6 - num) : num);
				}
				Vector3 point = points[index];
				Vector3 point2 = points[i];
				Vector3 point3 = points[num5];
				Vector3 point4 = points[num6];
				float num7;
				Vector3 point5;
				if (Is2D)
				{
					for (num7 = num4; num7 <= 1f; num7 += num3)
					{
						GetSplinePoint2D(ref point, ref point2, ref point3, ref point4, num7, out point5);
						path.Add(point5);
					}
				}
				else
				{
					for (num7 = num4; num7 <= 1f; num7 += num3)
					{
						GetSplinePoint3D(ref point, ref point2, ref point3, ref point4, num7, out point5);
						path.Add(point5);
					}
				}
				num4 = num7 - 1f;
			}
			return true;
		}

		public static bool CreateSplineWithSegmentDistance(ICollection<Vector3> path, IList<Vector3> points, float distancePerSegment, bool closePath)
		{
			if (points.Count < 4 || distancePerSegment <= 0f)
			{
				return false;
			}
			int num = (closePath ? points.Count : (points.Count - 1));
			int num2 = (closePath ? 1 : 0);
			float num3 = 0f;
			for (int i = 0; i < num; i++)
			{
				int index = ((i == 0) ? (num - num2) : (i - 1));
				int num4 = i + 1;
				int num5 = i + 2;
				if (closePath && num4 > num - 1)
				{
					num4 -= num;
				}
				if (num5 > num - 1)
				{
					num5 = (closePath ? (num5 - num) : num);
				}
				Vector3 point = points[index];
				Vector3 point2 = points[i];
				Vector3 point3 = points[num4];
				Vector3 point4 = points[num5];
				Vector3 point5;
				if (Is2D)
				{
					float value = 1f / (Distance2D(ref point3, ref point2) / distancePerSegment);
					value = Mathf.Clamp(value, 0.00390625f, 1f);
					for (float num6 = num3; num6 <= 1f; num6 += value)
					{
						GetSplinePoint2D(ref point, ref point2, ref point3, ref point4, num6, out point5);
						path.Add(point5);
					}
				}
				else
				{
					float value = 1f / (Distance3D(ref point3, ref point2) / distancePerSegment);
					value = Mathf.Clamp(value, 0.00390625f, 1f);
					for (float num6 = num3; num6 <= 1f; num6 += value)
					{
						GetSplinePoint3D(ref point, ref point2, ref point3, ref point4, num6, out point5);
						path.Add(point5);
					}
				}
				num3 = 0f;
			}
			return true;
		}
	}
	public class LightningBeamSpellScript : LightningSpellScript
	{
		[Header("Beam")]
		[Tooltip("The lightning path script creating the beam of lightning")]
		public LightningBoltPathScriptBase LightningPathScript;

		[Tooltip("Give the end point some randomization")]
		public float EndPointRandomization = 1.5f;

		[HideInInspector]
		public Action<RaycastHit> CollisionCallback;

		private void CheckCollision()
		{
			if (Physics.Raycast(SpellStart.transform.position, Direction, out var hitInfo, MaxDistance, CollisionMask))
			{
				SpellEnd.transform.position = hitInfo.point;
				SpellEnd.transform.position += UnityEngine.Random.insideUnitSphere * EndPointRandomization;
				PlayCollisionSound(SpellEnd.transform.position);
				if (CollisionParticleSystem != null)
				{
					CollisionParticleSystem.transform.position = hitInfo.point;
					CollisionParticleSystem.Play();
				}
				ApplyCollisionForce(hitInfo.point);
				if (CollisionCallback != null)
				{
					CollisionCallback(hitInfo);
				}
			}
			else
			{
				if (CollisionParticleSystem != null)
				{
					CollisionParticleSystem.Stop();
				}
				SpellEnd.transform.position = SpellStart.transform.position + Direction * MaxDistance;
				SpellEnd.transform.position += UnityEngine.Random.insideUnitSphere * EndPointRandomization;
			}
		}

		protected override void Start()
		{
			base.Start();
			LightningPathScript.ManualMode = true;
		}

		protected override void LateUpdate()
		{
			base.LateUpdate();
			if (base.Casting)
			{
				CheckCollision();
			}
		}

		protected override void OnCastSpell()
		{
			LightningPathScript.ManualMode = false;
		}

		protected override void OnStopSpell()
		{
			LightningPathScript.ManualMode = true;
		}
	}
	public interface ICollisionHandler
	{
		void HandleCollision(GameObject obj, List<ParticleCollisionEvent> collision, int collisionCount);
	}
	[RequireComponent(typeof(ParticleSystem))]
	public class LightningParticleCollisionForwarder : MonoBehaviour
	{
		[Tooltip("The script to forward the collision to. Must implement ICollisionHandler.")]
		public MonoBehaviour CollisionHandler;

		private ParticleSystem _particleSystem;

		private readonly List<ParticleCollisionEvent> collisionEvents = new List<ParticleCollisionEvent>();

		private void Start()
		{
			_particleSystem = GetComponent<ParticleSystem>();
		}

		private void OnParticleCollision(GameObject other)
		{
			if (CollisionHandler is ICollisionHandler collisionHandler)
			{
				int num = _particleSystem.GetCollisionEvents(other, collisionEvents);
				if (num != 0)
				{
					collisionHandler.HandleCollision(other, collisionEvents, num);
				}
			}
		}
	}
	public class LightningParticleSpellScript : LightningSpellScript, ICollisionHandler
	{
		[Header("Particle system")]
		public ParticleSystem ParticleSystem;

		[Tooltip("Particle system collision interval. This time must elapse before another collision will be registered.")]
		public float CollisionInterval;

		protected float collisionTimer;

		[HideInInspector]
		public Action<GameObject, List<ParticleCollisionEvent>, int> CollisionCallback;

		[Header("Particle Light Properties")]
		[Tooltip("Whether to enable point lights for the particles")]
		public bool EnableParticleLights = true;

		[SingleLineClamp("Possible range for particle lights", 0.001, 100.0)]
		public RangeOfFloats ParticleLightRange = new RangeOfFloats
		{
			Minimum = 2f,
			Maximum = 5f
		};

		[SingleLineClamp("Possible range of intensity for particle lights", 0.009999999776482582, 8.0)]
		public RangeOfFloats ParticleLightIntensity = new RangeOfFloats
		{
			Minimum = 0.2f,
			Maximum = 0.3f
		};

		[Tooltip("Possible range of colors for particle lights")]
		public Color ParticleLightColor1 = Color.white;

		[Tooltip("Possible range of colors for particle lights")]
		public Color ParticleLightColor2 = Color.white;

		[Tooltip("The culling mask for particle lights")]
		public LayerMask ParticleLightCullingMask = -1;

		private ParticleSystem.Particle[] particles = new ParticleSystem.Particle[512];

		private readonly List<GameObject> particleLights = new List<GameObject>();

		private void PopulateParticleLight(Light src)
		{
			src.bounceIntensity = 0f;
			src.type = LightType.Point;
			src.shadows = LightShadows.None;
			src.color = new Color(UnityEngine.Random.Range(ParticleLightColor1.r, ParticleLightColor2.r), UnityEngine.Random.Range(ParticleLightColor1.g, ParticleLightColor2.g), UnityEngine.Random.Range(ParticleLightColor1.b, ParticleLightColor2.b), 1f);
			src.cullingMask = ParticleLightCullingMask;
			src.intensity = UnityEngine.Random.Range(ParticleLightIntensity.Minimum, ParticleLightIntensity.Maximum);
			src.range = UnityEngine.Random.Range(ParticleLightRange.Minimum, ParticleLightRange.Maximum);
		}

		private void UpdateParticleLights()
		{
			if (EnableParticleLights)
			{
				int num = ParticleSystem.GetParticles(particles);
				while (particleLights.Count < num)
				{
					GameObject gameObject = new GameObject("LightningParticleSpellLight");
					gameObject.hideFlags = HideFlags.HideAndDontSave;
					PopulateParticleLight(gameObject.AddComponent<Light>());
					particleLights.Add(gameObject);
				}
				while (particleLights.Count > num)
				{
					UnityEngine.Object.Destroy(particleLights[particleLights.Count - 1]);
					particleLights.RemoveAt(particleLights.Count - 1);
				}
				for (int i = 0; i < num; i++)
				{
					particleLights[i].transform.position = particles[i].position;
				}
			}
		}

		private void UpdateParticleSystems()
		{
			if (EmissionParticleSystem != null && EmissionParticleSystem.isPlaying)
			{
				EmissionParticleSystem.transform.position = SpellStart.transform.position;
				EmissionParticleSystem.transform.forward = Direction;
			}
			if (ParticleSystem != null)
			{
				if (ParticleSystem.isPlaying)
				{
					ParticleSystem.transform.position = SpellStart.transform.position;
					ParticleSystem.transform.forward = Direction;
				}
				UpdateParticleLights();
			}
		}

		protected override void OnDestroy()
		{
			base.OnDestroy();
			foreach (GameObject particleLight in particleLights)
			{
				UnityEngine.Object.Destroy(particleLight);
			}
		}

		protected override void Start()
		{
			base.Start();
		}

		protected override void Update()
		{
			base.Update();
			UpdateParticleSystems();
			collisionTimer -= LightningBoltScript.DeltaTime;
		}

		protected override void OnCastSpell()
		{
			if (ParticleSystem != null)
			{
				ParticleSystem.Play();
				UpdateParticleSystems();
			}
		}

		protected override void OnStopSpell()
		{
			if (ParticleSystem != null)
			{
				ParticleSystem.Stop();
			}
		}

		void ICollisionHandler.HandleCollision(GameObject obj, List<ParticleCollisionEvent> collisions, int collisionCount)
		{
			if (collisionTimer <= 0f)
			{
				collisionTimer = CollisionInterval;
				PlayCollisionSound(collisions[0].intersection);
				ApplyCollisionForce(collisions[0].intersection);
				if (CollisionCallback != null)
				{
					CollisionCallback(obj, collisions, collisionCount);
				}
			}
		}
	}
	public abstract class LightningSpellScript : MonoBehaviour
	{
		[Header("Direction and distance")]
		[Tooltip("The start point of the spell. Set this to a muzzle end or hand.")]
		public GameObject SpellStart;

		[Tooltip("The end point of the spell. Set this to an empty game object. This will change depending on things like collisions, randomness, etc. Not all spells need an end object, but create this anyway to be sure.")]
		public GameObject SpellEnd;

		[HideInInspector]
		[Tooltip("The direction of the spell. Should be normalized. Does not change unless explicitly modified.")]
		public Vector3 Direction;

		[Tooltip("The maximum distance of the spell")]
		public float MaxDistance = 15f;

		[Header("Collision")]
		[Tooltip("Whether the collision is an exploision. If not explosion, collision is directional.")]
		public bool CollisionIsExplosion;

		[Tooltip("The radius of the collision explosion")]
		public float CollisionRadius = 1f;

		[Tooltip("The force to explode with when there is a collision")]
		public float CollisionForce = 50f;

		[Tooltip("Collision force mode")]
		public ForceMode CollisionForceMode = ForceMode.Impulse;

		[Tooltip("The particle system for collisions. For best effects, this should emit particles in bursts at time 0 and not loop.")]
		public ParticleSystem CollisionParticleSystem;

		[Tooltip("The layers that the spell should collide with")]
		public LayerMask CollisionMask = -1;

		[Tooltip("Collision audio source")]
		public AudioSource CollisionAudioSource;

		[Tooltip("Collision audio clips. One will be chosen at random and played one shot with CollisionAudioSource.")]
		public AudioClip[] CollisionAudioClips;

		[Tooltip("Collision sound volume range.")]
		public RangeOfFloats CollisionVolumeRange = new RangeOfFloats
		{
			Minimum = 0.4f,
			Maximum = 0.6f
		};

		[Header("Duration and Cooldown")]
		[Tooltip("The duration in seconds that the spell will last. Not all spells support a duration. For one shot spells, this is how long the spell cast / emission light, etc. will last.")]
		public float Duration;

		[Tooltip("The cooldown in seconds. Once cast, the spell must wait for the cooldown before being cast again.")]
		public float Cooldown;

		[Header("Emission")]
		[Tooltip("Emission sound")]
		public AudioSource EmissionSound;

		[Tooltip("Emission particle system. For best results use world space, turn off looping and play on awake.")]
		public ParticleSystem EmissionParticleSystem;

		[Tooltip("Light to illuminate when spell is cast")]
		public Light EmissionLight;

		private int stopToken;

		protected float DurationTimer { get; private set; }

		protected float CooldownTimer { get; private set; }

		public bool Casting { get; private set; }

		public bool CanCastSpell
		{
			get
			{
				if (!Casting)
				{
					return CooldownTimer <= 0f;
				}
				return false;
			}
		}

		private IEnumerator StopAfterSecondsCoRoutine(float seconds)
		{
			int token = stopToken;
			yield return new WaitForSecondsLightning(seconds);
			if (token == stopToken)
			{
				StopSpell();
			}
		}

		protected void ApplyCollisionForce(Vector3 point)
		{
			if (!(CollisionForce > 0f) || !(CollisionRadius > 0f))
			{
				return;
			}
			Collider[] array = Physics.OverlapSphere(point, CollisionRadius, CollisionMask);
			for (int i = 0; i < array.Length; i++)
			{
				Rigidbody component = array[i].GetComponent<Rigidbody>();
				if (component != null)
				{
					if (CollisionIsExplosion)
					{
						component.AddExplosionForce(CollisionForce, point, CollisionRadius, CollisionForce * 0.02f, CollisionForceMode);
					}
					else
					{
						component.AddForce(CollisionForce * Direction, CollisionForceMode);
					}
				}
			}
		}

		protected void PlayCollisionSound(Vector3 pos)
		{
			if (CollisionAudioSource != null && CollisionAudioClips != null && CollisionAudioClips.Length != 0)
			{
				int num = UnityEngine.Random.Range(0, CollisionAudioClips.Length - 1);
				float volumeScale = UnityEngine.Random.Range(CollisionVolumeRange.Minimum, CollisionVolumeRange.Maximum);
				CollisionAudioSource.transform.position = pos;
				CollisionAudioSource.PlayOneShot(CollisionAudioClips[num], volumeScale);
			}
		}

		protected virtual void Start()
		{
			if (EmissionLight != null)
			{
				EmissionLight.enabled = false;
			}
		}

		protected virtual void Update()
		{
			CooldownTimer = Mathf.Max(0f, CooldownTimer - LightningBoltScript.DeltaTime);
			DurationTimer = Mathf.Max(0f, DurationTimer - LightningBoltScript.DeltaTime);
		}

		protected virtual void LateUpdate()
		{
		}

		protected virtual void OnDestroy()
		{
		}

		protected abstract void OnCastSpell();

		protected abstract void OnStopSpell();

		protected virtual void OnActivated()
		{
		}

		protected virtual void OnDeactivated()
		{
		}

		public bool CastSpell()
		{
			if (!CanCastSpell)
			{
				return false;
			}
			Casting = true;
			DurationTimer = Duration;
			CooldownTimer = Cooldown;
			OnCastSpell();
			if (Duration > 0f)
			{
				StopAfterSeconds(Duration);
			}
			if (EmissionParticleSystem != null)
			{
				EmissionParticleSystem.Play();
			}
			if (EmissionLight != null)
			{
				EmissionLight.transform.position = SpellStart.transform.position;
				EmissionLight.enabled = true;
			}
			if (EmissionSound != null)
			{
				EmissionSound.Play();
			}
			return true;
		}

		public void StopSpell()
		{
			if (Casting)
			{
				stopToken++;
				if (EmissionParticleSystem != null)
				{
					EmissionParticleSystem.Stop();
				}
				if (EmissionLight != null)
				{
					EmissionLight.enabled = false;
				}
				if (EmissionSound != null && EmissionSound.loop)
				{
					EmissionSound.Stop();
				}
				DurationTimer = 0f;
				Casting = false;
				OnStopSpell();
			}
		}

		public void ActivateSpell()
		{
			OnActivated();
		}

		public void DeactivateSpell()
		{
			OnDeactivated();
		}

		public void StopAfterSeconds(float seconds)
		{
			StartCoroutine(StopAfterSecondsCoRoutine(seconds));
		}

		public static GameObject FindChildRecursively(Transform t, string name)
		{
			if (t.name == name)
			{
				return t.gameObject;
			}
			for (int i = 0; i < t.childCount; i++)
			{
				GameObject gameObject = FindChildRecursively(t.GetChild(i), name);
				if (gameObject != null)
				{
					return gameObject;
				}
			}
			return null;
		}
	}
	public class LightningWhipSpell : LightningSpellScript
	{
		[Header("Whip")]
		[Tooltip("Attach the whip to what object")]
		public GameObject AttachTo;

		[Tooltip("Rotate the whip with this object")]
		public GameObject RotateWith;

		[Tooltip("Whip handle")]
		public GameObject WhipHandle;

		[Tooltip("Whip start")]
		public GameObject WhipStart;

		[Tooltip("Whip spring")]
		public GameObject WhipSpring;

		[Tooltip("Whip crack audio source")]
		public AudioSource WhipCrackAudioSource;

		[HideInInspector]
		public Action<Vector3> CollisionCallback;

		private IEnumerator WhipForward()
		{
			for (int i = 0; i < WhipStart.transform.childCount; i++)
			{
				Rigidbody component = WhipStart.transform.GetChild(i).gameObject.GetComponent<Rigidbody>();
				if (component != null)
				{
					component.drag = 0f;
					component.velocity = Vector3.zero;
					component.angularVelocity = Vector3.zero;
				}
			}
			WhipSpring.SetActive(value: true);
			Vector3 position = WhipStart.GetComponent<Rigidbody>().position;
			Vector3 whipPositionForwards;
			Vector3 position2;
			if (Physics.Raycast(position, Direction, out var hitInfo, MaxDistance, CollisionMask))
			{
				Vector3 normalized = (hitInfo.point - position).normalized;
				whipPositionForwards = position + normalized * MaxDistance;
				position2 = position - normalized * 25f;
			}
			else
			{
				whipPositionForwards = position + Direction * MaxDistance;
				position2 = position - Direction * 25f;
			}
			WhipSpring.GetComponent<Rigidbody>().position = position2;
			yield return new WaitForSecondsLightning(0.25f);
			WhipSpring.GetComponent<Rigidbody>().position = whipPositionForwards;
			yield return new WaitForSecondsLightning(0.1f);
			if (WhipCrackAudioSource != null)
			{
				WhipCrackAudioSource.Play();
			}
			yield return new WaitForSecondsLightning(0.1f);
			if (CollisionParticleSystem != null)
			{
				CollisionParticleSystem.Play();
			}
			ApplyCollisionForce(SpellEnd.transform.position);
			WhipSpring.SetActive(value: false);
			if (CollisionCallback != null)
			{
				CollisionCallback(SpellEnd.transform.position);
			}
			yield return new WaitForSecondsLightning(0.1f);
			for (int j = 0; j < WhipStart.transform.childCount; j++)
			{
				Rigidbody component2 = WhipStart.transform.GetChild(j).gameObject.GetComponent<Rigidbody>();
				if (component2 != null)
				{
					component2.velocity = Vector3.zero;
					component2.angularVelocity = Vector3.zero;
					component2.drag = 0.5f;
				}
			}
		}

		protected override void Start()
		{
			base.Start();
			WhipSpring.SetActive(value: false);
			WhipHandle.SetActive(value: false);
		}

		protected override void Update()
		{
			base.Update();
			base.gameObject.transform.position = AttachTo.transform.position;
			base.gameObject.transform.rotation = RotateWith.transform.rotation;
		}

		protected override void OnCastSpell()
		{
			StartCoroutine(WhipForward());
		}

		protected override void OnStopSpell()
		{
		}

		protected override void OnActivated()
		{
			base.OnActivated();
			WhipHandle.SetActive(value: true);
		}

		protected override void OnDeactivated()
		{
			base.OnDeactivated();
			WhipHandle.SetActive(value: false);
		}
	}
	public class ThunderAndLightningScript : MonoBehaviour
	{
		private class LightningBoltHandler
		{
			private ThunderAndLightningScript script;

			private readonly System.Random random = new System.Random();

			public float VolumeMultiplier { get; set; }

			public LightningBoltHandler(ThunderAndLightningScript script)
			{
				this.script = script;
				CalculateNextLightningTime();
			}

			private void UpdateLighting()
			{
				if (script.lightningInProgress)
				{
					return;
				}
				if (script.ModifySkyboxExposure)
				{
					script.skyboxExposureStorm = 0.35f;
					if (script.skyboxMaterial != null && script.skyboxMaterial.HasProperty("_Exposure"))
					{
						script.skyboxMaterial.SetFloat("_Exposure", script.skyboxExposureStorm);
					}
				}
				CheckForLightning();
			}

			private void CalculateNextLightningTime()
			{
				script.nextLightningTime = DigitalRuby.ThunderAndLightning.LightningBoltScript.TimeSinceStart + script.LightningIntervalTimeRange.Random(random);
				script.lightningInProgress = false;
				if (script.ModifySkyboxExposure && script.skyboxMaterial.HasProperty("_Exposure"))
				{
					script.skyboxMaterial.SetFloat("_Exposure", script.skyboxExposureStorm);
				}
			}

			public IEnumerator ProcessLightning(Vector3? _start, Vector3? _end, bool intense, bool visible)
			{
				script.lightningInProgress = true;
				float intensity;
				float time;
				AudioClip[] sounds;
				if (intense)
				{
					float t = UnityEngine.Random.Range(0f, 1f);
					intensity = Mathf.Lerp(2f, 8f, t);
					time = 5f / intensity;
					sounds = script.ThunderSoundsIntense;
				}
				else
				{
					float t2 = UnityEngine.Random.Range(0f, 1f);
					intensity = Mathf.Lerp(0f, 2f, t2);
					time = 30f / intensity;
					sounds = script.ThunderSoundsNormal;
				}
				if (script.skyboxMaterial != null && script.ModifySkyboxExposure)
				{
					script.skyboxMaterial.SetFloat("_Exposure", Mathf.Max(intensity * 0.5f, script.skyboxExposureStorm));
				}
				Strike(_start, _end, intense, intensity, script.Camera, visible ? script.Camera : null);
				CalculateNextLightningTime();
				if (intensity >= 1f && sounds != null && sounds.Length != 0)
				{
					yield return new WaitForSecondsLightning(time);
					AudioClip audioClip;
					do
					{
						audioClip = sounds[UnityEngine.Random.Range(0, sounds.Length - 1)];
					}
					while (sounds.Length > 1 && audioClip == script.lastThunderSound);
					script.lastThunderSound = audioClip;
					script.audioSourceThunder.PlayOneShot(audioClip, intensity * 0.5f * VolumeMultiplier);
				}
			}

			private void Strike(Vector3? _start, Vector3? _end, bool intense, float intensity, Camera camera, Camera visibleInCamera)
			{
				float minInclusive = (intense ? (-1000f) : (-5000f));
				float maxInclusive = (intense ? 1000f : 5000f);
				float num = (intense ? 500f : 2500f);
				float num2 = ((UnityEngine.Random.Range(0, 2) == 0) ? UnityEngine.Random.Range(minInclusive, 0f - num) : UnityEngine.Random.Range(num, maxInclusive));
				float lightningYStart = script.LightningYStart;
				float num3 = ((UnityEngine.Random.Range(0, 2) == 0) ? UnityEngine.Random.Range(minInclusive, 0f - num) : UnityEngine.Random.Range(num, maxInclusive));
				Vector3 vector = script.Camera.transform.position;
				vector.x += num2;
				vector.y = lightningYStart;
				vector.z += num3;
				if (visibleInCamera != null)
				{
					Quaternion rotation = visibleInCamera.transform.rotation;
					visibleInCamera.transform.rotation = Quaternion.Euler(0f, rotation.eulerAngles.y, 0f);
					float x = UnityEngine.Random.Range((float)visibleInCamera.pixelWidth * 0.1f, (float)visibleInCamera.pixelWidth * 0.9f);
					float z = UnityEngine.Random.Range(visibleInCamera.nearClipPlane + num + num, maxInclusive);
					vector = visibleInCamera.ScreenToWorldPoint(new Vector3(x, 0f, z));
					vector.y = lightningYStart;
					visibleInCamera.transform.rotation = rotation;
				}
				Vector3 vector2 = vector;
				num2 = UnityEngine.Random.Range(-100f, 100f);
				lightningYStart = ((UnityEngine.Random.Range(0, 4) == 0) ? UnityEngine.Random.Range(-1f, 600f) : (-1f));
				num3 += UnityEngine.Random.Range(-100f, 100f);
				vector2.x += num2;
				vector2.y = lightningYStart;
				vector2.z += num3;
				vector2.x += num * camera.transform.forward.x;
				vector2.z += num * camera.transform.forward.z;
				while ((vector - vector2).magnitude < 500f)
				{
					vector2.x += num * camera.transform.forward.x;
					vector2.z += num * camera.transform.forward.z;
				}
				vector = _start ?? vector;
				vector2 = _end ?? vector2;
				if (Physics.Raycast(vector, (vector - vector2).normalized, out var hitInfo, float.MaxValue))
				{
					vector2 = hitInfo.point;
				}
				int generations = script.LightningBoltScript.Generations;
				RangeOfFloats trunkWidthRange = script.LightningBoltScript.TrunkWidthRange;
				if (UnityEngine.Random.value < script.CloudLightningChance)
				{
					script.LightningBoltScript.TrunkWidthRange = default(RangeOfFloats);
					script.LightningBoltScript.Generations = 1;
				}
				script.LightningBoltScript.LightParameters.LightIntensity = intensity * 0.5f;
				script.LightningBoltScript.Trigger(vector, vector2);
				script.LightningBoltScript.TrunkWidthRange = trunkWidthRange;
				script.LightningBoltScript.Generations = generations;
			}

			private void CheckForLightning()
			{
				if (Time.time >= script.nextLightningTime)
				{
					bool intense = UnityEngine.Random.value < script.LightningIntenseProbability;
					script.StartCoroutine(ProcessLightning(null, null, intense, script.LightningAlwaysVisible));
				}
			}

			public void Update()
			{
				UpdateLighting();
			}
		}

		[Tooltip("Lightning bolt script - optional, leave null if you don't want lightning bolts")]
		public LightningBoltPrefabScript LightningBoltScript;

		[Tooltip("Camera where the lightning should be centered over. Defaults to main camera.")]
		public Camera Camera;

		[SingleLine("Random interval between strikes.")]
		public RangeOfFloats LightningIntervalTimeRange = new RangeOfFloats
		{
			Minimum = 10f,
			Maximum = 25f
		};

		[Tooltip("Probability (0-1) of an intense lightning bolt that hits really close. Intense lightning has increased brightness and louder thunder compared to normal lightning, and the thunder sounds plays a lot sooner.")]
		[Range(0f, 1f)]
		public float LightningIntenseProbability = 0.2f;

		[Tooltip("Sounds to play for normal thunder. One will be chosen at random for each lightning strike. Depending on intensity, some normal lightning may not play a thunder sound.")]
		public AudioClip[] ThunderSoundsNormal;

		[Tooltip("Sounds to play for intense thunder. One will be chosen at random for each lightning strike.")]
		public AudioClip[] ThunderSoundsIntense;

		[Tooltip("Whether lightning strikes should always try to be in the camera view")]
		public bool LightningAlwaysVisible = true;

		[Tooltip("The chance lightning will simply be in the clouds with no visible bolt")]
		[Range(0f, 1f)]
		public float CloudLightningChance = 0.5f;

		[Tooltip("Whether to modify the skybox exposure when lightning is created")]
		public bool ModifySkyboxExposure;

		[Tooltip("Base point light range for lightning bolts. Increases as intensity increases.")]
		[Range(1f, 10000f)]
		public float BaseLightRange = 2000f;

		[Tooltip("Starting y value for the lightning strikes")]
		[Range(0f, 100000f)]
		public float LightningYStart = 500f;

		[Tooltip("Volume multiplier")]
		[Range(0f, 1f)]
		public float VolumeMultiplier = 1f;

		private float skyboxExposureOriginal;

		private float skyboxExposureStorm;

		private float nextLightningTime;

		private bool lightningInProgress;

		private AudioSource audioSourceThunder;

		private LightningBoltHandler lightningBoltHandler;

		private Material skyboxMaterial;

		private AudioClip lastThunderSound;

		public float SkyboxExposureOriginal => skyboxExposureOriginal;

		public bool EnableLightning { get; set; }

		private void Start()
		{
			EnableLightning = true;
			if (Camera == null)
			{
				Camera = Camera.main;
			}
			if (RenderSettings.skybox != null)
			{
				skyboxMaterial = (RenderSettings.skybox = new Material(RenderSettings.skybox));
			}
			skyboxExposureOriginal = (skyboxExposureStorm = ((skyboxMaterial == null || !skyboxMaterial.HasProperty("_Exposure")) ? 1f : skyboxMaterial.GetFloat("_Exposure")));
			audioSourceThunder = base.gameObject.AddComponent<AudioSource>();
			lightningBoltHandler = new LightningBoltHandler(this);
			lightningBoltHandler.VolumeMultiplier = VolumeMultiplier;
		}

		private void Update()
		{
			if (lightningBoltHandler != null && EnableLightning)
			{
				lightningBoltHandler.VolumeMultiplier = VolumeMultiplier;
				lightningBoltHandler.Update();
			}
		}

		public void CallNormalLightning()
		{
			CallNormalLightning(null, null);
		}

		public void CallNormalLightning(Vector3? start, Vector3? end)
		{
			StartCoroutine(lightningBoltHandler.ProcessLightning(start, end, intense: false, visible: true));
		}

		public void CallIntenseLightning()
		{
			CallIntenseLightning(null, null);
		}

		public void CallIntenseLightning(Vector3? start, Vector3? end)
		{
			StartCoroutine(lightningBoltHandler.ProcessLightning(start, end, intense: true, visible: true));
		}
	}
}
namespace EasyVR
{
	public class KillPanel : MonoBehaviour
	{
		private void OnTriggerEnter(Collider other)
		{
			if (other.gameObject.CompareTag("Player") && Physics.Raycast(MonoSingleton<PlayerInfo>.Instance.transform.position, MonoSingleton<PlayerInfo>.Instance.transform.up, out var hitInfo))
			{
				UnityEngine.Debug.Log(hitInfo.collider.name);
			}
		}
	}
	public class PlayerInfo : MonoSingleton<PlayerInfo>
	{
		public bool allowedOpenUI = true;

		public bool allowedMove = true;

		private void Start()
		{
			Test();
		}

		private void Test()
		{
			TestManager.AddTest("移动到 2 2 2 转脸", delegate
			{
				MoveTo(Vector3.one * 2f, Quaternion.Euler(0f, 90f, 0f));
			});
			TestManager.AddTest("移动到 4 4 4 不转脸", delegate
			{
				MoveTo(Vector3.one * 4f, Quaternion.identity, rotatePlayer: false);
			});
		}

		private void Update()
		{
		}

		public void MoveTo(Vector3 playerDestination, Quaternion playerRotation, bool rotatePlayer = true)
		{
		}

		public void MoveToTransform(Transform destination, bool rotatePlayer = true)
		{
			MoveTo(destination.position, destination.rotation, rotatePlayer);
		}
	}
}
namespace VLights
{
	public static class VLightShaderUtil
	{
		public const string POST_SHADER_NAME = "Hidden/V-Light/Post";

		public const string DEPTH_SHADER_NAME = "Hidden/V-Light/Depth";

		public const string INTERLEAVED_SHADER_NAME = "Hidden/V-Light/Light Depth";
	}
}
namespace Autohand.Demo
{
	public class SteamVRControllerEvent : MonoBehaviour
	{
		public UnityEvent Pressed;

		public UnityEvent Released;

		private bool pressed;

		private void Update()
		{
			if (!pressed && MonoSingleton<PlayerInfo>.Instance.rightController.TriggerPressDown)
			{
				pressed = true;
				Pressed?.Invoke();
			}
			if (pressed && MonoSingleton<PlayerInfo>.Instance.rightController.TriggerPressUp)
			{
				pressed = false;
				Released?.Invoke();
			}
		}
	}
}
namespace Consolation
{
	internal class Console : MonoBehaviour
	{
		public KeyCode toggleKey = KeyCode.BackQuote;

		public bool openOnStart;

		public bool shakeToOpen = true;

		public bool shakeRequiresTouch;

		public float shakeAcceleration = 3f;

		public float toggleThresholdSeconds = 0.5f;

		private float lastToggleTime;

		public bool restrictLogCount;

		public int maxLogCount = 1000;

		public int logFontSize = 12;

		public float scaleFactor = 1f;

		private static readonly GUIContent clearLabel = new GUIContent("Clear", "Clear the contents of the console.");

		private static readonly GUIContent collapseLabel = new GUIContent("Collapse", "Hide repeated messages.");

		private const int margin = 20;

		private const string windowTitle = "Console";

		private static readonly Dictionary<LogType, Color> logTypeColors = new Dictionary<LogType, Color>
		{
			{
				LogType.Assert,
				Color.white
			},
			{
				LogType.Error,
				Color.red
			},
			{
				LogType.Exception,
				Color.red
			},
			{
				LogType.Log,
				Color.white
			},
			{
				LogType.Warning,
				Color.yellow
			}
		};

		private bool isCollapsed;

		private bool isVisible;

		private readonly List<Log> logs = new List<Log>();

		private readonly ConcurrentQueue<Log> queuedLogs = new ConcurrentQueue<Log>();

		private Vector2 scrollPosition;

		private readonly Rect titleBarRect = new Rect(0f, 0f, 10000f, 20f);

		private float windowX = 20f;

		private float windowY = 20f;

		private readonly Dictionary<LogType, bool> logTypeFilters = new Dictionary<LogType, bool>
		{
			{
				LogType.Assert,
				true
			},
			{
				LogType.Error,
				true
			},
			{
				LogType.Exception,
				true
			},
			{
				LogType.Log,
				true
			},
			{
				LogType.Warning,
				true
			}
		};

		private void OnDisable()
		{
			Application.logMessageReceivedThreaded -= HandleLogThreaded;
		}

		private void OnEnable()
		{
			Application.logMessageReceivedThreaded += HandleLogThreaded;
		}

		private void OnGUI()
		{
			if (isVisible)
			{
				GUI.matrix = Matrix4x4.Scale(Vector3.one * scaleFactor);
				float width = (float)Screen.width / scaleFactor - 40f;
				float height = (float)Screen.height / scaleFactor - 40f;
				Rect screenRect = new Rect(windowX, windowY, width, height);
				Rect rect = GUILayout.Window(123456, screenRect, DrawWindow, "Console");
				windowX = rect.x;
				windowY = rect.y;
			}
		}

		private void Start()
		{
			if (openOnStart)
			{
				isVisible = true;
			}
		}

		private void Update()
		{
			UpdateQueuedLogs();
			float realtimeSinceStartup = Time.realtimeSinceStartup;
			if (Input.GetKeyDown(toggleKey))
			{
				isVisible = !isVisible;
			}
			if (shakeToOpen && Input.acceleration.sqrMagnitude > shakeAcceleration && realtimeSinceStartup - lastToggleTime >= toggleThresholdSeconds && (!shakeRequiresTouch || Input.touchCount > 2))
			{
				isVisible = !isVisible;
				lastToggleTime = realtimeSinceStartup;
			}
		}

		private void DrawLog(Log log, GUIStyle logStyle, GUIStyle badgeStyle)
		{
			GUI.contentColor = logTypeColors[log.type];
			if (isCollapsed)
			{
				GUILayout.BeginHorizontal();
				GUILayout.Label(log.GetTruncatedMessage(), logStyle);
				GUILayout.FlexibleSpace();
				GUILayout.Label(log.count.ToString(), GUI.skin.box);
				GUILayout.EndHorizontal();
			}
			else
			{
				for (int i = 0; i < log.count; i++)
				{
					GUILayout.Label(log.GetTruncatedMessage(), logStyle);
				}
			}
			GUI.contentColor = Color.white;
		}

		private void DrawLogList()
		{
			GUIStyle box = GUI.skin.box;
			box.fontSize = logFontSize;
			GUIStyle label = GUI.skin.label;
			label.fontSize = logFontSize;
			scrollPosition = GUILayout.BeginScrollView(scrollPosition);
			GUILayout.BeginVertical();
			foreach (Log item in logs.Where(IsLogVisible))
			{
				DrawLog(item, label, box);
			}
			GUILayout.EndVertical();
			Rect lastRect = GUILayoutUtility.GetLastRect();
			GUILayout.EndScrollView();
			Rect lastRect2 = GUILayoutUtility.GetLastRect();
			if (Event.current.type == EventType.Repaint && IsScrolledToBottom(lastRect, lastRect2))
			{
				ScrollToBottom();
			}
		}

		private void DrawToolbar()
		{
			GUILayout.BeginHorizontal();
			if (GUILayout.Button(clearLabel))
			{
				logs.Clear();
			}
			foreach (LogType value2 in Enum.GetValues(typeof(LogType)))
			{
				bool value = logTypeFilters[value2];
				string text = value2.ToString();
				logTypeFilters[value2] = GUILayout.Toggle(value, text, GUILayout.ExpandWidth(expand: false));
				GUILayout.Space(20f);
			}
			isCollapsed = GUILayout.Toggle(isCollapsed, collapseLabel, GUILayout.ExpandWidth(expand: false));
			GUILayout.EndHorizontal();
		}

		private void DrawWindow(int windowID)
		{
			DrawLogList();
			DrawToolbar();
			GUI.DragWindow(titleBarRect);
		}

		private Log? GetLastLog()
		{
			if (logs.Count == 0)
			{
				return null;
			}
			return logs.Last();
		}

		private void UpdateQueuedLogs()
		{
			Log result;
			while (queuedLogs.TryDequeue(out result))
			{
				ProcessLogItem(result);
			}
		}

		private void HandleLogThreaded(string message, string stackTrace, LogType type)
		{
			Log log = default(Log);
			log.count = 1;
			log.message = message;
			log.stackTrace = stackTrace;
			log.type = type;
			Log item = log;
			queuedLogs.Enqueue(item);
		}

		private void ProcessLogItem(Log log)
		{
			Log? lastLog = GetLastLog();
			if (lastLog.HasValue && log.Equals(lastLog.Value))
			{
				log.count = lastLog.Value.count + 1;
				logs[logs.Count - 1] = log;
			}
			else
			{
				logs.Add(log);
				TrimExcessLogs();
			}
		}

		private bool IsLogVisible(Log log)
		{
			return logTypeFilters[log.type];
		}

		private bool IsScrolledToBottom(Rect innerScrollRect, Rect outerScrollRect)
		{
			float height = innerScrollRect.height;
			float num = outerScrollRect.height - (float)GUI.skin.box.padding.vertical;
			if (num > height)
			{
				return true;
			}
			return Mathf.Approximately(height, scrollPosition.y + num);
		}

		private void ScrollToBottom()
		{
			scrollPosition = new Vector2(0f, 2.1474836E+09f);
		}

		private void TrimExcessLogs()
		{
			if (restrictLogCount)
			{
				int num = logs.Count - maxLogCount;
				if (num > 0)
				{
					logs.RemoveRange(0, num);
				}
			}
		}
	}
	internal struct Log
	{
		public int count;

		public string message;

		public string stackTrace;

		public LogType type;

		private const int maxMessageLength = 16382;

		public bool Equals(Log log)
		{
			if (message == log.message && stackTrace == log.stackTrace)
			{
				return type == log.type;
			}
			return false;
		}

		public string GetTruncatedMessage()
		{
			if (string.IsNullOrEmpty(message))
			{
				return message;
			}
			if (message.Length > 16382)
			{
				return message.Substring(0, 16382);
			}
			return message;
		}
	}
	internal class ConcurrentQueue<T>
	{
		private readonly Queue<T> queue = new Queue<T>();

		private readonly object queueLock = new object();

		public void Enqueue(T item)
		{
			lock (queueLock)
			{
				queue.Enqueue(item);
			}
		}

		public bool TryDequeue(out T result)
		{
			lock (queueLock)
			{
				if (queue.Count == 0)
				{
					result = default(T);
					return false;
				}
				result = queue.Dequeue();
				return true;
			}
		}
	}
}
namespace EFramework.Unity.Tools
{
	public class Timer
	{
		private class TimerManager : MonoBehaviour
		{
			private List<Timer> _timers = new List<Timer>();

			private List<Timer> _timersToAdd = new List<Timer>();

			public void RegisterTimer(Timer timer)
			{
				_timersToAdd.Add(timer);
			}

			public void CancelAllTimers()
			{
				foreach (Timer timer in _timers)
				{
					timer.Cancel();
				}
				_timers = new List<Timer>();
				_timersToAdd = new List<Timer>();
			}

			public void PauseAllTimers()
			{
				foreach (Timer timer in _timers)
				{
					timer.Pause();
				}
			}

			public void ResumeAllTimers()
			{
				foreach (Timer timer in _timers)
				{
					timer.Resume();
				}
			}

			[UsedImplicitly]
			private void Update()
			{
				UpdateAllTimers();
			}

			private void UpdateAllTimers()
			{
				if (_timersToAdd.Count > 0)
				{
					_timers.AddRange(_timersToAdd);
					_timersToAdd.Clear();
				}
				foreach (Timer timer in _timers)
				{
					timer.Update();
				}
				_timers.RemoveAll((Timer t) => t.isDone);
			}
		}

		private static TimerManager _manager;

		private readonly Action _onComplete;

		private readonly Action<float> _onUpdate;

		private float _startTime;

		private float _lastUpdateTime;

		private float? _timeElapsedBeforeCancel;

		private float? _timeElapsedBeforePause;

		private readonly MonoBehaviour _autoDestroyOwner;

		private readonly bool _hasAutoDestroyOwner;

		public float duration { get; private set; }

		public bool isLooped { get; set; }

		public bool isCompleted { get; private set; }

		public bool usesRealTime { get; private set; }

		public bool isPaused => _timeElapsedBeforePause.HasValue;

		public bool isCancelled => _timeElapsedBeforeCancel.HasValue;

		public bool isDone
		{
			get
			{
				if (!isCompleted && !isCancelled)
				{
					return isOwnerDestroyed;
				}
				return true;
			}
		}

		private bool isOwnerDestroyed
		{
			get
			{
				if (_hasAutoDestroyOwner)
				{
					return _autoDestroyOwner == null;
				}
				return false;
			}
		}

		public static Timer Register(float duration, Action onComplete, Action<float> onUpdate = null, bool isLooped = false, bool useRealTime = false, MonoBehaviour autoDestroyOwner = null)
		{
			if (_manager == null)
			{
				TimerManager timerManager = UnityEngine.Object.FindObjectOfType<TimerManager>();
				if (timerManager != null)
				{
					_manager = timerManager;
				}
				else
				{
					_manager = new GameObject
					{
						name = "TimerManager"
					}.AddComponent<TimerManager>();
				}
			}
			Timer timer = new Timer(duration, onComplete, onUpdate, isLooped, useRealTime, autoDestroyOwner);
			_manager.RegisterTimer(timer);
			return timer;
		}

		public static void Cancel(Timer timer)
		{
			timer?.Cancel();
		}

		public static void Pause(Timer timer)
		{
			timer?.Pause();
		}

		public static void Resume(Timer timer)
		{
			timer?.Resume();
		}

		public static void CancelAllRegisteredTimers()
		{
			if (_manager != null)
			{
				_manager.CancelAllTimers();
			}
		}

		public static void PauseAllRegisteredTimers()
		{
			if (_manager != null)
			{
				_manager.PauseAllTimers();
			}
		}

		public static void ResumeAllRegisteredTimers()
		{
			if (_manager != null)
			{
				_manager.ResumeAllTimers();
			}
		}

		public void Cancel()
		{
			if (!isDone)
			{
				_timeElapsedBeforeCancel = GetTimeElapsed();
				_timeElapsedBeforePause = null;
			}
		}

		public void Pause()
		{
			if (!isPaused && !isDone)
			{
				_timeElapsedBeforePause = GetTimeElapsed();
			}
		}

		public void Resume()
		{
			if (isPaused && !isDone)
			{
				_timeElapsedBeforePause = null;
			}
		}

		public float GetTimeElapsed()
		{
			if (isCompleted || GetWorldTime() >= GetFireTime())
			{
				return duration;
			}
			return _timeElapsedBeforeCancel ?? _timeElapsedBeforePause ?? (GetWorldTime() - _startTime);
		}

		public float GetTimeRemaining()
		{
			return duration - GetTimeElapsed();
		}

		public float GetRatioComplete()
		{
			return GetTimeElapsed() / duration;
		}

		public float GetRatioRemaining()
		{
			return GetTimeRemaining() / duration;
		}

		private Timer(float duration, Action onComplete, Action<float> onUpdate, bool isLooped, bool usesRealTime, MonoBehaviour autoDestroyOwner)
		{
			this.duration = duration;
			_onComplete = onComplete;
			_onUpdate = onUpdate;
			this.isLooped = isLooped;
			this.usesRealTime = usesRealTime;
			_autoDestroyOwner = autoDestroyOwner;
			_hasAutoDestroyOwner = autoDestroyOwner != null;
			_startTime = GetWorldTime();
			_lastUpdateTime = _startTime;
		}

		private float GetWorldTime()
		{
			if (!usesRealTime)
			{
				return Time.time;
			}
			return Time.realtimeSinceStartup;
		}

		private float GetFireTime()
		{
			return _startTime + duration;
		}

		private float GetTimeDelta()
		{
			return GetWorldTime() - _lastUpdateTime;
		}

		private void Update()
		{
			if (isDone)
			{
				return;
			}
			if (isPaused)
			{
				_startTime += GetTimeDelta();
				_lastUpdateTime = GetWorldTime();
				return;
			}
			_lastUpdateTime = GetWorldTime();
			if (_onUpdate != null)
			{
				_onUpdate(GetTimeElapsed());
			}
			if (GetWorldTime() >= GetFireTime())
			{
				if (_onComplete != null)
				{
					_onComplete();
				}
				if (isLooped)
				{
					_startTime = GetWorldTime();
				}
				else
				{
					isCompleted = true;
				}
			}
		}
	}
}
namespace EFramework.Tweens
{
	public static class AnchoredPositionTween
	{
		private class Driver : Tween<Vector2>
		{
			private RectTransform rectTransform;

			public override bool OnInitialize()
			{
				rectTransform = base.gameObject.GetComponent<RectTransform>();
				return rectTransform != null;
			}

			public override Vector2 OnGetFrom()
			{
				return rectTransform.anchoredPosition;
			}

			public override void OnUpdate(float easedTime)
			{
				valueCurrent.x = InterpolateValue(valueFrom.x, valueTo.x, easedTime);
				valueCurrent.y = InterpolateValue(valueFrom.y, valueTo.y, easedTime);
				rectTransform.anchoredPosition = valueCurrent;
			}
		}

		public static Tween<Vector2> TweenAnchoredPosition(this Component self, Vector2 to, float duration)
		{
			return Tween<Vector2>.Add<Driver>(self).Finalize(duration, to);
		}

		public static Tween<Vector2> TweenAnchoredPosition(this GameObject self, Vector2 to, float duration)
		{
			return Tween<Vector2>.Add<Driver>(self).Finalize(duration, to);
		}
	}
	public static class AnchoredPositionXTween
	{
		private class Driver : Tween<float>
		{
			private RectTransform rectTransform;

			private Vector2 anchoredPosition;

			public override bool OnInitialize()
			{
				rectTransform = base.gameObject.GetComponent<RectTransform>();
				return rectTransform != null;
			}

			public override float OnGetFrom()
			{
				return rectTransform.anchoredPosition.x;
			}

			public override void OnUpdate(float easedTime)
			{
				anchoredPosition = rectTransform.anchoredPosition;
				valueCurrent = InterpolateValue(valueFrom, valueTo, easedTime);
				anchoredPosition.x = valueCurrent;
				rectTransform.anchoredPosition = anchoredPosition;
			}
		}

		public static Tween<float> TweenAnchoredPositionX(this Component self, float to, float duration)
		{
			return Tween<float>.Add<Driver>(self).Finalize(duration, to);
		}

		public static Tween<float> TweenAnchoredPositionX(this GameObject self, float to, float duration)
		{
			return Tween<float>.Add<Driver>(self).Finalize(duration, to);
		}
	}
	public static class AnchoredPositionYTween
	{
		private class Driver : Tween<float>
		{
			private RectTransform rectTransform;

			private Vector2 anchoredPosition;

			public override bool OnInitialize()
			{
				rectTransform = base.gameObject.GetComponent<RectTransform>();
				return rectTransform != null;
			}

			public override float OnGetFrom()
			{
				return rectTransform.anchoredPosition.y;
			}

			public override void OnUpdate(float easedTime)
			{
				anchoredPosition = rectTransform.anchoredPosition;
				valueCurrent = InterpolateValue(valueFrom, valueTo, easedTime);
				anchoredPosition.y = valueCurrent;
				rectTransform.anchoredPosition = anchoredPosition;
			}
		}

		public static Tween<float> TweenAnchoredPositionY(this Component self, float to, float duration)
		{
			return Tween<float>.Add<Driver>(self).Finalize(duration, to);
		}

		public static Tween<float> TweenAnchoredPositionY(this GameObject self, float to, float duration)
		{
			return Tween<float>.Add<Driver>(self).Finalize(duration, to);
		}
	}
	public static class AudioSourcePitchTween
	{
		private class Driver : Tween<float>
		{
			private AudioSource audioSource;

			public override bool OnInitialize()
			{
				audioSource = base.gameObject.GetComponent<AudioSource>();
				return audioSource != null;
			}

			public override float OnGetFrom()
			{
				return audioSource.pitch;
			}

			public override void OnUpdate(float easedTime)
			{
				valueCurrent = InterpolateValue(valueFrom, valueTo, easedTime);
				audioSource.pitch = valueCurrent;
			}
		}

		public static Tween<float> TweenAudioSourcePitch(this Component self, float to, float duration)
		{
			return Tween<float>.Add<Driver>(self).Finalize(duration, to);
		}

		public static Tween<float> TweenAudioSourcePitch(this GameObject self, float to, float duration)
		{
			return Tween<float>.Add<Driver>(self).Finalize(duration, to);
		}
	}
	public static class AudioSourceVolumeTween
	{
		private class Driver : Tween<float>
		{
			private AudioSource audioSource;

			public override bool OnInitialize()
			{
				audioSource = base.gameObject.GetComponent<AudioSource>();
				return audioSource != null;
			}

			public override float OnGetFrom()
			{
				return audioSource.volume;
			}

			public override void OnUpdate(float easedTime)
			{
				valueCurrent = InterpolateValue(valueFrom, valueTo, easedTime);
				audioSource.volume = valueCurrent;
			}
		}

		public static Tween<float> TweenAudioSourceVolume(this Component self, float to, float duration)
		{
			return Tween<float>.Add<Driver>(self).Finalize(duration, to);
		}

		public static Tween<float> TweenAudioSourceVolume(this GameObject self, float to, float duration)
		{
			return Tween<float>.Add<Driver>(self).Finalize(duration, to);
		}
	}
	public static class CancelAllTween
	{
		public static void TweenCancelAll(this Component self, bool includeChildren = false, bool includeInactive = false)
		{
			self.gameObject.TweenCancelAll(includeChildren, includeInactive);
		}

		public static void TweenCancelAll(this GameObject self, bool includeChildren = false, bool includeInactive = false)
		{
			ITween[] array = (includeChildren ? self.GetComponentsInChildren<ITween>(includeInactive) : self.GetComponents<ITween>());
			for (int i = 0; i < array.Length; i++)
			{
				array[i].Cancel();
			}
		}
	}
	public static class CanvasGroupAlphaTween
	{
		private class Driver : Tween<float>
		{
			private CanvasGroup canvasGroup;

			public override bool OnInitialize()
			{
				canvasGroup = base.gameObject.GetComponent<CanvasGroup>();
				return canvasGroup != null;
			}

			public override float OnGetFrom()
			{
				return canvasGroup.alpha;
			}

			public override void OnUpdate(float easedTime)
			{
				valueCurrent = InterpolateValue(valueFrom, valueTo, easedTime);
				canvasGroup.alpha = valueCurrent;
			}
		}

		public static Tween<float> TweenCanvasGroupAlpha(this Component self, float to, float duration)
		{
			return Tween<float>.Add<Driver>(self).Finalize(duration, to);
		}

		public static Tween<float> TweenCanvasGroupAlpha(this GameObject self, float to, float duration)
		{
			return Tween<float>.Add<Driver>(self).Finalize(duration, to);
		}
	}
	public static class DelayedInvokeTween
	{
		private class Driver : Tween<bool>
		{
			public override bool OnInitialize()
			{
				return true;
			}

			public override bool OnGetFrom()
			{
				return true;
			}

			public override void OnUpdate(float easedTime)
			{
			}
		}

		public static Tween<bool> TweenDelayedInvoke(this Component self, float duration, Action onComplete)
		{
			return Tween<bool>.Add<Driver>(self).SetOnComplete(onComplete).Finalize(duration, valueTo: false);
		}

		public static Tween<bool> TweenDelayedInvoke(this GameObject self, float duration, Action onComplete)
		{
			return Tween<bool>.Add<Driver>(self).SetOnComplete(onComplete).Finalize(duration, valueTo: false);
		}
	}
	public static class EulerAnglesTween
	{
		private class Driver : Tween<Vector3>
		{
			private Quaternion quaternionValueFrom;

			private Quaternion quaternionValueTo;

			public override bool OnInitialize()
			{
				quaternionValueTo = Quaternion.Euler(valueTo);
				return true;
			}

			public override Vector3 OnGetFrom()
			{
				Vector3 eulerAngles = base.transform.eulerAngles;
				quaternionValueFrom = Quaternion.Euler(eulerAngles);
				return eulerAngles;
			}

			public override void OnUpdate(float easedTime)
			{
				if (easedTime == 0f)
				{
					base.transform.rotation = quaternionValueFrom;
				}
				else if (easedTime == 1f)
				{
					base.transform.rotation = quaternionValueTo;
				}
				else
				{
					base.transform.rotation = Quaternion.Lerp(quaternionValueFrom, quaternionValueTo, easedTime);
				}
			}
		}

		public static Tween<Vector3> TweenRotation(this Component self, Vector3 to, float duration)
		{
			return Tween<Vector3>.Add<Driver>(self).Finalize(duration, to);
		}

		public static Tween<Vector3> TweenRotation(this GameObject self, Vector3 to, float duration)
		{
			return Tween<Vector3>.Add<Driver>(self).Finalize(duration, to);
		}
	}
	public static class EulerAnglesXTween
	{
		private class Driver : Tween<float>
		{
			private Quaternion quaternionValueFrom;

			private Quaternion quaternionValueTo;

			public override bool OnInitialize()
			{
				return true;
			}

			public override float OnGetFrom()
			{
				return base.transform.eulerAngles.x;
			}

			public override void OnUpdate(float easedTime)
			{
				quaternionValueFrom = Quaternion.Euler(valueFrom, base.transform.eulerAngles.y, base.transform.eulerAngles.z);
				quaternionValueTo = Quaternion.Euler(valueTo, base.transform.eulerAngles.y, base.transform.eulerAngles.z);
				base.transform.rotation = Quaternion.Lerp(quaternionValueFrom, quaternionValueTo, easedTime);
			}
		}

		public static Tween<float> TweenRotationX(this Component self, float to, float duration)
		{
			return Tween<float>.Add<Driver>(self).Finalize(duration, to);
		}

		public static Tween<float> TweenRotationX(this GameObject self, float to, float duration)
		{
			return Tween<float>.Add<Driver>(self).Finalize(duration, to);
		}
	}
	public static class EulerAnglesYTween
	{
		private class Driver : Tween<float>
		{
			private Quaternion quaternionValueFrom;

			private Quaternion quaternionValueTo;

			public override bool OnInitialize()
			{
				return true;
			}

			public override float OnGetFrom()
			{
				return base.transform.eulerAngles.y;
			}

			public override void OnUpdate(float easedTime)
			{
				quaternionValueFrom = Quaternion.Euler(base.transform.eulerAngles.x, valueFrom, base.transform.eulerAngles.z);
				quaternionValueTo = Quaternion.Euler(base.transform.eulerAngles.x, valueTo, base.transform.eulerAngles.z);
				base.transform.rotation = Quaternion.Lerp(quaternionValueFrom, quaternionValueTo, easedTime);
			}
		}

		public static Tween<float> TweenRotationY(this Component self, float to, float duration)
		{
			return Tween<float>.Add<Driver>(self).Finalize(duration, to);
		}

		public static Tween<float> TweenRotationY(this GameObject self, float to, float duration)
		{
			return Tween<float>.Add<Driver>(self).Finalize(duration, to);
		}
	}
	public static class EulerAnglesZTween
	{
		private class Driver : Tween<float>
		{
			private Quaternion quaternionValueFrom;

			private Quaternion quaternionValueTo;

			public override bool OnInitialize()
			{
				return true;
			}

			public override float OnGetFrom()
			{
				return base.transform.eulerAngles.z;
			}

			public override void OnUpdate(float easedTime)
			{
				quaternionValueFrom = Quaternion.Euler(base.transform.eulerAngles.x, base.transform.eulerAngles.y, valueFrom);
				quaternionValueTo = Quaternion.Euler(base.transform.eulerAngles.x, base.transform.eulerAngles.y, valueTo);
				base.transform.rotation = Quaternion.Lerp(quaternionValueFrom, quaternionValueTo, easedTime);
			}
		}

		public static Tween<float> TweenRotationZ(this Component self, float to, float duration)
		{
			return Tween<float>.Add<Driver>(self).Finalize(duration, to);
		}

		public static Tween<float> TweenRotationZ(this GameObject self, float to, float duration)
		{
			return Tween<float>.Add<Driver>(self).Finalize(duration, to);
		}
	}
	public static class GraphicAlphaTween
	{
		private class Driver : Tween<float>
		{
			private Graphic graphic;

			private Color color;

			public override bool OnInitialize()
			{
				graphic = base.gameObject.GetComponent<Graphic>();
				return graphic != null;
			}

			public override float OnGetFrom()
			{
				return graphic.color.a;
			}

			public override void OnUpdate(float easedTime)
			{
				color = graphic.color;
				valueCurrent = InterpolateValue(valueFrom, valueTo, easedTime);
				color.a = valueCurrent;
				graphic.color = color;
			}
		}

		public static Tween<float> TweenGraphicAlpha(this Component self, float to, float duration)
		{
			return Tween<float>.Add<Driver>(self).Finalize(duration, to);
		}

		public static Tween<float> TweenGraphicAlpha(this GameObject self, float to, float duration)
		{
			return Tween<float>.Add<Driver>(self).Finalize(duration, to);
		}
	}
	public static class GraphicColorTween
	{
		private class Driver : Tween<Color>
		{
			private Graphic graphic;

			public override bool OnInitialize()
			{
				graphic = base.gameObject.GetComponent<Graphic>();
				return graphic != null;
			}

			public override Color OnGetFrom()
			{
				return graphic.color;
			}

			public override void OnUpdate(float easedTime)
			{
				valueCurrent.r = InterpolateValue(valueFrom.r, valueTo.r, easedTime);
				valueCurrent.g = InterpolateValue(valueFrom.g, valueTo.g, easedTime);
				valueCurrent.b = InterpolateValue(valueFrom.b, valueTo.b, easedTime);
				valueCurrent.a = InterpolateValue(valueFrom.a, valueTo.a, easedTime);
				graphic.color = valueCurrent;
			}
		}

		public static Tween<Color> TweenGraphicColor(this Component self, Color to, float duration)
		{
			return Tween<Color>.Add<Driver>(self).Finalize(duration, to);
		}

		public static Tween<Color> TweenGraphicColor(this GameObject self, Color to, float duration)
		{
			return Tween<Color>.Add<Driver>(self).Finalize(duration, to);
		}
	}
	public static class ImageFillAmountTween
	{
		private class Driver : Tween<float>
		{
			private Image image;

			public override bool OnInitialize()
			{
				image = base.gameObject.GetComponent<Image>();
				return image != null;
			}

			public override float OnGetFrom()
			{
				return image.fillAmount;
			}

			public override void OnUpdate(float easedTime)
			{
				valueCurrent = InterpolateValue(valueFrom, valueTo, easedTime);
				image.fillAmount = valueCurrent;
			}
		}

		public static Tween<float> TweenImageFillAmount(this Component self, float to, float duration)
		{
			return Tween<float>.Add<Driver>(self).Finalize(duration, to);
		}

		public static Tween<float> TweenImageFillAmount(this GameObject self, float to, float duration)
		{
			return Tween<float>.Add<Driver>(self).Finalize(duration, to);
		}
	}
	public static class LocalEulerAnglesTween
	{
		private class Driver : Tween<Vector3>
		{
			private Quaternion quaternionValueFrom;

			private Quaternion quaternionValueTo;

			public override bool OnInitialize()
			{
				quaternionValueTo = Quaternion.Euler(valueTo);
				return true;
			}

			public override Vector3 OnGetFrom()
			{
				Vector3 localEulerAngles = base.transform.localEulerAngles;
				quaternionValueFrom = Quaternion.Euler(localEulerAngles);
				return localEulerAngles;
			}

			public override void OnUpdate(float easedTime)
			{
				if (easedTime == 0f)
				{
					base.transform.localRotation = quaternionValueFrom;
				}
				else if (easedTime == 1f)
				{
					base.transform.localRotation = quaternionValueTo;
				}
				else
				{
					base.transform.localRotation = Quaternion.Lerp(quaternionValueFrom, quaternionValueTo, easedTime);
				}
			}
		}

		public static Tween<Vector3> TweenLocalRotation(this Component self, Vector3 to, float duration)
		{
			return Tween<Vector3>.Add<Driver>(self).Finalize(duration, to);
		}

		public static Tween<Vector3> TweenLocalRotation(this GameObject self, Vector3 to, float duration)
		{
			return Tween<Vector3>.Add<Driver>(self).Finalize(duration, to);
		}
	}
	public static class LocalEulerAnglesXTween
	{
		private class Driver : Tween<float>
		{
			private Quaternion quaternionValueFrom;

			private Quaternion quaternionValueTo;

			public override bool OnInitialize()
			{
				return true;
			}

			public override float OnGetFrom()
			{
				return base.transform.localEulerAngles.x;
			}

			public override void OnUpdate(float easedTime)
			{
				quaternionValueFrom = Quaternion.Euler(valueFrom, base.transform.localEulerAngles.y, base.transform.localEulerAngles.z);
				quaternionValueTo = Quaternion.Euler(valueTo, base.transform.localEulerAngles.y, base.transform.localEulerAngles.z);
				base.transform.localRotation = Quaternion.Lerp(quaternionValueFrom, quaternionValueTo, easedTime);
			}
		}

		public static Tween<float> TweenLocalRotationX(this Component self, float to, float duration)
		{
			return Tween<float>.Add<Driver>(self).Finalize(duration, to);
		}

		public static Tween<float> TweenLocalRotationX(this GameObject self, float to, float duration)
		{
			return Tween<float>.Add<Driver>(self).Finalize(duration, to);
		}
	}
	public static class LocalEulerAnglesYTween
	{
		private class Driver : Tween<float>
		{
			private Quaternion quaternionValueFrom;

			private Quaternion quaternionValueTo;

			public override bool OnInitialize()
			{
				return true;
			}

			public override float OnGetFrom()
			{
				return base.transform.localEulerAngles.y;
			}

			public override void OnUpdate(float easedTime)
			{
				quaternionValueFrom = Quaternion.Euler(base.transform.localEulerAngles.x, valueFrom, base.transform.localEulerAngles.z);
				quaternionValueTo = Quaternion.Euler(base.transform.localEulerAngles.x, valueTo, base.transform.localEulerAngles.z);
				base.transform.localRotation = Quaternion.Lerp(quaternionValueFrom, quaternionValueTo, easedTime);
			}
		}

		public static Tween<float> TweenLocalRotationY(this Component self, float to, float duration)
		{
			return Tween<float>.Add<Driver>(self).Finalize(duration, to);
		}

		public static Tween<float> TweenLocalRotationY(this GameObject self, float to, float duration)
		{
			return Tween<float>.Add<Driver>(self).Finalize(duration, to);
		}
	}
	public static class LocalEulerAnglesZTween
	{
		private class Driver : Tween<float>
		{
			private Quaternion quaternionValueFrom;

			private Quaternion quaternionValueTo;

			public override bool OnInitialize()
			{
				return true;
			}

			public override float OnGetFrom()
			{
				return base.transform.localEulerAngles.z;
			}

			public override void OnUpdate(float easedTime)
			{
				quaternionValueFrom = Quaternion.Euler(base.transform.localEulerAngles.x, base.transform.localEulerAngles.y, valueFrom);
				quaternionValueTo = Quaternion.Euler(base.transform.localEulerAngles.x, base.transform.localEulerAngles.y, valueTo);
				base.transform.localRotation = Quaternion.Lerp(quaternionValueFrom, quaternionValueTo, easedTime);
			}
		}

		public static Tween<float> TweenLocalRotationZ(this Component self, float to, float duration)
		{
			return Tween<float>.Add<Driver>(self).Finalize(duration, to);
		}

		public static Tween<float> TweenLocalRotationZ(this GameObject self, float to, float duration)
		{
			return Tween<float>.Add<Driver>(self).Finalize(duration, to);
		}
	}
	public static class LocalPositionTween
	{
		private class Driver : Tween<Vector3>
		{
			public override bool OnInitialize()
			{
				return true;
			}

			public override Vector3 OnGetFrom()
			{
				return base.transform.localPosition;
			}

			public override void OnUpdate(float easedTime)
			{
				valueCurrent.x = InterpolateValue(valueFrom.x, valueTo.x, easedTime);
				valueCurrent.y = InterpolateValue(valueFrom.y, valueTo.y, easedTime);
				valueCurrent.z = InterpolateValue(valueFrom.z, valueTo.z, easedTime);
				base.transform.localPosition = valueCurrent;
			}
		}

		public static Tween<Vector3> TweenLocalPosition(this Component self, Vector3 to, float duration)
		{
			return Tween<Vector3>.Add<Driver>(self).Finalize(duration, to);
		}

		public static Tween<Vector3> TweenLocalPosition(this GameObject self, Vector3 to, float duration)
		{
			return Tween<Vector3>.Add<Driver>(self).Finalize(duration, to);
		}
	}
	public static class LocalPositionXTween
	{
		private class Driver : Tween<float>
		{
			private Vector3 localPosition;

			public override bool OnInitialize()
			{
				return true;
			}

			public override float OnGetFrom()
			{
				return base.transform.localPosition.x;
			}

			public override void OnUpdate(float easedTime)
			{
				localPosition = base.transform.localPosition;
				valueCurrent = InterpolateValue(valueFrom, valueTo, easedTime);
				localPosition.x = valueCurrent;
				base.transform.localPosition = localPosition;
			}
		}

		public static Tween<float> TweenLocalPositionX(this Component self, float to, float duration)
		{
			return Tween<float>.Add<Driver>(self).Finalize(duration, to);
		}

		public static Tween<float> TweenLocalPositionX(this GameObject self, float to, float duration)
		{
			return Tween<float>.Add<Driver>(self).Finalize(duration, to);
		}
	}
	public static class LocalPositionYTween
	{
		private class Driver : Tween<float>
		{
			private Vector3 localPosition;

			public override bool OnInitialize()
			{
				return true;
			}

			public override float OnGetFrom()
			{
				return base.transform.localPosition.y;
			}

			public override void OnUpdate(float easedTime)
			{
				localPosition = base.transform.localPosition;
				valueCurrent = InterpolateValue(valueFrom, valueTo, easedTime);
				localPosition.y = valueCurrent;
				base.transform.localPosition = localPosition;
			}
		}

		public static Tween<float> TweenLocalPositionY(this Component self, float to, float duration)
		{
			return Tween<float>.Add<Driver>(self).Finalize(duration, to);
		}

		public static Tween<float> TweenLocalPositionY(this GameObject self, float to, float duration)
		{
			return Tween<float>.Add<Driver>(self).Finalize(duration, to);
		}
	}
	public static class LocalPositionZTween
	{
		private class Driver : Tween<float>
		{
			private Vector3 localPosition;

			public override bool OnInitialize()
			{
				return true;
			}

			public override float OnGetFrom()
			{
				return base.transform.localPosition.z;
			}

			public override void OnUpdate(float easedTime)
			{
				localPosition = base.transform.localPosition;
				valueCurrent = InterpolateValue(valueFrom, valueTo, easedTime);
				localPosition.z = valueCurrent;
				base.transform.localPosition = localPosition;
			}
		}

		public static Tween<float> TweenLocalPositionZ(this Component self, float to, float duration)
		{
			return Tween<float>.Add<Driver>(self).Finalize(duration, to);
		}

		public static Tween<float> TweenLocalPositionZ(this GameObject self, float to, float duration)
		{
			return Tween<float>.Add<Driver>(self).Finalize(duration, to);
		}
	}
	public static class LocalScaleTween
	{
		private class Driver : Tween<Vector3>
		{
			public override bool OnInitialize()
			{
				return true;
			}

			public override Vector3 OnGetFrom()
			{
				return base.transform.localScale;
			}

			public override void OnUpdate(float easedTime)
			{
				valueCurrent.x = InterpolateValue(valueFrom.x, valueTo.x, easedTime);
				valueCurrent.y = InterpolateValue(valueFrom.y, valueTo.y, easedTime);
				valueCurrent.z = InterpolateValue(valueFrom.z, valueTo.z, easedTime);
				base.transform.localScale = valueCurrent;
			}
		}

		public static Tween<Vector3> TweenLocalScale(this Component self, Vector3 to, float duration)
		{
			return Tween<Vector3>.Add<Driver>(self).Finalize(duration, to);
		}

		public static Tween<Vector3> TweenLocalScale(this GameObject self, Vector3 to, float duration)
		{
			return Tween<Vector3>.Add<Driver>(self).Finalize(duration, to);
		}
	}
	public static class LocalScaleXTween
	{
		private class Driver : Tween<float>
		{
			private Vector3 localScale;

			public override bool OnInitialize()
			{
				return true;
			}

			public override float OnGetFrom()
			{
				return base.transform.localScale.x;
			}

			public override void OnUpdate(float easedTime)
			{
				localScale = base.transform.localScale;
				valueCurrent = InterpolateValue(valueFrom, valueTo, easedTime);
				localScale.x = valueCurrent;
				base.transform.localScale = localScale;
			}
		}

		public static Tween<float> TweenLocalScaleX(this Component self, float to, float duration)
		{
			return Tween<float>.Add<Driver>(self).Finalize(duration, to);
		}

		public static Tween<float> TweenLocalScaleX(this GameObject self, float to, float duration)
		{
			return Tween<float>.Add<Driver>(self).Finalize(duration, to);
		}
	}
	public static class LocalScaleYTween
	{
		private class Driver : Tween<float>
		{
			private Vector3 localScale;

			public override bool OnInitialize()
			{
				return true;
			}

			public override float OnGetFrom()
			{
				return base.transform.localScale.y;
			}

			public override void OnUpdate(float easedTime)
			{
				localScale = base.transform.localScale;
				valueCurrent = InterpolateValue(valueFrom, valueTo, easedTime);
				localScale.y = valueCurrent;
				base.transform.localScale = localScale;
			}
		}

		public static Tween<float> TweenLocalScaleY(this Component self, float to, float duration)
		{
			return Tween<float>.Add<Driver>(self).Finalize(duration, to);
		}

		public static Tween<float> TweenLocalScaleY(this GameObject self, float to, float duration)
		{
			return Tween<float>.Add<Driver>(self).Finalize(duration, to);
		}
	}
	public static class LocalScaleZTween
	{
		private class Driver : Tween<float>
		{
			private Vector3 localScale;

			public override bool OnInitialize()
			{
				return true;
			}

			public override float OnGetFrom()
			{
				return base.transform.localScale.z;
			}

			public override void OnUpdate(float easedTime)
			{
				localScale = base.transform.localScale;
				valueCurrent = InterpolateValue(valueFrom, valueTo, easedTime);
				localScale.z = valueCurrent;
				base.transform.localScale = localScale;
			}
		}

		public static Tween<float> TweenLocalScaleZ(this Component self, float to, float duration)
		{
			return Tween<float>.Add<Driver>(self).Finalize(duration, to);
		}

		public static Tween<float> TweenLocalScaleZ(this GameObject self, float to, float duration)
		{
			return Tween<float>.Add<Driver>(self).Finalize(duration, to);
		}
	}
	public static class MaterialAlphaTween
	{
		private class Driver : Tween<float>
		{
			private MeshRenderer meshRenderer;

			private Material material;

			private Color color;

			public override bool OnInitialize()
			{
				meshRenderer = base.gameObject.GetComponent<MeshRenderer>();
				if (meshRenderer != null)
				{
					material = meshRenderer.material;
				}
				return meshRenderer != null;
			}

			public override float OnGetFrom()
			{
				return material.color.a;
			}

			public override void OnUpdate(float easedTime)
			{
				color = material.color;
				valueCurrent = InterpolateValue(valueFrom, valueTo, easedTime);
				color.a = valueCurrent;
				material.color = color;
			}
		}

		public static Tween<float> TweenMaterialAlpha(this Component self, float to, float duration)
		{
			return Tween<float>.Add<Driver>(self).Finalize(duration, to);
		}

		public static Tween<float> TweenMaterialAlpha(this GameObject self, float to, float duration)
		{
			return Tween<float>.Add<Driver>(self).Finalize(duration, to);
		}
	}
	public static class MaterialColorTween
	{
		private class Driver : Tween<Color>
		{
			private MeshRenderer meshRenderer;

			private Material material;

			private Color color;

			public override bool OnInitialize()
			{
				meshRenderer = base.gameObject.GetComponent<MeshRenderer>();
				if (meshRenderer != null)
				{
					material = meshRenderer.material;
				}
				return meshRenderer != null;
			}

			public override Color OnGetFrom()
			{
				return material.color;
			}

			public override void OnUpdate(float easedTime)
			{
				color = material.color;
				valueCurrent.r = InterpolateValue(valueFrom.r, valueTo.r, easedTime);
				valueCurrent.g = InterpolateValue(valueFrom.g, valueTo.g, easedTime);
				valueCurrent.b = InterpolateValue(valueFrom.b, valueTo.b, easedTime);
				valueCurrent.a = InterpolateValue(valueFrom.a, valueTo.a, easedTime);
				color = valueCurrent;
				material.color = color;
			}
		}

		public static Tween<Color> TweenMaterialColor(this Component self, Color to, float duration)
		{
			return Tween<Color>.Add<Driver>(self).Finalize(duration, to);
		}

		public static Tween<Color> TweenMaterialColor(this GameObject self, Color to, float duration)
		{
			return Tween<Color>.Add<Driver>(self).Finalize(duration, to);
		}
	}
	public static class PositionTween
	{
		private class Driver : Tween<Vector3>
		{
			public override bool OnInitialize()
			{
				return true;
			}

			public override Vector3 OnGetFrom()
			{
				return base.transform.position;
			}

			public override void OnUpdate(float easedTime)
			{
				valueCurrent.x = InterpolateValue(valueFrom.x, valueTo.x, easedTime);
				valueCurrent.y = InterpolateValue(valueFrom.y, valueTo.y, easedTime);
				valueCurrent.z = InterpolateValue(valueFrom.z, valueTo.z, easedTime);
				base.transform.position = valueCurrent;
			}
		}

		public static Tween<Vector3> TweenPosition(this Component self, Vector3 to, float duration)
		{
			return Tween<Vector3>.Add<Driver>(self).Finalize(duration, to);
		}

		public static Tween<Vector3> TweenPosition(this GameObject self, Vector3 to, float duration)
		{
			return Tween<Vector3>.Add<Driver>(self).Finalize(duration, to);
		}
	}
	public static class PositionXTween
	{
		private class Driver : Tween<float>
		{
			private Vector3 position;

			public override bool OnInitialize()
			{
				return true;
			}

			public override float OnGetFrom()
			{
				return base.transform.position.x;
			}

			public override void OnUpdate(float easedTime)
			{
				position = base.transform.position;
				valueCurrent = InterpolateValue(valueFrom, valueTo, easedTime);
				position.x = valueCurrent;
				base.transform.position = position;
			}
		}

		public static Tween<float> TweenPositionX(this Component self, float to, float duration)
		{
			return Tween<float>.Add<Driver>(self).Finalize(duration, to);
		}

		public static Tween<float> TweenPositionX(this GameObject self, float to, float duration)
		{
			return Tween<float>.Add<Driver>(self).Finalize(duration, to);
		}
	}
	public static class PositionYTween
	{
		private class Driver : Tween<float>
		{
			private Vector3 position;

			public override bool OnInitialize()
			{
				return true;
			}

			public override float OnGetFrom()
			{
				return base.transform.position.y;
			}

			public override void OnUpdate(float easedTime)
			{
				position = base.transform.position;
				valueCurrent = InterpolateValue(valueFrom, valueTo, easedTime);
				position.y = valueCurrent;
				base.transform.position = position;
			}
		}

		public static Tween<float> TweenPositionY(this Component self, float to, float duration)
		{
			return Tween<float>.Add<Driver>(self).Finalize(duration, to);
		}

		public static Tween<float> TweenPositionY(this GameObject self, float to, float duration)
		{
			return Tween<float>.Add<Driver>(self).Finalize(duration, to);
		}
	}
	public static class PositionZTween
	{
		private class Driver : Tween<float>
		{
			private Vector3 position;

			public override bool OnInitialize()
			{
				return true;
			}

			public override float OnGetFrom()
			{
				return base.transform.position.z;
			}

			public override void OnUpdate(float easedTime)
			{
				position = base.transform.position;
				valueCurrent = InterpolateValue(valueFrom, valueTo, easedTime);
				position.z = valueCurrent;
				base.transform.position = position;
			}
		}

		public static Tween<float> TweenPositionZ(this Component self, float to, float duration)
		{
			return Tween<float>.Add<Driver>(self).Finalize(duration, to);
		}

		public static Tween<float> TweenPositionZ(this GameObject self, float to, float duration)
		{
			return Tween<float>.Add<Driver>(self).Finalize(duration, to);
		}
	}
	public static class SpriteRendererAlphaTween
	{
		private class Driver : Tween<float>
		{
			private SpriteRenderer spriteRenderer;

			private Color color;

			public override bool OnInitialize()
			{
				spriteRenderer = base.gameObject.GetComponent<SpriteRenderer>();
				return spriteRenderer != null;
			}

			public override float OnGetFrom()
			{
				return spriteRenderer.color.a;
			}

			public override void OnUpdate(float easedTime)
			{
				color = spriteRenderer.color;
				valueCurrent = InterpolateValue(valueFrom, valueTo, easedTime);
				color.a = valueCurrent;
				spriteRenderer.color = color;
			}
		}

		public static Tween<float> TweenSpriteRendererAlpha(this Component self, float to, float duration)
		{
			return Tween<float>.Add<Driver>(self).Finalize(duration, to);
		}

		public static Tween<float> TweenSpriteRendererAlpha(this GameObject self, float to, float duration)
		{
			return Tween<float>.Add<Driver>(self).Finalize(duration, to);
		}
	}
	public static class SpriteRendererColorTween
	{
		private class Driver : Tween<Color>
		{
			private SpriteRenderer spriteRenderer;

			public override bool OnInitialize()
			{
				spriteRenderer = base.gameObject.GetComponent<SpriteRenderer>();
				return spriteRenderer != null;
			}

			public override Color OnGetFrom()
			{
				return spriteRenderer.color;
			}

			public override void OnUpdate(float easedTime)
			{
				valueCurrent.r = InterpolateValue(valueFrom.r, valueTo.r, easedTime);
				valueCurrent.g = InterpolateValue(valueFrom.g, valueTo.g, easedTime);
				valueCurrent.b = InterpolateValue(valueFrom.b, valueTo.b, easedTime);
				valueCurrent.a = InterpolateValue(valueFrom.a, valueTo.a, easedTime);
				spriteRenderer.color = valueCurrent;
			}
		}

		public static Tween<Color> TweenSpriteRendererColor(this Component self, Color to, float duration)
		{
			return Tween<Color>.Add<Driver>(self).Finalize(duration, to);
		}

		public static Tween<Color> TweenSpriteRendererColor(this GameObject self, Color to, float duration)
		{
			return Tween<Color>.Add<Driver>(self).Finalize(duration, to);
		}
	}
	public static class TextMeshAlphaTween
	{
		private class Driver : Tween<float>
		{
			private TextMesh textMesh;

			private Color color;

			public override bool OnInitialize()
			{
				textMesh = base.gameObject.GetComponent<TextMesh>();
				return textMesh != null;
			}

			public override float OnGetFrom()
			{
				return textMesh.color.a;
			}

			public override void OnUpdate(float easedTime)
			{
				color = textMesh.color;
				valueCurrent = InterpolateValue(valueFrom, valueTo, easedTime);
				color.a = valueCurrent;
				textMesh.color = color;
			}
		}

		public static Tween<float> TweenTextMeshAlpha(this Component self, float to, float duration)
		{
			return Tween<float>.Add<Driver>(self).Finalize(duration, to);
		}

		public static Tween<float> TweenTextMeshAlpha(this GameObject self, float to, float duration)
		{
			return Tween<float>.Add<Driver>(self).Finalize(duration, to);
		}
	}
	public static class ValueColorTween
	{
		private class Driver : Tween<Color>
		{
			private Action<Color> onUpdate;

			private bool hasOnUpdate;

			public override bool OnInitialize()
			{
				return true;
			}

			public override Color OnGetFrom()
			{
				return Color.black;
			}

			public override void OnUpdate(float easedTime)
			{
				valueCurrent.r = InterpolateValue(valueFrom.r, valueTo.r, easedTime);
				valueCurrent.g = InterpolateValue(valueFrom.g, valueTo.g, easedTime);
				valueCurrent.b = InterpolateValue(valueFrom.b, valueTo.b, easedTime);
				valueCurrent.a = InterpolateValue(valueFrom.a, valueTo.a, easedTime);
				if (hasOnUpdate)
				{
					onUpdate(valueCurrent);
				}
			}

			public Tween<Color> SetOnUpdate(Action<Color> onUpdate)
			{
				this.onUpdate = onUpdate;
				hasOnUpdate = true;
				return this;
			}
		}

		public static Tween<Color> TweenValueColor(this Component self, Color to, float duration, Action<Color> onUpdate)
		{
			return Tween<Color>.Add<Driver>(self).SetOnUpdate(onUpdate).Finalize(duration, to);
		}

		public static Tween<Color> TweenValueColor(this GameObject self, Color to, float duration, Action<Color> onUpdate)
		{
			return Tween<Color>.Add<Driver>(self).SetOnUpdate(onUpdate).Finalize(duration, to);
		}
	}
	public static class ValueFloatTween
	{
		private class Driver : Tween<float>
		{
			private Action<float> onUpdate;

			private bool hasOnUpdate;

			public override bool OnInitialize()
			{
				return true;
			}

			public override float OnGetFrom()
			{
				return 0f;
			}

			public override void OnUpdate(float easedTime)
			{
				valueCurrent = InterpolateValue(valueFrom, valueTo, easedTime);
				if (hasOnUpdate)
				{
					onUpdate(valueCurrent);
				}
			}

			public Tween<float> SetOnUpdate(Action<float> onUpdate)
			{
				this.onUpdate = onUpdate;
				hasOnUpdate = true;
				return this;
			}
		}

		public static Tween<float> TweenValueFloat(this Component self, float to, float duration, Action<float> onUpdate)
		{
			return Tween<float>.Add<Driver>(self).SetOnUpdate(onUpdate).Finalize(duration, to);
		}

		public static Tween<float> TweenValueFloat(this GameObject self, float to, float duration, Action<float> onUpdate)
		{
			return Tween<float>.Add<Driver>(self).SetOnUpdate(onUpdate).Finalize(duration, to);
		}
	}
}
namespace EFramework.Tweens.Core
{
	public enum EaseType
	{
		Linear = 0,
		SineIn = 10,
		SineOut = 11,
		SineInOut = 12,
		QuadIn = 20,
		QuadOut = 21,
		QuadInOut = 22,
		CubicIn = 30,
		CubicOut = 31,
		CubicInOut = 32,
		QuartIn = 40,
		QuartOut = 41,
		QuartInOut = 42,
		QuintIn = 50,
		QuintOut = 51,
		QuintInOut = 52,
		ExpoIn = 60,
		ExpoOut = 61,
		ExpoInOut = 62,
		CircIn = 70,
		CircOut = 71,
		CircInOut = 72,
		BackIn = 80,
		BackOut = 81,
		BackInOut = 82,
		ElasticIn = 90,
		ElasticOut = 91,
		ElasticInOut = 92,
		BounceIn = 100,
		BounceOut = 101,
		BounceInOut = 102
	}
	public static class Easer
	{
		private const float constantA = 1.70158f;

		private const float constantB = 2.5949094f;

		private const float constantC = 2.70158f;

		private const float constantD = (float)Math.PI * 2f / 3f;

		private const float constantE = (float)Math.PI * 4f / 9f;

		private const float constantF = 7.5625f;

		private const float constantG = 2.75f;

		public static float Apply(EaseType ease, float time)
		{
			return ease switch
			{
				EaseType.Linear => Linear(time), 
				EaseType.SineIn => SineIn(time), 
				EaseType.SineOut => SineOut(time), 
				EaseType.SineInOut => SineInOut(time), 
				EaseType.QuadIn => QuadIn(time), 
				EaseType.QuadOut => QuadOut(time), 
				EaseType.QuadInOut => QuadInOut(time), 
				EaseType.CubicIn => CubicIn(time), 
				EaseType.CubicOut => CubicOut(time), 
				EaseType.CubicInOut => CubicInOut(time), 
				EaseType.QuartIn => QuartIn(time), 
				EaseType.QuartOut => QuartOut(time), 
				EaseType.QuartInOut => QuartInOut(time), 
				EaseType.QuintIn => QuintIn(time), 
				EaseType.QuintOut => QuintOut(time), 
				EaseType.QuintInOut => QuintInOut(time), 
				EaseType.ExpoIn => ExpoIn(time), 
				EaseType.ExpoOut => ExpoOut(time), 
				EaseType.ExpoInOut => ExpoInOut(time), 
				EaseType.CircIn => CircIn(time), 
				EaseType.CircOut => CircOut(time), 
				EaseType.CircInOut => CircInOut(time), 
				EaseType.BackIn => BackIn(time), 
				EaseType.BackOut => BackOut(time), 
				EaseType.BackInOut => BackInOut(time), 
				EaseType.ElasticIn => ElasticIn(time), 
				EaseType.ElasticOut => ElasticOut(time), 
				EaseType.ElasticInOut => ElasticInOut(time), 
				EaseType.BounceIn => BounceIn(time), 
				EaseType.BounceOut => BounceOut(time), 
				EaseType.BounceInOut => BounceInOut(time), 
				_ => 0f, 
			};
		}

		private static float Linear(float time)
		{
			return time;
		}

		private static float SineIn(float time)
		{
			return 1f - Mathf.Cos(time * (float)Math.PI / 2f);
		}

		private static float SineOut(float time)
		{
			return Mathf.Sin(time * (float)Math.PI / 2f);
		}

		private static float SineInOut(float time)
		{
			return (0f - (Mathf.Cos((float)Math.PI * time) - 1f)) / 2f;
		}

		private static float QuadIn(float time)
		{
			return time * time;
		}

		private static float QuadOut(float time)
		{
			return 1f - (1f - time) * (1f - time);
		}

		private static float QuadInOut(float time)
		{
			if (!(time < 0.5f))
			{
				return 1f - Mathf.Pow(-2f * time + 2f, 2f) / 2f;
			}
			return 2f * time * time;
		}

		private static float CubicIn(float time)
		{
			return time * time * time;
		}

		private static float CubicOut(float time)
		{
			return 1f - Mathf.Pow(1f - time, 3f);
		}

		private static float CubicInOut(float time)
		{
			if (!(time < 0.5f))
			{
				return 1f - Mathf.Pow(-2f * time + 2f, 3f) / 2f;
			}
			return 4f * time * time * time;
		}

		private static float QuartIn(float time)
		{
			return time * time * time * time;
		}

		private static float QuartOut(float time)
		{
			return 1f - Mathf.Pow(1f - time, 4f);
		}

		private static float QuartInOut(float time)
		{
			if (!((double)time < 0.5))
			{
				return 1f - Mathf.Pow(-2f * time + 2f, 4f) / 2f;
			}
			return 8f * time * time * time * time;
		}

		private static float QuintIn(float time)
		{
			return time * time * time * time * time;
		}

		private static float QuintOut(float time)
		{
			return 1f - Mathf.Pow(1f - time, 5f);
		}

		private static float QuintInOut(float time)
		{
			if (!(time < 0.5f))
			{
				return 1f - Mathf.Pow(-2f * time + 2f, 5f) / 2f;
			}
			return 16f * time * time * time * time * time;
		}

		private static float ExpoIn(float time)
		{
			if (time != 0f)
			{
				return Mathf.Pow(2f, 10f * time - 10f);
			}
			return 0f;
		}

		private static float ExpoOut(float time)
		{
			if (time != 1f)
			{
				return 1f - Mathf.Pow(2f, -10f * time);
			}
			return 1f;
		}

		private static float ExpoInOut(float time)
		{
			if (time != 0f)
			{
				if (time != 1f)
				{
					if (!((double)time < 0.5))
					{
						return (2f - Mathf.Pow(2f, -20f * time + 10f)) / 2f;
					}
					return Mathf.Pow(2f, 20f * time - 10f) / 2f;
				}
				return 1f;
			}
			return 0f;
		}

		private static float CircIn(float time)
		{
			return 1f - Mathf.Sqrt(1f - Mathf.Pow(time, 2f));
		}

		private static float CircOut(float time)
		{
			return Mathf.Sqrt(1f - Mathf.Pow(time - 1f, 2f));
		}

		private static float CircInOut(float time)
		{
			if (!((double)time < 0.5))
			{
				return (Mathf.Sqrt(1f - Mathf.Pow(-2f * time + 2f, 2f)) + 1f) / 2f;
			}
			return (1f - Mathf.Sqrt(1f - Mathf.Pow(2f * time, 2f))) / 2f;
		}

		private static float BackIn(float time)
		{
			return 2.70158f * time * time * time - 1.70158f * time * time;
		}

		private static float BackOut(float time)
		{
			return 1f + 2.70158f * Mathf.Pow(time - 1f, 3f) + 1.70158f * Mathf.Pow(time - 1f, 2f);
		}

		private static float BackInOut(float time)
		{
			if (!((double)time < 0.5))
			{
				return (Mathf.Pow(2f * time - 2f, 2f) * (3.5949094f * (time * 2f - 2f) + 2.5949094f) + 2f) / 2f;
			}
			return Mathf.Pow(2f * time, 2f) * (7.189819f * time - 2.5949094f) / 2f;
		}

		private static float ElasticIn(float time)
		{
			if (time != 0f)
			{
				if (time != 1f)
				{
					return (0f - Mathf.Pow(2f, 10f * time - 10f)) * Mathf.Sin((time * 10f - 10.75f) * ((float)Math.PI * 2f / 3f));
				}
				return 1f;
			}
			return 0f;
		}

		private static float ElasticOut(float time)
		{
			if (time != 0f)
			{
				if (time != 1f)
				{
					return Mathf.Pow(2f, -10f * time) * Mathf.Sin((time * 10f - 0.75f) * ((float)Math.PI * 2f / 3f)) + 1f;
				}
				return 1f;
			}
			return 0f;
		}

		private static float ElasticInOut(float time)
		{
			if (time != 0f)
			{
				if (time != 1f)
				{
					if (!((double)time < 0.5))
					{
						return Mathf.Pow(2f, -20f * time + 10f) * Mathf.Sin((20f * time - 11.125f) * ((float)Math.PI * 4f / 9f)) / 2f + 1f;
					}
					return (0f - Mathf.Pow(2f, 20f * time - 10f) * Mathf.Sin((20f * time - 11.125f) * ((float)Math.PI * 4f / 9f))) / 2f;
				}
				return 1f;
			}
			return 0f;
		}

		private static float BounceIn(float time)
		{
			return 1f - BounceOut(1f - time);
		}

		private static float BounceOut(float time)
		{
			if (time < 0.36363637f)
			{
				return 7.5625f * time * time;
			}
			if (time < 0.72727275f)
			{
				return 7.5625f * (time -= 0.54545456f) * time + 0.75f;
			}
			if (time < 0.90909094f)
			{
				return 7.5625f * (time -= 0.8181818f) * time + 0.9375f;
			}
			return 7.5625f * (time -= 21f / 22f) * time + 63f / 64f;
		}

		private static float BounceInOut(float time)
		{
			if (!(time < 0.5f))
			{
				return (1f + BounceOut(2f * time - 1f)) / 2f;
			}
			return (1f - BounceOut(1f - 2f * time)) / 2f;
		}
	}
	public interface ITween
	{
		void Cancel();
	}
	public abstract class Tween<DriverValueType> : MonoBehaviour, ITween
	{
		internal DriverValueType valueFrom;

		internal DriverValueType valueTo;

		internal DriverValueType valueCurrent;

		private bool isPaused;

		private float time;

		private EaseType ease;

		private bool isDecommissioned;

		private bool isInfinite;

		private bool didOverwriteFrom;

		private bool hasPingPong;

		private bool isPlayingForward = true;

		private bool timeDidReachEnd;

		private bool hasLoopCount;

		private int loopCount;

		private bool hasDuration;

		private float duration;

		private bool hasDelay;

		private float delay;

		private bool goToFirstFrameImmediately;

		private bool hasOvershooting;

		private float overshooting;

		private Action onComplete;

		private bool hasOnComplete;

		private Action onCancel;

		private bool hasOnCancel;

		public abstract bool OnInitialize();

		public abstract DriverValueType OnGetFrom();

		public abstract void OnUpdate(float easedTime);

		private void Start()
		{
			if (!OnInitialize())
			{
				Decommission();
			}
			else if (!hasDelay || goToFirstFrameImmediately)
			{
				if (!didOverwriteFrom)
				{
					valueFrom = OnGetFrom();
				}
				OnUpdate(Easer.Apply(ease, 0f));
			}
		}

		private void OnDisable()
		{
			if (!timeDidReachEnd)
			{
				Decommission();
			}
		}

		private void Update()
		{
			if (isDecommissioned || isPaused)
			{
				return;
			}
			if (hasDelay)
			{
				delay -= Time.deltaTime;
				if (delay <= 0f)
				{
					hasDelay = false;
					if (!didOverwriteFrom)
					{
						valueFrom = OnGetFrom();
					}
					OnUpdate(Easer.Apply(ease, 0f));
				}
				return;
			}
			if (!hasDuration)
			{
				OnUpdate(Easer.Apply(ease, 1f));
				Decommission();
				return;
			}
			float num = Time.deltaTime / duration;
			time += (isPlayingForward ? num : (0f - num));
			if (time > 1f)
			{
				time = 1f;
				if (hasPingPong)
				{
					isPlayingForward = false;
				}
				else if (!isInfinite)
				{
					timeDidReachEnd = true;
				}
				else
				{
					time = 0f;
				}
			}
			else if (hasPingPong && time < 0f)
			{
				time = 0f;
				isPlayingForward = true;
				if (!isInfinite)
				{
					timeDidReachEnd = true;
				}
			}
			OnUpdate(Easer.Apply(ease, time));
			if (!timeDidReachEnd)
			{
				return;
			}
			if (hasLoopCount && loopCount > 1)
			{
				timeDidReachEnd = false;
				loopCount--;
				time = 0f;
				return;
			}
			if (hasOnComplete)
			{
				onComplete();
			}
			Decommission();
		}

		private void Decommission()
		{
			isDecommissioned = true;
			UnityEngine.Object.Destroy(this);
		}

		internal float InterpolateValue(float from, float to, float value)
		{
			if (hasOvershooting)
			{
				if (value > 1f)
				{
					value -= (value - 1f) / (overshooting + 1f);
				}
				else if (time < 0f)
				{
					value -= value / (overshooting + 1f);
				}
			}
			return from * (1f - value) + to * value;
		}

		internal Tween<DriverValueType> Finalize(float duration, DriverValueType valueTo)
		{
			if (!base.gameObject.activeInHierarchy)
			{
				Decommission();
			}
			else
			{
				this.duration = duration;
				hasDuration = duration > 0f;
				this.valueTo = valueTo;
			}
			return this;
		}

		public void Cancel()
		{
			if (hasOnCancel)
			{
				onCancel();
			}
			Decommission();
		}

		public Tween<DriverValueType> SetFrom(DriverValueType valueFrom)
		{
			didOverwriteFrom = true;
			this.valueFrom = valueFrom;
			return this;
		}

		public Tween<DriverValueType> SetOnComplete(Action onComplete)
		{
			hasOnComplete = true;
			this.onComplete = onComplete;
			return this;
		}

		public Tween<DriverValueType> SetOnCancel(Action onCancel)
		{
			hasOnCancel = true;
			this.onCancel = onCancel;
			return this;
		}

		public Tween<DriverValueType> SetPingPong()
		{
			hasPingPong = true;
			return this;
		}

		public Tween<DriverValueType> SetLoopCount(int loopCount)
		{
			hasLoopCount = true;
			this.loopCount = loopCount;
			return this;
		}

		public Tween<DriverValueType> SetInfinite()
		{
			isInfinite = true;
			return this;
		}

		public Tween<DriverValueType> SetDelay(float delay, bool goToFirstFrameImmediately = false)
		{
			this.delay = delay;
			hasDelay = true;
			this.goToFirstFrameImmediately = goToFirstFrameImmediately;
			return this;
		}

		public Tween<DriverValueType> SetRandomTime()
		{
			time = UnityEngine.Random.Range(0f, 1f);
			return this;
		}

		public Tween<DriverValueType> SetTime(float time)
		{
			this.time = time;
			return this;
		}

		public Tween<DriverValueType> SetPaused(bool isPaused)
		{
			this.isPaused = isPaused;
			return this;
		}

		public Tween<DriverValueType> SetOvershooting(float overshooting)
		{
			this.overshooting = overshooting;
			hasOvershooting = true;
			return this;
		}

		public Tween<DriverValueType> SetEase(EaseType ease)
		{
			this.ease = ease;
			return this;
		}

		public Tween<DriverValueType> SetEaseLinear()
		{
			ease = EaseType.Linear;
			return this;
		}

		public Tween<DriverValueType> SetEaseSineIn()
		{
			ease = EaseType.SineIn;
			return this;
		}

		public Tween<DriverValueType> SetEaseSineOut()
		{
			ease = EaseType.SineOut;
			return this;
		}

		public Tween<DriverValueType> SetEaseSineInOut()
		{
			ease = EaseType.SineInOut;
			return this;
		}

		public Tween<DriverValueType> SetEaseQuadIn()
		{
			ease = EaseType.QuadIn;
			return this;
		}

		public Tween<DriverValueType> SetEaseQuadOut()
		{
			ease = EaseType.QuadOut;
			return this;
		}

		public Tween<DriverValueType> SetEaseQuadInOut()
		{
			ease = EaseType.QuadInOut;
			return this;
		}

		public Tween<DriverValueType> SetEaseCubicIn()
		{
			ease = EaseType.CubicIn;
			return this;
		}

		public Tween<DriverValueType> SetEaseCubicOut()
		{
			ease = EaseType.CubicOut;
			return this;
		}

		public Tween<DriverValueType> SetEaseCubicInOut()
		{
			ease = EaseType.CubicInOut;
			return this;
		}

		public Tween<DriverValueType> SetEaseQuartIn()
		{
			ease = EaseType.QuartIn;
			return this;
		}

		public Tween<DriverValueType> SetEaseQuartOut()
		{
			ease = EaseType.QuartOut;
			return this;
		}

		public Tween<DriverValueType> SetEaseQuartInOut()
		{
			ease = EaseType.QuartInOut;
			return this;
		}

		public Tween<DriverValueType> SetEaseQuintIn()
		{
			ease = EaseType.QuintIn;
			return this;
		}

		public Tween<DriverValueType> SetEaseQuintOut()
		{
			ease = EaseType.QuintOut;
			return this;
		}

		public Tween<DriverValueType> SetEaseQuintInOut()
		{
			ease = EaseType.QuintInOut;
			return this;
		}

		public Tween<DriverValueType> SetEaseExpoIn()
		{
			ease = EaseType.ExpoIn;
			return this;
		}

		public Tween<DriverValueType> SetEaseExpoOut()
		{
			ease = EaseType.ExpoOut;
			return this;
		}

		public Tween<DriverValueType> SetEaseExpoInOut()
		{
			ease = EaseType.ExpoInOut;
			return this;
		}

		public Tween<DriverValueType> SetEaseCircIn()
		{
			ease = EaseType.CircIn;
			return this;
		}

		public Tween<DriverValueType> SetEaseCircOut()
		{
			ease = EaseType.CircOut;
			return this;
		}

		public Tween<DriverValueType> SetEaseCircInOut()
		{
			ease = EaseType.CircInOut;
			return this;
		}

		public Tween<DriverValueType> SetEaseBackIn()
		{
			ease = EaseType.BackIn;
			return this;
		}

		public Tween<DriverValueType> SetEaseBackOut()
		{
			ease = EaseType.BackOut;
			return this;
		}

		public Tween<DriverValueType> SetEaseBackInOut()
		{
			ease = EaseType.BackInOut;
			return this;
		}

		public Tween<DriverValueType> SetEaseElasticIn()
		{
			ease = EaseType.ElasticIn;
			return this;
		}

		public Tween<DriverValueType> SetEaseElasticOut()
		{
			ease = EaseType.ElasticOut;
			return this;
		}

		public Tween<DriverValueType> SetEaseElasticInOut()
		{
			ease = EaseType.ElasticInOut;
			return this;
		}

		public Tween<DriverValueType> SetEaseBounceIn()
		{
			ease = EaseType.BounceIn;
			return this;
		}

		public Tween<DriverValueType> SetEaseBounceOut()
		{
			ease = EaseType.BounceOut;
			return this;
		}

		public Tween<DriverValueType> SetEaseBounceInOut()
		{
			ease = EaseType.BounceInOut;
			return this;
		}

		internal static Driver Add<Driver>(GameObject gameObject) where Driver : Tween<DriverValueType>
		{
			return gameObject.AddComponent<Driver>();
		}

		internal static Driver Add<Driver>(Component component) where Driver : Tween<DriverValueType>
		{
			return component.gameObject.AddComponent<Driver>();
		}
	}
}
namespace EFramework.Utility
{
	public static class JSONParser
	{
		[ThreadStatic]
		private static Stack<List<string>> splitArrayPool;

		[ThreadStatic]
		private static StringBuilder stringBuilder;

		[ThreadStatic]
		private static Dictionary<Type, Dictionary<string, FieldInfo>> fieldInfoCache;

		[ThreadStatic]
		private static Dictionary<Type, Dictionary<string, PropertyInfo>> propertyInfoCache;

		public static T FromJson<T>(this string json)
		{
			if (propertyInfoCache == null)
			{
				propertyInfoCache = new Dictionary<Type, Dictionary<string, PropertyInfo>>();
			}
			if (fieldInfoCache == null)
			{
				fieldInfoCache = new Dictionary<Type, Dictionary<string, FieldInfo>>();
			}
			if (stringBuilder == null)
			{
				stringBuilder = new StringBuilder();
			}
			if (splitArrayPool == null)
			{
				splitArrayPool = new Stack<List<string>>();
			}
			stringBuilder.Length = 0;
			for (int i = 0; i < json.Length; i++)
			{
				char c = json[i];
				if (c == '"')
				{
					i = AppendUntilStringEnd(appendEscapeCharacter: true, i, json);
				}
				else if (!char.IsWhiteSpace(c))
				{
					stringBuilder.Append(c);
				}
			}
			return (T)ParseValue(typeof(T), stringBuilder.ToString());
		}

		private static int AppendUntilStringEnd(bool appendEscapeCharacter, int startIdx, string json)
		{
			stringBuilder.Append(json[startIdx]);
			for (int i = startIdx + 1; i < json.Length; i++)
			{
				if (json[i] == '\\')
				{
					if (appendEscapeCharacter)
					{
						stringBuilder.Append(json[i]);
					}
					stringBuilder.Append(json[i + 1]);
					i++;
				}
				else
				{
					if (json[i] == '"')
					{
						stringBuilder.Append(json[i]);
						return i;
					}
					stringBuilder.Append(json[i]);
				}
			}
			return json.Length - 1;
		}

		private static List<string> Split(string json)
		{
			List<string> list = ((splitArrayPool.Count > 0) ? splitArrayPool.Pop() : new List<string>());
			list.Clear();
			if (json.Length == 2)
			{
				return list;
			}
			int num = 0;
			stringBuilder.Length = 0;
			for (int i = 1; i < json.Length - 1; i++)
			{
				switch (json[i])
				{
				case '[':
				case '{':
					num++;
					break;
				case ']':
				case '}':
					num--;
					break;
				case '"':
					i = AppendUntilStringEnd(appendEscapeCharacter: true, i, json);
					continue;
				case ',':
				case ':':
					if (num == 0)
					{
						list.Add(stringBuilder.ToString());
						stringBuilder.Length = 0;
						continue;
					}
					break;
				}
				stringBuilder.Append(json[i]);
			}
			list.Add(stringBuilder.ToString());
			return list;
		}

		internal static object ParseValue(Type type, string json)
		{
			if (type == typeof(string))
			{
				if (json.Length <= 2)
				{
					return string.Empty;
				}
				StringBuilder stringBuilder = new StringBuilder(json.Length);
				for (int i = 1; i < json.Length - 1; i++)
				{
					if (json[i] == '\\' && i + 1 < json.Length - 1)
					{
						int num = "\"\\nrtbf/".IndexOf(json[i + 1]);
						if (num >= 0)
						{
							stringBuilder.Append("\"\\\n\r\t\b\f/"[num]);
							i++;
							continue;
						}
						if (json[i + 1] == 'u' && i + 5 < json.Length - 1)
						{
							uint result = 0u;
							if (uint.TryParse(json.Substring(i + 2, 4), NumberStyles.AllowHexSpecifier, null, out result))
							{
								stringBuilder.Append((char)result);
								i += 5;
								continue;
							}
						}
					}
					stringBuilder.Append(json[i]);
				}
				return stringBuilder.ToString();
			}
			if (type.IsPrimitive)
			{
				return Convert.ChangeType(json, type, CultureInfo.InvariantCulture);
			}
			if (type == typeof(decimal))
			{
				decimal.TryParse(json, NumberStyles.Float, CultureInfo.InvariantCulture, out var result2);
				return result2;
			}
			if (json == "null")
			{
				return null;
			}
			if (type.IsEnum)
			{
				if (json[0] == '"')
				{
					json = json.Substring(1, json.Length - 2);
				}
				try
				{
					return Enum.Parse(type, json, ignoreCase: false);
				}
				catch
				{
					return 0;
				}
			}
			if (type.IsArray)
			{
				Type elementType = type.GetElementType();
				if (json[0] != '[' || json[json.Length - 1] != ']')
				{
					return null;
				}
				List<string> list = Split(json);
				Array array = Array.CreateInstance(elementType, list.Count);
				for (int j = 0; j < list.Count; j++)
				{
					array.SetValue(ParseValue(elementType, list[j]), j);
				}
				splitArrayPool.Push(list);
				return array;
			}
			if (type.IsGenericType && type.GetGenericTypeDefinition() == typeof(List<>))
			{
				Type type2 = type.GetGenericArguments()[0];
				if (json[0] != '[' || json[json.Length - 1] != ']')
				{
					return null;
				}
				List<string> list2 = Split(json);
				IList list3 = (IList)type.GetConstructor(new Type[1] { typeof(int) }).Invoke(new object[1] { list2.Count });
				for (int k = 0; k < list2.Count; k++)
				{
					list3.Add(ParseValue(type2, list2[k]));
				}
				splitArrayPool.Push(list2);
				return list3;
			}
			if (type.IsGenericType && type.GetGenericTypeDefinition() == typeof(Dictionary<, >))
			{
				Type[] genericArguments = type.GetGenericArguments();
				Type type3 = genericArguments[0];
				Type type4 = genericArguments[1];
				if (type3 != typeof(string))
				{
					return null;
				}
				if (json[0] != '{' || json[json.Length - 1] != '}')
				{
					return null;
				}
				List<string> list4 = Split(json);
				if (list4.Count % 2 != 0)
				{
					return null;
				}
				IDictionary dictionary = (IDictionary)type.GetConstructor(new Type[1] { typeof(int) }).Invoke(new object[1] { list4.Count / 2 });
				for (int l = 0; l < list4.Count; l += 2)
				{
					if (list4[l].Length > 2)
					{
						string key = list4[l].Substring(1, list4[l].Length - 2);
						object value = ParseValue(type4, list4[l + 1]);
						dictionary.Add(key, value);
					}
				}
				return dictionary;
			}
			if (type == typeof(object))
			{
				return ParseAnonymousValue(json);
			}
			if (json[0] == '{' && json[json.Length - 1] == '}')
			{
				return ParseObject(type, json);
			}
			return null;
		}

		private static object ParseAnonymousValue(string json)
		{
			if (json.Length == 0)
			{
				return null;
			}
			if (json[0] == '{' && json[json.Length - 1] == '}')
			{
				List<string> list = Split(json);
				if (list.Count % 2 != 0)
				{
					return null;
				}
				Dictionary<string, object> dictionary = new Dictionary<string, object>(list.Count / 2);
				for (int i = 0; i < list.Count; i += 2)
				{
					dictionary.Add(list[i].Substring(1, list[i].Length - 2), ParseAnonymousValue(list[i + 1]));
				}
				return dictionary;
			}
			if (json[0] == '[' && json[json.Length - 1] == ']')
			{
				List<string> list2 = Split(json);
				List<object> list3 = new List<object>(list2.Count);
				for (int j = 0; j < list2.Count; j++)
				{
					list3.Add(ParseAnonymousValue(list2[j]));
				}
				return list3;
			}
			if (json[0] == '"' && json[json.Length - 1] == '"')
			{
				return json.Substring(1, json.Length - 2).Replace("\\", string.Empty);
			}
			if (char.IsDigit(json[0]) || json[0] == '-')
			{
				if (json.Contains("."))
				{
					double.TryParse(json, NumberStyles.Float, CultureInfo.InvariantCulture, out var result);
					return result;
				}
				int.TryParse(json, out var result2);
				return result2;
			}
			if (json == "true")
			{
				return true;
			}
			if (json == "false")
			{
				return false;
			}
			return null;
		}

		private static Dictionary<string, T> CreateMemberNameDictionary<T>(T[] members) where T : MemberInfo
		{
			Dictionary<string, T> dictionary = new Dictionary<string, T>(StringComparer.OrdinalIgnoreCase);
			foreach (T val in members)
			{
				if (val.IsDefined(typeof(IgnoreDataMemberAttribute), inherit: true))
				{
					continue;
				}
				string name = val.Name;
				if (val.IsDefined(typeof(DataMemberAttribute), inherit: true))
				{
					DataMemberAttribute dataMemberAttribute = (DataMemberAttribute)Attribute.GetCustomAttribute(val, typeof(DataMemberAttribute), inherit: true);
					if (!string.IsNullOrEmpty(dataMemberAttribute.Name))
					{
						name = dataMemberAttribute.Name;
					}
				}
				dictionary.Add(name, val);
			}
			return dictionary;
		}

		private static object ParseObject(Type type, string json)
		{
			object uninitializedObject = FormatterServices.GetUninitializedObject(type);
			List<string> list = Split(json);
			if (list.Count % 2 != 0)
			{
				return uninitializedObject;
			}
			if (!fieldInfoCache.TryGetValue(type, out var value))
			{
				value = CreateMemberNameDictionary(type.GetFields(BindingFlags.Instance | BindingFlags.Public | BindingFlags.FlattenHierarchy));
				fieldInfoCache.Add(type, value);
			}
			if (!propertyInfoCache.TryGetValue(type, out var value2))
			{
				value2 = CreateMemberNameDictionary(type.GetProperties(BindingFlags.Instance | BindingFlags.Public | BindingFlags.FlattenHierarchy));
				propertyInfoCache.Add(type, value2);
			}
			for (int i = 0; i < list.Count; i += 2)
			{
				if (list[i].Length > 2)
				{
					string key = list[i].Substring(1, list[i].Length - 2);
					string json2 = list[i + 1];
					PropertyInfo value4;
					if (value.TryGetValue(key, out var value3))
					{
						value3.SetValue(uninitializedObject, ParseValue(value3.FieldType, json2));
					}
					else if (value2.TryGetValue(key, out value4))
					{
						value4.SetValue(uninitializedObject, ParseValue(value4.PropertyType, json2), null);
					}
				}
			}
			return uninitializedObject;
		}
	}
	public static class JSONWriter
	{
		public static string ToJson(this object item)
		{
			StringBuilder stringBuilder = new StringBuilder();
			AppendValue(stringBuilder, item);
			return stringBuilder.ToString();
		}

		private static void AppendValue(StringBuilder stringBuilder, object item)
		{
			if (item == null)
			{
				stringBuilder.Append("null");
				return;
			}
			Type type = item.GetType();
			if (type == typeof(string))
			{
				stringBuilder.Append('"');
				string text = (string)item;
				for (int i = 0; i < text.Length; i++)
				{
					if (text[i] < ' ' || text[i] == '"' || text[i] == '\\')
					{
						stringBuilder.Append('\\');
						int num = "\"\\\n\r\t\b\f".IndexOf(text[i]);
						if (num >= 0)
						{
							stringBuilder.Append("\"\\nrtbf"[num]);
						}
						else
						{
							stringBuilder.AppendFormat("u{0:X4}", (uint)text[i]);
						}
					}
					else
					{
						stringBuilder.Append(text[i]);
					}
				}
				stringBuilder.Append('"');
				return;
			}
			if (type == typeof(byte) || type == typeof(int))
			{
				stringBuilder.Append(item.ToString());
				return;
			}
			if (type == typeof(float))
			{
				stringBuilder.Append(((float)item).ToString(CultureInfo.InvariantCulture));
				return;
			}
			if (type == typeof(double))
			{
				stringBuilder.Append(((double)item).ToString(CultureInfo.InvariantCulture));
				return;
			}
			if (type == typeof(bool))
			{
				stringBuilder.Append(((bool)item) ? "true" : "false");
				return;
			}
			if (type.IsEnum)
			{
				stringBuilder.Append('"');
				stringBuilder.Append(item.ToString());
				stringBuilder.Append('"');
				return;
			}
			if (item is IList)
			{
				stringBuilder.Append('[');
				bool flag = true;
				IList list = item as IList;
				for (int j = 0; j < list.Count; j++)
				{
					if (flag)
					{
						flag = false;
					}
					else
					{
						stringBuilder.Append(',');
					}
					AppendValue(stringBuilder, list[j]);
				}
				stringBuilder.Append(']');
				return;
			}
			if (type.IsGenericType && type.GetGenericTypeDefinition() == typeof(Dictionary<, >))
			{
				if (type.GetGenericArguments()[0] != typeof(string))
				{
					stringBuilder.Append("{}");
					return;
				}
				stringBuilder.Append('{');
				IDictionary dictionary = item as IDictionary;
				bool flag2 = true;
				foreach (object key in dictionary.Keys)
				{
					if (flag2)
					{
						flag2 = false;
					}
					else
					{
						stringBuilder.Append(',');
					}
					stringBuilder.Append('"');
					stringBuilder.Append((string)key);
					stringBuilder.Append("\":");
					AppendValue(stringBuilder, dictionary[key]);
				}
				stringBuilder.Append('}');
				return;
			}
			stringBuilder.Append('{');
			bool flag3 = true;
			FieldInfo[] fields = type.GetFields(BindingFlags.Instance | BindingFlags.Public | BindingFlags.FlattenHierarchy);
			for (int k = 0; k < fields.Length; k++)
			{
				if (fields[k].IsDefined(typeof(IgnoreDataMemberAttribute), inherit: true))
				{
					continue;
				}
				object value = fields[k].GetValue(item);
				if (value != null)
				{
					if (flag3)
					{
						flag3 = false;
					}
					else
					{
						stringBuilder.Append(',');
					}
					stringBuilder.Append('"');
					stringBuilder.Append(GetMemberName(fields[k]));
					stringBuilder.Append("\":");
					AppendValue(stringBuilder, value);
				}
			}
			PropertyInfo[] properties = type.GetProperties(BindingFlags.Instance | BindingFlags.Public | BindingFlags.FlattenHierarchy);
			for (int l = 0; l < properties.Length; l++)
			{
				if (!properties[l].CanRead || properties[l].IsDefined(typeof(IgnoreDataMemberAttribute), inherit: true))
				{
					continue;
				}
				object value2 = properties[l].GetValue(item, null);
				if (value2 != null)
				{
					if (flag3)
					{
						flag3 = false;
					}
					else
					{
						stringBuilder.Append(',');
					}
					stringBuilder.Append('"');
					stringBuilder.Append(GetMemberName(properties[l]));
					stringBuilder.Append("\":");
					AppendValue(stringBuilder, value2);
				}
			}
			stringBuilder.Append('}');
		}

		private static string GetMemberName(MemberInfo member)
		{
			if (member.IsDefined(typeof(DataMemberAttribute), inherit: true))
			{
				DataMemberAttribute dataMemberAttribute = (DataMemberAttribute)Attribute.GetCustomAttribute(member, typeof(DataMemberAttribute), inherit: true);
				if (!string.IsNullOrEmpty(dataMemberAttribute.Name))
				{
					return dataMemberAttribute.Name;
				}
			}
			return member.Name;
		}
	}
}
namespace EFramework.Network
{
	public delegate void SendBytesTo(byte[] data, EndPoint point);
	public class ClientConnection : IDisposable
	{
		public string Uid { get; set; }

		public Socket Socket { get; set; }

		public byte[] Buffer { get; set; }

		public static int BufferSize { get; set; } = 32768;


		public bool IsConnected
		{
			get
			{
				if (!Socket.Poll(1000, SelectMode.SelectRead) || Socket.Available != 0)
				{
					return Socket.Connected;
				}
				return false;
			}
		}

		public IPAddress RemoteIP => (Socket.RemoteEndPoint as IPEndPoint)?.Address;

		public int RemotePort => (Socket.RemoteEndPoint as IPEndPoint).Port;

		public event SendBytesTo SendData;

		public ClientConnection()
		{
			Buffer = new byte[BufferSize];
		}

		public void Dispose()
		{
			Socket.Close();
		}

		public void Send(byte[] data)
		{
			if (Socket.SocketType == SocketType.Stream)
			{
				Socket.BeginSend(data, 0, data.Length, SocketFlags.None, EndSend, null);
			}
			else if (Socket.SocketType == SocketType.Dgram)
			{
				if (this.SendData != null)
				{
					this.SendData?.Invoke(data, Socket.RemoteEndPoint);
				}
				else
				{
					Socket.BeginSendTo(data, 0, data.Length, SocketFlags.None, Socket.RemoteEndPoint, EndSendTo, null);
				}
			}
		}

		private void EndSend(IAsyncResult ar)
		{
			Socket.EndSend(ar);
		}

		private void EndSendTo(IAsyncResult ar)
		{
			Socket.EndSendTo(ar);
		}
	}
	[Flags]
	public enum ESocketType
	{
		Tcp = 0,
		Udp = 1
	}
	public class SocketClient : ClientConnection, IDisposable
	{
		public ESocketType ClientType { get; set; }

		public int LoopInterval { get; set; } = 50;


		public int UDPDataInterval { get; set; } = 5000;


		private System.Timers.Timer UDPTimer { get; set; }

		private System.Timers.Timer DisconnectTimer { get; set; }

		public event EventHandler OnConnected;

		public event EventHandler OnDisconnected;

		public event EventHandler<SocketClientEventArgs> OnReceived;

		public event EventHandler<ErrorEventArgs> OnError;

		public SocketClient(ESocketType type)
		{
			ClientType = type;
			UDPTimer = new System.Timers.Timer(UDPDataInterval);
			UDPTimer.Elapsed += delegate
			{
				if (base.IsConnected)
				{
					base.Socket.Send(new byte[1]);
				}
			};
			DisconnectTimer = new System.Timers.Timer(LoopInterval);
			DisconnectTimer.Elapsed += delegate
			{
				if (!base.IsConnected)
				{
					Disconnect();
				}
			};
		}

		public new void Dispose()
		{
			Disconnect();
		}

		public void Connect(IPAddress address, int port)
		{
			Connect(new IPEndPoint(address, port));
		}

		public void Connect(IPEndPoint point)
		{
			try
			{
				if (ClientType == ESocketType.Tcp)
				{
					base.Socket = new Socket(point.AddressFamily, SocketType.Stream, ProtocolType.Tcp);
					base.Socket.BeginConnect(point, ConnectCallback, null);
				}
				else if (ClientType == ESocketType.Udp)
				{
					base.Socket = new Socket(point.AddressFamily, SocketType.Dgram, ProtocolType.Udp);
					base.Socket.Connect(point);
					base.Socket.Send(new byte[1]);
					this.OnConnected?.Invoke(this, new EventArgs());
					UDPTimer.Start();
					DisconnectTimer.Start();
					base.Socket.BeginReceive(base.Buffer, 0, ClientConnection.BufferSize, SocketFlags.None, ReadCallbackUDP, null);
				}
			}
			catch (SocketException exception)
			{
				this.OnError?.Invoke(this, new ErrorEventArgs(exception));
			}
		}

		public void Disconnect()
		{
			try
			{
				if (base.Socket != null)
				{
					UDPTimer.Stop();
					DisconnectTimer.Stop();
					base.Socket.Close();
					this.OnDisconnected?.Invoke(this, new EventArgs());
				}
			}
			catch (SocketException exception)
			{
				this.OnError?.Invoke(this, new ErrorEventArgs(exception));
			}
		}

		private void ConnectCallback(IAsyncResult ar)
		{
			try
			{
				base.Socket.EndConnect(ar);
				this.OnConnected?.Invoke(this, new EventArgs());
				DisconnectTimer.Start();
				base.Socket.BeginReceive(base.Buffer, 0, ClientConnection.BufferSize, SocketFlags.None, ReadCallback, null);
			}
			catch (SocketException exception)
			{
				this.OnError?.Invoke(this, new ErrorEventArgs(exception));
			}
		}

		private void ReadCallback(IAsyncResult ar)
		{
			try
			{
				if (base.Socket.Connected)
				{
					int num = base.Socket.EndReceive(ar);
					if (num > 0)
					{
						byte[] array = new byte[num];
						Array.Copy(base.Buffer, array, num);
						this.OnReceived?.Invoke(this, new SocketClientEventArgs
						{
							Data = array
						});
					}
					base.Socket.BeginReceive(base.Buffer, 0, ClientConnection.BufferSize, SocketFlags.None, ReadCallback, null);
				}
			}
			catch (SocketException exception)
			{
				this.OnError?.Invoke(this, new ErrorEventArgs(exception));
			}
		}

		private void ReadCallbackUDP(IAsyncResult ar)
		{
			try
			{
				if (base.Socket.Connected)
				{
					int num = base.Socket.EndReceive(ar);
					if (num > 0)
					{
						byte[] array = new byte[num];
						Array.Copy(base.Buffer, array, num);
						this.OnReceived?.Invoke(this, new SocketClientEventArgs
						{
							Data = array
						});
					}
					base.Socket.BeginReceive(base.Buffer, 0, ClientConnection.BufferSize, SocketFlags.None, ReadCallbackUDP, null);
				}
			}
			catch (SocketException exception)
			{
				this.OnError?.Invoke(this, new ErrorEventArgs(exception));
			}
		}
	}
	public class SocketClientEventArgs : EventArgs
	{
		public byte[] Data { get; set; }
	}
	public class SocketServer : IDisposable
	{
		public string Uid { get; set; }

		public IPAddress IPAddress { get; set; }

		public int Port { get; set; }

		public List<ClientConnection> ConnectedClients { get; set; } = new List<ClientConnection>();


		public int LoopInterval { get; set; } = 50;


		public int Backlog { get; set; }

		public ESocketType ServerType { get; set; }

		public bool UDPClientManage { get; set; } = true;


		private int _UDPDataInterval => (int)((double)UDPDataInterval * 1.5);

		public int UDPDataInterval { get; set; } = 5000;


		private Socket Listener { get; set; }

		private System.Timers.Timer DisconnectTimer { get; set; }

		private Dictionary<EndPoint, double> LastDataRecievedTime { get; set; }

		private double TimeNow => (DateTime.UtcNow - new DateTime(1970, 1, 1)).TotalSeconds;

		public event EventHandler<SocketServerClientEventArgs> OnConnected;

		public event EventHandler<SocketServerClientEventArgs> OnDisconnected;

		public event EventHandler<SocketServerDataEventArgs> OnReceived;

		public event EventHandler<ErrorEventArgs> OnError;

		public event EventHandler OnStart;

		public event EventHandler OnStop;

		public SocketServer(ESocketType type, IPAddress address, int port)
		{
			Uid = Guid.NewGuid().ToString();
			ServerType = type;
			IPAddress = address;
			Port = port;
			DisconnectTimer = new System.Timers.Timer(LoopInterval);
		}

		public void Dispose()
		{
			Stop();
		}

		public void Start()
		{
			try
			{
				if (ServerType == ESocketType.Tcp)
				{
					Listener = new Socket(IPAddress.AddressFamily, SocketType.Stream, ProtocolType.Tcp);
					DisconnectTimer.Elapsed += delegate
					{
						lock (ConnectedClients)
						{
							ConnectedClients.RemoveAll(delegate(ClientConnection x)
							{
								if (!x.IsConnected)
								{
									this.OnDisconnected?.Invoke(this, new SocketServerClientEventArgs
									{
										Client = x
									});
									return true;
								}
								return false;
							});
						}
					};
				}
				else if (ServerType == ESocketType.Udp)
				{
					if (UDPClientManage)
					{
						LastDataRecievedTime = new Dictionary<EndPoint, double>();
						DisconnectTimer.Elapsed += delegate
						{
							double timeNow = TimeNow;
							Dictionary<EndPoint, double> lastDataRecievedTime = LastDataRecievedTime;
							List<EndPoint> list = new List<EndPoint>();
							foreach (KeyValuePair<EndPoint, double> kp in lastDataRecievedTime)
							{
								if (timeNow - kp.Value > (double)(_UDPDataInterval / 1000))
								{
									lock (ConnectedClients)
									{
										IEnumerable<ClientConnection> source = ConnectedClients.Where((ClientConnection x) => x.Uid == kp.Key.ToString());
										if (source.Count() > 0)
										{
											this.OnDisconnected?.Invoke(this, new SocketServerClientEventArgs
											{
												Client = source.First()
											});
											ConnectedClients.Remove(source.First());
											list.Add(kp.Key);
										}
									}
								}
							}
							lock (LastDataRecievedTime)
							{
								foreach (EndPoint item in list)
								{
									LastDataRecievedTime.Remove(item);
								}
							}
						};
					}
					Listener = new Socket(IPAddress.AddressFamily, SocketType.Dgram, ProtocolType.Udp);
				}
				Listener.ReceiveBufferSize = ClientConnection.BufferSize;
				Listener.SendBufferSize = ClientConnection.BufferSize;
				Listener.Bind(new IPEndPoint(IPAddress, Port));
				if (ServerType == ESocketType.Tcp)
				{
					Listener.Listen(Backlog);
				}
				DisconnectTimer.Start();
				ListenerLoop();
			}
			catch (SocketException exception)
			{
				this.OnError?.Invoke(this, new ErrorEventArgs(exception));
			}
		}

		public void Stop()
		{
			try
			{
				DisconnectTimer.Stop();
				foreach (ClientConnection connectedClient in ConnectedClients)
				{
					this.OnDisconnected?.Invoke(this, new SocketServerClientEventArgs
					{
						Client = connectedClient
					});
					connectedClient.Socket.Close();
				}
				ConnectedClients.Clear();
				this.OnStop?.Invoke(this, new EventArgs());
				Listener.Close();
			}
			catch (SocketException exception)
			{
				this.OnError?.Invoke(this, new ErrorEventArgs(exception));
			}
		}

		private void ListenerLoop()
		{
			try
			{
				this.OnStart?.Invoke(this, new EventArgs());
				if (ServerType == ESocketType.Tcp)
				{
					Listener.BeginAccept(AcceptCallback, Listener);
				}
				if (ServerType == ESocketType.Udp)
				{
					if (UDPClientManage)
					{
						byte[] array = new byte[ClientConnection.BufferSize];
						EndPoint remoteEP = new IPEndPoint(IPAddress.Loopback, 0);
						Listener.BeginReceiveFrom(array, 0, ClientConnection.BufferSize, SocketFlags.None, ref remoteEP, AcceptCallbackUDP, new object[3] { array, remoteEP, Listener });
					}
					else
					{
						byte[] array2 = new byte[ClientConnection.BufferSize];
						EndPoint remoteEP2 = new IPEndPoint(IPAddress.Loopback, 0);
						Listener.BeginReceiveFrom(array2, 0, ClientConnection.BufferSize, SocketFlags.None, ref remoteEP2, ReadCallbackUDP, new object[3] { array2, remoteEP2, Listener });
					}
				}
			}
			catch (SocketException exception)
			{
				this.OnError?.Invoke(this, new ErrorEventArgs(exception));
			}
		}

		private void AcceptCallback(IAsyncResult ar)
		{
			try
			{
				Socket socket = (Socket)ar.AsyncState;
				Socket socket2 = socket.EndAccept(ar);
				ClientConnection clientConnection = new ClientConnection
				{
					Uid = Guid.NewGuid().ToString(),
					Socket = socket2
				};
				lock (ConnectedClients)
				{
					ConnectedClients.Add(clientConnection);
				}
				this.OnConnected?.Invoke(this, new SocketServerClientEventArgs
				{
					Client = clientConnection
				});
				clientConnection.Socket.BeginReceive(clientConnection.Buffer, 0, ClientConnection.BufferSize, SocketFlags.None, ReadCallback, clientConnection);
				socket.BeginAccept(AcceptCallback, Listener);
			}
			catch (SocketException exception)
			{
				this.OnError?.Invoke(this, new ErrorEventArgs(exception));
			}
			catch (ObjectDisposedException)
			{
			}
		}

		private void ReadCallback(IAsyncResult ar)
		{
			try
			{
				ClientConnection clientConnection = (ClientConnection)ar.AsyncState;
				int num = clientConnection.Socket.EndReceive(ar);
				if (num > 0)
				{
					byte[] array = new byte[num];
					Array.Copy(clientConnection.Buffer, 0, array, 0, num);
					this.OnReceived?.Invoke(this, new SocketServerDataEventArgs
					{
						Client = clientConnection,
						Data = array
					});
				}
				Thread.Sleep(LoopInterval);
				clientConnection.Socket.BeginReceive(clientConnection.Buffer, 0, ClientConnection.BufferSize, SocketFlags.None, ReadCallback, clientConnection);
			}
			catch (SocketException exception)
			{
				this.OnError?.Invoke(this, new ErrorEventArgs(exception));
			}
			catch (ObjectDisposedException)
			{
			}
		}

		private void AcceptCallbackUDP(IAsyncResult ar)
		{
			try
			{
				object[] array = (object[])ar.AsyncState;
				byte[] array2 = array[0] as byte[];
				EndPoint remote_ip = array[1] as EndPoint;
				int num = (array[2] as Socket).EndReceiveFrom(ar, ref remote_ip);
				List<ClientConnection> list = ConnectedClients.Where((ClientConnection x) => x.Uid == remote_ip.ToString()).ToList();
				ClientConnection clientConnection;
				if (list.Count == 0)
				{
					clientConnection = new ClientConnection
					{
						Uid = remote_ip.ToString(),
						Socket = new Socket(remote_ip.AddressFamily, SocketType.Dgram, ProtocolType.Udp)
					};
					clientConnection.SendData += SendData;
					clientConnection.Socket.Connect(remote_ip);
					if (clientConnection.IsConnected)
					{
						ConnectedClients.Add(clientConnection);
						this.OnConnected?.Invoke(this, new SocketServerClientEventArgs
						{
							Client = clientConnection
						});
					}
				}
				else
				{
					clientConnection = list.First();
				}
				if (num > 1)
				{
					byte[] array3 = new byte[num];
					Array.Copy(array2, 0, array3, 0, num);
					this.OnReceived?.Invoke(this, new SocketServerDataEventArgs
					{
						Client = clientConnection,
						Data = array3
					});
				}
				else if (LastDataRecievedTime.ContainsKey(remote_ip))
				{
					LastDataRecievedTime[remote_ip] = TimeNow;
				}
				else
				{
					LastDataRecievedTime.Add(remote_ip, TimeNow);
				}
				Listener.BeginReceiveFrom(array2, 0, ClientConnection.BufferSize, SocketFlags.None, ref remote_ip, AcceptCallbackUDP, new object[3] { array2, remote_ip, Listener });
			}
			catch (SocketException exception)
			{
				this.OnError?.Invoke(this, new ErrorEventArgs(exception));
			}
			catch (ObjectDisposedException)
			{
			}
		}

		private void ReadCallbackUDP(IAsyncResult ar)
		{
			try
			{
				object[] obj = (object[])ar.AsyncState;
				byte[] array = obj[0] as byte[];
				EndPoint endPoint = obj[1] as EndPoint;
				int num = (obj[2] as Socket).EndReceiveFrom(ar, ref endPoint);
				if (num > 0)
				{
					byte[] array2 = new byte[num];
					Array.Copy(array, 0, array2, 0, num);
					this.OnReceived?.Invoke(this, new SocketServerDataEventArgs
					{
						Data = array2
					});
				}
				Listener.BeginReceiveFrom(array, 0, ClientConnection.BufferSize, SocketFlags.None, ref endPoint, ReadCallbackUDP, new object[3] { array, endPoint, Listener });
			}
			catch (SocketException exception)
			{
				this.OnError?.Invoke(this, new ErrorEventArgs(exception));
			}
			catch (ObjectDisposedException)
			{
			}
		}

		private void DisconnectCallback(IAsyncResult ar)
		{
			try
			{
				ClientConnection clientConnection = (ClientConnection)ar.AsyncState;
				clientConnection.Socket.EndDisconnect(ar);
				this.OnDisconnected?.Invoke(this, new SocketServerClientEventArgs
				{
					Client = clientConnection
				});
				lock (ConnectedClients)
				{
					ConnectedClients.Remove(clientConnection);
				}
			}
			catch (SocketException exception)
			{
				this.OnError?.Invoke(this, new ErrorEventArgs(exception));
			}
		}

		public void SendData(byte[] data, EndPoint point)
		{
			try
			{
				Listener.BeginSendTo(data, 0, data.Length, SocketFlags.None, point, EndSendTo, null);
			}
			catch (SocketException exception)
			{
				this.OnError?.Invoke(this, new ErrorEventArgs(exception));
			}
		}

		private void EndSendTo(IAsyncResult ar)
		{
			try
			{
				Listener.EndSendTo(ar);
			}
			catch (SocketException exception)
			{
				this.OnError?.Invoke(this, new ErrorEventArgs(exception));
			}
		}
	}
	public class SocketServerDataEventArgs : EventArgs
	{
		public ClientConnection Client { get; set; }

		public byte[] Data { get; set; }
	}
	public class SocketServerClientEventArgs : EventArgs
	{
		public ClientConnection Client { get; set; }
	}
	public class SocketServerPool : IDisposable
	{
		public List<SocketServer> Servers { get; set; } = new List<SocketServer>();


		public SocketServer this[int index]
		{
			get
			{
				if (Servers.Count < index)
				{
					return Servers[index];
				}
				return null;
			}
		}

		public SocketServer this[string name]
		{
			get
			{
				IEnumerable<SocketServer> source = Servers.Where((SocketServer x) => x.Uid == name);
				if (source.Count() > 0)
				{
					return source.First();
				}
				return null;
			}
		}

		public void Dispose()
		{
			Servers.ForEach(delegate(SocketServer x)
			{
				x.Stop();
			});
			Servers.Clear();
		}

		public SocketServer Add(ESocketType type, IPAddress ip, int port)
		{
			SocketServer socketServer = new SocketServer(type, ip, port);
			Servers.Add(socketServer);
			return socketServer;
		}

		public bool Remove(string name)
		{
			if (Servers.RemoveAll((SocketServer x) => x.Uid == name) <= 0)
			{
				return false;
			}
			return true;
		}

		public bool Remove(int index)
		{
			try
			{
				Servers.RemoveAt(index);
			}
			catch
			{
				return false;
			}
			return true;
		}
	}
}
namespace EFramework.Network.Http
{
	public static class HttpHelper
	{
		public static string HttpGetRequest(string url)
		{
			string empty = string.Empty;
			try
			{
				return GetHttpResponse(CreateHttpRequest(url, "GET").GetResponse() as HttpWebResponse, "GET");
			}
			catch (Exception ex)
			{
				return ex.Message;
			}
		}

		public static async void HttpGetRequestAsync(string url, Action<string> action)
		{
			_ = string.Empty;
			string obj;
			try
			{
				obj = GetHttpResponse((await CreateHttpRequest(url, "GET").GetResponseAsync()) as HttpWebResponse, "GET");
			}
			catch (Exception ex)
			{
				obj = ex.Message;
			}
			action(obj);
		}

		public static string HttpPostRequest(string url, string postJsonData)
		{
			string empty = string.Empty;
			try
			{
				return GetHttpResponse(CreateHttpRequest(url, "POST", postJsonData).GetResponse() as HttpWebResponse, "POST");
			}
			catch (Exception ex)
			{
				return ex.Message;
			}
		}

		public static async void HttpPostRequestAsync(string url, string postData)
		{
			_ = string.Empty;
			string text;
			try
			{
				text = GetHttpResponse((await CreateHttpRequest(url, "POST", postData).GetResponseAsync()) as HttpWebResponse, "POST");
				UnityEngine.Debug.Log(text.Length);
			}
			catch (Exception ex)
			{
				text = ex.Message;
			}
			if (text != "true")
			{
				UnityEngine.Debug.Log("--> reslut : " + text);
				UnityEngine.Debug.Log(postData);
			}
		}

		public static async void HttpPostRequestAsync(string url, string postData, Action<string> action)
		{
			_ = string.Empty;
			string text;
			try
			{
				text = GetHttpResponse((await CreateHttpRequest(url, "POST", postData).GetResponseAsync()) as HttpWebResponse, "POST");
				UnityEngine.Debug.Log(text.Length);
			}
			catch (Exception ex)
			{
				text = ex.Message;
			}
			if (text != "true")
			{
				action(text);
			}
		}

		private static HttpWebRequest CreateHttpRequest(string url, string requestType, params object[] strJson)
		{
			HttpWebRequest result = null;
			if (string.Equals(requestType, "GET", StringComparison.OrdinalIgnoreCase))
			{
				result = CreateGetHttpWebRequest(url);
			}
			if (string.Equals(requestType, "POST", StringComparison.OrdinalIgnoreCase))
			{
				result = CreatePostHttpWebRequest(url, strJson[0].ToString());
			}
			return result;
		}

		private static HttpWebRequest CreateGetHttpWebRequest(string url)
		{
			HttpWebRequest obj = WebRequest.Create(url) as HttpWebRequest;
			obj.Method = "GET";
			obj.Timeout = 5000;
			obj.ContentType = "text/html;charset=UTF-8";
			obj.AutomaticDecompression = DecompressionMethods.GZip | DecompressionMethods.Deflate;
			return obj;
		}

		private static HttpWebRequest CreatePostHttpWebRequest(string url, string postData)
		{
			HttpWebRequest obj = WebRequest.Create(url) as HttpWebRequest;
			obj.KeepAlive = false;
			obj.Timeout = 5000;
			obj.Method = "POST";
			obj.ContentType = "application/x-www-form-urlencoded;charset=UTF-8";
			obj.ContentLength = postData.Length;
			obj.AllowWriteStreamBuffering = false;
			StreamWriter streamWriter = new StreamWriter(obj.GetRequestStream(), Encoding.ASCII);
			streamWriter.Write(postData);
			streamWriter.Flush();
			return obj;
		}

		private static string GetHttpResponse(HttpWebResponse response, string requestType)
		{
			string text = "";
			string text2 = "UTF-8";
			if (string.Equals(requestType, "POST", StringComparison.OrdinalIgnoreCase))
			{
				text2 = response.ContentEncoding;
				if (text2 == null || text2.Length < 1)
				{
					text2 = "UTF-8";
				}
			}
			using StreamReader streamReader = new StreamReader(response.GetResponseStream(), Encoding.GetEncoding(text2));
			return streamReader.ReadToEnd();
		}

		private static string GetHttpResponseAsync(HttpWebResponse response, string requestType)
		{
			string text = "";
			string text2 = "UTF-8";
			if (string.Equals(requestType, "POST", StringComparison.OrdinalIgnoreCase))
			{
				text2 = response.ContentEncoding;
				if (text2 == null || text2.Length < 1)
				{
					text2 = "UTF-8";
				}
			}
			using StreamReader streamReader = new StreamReader(response.GetResponseStream(), Encoding.GetEncoding(text2));
			return streamReader.ReadToEnd();
		}
	}
}
namespace EFramework.Core
{
	public class EventAgent<T>
	{
		private static EventAgent<T> inatance;

		private Dictionary<T, Signal> eventList = new Dictionary<T, Signal>();

		public static EventAgent<T> Instance
		{
			get
			{
				if (inatance == null)
				{
					inatance = new EventAgent<T>();
				}
				return inatance;
			}
		}

		private EventAgent()
		{
		}

		public void AddListener(T eid, Action action)
		{
			if (!eventList.TryGetValue(eid, out var value))
			{
				value = new Signal();
				eventList.Add(eid, value);
			}
			value.AddListener(action);
		}

		public void Invoke(T eid)
		{
			if (eventList.TryGetValue(eid, out var value))
			{
				value.InvokeSafe();
			}
		}

		public void RemoveListener(T eid, Action action)
		{
			if (eventList.TryGetValue(eid, out var value))
			{
				value.RemoveListener(action);
			}
		}

		private void RemoveListener(T eid)
		{
			if (CheckHaveListener(eid))
			{
				eventList.Remove(eid);
			}
		}

		public bool CheckHaveListener(T eid)
		{
			if (eventList.TryGetValue(eid, out var value))
			{
				Delegate[] invokeList = value.GetInvokeList();
				if (invokeList != null && invokeList.Length != 0)
				{
					return true;
				}
			}
			return false;
		}

		private void RemoveListener(Action listener)
		{
			Dictionary<T, Signal>.Enumerator enumerator = eventList.GetEnumerator();
			while (enumerator.MoveNext())
			{
				enumerator.Current.Value.RemoveListener(listener);
			}
		}
	}
	public class EventAgentDelegate<T>
	{
		private static EventAgentDelegate<T> inatance;

		private Dictionary<T, SignalDelegate> eventList = new Dictionary<T, SignalDelegate>();

		public static EventAgentDelegate<T> Instance
		{
			get
			{
				if (inatance == null)
				{
					inatance = new EventAgentDelegate<T>();
				}
				return inatance;
			}
		}

		private EventAgentDelegate()
		{
		}

		public void AddListener(T eid, Delegate action)
		{
			if (!eventList.TryGetValue(eid, out var value))
			{
				value = new SignalDelegate();
				eventList.Add(eid, value);
			}
			value.AddListener(action, bInsertAtFirst: false);
		}

		public void Invoke(T eid)
		{
			if (eventList.TryGetValue(eid, out var value))
			{
				value.Invoke();
			}
		}

		public void Invoke<T1>(T eid, T1 t1)
		{
			if (eventList.TryGetValue(eid, out var value))
			{
				value.Invoke(t1);
			}
		}

		public void Invoke<T1, T2>(T eid, T1 t1, T2 t2)
		{
			if (eventList.TryGetValue(eid, out var value))
			{
				value.Invoke(t1, t2);
			}
		}

		public void Invoke<T1, T2, T3>(T eid, T1 t1, T2 t2, T3 t3)
		{
			if (eventList.TryGetValue(eid, out var value))
			{
				value.Invoke(t1, t2, t3);
			}
		}

		public void Invoke<T1, T2, T3, T4>(T eid, T1 t1, T2 t2, T3 t3, T4 t4)
		{
			if (eventList.TryGetValue(eid, out var value))
			{
				value.Invoke(t1, t2, t3, t4);
			}
		}

		public void RemoveListener(T eid, Delegate action)
		{
			if (eventList.TryGetValue(eid, out var value))
			{
				value.RemoveListener(action);
			}
		}

		private void RemoveListener(T eid)
		{
			if (CheckHaveListener(eid))
			{
				eventList.Remove(eid);
			}
		}

		public bool CheckHaveListener(T eid)
		{
			if (eventList.TryGetValue(eid, out var value))
			{
				Delegate[] invokeList = value.GetInvokeList();
				if (invokeList != null && invokeList.Length != 0)
				{
					return true;
				}
			}
			return false;
		}

		private void RemoveListener(Delegate listener)
		{
			Dictionary<T, SignalDelegate>.Enumerator enumerator = eventList.GetEnumerator();
			while (enumerator.MoveNext())
			{
				enumerator.Current.Value.RemoveListener(listener);
			}
		}
	}
	public class EventAgent<T, T1>
	{
		private static EventAgent<T, T1> mInatance;

		private Dictionary<T, Signal<T1>> eventList = new Dictionary<T, Signal<T1>>();

		public static EventAgent<T, T1> Instance
		{
			get
			{
				if (mInatance == null)
				{
					mInatance = new EventAgent<T, T1>();
				}
				return mInatance;
			}
		}

		private EventAgent()
		{
		}

		public void AddListener(T eid, Action<T1> action)
		{
			if (!eventList.TryGetValue(eid, out var value))
			{
				value = new Signal<T1>();
				eventList.Add(eid, value);
			}
			value.AddListener(action);
		}

		public void Invoke(T eid, T1 param1)
		{
			if (eventList.TryGetValue(eid, out var value))
			{
				value.Invoke(param1);
			}
		}

		public void RemoveListener(T eid, Action<T1> action)
		{
			if (eventList.TryGetValue(eid, out var value))
			{
				value.RemoveListener(action);
			}
		}

		private void RemoveListener(T eid)
		{
			if (CheckHaveListener(eid))
			{
				eventList.Remove(eid);
			}
		}

		public bool CheckHaveListener(T eid)
		{
			if (eventList.TryGetValue(eid, out var value))
			{
				Delegate[] invokeList = value.GetInvokeList();
				if (invokeList != null && invokeList.Length != 0)
				{
					return true;
				}
			}
			return false;
		}

		private void RemoveListener(Action<T1> listener)
		{
			Dictionary<T, Signal<T1>>.Enumerator enumerator = eventList.GetEnumerator();
			while (enumerator.MoveNext())
			{
				enumerator.Current.Value.RemoveListener(listener);
			}
		}
	}
	public class EventAgent<T, T1, T2>
	{
		private static EventAgent<T, T1, T2> mInatance;

		private Dictionary<T, Signal<T1, T2>> eventList = new Dictionary<T, Signal<T1, T2>>();

		public static EventAgent<T, T1, T2> Instance
		{
			get
			{
				if (mInatance == null)
				{
					mInatance = new EventAgent<T, T1, T2>();
				}
				return mInatance;
			}
		}

		private EventAgent()
		{
		}

		public void AddListener(T eid, Action<T1, T2> action)
		{
			if (!eventList.TryGetValue(eid, out var value))
			{
				value = new Signal<T1, T2>();
				eventList.Add(eid, value);
			}
			value.AddListener(action);
		}

		public void Invoke(T eid, T1 param1, T2 param2)
		{
			if (eventList.TryGetValue(eid, out var value))
			{
				value.Invoke(param1, param2);
			}
		}

		public void RemoveListener(T eid, Action<T1, T2> action)
		{
			if (eventList.TryGetValue(eid, out var value))
			{
				value.RemoveListener(action);
			}
		}

		private void RemoveListener(T eid)
		{
			if (CheckHaveListener(eid))
			{
				eventList.Remove(eid);
			}
		}

		public bool CheckHaveListener(T eid)
		{
			if (eventList.TryGetValue(eid, out var value))
			{
				Delegate[] invokeList = value.GetInvokeList();
				if (invokeList != null && invokeList.Length != 0)
				{
					return true;
				}
			}
			return false;
		}

		private void RemoveListener(Action<T1, T2> listener)
		{
			Dictionary<T, Signal<T1, T2>>.Enumerator enumerator = eventList.GetEnumerator();
			while (enumerator.MoveNext())
			{
				enumerator.Current.Value.RemoveListener(listener);
			}
		}
	}
	public class EventAgent<T, T1, T2, T3>
	{
		private static EventAgent<T, T1, T2, T3> mInatance;

		private Dictionary<T, Signal<T1, T2, T3>> eventList = new Dictionary<T, Signal<T1, T2, T3>>();

		public static EventAgent<T, T1, T2, T3> Instance
		{
			get
			{
				if (mInatance == null)
				{
					mInatance = new EventAgent<T, T1, T2, T3>();
				}
				return mInatance;
			}
		}

		private EventAgent()
		{
		}

		public void AddListener(T eid, Action<T1, T2, T3> action)
		{
			if (!eventList.TryGetValue(eid, out var value))
			{
				value = new Signal<T1, T2, T3>();
				eventList.Add(eid, value);
			}
			value.AddListener(action);
		}

		public void Invoke(T eid, T1 param1, T2 param2, T3 param3)
		{
			if (eventList.TryGetValue(eid, out var value))
			{
				value.Invoke(param1, param2, param3);
			}
		}

		public void RemoveListener(T eid, Action<T1, T2, T3> action)
		{
			if (eventList.TryGetValue(eid, out var value))
			{
				value.RemoveListener(action);
			}
		}

		private void RemoveListener(T eid)
		{
			if (CheckHaveListener(eid))
			{
				eventList.Remove(eid);
			}
		}

		public bool CheckHaveListener(T eid)
		{
			if (eventList.TryGetValue(eid, out var value))
			{
				Delegate[] invokeList = value.GetInvokeList();
				if (invokeList != null && invokeList.Length != 0)
				{
					return true;
				}
			}
			return false;
		}

		private void RemoveListener(Action<T1, T2, T3> listener)
		{
			Dictionary<T, Signal<T1, T2, T3>>.Enumerator enumerator = eventList.GetEnumerator();
			while (enumerator.MoveNext())
			{
				enumerator.Current.Value.RemoveListener(listener);
			}
		}
	}
	public class EventAgent<T, T1, T2, T3, T4>
	{
		private static EventAgent<T, T1, T2, T3, T4> mInatance;

		private Dictionary<T, Signal<T1, T2, T3, T4>> eventList = new Dictionary<T, Signal<T1, T2, T3, T4>>();

		public static EventAgent<T, T1, T2, T3, T4> Instance
		{
			get
			{
				if (mInatance == null)
				{
					mInatance = new EventAgent<T, T1, T2, T3, T4>();
				}
				return mInatance;
			}
		}

		private EventAgent()
		{
		}

		public void AddListener(T eid, Action<T1, T2, T3, T4> action)
		{
			if (!eventList.TryGetValue(eid, out var value))
			{
				value = new Signal<T1, T2, T3, T4>();
				eventList.Add(eid, value);
			}
			value.AddListener(action);
		}

		public void Invoke(T eid, T1 param1, T2 param2, T3 param3, T4 param4)
		{
			if (eventList.TryGetValue(eid, out var value))
			{
				value.Invoke(param1, param2, param3, param4);
			}
		}

		public void RemoveListener(T eid, Action<T1, T2, T3, T4> action)
		{
			if (eventList.TryGetValue(eid, out var value))
			{
				value.RemoveListener(action);
			}
		}

		private void RemoveListener(T eid)
		{
			if (CheckHaveListener(eid))
			{
				eventList.Remove(eid);
			}
		}

		public bool CheckHaveListener(T eid)
		{
			if (eventList.TryGetValue(eid, out var value))
			{
				Delegate[] invokeList = value.GetInvokeList();
				if (invokeList != null && invokeList.Length != 0)
				{
					return true;
				}
			}
			return false;
		}

		private void RemoveListener(Action<T1, T2, T3, T4> listener)
		{
			Dictionary<T, Signal<T1, T2, T3, T4>>.Enumerator enumerator = eventList.GetEnumerator();
			while (enumerator.MoveNext())
			{
				enumerator.Current.Value.RemoveListener(listener);
			}
		}
	}
	public class EventManager
	{
		public static void AddListener(Enum eid, Action action)
		{
			EventAgent<Enum>.Instance.AddListener(eid, action);
		}

		public static void SendEvent(Enum eid)
		{
			EventAgent<Enum>.Instance.Invoke(eid);
			EventAgentDelegate<Enum>.Instance.Invoke(eid);
		}

		public static void RemoveListener(Enum eid, Action action)
		{
			EventAgent<Enum>.Instance.RemoveListener(eid, action);
		}

		public static void AddListener<T>(Enum eid, Action<T> action)
		{
			EventAgent<Enum, T>.Instance.AddListener(eid, action);
		}

		public static void SendEvent<T>(Enum eid, T param)
		{
			EventAgent<Enum, T>.Instance.Invoke(eid, param);
			EventAgentDelegate<Enum>.Instance.Invoke(eid, param);
		}

		public static void RemoveListener<T>(Enum eid, Action<T> action)
		{
			EventAgent<Enum, T>.Instance.RemoveListener(eid, action);
		}

		public static void AddListener<T1, T2>(Enum eid, Action<T1, T2> action)
		{
			EventAgent<Enum, T1, T2>.Instance.AddListener(eid, action);
		}

		public static void SendEvent<T1, T2>(Enum eid, T1 param1, T2 param2)
		{
			EventAgent<Enum, T1, T2>.Instance.Invoke(eid, param1, param2);
			EventAgentDelegate<Enum>.Instance.Invoke(eid, param1, param2);
		}

		public static void RemoveListener<T1, T2>(Enum eid, Action<T1, T2> action)
		{
			EventAgent<Enum, T1, T2>.Instance.RemoveListener(eid, action);
		}

		public static void AddListener<T1, T2, T3>(Enum eid, Action<T1, T2, T3> action)
		{
			EventAgent<Enum, T1, T2, T3>.Instance.AddListener(eid, action);
		}

		public static void SendEvent<T1, T2, T3>(Enum eid, T1 param1, T2 param2, T3 param3)
		{
			EventAgent<Enum, T1, T2, T3>.Instance.Invoke(eid, param1, param2, param3);
			EventAgentDelegate<Enum>.Instance.Invoke(eid, param1, param2, param3);
		}

		public static void RemoveListener<T1, T2, T3>(Enum eid, Action<T1, T2, T3> action)
		{
			EventAgent<Enum, T1, T2, T3>.Instance.RemoveListener(eid, action);
		}

		public static void AddListener<T1, T2, T3, T4>(Enum eid, Action<T1, T2, T3, T4> action)
		{
			EventAgent<Enum, T1, T2, T3, T4>.Instance.AddListener(eid, action);
		}

		public static void SendEvent<T1, T2, T3, T4>(Enum eid, T1 param1, T2 param2, T3 param3, T4 param4)
		{
			EventAgent<Enum, T1, T2, T3, T4>.Instance.Invoke(eid, param1, param2, param3, param4);
			EventAgentDelegate<Enum>.Instance.Invoke(eid, param1, param2, param3, param4);
		}

		public static void RemoveListener<T1, T2, T3, T4>(Enum eid, Action<T1, T2, T3, T4> action)
		{
			EventAgent<Enum, T1, T2, T3, T4>.Instance.RemoveListener(eid, action);
		}

		public static void AddListener(string eid, Action action)
		{
			EventAgent<string>.Instance.AddListener(eid, action);
		}

		public static void SendEvent(string eid)
		{
			EventAgent<string>.Instance.Invoke(eid);
			EventAgentDelegate<string>.Instance.Invoke(eid);
		}

		public static void RemoveListener(string eid, Action action)
		{
			EventAgent<string>.Instance.RemoveListener(eid, action);
		}

		public static void AddListener<T>(string eid, Action<T> action)
		{
			EventAgent<string, T>.Instance.AddListener(eid, action);
		}

		public static void SendEvent<T>(string eid, T param)
		{
			EventAgent<string, T>.Instance.Invoke(eid, param);
			EventAgentDelegate<string>.Instance.Invoke(eid, param);
		}

		public static void RemoveListener<T>(string eid, Action<T> action)
		{
			EventAgent<string, T>.Instance.RemoveListener(eid, action);
		}

		public static void AddListener<T1, T2>(string eid, Action<T1, T2> action)
		{
			EventAgent<string, T1, T2>.Instance.AddListener(eid, action);
		}

		public static void SendEvent<T1, T2>(string eid, T1 param1, T2 param2)
		{
			EventAgent<string, T1, T2>.Instance.Invoke(eid, param1, param2);
			EventAgentDelegate<string>.Instance.Invoke(eid, param1, param2);
		}

		public static void RemoveListener<T1, T2>(string eid, Action<T1, T2> action)
		{
			EventAgent<string, T1, T2>.Instance.RemoveListener(eid, action);
		}

		public static void AddListener<T1, T2, T3>(string eid, Action<T1, T2, T3> action)
		{
			EventAgent<string, T1, T2, T3>.Instance.AddListener(eid, action);
		}

		public static void SendEvent<T1, T2, T3>(string eid, T1 param1, T2 param2, T3 param3)
		{
			EventAgent<string, T1, T2, T3>.Instance.Invoke(eid, param1, param2, param3);
			EventAgentDelegate<string>.Instance.Invoke(eid, param1, param2, param3);
		}

		public static void RemoveListener<T1, T2, T3>(string eid, Action<T1, T2, T3> action)
		{
			EventAgent<string, T1, T2, T3>.Instance.RemoveListener(eid, action);
		}

		public static void AddListener<T1, T2, T3, T4>(string eid, Action<T1, T2, T3, T4> action)
		{
			EventAgent<string, T1, T2, T3, T4>.Instance.AddListener(eid, action);
		}

		public static void SendEvent<T1, T2, T3, T4>(string eid, T1 param1, T2 param2, T3 param3, T4 param4)
		{
			EventAgent<string, T1, T2, T3, T4>.Instance.Invoke(eid, param1, param2, param3, param4);
			EventAgentDelegate<string>.Instance.Invoke(eid, param1, param2, param3, param4);
		}

		public static void RemoveListener<T1, T2, T3, T4>(string eid, Action<T1, T2, T3, T4> action)
		{
			EventAgent<string, T1, T2, T3, T4>.Instance.RemoveListener(eid, action);
		}

		public static void AddListener(int eid, Action action)
		{
			EventAgent<int>.Instance.AddListener(eid, action);
		}

		public static void SendEvent(int eid)
		{
			EventAgent<int>.Instance.Invoke(eid);
			EventAgentDelegate<int>.Instance.Invoke(eid);
		}

		public static void RemoveListener(int eid, Action action)
		{
			EventAgent<int>.Instance.RemoveListener(eid, action);
		}

		public static void AddListener<T>(int eid, Action<T> action)
		{
			EventAgent<int, T>.Instance.AddListener(eid, action);
		}

		public static void SendEvent<T>(int eid, T param)
		{
			EventAgent<int, T>.Instance.Invoke(eid, param);
			EventAgentDelegate<int>.Instance.Invoke(eid, param);
		}

		public static void RemoveListener<T>(int eid, Action<T> action)
		{
			EventAgent<int, T>.Instance.RemoveListener(eid, action);
		}

		public static void AddListener<T1, T2>(int eid, Action<T1, T2> action)
		{
			EventAgent<int, T1, T2>.Instance.AddListener(eid, action);
		}

		public static void SendEvent<T1, T2>(int eid, T1 param1, T2 param2)
		{
			EventAgent<int, T1, T2>.Instance.Invoke(eid, param1, param2);
			EventAgentDelegate<int>.Instance.Invoke(eid, param1, param2);
		}

		public static void RemoveListener<T1, T2>(int eid, Action<T1, T2> action)
		{
			EventAgent<int, T1, T2>.Instance.RemoveListener(eid, action);
		}

		public static void AddListener<T1, T2, T3>(int eid, Action<T1, T2, T3> action)
		{
			EventAgent<int, T1, T2, T3>.Instance.AddListener(eid, action);
		}

		public static void SendEvent<T1, T2, T3>(int eid, T1 param1, T2 param2, T3 param3)
		{
			EventAgent<int, T1, T2, T3>.Instance.Invoke(eid, param1, param2, param3);
			EventAgentDelegate<int>.Instance.Invoke(eid, param1, param2, param3);
		}

		public static void RemoveListener<T1, T2, T3>(int eid, Action<T1, T2, T3> action)
		{
			EventAgent<int, T1, T2, T3>.Instance.RemoveListener(eid, action);
		}

		public static void AddListener<T1, T2, T3, T4>(int eid, Action<T1, T2, T3, T4> action)
		{
			EventAgent<int, T1, T2, T3, T4>.Instance.AddListener(eid, action);
		}

		public static void SendEvent<T1, T2, T3, T4>(int eid, T1 param1, T2 param2, T3 param3, T4 param4)
		{
			EventAgent<int, T1, T2, T3, T4>.Instance.Invoke(eid, param1, param2, param3, param4);
			EventAgentDelegate<int>.Instance.Invoke(eid, param1, param2, param3, param4);
		}

		public static void RemoveListener<T1, T2, T3, T4>(int eid, Action<T1, T2, T3, T4> action)
		{
			EventAgent<int, T1, T2, T3, T4>.Instance.RemoveListener(eid, action);
		}

		public static void AddListener(object eid, Action action)
		{
			EventAgent<object>.Instance.AddListener(eid, action);
		}

		public static void SendEvent(object eid)
		{
			EventAgent<object>.Instance.Invoke(eid);
		}

		public static void RemoveListener(object eid, Action action)
		{
			EventAgent<object>.Instance.RemoveListener(eid, action);
		}

		public static void AddListener<T>(object eid, Action<T> action)
		{
			EventAgent<object, T>.Instance.AddListener(eid, action);
		}

		public static void SendEvent<T>(object eid, T param)
		{
			EventAgent<object, T>.Instance.Invoke(eid, param);
		}

		public static void RemoveListener<T>(object eid, Action<T> action)
		{
			EventAgent<object, T>.Instance.RemoveListener(eid, action);
		}

		public static void AddListener<T1, T2>(object eid, Action<T1, T2> action)
		{
			EventAgent<object, T1, T2>.Instance.AddListener(eid, action);
		}

		public static void SendEvent<T1, T2>(object eid, T1 param1, T2 param2)
		{
			EventAgent<object, T1, T2>.Instance.Invoke(eid, param1, param2);
		}

		public static void RemoveListener<T1, T2>(object eid, Action<T1, T2> action)
		{
			EventAgent<object, T1, T2>.Instance.RemoveListener(eid, action);
		}

		public static void AddListener<T1, T2, T3>(object eid, Action<T1, T2, T3> action)
		{
			EventAgent<object, T1, T2, T3>.Instance.AddListener(eid, action);
		}

		public static void SendEvent<T1, T2, T3>(object eid, T1 param1, T2 param2, T3 param3)
		{
			EventAgent<object, T1, T2, T3>.Instance.Invoke(eid, param1, param2, param3);
		}

		public static void RemoveListener<T1, T2, T3>(object eid, Action<T1, T2, T3> action)
		{
			EventAgent<object, T1, T2, T3>.Instance.RemoveListener(eid, action);
		}

		public static void AddListener<T1, T2, T3, T4>(object eid, Action<T1, T2, T3, T4> action)
		{
			EventAgent<object, T1, T2, T3, T4>.Instance.AddListener(eid, action);
		}

		public static void SendEvent<T1, T2, T3, T4>(object eid, T1 param1, T2 param2, T3 param3, T4 param4)
		{
			EventAgent<object, T1, T2, T3, T4>.Instance.Invoke(eid, param1, param2, param3, param4);
		}

		public static void RemoveListener<T1, T2, T3, T4>(object eid, Action<T1, T2, T3, T4> action)
		{
			EventAgent<object, T1, T2, T3, T4>.Instance.RemoveListener(eid, action);
		}
	}
	public class SignalBase
	{
		protected int _methodCount;

		protected Delegate[] _methods;

		public SignalBase(int capacity)
		{
			_methods = new Delegate[capacity];
			_methodCount = 0;
		}

		public SignalBase()
		{
			_methods = new Delegate[50];
			_methodCount = 0;
		}

		public void AddListener(Delegate del, bool bInsertAtFirst)
		{
			if (bInsertAtFirst)
			{
				if (_methods[0] == del)
				{
					return;
				}
				Delegate[] array = ((_methodCount + 1 <= _methods.Length) ? new Delegate[_methods.Length] : new Delegate[_methods.Length * 2]);
				bool flag = false;
				int num = 0;
				array[num++] = del;
				for (int i = 0; i < _methodCount; i++)
				{
					if (_methods[i] == del)
					{
						flag = true;
					}
					else
					{
						array[num++] = _methods[i];
					}
				}
				if (!flag)
				{
					_methodCount++;
				}
				_methods = array;
				return;
			}
			for (int j = 0; j < _methodCount; j++)
			{
				if (_methods[j] == del)
				{
					return;
				}
			}
			if (_methodCount + 1 > _methods.Length)
			{
				Delegate[] array2 = new Delegate[_methods.Length * 2];
				Array.Copy(_methods, 0, array2, 0, _methodCount);
				_methods = array2;
			}
			_methods[_methodCount] = del;
			_methodCount++;
		}

		public void RemoveListener(Delegate del)
		{
			int methodCount = _methodCount;
			for (int i = 0; i < methodCount; i++)
			{
				if (_methods[i] == del)
				{
					_methodCount--;
					_methods[i] = null;
					for (int j = i; j < _methodCount; j++)
					{
						_methods[j] = _methods[j + 1];
					}
					break;
				}
			}
		}

		public void RemoveAllListeners()
		{
			for (int i = 0; i < _methodCount; i++)
			{
				_methods[i] = null;
			}
			_methodCount = 0;
		}

		public int GetListenerCount()
		{
			return _methodCount;
		}

		public Delegate[] GetInvokeList()
		{
			throw new NotImplementedException();
		}
	}
	public class SignalDelegate : SignalBase
	{
		public static SignalDelegate operator +(SignalDelegate p1, Delegate p2)
		{
			p1.AddListener(p2, bInsertAtFirst: false);
			return p1;
		}

		public static SignalDelegate operator -(SignalDelegate p1, Delegate p2)
		{
			p1.RemoveListener(p2);
			return p1;
		}

		public void Invoke()
		{
			int methodCount = _methodCount;
			for (int i = 0; i < methodCount; i++)
			{
				Delegate @delegate = _methods[i];
				if ((object)@delegate != null)
				{
					(@delegate as Action)();
				}
			}
		}

		public void Invoke<T0>(T0 t0)
		{
			int methodCount = _methodCount;
			for (int i = 0; i < methodCount; i++)
			{
				Delegate @delegate = _methods[i];
				if ((object)@delegate != null)
				{
					(@delegate as Action<T0>)(t0);
				}
			}
		}

		public void Invoke<T0, T1>(T0 t0, T1 t1)
		{
			int methodCount = _methodCount;
			for (int i = 0; i < methodCount; i++)
			{
				Delegate @delegate = _methods[i];
				if ((object)@delegate != null)
				{
					(@delegate as Action<T0, T1>)(t0, t1);
				}
			}
		}

		public void Invoke<T0, T1, T2>(T0 t0, T1 t1, T2 t2)
		{
			int methodCount = _methodCount;
			for (int i = 0; i < methodCount; i++)
			{
				Delegate @delegate = _methods[i];
				if ((object)@delegate != null)
				{
					(@delegate as Action<T0, T1, T2>)(t0, t1, t2);
				}
			}
		}

		public void Invoke<T0, T1, T2, T3>(T0 t0, T1 t1, T2 t2, T3 t3)
		{
			int methodCount = _methodCount;
			for (int i = 0; i < methodCount; i++)
			{
				Delegate @delegate = _methods[i];
				if ((object)@delegate != null)
				{
					(@delegate as Action<T0, T1, T2, T3>)(t0, t1, t2, t3);
				}
			}
		}

		public void InvokeSafe()
		{
			try
			{
				Invoke();
			}
			catch (Exception message)
			{
				UnityEngine.Debug.LogError(message);
			}
		}

		public void InvokeSafe<T0>(T0 t0)
		{
			try
			{
				Invoke(t0);
			}
			catch (Exception message)
			{
				UnityEngine.Debug.LogError(message);
			}
		}

		public void InvokeSafe<T0, T1>(T0 t0, T1 t1)
		{
			try
			{
				Invoke(t0, t1);
			}
			catch (Exception message)
			{
				UnityEngine.Debug.LogError(message);
			}
		}

		public void InvokeSafe<T0, T1, T2>(T0 t0, T1 t1, T2 t2)
		{
			try
			{
				Invoke(t0, t1, t2);
			}
			catch (Exception message)
			{
				UnityEngine.Debug.LogError(message);
			}
		}

		public void InvokeSafe<T0, T1, T2, T3>(T0 t0, T1 t1, T2 t2, T3 t3)
		{
			try
			{
				Invoke(t0, t1, t2, t3);
			}
			catch (Exception message)
			{
				UnityEngine.Debug.LogError(message);
			}
		}

		public SignalDelegate(int capacity)
			: base(capacity)
		{
		}

		public SignalDelegate()
		{
		}
	}
	public class Signal : SignalBase
	{
		public static Signal operator +(Signal p1, Action p2)
		{
			p1.AddListener(p2);
			return p1;
		}

		public static Signal operator -(Signal p1, Action p2)
		{
			p1.RemoveListener(p2);
			return p1;
		}

		public void AddListener(Action a, bool bInsertAtFirst = false)
		{
			AddListener((Delegate)a, bInsertAtFirst);
		}

		public void RemoveListener(Action a)
		{
			RemoveListener((Delegate)a);
		}

		public void Invoke()
		{
			int methodCount = _methodCount;
			for (int i = 0; i < methodCount; i++)
			{
				Delegate @delegate = _methods[i];
				if ((object)@delegate != null)
				{
					(@delegate as Action)();
				}
			}
		}

		public void InvokeSafe()
		{
			try
			{
				int methodCount = _methodCount;
				for (int i = 0; i < methodCount; i++)
				{
					Delegate @delegate = _methods[i];
					if ((object)@delegate != null)
					{
						(@delegate as Action)();
					}
				}
			}
			catch (Exception message)
			{
				UnityEngine.Debug.LogError(message);
			}
		}

		public Signal(int capacity)
			: base(capacity)
		{
		}

		public Signal()
		{
		}
	}
	public class Signal<T> : SignalBase
	{
		public static Signal<T> operator +(Signal<T> p1, Action<T> p2)
		{
			p1.AddListener(p2);
			return p1;
		}

		public static Signal<T> operator -(Signal<T> p1, Action<T> p2)
		{
			p1.RemoveListener(p2);
			return p1;
		}

		public void AddListener(Action<T> a, bool bInsertAtFirst = false)
		{
			AddListener((Delegate)a, bInsertAtFirst);
		}

		public void RemoveListener(Action<T> a)
		{
			RemoveListener((Delegate)a);
		}

		public void Invoke(T t1)
		{
			int methodCount = _methodCount;
			for (int i = 0; i < methodCount; i++)
			{
				Delegate @delegate = _methods[i];
				if ((object)@delegate != null)
				{
					(@delegate as Action<T>)(t1);
				}
			}
		}

		public void InvokeSafe(T t)
		{
			try
			{
				int methodCount = _methodCount;
				for (int i = 0; i < methodCount; i++)
				{
					Delegate @delegate = _methods[i];
					if ((object)@delegate != null)
					{
						(@delegate as Action<T>)(t);
					}
				}
			}
			catch (Exception message)
			{
				UnityEngine.Debug.LogError(message);
			}
		}

		public void AddListener(Signal<GameObject> selectedModel)
		{
			throw new NotImplementedException();
		}

		public Signal(int capacity)
			: base(capacity)
		{
		}

		public Signal()
		{
		}
	}
	public class Signal<T1, T2> : SignalBase
	{
		public static Signal<T1, T2> operator +(Signal<T1, T2> p1, Action<T1, T2> p2)
		{
			p1.AddListener(p2);
			return p1;
		}

		public static Signal<T1, T2> operator -(Signal<T1, T2> p1, Action<T1, T2> p2)
		{
			p1.RemoveListener(p2);
			return p1;
		}

		public void AddListener(Action<T1, T2> a, bool bInsertAtFirst = false)
		{
			AddListener((Delegate)a, bInsertAtFirst);
		}

		public void RemoveListener(Action<T1, T2> a)
		{
			RemoveListener((Delegate)a);
		}

		public void Invoke(T1 t1, T2 t2)
		{
			int methodCount = _methodCount;
			for (int i = 0; i < methodCount; i++)
			{
				Delegate @delegate = _methods[i];
				if ((object)@delegate != null)
				{
					(@delegate as Action<T1, T2>)(t1, t2);
				}
			}
		}

		public void InvokeSafe(T1 t1, T2 t2)
		{
			try
			{
				int methodCount = _methodCount;
				for (int i = 0; i < methodCount; i++)
				{
					Delegate @delegate = _methods[i];
					if ((object)@delegate != null)
					{
						(@delegate as Action<T1, T2>)(t1, t2);
					}
				}
			}
			catch (Exception message)
			{
				UnityEngine.Debug.LogError(message);
			}
		}

		public Signal(int capacity)
			: base(capacity)
		{
		}

		public Signal()
		{
		}
	}
	public class Signal<T1, T2, T3> : SignalBase
	{
		public static Signal<T1, T2, T3> operator +(Signal<T1, T2, T3> p1, Action<T1, T2, T3> p2)
		{
			p1.AddListener(p2);
			return p1;
		}

		public static Signal<T1, T2, T3> operator -(Signal<T1, T2, T3> p1, Action<T1, T2, T3> p2)
		{
			p1.RemoveListener(p2);
			return p1;
		}

		public void AddListener(Action<T1, T2, T3> a, bool bInsertAtFirst = false)
		{
			AddListener((Delegate)a, bInsertAtFirst);
		}

		public void RemoveListener(Action<T1, T2, T3> a)
		{
			RemoveListener((Delegate)a);
		}

		public void Invoke(T1 t1, T2 t2, T3 t3)
		{
			int methodCount = _methodCount;
			for (int i = 0; i < methodCount; i++)
			{
				Delegate @delegate = _methods[i];
				if ((object)@delegate != null)
				{
					(@delegate as Action<T1, T2, T3>)(t1, t2, t3);
				}
			}
		}

		public void InvokeSafe(T1 t1, T2 t2, T3 t3)
		{
			try
			{
				int methodCount = _methodCount;
				for (int i = 0; i < methodCount; i++)
				{
					Delegate @delegate = _methods[i];
					if ((object)@delegate != null)
					{
						(@delegate as Action<T1, T2, T3>)(t1, t2, t3);
					}
				}
			}
			catch (Exception message)
			{
				UnityEngine.Debug.LogError(message);
			}
		}

		public Signal(int capacity)
			: base(capacity)
		{
		}

		public Signal()
		{
		}
	}
	public class Signal<T1, T2, T3, T4> : SignalBase
	{
		public static Signal<T1, T2, T3, T4> operator +(Signal<T1, T2, T3, T4> p1, Action<T1, T2, T3, T4> p2)
		{
			p1.AddListener(p2);
			return p1;
		}

		public static Signal<T1, T2, T3, T4> operator -(Signal<T1, T2, T3, T4> p1, Action<T1, T2, T3, T4> p2)
		{
			p1.RemoveListener(p2);
			return p1;
		}

		public void AddListener(Action<T1, T2, T3, T4> a, bool bInsertAtFirst = false)
		{
			AddListener((Delegate)a, bInsertAtFirst);
		}

		public void RemoveListener(Action<T1, T2, T3, T4> a)
		{
			RemoveListener((Delegate)a);
		}

		public void Invoke(T1 t1, T2 t2, T3 t3, T4 t4)
		{
			int methodCount = _methodCount;
			for (int i = 0; i < methodCount; i++)
			{
				Delegate @delegate = _methods[i];
				if ((object)@delegate != null)
				{
					(@delegate as Action<T1, T2, T3, T4>)(t1, t2, t3, t4);
				}
			}
		}

		public void InvokeSafe(T1 t1, T2 t2, T3 t3, T4 t4)
		{
			try
			{
				int methodCount = _methodCount;
				for (int i = 0; i < methodCount; i++)
				{
					Delegate @delegate = _methods[i];
					if ((object)@delegate != null)
					{
						(@delegate as Action<T1, T2, T3, T4>)(t1, t2, t3, t4);
					}
				}
			}
			catch (Exception message)
			{
				UnityEngine.Debug.LogError(message);
			}
		}

		public Signal(int capacity)
			: base(capacity)
		{
		}

		public Signal()
		{
		}
	}
	[AttributeUsage(AttributeTargets.Method)]
	public class RegisterCommandAttribute : Attribute
	{
		private string m_command;

		private string m_description;

		private object m_instance;

		private string[] m_parameterNames;

		public string Command
		{
			get
			{
				return m_command;
			}
			set
			{
				m_command = value;
			}
		}

		public string Description => m_description;

		public string[] ParameterNames => m_parameterNames;

		public RegisterCommandAttribute(string command, string description, params string[] parameterNames)
		{
			m_command = command;
			m_description = description;
			m_parameterNames = parameterNames;
		}

		public RegisterCommandAttribute(string command = null)
		{
			m_command = command;
		}
	}
}
namespace CommandTerminal
{
	public static class BuiltinCommands
	{
		[RegisterCommand(null, Help = "Clear the command console", MaxArgCount = 0)]
		private static void CommandClear(CommandArg[] args)
		{
			Terminal.Buffer.Clear();
		}

		[RegisterCommand(null, Help = "Display help information about a command", MaxArgCount = 1)]
		private static void CommandHelp(CommandArg[] args)
		{
			if (args.Length == 0)
			{
				foreach (KeyValuePair<string, CommandInfo> command in Terminal.Shell.Commands)
				{
					Terminal.Log("{0}: {1}", command.Key.PadRight(16), command.Value.help);
				}
				return;
			}
			string text = args[0].String.ToUpper();
			if (!Terminal.Shell.Commands.ContainsKey(text))
			{
				Terminal.Shell.IssueErrorMessage("Command {0} could not be found.", text);
				return;
			}
			CommandInfo commandInfo = Terminal.Shell.Commands[text];
			if (commandInfo.help == null)
			{
				Terminal.Log("{0} does not provide any help documentation.", text);
			}
			else if (commandInfo.hint == null)
			{
				Terminal.Log(commandInfo.help);
			}
			else
			{
				Terminal.Log("{0}\nUsage: {1}", commandInfo.help, commandInfo.hint);
			}
		}

		[RegisterCommand(null, Help = "Time the execution of a command", MinArgCount = 1)]
		private static void CommandTime(CommandArg[] args)
		{
			Stopwatch stopwatch = new Stopwatch();
			stopwatch.Start();
			Terminal.Shell.RunCommand(JoinArguments(args));
			stopwatch.Stop();
			Terminal.Log("Time: {0}ms", (double)stopwatch.ElapsedTicks / 10000.0);
		}

		[RegisterCommand(null, Help = "Output message")]
		private static void CommandPrint(CommandArg[] args)
		{
			Terminal.Log(JoinArguments(args));
		}

		[RegisterCommand(null, Help = "List all variables or set a variable value")]
		private static void CommandSet(CommandArg[] args)
		{
			if (args.Length == 0)
			{
				foreach (KeyValuePair<string, CommandArg> variable in Terminal.Shell.Variables)
				{
					Terminal.Log("{0}: {1}", variable.Key.PadRight(16), variable.Value);
				}
				return;
			}
			string @string = args[0].String;
			if (@string[0] == '$')
			{
				Terminal.Log(TerminalLogType.Warning, "Warning: Variable name starts with '$', '${0}'.", @string);
			}
			Terminal.Shell.SetVariable(@string, JoinArguments(args, 1));
		}

		[RegisterCommand(null, Help = "No operation")]
		private static void CommandNoop(CommandArg[] args)
		{
		}

		[RegisterCommand(null, Help = "Quit running application", MaxArgCount = 0)]
		private static void CommandQuit(CommandArg[] args)
		{
			Application.Quit();
		}

		private static string JoinArguments(CommandArg[] args, int start = 0)
		{
			StringBuilder stringBuilder = new StringBuilder();
			int num = args.Length;
			for (int i = start; i < num; i++)
			{
				stringBuilder.Append(args[i].String);
				if (i < num - 1)
				{
					stringBuilder.Append(" ");
				}
			}
			return stringBuilder.ToString();
		}
	}
	public class CommandAutocomplete
	{
		private List<string> known_words = new List<string>();

		private List<string> buffer = new List<string>();

		public void Register(string word)
		{
			if (!known_words.Contains(word))
			{
				known_words.Add(word.ToLower());
			}
		}

		public string[] Complete(ref string text, ref int format_width)
		{
			string value = EatLastWord(ref text).ToLower();
			for (int i = 0; i < known_words.Count; i++)
			{
				string text2 = known_words[i];
				if (text2.StartsWith(value))
				{
					buffer.Add(text2);
					if (text2.Length > format_width)
					{
						format_width = text2.Length;
					}
				}
			}
			string[] array = buffer.ToArray();
			buffer.Clear();
			text += PartialWord(array);
			return array;
		}

		private string EatLastWord(ref string text)
		{
			int num = text.LastIndexOf(' ');
			string result = text.Substring(num + 1);
			text = text.Substring(0, num + 1);
			return result;
		}

		private string PartialWord(string[] words)
		{
			if (words.Length == 0)
			{
				return "";
			}
			string text = words[0];
			int num = text.Length;
			if (words.Length == 1)
			{
				return text;
			}
			foreach (string text2 in words)
			{
				if (num > text2.Length)
				{
					num = text2.Length;
				}
				for (int j = 0; j < num; j++)
				{
					if (text2[j] != text[j])
					{
						num = j;
					}
				}
			}
			return text.Substring(0, num);
		}
	}
	public class CommandHistory
	{
		private List<string> history = new List<string>();

		private int position;

		public void Push(string command_string)
		{
			if (!(command_string == ""))
			{
				history.Add(command_string);
				position = history.Count;
			}
		}

		public string Next()
		{
			position++;
			if (position >= history.Count)
			{
				position = history.Count;
				return "";
			}
			return history[position];
		}

		public string Previous()
		{
			if (history.Count == 0)
			{
				return "";
			}
			position--;
			if (position < 0)
			{
				position = 0;
			}
			return history[position];
		}

		public void Clear()
		{
			history.Clear();
			position = 0;
		}
	}
	public enum TerminalLogType
	{
		Error,
		Assert,
		Warning,
		Message,
		Exception,
		Input,
		ShellMessage
	}
	public struct LogItem
	{
		public TerminalLogType type;

		public string message;

		public string stack_trace;
	}
	public class CommandLog
	{
		private List<LogItem> logs = new List<LogItem>();

		private int max_items;

		public List<LogItem> Logs => logs;

		public CommandLog(int max_items)
		{
			this.max_items = max_items;
		}

		public void HandleLog(string message, TerminalLogType type)
		{
			HandleLog(message, "", type);
		}

		public void HandleLog(string message, string stack_trace, TerminalLogType type)
		{
			LogItem logItem = default(LogItem);
			logItem.message = message;
			logItem.stack_trace = stack_trace;
			logItem.type = type;
			LogItem item = logItem;
			logs.Add(item);
			if (logs.Count > max_items)
			{
				logs.RemoveAt(0);
			}
		}

		public void Clear()
		{
			logs.Clear();
		}
	}
	public struct CommandInfo
	{
		public Action<CommandArg[]> proc;

		public int max_arg_count;

		public int min_arg_count;

		public string help;

		public string hint;
	}
	public struct CommandArg
	{
		public string String { get; set; }

		public int Int
		{
			get
			{
				if (int.TryParse(String, out var result))
				{
					return result;
				}
				TypeError("int");
				return 0;
			}
		}

		public float Float
		{
			get
			{
				if (float.TryParse(String, out var result))
				{
					return result;
				}
				TypeError("float");
				return 0f;
			}
		}

		public bool Bool
		{
			get
			{
				if (string.Compare(String, "TRUE", ignoreCase: true) == 0)
				{
					return true;
				}
				if (string.Compare(String, "FALSE", ignoreCase: true) == 0)
				{
					return false;
				}
				TypeError("bool");
				return false;
			}
		}

		public override string ToString()
		{
			return String;
		}

		private void TypeError(string expected_type)
		{
			Terminal.Shell.IssueErrorMessage("Incorrect type for {0}, expected <{1}>", String, expected_type);
		}
	}
	public class CommandShell
	{
		private Dictionary<string, CommandInfo> commands = new Dictionary<string, CommandInfo>();

		private Dictionary<string, CommandArg> variables = new Dictionary<string, CommandArg>();

		private List<CommandArg> arguments = new List<CommandArg>();

		public string IssuedErrorMessage { get; private set; }

		public Dictionary<string, CommandInfo> Commands => commands;

		public Dictionary<string, CommandArg> Variables => variables;

		public void RegisterCommands()
		{
			Dictionary<string, CommandInfo> dictionary = new Dictionary<string, CommandInfo>();
			BindingFlags bindingAttr = BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic;
			Type[] types = Assembly.GetExecutingAssembly().GetTypes();
			for (int i = 0; i < types.Length; i++)
			{
				MethodInfo[] methods = types[i].GetMethods(bindingAttr);
				foreach (MethodInfo methodInfo in methods)
				{
					RegisterCommandAttribute registerCommandAttribute = Attribute.GetCustomAttribute(methodInfo, typeof(RegisterCommandAttribute)) as RegisterCommandAttribute;
					if (registerCommandAttribute == null)
					{
						if (!methodInfo.Name.StartsWith("FRONTCOMMAND", StringComparison.CurrentCultureIgnoreCase))
						{
							continue;
						}
						registerCommandAttribute = new RegisterCommandAttribute();
					}
					ParameterInfo[] parameters = methodInfo.GetParameters();
					string text = InferFrontCommandName(methodInfo.Name);
					text = ((registerCommandAttribute.Name != null) ? registerCommandAttribute.Name : InferCommandName((text == null) ? methodInfo.Name : text));
					if (parameters.Length != 1 || parameters[0].ParameterType != typeof(CommandArg[]))
					{
						dictionary.Add(text.ToUpper(), CommandFromParamInfo(parameters, registerCommandAttribute.Help));
						continue;
					}
					Action<CommandArg[]> proc = (Action<CommandArg[]>)Delegate.CreateDelegate(typeof(Action<CommandArg[]>), methodInfo);
					AddCommand(text, proc, registerCommandAttribute.MinArgCount, registerCommandAttribute.MaxArgCount, registerCommandAttribute.Help, registerCommandAttribute.Hint);
				}
			}
			HandleRejectedCommands(dictionary);
		}

		public void RunCommand(string line)
		{
			string s = line;
			IssuedErrorMessage = null;
			arguments.Clear();
			while (s != "")
			{
				CommandArg item = EatArgument(ref s);
				if (!(item.String != ""))
				{
					continue;
				}
				if (item.String[0] == '$')
				{
					string key = item.String.Substring(1).ToUpper();
					if (variables.ContainsKey(key))
					{
						item = variables[key];
					}
				}
				arguments.Add(item);
			}
			if (arguments.Count != 0)
			{
				string text = arguments[0].String.ToUpper();
				arguments.RemoveAt(0);
				if (!commands.ContainsKey(text))
				{
					IssueErrorMessage("Command {0} could not be found", text);
				}
				else
				{
					RunCommand(text, arguments.ToArray());
				}
			}
		}

		public void RunCommand(string command_name, CommandArg[] arguments)
		{
			CommandInfo commandInfo = commands[command_name];
			int num = arguments.Length;
			string text = null;
			int num2 = 0;
			if (num < commandInfo.min_arg_count)
			{
				text = ((commandInfo.min_arg_count != commandInfo.max_arg_count) ? "at least" : "exactly");
				num2 = commandInfo.min_arg_count;
			}
			else if (commandInfo.max_arg_count > -1 && num > commandInfo.max_arg_count)
			{
				text = ((commandInfo.min_arg_count != commandInfo.max_arg_count) ? "at most" : "exactly");
				num2 = commandInfo.max_arg_count;
			}
			if (text != null)
			{
				string text2 = ((num2 == 1) ? "" : "s");
				IssueErrorMessage("{0} requires {1} {2} argument{3}", command_name, text, num2, text2);
				if (commandInfo.hint != null)
				{
					IssuedErrorMessage += $"\n    -> Usage: {commandInfo.hint}";
				}
			}
			else
			{
				EventManager.SendEvent(command_name, arguments);
			}
		}

		public void AddCommand(string name, CommandInfo info)
		{
			name = name.ToUpper();
			if (!commands.ContainsKey(name))
			{
				commands.Add(name, info);
			}
			EventManager.AddListener(name, info.proc);
		}

		public void AddCommand(string name, Action<CommandArg[]> proc, int min_args = 0, int max_args = -1, string help = "", string hint = null)
		{
			CommandInfo commandInfo = default(CommandInfo);
			commandInfo.proc = proc;
			commandInfo.min_arg_count = min_args;
			commandInfo.max_arg_count = max_args;
			commandInfo.help = help;
			commandInfo.hint = hint;
			CommandInfo info = commandInfo;
			Terminal.Autocomplete.Register(name);
			AddCommand(name, info);
		}

		public void SetVariable(string name, string value)
		{
			SetVariable(name, new CommandArg
			{
				String = value
			});
		}

		public void SetVariable(string name, CommandArg value)
		{
			name = name.ToUpper();
			if (variables.ContainsKey(name))
			{
				variables[name] = value;
			}
			else
			{
				variables.Add(name, value);
			}
		}

		public CommandArg GetVariable(string name)
		{
			name = name.ToUpper();
			if (variables.ContainsKey(name))
			{
				return variables[name];
			}
			IssueErrorMessage("No variable named {0}", name);
			return default(CommandArg);
		}

		public void IssueErrorMessage(string format, params object[] message)
		{
			IssuedErrorMessage = string.Format(format, message);
		}

		private string InferCommandName(string method_name)
		{
			int num = method_name.IndexOf("COMMAND", StringComparison.CurrentCultureIgnoreCase);
			if (num >= 0)
			{
				return method_name.Remove(num, 7);
			}
			return method_name;
		}

		private string InferFrontCommandName(string method_name)
		{
			int num = method_name.IndexOf("FRONT", StringComparison.CurrentCultureIgnoreCase);
			if (num < 0)
			{
				return null;
			}
			return method_name.Remove(num, 5);
		}

		private void HandleRejectedCommands(Dictionary<string, CommandInfo> rejected_commands)
		{
			foreach (KeyValuePair<string, CommandInfo> rejected_command in rejected_commands)
			{
				if (commands.ContainsKey(rejected_command.Key))
				{
					commands[rejected_command.Key] = new CommandInfo
					{
						proc = commands[rejected_command.Key].proc,
						min_arg_count = rejected_command.Value.min_arg_count,
						max_arg_count = rejected_command.Value.max_arg_count,
						help = rejected_command.Value.help
					};
				}
				else
				{
					IssueErrorMessage("{0} is missing a front command.", rejected_command);
				}
			}
		}

		private CommandInfo CommandFromParamInfo(ParameterInfo[] parameters, string help)
		{
			int num = 0;
			for (int i = 0; i < parameters.Length; i++)
			{
				if (parameters[i].IsOptional)
				{
					num++;
				}
			}
			CommandInfo result = default(CommandInfo);
			result.proc = null;
			result.min_arg_count = parameters.Length - num;
			result.max_arg_count = parameters.Length;
			result.help = help;
			return result;
		}

		private CommandArg EatArgument(ref string s)
		{
			CommandArg result = default(CommandArg);
			int num = s.IndexOf(' ');
			if (num >= 0)
			{
				result.String = s.Substring(0, num);
				s = s.Substring(num + 1);
			}
			else
			{
				result.String = s;
				s = "";
			}
			return result;
		}
	}
	[AttributeUsage(AttributeTargets.Method)]
	public class RegisterCommandAttribute : Attribute
	{
		private int min_arg_count;

		private int max_arg_count = -1;

		public int MinArgCount
		{
			get
			{
				return min_arg_count;
			}
			set
			{
				min_arg_count = value;
			}
		}

		public int MaxArgCount
		{
			get
			{
				return max_arg_count;
			}
			set
			{
				max_arg_count = value;
			}
		}

		public string Name { get; set; }

		public string Help { get; set; }

		public string Hint { get; set; }

		public RegisterCommandAttribute(string command_name = null)
		{
			Name = command_name;
		}
	}
	public enum TerminalState
	{
		Close,
		OpenSmall,
		OpenFull
	}
	public class Terminal : MonoBehaviour
	{
		[Header("Window")]
		[Range(0f, 1f)]
		[SerializeField]
		private float MaxHeight = 0.7f;

		[SerializeField]
		[Range(0f, 1f)]
		private float SmallTerminalRatio = 0.33f;

		[Range(100f, 1000f)]
		[SerializeField]
		private float ToggleSpeed = 360f;

		[SerializeField]
		private string ToggleHotkey = "`";

		[SerializeField]
		private string ToggleFullHotkey = "#`";

		[SerializeField]
		private int BufferSize = 512;

		[Header("Input")]
		[SerializeField]
		private Font ConsoleFont;

		[SerializeField]
		private string InputCaret = ">";

		[SerializeField]
		private bool ShowGUIButtons;

		[SerializeField]
		private bool RightAlignButtons;

		[Header("Theme")]
		[Range(0f, 1f)]
		[SerializeField]
		private float InputContrast;

		[Range(0f, 1f)]
		[SerializeField]
		private float InputAlpha = 0.5f;

		[SerializeField]
		private Color BackgroundColor = Color.black;

		[SerializeField]
		private Color ForegroundColor = Color.white;

		[SerializeField]
		private Color ShellColor = Color.white;

		[SerializeField]
		private Color InputColor = Color.cyan;

		[SerializeField]
		private Color WarningColor = Color.yellow;

		[SerializeField]
		private Color ErrorColor = Color.red;

		public bool upload;

		private TerminalState state;

		private TextEditor editor_state;

		private bool input_fix;

		private bool move_cursor;

		private bool initial_open;

		private Rect window;

		private float current_open_t;

		private float open_target;

		private float real_window_size;

		private string command_text;

		private string cached_command_text;

		private Vector2 scroll_position;

		private GUIStyle window_style;

		private GUIStyle label_style;

		private GUIStyle input_style;

		private Texture2D background_texture;

		private Texture2D input_background_texture;

		private string url = "http://47.110.142.168:8080/insert?name=Neo2&log=[{\"level\":{},\"time\":\"{}\",\"info\":\"{}\"}]";

		public static CommandLog Buffer { get; private set; }

		public static CommandShell Shell { get; private set; }

		public static CommandHistory History { get; private set; }

		public static CommandAutocomplete Autocomplete { get; private set; }

		public static bool IssuedError => Shell.IssuedErrorMessage != null;

		public bool IsClosed
		{
			get
			{
				if (state == TerminalState.Close)
				{
					return Mathf.Approximately(current_open_t, open_target);
				}
				return false;
			}
		}

		public static void Log(string format, params object[] message)
		{
			Log(TerminalLogType.ShellMessage, format, message);
		}

		public static void Log(TerminalLogType type, string format, params object[] message)
		{
			Buffer.HandleLog(string.Format(format, message), type);
		}

		public void SetState(TerminalState new_state)
		{
			input_fix = true;
			cached_command_text = command_text;
			command_text = "";
			switch (new_state)
			{
			case TerminalState.Close:
				open_target = 0f;
				break;
			case TerminalState.OpenSmall:
				open_target = (float)Screen.height * MaxHeight * SmallTerminalRatio;
				if (current_open_t > open_target)
				{
					open_target = 0f;
					state = TerminalState.Close;
					return;
				}
				real_window_size = open_target;
				scroll_position.y = 2.1474836E+09f;
				break;
			default:
				real_window_size = (float)Screen.height * MaxHeight;
				open_target = real_window_size;
				break;
			}
			state = new_state;
		}

		public void ToggleState(TerminalState new_state)
		{
			if (state == new_state)
			{
				SetState(TerminalState.Close);
			}
			else
			{
				SetState(new_state);
			}
		}

		private void OnEnable()
		{
			Buffer = new CommandLog(BufferSize);
			Shell = new CommandShell();
			History = new CommandHistory();
			Autocomplete = new CommandAutocomplete();
			Application.logMessageReceivedThreaded += HandleUnityLog;
		}

		private void OnDisable()
		{
			Application.logMessageReceivedThreaded -= HandleUnityLog;
		}

		private void Start()
		{
			if (ConsoleFont == null)
			{
				ConsoleFont = Font.CreateDynamicFontFromOSFont("Courier New", 16);
				UnityEngine.Debug.LogWarning("Command Console Warning: Please assign a font.");
			}
			command_text = "";
			cached_command_text = command_text;
			SetupWindow();
			SetupInput();
			SetupLabels();
			Shell.RegisterCommands();
			if (IssuedError)
			{
				Log(TerminalLogType.Error, "Error: {0}", Shell.IssuedErrorMessage);
			}
			foreach (KeyValuePair<string, CommandInfo> command in Shell.Commands)
			{
				Autocomplete.Register(command.Key);
			}
			UnityEngine.Debug.Log(url);
		}

		private void OnGUI()
		{
			if (Event.current.Equals(Event.KeyboardEvent(ToggleHotkey)))
			{
				SetState(TerminalState.OpenSmall);
				initial_open = true;
			}
			else if (Event.current.Equals(Event.KeyboardEvent(ToggleFullHotkey)))
			{
				SetState(TerminalState.OpenFull);
				initial_open = true;
			}
			if (ShowGUIButtons)
			{
				DrawGUIButtons();
			}
			if (!IsClosed)
			{
				HandleOpenness();
				window = GUILayout.Window(88, window, DrawConsole, "", window_style);
			}
		}

		private void SetupWindow()
		{
			real_window_size = (float)Screen.height * MaxHeight / 3f;
			window = new Rect(0f, current_open_t - real_window_size, Screen.width, real_window_size);
			background_texture = new Texture2D(1, 1);
			background_texture.SetPixel(0, 0, BackgroundColor);
			background_texture.Apply();
			window_style = new GUIStyle();
			window_style.normal.background = background_texture;
			window_style.padding = new RectOffset(4, 4, 4, 4);
			window_style.normal.textColor = ForegroundColor;
			window_style.font = ConsoleFont;
		}

		private void SetupLabels()
		{
			label_style = new GUIStyle();
			label_style.font = ConsoleFont;
			label_style.normal.textColor = ForegroundColor;
			label_style.wordWrap = true;
		}

		private void SetupInput()
		{
			input_style = new GUIStyle();
			input_style.padding = new RectOffset(4, 4, 4, 4);
			input_style.font = ConsoleFont;
			input_style.fixedHeight = (float)ConsoleFont.fontSize * 1.6f;
			input_style.normal.textColor = InputColor;
			Color color = default(Color);
			color.r = BackgroundColor.r - InputContrast;
			color.g = BackgroundColor.g - InputContrast;
			color.b = BackgroundColor.b - InputContrast;
			color.a = InputAlpha;
			input_background_texture = new Texture2D(1, 1);
			input_background_texture.SetPixel(0, 0, color);
			input_background_texture.Apply();
			input_style.normal.background = input_background_texture;
		}

		private void DrawConsole(int Window2D)
		{
			GUILayout.BeginVertical();
			scroll_position = GUILayout.BeginScrollView(scroll_position, false, false, GUIStyle.none, GUIStyle.none);
			GUILayout.FlexibleSpace();
			DrawLogs();
			GUILayout.EndScrollView();
			if (move_cursor)
			{
				CursorToEnd();
				move_cursor = false;
			}
			if (Event.current.Equals(Event.KeyboardEvent("escape")))
			{
				SetState(TerminalState.Close);
			}
			else if (Event.current.Equals(Event.KeyboardEvent("return")) || Event.current.Equals(Event.KeyboardEvent("[enter]")))
			{
				EnterCommand();
			}
			else if (Event.current.Equals(Event.KeyboardEvent("up")))
			{
				command_text = History.Previous();
				move_cursor = true;
			}
			else if (Event.current.Equals(Event.KeyboardEvent("down")))
			{
				command_text = History.Next();
			}
			else if (Event.current.Equals(Event.KeyboardEvent(ToggleHotkey)))
			{
				ToggleState(TerminalState.OpenSmall);
			}
			else if (Event.current.Equals(Event.KeyboardEvent(ToggleFullHotkey)))
			{
				ToggleState(TerminalState.OpenFull);
			}
			else if (Event.current.Equals(Event.KeyboardEvent("tab")))
			{
				CompleteCommand();
				move_cursor = true;
			}
			GUILayout.BeginHorizontal();
			if (InputCaret != "")
			{
				GUILayout.Label(InputCaret, input_style, GUILayout.Width(ConsoleFont.fontSize));
			}
			GUI.SetNextControlName("command_text_field");
			command_text = GUILayout.TextField(command_text, input_style);
			if (input_fix && command_text.Length > 0)
			{
				command_text = cached_command_text;
				input_fix = false;
			}
			if (initial_open)
			{
				GUI.FocusControl("command_text_field");
				initial_open = false;
			}
			if (ShowGUIButtons && GUILayout.Button("| run", input_style, GUILayout.Width(Screen.width / 10)))
			{
				EnterCommand();
			}
			GUILayout.EndHorizontal();
			GUILayout.EndVertical();
		}

		private void DrawLogs()
		{
			foreach (LogItem log in Buffer.Logs)
			{
				label_style.normal.textColor = GetLogColor(log.type);
				GUILayout.Label(log.message, label_style);
			}
		}

		private void DrawGUIButtons()
		{
			int fontSize = ConsoleFont.fontSize;
			GUILayout.BeginArea(new Rect(RightAlignButtons ? (Screen.width - 7 * fontSize) : 0, current_open_t, 7 * fontSize, fontSize * 2));
			GUILayout.BeginHorizontal();
			if (GUILayout.Button("Small", window_style))
			{
				ToggleState(TerminalState.OpenSmall);
			}
			else if (GUILayout.Button("Full", window_style))
			{
				ToggleState(TerminalState.OpenFull);
			}
			GUILayout.EndHorizontal();
			GUILayout.EndArea();
		}

		private void HandleOpenness()
		{
			float num = ToggleSpeed * Time.unscaledDeltaTime;
			if (current_open_t < open_target)
			{
				current_open_t += num;
				if (current_open_t > open_target)
				{
					current_open_t = open_target;
				}
			}
			else
			{
				if (!(current_open_t > open_target))
				{
					if (input_fix)
					{
						input_fix = false;
					}
					return;
				}
				current_open_t -= num;
				if (current_open_t < open_target)
				{
					current_open_t = open_target;
				}
			}
			window = new Rect(0f, current_open_t - real_window_size, Screen.width, real_window_size);
		}

		private void EnterCommand()
		{
			Log(TerminalLogType.Input, "{0}", command_text);
			Shell.RunCommand(command_text);
			History.Push(command_text);
			if (IssuedError)
			{
				Log(TerminalLogType.Error, "Error: {0}", Shell.IssuedErrorMessage);
			}
			command_text = "";
			scroll_position.y = 2.1474836E+09f;
		}

		private void CompleteCommand()
		{
			string text = command_text;
			int format_width = 0;
			string[] array = Autocomplete.Complete(ref text, ref format_width);
			int num = array.Length;
			if (num != 0)
			{
				command_text = text;
			}
			if (num > 1)
			{
				StringBuilder stringBuilder = new StringBuilder();
				string[] array2 = array;
				foreach (string text2 in array2)
				{
					stringBuilder.Append(text2.PadRight(format_width + 4));
				}
				Log("{0}", stringBuilder);
				scroll_position.y = 2.1474836E+09f;
			}
			CursorToEnd();
		}

		private void CursorToEnd()
		{
			if (editor_state == null)
			{
				editor_state = (TextEditor)GUIUtility.GetStateObject(typeof(TextEditor), GUIUtility.keyboardControl);
			}
			editor_state.MoveCursorToPosition(new Vector2(999f, 999f));
		}

		private void HandleUnityLog(string message, string stack_trace, LogType type)
		{
			Buffer.HandleLog(message, stack_trace, (TerminalLogType)type);
			scroll_position.y = 2.1474836E+09f;
			_ = upload;
		}

		private Color GetLogColor(TerminalLogType type)
		{
			return type switch
			{
				TerminalLogType.Message => ForegroundColor, 
				TerminalLogType.Warning => WarningColor, 
				TerminalLogType.Input => InputColor, 
				TerminalLogType.ShellMessage => ShellColor, 
				_ => ErrorColor, 
			};
		}
	}
}
