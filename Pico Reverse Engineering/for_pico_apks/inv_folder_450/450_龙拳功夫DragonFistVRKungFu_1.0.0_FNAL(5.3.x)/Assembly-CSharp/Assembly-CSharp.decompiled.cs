using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.Serialization.Formatters.Binary;
using System.Text;
using AOT;
using BeautifyEffect;
using BoundarySystem_Ext;
using LitJson;
using Pvr_UnitySDKAPI;
using Pvr_UnitySDKAPI.Achievement;
using RootMotion.Demos;
using RootMotion.Dynamics;
using RootMotion.FinalIK;
using TMPro;
using UnityEngine;
using UnityEngine.Analytics;
using UnityEngine.Android;
using UnityEngine.Audio;
using UnityEngine.EventSystems;
using UnityEngine.Events;
using UnityEngine.Networking;
using UnityEngine.Rendering;
using UnityEngine.SceneManagement;
using UnityEngine.UI;
using UnityEngine.XR;
using UnityStandardAssets.Cameras;
using VolumetricFogAndMist;

[assembly: CompilationRelaxations(8)]
[assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)]
[assembly: Debuggable(DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)]
[assembly: AssemblyVersion("0.0.0.0")]
public class Random_movement : MonoBehaviour
{
	private Vector3 dir;

	private void Start()
	{
		dir = Quaternion.Euler(0f, UnityEngine.Random.Range(0f, 360f), 0f) * Vector3.forward;
	}

	private void FixedUpdate()
	{
		base.transform.Translate(dir / 20f);
	}
}
public class demo_scene_control : MonoBehaviour
{
	public Transform c_point;

	public Transform c_point1;

	public Transform f_point;

	public Transform[] style1 = new Transform[8];

	public Transform[] style2 = new Transform[8];

	public Transform[] style3 = new Transform[8];

	public Transform[] style4 = new Transform[8];

	private GameObject current;

	private int style;

	private int cur_effect;

	private int max_n = 11;

	private void Start()
	{
		Restart();
	}

	private void Update()
	{
		base.transform.RotateAround(c_point1.transform.position, Vector3.up, 0.5f);
	}

	private void OnGUI()
	{
		string text = current.name;
		text = text.Substring(0, text.Length - 7);
		GUI.Label(new Rect(15f, 10f, 200f, 20f), text);
		if (GUI.Button(new Rect(290f, 30f, 90f, 30f), "Style1"))
		{
			style = 0;
			Restart();
		}
		if (GUI.Button(new Rect(390f, 30f, 90f, 30f), "Style 2"))
		{
			style = 1;
			Restart();
		}
		if (GUI.Button(new Rect(490f, 30f, 90f, 30f), "Style 3"))
		{
			style = 2;
			Restart();
		}
		if (GUI.Button(new Rect(590f, 30f, 90f, 30f), "Style 4"))
		{
			style = 3;
			Restart();
		}
		if (GUI.Button(new Rect(10f, 30f, 40f, 30f), "<-"))
		{
			if (cur_effect <= 0)
			{
				cur_effect = max_n;
			}
			else
			{
				cur_effect--;
			}
			Restart();
		}
		if (GUI.Button(new Rect(60f, 30f, 40f, 30f), "->"))
		{
			if (cur_effect >= max_n)
			{
				cur_effect = 0;
			}
			else
			{
				cur_effect++;
			}
			Restart();
		}
	}

	private void Restart()
	{
		Transform transform = c_point;
		UnityEngine.Object.Destroy(current);
		if (cur_effect == 4 || cur_effect == 5)
		{
			transform.transform.eulerAngles = new Vector3(0f, -90f, 0f);
			transform.transform.position = c_point1.transform.position + new Vector3(1f, 1f, 0f);
		}
		else if (cur_effect == 6 || cur_effect == 7)
		{
			transform.transform.eulerAngles = c_point1.transform.eulerAngles;
			transform.transform.position = c_point1.transform.position + new Vector3(0f, 1f, 0f);
		}
		else if (cur_effect == 10 || cur_effect == 11)
		{
			transform.transform.eulerAngles = new Vector3(0f, 0f, 0f);
			transform.transform.position = c_point1.transform.position + new Vector3(0f, 1f, 0f);
		}
		else
		{
			transform.transform.eulerAngles = c_point1.transform.eulerAngles;
			transform.transform.position = c_point1.transform.position;
		}
		if (style == 0)
		{
			current = UnityEngine.Object.Instantiate(style1[cur_effect], transform.transform.position, transform.transform.rotation).gameObject;
		}
		if (style == 1)
		{
			current = UnityEngine.Object.Instantiate(style2[cur_effect], transform.transform.position, transform.transform.rotation).gameObject;
		}
		if (style == 2)
		{
			current = UnityEngine.Object.Instantiate(style3[cur_effect], transform.transform.position, transform.transform.rotation).gameObject;
		}
		if (style == 3)
		{
			current = UnityEngine.Object.Instantiate(style4[cur_effect], transform.transform.position, transform.transform.rotation).gameObject;
		}
	}
}
public class AIController : MonoBehaviour
{
	public GameCharacter gameCharacter;

	public Transform aiTrackerContainer;

	public Transform[] aiTrackers;

	public Transform trackerContainer;

	public Transform[] trackers;

	public Transform[] ikTrackers;

	public Transform[] followTrackers;

	private Vector3[] defaultPositions;

	private Quaternion[] defaultRotations;

	public bool debug;

	public Transform moveToDebug;

	public float minDist = 1f;

	public float minAttackHeight = 1f;

	public float tryAttackTime = 2f;

	public float resetTime;

	public float nextStanceTime;

	public float impatientTimer = 15f;

	public bool doneImpatience;

	public float facingAngle;

	public Vector3 walkTarget;

	public Vector3 walkSpeedTarget;

	private Vector3 playerTarget;

	public Vector3 playerLookTarget;

	public bool doingSpecial;

	public int doingMove;

	public int specialMoveMove;

	public int stance;

	public float heightAdjust;

	public float enemyHeadY;

	public float targetHeightAdjust;

	public float heightAdjustTimer = 3f;

	public float angleDiff;

	private float dodgeTimer;

	private int lastMove = -1;

	private float sameMoveTimer;

	public MoveWithController playerController;

	public MoveReplayer replayer;

	public int fightAI_chargeIn;

	public bool fightAI_targetPlayer;

	public string fightAI_keepAway;

	public bool fightAI_considerAbandonMove;

	public bool fightAI_pathClear;

	public float fightAI_sizeupTime;

	public float fightAI_keepAwayTime;

	public float fightAI_sizeupSpeedPerc;

	public float tauntTime;

	public float tauntSpeed;

	private bool doneTaunt;

	public float blindPerc;

	private float changeTargetTimer = 1f;

	public LayerMask pathRayMask;

	public LayerMask dodgeDetectLayers;

	public Vector3 stanceOffset;

	private float minHandRadius = 1f;

	private float dodgeDist = 1.5f;

	private float dodgeMinSpeed = 3f;

	public bool verbose;

	public ChamberFighter chamberArea;

	private Vector3 lastRHandPos;

	private Vector3 lastLHandPos;

	private Vector3 walk;

	public int attacksDone;

	public float headTurnTimer;

	public float headLookPerc;

	private float nextJumpTime;

	public bool stayStillForMove;

	public bool dontTurnForMove;

	public float rangeBias = 1f;

	public MinMax rangeBiasRange;

	public float walkSpeedMod = 1f;

	public float walkSpeedChange = 1f;

	public float dashTimer;

	public float clampDiv = 1f;

	public float landOffset;

	private float turnSpeed;

	private void Start()
	{
		targetHeightAdjust = 1f;
		replayer = GetComponent<MoveReplayer>();
		List<Collider> list = new List<Collider>();
		BodyPartData[] bodyParts = gameCharacter.rigidBodies.bodyParts;
		foreach (BodyPartData bodyPartData in bodyParts)
		{
			if (!bodyPartData.isHandOrLowerArm)
			{
				list.Add(bodyPartData.hittable.collider);
			}
		}
		replayer.keepOutside = list.ToArray();
		enemyHeadY = 1.75f;
		replayer.head = aiTrackers[0];
		replayer.l_hand = aiTrackers[1];
		replayer.r_hand = aiTrackers[2];
		replayer.l_offset = trackers[1].GetComponent<PuppetTrackerHandOffset>();
		replayer.r_offset = trackers[2].GetComponent<PuppetTrackerHandOffset>();
		gameCharacter.dynamicTrackers[0].gameObject.SetActive(value: false);
		gameCharacter.dynamicTrackers[1].gameObject.SetActive(value: false);
		doingMove = -1;
		specialMoveMove = -1;
		defaultPositions = new Vector3[aiTrackers.Length];
		defaultRotations = new Quaternion[aiTrackers.Length];
		for (int j = 0; j < aiTrackers.Length; j++)
		{
			defaultPositions[j] = aiTrackers[j].localPosition;
			defaultRotations[j] = aiTrackers[j].localRotation;
		}
		resetTime = 0.1f;
		walkTarget = base.transform.right * 2f;
		heightAdjust = 1f;
		tryAttackTime = 0.1f;
		walk = Vector3.zero;
		sizeUp(1f);
	}

	public void sizeUp(float mod)
	{
		if (!(fightAI_sizeupTime > 0f))
		{
			fightAI_sizeupTime = Settings.instance.aiSizeupTime.random() * mod;
			fightAI_sizeupSpeedPerc = UnityEngine.Random.value;
			headLookPerc = UnityEngine.Random.value / 2f;
		}
	}

	public void reset()
	{
		replayer.doAction(fightingStyle().idle, loop: true, offsetHeight: false, 0.4f, "Reset");
	}

	public int chargeIn()
	{
		Vector3 vector = gameCharacter.targetEnemy.standPosition - gameCharacter.standPosition;
		if (!gameCharacter.targetEnemy.rigidBodies.fall.gotUp)
		{
			return -1;
		}
		if (facingAngle > 45f)
		{
			return -1;
		}
		if (vector.magnitude < 1.5f)
		{
			return 0;
		}
		if (gameCharacter.targetEnemy.rigidBodies.dazed())
		{
			return 1;
		}
		if (gameCharacter.targetEnemy.targetEnemy == this && gameCharacter.targetEnemy.rigidBodies.staminaPerc() < gameCharacter.rigidBodies.staminaPerc() * 0.85f)
		{
			return 1;
		}
		int num = 0;
		foreach (CharacterEffect effect in gameCharacter.effects)
		{
			if (effect.effectData != null)
			{
				if (effect.effectData.whenHasEffect == CharacterEffectData.AIType.ChargeIn)
				{
					num++;
				}
				else if (effect.effectData.whenHasEffect == CharacterEffectData.AIType.RunAway)
				{
					num--;
				}
			}
		}
		return num;
	}

	private void gotoDefaultPositions()
	{
		for (int i = 0; i < aiTrackers.Length; i++)
		{
			aiTrackers[i].localPosition = Vector3.MoveTowards(aiTrackers[i].localPosition, defaultPositions[i], Time.deltaTime);
			if (i > 0)
			{
				aiTrackers[i].localRotation = Quaternion.RotateTowards(aiTrackers[i].localRotation, defaultRotations[i], Time.deltaTime * 45f);
			}
		}
	}

	private void walkTowards(Vector3 targetPos, float speedPerc = 1f, bool clamp = true)
	{
		if (clamp)
		{
			targetPos = GameController.instance.standButtons.clampPos(targetPos);
		}
		if (stayStillForMove)
		{
			walkSpeedTarget = Vector3.zero;
			walk = Vector3.MoveTowards(walk, walkSpeedTarget, Time.deltaTime * 5f);
			return;
		}
		Vector3 vector = targetPos - gameCharacter.standPosition;
		vector.y = 0f;
		vector = Vector3.ClampMagnitude(vector, 1f);
		walkSpeedTarget = vector * speedPerc;
		if (Time.time > nextJumpTime && Physics.Raycast(gameCharacter.standPosition + Vector3.up * 0.25f, walkSpeedTarget, out var hitInfo, 1f, gameCharacter.mover.scenery))
		{
			nextJumpTime = Time.time + 2f + UnityEngine.Random.value;
			float num = Quaternion.Angle(Quaternion.LookRotation(GameController.flatVector(gameCharacter.rigidBodies.face.transform.forward)), Quaternion.LookRotation(GameController.flatVector(hitInfo.point - gameCharacter.rigidBodies.face.transform.position)));
			if (hitInfo.collider.tag == "Kickable" && num < 15f)
			{
				gameCharacter.kickController.Kick();
			}
			else if (GameController.instance.standButtons.ai_Jumping && !Physics.Raycast(gameCharacter.standPosition + Vector3.up * 1.5f, walkSpeedTarget, 1f, gameCharacter.mover.scenery))
			{
				gameCharacter.vrCharacterController.jump();
			}
		}
	}

	private void turnToPlayer()
	{
		if (gameCharacter.targetEnemy == null)
		{
			return;
		}
		if (gameCharacter.kickController.kicking || gameCharacter.rigidBodies.isDown(allTheWay: false) || gameCharacter.targetEnemy == null)
		{
			turnSpeed = 0f;
			return;
		}
		Vector3 vector = diffToTarget();
		vector.y = 0f;
		Quaternion b = Quaternion.LookRotation(-vector);
		angleDiff = Quaternion.Angle(aiTrackerContainer.transform.rotation, b);
		float num = 10f;
		if (angleDiff > num)
		{
			turnSpeed = Mathf.MoveTowards(turnSpeed, 1f, Time.deltaTime);
			aiTrackerContainer.transform.rotation = Quaternion.Slerp(aiTrackerContainer.transform.rotation, b, GameController.instance.difficultyLevel.aiTurnSpeed.lerp(gameCharacter.difficulty) * Time.deltaTime * turnSpeed / 20f);
			return;
		}
		turnSpeed = Mathf.MoveTowards(turnSpeed, 0f, Time.deltaTime);
		float num2 = 1f - angleDiff / num;
		num2 *= num2;
		aiTrackerContainer.transform.rotation = Quaternion.Slerp(aiTrackerContainer.transform.rotation, b, GameController.instance.difficultyLevel.aiTurnSpeed.lerp(gameCharacter.difficulty) * num2);
	}

	public FightingStyle fightingStyle()
	{
		return MoveRecorder.instance.actions.fightingStyles[gameCharacter.fightingStyle];
	}

	public float taunt(float delay)
	{
		Invoke("taunt", delay);
		return 2f;
	}

	public float taunt()
	{
		taunt(speak: true);
		tauntTime = 0.5f;
		return 2f;
	}

	public float taunt(bool speak)
	{
		replayer.doAction(fightingStyle().taunt, loop: false, offsetHeight: false, 0.4f, "Taunt");
		tauntSpeed = 0.8f + UnityEngine.Random.value * 0.2f;
		tauntTime = fightingStyle().taunt.totalTime / tauntSpeed / (gameCharacter.rigidBodies.aiSpeed * moveSpeedMod());
		resetTime = tauntTime - 1f;
		if (speak && OptionData.getBool("Voices"))
		{
			return gameCharacter.rigidBodies.say(gameCharacter.data.voice.IntroPhrase(gameCharacter.data.fightsFinished > 0));
		}
		return tauntTime;
	}

	public void FinalWinVoice()
	{
		Invoke("OnWinVoice", 0.5f);
	}

	private void OnWinVoice()
	{
		bool flag = gameCharacter.targetEnemy.lives == 0;
		VoiceData voice = gameCharacter.data.voice.PhraseOfType(flag ? VoiceData.Type.OnWinFinal : VoiceData.Type.OnWin, 1f);
		gameCharacter.rigidBodies.say(voice);
	}

	private void switchStance(float switchTime, string note)
	{
		minAttackHeight = 1000f;
		doingMove = -1;
		stayStillForMove = false;
		dontTurnForMove = false;
		clampDiv = UnityEngine.Random.Range(1f, 4f);
		dashTimer = 1f;
		dodgeDist = UnityEngine.Random.value + 1f;
		dodgeMinSpeed = 2f + UnityEngine.Random.value * 3f;
		if (gameCharacter.targetEnemy != null && gameCharacter.targetEnemy.rigidBodies.isDown(allTheWay: true) && !doneTaunt && chamberArea == null)
		{
			taunt(speak: false);
			if (gameCharacter.id == 1)
			{
				Invoke("OnWinVoice", 0.5f);
				headLookPerc = 0.8f;
			}
			else
			{
				headLookPerc = ((UnityEngine.Random.value < 0.5f) ? 0.5f : 0f);
			}
			doneTaunt = true;
			return;
		}
		gameCharacter.rigidBodies.aiSpeed = GameController.instance.difficultyLevel.aiSpeed.lerp(gameCharacter.difficulty) * Settings.instance.aiSpeedVariance.random();
		if (nextStanceTime <= 0f)
		{
			if (gameCharacter.data.fightStyleName == "All")
			{
				gameCharacter.randomFightingStyle();
			}
			stance = UnityEngine.Random.Range(0, fightingStyle().stances.Count);
			if (chamberArea != null)
			{
				resetTime = (nextStanceTime = 1f + UnityEngine.Random.value);
			}
			else
			{
				resetTime = (nextStanceTime = Settings.instance.aiStanceSwitchFrequency.random());
			}
		}
		if (gameCharacter.targetEnemy != null)
		{
			Vector3 vector = diffToTarget();
			if (gameCharacter.targetEnemy.isPlayer())
			{
				stanceOffset = Quaternion.Euler(0f, Settings.instance.aiStanceOffsetAngle.random(), 0f) * vector.normalized * Settings.instance.aiStanceOffsetDistance.random();
			}
			else
			{
				stanceOffset = Quaternion.Euler(0f, Settings.instance.aiStanceOffsetAngle.random(), 0f) * vector.normalized * Settings.instance.aiStanceOffsetDistance_vsAI.random();
			}
		}
		else
		{
			stanceOffset = Vector3.zero;
		}
		resetThink();
		if (attacksDone > 2)
		{
			attacksDone = 0;
			if ((double)UnityEngine.Random.value < 0.3)
			{
				fightAI_keepAwayTime = 1f + UnityEngine.Random.value * 2f;
			}
			else
			{
				sizeUp(0.4f);
			}
		}
		else if (UnityEngine.Random.value < 0.1f && nextStanceTime == 0f)
		{
			sizeUp(UnityEngine.Random.value);
		}
		if (chamberArea != null)
		{
			replayer.doAction(fightingStyle().stances[stance].stance, loop: true, offsetHeight: false, switchTime, note);
			return;
		}
		if (fightingStyle().stances.Count == 0)
		{
			replayer.doAction(MoveRecorder.instance.actions.defaultAction, loop: true, offsetHeight: false, switchTime, note);
			return;
		}
		replayer.doAction(fightingStyle().stances[stance].stance, loop: true, offsetHeight: false, switchTime, note);
		if (debug)
		{
			FaceCanvasController.addText("Change Stance: " + stance);
		}
	}

	public Vector3 diffToTarget()
	{
		if (gameCharacter.targetEnemy == null)
		{
			return Vector3.zero;
		}
		return gameCharacter.standPosition - playerTarget;
	}

	public FightingStyle_Stance currentStance()
	{
		return fightingStyle().stances[stance];
	}

	public SpecialMove specialMove()
	{
		return gameCharacter.specialMove.move();
	}

	public RecordAction currentAttack()
	{
		if (specialMoveMove > -1)
		{
			return specialMove().ai_attacks[specialMoveMove];
		}
		if (currentStance().attacks.Count == 0)
		{
			UnityEngine.Debug.LogError("Stance has not attacks");
		}
		if (doingMove >= currentStance().attacks.Count)
		{
			doingMove = currentStance().attacks.Count - 1;
		}
		return currentStance().attacks[doingMove];
	}

	public bool pathClear(Vector3 to, RigidBodies target)
	{
		Vector3 direction = new Vector3(to.x, 1f, to.y) - gameCharacter.rigidBodies.bodyParts[0].rb.position;
		direction.y = 0f;
		Ray ray = new Ray(gameCharacter.rigidBodies.bodyParts[0].rb.position + direction.normalized * 0.5f, direction);
		if (to.y - gameCharacter.standPosition.y > 1.5f)
		{
			return false;
		}
		if (Physics.Raycast(ray, out var hitInfo, ray.direction.magnitude, pathRayMask))
		{
			Hittable component = hitInfo.collider.GetComponent<Hittable>();
			if (component != null && component.rb != target)
			{
				if (!(component.rb.character == gameCharacter))
				{
					fightAI_pathClear = false;
				}
				return fightAI_pathClear;
			}
		}
		fightAI_pathClear = true;
		return fightAI_pathClear;
	}

	public void onHit()
	{
		updatePlayerTarget(ignoreBlind: true);
		fightAI_considerAbandonMove = true;
		fightAI_keepAwayTime = 0f;
	}

	private void counters()
	{
		if (currentStance().counters.Count == 0)
		{
			return;
		}
		dodgeTimer -= Time.deltaTime;
		if (dodgeTimer <= 0f)
		{
			dodgeTimer += 1f;
		}
		float num = GameController.instance.difficultyLevel.aiDodgeLikelihood.lerp(gameCharacter.difficulty);
		num /= Mathf.Lerp(1f, 10f, blindPerc);
		if (dodgeTimer > num / 2f)
		{
			return;
		}
		if (gameCharacter.targetEnemy.kickController.kicking && (gameCharacter.standPosition - gameCharacter.targetEnemy.standPosition).magnitude < 1.5f)
		{
			List<FightingStyleCounter> list = new List<FightingStyleCounter>();
			foreach (FightingStyleCounter counter in currentStance().counters)
			{
				if (counter.kickViable())
				{
					list.Add(counter);
				}
			}
			if (list.Count > 0)
			{
				FightingStyleCounter fightingStyleCounter = list[UnityEngine.Random.Range(0, list.Count)];
				if (replayer.doAction(fightingStyleCounter.action, loop: false, offsetHeight: true, 0.2f, "Counter"))
				{
					doingMove = 0;
					resetTime = fightingStyleCounter.action.totalTime - 0.5f;
				}
			}
		}
		if (dodgeTimer > num)
		{
			return;
		}
		for (int i = 0; i < 2; i++)
		{
			Hittable obj = ((i == 0) ? gameCharacter.targetEnemy.rigidBodies.leftHand : gameCharacter.targetEnemy.rigidBodies.rightHand);
			Vector3 position = obj.transform.position;
			Vector3 vector = GameController.flatVector(position - gameCharacter.rigidBodies.head.position);
			Vector3 vector2 = GameController.flatVector(((i == 0) ? lastLHandPos : lastRHandPos) - gameCharacter.rigidBodies.head.position);
			if (i == 0)
			{
				lastLHandPos = position;
			}
			else
			{
				lastRHandPos = position;
			}
			if (!(obj.grabHittable == null) || !(vector.magnitude < dodgeDist) || !(vector.magnitude < vector2.magnitude) || !((vector - vector2).magnitude / Time.deltaTime > dodgeMinSpeed))
			{
				continue;
			}
			float y = Quaternion.LookRotation(aiTrackerContainer.forward).eulerAngles.y;
			float y2 = Quaternion.LookRotation(vector).eulerAngles.y;
			float angle = Mathf.Round(Mathf.DeltaAngle(y, y2));
			if (currentStance().counters.Count > 0)
			{
				List<FightingStyleCounter> list2 = new List<FightingStyleCounter>();
				foreach (FightingStyleCounter counter2 in currentStance().counters)
				{
					if (counter2.viable(angle, position.y, gameCharacter.rigidBodies.head.transform.position.y))
					{
						list2.Add(counter2);
					}
				}
				if (list2.Count > 0)
				{
					FightingStyleCounter fightingStyleCounter2 = list2[UnityEngine.Random.Range(0, list2.Count)];
					if (replayer.doAction(fightingStyleCounter2.action, loop: false, offsetHeight: true, 0.2f, "Counter"))
					{
						doingMove = 0;
						resetTime = fightingStyleCounter2.action.totalTime - 0.5f;
					}
					else if (debug)
					{
						FaceCanvasController.addText("Cant Dodge (Busy)");
					}
				}
			}
			else if (debug)
			{
				FaceCanvasController.addText("Cant Dodge (No Options)");
			}
		}
	}

	private void resetThink()
	{
		float num = GameController.instance.difficultyLevel.aiThinkTime.lerp(gameCharacter.difficulty, invert: true) / gameCharacter.damageAutobalance;
		tryAttackTime = UnityEngine.Random.value * num;
		if (gameCharacter.targetEnemy.isPlayer() && fightAI_keepAway == "")
		{
			rangeBias = rangeBiasRange.random();
		}
		else
		{
			rangeBias = 1f;
		}
	}

	private void specialNext()
	{
		resetTime = 5f;
		if (PoseDisplay.instance.showPose(gameCharacter, gameCharacter.specialMove.move().pose))
		{
			gameCharacter.doSpecial();
			float time = specialMoveSpeed() * gameCharacter.doingSpecialData.moveDelayMod;
			specialMoveMove = (gameCharacter.specialMove.kickMove ? (-1) : UnityEngine.Random.Range(0, specialMove().ai_attacks.Count));
			Invoke("specialNext2", time);
		}
		else
		{
			switchStance(0.4f, "Abandon special");
		}
	}

	private void specialNext2()
	{
		if (replayer.isTransitioning())
		{
			Invoke("specialNext2", 0.1f);
		}
		else if (specialMoveMove > -1)
		{
			RecordAction recordAction = specialMove().ai_attacks[specialMoveMove];
			replayer.doAction(recordAction, loop: false, offsetHeight: true, 0.1f, "Special Attack");
			doingSpecial = false;
			if (gameCharacter.doingSpecialData.stayStillDuring)
			{
				stayStillForMove = true;
			}
			if (gameCharacter.doingSpecialData.dontTurnDuring)
			{
				dontTurnForMove = true;
			}
			resetTime = recordAction.totalTime - 0.5f;
			tryAttackTime = recordAction.totalTime;
			specialMoveMove = -1;
		}
		else if (gameCharacter.doingSpecial == 0f && (gameCharacter.specialMove.moveType != SpecialMoveData.Type.NoHands || gameCharacter.specialMove.prefab != null))
		{
			resetTime = 0f;
			doingSpecial = false;
			doingMove = -1;
		}
		else if (doingMove < 0 || doingMove >= specialMove().ai_attacks.Count)
		{
			resetTime = 0f;
			doingSpecial = false;
			doingMove = -1;
		}
		else
		{
			RecordAction recordAction2 = specialMove().ai_attacks[doingMove];
			replayer.doAction(recordAction2, loop: false, offsetHeight: true, 0.1f, "Special Attack");
			doingSpecial = false;
			resetTime = recordAction2.totalTime - 0.5f;
			tryAttackTime = recordAction2.totalTime;
			if (gameCharacter.specialMove.kickMove)
			{
				Invoke("specialKick", 0.1f);
			}
		}
	}

	private void specialKick()
	{
		gameCharacter.kickController.Kick();
		resetTime = 1f;
		tryAttackTime = 1f;
	}

	private float specialMoveSpeed()
	{
		return GameController.instance.difficultyLevel.aiSpecialMoveSpeed.lerp(gameCharacter.difficulty) * moveSpeedMod();
	}

	private float moveSpeedMod()
	{
		return gameCharacter.moveSpeedMod();
	}

	private void updatePlayerTarget(bool ignoreBlind = false)
	{
		if (gameCharacter.targetEnemy == null)
		{
			return;
		}
		if (gameCharacter.targetEnemy.rigidBodies.isDown(allTheWay: false) || !gameCharacter.targetEnemy.rigidBodies.fall.gotUp)
		{
			playerTarget = gameCharacter.targetEnemy.rigidBodies.headHittable.transform.position;
			playerLookTarget = playerTarget;
			playerTarget.y = 0f;
			return;
		}
		if (gameCharacter.targetEnemy.hasEffect(CharacterEffect.Effect.Ghost) || gameCharacter.hasEffect(CharacterEffect.Effect.Blinded))
		{
			blindPerc = 1f;
		}
		else if (gameCharacter.hasEffect(CharacterEffect.Effect.BlindLite))
		{
			blindPerc = 0.25f;
		}
		else
		{
			blindPerc = 0f;
		}
		if (blindPerc > 0f && !ignoreBlind)
		{
			playerTarget = Vector3.MoveTowards(playerTarget, new Vector3(gameCharacter.targetEnemy.standPosition.x, 0f, gameCharacter.targetEnemy.standPosition.z), Time.deltaTime * Mathf.Lerp(2f, 1f, blindPerc));
			playerLookTarget = Vector3.MoveTowards(playerLookTarget, gameCharacter.targetEnemy.rigidBodies.head.position, Time.deltaTime * Mathf.Lerp(1.5f, 3f, blindPerc));
		}
		else
		{
			playerLookTarget = gameCharacter.targetEnemy.rigidBodies.head.position;
			playerTarget = new Vector3(gameCharacter.targetEnemy.standPosition.x, 0f, gameCharacter.targetEnemy.standPosition.z);
		}
		UnityEngine.Debug.DrawLine(playerTarget, playerTarget + Vector3.up, Color.magenta);
	}

	private void Update()
	{
		if (GameController.instance.paused)
		{
			return;
		}
		trackerContainer.position = aiTrackerContainer.position;
		for (int i = 0; i < 3; i++)
		{
			if (i == 0)
			{
				trackers[i].position = aiTrackers[i].position;
				trackers[i].rotation = aiTrackers[i].rotation;
				continue;
			}
			float num = gameCharacter.moveSpeedMod();
			Vector3 position = aiTrackers[i].position;
			Quaternion rotation = aiTrackers[i].rotation;
			trackers[i].position = Vector3.MoveTowards(trackers[i].position, position, Time.deltaTime * Settings.instance.maxMoveSpeed * num);
			trackers[i].rotation = Quaternion.RotateTowards(trackers[i].rotation, rotation, Time.deltaTime * Settings.instance.maxRotateSpeed * num);
		}
		walk = Vector3.MoveTowards(walk, walkSpeedTarget, Time.deltaTime * GameController.instance.difficultyLevel.aiChangeDirSpeed.lerp(gameCharacter.difficulty));
		walkSpeedTarget = Vector3.zero;
		Vector3 vector = diffToTarget();
		vector.y = 0f;
		Quaternion a = Quaternion.LookRotation(-vector);
		Quaternion b = Quaternion.LookRotation(aiTrackerContainer.transform.forward);
		facingAngle = Quaternion.Angle(a, b);
		gameCharacter.mover.moving = walk * walkSpeedMod;
		gameCharacter.rigidBodies.ik.solver.locomotion.maxVelocity = walk.magnitude;
		minHandRadius = Mathf.MoveTowards(minHandRadius, Mathf.Clamp01(gameCharacter.rigidBodies.slide.magnitude / 2f) * 1.5f, Time.deltaTime * 4f);
		walkSpeedChange -= Time.deltaTime;
		if (walkSpeedChange < 0f)
		{
			walkSpeedMod = 0.5f + UnityEngine.Random.value * 0.5f;
			walkSpeedChange = UnityEngine.Random.value + 0.25f;
		}
		bool flag = chamberArea != null;
		if (gameCharacter.rigidBodies.isDown(allTheWay: false) || gameCharacter.hasEffect(CharacterEffect.Effect.Stunned))
		{
			replayer.doAction(fightingStyle().stances[stance].stance, loop: true, offsetHeight: false, 1f, "Knocked out");
			gameCharacter.mover.moving = Vector3.zero;
			MoveRecorder.instance.playback(replayer, gameCharacter.rigidBodies.aiSpeed * moveSpeedMod(), gameCharacter.rigidBodies.heightStandOffset, heightAdjust + landOffset, gameCharacter.headRecoil, gameCharacter.hands, (gameCharacter.rigidBodies.slide.magnitude < 0.1f) ? headLookPerc : 0f);
			return;
		}
		if (PracticeMoveController.isActive(-1))
		{
			updatePlayerTarget();
			gameCharacter.targetEnemy = GameController.instance.player;
			if (gameCharacter.mover.slide.magnitude < 0.01f)
			{
				walkTarget = Vector3.zero;
				walkTowards(walkTarget, 0.5f, clamp: false);
			}
			turnToPlayer();
			counters();
			nextStanceTime -= Time.deltaTime;
			resetTime -= Time.deltaTime * gameCharacter.rigidBodies.aiSpeed * moveSpeedMod();
			if (resetTime <= 0f)
			{
				switchStance(0.4f, "Practice");
			}
			MoveRecorder.instance.playback(replayer, gameCharacter.rigidBodies.aiSpeed * moveSpeedMod(), gameCharacter.rigidBodies.heightStandOffset, heightAdjust + landOffset, gameCharacter.headRecoil, gameCharacter.hands, (gameCharacter.rigidBodies.slide.magnitude < 0.1f) ? headLookPerc : 0f);
			return;
		}
		if (flag)
		{
			updatePlayerTarget();
			Vector3 vector2 = walkTarget - chamberArea.transform.position;
			gameCharacter.targetEnemy = GameController.instance.player;
			if (vector2.magnitude > 2f)
			{
				walkTarget = chamberArea.transform.position + Quaternion.Euler(0f, UnityEngine.Random.value * 360f, 0f) * Vector3.forward;
				int[] array = new int[3] { 0, 15, 2 };
				gameCharacter.fightingStyle = array[UnityEngine.Random.Range(0, array.Length)];
				switchStance(0.5f, "Chamber");
			}
			walkTowards(walkTarget, 0.5f, clamp: false);
			nextStanceTime -= Time.deltaTime;
			resetTime -= Time.deltaTime;
			if (nextStanceTime <= 0f)
			{
				switchStance(0.4f, "Chamber");
			}
			turnToPlayer();
			MoveRecorder.instance.playback(replayer, gameCharacter.rigidBodies.aiSpeed * moveSpeedMod(), gameCharacter.rigidBodies.heightStandOffset, heightAdjust + landOffset, gameCharacter.headRecoil, gameCharacter.hands, (gameCharacter.rigidBodies.slide.magnitude < 0.1f) ? headLookPerc : 0f);
			return;
		}
		if (doingMove == -1 || replayer.playbackElapsed > 0.5f)
		{
			updatePlayerTarget();
		}
		else
		{
			turnSpeed = 0f;
		}
		switch (GameController.instance.ai_Modes[GameController.instance.aiMode].name)
		{
		case "Walkabout":
			if ((walkTarget - base.transform.position).magnitude < 0.1f)
			{
				walkTarget = new Vector3(UnityEngine.Random.Range(-3, 3), 0f, UnityEngine.Random.Range(3, 9));
			}
			walkTowards(walkTarget);
			break;
		case "Turn":
			turnToPlayer();
			break;
		case "Fight":
		{
			if (gameCharacter.targetEnemy == null)
			{
				break;
			}
			UnityEngine.Debug.DrawLine(gameCharacter.standPosition + Vector3.up, gameCharacter.targetEnemy.standPosition + Vector3.up, Color.green);
			if (gameCharacter.rigidBodies.isDown(allTheWay: true))
			{
				doingMove = -1;
				resetTime = 5f;
				changeTargetTimer = 0f;
				turnToPlayer();
				fightAI_keepAwayTime = 2.5f;
			}
			else if (tauntTime > 0f)
			{
				tauntTime -= Time.deltaTime;
				resetTime -= Time.deltaTime;
				if (!gameCharacter.targetEnemy.rigidBodies.isDown(allTheWay: false) && gameCharacter.targetEnemy.rigidBodies.fall.gotUp && diffToTarget().magnitude < 3f && GameController.instance.specialMode.name != "Ninja Challenge")
				{
					Vector3 from = GameController.flatVector(gameCharacter.targetEnemy.trackers.transforms[0].forward);
					Vector3 to = GameController.flatVector(gameCharacter.trackers.transforms[0].position - gameCharacter.targetEnemy.trackers.transforms[0].position);
					if (Vector3.Angle(from, to) < 45f)
					{
						fightAI_sizeupTime = 0f;
						fightAI_keepAway = "";
						tauntTime = 0f;
						resetTime = 0f;
						tryAttackTime = 0.1f;
						switchStance(0.5f, "End of taunt (cut short)");
					}
				}
				turnToPlayer();
				if (diffToTarget().magnitude < 2f)
				{
					walkTowards(gameCharacter.targetEnemy.standPosition + diffToTarget() * 2f);
				}
				if (resetTime <= 0f)
				{
					switchStance(2f, "End of taunt");
				}
			}
			else
			{
				Vector3 vector3 = diffToTarget();
				vector3.y = 0f;
				enemyHeadY = Mathf.MoveTowards(enemyHeadY, (gameCharacter.targetEnemy.trackers.transforms[0].position - gameCharacter.targetEnemy.standPosition).y + 0.1f, Time.deltaTime / 3f);
				if (impatientTimer > 0f)
				{
					if (fightAI_keepAway != "")
					{
						impatientTimer = Mathf.MoveTowards(impatientTimer, 15f, Time.deltaTime);
					}
					else
					{
						impatientTimer = Mathf.MoveTowards(impatientTimer, 0f, Time.deltaTime);
						if (impatientTimer == 0f)
						{
							doneImpatience = true;
							VoiceData voice = gameCharacter.data.voice.PhraseOfType(VoiceData.Type.AfterDelay, 0.5f);
							impatientTimer += 5f;
							gameCharacter.rigidBodies.say(voice);
						}
					}
				}
				fightAI_chargeIn = chargeIn();
				float num2 = GameController.instance.difficultyLevel.aiDashFrequency.lerp(gameCharacter.difficulty);
				if (num2 > 0f)
				{
					dashTimer -= Time.deltaTime * num2;
					if (dashTimer < 0f)
					{
						if (gameCharacter.mover.canDash())
						{
							if (doingMove == -1 || (replayer.playbackElapsed < replayer.currentAction.attackTime / 4f && !gameCharacter.kickController.kicking))
							{
								float magnitude = (playerTarget - gameCharacter.standPosition).magnitude;
								if (fightAI_chargeIn == 1 || doingMove != -1)
								{
									if (magnitude > 1.5f)
									{
										gameCharacter.mover.dash(gameCharacter.targetEnemy.standPosition - gameCharacter.standPosition);
									}
								}
								else if ((fightAI_chargeIn == -1 || fightAI_keepAway != "") && magnitude < 2.5f)
								{
									gameCharacter.mover.dash(gameCharacter.standPosition - gameCharacter.targetEnemy.standPosition);
								}
								else if (magnitude < 3f && magnitude > 1.5f)
								{
									gameCharacter.mover.dash(Quaternion.Euler(0f, UnityEngine.Random.value * 360f, 0f) * Vector3.forward);
								}
								dashTimer = 2f + UnityEngine.Random.value * 5f;
							}
						}
						else
						{
							dashTimer += UnityEngine.Random.value;
						}
					}
				}
				if (fightAI_chargeIn > 0 && pathClear(gameCharacter.targetEnemy.standPosition, gameCharacter.targetEnemy.rigidBodies))
				{
					fightAI_targetPlayer = true;
					if (walkSpeedMod < 1f)
					{
						walkSpeedMod = 1f;
					}
					stanceOffset = -diffToTarget().normalized;
				}
				else if (changeTargetTimer <= 0f)
				{
					fightAI_keepAway = "";
					if (fightAI_keepAway == "" && gameCharacter.rigidBodies.standUpPercMax > 0.1f && gameCharacter.rigidBodies.standUpPerc < gameCharacter.rigidBodies.standUpPercMax * GameController.instance.difficultyLevel.aiCaution.lerp(gameCharacter.difficulty) && gameCharacter.rigidBodies.standUpPerc / 2f < gameCharacter.targetEnemy.rigidBodies.standUpPerc && gameCharacter.targetEnemy.targetEnemy == gameCharacter)
					{
						fightAI_keepAway = "Low Stamina";
					}
					if (fightAI_keepAway == "" && fightAI_keepAwayTime > 0f)
					{
						fightAI_keepAway = "Keep away time>0";
					}
					if (fightAI_chargeIn < 0 && UnityEngine.Random.value < 0.3f)
					{
						fightAI_keepAway = "Scary Effects";
					}
					if ((fightAI_sizeupTime > 0f || GameController.instance.player == null) && fightAI_keepAway == "" && fightAI_chargeIn <= 0)
					{
						changeTargetTimer = 1f + UnityEngine.Random.value * 5f;
						Vector3 vector4 = UnityEngine.Random.insideUnitSphere * vector3.magnitude / 1.5f - vector3 / 2f;
						vector4.y = 0f;
						fightAI_sizeupSpeedPerc = UnityEngine.Random.value;
						fightAI_targetPlayer = false;
						if (gameCharacter.standingIndex > 0)
						{
							vector4 = Quaternion.Euler(0f, 120f * (float)gameCharacter.standingIndex, 0f) * vector4;
						}
						walkTarget = gameCharacter.standPosition + vector4;
						Vector3 vector5 = walkTarget - playerTarget;
						if (vector5.magnitude < 2f)
						{
							walkTarget = playerTarget + vector5.normalized * 2f;
						}
					}
					else
					{
						if ((fightAI_keepAway == "" || fightAI_chargeIn > 0) && facingAngle < 5f)
						{
							if (fightAI_chargeIn > 0 && walkSpeedMod < 1f)
							{
								walkSpeedMod = 1f;
							}
							fightAI_targetPlayer = UnityEngine.Random.value < 0.75f || fightAI_chargeIn > 0;
							Vector3 vector6 = UnityEngine.Random.insideUnitSphere * 4f;
							vector6.y = 0f;
							walkTarget = gameCharacter.standPosition + vector6;
							if (!pathClear((!fightAI_targetPlayer) ? walkTarget : gameCharacter.targetEnemy.standPosition, gameCharacter.targetEnemy.rigidBodies))
							{
								vector6 = UnityEngine.Random.insideUnitSphere * 4f;
								vector6.y = 0f;
								walkTarget = gameCharacter.standPosition + vector6;
							}
						}
						else
						{
							fightAI_targetPlayer = false;
							walkTarget = gameCharacter.targetEnemy.standPosition + Quaternion.Euler(0f, UnityEngine.Random.Range(-1f, 1f) * 50f * (120f * (float)gameCharacter.standingIndex), 0f) * vector3.normalized * UnityEngine.Random.Range(2.5f, 4f);
						}
						if (!GameController.instance.standButtons.inFightArea(walkTarget))
						{
							Vector3 vector7 = GameController.instance.standButtons.clampPos(walkTarget);
							walkTarget = vector7 / clampDiv;
						}
						if (!pathClear((!fightAI_targetPlayer) ? walkTarget : gameCharacter.targetEnemy.standPosition, gameCharacter.targetEnemy.rigidBodies))
						{
							fightAI_targetPlayer = false;
							Vector3 vector8 = UnityEngine.Random.insideUnitSphere * 4f;
							vector8.y = 0f;
							walkTarget = gameCharacter.standPosition + vector8;
						}
						changeTargetTimer = 1f + UnityEngine.Random.value * 1f;
					}
				}
				else
				{
					changeTargetTimer -= Time.deltaTime;
				}
				if (gameCharacter.rigidBodies.fall.gotUp)
				{
					turnToPlayer();
				}
				if (fightAI_keepAwayTime > 0f && fightAI_keepAway == "")
				{
					changeTargetTimer = 0f;
				}
				if (doingMove == -1)
				{
					heightAdjustTimer -= Time.deltaTime;
					nextStanceTime = Mathf.MoveTowards(nextStanceTime, 0f, Time.deltaTime);
				}
				if (heightAdjustTimer < 0f)
				{
					if (gameCharacter.targetEnemy.isPlayer())
					{
						float t = ((gameCharacter.targetEnemy.rigidBodies.head.position - gameCharacter.rigidBodies.head.position).magnitude - 1f) / 3f;
						if (gameCharacter.data.willgoLow == 0f)
						{
							if (gameCharacter.targetEnemy.trackers.transforms[0].localPosition.y < 1.2f && fightAI_chargeIn <= 0)
							{
								fightAI_keepAway = "Too low";
							}
							targetHeightAdjust = 1f;
						}
						else
						{
							targetHeightAdjust = Mathf.Lerp(1f, enemyHeadY / 1.597336f, gameCharacter.data.willgoLow * 0.75f);
							targetHeightAdjust = Mathf.Lerp(targetHeightAdjust, 1f, t);
						}
					}
					else
					{
						enemyHeadY = (gameCharacter.targetEnemy.trackers.transforms[0].position - gameCharacter.targetEnemy.standPosition).y + 0.1f;
						targetHeightAdjust = 1f;
					}
					heightAdjustTimer += (UnityEngine.Random.value + 0.5f) * targetHeightAdjust;
					targetHeightAdjust -= UnityEngine.Random.value * (0.15f * targetHeightAdjust);
				}
				if (gameCharacter.rigidBodies.slide.magnitude < 1f || tauntTime > 0f)
				{
					vector3.y = 0f;
					Vector3 targetPos = (fightAI_targetPlayer ? (playerTarget + stanceOffset) : walkTarget);
					targetPos = GameController.instance.standButtons.clampPos(targetPos);
					moveToDebug.transform.position = targetPos;
					if (doingMove == -1)
					{
						counters();
						if (gameCharacter.targetEnemy.rigidBodies.isDown(allTheWay: true))
						{
							targetHeightAdjust = 1f;
							if (tauntTime > 0f)
							{
								tauntTime -= Time.deltaTime;
							}
							if (tauntTime < 1f)
							{
								playerLookTarget = gameCharacter.targetEnemy.rigidBodies.head.position;
								playerTarget = new Vector3(gameCharacter.targetEnemy.standPosition.x, 0f, gameCharacter.targetEnemy.standPosition.z);
								playerTarget += vector3.normalized * Settings.instance.restartDistance.min;
								replayer.doAction(fightingStyle().idle, loop: true, offsetHeight: false, 1f, "end of taunt");
								resetTime = 1f;
								float magnitude2 = diffToTarget().magnitude;
								if (magnitude2 < Settings.instance.restartDistance.min || magnitude2 > Settings.instance.restartDistance.max)
								{
									walkTowards(playerTarget);
								}
								sizeUp(1f);
							}
							fightAI_keepAwayTime = 2f + UnityEngine.Random.value;
							resetThink();
						}
						else if (fightAI_sizeupTime > 0f && fightAI_keepAway == "")
						{
							walkTowards(walkTarget, fightAI_sizeupSpeedPerc);
							fightAI_sizeupTime -= Time.deltaTime;
						}
						else
						{
							float speedPerc = 1f;
							if (GameController.instance.standButtons.inFightArea(gameCharacter.standPosition))
							{
								speedPerc = Mathf.Clamp01((diffToTarget().magnitude - 2f) / 4f);
								speedPerc = Mathf.Lerp(GameController.instance.difficultyLevel.aiWalkSpeed.lerp(gameCharacter.difficulty), 1f, speedPerc);
							}
							walkTowards(targetPos, speedPerc);
						}
						targetHeightAdjust = Mathf.Clamp01(targetHeightAdjust);
						heightAdjust = Mathf.Lerp(heightAdjust, targetHeightAdjust, Time.deltaTime * 6f);
					}
					else
					{
						RecordAction recordAction = currentAttack();
						float num3 = Mathf.Max(recordAction.attackRange * Mathf.Min(1f, rangeBias) * 0.75f, GameController.instance.difficultyLevel.minDistance.lerp(gameCharacter.difficulty));
						float range = recordAction.getRange(2.5f, replayer.playbackElapsed);
						if (vector3.magnitude > range && !replayer.isTransitioning() && fightAI_considerAbandonMove)
						{
							if (verbose)
							{
								UnityEngine.Debug.LogError("Abandon move");
							}
							doingMove = -1;
							switchStance(0.5f, "Abandon");
						}
						else if (vector3.magnitude > num3)
						{
							walkTowards(playerTarget, 1f, clamp: false);
						}
						else if (vector3.magnitude < num3 * 0.5f)
						{
							walkTowards(playerTarget + vector3.normalized * num3);
						}
						else
						{
							walkTowards(playerTarget, walkSpeedMod, clamp: false);
						}
					}
				}
				fightAI_keepAwayTime = Mathf.MoveTowards(fightAI_keepAwayTime, 0f, Time.deltaTime);
				bool flag2 = false;
				if (doingMove == -1 && !gameCharacter.targetEnemy.rigidBodies.isDown(allTheWay: true) && fightAI_keepAwayTime == 0f && Mathf.Abs(heightAdjust - targetHeightAdjust) < 0.1f && GameController.instance.movingAllowed)
				{
					tryAttackTime -= Time.deltaTime;
					if (tryAttackTime < 0f)
					{
						if (verbose)
						{
							UnityEngine.Debug.LogError("Do move " + gameCharacter.name);
						}
						resetThink();
						Vector3 vector9 = diffToTarget();
						List<int> list = new List<int>();
						float num4 = GameController.instance.difficultyLevel.aiMoveChoiceVariance.lerp(gameCharacter.difficulty);
						Vector3 vector10 = gameCharacter.mover.velocity - gameCharacter.targetEnemy.mover.velocity;
						float num5 = 0.5f + UnityEngine.Random.value;
						if (UnityEngine.Random.value < 0.5f)
						{
							num5 = vector10.magnitude * (UnityEngine.Random.value / 2f + 0.5f);
							if (fightAI_keepAway != "")
							{
								num5 /= 2f;
							}
						}
						if (gameCharacter.rigidBodies.specialPerc >= 1f)
						{
							for (int j = 0; j < specialMove().ai_attacks.Count; j++)
							{
								switch (gameCharacter.specialMove.aiDoWhen)
								{
								case SpecialMoveData.AIDoWhen.WithinMovingRange:
									if (UnityEngine.Random.value < 0.5f && vector9.magnitude < specialMove().ai_attacks[j].getRange(1.5f) * (1f + UnityEngine.Random.Range(0f - num4, num4)))
									{
										list.Add(j);
									}
									break;
								case SpecialMoveData.AIDoWhen.WithinStillRange:
									if (vector9.magnitude < specialMove().ai_attacks[j].getRange(0.1f))
									{
										list.Add(j);
									}
									break;
								case SpecialMoveData.AIDoWhen.GreaterThanCustom:
									if (UnityEngine.Random.value < 0.1f && vector9.magnitude > gameCharacter.specialMove.customRange)
									{
										list.Add(j);
									}
									break;
								case SpecialMoveData.AIDoWhen.LessThanCustom:
									if (UnityEngine.Random.value < 0.5f && vector9.magnitude < gameCharacter.specialMove.customRange)
									{
										list.Add(j);
									}
									break;
								case SpecialMoveData.AIDoWhen.AroundCustom:
									if (UnityEngine.Random.value < 0.5f && Mathf.Abs(vector9.magnitude - gameCharacter.specialMove.customRange) < 1f)
									{
										list.Add(j);
									}
									break;
								default:
									if (UnityEngine.Random.value < 0.1f)
									{
										list.Add(j);
									}
									break;
								}
							}
						}
						if (specialMoveMove > -1)
						{
							RecordAction recordAction2 = specialMove().ai_attacks[specialMoveMove];
							if (!replayer.doAction(recordAction2, loop: false, offsetHeight: true, specialMoveSpeed(), "Do Special Pose"))
							{
								replayer.doAction(recordAction2, loop: false, offsetHeight: true, 0.1f, "Special Attack");
								doingSpecial = false;
								resetTime = recordAction2.totalTime - 0.1f;
								tryAttackTime = recordAction2.totalTime;
								specialMoveMove = -1;
							}
						}
						else if (list.Count > 0)
						{
							int index = UnityEngine.Random.Range(0, list.Count);
							doingMove = list[index];
							doingSpecial = true;
							headLookPerc = 0f;
							RecordAction pose = specialMove().pose;
							float time = specialMoveSpeed();
							if (!replayer.doAction(pose, loop: false, offsetHeight: true, time, "Do Special Pose"))
							{
								doingMove = -1;
								doingSpecial = false;
							}
							else
							{
								fightAI_considerAbandonMove = false;
								Invoke("specialNext", time);
							}
						}
						else
						{
							float num6 = Mathf.Clamp01(1f - (angleDiff - 5f) / 45f);
							if (gameCharacter.hasEffect(CharacterEffect.Effect.QuickWalk))
							{
								num5 *= 2f;
							}
							if (gameCharacter.hasEffect(CharacterEffect.Effect.TigerClaws))
							{
								num5 *= 1.4f;
							}
							num5 *= num6;
							bool flag3 = OptionData.getBool("Kicks") && UnityEngine.Random.value < Settings.instance.baseKickFreqency * gameCharacter.data.kickFrequency * gameCharacter.kickController.kickStamina;
							if (!flag3 && gameCharacter.kickingMove())
							{
								flag3 = true;
							}
							if (minAttackHeight >= 999f)
							{
								for (int k = 0; k < currentStance().attacks.Count; k++)
								{
									float attackHeight = currentStance().attacks[k].attackHeight;
									if (attackHeight < minAttackHeight)
									{
										minAttackHeight = attackHeight;
									}
								}
							}
							if (!flag3 && enemyHeadY > 0f && enemyHeadY < minAttackHeight * heightAdjust && gameCharacter.kickController.kickStamina > 0.9f)
							{
								flag3 = true;
							}
							if (!gameCharacter.kickController.kicking && flag3)
							{
								if (vector9.magnitude > 0.5f * num5 && vector9.magnitude < 1.2f * num5)
								{
									gameCharacter.kickController.Kick();
									resetTime = 1f;
									flag3 = true;
									tryAttackTime = 1f;
								}
							}
							else
							{
								flag3 = false;
							}
							if (!flag3)
							{
								for (int l = 0; l < currentStance().attacks.Count; l++)
								{
									RecordAction recordAction3 = currentStance().attacks[l];
									bool flag4 = false;
									if (vector9.magnitude < recordAction3.getRange(num5) && !(enemyHeadY < recordAction3.attackHeight * heightAdjust - 0.1f))
									{
										flag4 = true;
									}
									if (flag4 && (!(Time.time < sameMoveTimer) || l != lastMove || currentStance().attacks.Count <= 1))
									{
										list.Add(l);
									}
								}
								if (list.Count > 0)
								{
									int index2 = UnityEngine.Random.Range(0, list.Count);
									doingMove = list[index2];
									doingSpecial = false;
									headLookPerc = 0f;
									if (verbose)
									{
										UnityEngine.Debug.LogError("..." + doingMove);
									}
									RecordAction recordAction4 = currentStance().attacks[doingMove];
									walkSpeedMod = 1f;
									walkSpeedChange = recordAction4.totalTime;
									if (replayer.doAction(recordAction4, loop: false, offsetHeight: true, 0.1f, "Do attack"))
									{
										lastMove = doingMove;
										sameMoveTimer = Time.time + (float)UnityEngine.Random.Range(3, 8);
									}
									else
									{
										doingMove = -1;
									}
									float num7 = (recordAction4.totalTime - 2f) / 5f;
									fightAI_considerAbandonMove = UnityEngine.Random.value < num7;
									resetTime = recordAction4.totalTime - 1f;
									if (debug)
									{
										FaceCanvasController.addText("Do move: " + doingMove + " (" + recordAction4.name + ")");
									}
									flag2 = true;
								}
								else
								{
									if (verbose)
									{
										UnityEngine.Debug.LogError("...None");
									}
									doingMove = -1;
								}
							}
						}
					}
				}
				if (!flag2)
				{
					resetTime -= Time.deltaTime * gameCharacter.rigidBodies.aiSpeed * moveSpeedMod();
					if (resetTime <= 0f)
					{
						switchStance(0.4f, "End of move");
						headLookPerc = (((double)UnityEngine.Random.value < 0.5) ? 0.5f : 0f);
						resetTime = 2f;
					}
				}
				else
				{
					attacksDone++;
				}
			}
			if (headTurnTimer > 0f)
			{
				headTurnTimer -= Time.deltaTime;
				headLookPerc = 1f;
			}
			float num8 = gameCharacter.rigidBodies.aiSpeed * moveSpeedMod();
			if (tauntTime > 0f)
			{
				num8 *= tauntSpeed;
			}
			MoveRecorder.instance.playback(replayer, num8, gameCharacter.rigidBodies.heightStandOffset, heightAdjust + landOffset, gameCharacter.headRecoil, gameCharacter.hands, (headTurnTimer > 0f || gameCharacter.rigidBodies.slide.magnitude < 0.1f) ? headLookPerc : 0f);
			break;
		}
		case "Playback":
			MoveRecorder.instance.playback(replayer, 1f, gameCharacter.rigidBodies.heightStandOffset, 1f, gameCharacter.headRecoil, gameCharacter.hands, 0f);
			break;
		case "Mirror":
		{
			if (gameCharacter.targetEnemy == null || gameCharacter.targetEnemy.playerController == null)
			{
				break;
			}
			followTrackers = GameController.instance.player.playerController.scaledTrackers;
			for (int m = 0; m < 3; m++)
			{
				aiTrackers[m].transform.localPosition = followTrackers[m].localPosition;
				if (m == 0 && headLookPerc >= 0.5f)
				{
					aiTrackers[m].transform.rotation = Quaternion.LookRotation(followTrackers[m].position - aiTrackers[m].position, aiTrackers[m].rotation * Vector3.up);
				}
				else
				{
					aiTrackers[m].transform.localRotation = followTrackers[m].localRotation;
				}
				if (gameCharacter.rigidBodies.hands != null && gameCharacter.targetEnemy.rigidBodies.hands != null)
				{
					gameCharacter.rigidBodies.hands.l_squeezeAmount = gameCharacter.targetEnemy.rigidBodies.hands.l_squeezeAmount;
					gameCharacter.rigidBodies.hands.r_squeezeAmount = gameCharacter.targetEnemy.rigidBodies.hands.r_squeezeAmount;
					gameCharacter.rigidBodies.hands.l_squeezeAmount_secondary = gameCharacter.targetEnemy.rigidBodies.hands.l_squeezeAmount_secondary;
					gameCharacter.rigidBodies.hands.r_squeezeAmount_secondary = gameCharacter.targetEnemy.rigidBodies.hands.r_squeezeAmount_secondary;
				}
			}
			break;
		}
		case "Idle":
			replayer.doAction(fightingStyle().idle, loop: true, offsetHeight: false, 1f, "Idle mode");
			MoveRecorder.instance.playback(replayer, gameCharacter.rigidBodies.aiSpeed * moveSpeedMod(), gameCharacter.rigidBodies.heightStandOffset, heightAdjust + landOffset, gameCharacter.headRecoil, gameCharacter.hands, headLookPerc);
			break;
		case "Stance":
			if (Settings.instance.testCounters && doingMove == -1)
			{
				dodgeDist = 1.5f;
				dodgeMinSpeed = 3f;
				counters();
			}
			resetTime -= Time.deltaTime;
			if (resetTime <= 0f)
			{
				switchStance(0.4f, "Stance Mode Switch");
				walkTarget = gameCharacter.standPosition;
			}
			MoveRecorder.instance.playback(replayer, gameCharacter.rigidBodies.aiSpeed * moveSpeedMod(), gameCharacter.rigidBodies.heightStandOffset, heightAdjust + landOffset, gameCharacter.headRecoil, gameCharacter.hands, headLookPerc);
			break;
		default:
			gotoDefaultPositions();
			break;
		}
	}
}
[Serializable]
public class AIMode
{
	public string name;

	public bool fightMode;

	public bool editMode;
}
[Serializable]
public class AchievementData : Exportable
{
	public enum Category
	{
		Easy,
		Medium,
		Hard,
		Completion,
		Wacky,
		Total
	}

	public string id;

	public string description;

	public bool hasHardVersion;

	public Category category;

	public DifficultyLevel.Level done;

	public DifficultyLevel.Level confirmed;

	public Sprite icon;

	[TextArea(5, 5)]
	public string notes;

	public void localise()
	{
		LocalisationController.getText("Achievement Name", name, suppressError: true);
		LocalisationController.getText("Achievement Description", description, suppressError: true);
	}

	public string getName(string difficulty, bool localise = false)
	{
		if (localise)
		{
			if (!hasHardVersion)
			{
				return LocalisationController.getChinese(name);
			}
			return LocalisationController.getChinese(name) + " (" + LocalisationController.getChinese(difficulty) + ")";
		}
		if (!hasHardVersion)
		{
			return name;
		}
		return name + " (" + difficulty + ")";
	}

	public string getID(DifficultyLevel.Level diff)
	{
		if (!hasHardVersion)
		{
			return id;
		}
		return id + "_" + getDifficultySuffix(diff);
	}

	public string getDifficultySuffix(DifficultyLevel.Level diff)
	{
		return diff switch
		{
			DifficultyLevel.Level.Easy => "Esy", 
			DifficultyLevel.Level.Medium => "Md", 
			DifficultyLevel.Level.Hard => "Hrd", 
			DifficultyLevel.Level.Harder => "Hrder", 
			DifficultyLevel.Level.Master => "Mster", 
			_ => "", 
		};
	}

	public string getDescription(string difficulty, bool localise = false)
	{
		if (localise)
		{
			return LocalisationController.getChinese(description);
		}
		if (!hasHardVersion)
		{
			return description;
		}
		if (difficulty == "Master")
		{
			return description + " in " + difficulty + " difficulty";
		}
		return description + " in " + difficulty + " (or higher) difficulty";
	}

	public bool complete()
	{
		if (hasHardVersion)
		{
			if (GameController.instance.difficultyLevel.level == DifficultyLevel.Level.None || !GameController.instance.specialMode.hasDifficultyLevels)
			{
				return false;
			}
			if (GameController.instance.difficultyLevel.level > done)
			{
				done = GameController.instance.difficultyLevel.level;
				if (category != Category.Completion && done == DifficultyLevel.Level.Master)
				{
					done = DifficultyLevel.Level.Harder;
				}
				return true;
			}
		}
		else if (done == DifficultyLevel.Level.None)
		{
			done = DifficultyLevel.Level.Easy;
			return true;
		}
		return false;
	}
}
public class AchievementsController : MonoBehaviour
{
	public static AchievementsController instance;

	public AchievementData[] achievements;

	public List<GameStat> statsToCheck = new List<GameStat>();

	public float checkTimer;

	public Sprite[] difficultyOverlays;

	public Sprite placeHolder;

	[Header("Checks for achievements")]
	public bool hasHitHead;

	public bool hasHitOther;

	public bool hasUsedLeftArm;

	public bool hasUsedRightArm;

	public bool perfect;

	public List<AchievementData> queue;

	private float queueTimer;

	public bool notify = true;

	private void Start()
	{
		instance = this;
		AchievementCore.RegisterNetwork();
		List<string> list = new List<string>();
		AchievementData[] array = achievements;
		foreach (AchievementData achievementData in array)
		{
			string text = "";
			string[] array2 = achievementData.name.Split(' ');
			foreach (string text2 in array2)
			{
				text += text2[0];
			}
			achievementData.id = text;
			list.Add(text);
			int num = countID(text, list);
			if (num > 1)
			{
				achievementData.id += num;
			}
		}
	}

	private void OnDestroy()
	{
		AchievementCore.UnRegisterNetwork();
	}

	private void OnApplicationPause(bool pause)
	{
		if (!pause)
		{
			achievementInit();
		}
	}

	private void achievementInit()
	{
		Achievements.Init().OnComplete(initAchievementCallback);
	}

	private void initAchievementCallback(Pvr_Message msg)
	{
		if (msg.IsError)
		{
			Error error = msg.GetError();
			UnityEngine.Debug.LogError("Achievement Init Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
		}
	}

	private int countID(string id, List<string> baseIDs)
	{
		int num = 0;
		foreach (string baseID in baseIDs)
		{
			if (id == baseID)
			{
				num++;
			}
		}
		return num;
	}

	public void export()
	{
		string text = "<table>";
		text += "<tr>";
		text += "<th>ID</th>";
		text += "<th>Name</th>";
		text += "<th>Description</th>";
		text += "<th>Category</th>";
		text += "</tr>";
		AchievementData[] array = achievements;
		foreach (AchievementData achievementData in array)
		{
			if (achievementData.hasHardVersion)
			{
				DifficultyLevel[] difficultyLevels = Settings.instance.difficultyLevels;
				foreach (DifficultyLevel difficultyLevel in difficultyLevels)
				{
					if (!difficultyLevel.isMaster() || achievementData.category == AchievementData.Category.Completion)
					{
						text += "<tr>";
						text = text + "<td>" + achievementData.getID(difficultyLevel.level) + "</td>";
						text = text + "<td>" + achievementData.getName(difficultyLevel.name) + "</td>";
						text = text + "<td>" + achievementData.getDescription(difficultyLevel.name) + "</td>";
						text = text + "<td>" + achievementData.getName(difficultyLevel.name, localise: true) + "</td>";
						text = text + "<td>" + achievementData.getDescription(difficultyLevel.name, localise: true) + "</td>";
						text = text + "<td>" + achievementData.category.ToString() + "</td>";
						text += "</tr>";
					}
				}
			}
			else
			{
				text += "<tr>";
				text = text + "<td>" + achievementData.getID(DifficultyLevel.Level.Easy) + "</td>";
				text = text + "<td>" + achievementData.name + "</th>";
				text = text + "<td>" + achievementData.description + "</th>";
				text = text + "<td>" + achievementData.getName("", localise: true) + "</td>";
				text = text + "<td>" + achievementData.getDescription("", localise: true) + "</td>";
				text = text + "<td>" + achievementData.category.ToString() + "</th>";
				text += "</tr>";
			}
			text += "\n";
		}
		text += "</table>";
		GameData.instance.exportWebPage("achievements", text, "htm", andOpen: true);
	}

	public void fightReset()
	{
		hasHitHead = false;
		hasHitOther = false;
		hasUsedLeftArm = false;
		hasUsedRightArm = false;
	}

	public void onWinChecks()
	{
		achievement("Victory");
		if (GameController.instance.levelCharacters[GameController.instance.selectedPos].hasStars >= 3)
		{
			achievement("Dominance");
		}
		if (!hasHitHead)
		{
			achievement("Body Blows");
		}
		if (!hasHitOther)
		{
			achievement("Head Banger");
		}
		if (!hasUsedLeftArm || !hasUsedRightArm)
		{
			achievement("One Armed Boxer");
		}
		foreach (GameCharacter player in GameController.instance.players)
		{
			if (player.team != 0)
			{
				switch (player.rigidBodies.lastHit)
				{
				case RigidBodies.LastHit.FlyingKick:
					achievement("Flying Kick Down");
					break;
				case RigidBodies.LastHit.FlyingPunch:
					achievement("Flying Beat Down");
					break;
				case RigidBodies.LastHit.Crockery:
					achievement("Crockery");
					break;
				case RigidBodies.LastHit.SpecialMove:
					achievement("Special Technique");
					break;
				case RigidBodies.LastHit.Projectile:
					achievement("Flying Blades");
					break;
				}
			}
		}
		bool flag = true;
		CharacterData[] characterOrder = GameData.instance.characterOrder;
		for (int i = 0; i < characterOrder.Length; i++)
		{
			if (characterOrder[i].hasStars < 3)
			{
				flag = false;
			}
		}
		if (flag)
		{
			achievement("Full Marks");
		}
	}

	public void onCompleteChecks()
	{
		if (GameController.instance.specialMode.name == "Stamina")
		{
			achievement("Staying Power");
		}
		else if (GameController.instance.specialMode.name == "Dragon Doubles")
		{
			achievement("Seeing Double");
		}
		else
		{
			achievement("Kiss of the Dragon");
		}
	}

	public void checkStat(GameStat stat)
	{
		if (!statsToCheck.Contains(stat))
		{
			statsToCheck.Add(stat);
			checkTimer = 0.5f;
		}
	}

	public void addToQueue(AchievementData achievement)
	{
		queueTimer = 0.1f;
		queue.Add(achievement);
	}

	public static void achievement(string name)
	{
		AchievementData[] array = instance.achievements;
		foreach (AchievementData achievementData in array)
		{
			if (achievementData.name.ToLower() == name.ToLower())
			{
				if (achievementData.complete())
				{
					instance.addToQueue(achievementData);
				}
				break;
			}
		}
	}

	private void unlockAchievement(string achievementName)
	{
		Achievements.Unlock(achievementName).OnComplete(achievementUnlockCallback);
	}

	private void achievementUnlockCallback(Pvr_Message msg)
	{
		if (msg.IsError)
		{
			Error error = msg.GetError();
			UnityEngine.Debug.LogError("Achievment Unlock Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
		}
	}

	private void Update()
	{
		Request.RunCallbacks();
		if (queue.Count > 0)
		{
			if (queueTimer > 0f)
			{
				queueTimer -= Time.deltaTime;
			}
			else
			{
				queueTimer = 2f;
				AchievementData achievementData = queue[0];
				string text = LocalisationController.getText("General", "Achievement:") + " " + LocalisationController.getText("Achievement", achievementData.name);
				if (achievementData.hasHardVersion)
				{
					if (achievementData.confirmed < achievementData.done)
					{
						achievementData.confirmed++;
						text = text + " (" + achievementData.confirmed.ToString() + ")";
					}
				}
				else
				{
					achievementData.confirmed++;
				}
				string iD = achievementData.getID(achievementData.confirmed);
				unlockAchievement(iD);
				if (achievementData.confirmed == achievementData.done)
				{
					queue.RemoveAt(0);
				}
				if (notify)
				{
					GeneralSounds.playSound(8);
					CanvasController.addText(localise: false, iD, Camera.main.transform.position + Camera.main.transform.forward * 2f, Color.cyan, 4f);
				}
			}
		}
		if (!(checkTimer > 0f))
		{
			return;
		}
		checkTimer -= Time.deltaTime;
		if (!(checkTimer <= 0f) || statsToCheck.Count <= 0)
		{
			return;
		}
		GameStat gameStat = statsToCheck[0];
		checkTimer = 0.1f;
		string text2 = gameStat.name;
		if (text2 != null && text2 == "Head Kicks Landed")
		{
			if (gameStat.value >= 25f)
			{
				achievement("Head Hunter");
			}
		}
		else
		{
			checkTimer = 0f;
		}
		statsToCheck.RemoveAt(0);
	}
}
public class AltCostume : MonoBehaviour
{
	public Material[] materials;

	private Material[] originalMaterials;

	public RigidBodies rb;

	public bool hide;

	private void Start()
	{
		refresh();
	}

	public void refresh()
	{
		if (rb == null)
		{
			rb = GetComponentInParent<RigidBodies>();
		}
		SkinnedMeshRenderer component = GetComponent<SkinnedMeshRenderer>();
		if (component != null)
		{
			if (materials.Length != 0)
			{
				if (originalMaterials == null)
				{
					originalMaterials = component.materials;
				}
				component.materials = ((rb.altCostume() == 1) ? materials : originalMaterials);
			}
		}
		else
		{
			MeshRenderer component2 = GetComponent<MeshRenderer>();
			if (component2 != null)
			{
				if (materials.Length != 0)
				{
					if (originalMaterials == null)
					{
						originalMaterials = component2.materials;
					}
					component2.materials = materials;
					component2.materials = ((rb.altCostume() == 1) ? materials : originalMaterials);
				}
				component2.enabled = !hide || rb.altCostume() != 1;
			}
		}
		if (hide && rb.altCostume() == 1)
		{
			base.gameObject.SetActive(value: false);
		}
	}

	private void Update()
	{
	}
}
public class AmbientSoundController : MonoBehaviour
{
	private static AmbientSoundController instance;

	public float fadeTime = 3f;

	private AudioSource audioSource;

	public float fadeTarget = 1f;

	private void Start()
	{
		instance = this;
		audioSource = GetComponent<AudioSource>();
		audioSource.volume = 0f;
	}

	public static void fade(bool fadeOut, float fadeTime)
	{
		instance.fadeTime = fadeTime;
		instance.fadeTarget = ((!fadeOut) ? 1 : 0);
	}

	public static void fadeIn(float fadeTime, AudioClip clip)
	{
		if (!(instance == null))
		{
			instance.audioSource.clip = clip;
			instance.audioSource.Play();
			instance.audioSource.volume = 0f;
			instance.fadeTime = fadeTime;
			instance.fadeTarget = 1f;
		}
	}

	private void Update()
	{
		if (!Fader.paused)
		{
			audioSource.volume = Mathf.MoveTowards(audioSource.volume, fadeTarget, Time.deltaTime / fadeTime);
			GameController.instance.mixer.SetFloat("Volume", audioSource.volume);
			audioSource.pitch = Time.timeScale;
		}
	}
}
public class AreaOfEffect : MonoBehaviour
{
	public MinMax radius;

	public CharacterEffect.Effect effect;

	public float maxAmount = 5f;

	private void Start()
	{
		foreach (GameCharacter player in GameController.instance.players)
		{
			float magnitude = (player.rigidBodies.head.position - base.transform.position).magnitude;
			float num = 1f - Mathf.Clamp01((magnitude - radius.min) / (radius.max - radius.min));
			if (num > 0f)
			{
				player.addEffect(base.transform.position, effect, num * maxAmount, preventSpecialRecharge: false, isTest: false);
			}
		}
	}

	private void Update()
	{
	}
}
public class Billboard : MonoBehaviour
{
	public Vector3 offset;

	private void Start()
	{
	}

	private void Update()
	{
		if (!(Camera.main == null))
		{
			base.transform.rotation = Quaternion.LookRotation(Camera.main.transform.position - base.transform.position) * Quaternion.Euler(offset);
		}
	}
}
public class BillboardMaker : MonoBehaviour
{
	public Vector2Int size;

	public Camera cam;

	public AudioSource audioSource;

	public string fileName = "crowdMan";

	public string direction = "";

	private void Start()
	{
		cam = GetComponent<Camera>();
		audioSource = GetComponent<AudioSource>();
		Invoke("takePic", 1f);
	}

	private void takePic()
	{
		RenderTexture active = RenderTexture.active;
		RenderTexture renderTexture = new RenderTexture(size.x, size.y, 24, RenderTextureFormat.ARGB32);
		cam.targetTexture = renderTexture;
		cam.Render();
		DumpRenderTexture(renderTexture, Application.dataPath + "/Resources/crowd/" + direction + "/" + fileName + ".png");
		cam.targetTexture = active;
		audioSource.Play();
	}

	public void DumpRenderTexture(RenderTexture rt, string pngOutPath)
	{
		RenderTexture active = RenderTexture.active;
		Texture2D texture2D = new Texture2D(rt.width, rt.height);
		RenderTexture.active = rt;
		texture2D.ReadPixels(new Rect(0f, 0f, rt.width, rt.height), 0, 0);
		texture2D.Apply();
		File.WriteAllBytes(pngOutPath, texture2D.EncodeToPNG());
		RenderTexture.active = active;
	}
}
public class BlockSwingController : MonoBehaviour
{
	public Rigidbody toRelease;

	public float radius = 0.5f;

	public float onProb = 0.3f;

	public bool on;

	public AudioSource audioSource;

	private bool pressed;

	private void Start()
	{
		on = UnityEngine.Random.value < onProb;
	}

	private void Update()
	{
		if (GameController.instance == null || !on || GameController.instance.player == null || !toRelease.isKinematic)
		{
			return;
		}
		Vector3 vector = GameController.instance.player.standPosition - base.transform.position;
		vector.y = 0f;
		if (vector.magnitude < radius)
		{
			toRelease.isKinematic = false;
			if (!pressed)
			{
				pressed = true;
				audioSource.Play();
			}
		}
		else
		{
			pressed = false;
		}
	}
}
[Serializable]
public class BodyPartData
{
	public enum Source
	{
		Any,
		LeftHand,
		RightHand
	}

	public string name;

	public string friendlyName;

	public float weaponForce;

	public Rigidbody rb;

	public Hittable.HitType hitType;

	public float hapticAmount;

	public float knockDownPerc;

	public Hittable hittable;

	public Source source;

	public bool isHandOrLowerArm;

	public bool isHead;

	public bool isChest;

	public bool isRightHand;

	public bool isLeftHand;

	public bool isFoot;

	public bool isArm;

	public void setDefaults()
	{
		isHandOrLowerArm = false;
		if (name.Contains("_l"))
		{
			source = Source.LeftHand;
		}
		if (name.Contains("_r"))
		{
			source = Source.RightHand;
		}
		if (name.Contains(".L"))
		{
			source = Source.LeftHand;
		}
		if (name.Contains(".R"))
		{
			source = Source.RightHand;
		}
		if (name.Contains("hand"))
		{
			hitType = Hittable.HitType.Arm;
			weaponForce = 1f;
			hapticAmount = 1f;
			friendlyName = "Hand";
			isRightHand = source == Source.RightHand;
			isLeftHand = source == Source.LeftHand;
			isHandOrLowerArm = true;
		}
		else if (name.Contains("lowerarm") || name.Contains("forearm"))
		{
			hitType = Hittable.HitType.Arm;
			weaponForce = 0.35f;
			hapticAmount = 0.5f;
			friendlyName = "Forearm";
			isHandOrLowerArm = true;
			isArm = true;
		}
		else if (name.Contains("upperarm") || name.Contains("upper_arm"))
		{
			knockDownPerc = 0f;
			hitType = Hittable.HitType.Arm;
			isArm = true;
			friendlyName = "Upper Arm";
		}
		else if (name.Contains("head"))
		{
			hitType = Hittable.HitType.Head;
			weaponForce = 0f;
			knockDownPerc = 0.8f;
			isHead = true;
			friendlyName = "Head";
		}
		else if (name.Contains("thigh"))
		{
			hitType = Hittable.HitType.Leg;
			weaponForce = 0f;
			knockDownPerc = 0.5f;
			friendlyName = "Thigh";
		}
		else if (name.Contains("shin"))
		{
			hitType = Hittable.HitType.Leg;
			weaponForce = 0f;
			knockDownPerc = 0f;
			friendlyName = "Shin";
		}
		else if (name.Contains("foot"))
		{
			isFoot = true;
			knockDownPerc = 0f;
			weaponForce = 0.5f;
			hitType = Hittable.HitType.Leg;
			friendlyName = "Foot";
		}
		else
		{
			isChest = name.Contains("chest") || name.Contains("spine");
			knockDownPerc = 1f;
			hitType = Hittable.HitType.Body;
			friendlyName = "Torso";
		}
		rb.interpolation = RigidbodyInterpolation.Interpolate;
		rb.collisionDetectionMode = CollisionDetectionMode.ContinuousDynamic;
	}
}
public class Breakable : MonoBehaviour
{
	public enum BreakLimitation
	{
		Any,
		HandOnly,
		SpecialMove,
		FootOnly,
		HandOrfoot,
		NewGameOnly
	}

	public delegate void OnNext();

	public float smashForce = 5f;

	public float minHitPower = 5f;

	public bool hurtsPlayer;

	public BreakLimitation breakLimitation;

	public GameObject background;

	public Rigidbody leftPrefab;

	public Rigidbody rightPrefab;

	public GameObject singlePrefab;

	public AudioClip breakSound;

	public AudioClip hitSound;

	private ParticleSystem[] particles;

	private AudioSource audioSource;

	private float createTime;

	public bool disabled;

	public bool unbreakable;

	public bool broken;

	public bool hasFailed;

	private GameObject[] fragments;

	public OnNext onNext;

	public OnNext onHurt;

	public OnNext onSmash;

	public bool addSideWaysForce;

	private Rigidbody rb;

	private float minHealth;

	private bool hitBody;

	public bool kinematicForSec;

	public bool impactDisabled;

	public float hitTime;

	public MeshRenderer mesh;

	private void Start()
	{
		particles = GetComponentsInChildren<ParticleSystem>();
		audioSource = GetComponent<AudioSource>();
		createTime = Time.time;
		minHealth = minHitPower / 2f;
		rb = GetComponent<Rigidbody>();
		if (rb == null)
		{
			rb = GetComponentInParent<Rigidbody>();
		}
		if ((bool)rb && kinematicForSec)
		{
			rb.isKinematic = true;
		}
		broken = false;
	}

	private void clearFragments()
	{
		if (fragments == null)
		{
			return;
		}
		GameObject[] array = fragments;
		foreach (GameObject gameObject in array)
		{
			if (gameObject != null)
			{
				UnityEngine.Object.Destroy(gameObject.gameObject);
			}
		}
	}

	public void reset()
	{
		disabled = false;
		background.SetActive(value: true);
		broken = false;
	}

	private void OnDestroy()
	{
		clearFragments();
	}

	private void Update()
	{
		if (kinematicForSec && (bool)rb && rb.isKinematic)
		{
			rb.isKinematic = Time.time < createTime + 1f;
		}
	}

	private void OnCollisionEnter(Collision collision)
	{
		if (GameController.instance == null || (kinematicForSec && rb.isKinematic) || impactDisabled)
		{
			return;
		}
		Hittable component = collision.collider.GetComponent<Hittable>();
		if (component != null)
		{
			if (hitTime > Time.time)
			{
				return;
			}
			hitTime = Time.time + 0.25f;
		}
		float num = Mathf.Clamp01(collision.relativeVelocity.magnitude / 10f);
		bool flag = component != null && component.specialMove != null && !component.specialMove.finished;
		if (!flag && component != null && component.rb != null && component.rb.character != null && component.rb.character.specialMove.addEffectToSelf && component.rb.character.hasEffect(component.rb.character.specialMove.addEffect))
		{
			flag = true;
		}
		if (flag)
		{
			component.handHitType(collision);
		}
		string error = "";
		bool flag2 = true;
		if (component == null)
		{
			flag2 = breakLimitation == BreakLimitation.Any;
		}
		else
		{
			if (component.bodyPart != null && component.bodyPart.isFoot)
			{
				flag = component.rb.character.kickController.wasSpecial;
			}
			switch (breakLimitation)
			{
			case BreakLimitation.HandOnly:
				flag2 = component.bodyPart.isHandOrLowerArm;
				error = "Use Hand";
				break;
			case BreakLimitation.FootOnly:
				flag2 = component.bodyPart.isFoot;
				error = "Use Kick";
				break;
			case BreakLimitation.HandOrfoot:
				flag2 = component.bodyPart.isFoot || component.bodyPart.isHandOrLowerArm;
				break;
			case BreakLimitation.SpecialMove:
				error = "Use Special Move";
				flag2 = flag;
				break;
			default:
				flag2 = true;
				break;
			}
			component.rb.buzz(collision.relativeVelocity.magnitude, component.bodyPart.source);
		}
		if (!flag2)
		{
			Vector3 hitDir = -collision.contacts[0].normal;
			hitDir.y = 0f;
			if (component != null)
			{
				if (component.bodyPart.knockDownPerc > 0f && !hitBody && hurtsPlayer)
				{
					component.rb.Hit(hitDir, component, null, num * component.bodyPart.knockDownPerc, num * component.bodyPart.knockDownPerc, collision.contacts[0].point, Hittable.HandHitType.General, skipPressurePoints: true, "");
					component.hitSound(component.bodyPart.hitType, 1f, audioSource);
					onHurt?.Invoke();
				}
				hitBody = true;
			}
			hit(0f, flag, collision.relativeVelocity, collision.contacts[0].point, error, component != null && component.rb.character.isPlayer());
		}
		else
		{
			HitEffects.addHitEffect(success: true, num, collision.contacts[0].point, collision.contacts[0].normal, showPerc: false);
			hit(collision.relativeVelocity.magnitude, flag, collision.relativeVelocity, collision.contacts[0].point, "", component != null && component.rb.character.isPlayer());
		}
		if (flag && component != null && component.specialMove != null)
		{
			component.specialMove.onHit(success: true, null);
		}
	}

	protected void doNext()
	{
		if (onNext != null)
		{
			onNext();
		}
	}

	public void hit(float force, bool special, Vector3 dir, Vector3 hitPoint, string error, bool wasPlayer)
	{
		if (disabled || Time.time < createTime + 0.4f)
		{
			return;
		}
		bool flag;
		if (!wasPlayer)
		{
			flag = false;
		}
		else if (unbreakable)
		{
			flag = false;
			CanvasController.addText(localise: true, "Unbreakable", hitPoint, Color.red, 0.5f);
		}
		else if (breakLimitation == BreakLimitation.NewGameOnly)
		{
			CanvasController.addText(localise: true, "From New Game Only", hitPoint, Color.red, 2f);
			flag = false;
		}
		else if (breakLimitation == BreakLimitation.SpecialMove)
		{
			flag = special;
			if (!flag)
			{
				CanvasController.addText(localise: true, "Use Special Move", hitPoint, Color.red, 2f);
			}
		}
		else
		{
			flag = force > minHitPower;
			if (!flag)
			{
				Vector3 vector = Vector3.zero;
				if (GameController.instance.player != null)
				{
					vector = GameController.instance.player.standPosition - hitPoint;
					vector.y = 0f;
				}
				if (minHitPower < 100f)
				{
					Mathf.Round(force / minHitPower * 100f);
					if (error != "")
					{
						CanvasController.addText(localise: true, error, hitPoint, Color.red, 0.5f, base.transform);
					}
					else if (vector.magnitude > 0.65f)
					{
						if (force > 0f)
						{
							CanvasController.addText(localise: true, "Too Weak\nGet Closer", hitPoint, Color.red, 0.5f, base.transform);
						}
					}
					else if (force > 0f)
					{
						CanvasController.addText(localise: true, "Too Weak", hitPoint, Color.red, 0.5f, base.transform);
					}
				}
			}
		}
		if (flag)
		{
			if (onSmash != null)
			{
				onSmash();
			}
			broken = true;
			Invoke("doNext", 1f);
			disabled = true;
			if (!(singlePrefab == null) || !(leftPrefab == null) || !(rightPrefab == null))
			{
				if (singlePrefab != null)
				{
					GameObject gameObject = UnityEngine.Object.Instantiate(singlePrefab, base.transform.position, base.transform.rotation, base.transform.root);
					UnityEngine.Object.Destroy(gameObject, 5f);
					fragments = new GameObject[2];
					fragments[1] = gameObject;
				}
				else
				{
					Rigidbody rigidbody = UnityEngine.Object.Instantiate(leftPrefab, base.transform.position, base.transform.rotation, base.transform.root);
					Rigidbody rigidbody2 = UnityEngine.Object.Instantiate(rightPrefab, base.transform.position, base.transform.rotation, base.transform.root);
					Transform obj = rigidbody.transform;
					Vector3 localScale = (rigidbody2.transform.localScale = base.transform.lossyScale);
					obj.localScale = localScale;
					rigidbody.AddForce((base.transform.forward + base.transform.right).normalized * smashForce, ForceMode.Impulse);
					rigidbody2.AddForce((base.transform.forward - base.transform.right).normalized * smashForce, ForceMode.Impulse);
					UnityEngine.Object.Destroy(rigidbody.gameObject, 5f);
					UnityEngine.Object.Destroy(rigidbody2.gameObject, 5f);
					fragments = new GameObject[2];
					fragments[0] = rigidbody.gameObject;
					fragments[1] = rigidbody2.gameObject;
					if (mesh != null)
					{
						rigidbody.GetComponent<MeshRenderer>().material = mesh.material;
						rigidbody2.GetComponent<MeshRenderer>().material = mesh.material;
					}
				}
			}
			background.SetActive(value: false);
			ParticleSystem[] array = particles;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].Play();
			}
			audioSource.PlayOneShot(breakSound);
			return;
		}
		hasFailed = true;
		if (!(audioSource == null))
		{
			if (hitSound == null)
			{
				UnityEngine.Debug.LogError(base.name + " has null hitSound");
			}
			audioSource.PlayOneShot(hitSound);
			if (minHitPower > minHealth)
			{
				minHitPower -= 1f;
			}
		}
	}
}
public class BronzeDummiesController : MonoBehaviour
{
	public BronzeDummyHitArea[] dummies;

	public ChamberController chamber;

	private void Start()
	{
		dummies = GetComponentsInChildren<BronzeDummyHitArea>();
		chamber = GetComponentInParent<ChamberController>();
	}

	private void Update()
	{
		bool isComplete = true;
		BronzeDummyHitArea[] array = dummies;
		for (int i = 0; i < array.Length; i++)
		{
			if (!array[i].done)
			{
				isComplete = false;
			}
		}
		chamber.isComplete = isComplete;
	}
}
public class BronzeDummyHitArea : MonoBehaviour
{
	public delegate void OnHit(Vector3 position);

	public delegate void OnBlock();

	public AudioClip hitSound;

	public AudioClip hitLiteSound;

	public float minHitTime = 0.5f;

	public float minHitPower = 1f;

	private float hitTime;

	public float speed = 90f;

	public bool sidewaysHit;

	public bool done;

	private Quaternion offset;

	public OnHit onHit;

	public OnBlock onBlock;

	public bool disableKnockdown;

	public bool bouncePlayer;

	private Quaternion downRotation;

	private Collider lastHit;

	private void Start()
	{
		offset = base.transform.localRotation;
	}

	private void OnCollisionEnter(Collision collision)
	{
		if (hitTime > Time.time)
		{
			hitTime = Time.time + 0.1f;
			return;
		}
		Hittable component = collision.collider.GetComponent<Hittable>();
		if (component == null || component.bodyPart.weaponForce == 0f || hitTime > Time.time || done)
		{
			return;
		}
		float magnitude = collision.relativeVelocity.magnitude;
		if (!(component != null))
		{
			return;
		}
		hitTime = Time.time + minHitTime;
		if (collision.GetContact(0).thisCollider.name == "head" || collision.GetContact(0).thisCollider.name == "chest")
		{
			if (bouncePlayer)
			{
				component.rb.slide -= collision.contacts[0].normal * magnitude / 20f;
			}
			if (onHit == null)
			{
				if (magnitude < minHitPower)
				{
					component.audioSource.PlayOneShot(hitLiteSound);
					CanvasController.addText(localise: true, "Hit Too Weak", collision.GetContact(0).point, Color.red, 0.5f);
				}
				else if (!disableKnockdown)
				{
					done = true;
					if (sidewaysHit)
					{
						Vector3 vector = collision.GetContact(0).point - base.transform.position;
						vector.y = 0f;
						downRotation = Quaternion.Euler(0f, 0f, (vector.x > 0f) ? (-90) : 90);
					}
					else
					{
						downRotation = Quaternion.Euler(-90f, 0f, 0f);
					}
				}
			}
			else
			{
				onHit(collision.contacts[0].point);
			}
			component.audioSource.PlayOneShot(hitSound);
		}
		else
		{
			HitSurface component2 = collision.contacts[0].thisCollider.GetComponent<HitSurface>();
			if (component2 != null)
			{
				component2.PlaySound(component.audioSource);
			}
			else
			{
				component.audioSource.PlayOneShot(hitLiteSound);
				CanvasController.addText(localise: true, "Blocked", collision.GetContact(0).point, Color.red, 0.5f);
			}
			component.rb.buzz(collision.relativeVelocity.magnitude / 4f, component.bodyPart.source);
		}
		component.rb.buzz(collision.relativeVelocity.magnitude, component.bodyPart.source);
		HitEffects.addHitEffect(done, magnitude / 10f, collision.contacts[0].point, collision.contacts[0].normal, showPerc: false);
	}

	private void Update()
	{
		Quaternion quaternion = (done ? downRotation : Quaternion.identity);
		base.transform.localRotation = Quaternion.RotateTowards(base.transform.localRotation, offset * quaternion, Time.deltaTime * speed);
	}
}
public class BronzeDummyHitTypes : MonoBehaviour
{
	public AudioClip hitSound;

	public AudioClip hitLiteSound;

	public float minHitTime = 0.5f;

	public float minHitPower = 1f;

	private float hitTime;

	public DummyHitType[] headHits;

	public DummyHitType[] torsoHits;

	public ChamberController chamber;

	private void Start()
	{
		DummyHitType[] array = headHits;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].setup();
		}
		array = torsoHits;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].setup();
		}
	}

	private void OnCollisionEnter(Collision collision)
	{
		chamber = base.transform.parent.GetComponentInParent<ChamberController>();
		Hittable component = collision.collider.GetComponent<Hittable>();
		if (component == null || hitTime > Time.time)
		{
			return;
		}
		float num = Mathf.Clamp01(collision.relativeVelocity.magnitude);
		if (!(component != null))
		{
			return;
		}
		bool flag = false;
		string text = "Blocked";
		DummyHitType[] array;
		if (component.isHand)
		{
			if (num < minHitPower)
			{
				text = "Too Weak";
			}
			else
			{
				Hittable.HandHitType handHitType = component.handHitType(collision);
				string text2 = ((handHitType == Hittable.HandHitType.FingerJab) ? "Finger Jab" : handHitType.ToString());
				if (collision.GetContact(0).thisCollider.name == "head")
				{
					array = headHits;
					foreach (DummyHitType dummyHitType in array)
					{
						if (dummyHitType.handHitType == handHitType)
						{
							flag = dummyHitType.complete();
						}
					}
					text = "Head - " + text2;
				}
				else if (collision.GetContact(0).thisCollider.name == "chest")
				{
					array = torsoHits;
					foreach (DummyHitType dummyHitType2 in array)
					{
						if (dummyHitType2.handHitType == handHitType)
						{
							flag = dummyHitType2.complete();
						}
					}
					text = "Body - " + text2;
				}
				else if (num < minHitPower)
				{
					text = "";
				}
			}
		}
		hitTime = Time.time + minHitTime;
		chamber.isComplete = true;
		array = headHits;
		for (int i = 0; i < array.Length; i++)
		{
			if (!array[i].done)
			{
				chamber.isComplete = false;
			}
		}
		array = torsoHits;
		for (int i = 0; i < array.Length; i++)
		{
			if (!array[i].done)
			{
				chamber.isComplete = false;
			}
		}
		if (text != "")
		{
			CanvasController.addText(localise: true, text, collision.GetContact(0).point, flag ? Color.green : Color.red, flag ? 2f : 0.5f);
			if (!flag)
			{
				chamber.perfect = false;
			}
		}
		if (component.audioSource != null)
		{
			component.audioSource.PlayOneShot(flag ? hitSound : hitLiteSound);
		}
		component.rb.buzz(collision.relativeVelocity.magnitude, component.bodyPart.source);
		HitEffects.addHitEffect(flag, num / 10f, collision.contacts[0].point, collision.contacts[0].normal, showPerc: false);
	}
}
public class ButtonPositionDisplayController : MonoBehaviour
{
	public Pvr_KeyCode key;

	public bool billboard;

	private Vector3 initScale;

	private void Start()
	{
		initScale = base.transform.localScale;
	}

	public void updateScale(float perc)
	{
		base.transform.localScale = Vector3.Lerp(initScale, initScale + Vector3.one * 2f, perc);
	}

	private void Update()
	{
		if (billboard && Camera.main != null)
		{
			base.transform.rotation = Quaternion.LookRotation(Camera.main.transform.position - base.transform.position) * Quaternion.Euler(90f, 0f, 0f);
		}
	}
}
public class ButtonPositionsController : MonoBehaviour
{
	public ButtonPositionDisplayController[] buttons;

	public List<ButtonPositionDisplayController> showingButtons;

	public MeshRenderer meshRenderer;

	public Material menuMaterial;

	public Material tutorialMaterial;

	private bool inBody;

	private float displayScalePerc;

	private float showTime;

	private void Start()
	{
		buttons = GetComponentsInChildren<ButtonPositionDisplayController>();
		meshRenderer = base.transform.parent.GetComponent<MeshRenderer>();
		clear();
	}

	public Vector3 highlightedPosition()
	{
		if (showingButtons.Count == 0)
		{
			return Vector3.zero;
		}
		Vector3 zero = Vector3.zero;
		foreach (ButtonPositionDisplayController showingButton in showingButtons)
		{
			zero += showingButton.transform.position;
		}
		return zero / showingButtons.Count;
	}

	public void clear()
	{
		show(new Pvr_KeyCode[0]);
		refresh();
	}

	public void show(Pvr_KeyCode[] actions, float showTime = 0f)
	{
		this.showTime = showTime;
		showingButtons.Clear();
		ButtonPositionDisplayController[] array = buttons;
		foreach (ButtonPositionDisplayController buttonPositionDisplayController in array)
		{
			bool flag = Array.IndexOf(actions, buttonPositionDisplayController.key) > -1;
			buttonPositionDisplayController.gameObject.SetActive(flag);
			if (flag)
			{
				showingButtons.Add(buttonPositionDisplayController);
			}
		}
		refresh();
	}

	public void refresh()
	{
		if (!(VRMainRigController.instance == null) && !(GameController.instance == null) && !(GameController.instance.noPlayer == null))
		{
			if (showing())
			{
				base.transform.parent.gameObject.SetActive(value: true);
			}
			else
			{
				base.transform.parent.gameObject.SetActive(VRMainRigController.instance.following == GameController.instance.noPlayer.transform);
			}
			bool flag = VRMainRigController.instance.following != GameController.instance.noPlayer.transform;
			if (inBody != flag)
			{
				inBody = flag;
				meshRenderer.material = (inBody ? tutorialMaterial : menuMaterial);
			}
		}
	}

	public bool showing()
	{
		return showingButtons.Count > 0;
	}

	private void Update()
	{
		if (showingButtons.Count <= 0)
		{
			return;
		}
		displayScalePerc += Time.deltaTime;
		if (displayScalePerc > 1f)
		{
			displayScalePerc -= 1f;
		}
		foreach (ButtonPositionDisplayController showingButton in showingButtons)
		{
			showingButton.updateScale(displayScalePerc);
		}
		if (showTime > 0f)
		{
			showTime -= Time.deltaTime;
			if (showTime < 0f)
			{
				clear();
			}
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/3D/Anomaly")]
public class CameraFilterPack_3D_Anomaly : MonoBehaviour
{
	public Shader SCShader;

	public bool _Visualize;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 100f)]
	public float _FixDistance = 23f;

	[Range(-0.5f, 0.99f)]
	public float Anomaly_Near = 0.045f;

	[Range(0f, 1f)]
	public float Anomaly_Far = 0.11f;

	[Range(0f, 2f)]
	public float Intensity = 1f;

	[Range(0f, 1f)]
	public float AnomalyWithoutObject = 1f;

	[Range(0.1f, 1f)]
	public float Anomaly_Distortion = 0.25f;

	[Range(4f, 64f)]
	public float Anomaly_Distortion_Size = 12f;

	[Range(-4f, 8f)]
	public float Anomaly_Intensity = 2f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/3D_Anomaly");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value2", Intensity);
			material.SetFloat("Anomaly_Distortion", Anomaly_Distortion);
			material.SetFloat("Anomaly_Distortion_Size", Anomaly_Distortion_Size);
			material.SetFloat("Anomaly_Intensity", Anomaly_Intensity);
			material.SetFloat("_Visualize", _Visualize ? 1 : 0);
			material.SetFloat("_FixDistance", _FixDistance);
			material.SetFloat("Anomaly_Near", Anomaly_Near);
			material.SetFloat("Anomaly_Far", Anomaly_Far);
			material.SetFloat("Anomaly_With_Obj", AnomalyWithoutObject);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			GetComponent<Camera>().depthTextureMode = DepthTextureMode.Depth;
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/3D/Binary")]
public class CameraFilterPack_3D_Binary : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	public bool _Visualize;

	private Material SCMaterial;

	[Range(0f, 100f)]
	public float _FixDistance = 2f;

	[Range(-5f, 5f)]
	public float LightIntensity;

	[Range(0f, 8f)]
	public float MatrixSize = 2f;

	[Range(-4f, 4f)]
	public float MatrixSpeed = 1f;

	[Range(0f, 1f)]
	public float Fade = 1f;

	[Range(0f, 1f)]
	public float FadeFromBinary;

	public Color _MatrixColor = new Color(1f, 0.3f, 0.3f, 1f);

	public static Color ChangeColorRGB;

	private Texture2D Texture2;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		Texture2 = Resources.Load("CameraFilterPack_3D_Binary1") as Texture2D;
		SCShader = Shader.Find("CameraFilterPack/3D_Binary");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_DepthLevel", Fade);
			material.SetFloat("_FadeFromBinary", FadeFromBinary);
			material.SetFloat("_FixDistance", _FixDistance);
			material.SetFloat("_MatrixSize", MatrixSize);
			material.SetColor("_MatrixColor", _MatrixColor);
			material.SetFloat("_MatrixSpeed", MatrixSpeed * 2f);
			material.SetFloat("_Visualize", _Visualize ? 1 : 0);
			material.SetFloat("_LightIntensity", LightIntensity);
			material.SetTexture("_MainTex2", Texture2);
			float farClipPlane = GetComponent<Camera>().farClipPlane;
			material.SetFloat("_FarCamera", 1000f / farClipPlane);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			GetComponent<Camera>().depthTextureMode = DepthTextureMode.Depth;
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/3D/BlackHole")]
public class CameraFilterPack_3D_BlackHole : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	public bool _Visualize;

	private Material SCMaterial;

	[Range(0f, 100f)]
	public float _FixDistance = 5f;

	[Range(-0.99f, 0.99f)]
	public float _Distance = 0.05f;

	[Range(0f, 1f)]
	public float _Size = 0.25f;

	[Range(-2f, 2f)]
	public float DistortionLevel = 1.2f;

	[Range(0f, 1f)]
	public float DistortionSize;

	public bool AutoAnimatedNear;

	[Range(-5f, 5f)]
	public float AutoAnimatedNearSpeed = 0.5f;

	public static Color ChangeColorRGB;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/3D_BlackHole");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			if (AutoAnimatedNear)
			{
				_Distance += Time.deltaTime * AutoAnimatedNearSpeed;
				if (_Distance > 1f)
				{
					_Distance = -1f;
				}
				if (_Distance < -1f)
				{
					_Distance = 1f;
				}
				material.SetFloat("_Near", _Distance);
			}
			else
			{
				material.SetFloat("_Near", _Distance);
			}
			material.SetFloat("_Far", _Size);
			material.SetFloat("_FixDistance", _FixDistance);
			material.SetFloat("_DistortionLevel", DistortionLevel);
			material.SetFloat("_DistortionSize", DistortionSize);
			material.SetFloat("_Visualize", _Visualize ? 1 : 0);
			float farClipPlane = GetComponent<Camera>().farClipPlane;
			material.SetFloat("_FarCamera", 1000f / farClipPlane);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			GetComponent<Camera>().depthTextureMode = DepthTextureMode.Depth;
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/3D/Computer")]
public class CameraFilterPack_3D_Computer : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	public bool _Visualize;

	private Material SCMaterial;

	[Range(0f, 100f)]
	public float _FixDistance = 2f;

	[Range(-5f, 5f)]
	public float LightIntensity = 1f;

	[Range(0f, 8f)]
	public float MatrixSize = 2f;

	[Range(-4f, 4f)]
	public float MatrixSpeed = 0.1f;

	[Range(0f, 1f)]
	public float Fade = 1f;

	public Color _MatrixColor = new Color(0f, 0.5f, 1f, 1f);

	public static Color ChangeColorRGB;

	private Texture2D Texture2;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		Texture2 = Resources.Load("CameraFilterPack_3D_Computer1") as Texture2D;
		SCShader = Shader.Find("CameraFilterPack/3D_Computer");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_DepthLevel", Fade);
			material.SetFloat("_FixDistance", _FixDistance);
			material.SetFloat("_MatrixSize", MatrixSize);
			material.SetColor("_MatrixColor", _MatrixColor);
			material.SetFloat("_MatrixSpeed", MatrixSpeed * 2f);
			material.SetFloat("_Visualize", _Visualize ? 1 : 0);
			material.SetFloat("_LightIntensity", LightIntensity);
			material.SetTexture("_MainTex2", Texture2);
			float farClipPlane = GetComponent<Camera>().farClipPlane;
			material.SetFloat("_FarCamera", 1000f / farClipPlane);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			GetComponent<Camera>().depthTextureMode = DepthTextureMode.Depth;
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/3D/Distortion")]
public class CameraFilterPack_3D_Distortion : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	public bool _Visualize;

	private Material SCMaterial;

	[Range(0f, 100f)]
	public float _FixDistance = 1f;

	[Range(-0.99f, 0.99f)]
	public float _Distance = 0.5f;

	[Range(0f, 0.5f)]
	public float _Size = 0.1f;

	[Range(0f, 10f)]
	public float DistortionLevel = 1.2f;

	[Range(0.1f, 10f)]
	public float DistortionSize = 1.4f;

	[Range(-2f, 4f)]
	public float LightIntensity = 0.08f;

	public bool AutoAnimatedNear;

	[Range(-5f, 5f)]
	public float AutoAnimatedNearSpeed = 0.5f;

	public static Color ChangeColorRGB;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/3D_Distortion");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			if (AutoAnimatedNear)
			{
				_Distance += Time.deltaTime * AutoAnimatedNearSpeed;
				if (_Distance > 1f)
				{
					_Distance = -1f;
				}
				if (_Distance < -1f)
				{
					_Distance = 1f;
				}
				material.SetFloat("_Near", _Distance);
			}
			else
			{
				material.SetFloat("_Near", _Distance);
			}
			material.SetFloat("_Far", _Size);
			material.SetFloat("_FixDistance", _FixDistance);
			material.SetFloat("_DistortionLevel", DistortionLevel * 28f);
			material.SetFloat("_DistortionSize", DistortionSize * 16f);
			material.SetFloat("_LightIntensity", LightIntensity * 64f);
			material.SetFloat("_Visualize", _Visualize ? 1 : 0);
			float farClipPlane = GetComponent<Camera>().farClipPlane;
			material.SetFloat("_FarCamera", 1000f / farClipPlane);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			GetComponent<Camera>().depthTextureMode = DepthTextureMode.Depth;
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/3D/Fog_Smoke")]
public class CameraFilterPack_3D_Fog_Smoke : MonoBehaviour
{
	public Shader SCShader;

	public bool _Visualize;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 100f)]
	public float _FixDistance = 1f;

	[Range(-0.99f, 0.99f)]
	public float _Distance = 0.5f;

	[Range(0f, 0.5f)]
	public float _Size = 0.1f;

	[Range(0f, 10f)]
	public float DistortionLevel = 1.2f;

	[Range(0.1f, 10f)]
	public float DistortionSize = 1.4f;

	[Range(-2f, 4f)]
	public float LightIntensity = 0.08f;

	public bool AutoAnimatedNear;

	[Range(-5f, 5f)]
	public float AutoAnimatedNearSpeed = 0.5f;

	private Texture2D Texture2;

	public static Color ChangeColorRGB;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		Texture2 = Resources.Load("CameraFilterPack_3D_Myst1") as Texture2D;
		SCShader = Shader.Find("CameraFilterPack/3D_Myst");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			if (AutoAnimatedNear)
			{
				_Distance += Time.deltaTime * AutoAnimatedNearSpeed;
				if (_Distance > 1f)
				{
					_Distance = -1f;
				}
				if (_Distance < -1f)
				{
					_Distance = 1f;
				}
				material.SetFloat("_Near", _Distance);
			}
			else
			{
				material.SetFloat("_Near", _Distance);
			}
			material.SetFloat("_Far", _Size);
			material.SetFloat("_Visualize", _Visualize ? 1 : 0);
			material.SetFloat("_FixDistance", _FixDistance);
			material.SetFloat("_DistortionLevel", DistortionLevel * 28f);
			material.SetFloat("_DistortionSize", DistortionSize * 16f);
			material.SetFloat("_LightIntensity", LightIntensity * 64f);
			material.SetTexture("_MainTex2", Texture2);
			float farClipPlane = GetComponent<Camera>().farClipPlane;
			material.SetFloat("_FarCamera", 1000f / farClipPlane);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			GetComponent<Camera>().depthTextureMode = DepthTextureMode.Depth;
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/3D/Ghost")]
public class CameraFilterPack_3D_Ghost : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	public bool _Visualize;

	private Material SCMaterial;

	[Range(0f, 100f)]
	public float _FixDistance = 5f;

	[Range(-0.5f, 0.99f)]
	public float Ghost_Near = 0.08f;

	[Range(0f, 1f)]
	public float Ghost_Far = 0.55f;

	[Range(0f, 2f)]
	public float Intensity = 1f;

	[Range(0f, 1f)]
	public float GhostWithoutObject = 1f;

	[Range(-1f, 1f)]
	public float GhostPosX;

	[Range(-1f, 1f)]
	public float GhostPosY;

	[Range(0.1f, 8f)]
	public float GhostFade2 = 2f;

	[Range(-1f, 1f)]
	public float GhostFade;

	[Range(0.5f, 1.5f)]
	public float GhostSize = 0.9f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/3D_Ghost");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value2", Intensity);
			material.SetFloat("GhostPosX", GhostPosX);
			material.SetFloat("GhostPosY", GhostPosY);
			material.SetFloat("GhostFade", GhostFade);
			material.SetFloat("GhostFade2", GhostFade2);
			material.SetFloat("GhostSize", GhostSize);
			material.SetFloat("_Visualize", _Visualize ? 1 : 0);
			material.SetFloat("_FixDistance", _FixDistance);
			material.SetFloat("Drop_Near", Ghost_Near);
			material.SetFloat("Drop_Far", Ghost_Far);
			material.SetFloat("Drop_With_Obj", GhostWithoutObject);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			GetComponent<Camera>().depthTextureMode = DepthTextureMode.Depth;
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/3D/Inverse")]
public class CameraFilterPack_3D_Inverse : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	public bool _Visualize;

	private Material SCMaterial;

	[Range(0f, 100f)]
	public float _FixDistance = 1.5f;

	[Range(-0.99f, 0.99f)]
	public float _Distance = 0.4f;

	[Range(0f, 0.5f)]
	public float _Size = 0.5f;

	[Range(0f, 1f)]
	public float LightIntensity = 1f;

	public bool AutoAnimatedNear;

	[Range(-5f, 5f)]
	public float AutoAnimatedNearSpeed = 0.5f;

	public static Color ChangeColorRGB;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/3D_Inverse");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			if (AutoAnimatedNear)
			{
				_Distance += Time.deltaTime * AutoAnimatedNearSpeed;
				if (_Distance > 1f)
				{
					_Distance = -1f;
				}
				if (_Distance < -1f)
				{
					_Distance = 1f;
				}
				material.SetFloat("_Near", _Distance);
			}
			else
			{
				material.SetFloat("_Near", _Distance);
			}
			material.SetFloat("_Far", _Size);
			material.SetFloat("_FixDistance", _FixDistance);
			material.SetFloat("_LightIntensity", LightIntensity);
			material.SetFloat("_Visualize", _Visualize ? 1 : 0);
			float farClipPlane = GetComponent<Camera>().farClipPlane;
			material.SetFloat("_FarCamera", 1000f / farClipPlane);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			GetComponent<Camera>().depthTextureMode = DepthTextureMode.Depth;
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/3D/Matrix")]
public class CameraFilterPack_3D_Matrix : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	public bool _Visualize;

	[Range(0f, 100f)]
	public float _FixDistance = 1f;

	[Range(-5f, 5f)]
	public float LightIntensity = 1f;

	[Range(0f, 6f)]
	public float MatrixSize = 1f;

	[Range(-4f, 4f)]
	public float MatrixSpeed = 1f;

	[Range(0f, 1f)]
	public float Fade = 1f;

	public Color _MatrixColor = new Color(0f, 1f, 0f, 1f);

	public static Color ChangeColorRGB;

	private Texture2D Texture2;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		Texture2 = Resources.Load("CameraFilterPack_3D_Matrix1") as Texture2D;
		SCShader = Shader.Find("CameraFilterPack/3D_Matrix");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_DepthLevel", Fade);
			material.SetFloat("_FixDistance", _FixDistance);
			material.SetFloat("_MatrixSize", MatrixSize);
			material.SetColor("_MatrixColor", _MatrixColor);
			material.SetFloat("_MatrixSpeed", MatrixSpeed * 2f);
			material.SetFloat("_Visualize", _Visualize ? 1 : 0);
			material.SetFloat("_LightIntensity", LightIntensity);
			material.SetTexture("_MainTex2", Texture2);
			float farClipPlane = GetComponent<Camera>().farClipPlane;
			material.SetFloat("_FarCamera", 1000f / farClipPlane);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			GetComponent<Camera>().depthTextureMode = DepthTextureMode.Depth;
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/3D/Mirror")]
public class CameraFilterPack_3D_Mirror : MonoBehaviour
{
	public Shader SCShader;

	public bool _Visualize;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 100f)]
	public float _FixDistance = 1.5f;

	[Range(-0.99f, 0.99f)]
	public float _Distance = 0.4f;

	[Range(0f, 0.5f)]
	public float _Size = 0.5f;

	[Range(0f, 1f)]
	public float Fade = 1f;

	[Range(0f, 2f)]
	public float Lightning = 2f;

	public bool AutoAnimatedNear;

	[Range(-5f, 5f)]
	public float AutoAnimatedNearSpeed = 0.5f;

	public static Color ChangeColorRGB;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/3D_Mirror");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			if (AutoAnimatedNear)
			{
				_Distance += Time.deltaTime * AutoAnimatedNearSpeed;
				if (_Distance > 1f)
				{
					_Distance = -1f;
				}
				if (_Distance < -1f)
				{
					_Distance = 1f;
				}
				material.SetFloat("_Near", _Distance);
			}
			else
			{
				material.SetFloat("_Near", _Distance);
			}
			material.SetFloat("_Far", _Size);
			material.SetFloat("_FixDistance", _FixDistance);
			material.SetFloat("Fade", Fade);
			material.SetFloat("Lightning", Lightning);
			material.SetFloat("_Visualize", _Visualize ? 1 : 0);
			float farClipPlane = GetComponent<Camera>().farClipPlane;
			material.SetFloat("_FarCamera", 1000f / farClipPlane);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			GetComponent<Camera>().depthTextureMode = DepthTextureMode.Depth;
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/3D/Myst")]
public class CameraFilterPack_3D_Myst : MonoBehaviour
{
	public Shader SCShader;

	public bool _Visualize;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 100f)]
	public float _FixDistance = 1f;

	[Range(-0.99f, 0.99f)]
	public float _Distance = 0.5f;

	[Range(0f, 0.5f)]
	public float _Size = 0.1f;

	[Range(0f, 10f)]
	public float DistortionLevel = 1.2f;

	[Range(0.1f, 10f)]
	public float DistortionSize = 1.4f;

	[Range(-2f, 4f)]
	public float LightIntensity = 0.08f;

	public bool AutoAnimatedNear;

	[Range(-5f, 5f)]
	public float AutoAnimatedNearSpeed = 0.5f;

	private Texture2D Texture2;

	public static Color ChangeColorRGB;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		Texture2 = Resources.Load("CameraFilterPack_3D_Myst1") as Texture2D;
		SCShader = Shader.Find("CameraFilterPack/3D_Myst");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			if (AutoAnimatedNear)
			{
				_Distance += Time.deltaTime * AutoAnimatedNearSpeed;
				if (_Distance > 1f)
				{
					_Distance = -1f;
				}
				if (_Distance < -1f)
				{
					_Distance = 1f;
				}
				material.SetFloat("_Near", _Distance);
			}
			else
			{
				material.SetFloat("_Near", _Distance);
			}
			material.SetFloat("_Far", _Size);
			material.SetFloat("_Visualize", _Visualize ? 1 : 0);
			material.SetFloat("_FixDistance", _FixDistance);
			material.SetFloat("_DistortionLevel", DistortionLevel * 28f);
			material.SetFloat("_DistortionSize", DistortionSize * 16f);
			material.SetFloat("_LightIntensity", LightIntensity * 64f);
			material.SetTexture("_MainTex2", Texture2);
			float farClipPlane = GetComponent<Camera>().farClipPlane;
			material.SetFloat("_FarCamera", 1000f / farClipPlane);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			GetComponent<Camera>().depthTextureMode = DepthTextureMode.Depth;
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/3D/Scan_Scene")]
public class CameraFilterPack_3D_Scan_Scene : MonoBehaviour
{
	public Shader SCShader;

	public bool _Visualize;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 100f)]
	public float _FixDistance = 1f;

	[Range(0f, 0.99f)]
	public float _Distance = 1f;

	[Range(0f, 0.1f)]
	public float _Size = 0.01f;

	public bool AutoAnimatedNear;

	[Range(-5f, 5f)]
	public float AutoAnimatedNearSpeed = 1f;

	public Color ScanColor = new Color(2f, 0f, 0f, 1f);

	[Range(0f, 1f)]
	public float Fade = 1f;

	public static Color ChangeColorRGB;

	private Texture2D Texture2;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/3D_Scan_Scene");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_DepthLevel", Fade);
			if (AutoAnimatedNear)
			{
				_Distance += Time.deltaTime * AutoAnimatedNearSpeed;
				if (_Distance > 1f)
				{
					_Distance = 0f;
				}
				if (_Distance < 0f)
				{
					_Distance = 1f;
				}
				material.SetFloat("_Near", _Distance);
			}
			else
			{
				material.SetFloat("_Near", _Distance);
			}
			material.SetFloat("_Far", _Size);
			material.SetColor("_ColorRGB", ScanColor);
			material.SetFloat("_FixDistance", _FixDistance);
			material.SetFloat("_Visualize", _Visualize ? 1 : 0);
			float farClipPlane = GetComponent<Camera>().farClipPlane;
			material.SetFloat("_FarCamera", 1000f / farClipPlane);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			GetComponent<Camera>().depthTextureMode = DepthTextureMode.Depth;
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/3D/Shield")]
public class CameraFilterPack_3D_Shield : MonoBehaviour
{
	public Shader SCShader;

	public bool _Visualize;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 100f)]
	public float _FixDistance = 1.5f;

	[Range(-0.99f, 0.99f)]
	public float _Distance = 0.4f;

	[Range(0f, 0.5f)]
	public float _Size = 0.5f;

	[Range(0f, 1f)]
	public float _FadeShield = 0.75f;

	[Range(-0.2f, 0.2f)]
	public float LightIntensity = 0.025f;

	public bool AutoAnimatedNear;

	[Range(-5f, 5f)]
	public float AutoAnimatedNearSpeed = 0.5f;

	[Range(0f, 10f)]
	public float Speed = 0.2f;

	[Range(0f, 10f)]
	public float Speed_X = 0.2f;

	[Range(0f, 1f)]
	public float Speed_Y = 0.3f;

	[Range(0f, 10f)]
	public float Intensity = 2.4f;

	public static Color ChangeColorRGB;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/3D_Shield");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			if (AutoAnimatedNear)
			{
				_Distance += Time.deltaTime * AutoAnimatedNearSpeed;
				if (_Distance > 1f)
				{
					_Distance = -1f;
				}
				if (_Distance < -1f)
				{
					_Distance = 1f;
				}
				material.SetFloat("_Near", _Distance);
			}
			else
			{
				material.SetFloat("_Near", _Distance);
			}
			material.SetFloat("_Far", _Size);
			material.SetFloat("_FixDistance", _FixDistance);
			material.SetFloat("_LightIntensity", LightIntensity * 64f);
			material.SetFloat("_Visualize", _Visualize ? 1 : 0);
			material.SetFloat("_FadeShield", _FadeShield);
			material.SetFloat("_Value", Speed);
			material.SetFloat("_Value2", Speed_X);
			material.SetFloat("_Value3", Speed_Y);
			material.SetFloat("_Value4", Intensity);
			float farClipPlane = GetComponent<Camera>().farClipPlane;
			material.SetFloat("_FarCamera", 1000f / farClipPlane);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			GetComponent<Camera>().depthTextureMode = DepthTextureMode.Depth;
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/3D/Snow")]
public class CameraFilterPack_3D_Snow : MonoBehaviour
{
	public Shader SCShader;

	public bool _Visualize;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 100f)]
	public float _FixDistance = 5f;

	[Range(-0.5f, 0.99f)]
	public float Snow_Near = 0.08f;

	[Range(0f, 1f)]
	public float Snow_Far = 0.55f;

	[Range(0f, 1f)]
	public float Fade = 1f;

	[Range(0f, 2f)]
	public float Intensity = 1f;

	[Range(0.4f, 2f)]
	public float Size = 1f;

	[Range(0f, 0.5f)]
	public float Speed = 0.275f;

	[Range(0f, 1f)]
	public float SnowWithoutObject = 1f;

	private Texture2D Texture2;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		Texture2 = Resources.Load("CameraFilterPack_Blizzard1") as Texture2D;
		SCShader = Shader.Find("CameraFilterPack/3D_Snow");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", Fade);
			material.SetFloat("_Value2", Intensity);
			material.SetFloat("_Value4", Speed * 6f);
			material.SetFloat("_Value5", Size);
			material.SetFloat("_Visualize", _Visualize ? 1 : 0);
			material.SetFloat("_FixDistance", _FixDistance);
			material.SetFloat("Drop_Near", Snow_Near);
			material.SetFloat("Drop_Far", Snow_Far);
			material.SetFloat("Drop_With_Obj", SnowWithoutObject);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			material.SetTexture("Texture2", Texture2);
			GetComponent<Camera>().depthTextureMode = DepthTextureMode.Depth;
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/AAA/Blood")]
public class CameraFilterPack_AAA_Blood : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	[Range(0f, 128f)]
	public float Blood1;

	[Range(0f, 128f)]
	public float Blood2;

	[Range(0f, 128f)]
	public float Blood3;

	[Range(0f, 128f)]
	public float Blood4 = 1f;

	[Range(0f, 0.004f)]
	public float LightReflect = 0.002f;

	private Material SCMaterial;

	private Texture2D Texture2;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		Texture2 = Resources.Load("CameraFilterPack_AAA_Blood1") as Texture2D;
		SCShader = Shader.Find("CameraFilterPack/AAA_Blood");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", LightReflect);
			material.SetFloat("_Value2", Blood1);
			material.SetFloat("_Value3", Blood2);
			material.SetFloat("_Value4", Blood3);
			material.SetFloat("_Value5", Blood4);
			material.SetTexture("_MainTex2", Texture2);
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/AAA/Blood On Screen")]
public class CameraFilterPack_AAA_BloodOnScreen : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	[Range(0.02f, 1.6f)]
	public float Blood_On_Screen = 1f;

	public Color Blood_Color = Color.red;

	[Range(0f, 2f)]
	public float Blood_Intensify = 0.7f;

	[Range(0f, 2f)]
	public float Blood_Darkness = 0.5f;

	[Range(0f, 1f)]
	public float Blood_Distortion_Speed = 0.25f;

	[Range(0f, 1f)]
	public float Blood_Fade = 1f;

	private Material SCMaterial;

	private Texture2D Texture2;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		Texture2 = Resources.Load("CameraFilterPack_AAA_BloodOnScreen1") as Texture2D;
		SCShader = Shader.Find("CameraFilterPack/AAA_BloodOnScreen");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", Mathf.Clamp(Blood_On_Screen, 0.02f, 1.6f));
			material.SetFloat("_Value2", Mathf.Clamp(Blood_Intensify, 0f, 2f));
			material.SetFloat("_Value3", Mathf.Clamp(Blood_Darkness, 0f, 2f));
			material.SetFloat("_Value4", Mathf.Clamp(Blood_Fade, 0f, 1f));
			material.SetFloat("_Value5", Mathf.Clamp(Blood_Distortion_Speed, 0f, 2f));
			material.SetColor("_Color2", Blood_Color);
			material.SetTexture("_MainTex2", Texture2);
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/AAA/Blood_Hit")]
public class CameraFilterPack_AAA_Blood_Hit : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	[Range(0f, 1f)]
	public float Hit_Left = 1f;

	[Range(0f, 1f)]
	public float Hit_Up;

	[Range(0f, 1f)]
	public float Hit_Right;

	[Range(0f, 1f)]
	public float Hit_Down;

	[Range(0f, 1f)]
	public float Blood_Hit_Left;

	[Range(0f, 1f)]
	public float Blood_Hit_Up;

	[Range(0f, 1f)]
	public float Blood_Hit_Right;

	[Range(0f, 1f)]
	public float Blood_Hit_Down;

	[Range(0f, 1f)]
	public float Hit_Full;

	[Range(0f, 1f)]
	public float Blood_Hit_Full_1;

	[Range(0f, 1f)]
	public float Blood_Hit_Full_2;

	[Range(0f, 1f)]
	public float Blood_Hit_Full_3;

	[Range(0f, 1f)]
	public float LightReflect = 0.5f;

	private Material SCMaterial;

	private Texture2D Texture2;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		Texture2 = Resources.Load("CameraFilterPack_AAA_Blood_Hit1") as Texture2D;
		SCShader = Shader.Find("CameraFilterPack/AAA_Blood_Hit");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", LightReflect);
			material.SetFloat("_Value2", Mathf.Clamp(Hit_Left, 0f, 1f));
			material.SetFloat("_Value3", Mathf.Clamp(Hit_Up, 0f, 1f));
			material.SetFloat("_Value4", Mathf.Clamp(Hit_Right, 0f, 1f));
			material.SetFloat("_Value5", Mathf.Clamp(Hit_Down, 0f, 1f));
			material.SetFloat("_Value6", Mathf.Clamp(Blood_Hit_Left, 0f, 1f));
			material.SetFloat("_Value7", Mathf.Clamp(Blood_Hit_Up, 0f, 1f));
			material.SetFloat("_Value8", Mathf.Clamp(Blood_Hit_Right, 0f, 1f));
			material.SetFloat("_Value9", Mathf.Clamp(Blood_Hit_Down, 0f, 1f));
			material.SetFloat("_Value10", Mathf.Clamp(Hit_Full, 0f, 1f));
			material.SetFloat("_Value11", Mathf.Clamp(Blood_Hit_Full_1, 0f, 1f));
			material.SetFloat("_Value12", Mathf.Clamp(Blood_Hit_Full_2, 0f, 1f));
			material.SetFloat("_Value13", Mathf.Clamp(Blood_Hit_Full_3, 0f, 1f));
			material.SetTexture("_MainTex2", Texture2);
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/AAA/Blood_Plus")]
public class CameraFilterPack_AAA_Blood_Plus : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	[Range(0f, 1f)]
	public float Blood_1 = 1f;

	[Range(0f, 1f)]
	public float Blood_2;

	[Range(0f, 1f)]
	public float Blood_3;

	[Range(0f, 1f)]
	public float Blood_4;

	[Range(0f, 1f)]
	public float Blood_5;

	[Range(0f, 1f)]
	public float Blood_6;

	[Range(0f, 1f)]
	public float Blood_7;

	[Range(0f, 1f)]
	public float Blood_8;

	[Range(0f, 1f)]
	public float Blood_9;

	[Range(0f, 1f)]
	public float Blood_10;

	[Range(0f, 1f)]
	public float Blood_11;

	[Range(0f, 1f)]
	public float Blood_12;

	[Range(0f, 1f)]
	public float LightReflect = 0.5f;

	private Material SCMaterial;

	private Texture2D Texture2;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		Texture2 = Resources.Load("CameraFilterPack_AAA_Blood2") as Texture2D;
		SCShader = Shader.Find("CameraFilterPack/AAA_Blood_Plus");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", LightReflect);
			material.SetFloat("_Value2", Mathf.Clamp(Blood_1, 0f, 1f));
			material.SetFloat("_Value3", Mathf.Clamp(Blood_2, 0f, 1f));
			material.SetFloat("_Value4", Mathf.Clamp(Blood_3, 0f, 1f));
			material.SetFloat("_Value5", Mathf.Clamp(Blood_4, 0f, 1f));
			material.SetFloat("_Value6", Mathf.Clamp(Blood_5, 0f, 1f));
			material.SetFloat("_Value7", Mathf.Clamp(Blood_6, 0f, 1f));
			material.SetFloat("_Value8", Mathf.Clamp(Blood_7, 0f, 1f));
			material.SetFloat("_Value9", Mathf.Clamp(Blood_8, 0f, 1f));
			material.SetFloat("_Value10", Mathf.Clamp(Blood_9, 0f, 1f));
			material.SetFloat("_Value11", Mathf.Clamp(Blood_10, 0f, 1f));
			material.SetFloat("_Value12", Mathf.Clamp(Blood_11, 0f, 1f));
			material.SetFloat("_Value13", Mathf.Clamp(Blood_12, 0f, 1f));
			material.SetTexture("_MainTex2", Texture2);
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/AAA/Super Computer")]
public class CameraFilterPack_AAA_SuperComputer : MonoBehaviour
{
	public Shader SCShader;

	[Range(0f, 1f)]
	public float _AlphaHexa = 1f;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(-20f, 20f)]
	public float ShapeFormula = 10f;

	[Range(0f, 6f)]
	public float Shape = 1f;

	[Range(-4f, 4f)]
	public float _BorderSize = 1f;

	public Color _BorderColor = new Color(0f, 0.2f, 1f, 1f);

	public float _SpotSize = 2.5f;

	public Vector2 center = new Vector2(0f, 0f);

	public float Radius = 0.77f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/AAA_Super_Computer");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime / 4f;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", ShapeFormula);
			material.SetFloat("_Value2", Shape);
			material.SetFloat("_PositionX", center.x);
			material.SetFloat("_PositionY", center.y);
			material.SetFloat("_Radius", Radius);
			material.SetFloat("_BorderSize", _BorderSize);
			material.SetColor("_BorderColor", _BorderColor);
			material.SetFloat("_AlphaHexa", _AlphaHexa);
			material.SetFloat("_SpotSize", _SpotSize);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/AAA/Super Hexagon")]
public class CameraFilterPack_AAA_SuperHexagon : MonoBehaviour
{
	public Shader SCShader;

	[Range(0f, 1f)]
	public float _AlphaHexa = 1f;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0.2f, 10f)]
	public float HexaSize = 2.5f;

	public float _BorderSize = 1f;

	public Color _BorderColor = new Color(0.75f, 0.75f, 1f, 1f);

	public Color _HexaColor = new Color(0f, 0.5f, 1f, 1f);

	public float _SpotSize = 2.5f;

	public Vector2 center = new Vector2(0.5f, 0.5f);

	public float Radius = 0.25f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/AAA_Super_Hexagon");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", HexaSize);
			material.SetFloat("_PositionX", center.x);
			material.SetFloat("_PositionY", center.y);
			material.SetFloat("_Radius", Radius);
			material.SetFloat("_BorderSize", _BorderSize);
			material.SetColor("_BorderColor", _BorderColor);
			material.SetColor("_HexaColor", _HexaColor);
			material.SetFloat("_AlphaHexa", _AlphaHexa);
			material.SetFloat("_SpotSize", _SpotSize);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/AAA/WaterDrop")]
public class CameraFilterPack_AAA_WaterDrop : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	[Range(8f, 64f)]
	public float Distortion = 8f;

	[Range(0f, 7f)]
	public float SizeX = 1f;

	[Range(0f, 7f)]
	public float SizeY = 0.5f;

	[Range(0f, 10f)]
	public float Speed = 1f;

	private Material SCMaterial;

	private Texture2D Texture2;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		Texture2 = Resources.Load("CameraFilterPack_WaterDrop") as Texture2D;
		SCShader = Shader.Find("CameraFilterPack/AAA_WaterDrop");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Distortion", Distortion);
			material.SetFloat("_SizeX", SizeX);
			material.SetFloat("_SizeY", SizeY);
			material.SetFloat("_Speed", Speed);
			material.SetTexture("_MainTex2", Texture2);
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/AAA/WaterDropPro")]
public class CameraFilterPack_AAA_WaterDropPro : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	[Range(8f, 64f)]
	public float Distortion = 8f;

	[Range(0f, 7f)]
	public float SizeX = 1f;

	[Range(0f, 7f)]
	public float SizeY = 0.5f;

	[Range(0f, 10f)]
	public float Speed = 1f;

	private Material SCMaterial;

	private Texture2D Texture2;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		Texture2 = Resources.Load("CameraFilterPack_WaterDrop") as Texture2D;
		SCShader = Shader.Find("CameraFilterPack/AAA_WaterDropPro");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Distortion", Distortion);
			material.SetFloat("_SizeX", SizeX);
			material.SetFloat("_SizeY", SizeY);
			material.SetFloat("_Speed", Speed);
			material.SetTexture("_MainTex2", Texture2);
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Alien/Vision")]
public class CameraFilterPack_Alien_Vision : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 0.5f)]
	public float Therma_Variation = 0.5f;

	[Range(0f, 1f)]
	public float Speed = 0.5f;

	[Range(0f, 4f)]
	private float Burn;

	[Range(0f, 16f)]
	private float SceneCut = 1f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Alien_Vision");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", Therma_Variation);
			material.SetFloat("_Value2", Speed);
			material.SetFloat("_Value3", Burn);
			material.SetFloat("_Value4", SceneCut);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Antialiasing/FXAA")]
public class CameraFilterPack_Antialiasing_FXAA : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Antialiasing_FXAA");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetVector("_ScreenResolution", new Vector2(Screen.width, Screen.height));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Weather/Fog")]
public class CameraFilterPack_Atmosphere_Fog : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	public float _Near;

	[Range(0f, 1f)]
	public float _Far = 0.05f;

	public Color FogColor = new Color(0.4f, 0.4f, 0.4f, 1f);

	[Range(0f, 1f)]
	public float Fade = 1f;

	public static Color ChangeColorRGB;

	private Texture2D Texture2;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		Texture2 = Resources.Load("CameraFilterPack_Atmosphere_Rain_FX") as Texture2D;
		SCShader = Shader.Find("CameraFilterPack/Atmosphere_Fog");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_DepthLevel", Fade);
			material.SetFloat("_Near", _Near);
			material.SetFloat("_Far", _Far);
			material.SetColor("_ColorRGB", FogColor);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			GetComponent<Camera>().depthTextureMode = DepthTextureMode.Depth;
			material.SetTexture("Texture2", Texture2);
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Weather/Rain")]
public class CameraFilterPack_Atmosphere_Rain : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	public float Fade = 1f;

	[Range(0f, 2f)]
	public float Intensity = 0.5f;

	[Range(-0.25f, 0.25f)]
	public float DirectionX = 0.12f;

	[Range(0.4f, 2f)]
	public float Size = 1.5f;

	[Range(0f, 0.5f)]
	public float Speed = 0.275f;

	[Range(0f, 0.5f)]
	public float Distortion = 0.05f;

	[Range(0f, 1f)]
	public float StormFlashOnOff = 1f;

	private Texture2D Texture2;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		Texture2 = Resources.Load("CameraFilterPack_Atmosphere_Rain_FX") as Texture2D;
		SCShader = Shader.Find("CameraFilterPack/Atmosphere_Rain");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", Fade);
			material.SetFloat("_Value2", Intensity);
			material.SetFloat("_Value3", DirectionX);
			material.SetFloat("_Value4", Speed);
			material.SetFloat("_Value5", Size);
			material.SetFloat("_Value6", Distortion);
			material.SetFloat("_Value7", StormFlashOnOff);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			material.SetTexture("Texture2", Texture2);
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Weather/Rain_Pro")]
public class CameraFilterPack_Atmosphere_Rain_Pro : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	public float Fade = 1f;

	[Range(0f, 2f)]
	public float Intensity = 0.5f;

	[Range(-0.25f, 0.25f)]
	public float DirectionX = 0.12f;

	[Range(0.4f, 2f)]
	public float Size = 1.5f;

	[Range(0f, 0.5f)]
	public float Speed = 0.275f;

	[Range(0f, 0.5f)]
	public float Distortion = 0.025f;

	[Range(0f, 1f)]
	public float StormFlashOnOff = 1f;

	[Range(0f, 1f)]
	public float DropOnOff = 1f;

	private Texture2D Texture2;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		Texture2 = Resources.Load("CameraFilterPack_Atmosphere_Rain_FX") as Texture2D;
		SCShader = Shader.Find("CameraFilterPack/Atmosphere_Rain_Pro");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", Fade);
			material.SetFloat("_Value2", Intensity);
			material.SetFloat("_Value3", DirectionX);
			material.SetFloat("_Value4", Speed);
			material.SetFloat("_Value5", Size);
			material.SetFloat("_Value6", Distortion);
			material.SetFloat("_Value7", StormFlashOnOff);
			material.SetFloat("_Value8", DropOnOff);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			material.SetTexture("Texture2", Texture2);
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Weather/Rain_Pro_3D")]
public class CameraFilterPack_Atmosphere_Rain_Pro_3D : MonoBehaviour
{
	public Shader SCShader;

	public bool _Visualize;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 100f)]
	public float _FixDistance = 3f;

	[Range(0f, 1f)]
	public float Fade = 1f;

	[Range(0f, 2f)]
	public float Intensity = 0.5f;

	public bool DirectionFollowCameraZ;

	[Range(-0.45f, 0.45f)]
	public float DirectionX = 0.12f;

	[Range(0.4f, 2f)]
	public float Size = 1.5f;

	[Range(0f, 0.5f)]
	public float Speed = 0.275f;

	[Range(0f, 0.5f)]
	public float Distortion = 0.025f;

	[Range(0f, 1f)]
	public float StormFlashOnOff = 1f;

	[Range(0f, 1f)]
	public float DropOnOff = 1f;

	[Range(-0.5f, 0.99f)]
	public float Drop_Near;

	[Range(0f, 1f)]
	public float Drop_Far = 0.5f;

	[Range(0f, 1f)]
	public float Drop_With_Obj = 0.2f;

	[Range(0f, 1f)]
	public float Myst = 0.1f;

	[Range(0f, 1f)]
	public float Drop_Floor_Fluid;

	public Color Myst_Color = new Color(0.5f, 0.5f, 0.5f, 1f);

	private Texture2D Texture2;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		Texture2 = Resources.Load("CameraFilterPack_Atmosphere_Rain_FX") as Texture2D;
		SCShader = Shader.Find("CameraFilterPack/Atmosphere_Rain_Pro_3D");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", Fade);
			material.SetFloat("_Value2", Intensity);
			if (DirectionFollowCameraZ)
			{
				float z = GetComponent<Camera>().transform.rotation.z;
				if (z > 0f && z < 360f)
				{
					material.SetFloat("_Value3", z);
				}
				if (z < 0f)
				{
					material.SetFloat("_Value3", z);
				}
			}
			else
			{
				material.SetFloat("_Value3", DirectionX);
			}
			material.SetFloat("_Value4", Speed);
			material.SetFloat("_Value5", Size);
			material.SetFloat("_Value6", Distortion);
			material.SetFloat("_Value7", StormFlashOnOff);
			material.SetFloat("_Value8", DropOnOff);
			material.SetFloat("_FixDistance", _FixDistance);
			material.SetFloat("_Visualize", _Visualize ? 1 : 0);
			material.SetFloat("Drop_Near", Drop_Near);
			material.SetFloat("Drop_Far", Drop_Far);
			material.SetFloat("Drop_With_Obj", 1f - Drop_With_Obj);
			material.SetFloat("Myst", Myst);
			material.SetColor("Myst_Color", Myst_Color);
			material.SetFloat("Drop_Floor_Fluid", Drop_Floor_Fluid);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			material.SetTexture("Texture2", Texture2);
			GetComponent<Camera>().depthTextureMode = DepthTextureMode.Depth;
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Pixel/Snow_8bits")]
public class CameraFilterPack_Atmosphere_Snow_8bits : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0.9f, 2f)]
	public float Threshold = 1f;

	[Range(8f, 256f)]
	public float Size = 64f;

	[Range(-0.5f, 0.5f)]
	public float DirectionX;

	[Range(0f, 1f)]
	public float Fade = 1f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Atmosphere_Snow_8bits");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", Threshold);
			material.SetFloat("_Value2", Size);
			material.SetFloat("_Value3", DirectionX);
			material.SetFloat("_Value4", Fade);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Blend 2 Camera/Blend")]
public class CameraFilterPack_Blend2Camera_Blend : MonoBehaviour
{
	private string ShaderName = "CameraFilterPack/Blend2Camera_Blend";

	public Shader SCShader;

	public Camera Camera2;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	public float BlendFX = 0.5f;

	private RenderTexture Camera2tex;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
			Camera2.targetTexture = Camera2tex;
		}
		SCShader = Shader.Find(ShaderName);
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetTexture("_MainTex2", Camera2tex);
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", BlendFX);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void OnValidate()
	{
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
			Camera2.targetTexture = Camera2tex;
		}
	}

	private void Update()
	{
	}

	private void OnEnable()
	{
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
			Camera2.targetTexture = Camera2tex;
		}
	}

	private void OnDisable()
	{
		if (Camera2 != null)
		{
			Camera2.targetTexture = null;
		}
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Chroma Key/BlueScreen")]
public class CameraFilterPack_Blend2Camera_BlueScreen : MonoBehaviour
{
	private string ShaderName = "CameraFilterPack/Blend2Camera_BlueScreen";

	public Shader SCShader;

	public Camera Camera2;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	public float BlendFX = 1f;

	[Range(-0.2f, 0.2f)]
	public float Adjust;

	[Range(-0.2f, 0.2f)]
	public float Precision;

	[Range(-0.2f, 0.2f)]
	public float Luminosity;

	[Range(-0.3f, 0.3f)]
	public float Change_Red;

	[Range(-0.3f, 0.3f)]
	public float Change_Green;

	[Range(-0.3f, 0.3f)]
	public float Change_Blue;

	private RenderTexture Camera2tex;

	private Vector2 ScreenSize;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void OnValidate()
	{
		ScreenSize.x = Screen.width;
		ScreenSize.y = Screen.height;
	}

	private void Start()
	{
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture((int)ScreenSize.x, (int)ScreenSize.y, 24);
			Camera2.targetTexture = Camera2tex;
		}
		SCShader = Shader.Find(ShaderName);
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			if (Camera2 != null)
			{
				material.SetTexture("_MainTex2", Camera2tex);
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", BlendFX);
			material.SetFloat("_Value2", Adjust);
			material.SetFloat("_Value3", Precision);
			material.SetFloat("_Value4", Luminosity);
			material.SetFloat("_Value5", Change_Red);
			material.SetFloat("_Value6", Change_Green);
			material.SetFloat("_Value7", Change_Blue);
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
		ScreenSize.x = Screen.width;
		ScreenSize.y = Screen.height;
		_ = Application.isPlaying;
	}

	private void OnEnable()
	{
		Start();
	}

	private void OnDisable()
	{
		if (Camera2 != null)
		{
			Camera2.targetTexture = null;
		}
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Blend 2 Camera/Color")]
public class CameraFilterPack_Blend2Camera_Color : MonoBehaviour
{
	private string ShaderName = "CameraFilterPack/Blend2Camera_Color";

	public Shader SCShader;

	public Camera Camera2;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	public float SwitchCameraToCamera2;

	[Range(0f, 1f)]
	public float BlendFX = 0.5f;

	private RenderTexture Camera2tex;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
			Camera2.targetTexture = Camera2tex;
		}
		SCShader = Shader.Find(ShaderName);
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			if (Camera2 != null)
			{
				material.SetTexture("_MainTex2", Camera2tex);
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", BlendFX);
			material.SetFloat("_Value2", SwitchCameraToCamera2);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void OnValidate()
	{
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
			Camera2.targetTexture = Camera2tex;
		}
	}

	private void Update()
	{
	}

	private void OnEnable()
	{
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
			Camera2.targetTexture = Camera2tex;
		}
	}

	private void OnDisable()
	{
		if (Camera2 != null)
		{
			Camera2.targetTexture = null;
		}
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Blend 2 Camera/ColorBurn")]
public class CameraFilterPack_Blend2Camera_ColorBurn : MonoBehaviour
{
	private string ShaderName = "CameraFilterPack/Blend2Camera_ColorBurn";

	public Shader SCShader;

	public Camera Camera2;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	public float SwitchCameraToCamera2;

	[Range(0f, 1f)]
	public float BlendFX = 0.5f;

	private RenderTexture Camera2tex;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
			Camera2.targetTexture = Camera2tex;
		}
		SCShader = Shader.Find(ShaderName);
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			if (Camera2 != null)
			{
				material.SetTexture("_MainTex2", Camera2tex);
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", BlendFX);
			material.SetFloat("_Value2", SwitchCameraToCamera2);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void OnValidate()
	{
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
			Camera2.targetTexture = Camera2tex;
		}
	}

	private void Update()
	{
	}

	private void OnEnable()
	{
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
			Camera2.targetTexture = Camera2tex;
		}
	}

	private void OnDisable()
	{
		if (Camera2 != null)
		{
			Camera2.targetTexture = null;
		}
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Blend 2 Camera/ColorDodge")]
public class CameraFilterPack_Blend2Camera_ColorDodge : MonoBehaviour
{
	private string ShaderName = "CameraFilterPack/Blend2Camera_ColorDodge";

	public Shader SCShader;

	public Camera Camera2;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	public float SwitchCameraToCamera2;

	[Range(0f, 1f)]
	public float BlendFX = 0.5f;

	private RenderTexture Camera2tex;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
			Camera2.targetTexture = Camera2tex;
		}
		SCShader = Shader.Find(ShaderName);
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			if (Camera2 != null)
			{
				material.SetTexture("_MainTex2", Camera2tex);
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", BlendFX);
			material.SetFloat("_Value2", SwitchCameraToCamera2);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void OnValidate()
	{
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
			Camera2.targetTexture = Camera2tex;
		}
	}

	private void Update()
	{
	}

	private void OnEnable()
	{
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
			Camera2.targetTexture = Camera2tex;
		}
	}

	private void OnDisable()
	{
		if (Camera2 != null)
		{
			Camera2.targetTexture = null;
		}
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Chroma Key/Color Key")]
public class CameraFilterPack_Blend2Camera_ColorKey : MonoBehaviour
{
	private string ShaderName = "CameraFilterPack/Blend2Camera_ColorKey";

	public Shader SCShader;

	public Camera Camera2;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	public float BlendFX = 1f;

	public Color ColorKey;

	[Range(-0.2f, 0.2f)]
	public float Adjust;

	[Range(-0.2f, 0.2f)]
	public float Precision;

	[Range(-0.2f, 0.2f)]
	public float Luminosity;

	[Range(-0.3f, 0.3f)]
	public float Change_Red;

	[Range(-0.3f, 0.3f)]
	public float Change_Green;

	[Range(-0.3f, 0.3f)]
	public float Change_Blue;

	private RenderTexture Camera2tex;

	private Vector2 ScreenSize;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture((int)ScreenSize.x, (int)ScreenSize.y, 24);
			Camera2.targetTexture = Camera2tex;
		}
		SCShader = Shader.Find(ShaderName);
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			if (Camera2 != null)
			{
				material.SetTexture("_MainTex2", Camera2tex);
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", BlendFX);
			material.SetFloat("_Value2", Adjust);
			material.SetFloat("_Value3", Precision);
			material.SetFloat("_Value4", Luminosity);
			material.SetFloat("_Value5", Change_Red);
			material.SetFloat("_Value6", Change_Green);
			material.SetFloat("_Value7", Change_Blue);
			material.SetColor("_ColorKey", ColorKey);
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
		ScreenSize.x = Screen.width;
		ScreenSize.y = Screen.height;
		_ = Application.isPlaying;
	}

	private void OnEnable()
	{
		Start();
		Update();
	}

	private void OnDisable()
	{
		if (Camera2 != null && Camera2.targetTexture != null)
		{
			Camera2.targetTexture = null;
		}
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Blend 2 Camera/Darken")]
public class CameraFilterPack_Blend2Camera_Darken : MonoBehaviour
{
	private string ShaderName = "CameraFilterPack/Blend2Camera_Darken";

	public Shader SCShader;

	public Camera Camera2;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	public float SwitchCameraToCamera2;

	[Range(0f, 1f)]
	public float BlendFX = 0.5f;

	private RenderTexture Camera2tex;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
			Camera2.targetTexture = Camera2tex;
		}
		SCShader = Shader.Find(ShaderName);
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			if (Camera2 != null)
			{
				material.SetTexture("_MainTex2", Camera2tex);
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", BlendFX);
			material.SetFloat("_Value2", SwitchCameraToCamera2);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void OnValidate()
	{
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
			Camera2.targetTexture = Camera2tex;
		}
	}

	private void Update()
	{
	}

	private void OnEnable()
	{
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
			Camera2.targetTexture = Camera2tex;
		}
	}

	private void OnDisable()
	{
		if (Camera2 != null)
		{
			Camera2.targetTexture = null;
		}
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Blend 2 Camera/DarkerColor")]
public class CameraFilterPack_Blend2Camera_DarkerColor : MonoBehaviour
{
	private string ShaderName = "CameraFilterPack/Blend2Camera_DarkerColor";

	public Shader SCShader;

	public Camera Camera2;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	public float SwitchCameraToCamera2;

	[Range(0f, 1f)]
	public float BlendFX = 0.5f;

	private RenderTexture Camera2tex;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
			Camera2.targetTexture = Camera2tex;
		}
		SCShader = Shader.Find(ShaderName);
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			if (Camera2 != null)
			{
				material.SetTexture("_MainTex2", Camera2tex);
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", BlendFX);
			material.SetFloat("_Value2", SwitchCameraToCamera2);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void OnValidate()
	{
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
			Camera2.targetTexture = Camera2tex;
		}
	}

	private void Update()
	{
	}

	private void OnEnable()
	{
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
			Camera2.targetTexture = Camera2tex;
		}
	}

	private void OnDisable()
	{
		if (Camera2 != null)
		{
			Camera2.targetTexture = null;
		}
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Blend 2 Camera/Difference")]
public class CameraFilterPack_Blend2Camera_Difference : MonoBehaviour
{
	private string ShaderName = "CameraFilterPack/Blend2Camera_Difference";

	public Shader SCShader;

	public Camera Camera2;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	public float SwitchCameraToCamera2;

	[Range(0f, 1f)]
	public float BlendFX = 0.5f;

	private RenderTexture Camera2tex;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
			Camera2.targetTexture = Camera2tex;
		}
		SCShader = Shader.Find(ShaderName);
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			if (Camera2 != null)
			{
				material.SetTexture("_MainTex2", Camera2tex);
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", BlendFX);
			material.SetFloat("_Value2", SwitchCameraToCamera2);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void OnValidate()
	{
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
			Camera2.targetTexture = Camera2tex;
		}
	}

	private void Update()
	{
	}

	private void OnEnable()
	{
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
			Camera2.targetTexture = Camera2tex;
		}
	}

	private void OnDisable()
	{
		if (Camera2 != null)
		{
			Camera2.targetTexture = null;
		}
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Blend 2 Camera/Divide")]
public class CameraFilterPack_Blend2Camera_Divide : MonoBehaviour
{
	private string ShaderName = "CameraFilterPack/Blend2Camera_Divide";

	public Shader SCShader;

	public Camera Camera2;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	public float SwitchCameraToCamera2;

	[Range(0f, 1f)]
	public float BlendFX = 0.5f;

	private RenderTexture Camera2tex;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
			Camera2.targetTexture = Camera2tex;
		}
		SCShader = Shader.Find(ShaderName);
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			if (Camera2 != null)
			{
				material.SetTexture("_MainTex2", Camera2tex);
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", BlendFX);
			material.SetFloat("_Value2", SwitchCameraToCamera2);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void OnValidate()
	{
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
			Camera2.targetTexture = Camera2tex;
		}
	}

	private void Update()
	{
	}

	private void OnEnable()
	{
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
			Camera2.targetTexture = Camera2tex;
		}
	}

	private void OnDisable()
	{
		if (Camera2 != null)
		{
			Camera2.targetTexture = null;
		}
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Blend 2 Camera/Exclusion")]
public class CameraFilterPack_Blend2Camera_Exclusion : MonoBehaviour
{
	private string ShaderName = "CameraFilterPack/Blend2Camera_Exclusion";

	public Shader SCShader;

	public Camera Camera2;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	public float SwitchCameraToCamera2;

	[Range(0f, 1f)]
	public float BlendFX = 0.5f;

	private RenderTexture Camera2tex;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
			Camera2.targetTexture = Camera2tex;
		}
		SCShader = Shader.Find(ShaderName);
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			if (Camera2 != null)
			{
				material.SetTexture("_MainTex2", Camera2tex);
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", BlendFX);
			material.SetFloat("_Value2", SwitchCameraToCamera2);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void OnValidate()
	{
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
			Camera2.targetTexture = Camera2tex;
		}
	}

	private void Update()
	{
	}

	private void OnEnable()
	{
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
			Camera2.targetTexture = Camera2tex;
		}
	}

	private void OnDisable()
	{
		if (Camera2 != null)
		{
			Camera2.targetTexture = null;
		}
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Chroma Key/GreenScreen")]
public class CameraFilterPack_Blend2Camera_GreenScreen : MonoBehaviour
{
	private string ShaderName = "CameraFilterPack/Blend2Camera_GreenScreen";

	public Shader SCShader;

	public Camera Camera2;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	public float BlendFX = 1f;

	[Range(-0.2f, 0.2f)]
	public float Adjust;

	[Range(-0.2f, 0.2f)]
	public float Precision;

	[Range(-0.2f, 0.2f)]
	public float Luminosity;

	[Range(-0.3f, 0.3f)]
	public float Change_Red;

	[Range(-0.3f, 0.3f)]
	public float Change_Green;

	[Range(-0.3f, 0.3f)]
	public float Change_Blue;

	private RenderTexture Camera2tex;

	private Vector2 ScreenSize;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture((int)ScreenSize.x, (int)ScreenSize.y, 24);
			Camera2.targetTexture = Camera2tex;
		}
		SCShader = Shader.Find(ShaderName);
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			if (Camera2 != null)
			{
				material.SetTexture("_MainTex2", Camera2tex);
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", BlendFX);
			material.SetFloat("_Value2", Adjust);
			material.SetFloat("_Value3", Precision);
			material.SetFloat("_Value4", Luminosity);
			material.SetFloat("_Value5", Change_Red);
			material.SetFloat("_Value6", Change_Green);
			material.SetFloat("_Value7", Change_Blue);
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
		ScreenSize.x = Screen.width;
		ScreenSize.y = Screen.height;
		_ = Application.isPlaying;
	}

	private void OnEnable()
	{
		Start();
		Update();
	}

	private void OnDisable()
	{
		if (Camera2 != null && Camera2.targetTexture != null)
		{
			Camera2.targetTexture = null;
		}
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Blend 2 Camera/HardLight")]
public class CameraFilterPack_Blend2Camera_HardLight : MonoBehaviour
{
	private string ShaderName = "CameraFilterPack/Blend2Camera_HardLight";

	public Shader SCShader;

	public Camera Camera2;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	public float SwitchCameraToCamera2;

	[Range(0f, 1f)]
	public float BlendFX = 0.5f;

	private RenderTexture Camera2tex;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
			Camera2.targetTexture = Camera2tex;
		}
		SCShader = Shader.Find(ShaderName);
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			if (Camera2 != null)
			{
				material.SetTexture("_MainTex2", Camera2tex);
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", BlendFX);
			material.SetFloat("_Value2", SwitchCameraToCamera2);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void OnValidate()
	{
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
			Camera2.targetTexture = Camera2tex;
		}
	}

	private void Update()
	{
	}

	private void OnEnable()
	{
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
			Camera2.targetTexture = Camera2tex;
		}
	}

	private void OnDisable()
	{
		if (Camera2 != null)
		{
			Camera2.targetTexture = null;
		}
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Blend 2 Camera/HardMix")]
public class CameraFilterPack_Blend2Camera_HardMix : MonoBehaviour
{
	private string ShaderName = "CameraFilterPack/Blend2Camera_HardMix";

	public Shader SCShader;

	public Camera Camera2;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	public float SwitchCameraToCamera2;

	[Range(0f, 1f)]
	public float BlendFX = 0.5f;

	private RenderTexture Camera2tex;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
			Camera2.targetTexture = Camera2tex;
		}
		SCShader = Shader.Find(ShaderName);
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			if (Camera2 != null)
			{
				material.SetTexture("_MainTex2", Camera2tex);
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", BlendFX);
			material.SetFloat("_Value2", SwitchCameraToCamera2);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void OnValidate()
	{
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
			Camera2.targetTexture = Camera2tex;
		}
	}

	private void Update()
	{
	}

	private void OnEnable()
	{
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
			Camera2.targetTexture = Camera2tex;
		}
	}

	private void OnDisable()
	{
		if (Camera2 != null)
		{
			Camera2.targetTexture = null;
		}
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Blend 2 Camera/Hue")]
public class CameraFilterPack_Blend2Camera_Hue : MonoBehaviour
{
	private string ShaderName = "CameraFilterPack/Blend2Camera_Hue";

	public Shader SCShader;

	public Camera Camera2;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	public float SwitchCameraToCamera2;

	[Range(0f, 1f)]
	public float BlendFX = 0.5f;

	private RenderTexture Camera2tex;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
			Camera2.targetTexture = Camera2tex;
		}
		SCShader = Shader.Find(ShaderName);
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			if (Camera2 != null)
			{
				material.SetTexture("_MainTex2", Camera2tex);
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", BlendFX);
			material.SetFloat("_Value2", SwitchCameraToCamera2);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void OnValidate()
	{
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
			Camera2.targetTexture = Camera2tex;
		}
	}

	private void Update()
	{
	}

	private void OnEnable()
	{
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
			Camera2.targetTexture = Camera2tex;
		}
	}

	private void OnDisable()
	{
		if (Camera2 != null)
		{
			Camera2.targetTexture = null;
		}
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Blend 2 Camera/Lighten")]
public class CameraFilterPack_Blend2Camera_Lighten : MonoBehaviour
{
	private string ShaderName = "CameraFilterPack/Blend2Camera_Lighten";

	public Shader SCShader;

	public Camera Camera2;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	public float SwitchCameraToCamera2;

	[Range(0f, 1f)]
	public float BlendFX = 0.5f;

	private RenderTexture Camera2tex;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
			Camera2.targetTexture = Camera2tex;
		}
		SCShader = Shader.Find(ShaderName);
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			if (Camera2 != null)
			{
				material.SetTexture("_MainTex2", Camera2tex);
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", BlendFX);
			material.SetFloat("_Value2", SwitchCameraToCamera2);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void OnValidate()
	{
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
			Camera2.targetTexture = Camera2tex;
		}
	}

	private void Update()
	{
	}

	private void OnEnable()
	{
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
			Camera2.targetTexture = Camera2tex;
		}
	}

	private void OnDisable()
	{
		if (Camera2 != null)
		{
			Camera2.targetTexture = null;
		}
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Blend 2 Camera/LighterColor")]
public class CameraFilterPack_Blend2Camera_LighterColor : MonoBehaviour
{
	private string ShaderName = "CameraFilterPack/Blend2Camera_LighterColor";

	public Shader SCShader;

	public Camera Camera2;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	public float SwitchCameraToCamera2;

	[Range(0f, 1f)]
	public float BlendFX = 0.5f;

	private RenderTexture Camera2tex;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
			Camera2.targetTexture = Camera2tex;
		}
		SCShader = Shader.Find(ShaderName);
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			if (Camera2 != null)
			{
				material.SetTexture("_MainTex2", Camera2tex);
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", BlendFX);
			material.SetFloat("_Value2", SwitchCameraToCamera2);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void OnValidate()
	{
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
			Camera2.targetTexture = Camera2tex;
		}
	}

	private void Update()
	{
	}

	private void OnEnable()
	{
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
			Camera2.targetTexture = Camera2tex;
		}
	}

	private void OnDisable()
	{
		if (Camera2 != null)
		{
			Camera2.targetTexture = null;
		}
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Blend 2 Camera/LinearBurn")]
public class CameraFilterPack_Blend2Camera_LinearBurn : MonoBehaviour
{
	private string ShaderName = "CameraFilterPack/Blend2Camera_LinearBurn";

	public Shader SCShader;

	public Camera Camera2;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	public float SwitchCameraToCamera2;

	[Range(0f, 1f)]
	public float BlendFX = 0.5f;

	private RenderTexture Camera2tex;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
			Camera2.targetTexture = Camera2tex;
		}
		SCShader = Shader.Find(ShaderName);
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			if (Camera2 != null)
			{
				material.SetTexture("_MainTex2", Camera2tex);
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", BlendFX);
			material.SetFloat("_Value2", SwitchCameraToCamera2);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void OnValidate()
	{
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
			Camera2.targetTexture = Camera2tex;
		}
	}

	private void Update()
	{
	}

	private void OnEnable()
	{
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
			Camera2.targetTexture = Camera2tex;
		}
	}

	private void OnDisable()
	{
		if (Camera2 != null)
		{
			Camera2.targetTexture = null;
		}
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Blend 2 Camera/LinearDodge")]
public class CameraFilterPack_Blend2Camera_LinearDodge : MonoBehaviour
{
	private string ShaderName = "CameraFilterPack/Blend2Camera_LinearDodge";

	public Shader SCShader;

	public Camera Camera2;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	public float SwitchCameraToCamera2;

	[Range(0f, 1f)]
	public float BlendFX = 0.5f;

	private RenderTexture Camera2tex;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
			Camera2.targetTexture = Camera2tex;
		}
		SCShader = Shader.Find(ShaderName);
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			if (Camera2 != null)
			{
				material.SetTexture("_MainTex2", Camera2tex);
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", BlendFX);
			material.SetFloat("_Value2", SwitchCameraToCamera2);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void OnValidate()
	{
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
			Camera2.targetTexture = Camera2tex;
		}
	}

	private void Update()
	{
	}

	private void OnEnable()
	{
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
			Camera2.targetTexture = Camera2tex;
		}
	}

	private void OnDisable()
	{
		if (Camera2 != null)
		{
			Camera2.targetTexture = null;
		}
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Blend 2 Camera/LinearLight")]
public class CameraFilterPack_Blend2Camera_LinearLight : MonoBehaviour
{
	private string ShaderName = "CameraFilterPack/Blend2Camera_LinearLight";

	public Shader SCShader;

	public Camera Camera2;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	public float SwitchCameraToCamera2;

	[Range(0f, 1f)]
	public float BlendFX = 0.5f;

	private RenderTexture Camera2tex;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
			Camera2.targetTexture = Camera2tex;
		}
		SCShader = Shader.Find(ShaderName);
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			if (Camera2 != null)
			{
				material.SetTexture("_MainTex2", Camera2tex);
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", BlendFX);
			material.SetFloat("_Value2", SwitchCameraToCamera2);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void OnValidate()
	{
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
			Camera2.targetTexture = Camera2tex;
		}
	}

	private void Update()
	{
	}

	private void OnEnable()
	{
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
			Camera2.targetTexture = Camera2tex;
		}
	}

	private void OnDisable()
	{
		if (Camera2 != null)
		{
			Camera2.targetTexture = null;
		}
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Blend 2 Camera/Luminosity")]
public class CameraFilterPack_Blend2Camera_Luminosity : MonoBehaviour
{
	private string ShaderName = "CameraFilterPack/Blend2Camera_Luminosity";

	public Shader SCShader;

	public Camera Camera2;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	public float SwitchCameraToCamera2;

	[Range(0f, 1f)]
	public float BlendFX = 0.5f;

	private RenderTexture Camera2tex;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
			Camera2.targetTexture = Camera2tex;
		}
		SCShader = Shader.Find(ShaderName);
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			if (Camera2 != null)
			{
				material.SetTexture("_MainTex2", Camera2tex);
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", BlendFX);
			material.SetFloat("_Value2", SwitchCameraToCamera2);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void OnValidate()
	{
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
			Camera2.targetTexture = Camera2tex;
		}
	}

	private void Update()
	{
	}

	private void OnEnable()
	{
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
			Camera2.targetTexture = Camera2tex;
		}
	}

	private void OnDisable()
	{
		if (Camera2 != null)
		{
			Camera2.targetTexture = null;
		}
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Blend 2 Camera/Multiply")]
public class CameraFilterPack_Blend2Camera_Multiply : MonoBehaviour
{
	private string ShaderName = "CameraFilterPack/Blend2Camera_Multiply";

	public Shader SCShader;

	public Camera Camera2;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	public float SwitchCameraToCamera2;

	[Range(0f, 1f)]
	public float BlendFX = 0.5f;

	private RenderTexture Camera2tex;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
			Camera2.targetTexture = Camera2tex;
		}
		SCShader = Shader.Find(ShaderName);
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			if (Camera2 != null)
			{
				material.SetTexture("_MainTex2", Camera2tex);
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", BlendFX);
			material.SetFloat("_Value2", SwitchCameraToCamera2);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void OnValidate()
	{
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
			Camera2.targetTexture = Camera2tex;
		}
	}

	private void Update()
	{
	}

	private void OnEnable()
	{
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
			Camera2.targetTexture = Camera2tex;
		}
	}

	private void OnDisable()
	{
		if (Camera2 != null)
		{
			Camera2.targetTexture = null;
		}
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Blend 2 Camera/Overlay")]
public class CameraFilterPack_Blend2Camera_Overlay : MonoBehaviour
{
	private string ShaderName = "CameraFilterPack/Blend2Camera_Overlay";

	public Shader SCShader;

	public Camera Camera2;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	public float SwitchCameraToCamera2;

	[Range(0f, 1f)]
	public float BlendFX = 0.5f;

	private RenderTexture Camera2tex;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
			Camera2.targetTexture = Camera2tex;
		}
		SCShader = Shader.Find(ShaderName);
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			if (Camera2 != null)
			{
				material.SetTexture("_MainTex2", Camera2tex);
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", BlendFX);
			material.SetFloat("_Value2", SwitchCameraToCamera2);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void OnValidate()
	{
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
			Camera2.targetTexture = Camera2tex;
		}
	}

	private void Update()
	{
	}

	private void OnEnable()
	{
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
			Camera2.targetTexture = Camera2tex;
		}
	}

	private void OnDisable()
	{
		if (Camera2 != null)
		{
			Camera2.targetTexture = null;
		}
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Blend 2 Camera/PhotoshopFilters")]
public class CameraFilterPack_Blend2Camera_PhotoshopFilters : MonoBehaviour
{
	public enum filters
	{
		Darken,
		Multiply,
		ColorBurn,
		LinearBurn,
		DarkerColor,
		Lighten,
		Screen,
		ColorDodge,
		LinearDodge,
		LighterColor,
		Overlay,
		SoftLight,
		HardLight,
		VividLight,
		LinearLight,
		PinLight,
		HardMix,
		Difference,
		Exclusion,
		Subtract,
		Divide,
		Hue,
		Saturation,
		Color,
		Luminosity
	}

	private string ShaderName = "CameraFilterPack/Blend2Camera_Darken";

	public Shader SCShader;

	public Camera Camera2;

	public filters filterchoice;

	private filters filterchoicememo;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	public float SwitchCameraToCamera2;

	[Range(0f, 1f)]
	public float BlendFX = 0.5f;

	private RenderTexture Camera2tex;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void ChangeFilters()
	{
		if (filterchoice == filters.Darken)
		{
			ShaderName = "CameraFilterPack/Blend2Camera_Darken";
		}
		if (filterchoice == filters.Multiply)
		{
			ShaderName = "CameraFilterPack/Blend2Camera_Multiply";
		}
		if (filterchoice == filters.ColorBurn)
		{
			ShaderName = "CameraFilterPack/Blend2Camera_ColorBurn";
		}
		if (filterchoice == filters.LinearBurn)
		{
			ShaderName = "CameraFilterPack/Blend2Camera_LinearBurn";
		}
		if (filterchoice == filters.DarkerColor)
		{
			ShaderName = "CameraFilterPack/Blend2Camera_DarkerColor";
		}
		if (filterchoice == filters.Lighten)
		{
			ShaderName = "CameraFilterPack/Blend2Camera_Lighten";
		}
		if (filterchoice == filters.Screen)
		{
			ShaderName = "CameraFilterPack/Blend2Camera_Screen";
		}
		if (filterchoice == filters.ColorDodge)
		{
			ShaderName = "CameraFilterPack/Blend2Camera_ColorDodge";
		}
		if (filterchoice == filters.LinearDodge)
		{
			ShaderName = "CameraFilterPack/Blend2Camera_LinearDodge";
		}
		if (filterchoice == filters.LighterColor)
		{
			ShaderName = "CameraFilterPack/Blend2Camera_LighterColor";
		}
		if (filterchoice == filters.Overlay)
		{
			ShaderName = "CameraFilterPack/Blend2Camera_Overlay";
		}
		if (filterchoice == filters.SoftLight)
		{
			ShaderName = "CameraFilterPack/Blend2Camera_SoftLight";
		}
		if (filterchoice == filters.HardLight)
		{
			ShaderName = "CameraFilterPack/Blend2Camera_HardLight";
		}
		if (filterchoice == filters.VividLight)
		{
			ShaderName = "CameraFilterPack/Blend2Camera_VividLight";
		}
		if (filterchoice == filters.LinearLight)
		{
			ShaderName = "CameraFilterPack/Blend2Camera_LinearLight";
		}
		if (filterchoice == filters.PinLight)
		{
			ShaderName = "CameraFilterPack/Blend2Camera_PinLight";
		}
		if (filterchoice == filters.HardMix)
		{
			ShaderName = "CameraFilterPack/Blend2Camera_HardMix";
		}
		if (filterchoice == filters.Difference)
		{
			ShaderName = "CameraFilterPack/Blend2Camera_Difference";
		}
		if (filterchoice == filters.Exclusion)
		{
			ShaderName = "CameraFilterPack/Blend2Camera_Exclusion";
		}
		if (filterchoice == filters.Subtract)
		{
			ShaderName = "CameraFilterPack/Blend2Camera_Subtract";
		}
		if (filterchoice == filters.Divide)
		{
			ShaderName = "CameraFilterPack/Blend2Camera_Divide";
		}
		if (filterchoice == filters.Hue)
		{
			ShaderName = "CameraFilterPack/Blend2Camera_Hue";
		}
		if (filterchoice == filters.Saturation)
		{
			ShaderName = "CameraFilterPack/Blend2Camera_Saturation";
		}
		if (filterchoice == filters.Color)
		{
			ShaderName = "CameraFilterPack/Blend2Camera_Color";
		}
		if (filterchoice == filters.Luminosity)
		{
			ShaderName = "CameraFilterPack/Blend2Camera_Luminosity";
		}
	}

	private void Start()
	{
		filterchoicememo = filterchoice;
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
			Camera2.targetTexture = Camera2tex;
		}
		ChangeFilters();
		SCShader = Shader.Find(ShaderName);
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			if (Camera2 != null)
			{
				material.SetTexture("_MainTex2", Camera2tex);
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", BlendFX);
			material.SetFloat("_Value2", SwitchCameraToCamera2);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void OnValidate()
	{
		if (filterchoice != filterchoicememo)
		{
			ChangeFilters();
			SCShader = Shader.Find(ShaderName);
			UnityEngine.Object.DestroyImmediate(SCMaterial);
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
		}
		filterchoicememo = filterchoice;
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
			Camera2.targetTexture = Camera2tex;
		}
	}

	private void Update()
	{
	}

	private void OnEnable()
	{
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
			Camera2.targetTexture = Camera2tex;
		}
	}

	private void OnDisable()
	{
		if (Camera2 != null)
		{
			Camera2.targetTexture = null;
		}
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Blend 2 Camera/PinLight")]
public class CameraFilterPack_Blend2Camera_PinLight : MonoBehaviour
{
	private string ShaderName = "CameraFilterPack/Blend2Camera_PinLight";

	public Shader SCShader;

	public Camera Camera2;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	public float SwitchCameraToCamera2;

	[Range(0f, 1f)]
	public float BlendFX = 0.5f;

	private RenderTexture Camera2tex;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
			Camera2.targetTexture = Camera2tex;
		}
		SCShader = Shader.Find(ShaderName);
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			if (Camera2 != null)
			{
				material.SetTexture("_MainTex2", Camera2tex);
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", BlendFX);
			material.SetFloat("_Value2", SwitchCameraToCamera2);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void OnValidate()
	{
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
			Camera2.targetTexture = Camera2tex;
		}
	}

	private void Update()
	{
	}

	private void OnEnable()
	{
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
			Camera2.targetTexture = Camera2tex;
		}
	}

	private void OnDisable()
	{
		if (Camera2 != null)
		{
			Camera2.targetTexture = null;
		}
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Blend 2 Camera/Saturation")]
public class CameraFilterPack_Blend2Camera_Saturation : MonoBehaviour
{
	private string ShaderName = "CameraFilterPack/Blend2Camera_Saturation";

	public Shader SCShader;

	public Camera Camera2;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	public float SwitchCameraToCamera2;

	[Range(0f, 1f)]
	public float BlendFX = 0.5f;

	private RenderTexture Camera2tex;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
			Camera2.targetTexture = Camera2tex;
		}
		SCShader = Shader.Find(ShaderName);
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			if (Camera2 != null)
			{
				material.SetTexture("_MainTex2", Camera2tex);
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", BlendFX);
			material.SetFloat("_Value2", SwitchCameraToCamera2);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void OnValidate()
	{
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
			Camera2.targetTexture = Camera2tex;
		}
	}

	private void Update()
	{
	}

	private void OnEnable()
	{
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
			Camera2.targetTexture = Camera2tex;
		}
	}

	private void OnDisable()
	{
		if (Camera2 != null)
		{
			Camera2.targetTexture = null;
		}
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Blend 2 Camera/Screen")]
public class CameraFilterPack_Blend2Camera_Screen : MonoBehaviour
{
	private string ShaderName = "CameraFilterPack/Blend2Camera_Screen";

	public Shader SCShader;

	public Camera Camera2;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	public float SwitchCameraToCamera2;

	[Range(0f, 1f)]
	public float BlendFX = 0.5f;

	private RenderTexture Camera2tex;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
			Camera2.targetTexture = Camera2tex;
		}
		SCShader = Shader.Find(ShaderName);
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			if (Camera2 != null)
			{
				material.SetTexture("_MainTex2", Camera2tex);
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", BlendFX);
			material.SetFloat("_Value2", SwitchCameraToCamera2);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void OnValidate()
	{
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
			Camera2.targetTexture = Camera2tex;
		}
	}

	private void Update()
	{
	}

	private void OnEnable()
	{
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
			Camera2.targetTexture = Camera2tex;
		}
	}

	private void OnDisable()
	{
		if (Camera2 != null)
		{
			Camera2.targetTexture = null;
		}
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Blend 2 Camera/SoftLight")]
public class CameraFilterPack_Blend2Camera_SoftLight : MonoBehaviour
{
	private string ShaderName = "CameraFilterPack/Blend2Camera_SoftLight";

	public Shader SCShader;

	public Camera Camera2;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	public float SwitchCameraToCamera2;

	[Range(0f, 1f)]
	public float BlendFX = 0.5f;

	private RenderTexture Camera2tex;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
			Camera2.targetTexture = Camera2tex;
		}
		SCShader = Shader.Find(ShaderName);
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			if (Camera2 != null)
			{
				material.SetTexture("_MainTex2", Camera2tex);
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", BlendFX);
			material.SetFloat("_Value2", SwitchCameraToCamera2);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void OnValidate()
	{
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
			Camera2.targetTexture = Camera2tex;
		}
	}

	private void Update()
	{
	}

	private void OnEnable()
	{
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
			Camera2.targetTexture = Camera2tex;
		}
	}

	private void OnDisable()
	{
		if (Camera2 != null)
		{
			Camera2.targetTexture = null;
		}
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Split Screen/SideBySide")]
public class CameraFilterPack_Blend2Camera_SplitScreen : MonoBehaviour
{
	private string ShaderName = "CameraFilterPack/Blend2Camera_SplitScreen";

	public Shader SCShader;

	public Camera Camera2;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	public float SwitchCameraToCamera2;

	[Range(0f, 1f)]
	public float BlendFX = 1f;

	[Range(-3f, 3f)]
	public float SplitX = 0.5f;

	[Range(-3f, 3f)]
	public float SplitY = 0.5f;

	[Range(0f, 2f)]
	public float Smooth = 0.1f;

	[Range(-3.14f, 3.14f)]
	public float Rotation = 3.14f;

	private bool ForceYSwap;

	private RenderTexture Camera2tex;

	private Vector2 ScreenSize;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void OnValidate()
	{
		ScreenSize.x = Screen.width;
		ScreenSize.y = Screen.height;
	}

	private void Start()
	{
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture((int)ScreenSize.x, (int)ScreenSize.y, 24);
			Camera2.targetTexture = Camera2tex;
		}
		SCShader = Shader.Find(ShaderName);
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			if (Camera2 != null)
			{
				material.SetTexture("_MainTex2", Camera2tex);
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", BlendFX);
			material.SetFloat("_Value2", SwitchCameraToCamera2);
			material.SetFloat("_Value3", SplitX);
			material.SetFloat("_Value6", SplitY);
			material.SetFloat("_Value4", Smooth);
			material.SetFloat("_Value5", Rotation);
			material.SetInt("_ForceYSwap", (!ForceYSwap) ? 1 : 0);
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
		ScreenSize.x = Screen.width;
		ScreenSize.y = Screen.height;
	}

	private void OnEnable()
	{
		Start();
	}

	private void OnDisable()
	{
		if (Camera2 != null)
		{
			Camera2.targetTexture = null;
		}
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Split Screen/Split 3D")]
public class CameraFilterPack_Blend2Camera_SplitScreen3D : MonoBehaviour
{
	private string ShaderName = "CameraFilterPack/Blend2Camera_SplitScreen3D";

	public Shader SCShader;

	public Camera Camera2;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 100f)]
	public float _FixDistance = 1f;

	[Range(-0.99f, 0.99f)]
	public float _Distance = 0.5f;

	[Range(0f, 0.5f)]
	public float _Size = 0.1f;

	[Range(0f, 1f)]
	public float SwitchCameraToCamera2;

	[Range(0f, 1f)]
	public float BlendFX = 1f;

	[Range(-3f, 3f)]
	public float SplitX = 0.5f;

	[Range(-3f, 3f)]
	public float SplitY = 0.5f;

	[Range(0f, 2f)]
	public float Smooth = 0.1f;

	[Range(-3.14f, 3.14f)]
	public float Rotation = 3.14f;

	private bool ForceYSwap;

	private RenderTexture Camera2tex;

	private Vector2 ScreenSize;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void OnValidate()
	{
		ScreenSize.x = Screen.width;
		ScreenSize.y = Screen.height;
	}

	private void Start()
	{
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture((int)ScreenSize.x, (int)ScreenSize.y, 24);
			Camera2.targetTexture = Camera2tex;
		}
		SCShader = Shader.Find(ShaderName);
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			if (Camera2 != null)
			{
				material.SetTexture("_MainTex2", Camera2tex);
			}
			material.SetFloat("_Near", _Distance);
			material.SetFloat("_Far", _Size);
			material.SetFloat("_FixDistance", _FixDistance);
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", BlendFX);
			material.SetFloat("_Value2", SwitchCameraToCamera2);
			material.SetFloat("_Value3", SplitX);
			material.SetFloat("_Value6", SplitY);
			material.SetFloat("_Value4", Smooth);
			material.SetFloat("_Value5", Rotation);
			material.SetInt("_ForceYSwap", (!ForceYSwap) ? 1 : 0);
			GetComponent<Camera>().depthTextureMode = DepthTextureMode.Depth;
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
		ScreenSize.x = Screen.width;
		ScreenSize.y = Screen.height;
	}

	private void OnEnable()
	{
		Start();
	}

	private void OnDisable()
	{
		if (Camera2 != null)
		{
			Camera2.targetTexture = null;
		}
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Blend 2 Camera/Subtract")]
public class CameraFilterPack_Blend2Camera_Subtract : MonoBehaviour
{
	private string ShaderName = "CameraFilterPack/Blend2Camera_Subtract";

	public Shader SCShader;

	public Camera Camera2;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	public float SwitchCameraToCamera2;

	[Range(0f, 1f)]
	public float BlendFX = 0.5f;

	private RenderTexture Camera2tex;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
			Camera2.targetTexture = Camera2tex;
		}
		SCShader = Shader.Find(ShaderName);
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			if (Camera2 != null)
			{
				material.SetTexture("_MainTex2", Camera2tex);
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", BlendFX);
			material.SetFloat("_Value2", SwitchCameraToCamera2);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void OnValidate()
	{
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
			Camera2.targetTexture = Camera2tex;
		}
	}

	private void Update()
	{
	}

	private void OnEnable()
	{
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
			Camera2.targetTexture = Camera2tex;
		}
	}

	private void OnDisable()
	{
		if (Camera2 != null)
		{
			Camera2.targetTexture = null;
		}
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Blend 2 Camera/VividLight")]
public class CameraFilterPack_Blend2Camera_VividLight : MonoBehaviour
{
	private string ShaderName = "CameraFilterPack/Blend2Camera_VividLight";

	public Shader SCShader;

	public Camera Camera2;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	public float SwitchCameraToCamera2;

	[Range(0f, 1f)]
	public float BlendFX = 0.5f;

	private RenderTexture Camera2tex;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
			Camera2.targetTexture = Camera2tex;
		}
		SCShader = Shader.Find(ShaderName);
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			if (Camera2 != null)
			{
				material.SetTexture("_MainTex2", Camera2tex);
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", BlendFX);
			material.SetFloat("_Value2", SwitchCameraToCamera2);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void OnValidate()
	{
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
			Camera2.targetTexture = Camera2tex;
		}
	}

	private void Update()
	{
	}

	private void OnEnable()
	{
		if (Camera2 != null)
		{
			Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
			Camera2.targetTexture = Camera2tex;
		}
	}

	private void OnDisable()
	{
		if (Camera2 != null)
		{
			Camera2.targetTexture = null;
		}
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Weather/Blizzard")]
public class CameraFilterPack_Blizzard : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	[Range(0f, 2f)]
	public float _Speed = 1f;

	[Range(0.2f, 2f)]
	public float _Size = 1f;

	[Range(0f, 1f)]
	public float _Fade = 1f;

	private Material SCMaterial;

	private Texture2D Texture2;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		Texture2 = Resources.Load("CameraFilterPack_Blizzard1") as Texture2D;
		SCShader = Shader.Find("CameraFilterPack/Blizzard");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", _Speed);
			material.SetFloat("_Value2", _Size);
			material.SetFloat("_Value3", _Fade);
			material.SetTexture("_MainTex2", Texture2);
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Blur/Bloom")]
public class CameraFilterPack_Blur_Bloom : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 10f)]
	public float Amount = 4.5f;

	[Range(0f, 1f)]
	public float Glow = 0.5f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Blur_Bloom");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Amount", Amount);
			material.SetFloat("_Glow", Glow);
			material.SetVector("_ScreenResolution", new Vector2(Screen.width, Screen.height));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Blur/Blur Hole")]
public class CameraFilterPack_Blur_BlurHole : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	[Range(1f, 16f)]
	public float Size = 10f;

	[Range(-1f, 1f)]
	public float _Radius = 0.25f;

	[Range(-4f, 4f)]
	public float _SpotSize = 1f;

	[Range(0f, 1f)]
	public float _CenterX = 0.5f;

	[Range(0f, 1f)]
	public float _CenterY = 0.5f;

	[Range(0f, 1f)]
	public float _AlphaBlur = 1f;

	[Range(0f, 1f)]
	public float _AlphaBlurInside;

	private Material SCMaterial;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/BlurHole");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Distortion", Size);
			material.SetFloat("_Radius", _Radius);
			material.SetFloat("_SpotSize", _SpotSize);
			material.SetFloat("_CenterX", _CenterX);
			material.SetFloat("_CenterY", _CenterY);
			material.SetFloat("_Alpha", _AlphaBlur);
			material.SetFloat("_Alpha2", _AlphaBlurInside);
			material.SetVector("_ScreenResolution", new Vector2(Screen.width, Screen.height));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Blur/Blurry")]
public class CameraFilterPack_Blur_Blurry : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 20f)]
	public float Amount = 2f;

	[Range(1f, 8f)]
	public int FastFilter = 2;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Blur_Blurry");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			int fastFilter = FastFilter;
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Amount", Amount);
			material.SetVector("_ScreenResolution", new Vector2(Screen.width / fastFilter, Screen.height / fastFilter));
			int width = sourceTexture.width / fastFilter;
			int height = sourceTexture.height / fastFilter;
			if (FastFilter > 1)
			{
				RenderTexture temporary = RenderTexture.GetTemporary(width, height, 0);
				temporary.filterMode = FilterMode.Trilinear;
				Graphics.Blit(sourceTexture, temporary, material);
				Graphics.Blit(temporary, destTexture);
				RenderTexture.ReleaseTemporary(temporary);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture, material);
			}
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Blur/DitherOffset")]
public class CameraFilterPack_Blur_DitherOffset : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(1f, 16f)]
	public int Level = 4;

	public Vector2 Distance = new Vector2(30f, 0f);

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Blur_DitherOffset");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Level", Level);
			material.SetVector("_Distance", Distance);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Blur/Dithering2x2")]
public class CameraFilterPack_Blur_Dithering2x2 : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(2f, 16f)]
	public int Level = 4;

	public Vector2 Distance = new Vector2(30f, 0f);

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Blur_Dithering2x2");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Level", Level);
			material.SetVector("_Distance", Distance);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Blur/Focus")]
public class CameraFilterPack_Blur_Focus : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(-1f, 1f)]
	public float CenterX;

	[Range(-1f, 1f)]
	public float CenterY;

	[Range(0f, 10f)]
	public float _Size = 5f;

	[Range(0.12f, 64f)]
	public float _Eyes = 2f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Blur_Focus");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_CenterX", CenterX);
			material.SetFloat("_CenterY", CenterY);
			float value = Mathf.Round(_Size / 0.2f) * 0.2f;
			material.SetFloat("_Size", value);
			material.SetFloat("_Circle", _Eyes);
			material.SetVector("_ScreenResolution", new Vector2(Screen.width, Screen.height));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Blur/GaussianBlur")]
public class CameraFilterPack_Blur_GaussianBlur : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	[Range(1f, 16f)]
	public float Size = 10f;

	private Material SCMaterial;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Blur_GaussianBlur");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Distortion", Size);
			material.SetVector("_ScreenResolution", new Vector2(Screen.width, Screen.height));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Blur/Movie")]
public class CameraFilterPack_Blur_Movie : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1000f)]
	public float Radius = 150f;

	[Range(0f, 1000f)]
	public float Factor = 200f;

	[Range(1f, 8f)]
	public int FastFilter = 2;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Blur_Movie");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			int fastFilter = FastFilter;
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Radius", Radius / (float)fastFilter);
			material.SetFloat("_Factor", Factor);
			material.SetVector("_ScreenResolution", new Vector2(Screen.width / fastFilter, Screen.height / fastFilter));
			int width = sourceTexture.width / fastFilter;
			int height = sourceTexture.height / fastFilter;
			if (FastFilter > 1)
			{
				RenderTexture temporary = RenderTexture.GetTemporary(width, height, 0);
				Graphics.Blit(sourceTexture, temporary, material);
				Graphics.Blit(temporary, destTexture);
				RenderTexture.ReleaseTemporary(temporary);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture, material);
			}
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Blur/Noise")]
public class CameraFilterPack_Blur_Noise : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(2f, 16f)]
	public int Level = 4;

	public Vector2 Distance = new Vector2(30f, 0f);

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Blur_Noise");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Level", Level);
			material.SetVector("_Distance", Distance);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Blur/Radial")]
public class CameraFilterPack_Blur_Radial : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(-0.5f, 0.5f)]
	public float Intensity = 0.125f;

	[Range(-2f, 2f)]
	public float MovX = 0.5f;

	[Range(-2f, 2f)]
	public float MovY = 0.5f;

	[Range(0f, 10f)]
	private float blurWidth = 1f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Blur_Radial");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", Intensity);
			material.SetFloat("_Value2", MovX);
			material.SetFloat("_Value3", MovY);
			material.SetFloat("_Value4", blurWidth);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Blur/Radial_Fast")]
public class CameraFilterPack_Blur_Radial_Fast : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(-0.5f, 0.5f)]
	public float Intensity = 0.125f;

	[Range(-2f, 2f)]
	public float MovX = 0.5f;

	[Range(-2f, 2f)]
	public float MovY = 0.5f;

	[Range(0f, 10f)]
	private float blurWidth = 1f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Blur_Radial_Fast");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", Intensity);
			material.SetFloat("_Value2", MovX);
			material.SetFloat("_Value3", MovY);
			material.SetFloat("_Value4", blurWidth);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Blur/Regular")]
public class CameraFilterPack_Blur_Regular : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(1f, 16f)]
	public int Level = 4;

	public Vector2 Distance = new Vector2(30f, 0f);

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Blur_Regular");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Level", Level);
			material.SetVector("_Distance", Distance);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Blur/Steam")]
public class CameraFilterPack_Blur_Steam : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	public float Radius = 0.1f;

	[Range(0f, 1f)]
	public float Quality = 0.75f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Blur_Steam");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Radius", Radius);
			material.SetFloat("_Quality", Quality);
			material.SetVector("_ScreenResolution", new Vector2(Screen.width, Screen.height));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Blur/Tilt_Shift")]
public class CameraFilterPack_Blur_Tilt_Shift : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 20f)]
	public float Amount = 3f;

	[Range(2f, 16f)]
	public int FastFilter = 8;

	[Range(0f, 1f)]
	public float Smooth = 0.5f;

	[Range(0f, 1f)]
	public float Size = 0.5f;

	[Range(-1f, 1f)]
	public float Position = 0.5f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/BlurTiltShift");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			int fastFilter = FastFilter;
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Amount", Amount);
			material.SetFloat("_Value1", Smooth);
			material.SetFloat("_Value2", Size);
			material.SetFloat("_Value3", Position);
			material.SetVector("_ScreenResolution", new Vector2(Screen.width / fastFilter, Screen.height / fastFilter));
			int width = sourceTexture.width / fastFilter;
			int height = sourceTexture.height / fastFilter;
			if (FastFilter > 1)
			{
				RenderTexture temporary = RenderTexture.GetTemporary(width, height, 0);
				RenderTexture temporary2 = RenderTexture.GetTemporary(width, height, 0);
				temporary.filterMode = FilterMode.Trilinear;
				Graphics.Blit(sourceTexture, temporary, material, 2);
				Graphics.Blit(temporary, temporary2, material, 0);
				material.SetFloat("_Amount", Amount * 2f);
				Graphics.Blit(temporary2, temporary, material, 2);
				Graphics.Blit(temporary, temporary2, material, 0);
				material.SetTexture("_MainTex2", temporary2);
				RenderTexture.ReleaseTemporary(temporary);
				RenderTexture.ReleaseTemporary(temporary2);
				Graphics.Blit(sourceTexture, destTexture, material, 1);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture, material, 0);
			}
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Blur/Tilt_Shift_Hole")]
public class CameraFilterPack_Blur_Tilt_Shift_Hole : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 20f)]
	public float Amount = 3f;

	[Range(2f, 16f)]
	public int FastFilter = 8;

	[Range(0f, 1f)]
	public float Smooth = 0.5f;

	[Range(0f, 1f)]
	public float Size = 0.2f;

	[Range(-1f, 1f)]
	public float PositionX = 0.5f;

	[Range(-1f, 1f)]
	public float PositionY = 0.5f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/BlurTiltShift_Hole");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			int fastFilter = FastFilter;
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Amount", Amount);
			material.SetFloat("_Value1", Smooth);
			material.SetFloat("_Value2", Size);
			material.SetFloat("_Value3", PositionX);
			material.SetFloat("_Value4", PositionY);
			int width = sourceTexture.width / fastFilter;
			int height = sourceTexture.height / fastFilter;
			if (FastFilter > 1)
			{
				RenderTexture temporary = RenderTexture.GetTemporary(width, height, 0);
				RenderTexture temporary2 = RenderTexture.GetTemporary(width, height, 0);
				temporary.filterMode = FilterMode.Trilinear;
				Graphics.Blit(sourceTexture, temporary, material, 2);
				Graphics.Blit(temporary, temporary2, material, 0);
				material.SetFloat("_Amount", Amount * 2f);
				Graphics.Blit(temporary2, temporary, material, 2);
				Graphics.Blit(temporary, temporary2, material, 0);
				material.SetTexture("_MainTex2", temporary2);
				RenderTexture.ReleaseTemporary(temporary);
				RenderTexture.ReleaseTemporary(temporary2);
				Graphics.Blit(sourceTexture, destTexture, material, 1);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture, material, 0);
			}
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Blur/Tilt_Shift_V")]
public class CameraFilterPack_Blur_Tilt_Shift_V : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 20f)]
	public float Amount = 3f;

	[Range(2f, 16f)]
	public int FastFilter = 8;

	[Range(0f, 1f)]
	public float Smooth = 0.5f;

	[Range(0f, 1f)]
	public float Size = 0.5f;

	[Range(-1f, 1f)]
	public float Position = 0.5f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/BlurTiltShift_V");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			int fastFilter = FastFilter;
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Amount", Amount);
			material.SetFloat("_Value1", Smooth);
			material.SetFloat("_Value2", Size);
			material.SetFloat("_Value3", Position);
			int width = sourceTexture.width / fastFilter;
			int height = sourceTexture.height / fastFilter;
			if (FastFilter > 1)
			{
				RenderTexture temporary = RenderTexture.GetTemporary(width, height, 0);
				RenderTexture temporary2 = RenderTexture.GetTemporary(width, height, 0);
				temporary.filterMode = FilterMode.Trilinear;
				Graphics.Blit(sourceTexture, temporary, material, 2);
				Graphics.Blit(temporary, temporary2, material, 0);
				material.SetFloat("_Amount", Amount * 2f);
				Graphics.Blit(temporary2, temporary, material, 2);
				Graphics.Blit(temporary, temporary2, material, 0);
				material.SetTexture("_MainTex2", temporary2);
				RenderTexture.ReleaseTemporary(temporary);
				RenderTexture.ReleaseTemporary(temporary2);
				Graphics.Blit(sourceTexture, destTexture, material, 1);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture, material, 0);
			}
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Broken/Broken_Screen")]
public class CameraFilterPack_Broken_Screen : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	[Range(0f, 1f)]
	public float Fade = 1f;

	[Range(-1f, 1f)]
	public float Shadow = 1f;

	private Material SCMaterial;

	private Texture2D Texture2;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		Texture2 = Resources.Load("CameraFilterPack_Broken_Screen1") as Texture2D;
		SCShader = Shader.Find("CameraFilterPack/Broken_Screen");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Fade", Fade);
			material.SetFloat("_Shadow", Shadow);
			material.SetTexture("_MainTex2", Texture2);
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Broken/Simple")]
public class CameraFilterPack_Broken_Simple : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	public float __Speed = 1f;

	[Range(0f, 1f)]
	public float _Broke1 = 1f;

	[Range(0f, 1f)]
	public float _Broke2 = 1f;

	[Range(0f, 1f)]
	public float _PosX = 0.5f;

	[Range(0f, 1f)]
	public float _PosY = 0.5f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/CameraFilterPack_Broken_Simple");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Speed", __Speed);
			material.SetFloat("Broke1", _Broke1);
			material.SetFloat("Broke2", _Broke2);
			material.SetFloat("PosX", _PosX);
			material.SetFloat("PosY", _PosY);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Broken/Spliter")]
public class CameraFilterPack_Broken_Spliter : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	private float __Speed = 1f;

	[Range(0f, 1f)]
	public float _PosX = 0.5f;

	[Range(0f, 1f)]
	public float _PosY = 0.5f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/CameraFilterPack_Broken_Spliter");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Speed", __Speed);
			material.SetFloat("PosX", _PosX);
			material.SetFloat("PosY", _PosY);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Classic/ThermalVision")]
public class CameraFilterPack_Classic_ThermalVision : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	public float __Speed = 1f;

	[Range(0f, 1f)]
	public float _Fade = 1f;

	[Range(0f, 1f)]
	public float _Crt = 1f;

	[Range(0f, 1f)]
	public float _Curve = 1f;

	[Range(0f, 1f)]
	public float _Color1 = 1f;

	[Range(0f, 1f)]
	public float _Color2 = 1f;

	[Range(0f, 1f)]
	public float _Color3 = 1f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/CameraFilterPack_Classic_ThermalVision");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Speed", __Speed);
			material.SetFloat("Fade", _Fade);
			material.SetFloat("Crt", _Crt);
			material.SetFloat("Curve", _Curve);
			material.SetFloat("Color1", _Color1);
			material.SetFloat("Color2", _Color2);
			material.SetFloat("Color3", _Color3);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Colors/Levels")]
public class CameraFilterPack_Color_Adjust_Levels : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	public float levelMinimum;

	[Range(0f, 1f)]
	public float levelMiddle = 0.5f;

	[Range(0f, 1f)]
	public float levelMaximum = 1f;

	[Range(0f, 1f)]
	public float minOutput;

	[Range(0f, 1f)]
	public float maxOutput = 1f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Color_Levels");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("levelMinimum", levelMinimum);
			material.SetFloat("levelMiddle", levelMiddle);
			material.SetFloat("levelMaximum", levelMaximum);
			material.SetFloat("minOutput", minOutput);
			material.SetFloat("maxOutput", maxOutput);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Colors/BrightContrastSaturation")]
public class CameraFilterPack_Color_BrightContrastSaturation : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 10f)]
	public float Brightness = 2f;

	[Range(0f, 10f)]
	public float Saturation = 1.5f;

	[Range(0f, 10f)]
	public float Contrast = 1.5f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Color_BrightContrastSaturation");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_Brightness", Brightness);
			material.SetFloat("_Saturation", Saturation);
			material.SetFloat("_Contrast", Contrast);
			material.SetFloat("_TimeX", TimeX);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Colors/Chromatic_Aberration")]
public class CameraFilterPack_Color_Chromatic_Aberration : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(-0.02f, 0.02f)]
	public float Offset = 0.02f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Color_Chromatic_Aberration");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Distortion", Offset);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Colors/Chromatic_Plus")]
public class CameraFilterPack_Color_Chromatic_Plus : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 0.8f)]
	public float Size = 0.55f;

	[Range(0.01f, 0.4f)]
	public float Smooth = 0.26f;

	[Range(-0.02f, 0.02f)]
	public float Offset = 0.005f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Color_Chromatic_Plus");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", Size);
			material.SetFloat("_Value2", Smooth);
			material.SetFloat("_Distortion", Offset);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Colors/Contrast")]
public class CameraFilterPack_Color_Contrast : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 10f)]
	public float Contrast = 4.5f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Color_Contrast");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_Contrast", Contrast);
			material.SetFloat("_TimeX", TimeX);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Colors/GrayScale")]
public class CameraFilterPack_Color_GrayScale : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	[Range(0f, 1f)]
	public float _Fade = 1f;

	private Material SCMaterial;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Color_GrayScale");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Fade", _Fade);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Colors/Invert")]
public class CameraFilterPack_Color_Invert : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	[Range(0f, 1f)]
	public float _Fade = 1f;

	private Material SCMaterial;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Color_Invert");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Fade", _Fade);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Colors/Noise")]
public class CameraFilterPack_Color_Noise : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	public float Noise = 0.235f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Color_Noise");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Noise", Noise);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Colors/RGB")]
public class CameraFilterPack_Color_RGB : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	public Color ColorRGB = new Color(1f, 1f, 1f);

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Color_RGB");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetColor("_ColorRGB", ColorRGB);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Colors/Sepia")]
public class CameraFilterPack_Color_Sepia : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	[Range(0f, 1f)]
	public float _Fade = 1f;

	private Material SCMaterial;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Color_Sepia");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Fade", _Fade);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Colors/Switching")]
public class CameraFilterPack_Color_Switching : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 5f)]
	public int Color = 1;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Color_Switching");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Distortion", Color);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Colors/Color_YUV")]
public class CameraFilterPack_Color_YUV : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(-1f, 1f)]
	public float _Y;

	[Range(-1f, 1f)]
	public float _U;

	[Range(-1f, 1f)]
	public float _V;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Color_YUV");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Y", _Y);
			material.SetFloat("_U", _U);
			material.SetFloat("_V", _V);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/ColorsAdjust/ColorRGB")]
public class CameraFilterPack_Colors_Adjust_ColorRGB : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(-2f, 2f)]
	public float Red;

	[Range(-2f, 2f)]
	public float Green;

	[Range(-2f, 2f)]
	public float Blue;

	[Range(-1f, 1f)]
	public float Brightness;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Colors_Adjust_ColorRGB");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", Red);
			material.SetFloat("_Value2", Green);
			material.SetFloat("_Value3", Blue);
			material.SetFloat("_Value4", Brightness);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/ColorsAdjust/FullColors")]
public class CameraFilterPack_Colors_Adjust_FullColors : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(-200f, 200f)]
	public float Red_R = 100f;

	[Range(-200f, 200f)]
	public float Red_G;

	[Range(-200f, 200f)]
	public float Red_B;

	[Range(-200f, 200f)]
	public float Red_Constant;

	[Range(-200f, 200f)]
	public float Green_R;

	[Range(-200f, 200f)]
	public float Green_G = 100f;

	[Range(-200f, 200f)]
	public float Green_B;

	[Range(-200f, 200f)]
	public float Green_Constant;

	[Range(-200f, 200f)]
	public float Blue_R;

	[Range(-200f, 200f)]
	public float Blue_G;

	[Range(-200f, 200f)]
	public float Blue_B = 100f;

	[Range(-200f, 200f)]
	public float Blue_Constant;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Colors_Adjust_FullColors");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Red_R", Red_R / 100f);
			material.SetFloat("_Red_G", Red_G / 100f);
			material.SetFloat("_Red_B", Red_B / 100f);
			material.SetFloat("_Green_R", Green_R / 100f);
			material.SetFloat("_Green_G", Green_G / 100f);
			material.SetFloat("_Green_B", Green_B / 100f);
			material.SetFloat("_Blue_R", Blue_R / 100f);
			material.SetFloat("_Blue_G", Blue_G / 100f);
			material.SetFloat("_Blue_B", Blue_B / 100f);
			material.SetFloat("_Red_C", Red_Constant / 100f);
			material.SetFloat("_Green_C", Green_Constant / 100f);
			material.SetFloat("_Blue_C", Blue_Constant / 100f);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
		_ = Application.isPlaying;
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/ColorsAdjust/Photo Filters")]
public class CameraFilterPack_Colors_Adjust_PreFilters : MonoBehaviour
{
	public enum filters
	{
		Normal,
		BlueLagoon,
		BlueMoon,
		RedWhite,
		NashVille,
		VintageYellow,
		GoldenPink,
		DarkPink,
		PopRocket,
		RedSoftLight,
		YellowSunSet,
		Walden,
		WhiteShine,
		Fluo,
		MarsSunRise,
		Amelie,
		BlueJeans,
		NightVision,
		BlueParadise,
		Blindness_Deuteranomaly,
		Blindness_Protanopia,
		Blindness_Protanomaly,
		Blindness_Deuteranopia,
		Blindness_Tritanomaly,
		Blindness_Achromatopsia,
		Blindness_Achromatomaly,
		Blindness_Tritanopia,
		BlackAndWhite_Blue,
		BlackAndWhite_Green,
		BlackAndWhite_Orange,
		BlackAndWhite_Red,
		BlackAndWhite_Yellow
	}

	private string ShaderName = "CameraFilterPack/Colors_Adjust_PreFilters";

	public Shader SCShader;

	public filters filterchoice;

	[Range(0f, 1f)]
	public float FadeFX = 1f;

	private float TimeX = 1f;

	private Material SCMaterial;

	private float[] Matrix9;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void ChangeFilters()
	{
		if (filterchoice == filters.Normal)
		{
			Matrix9 = new float[12]
			{
				100f, 0f, 0f, 0f, 100f, 0f, 0f, 0f, 100f, 0f,
				0f, 0f
			};
		}
		if (filterchoice == filters.Blindness_Deuteranomaly)
		{
			Matrix9 = new float[12]
			{
				80f, 20f, 0f, 25.833f, 74.167f, 0f, 0f, 14.167f, 85.833f, 0f,
				0f, 0f
			};
		}
		if (filterchoice == filters.Blindness_Protanopia)
		{
			Matrix9 = new float[12]
			{
				56.667f, 43.333f, 0f, 55.833f, 44.167f, 0f, 0f, 24.167f, 75.833f, 0f,
				0f, 0f
			};
		}
		if (filterchoice == filters.Blindness_Protanomaly)
		{
			Matrix9 = new float[12]
			{
				81.667f, 18.333f, 0f, 33.333f, 66.667f, 0f, 0f, 12.5f, 87.5f, 0f,
				0f, 0f
			};
		}
		if (filterchoice == filters.Blindness_Deuteranopia)
		{
			Matrix9 = new float[12]
			{
				62.5f, 37.5f, 0f, 70f, 30f, 0f, 0f, 30f, 70f, 0f,
				0f, 0f
			};
		}
		if (filterchoice == filters.Blindness_Tritanomaly)
		{
			Matrix9 = new float[12]
			{
				96.667f, 3.333f, 0f, 0f, 73.333f, 26.667f, 0f, 18.333f, 81.667f, 0f,
				0f, 0f
			};
		}
		if (filterchoice == filters.Blindness_Achromatopsia)
		{
			Matrix9 = new float[12]
			{
				29.9f, 58.7f, 11.4f, 29.9f, 58.7f, 11.4f, 29.9f, 58.7f, 11.4f, 0f,
				0f, 0f
			};
		}
		if (filterchoice == filters.Blindness_Achromatomaly)
		{
			Matrix9 = new float[12]
			{
				61.8f, 32f, 6.2f, 16.3f, 77.5f, 6.2f, 16.3f, 32f, 51.6f, 0f,
				0f, 0f
			};
		}
		if (filterchoice == filters.Blindness_Tritanopia)
		{
			Matrix9 = new float[12]
			{
				95f, 5f, 0f, 0f, 43.333f, 56.667f, 0f, 47.5f, 52.5f, 0f,
				0f, 0f
			};
		}
		if (filterchoice == filters.BlueLagoon)
		{
			Matrix9 = new float[12]
			{
				100f, 102f, 0f, 18f, 100f, 4f, 28f, -26f, 100f, -64f,
				0f, 12f
			};
		}
		if (filterchoice == filters.GoldenPink)
		{
			Matrix9 = new float[12]
			{
				70f, 200f, 0f, 0f, 100f, 8f, 6f, 12f, 110f, 0f,
				0f, -6f
			};
		}
		if (filterchoice == filters.BlueMoon)
		{
			Matrix9 = new float[12]
			{
				200f, 98f, -116f, 24f, 100f, 2f, 30f, 52f, 20f, -48f,
				-20f, 12f
			};
		}
		if (filterchoice == filters.DarkPink)
		{
			Matrix9 = new float[12]
			{
				60f, 112f, 36f, 24f, 100f, 2f, 0f, -26f, 100f, -56f,
				-20f, 12f
			};
		}
		if (filterchoice == filters.RedWhite)
		{
			Matrix9 = new float[12]
			{
				-42f, 68f, 108f, -96f, 100f, 116f, -92f, 104f, 96f, 0f,
				2f, 4f
			};
		}
		if (filterchoice == filters.VintageYellow)
		{
			Matrix9 = new float[12]
			{
				200f, 109f, -104f, 42f, 126f, -1f, -40f, 121f, -31f, -48f,
				-20f, 12f
			};
		}
		if (filterchoice == filters.NashVille)
		{
			Matrix9 = new float[12]
			{
				130f, 8f, 7f, 19f, 89f, 3f, -1f, 11f, 57f, 10f,
				19f, 47f
			};
		}
		if (filterchoice == filters.PopRocket)
		{
			Matrix9 = new float[12]
			{
				100f, 6f, -17f, 0f, 107f, 0f, 10f, 21f, 100f, 40f,
				0f, 8f
			};
		}
		if (filterchoice == filters.RedSoftLight)
		{
			Matrix9 = new float[12]
			{
				-4f, 200f, -30f, -58f, 200f, -30f, -58f, 200f, -30f, -11f,
				0f, 0f
			};
		}
		if (filterchoice == filters.BlackAndWhite_Blue)
		{
			Matrix9 = new float[12]
			{
				0f, 0f, 100f, 0f, 0f, 100f, 0f, 0f, 100f, 0f,
				0f, 0f
			};
		}
		if (filterchoice == filters.BlackAndWhite_Green)
		{
			Matrix9 = new float[12]
			{
				0f, 100f, 0f, 0f, 100f, 0f, 0f, 100f, 0f, 0f,
				0f, 0f
			};
		}
		if (filterchoice == filters.BlackAndWhite_Orange)
		{
			Matrix9 = new float[12]
			{
				50f, 50f, 0f, 50f, 50f, 0f, 50f, 50f, 0f, 0f,
				0f, 0f
			};
		}
		if (filterchoice == filters.BlackAndWhite_Red)
		{
			Matrix9 = new float[12]
			{
				100f, 0f, 0f, 100f, 0f, 0f, 100f, 0f, 0f, 0f,
				0f, 0f
			};
		}
		if (filterchoice == filters.BlackAndWhite_Yellow)
		{
			Matrix9 = new float[12]
			{
				34f, 66f, 0f, 34f, 66f, 0f, 34f, 66f, 0f, 0f,
				0f, 0f
			};
		}
		if (filterchoice == filters.YellowSunSet)
		{
			Matrix9 = new float[12]
			{
				117f, -6f, 53f, -68f, 135f, 19f, -146f, -61f, 200f, 0f,
				0f, 0f
			};
		}
		if (filterchoice == filters.Walden)
		{
			Matrix9 = new float[12]
			{
				99f, 2f, 13f, 100f, 1f, 40f, 50f, 8f, 71f, 0f,
				2f, 7f
			};
		}
		if (filterchoice == filters.WhiteShine)
		{
			Matrix9 = new float[12]
			{
				190f, 24f, -33f, 2f, 200f, -6f, -10f, 27f, 200f, -6f,
				-13f, 15f
			};
		}
		if (filterchoice == filters.Fluo)
		{
			Matrix9 = new float[12]
			{
				100f, 0f, 0f, 0f, 113f, 0f, 200f, -200f, -200f, 0f,
				0f, 36f
			};
		}
		if (filterchoice == filters.MarsSunRise)
		{
			Matrix9 = new float[12]
			{
				50f, 141f, -81f, -17f, 62f, 29f, -159f, -137f, -200f, 7f,
				-34f, -6f
			};
		}
		if (filterchoice == filters.Amelie)
		{
			Matrix9 = new float[12]
			{
				100f, 11f, 39f, 1f, 63f, 53f, -24f, 71f, 20f, -25f,
				-10f, -24f
			};
		}
		if (filterchoice == filters.BlueJeans)
		{
			Matrix9 = new float[12]
			{
				181f, 11f, 15f, 40f, 40f, 20f, 40f, 40f, 20f, -59f,
				0f, 0f
			};
		}
		if (filterchoice == filters.NightVision)
		{
			Matrix9 = new float[12]
			{
				200f, -200f, -200f, 195f, 4f, -160f, 200f, -200f, -200f, -200f,
				10f, -200f
			};
		}
		if (filterchoice == filters.BlueParadise)
		{
			Matrix9 = new float[12]
			{
				66f, 200f, -200f, 25f, 38f, 36f, 30f, 150f, 114f, 17f,
				0f, 65f
			};
		}
	}

	private void Start()
	{
		ChangeFilters();
		SCShader = Shader.Find(ShaderName);
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Red_R", Matrix9[0] / 100f);
			material.SetFloat("_Red_G", Matrix9[1] / 100f);
			material.SetFloat("_Red_B", Matrix9[2] / 100f);
			material.SetFloat("_Green_R", Matrix9[3] / 100f);
			material.SetFloat("_Green_G", Matrix9[4] / 100f);
			material.SetFloat("_Green_B", Matrix9[5] / 100f);
			material.SetFloat("_Blue_R", Matrix9[6] / 100f);
			material.SetFloat("_Blue_G", Matrix9[7] / 100f);
			material.SetFloat("_Blue_B", Matrix9[8] / 100f);
			material.SetFloat("_Red_C", Matrix9[9] / 100f);
			material.SetFloat("_Green_C", Matrix9[10] / 100f);
			material.SetFloat("_Blue_C", Matrix9[11] / 100f);
			material.SetFloat("_FadeFX", FadeFX);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void OnValidate()
	{
		ChangeFilters();
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Colors/BleachBypass")]
public class CameraFilterPack_Colors_BleachBypass : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(-1f, 2f)]
	public float Value = 1f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Colors_BleachBypass");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", Value);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Colors/Brightness")]
public class CameraFilterPack_Colors_Brightness : MonoBehaviour
{
	public Shader SCShader;

	[Range(0f, 2f)]
	public float _Brightness = 1.5f;

	private Material SCMaterial;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Colors_Brightness");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			material.SetFloat("_Val", _Brightness);
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Colors/DarkColor")]
public class CameraFilterPack_Colors_DarkColor : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(-5f, 5f)]
	public float Alpha = 1f;

	[Range(0f, 16f)]
	private float Colors = 11f;

	[Range(-1f, 1f)]
	private float Green_Mod = 1f;

	[Range(0f, 10f)]
	private float Value4 = 1f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Colors_DarkColor");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", Alpha);
			material.SetFloat("_Value2", Colors);
			material.SetFloat("_Value3", Green_Mod);
			material.SetFloat("_Value4", Value4);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Colors/HSV")]
public class CameraFilterPack_Colors_HSV : MonoBehaviour
{
	public Shader SCShader;

	[Range(0f, 360f)]
	public float _HueShift = 180f;

	[Range(-32f, 32f)]
	public float _Saturation = 1f;

	[Range(-32f, 32f)]
	public float _ValueBrightness = 1f;

	private Material SCMaterial;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			material.SetFloat("_HueShift", _HueShift);
			material.SetFloat("_Sat", _Saturation);
			material.SetFloat("_Val", _ValueBrightness);
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Colors/HUE_Rotate")]
public class CameraFilterPack_Colors_HUE_Rotate : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(1f, 20f)]
	public float Speed = 10f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Colors_HUE_Rotate");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Speed", Speed);
			material.SetVector("_ScreenResolution", new Vector2(Screen.width, Screen.height));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Colors/NewPosterize")]
public class CameraFilterPack_Colors_NewPosterize : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 2f)]
	public float Gamma = 1f;

	[Range(0f, 16f)]
	public float Colors = 11f;

	[Range(-1f, 1f)]
	public float Green_Mod = 1f;

	[Range(0f, 10f)]
	private float Value4 = 1f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Colors_NewPosterize");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", Gamma);
			material.SetFloat("_Value2", Colors);
			material.SetFloat("_Value3", Green_Mod);
			material.SetFloat("_Value4", Value4);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Colors/RgbClamp")]
public class CameraFilterPack_Colors_RgbClamp : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	public float Red_Start;

	[Range(0f, 1f)]
	public float Red_End = 1f;

	[Range(0f, 1f)]
	public float Green_Start;

	[Range(0f, 1f)]
	public float Green_End = 1f;

	[Range(0f, 1f)]
	public float Blue_Start;

	[Range(0f, 1f)]
	public float Blue_End = 1f;

	[Range(0f, 1f)]
	public float RGB_Start;

	[Range(0f, 1f)]
	public float RGB_End = 1f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Colors_RgbClamp");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", Red_Start);
			material.SetFloat("_Value2", Red_End);
			material.SetFloat("_Value3", Green_Start);
			material.SetFloat("_Value4", Green_End);
			material.SetFloat("_Value5", Blue_Start);
			material.SetFloat("_Value6", Blue_End);
			material.SetFloat("_Value7", RGB_Start);
			material.SetFloat("_Value8", RGB_End);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Colors/Threshold")]
public class CameraFilterPack_Colors_Threshold : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	[Range(0f, 1f)]
	public float Threshold = 0.3f;

	private Material SCMaterial;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Colors_Threshold");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Distortion", Threshold);
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Convert/NormalMap")]
public class CameraFilterPack_Convert_Normal : MonoBehaviour
{
	public Shader SCShader;

	[Range(0f, 0.5f)]
	public float _Heigh = 0.0125f;

	[Range(0f, 0.25f)]
	public float _Intervale = 0.0025f;

	private Material SCMaterial;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Color_Convert_Normal");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			material.SetFloat("_Heigh", _Heigh);
			material.SetFloat("_Intervale", _Intervale);
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Distortion/Aspiration")]
public class CameraFilterPack_Distortion_Aspiration : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	public float Value = 0.8f;

	[Range(-1f, 1f)]
	public float PosX = 0.5f;

	[Range(-1f, 1f)]
	public float PosY = 0.5f;

	[Range(0f, 10f)]
	private float Value4 = 1f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Distortion_Aspiration");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", 1f - Value);
			material.SetFloat("_Value2", PosX);
			material.SetFloat("_Value3", PosY);
			material.SetFloat("_Value4", Value4);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Distortion/BigFace")]
public class CameraFilterPack_Distortion_BigFace : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 6.5f;

	private Material SCMaterial;

	public float _Size = 5f;

	[Range(2f, 10f)]
	public float Distortion = 2.5f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Distortion_BigFace");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Distortion", Distortion);
			material.SetFloat("_Size", _Size);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Distortion/BlackHole")]
public class CameraFilterPack_Distortion_BlackHole : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(-1f, 1f)]
	public float PositionX;

	[Range(-1f, 1f)]
	public float PositionY;

	[Range(-5f, 5f)]
	public float Size = 0.05f;

	[Range(0f, 180f)]
	public float Distortion = 30f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Distortion_BlackHole");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_PositionX", PositionX);
			material.SetFloat("_PositionY", PositionY);
			material.SetFloat("_Distortion", Size);
			material.SetFloat("_Distortion2", Distortion);
			material.SetVector("_ScreenResolution", new Vector2(Screen.width, Screen.height));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Distortion/Dissipation")]
public class CameraFilterPack_Distortion_Dissipation : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 2.99f)]
	public float Dissipation = 1f;

	[Range(0f, 16f)]
	private float Colors = 11f;

	[Range(-1f, 1f)]
	private float Green_Mod = 1f;

	[Range(0f, 10f)]
	private float Value4 = 1f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Distortion_Dissipation");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", Dissipation);
			material.SetFloat("_Value2", Colors);
			material.SetFloat("_Value3", Green_Mod);
			material.SetFloat("_Value4", Value4);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Distortion/Dream")]
public class CameraFilterPack_Distortion_Dream : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	[Range(1f, 10f)]
	public float Distortion = 1f;

	private Material SCMaterial;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Distortion_Dream");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Distortion", Distortion);
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Distortion/Dream2")]
public class CameraFilterPack_Distortion_Dream2 : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 100f)]
	public float Distortion = 6f;

	[Range(0f, 32f)]
	public float Speed = 5f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Distortion_Dream2");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Speed", Speed);
			material.SetFloat("_Distortion", Distortion);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Distortion/FishEye")]
public class CameraFilterPack_Distortion_FishEye : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	public float Distortion = 0.35f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Distortion_FishEye");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Distortion", Distortion);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Distortion/Flag")]
public class CameraFilterPack_Distortion_Flag : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	[Range(0f, 2f)]
	public float Distortion = 1f;

	private Material SCMaterial;

	public static float ChangeDistortion;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Distortion_Flag");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Distortion", Distortion);
			material.SetVector("_ScreenResolution", new Vector2(Screen.width, Screen.height));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Distortion/Flush")]
public class CameraFilterPack_Distortion_Flush : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(-10f, 50f)]
	public float Value = 5f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Distortion_Flush");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("Value", Value);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Distortion/Half_Sphere")]
public class CameraFilterPack_Distortion_Half_Sphere : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	[Range(1f, 6f)]
	private Material SCMaterial;

	public float SphereSize = 2.5f;

	[Range(-1f, 1f)]
	public float SpherePositionX;

	[Range(-1f, 1f)]
	public float SpherePositionY;

	[Range(1f, 10f)]
	public float Strength = 5f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Distortion_Half_Sphere");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_SphereSize", SphereSize);
			material.SetFloat("_SpherePositionX", SpherePositionX);
			material.SetFloat("_SpherePositionY", SpherePositionY);
			material.SetFloat("_Strength", Strength);
			material.SetVector("_ScreenResolution", new Vector2(Screen.width, Screen.height));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Distortion/Heat")]
public class CameraFilterPack_Distortion_Heat : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(1f, 100f)]
	public float Distortion = 35f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Distortion_Heat");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Distortion", Distortion);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Distortion/Lens")]
public class CameraFilterPack_Distortion_Lens : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(-1f, 1f)]
	public float CenterX;

	[Range(-1f, 1f)]
	public float CenterY;

	[Range(0f, 3f)]
	public float Distortion = 1f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Distortion_Lens");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_CenterX", CenterX);
			material.SetFloat("_CenterY", CenterY);
			material.SetFloat("_Distortion", Distortion);
			material.SetVector("_ScreenResolution", new Vector2(Screen.width, Screen.height));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Distortion/Noise")]
public class CameraFilterPack_Distortion_Noise : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 3f)]
	public float Distortion = 1f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Distortion_Noise");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Distortion", Distortion);
			material.SetVector("_ScreenResolution", new Vector2(Screen.width, Screen.height));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Distortion/ShockWave")]
public class CameraFilterPack_Distortion_ShockWave : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(-1.5f, 1.5f)]
	public float PosX = 0.5f;

	[Range(-1.5f, 1.5f)]
	public float PosY = 0.5f;

	[Range(0f, 10f)]
	public float Speed = 1f;

	[Range(0f, 10f)]
	private float Size = 1f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Distortion_ShockWave");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", PosX);
			material.SetFloat("_Value2", PosY);
			material.SetFloat("_Value3", Speed);
			material.SetFloat("_Value4", Size);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Distortion/ShockWave Manual")]
public class CameraFilterPack_Distortion_ShockWaveManual : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(-1.5f, 1.5f)]
	public float PosX = 0.5f;

	[Range(-1.5f, 1.5f)]
	public float PosY = 0.5f;

	[Range(-0.1f, 2f)]
	public float Value = 0.5f;

	[Range(0f, 10f)]
	public float Size = 1f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Distortion_ShockWaveManual");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", PosX);
			material.SetFloat("_Value2", PosY);
			material.SetFloat("_Value3", Value);
			material.SetFloat("_Value4", Size);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Distortion/Twist")]
public class CameraFilterPack_Distortion_Twist : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(-2f, 2f)]
	public float CenterX = 0.5f;

	[Range(-2f, 2f)]
	public float CenterY = 0.5f;

	[Range(-3.14f, 3.14f)]
	public float Distortion = 1f;

	[Range(-2f, 2f)]
	public float Size = 1f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Distortion_Twist");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_CenterX", CenterX);
			material.SetFloat("_CenterY", CenterY);
			material.SetFloat("_Distortion", Distortion);
			material.SetFloat("_Size", Size);
			material.SetVector("_ScreenResolution", new Vector2(Screen.width, Screen.height));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Distortion/Twist_Square")]
public class CameraFilterPack_Distortion_Twist_Square : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(-2f, 2f)]
	public float CenterX = 0.5f;

	[Range(-2f, 2f)]
	public float CenterY = 0.5f;

	[Range(-3.14f, 3.14f)]
	public float Distortion = 0.5f;

	[Range(-2f, 2f)]
	public float Size = 0.25f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Distortion_Twist_Square");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_CenterX", CenterX);
			material.SetFloat("_CenterY", CenterY);
			material.SetFloat("_Distortion", Distortion);
			material.SetFloat("_Size", Size);
			material.SetVector("_ScreenResolution", new Vector2(Screen.width, Screen.height));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Distortion/Water_Drop")]
public class CameraFilterPack_Distortion_Water_Drop : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(-1f, 1f)]
	public float CenterX;

	[Range(-1f, 1f)]
	public float CenterY;

	[Range(0f, 10f)]
	public float WaveIntensity = 1f;

	[Range(0f, 20f)]
	public int NumberOfWaves = 5;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Distortion_Water_Drop");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetVector("_ScreenResolution", new Vector2(Screen.width, Screen.height));
			material.SetFloat("_CenterX", CenterX);
			material.SetFloat("_CenterY", CenterY);
			material.SetFloat("_WaveIntensity", WaveIntensity);
			material.SetInt("_NumberOfWaves", NumberOfWaves);
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Distortion/Wave_Horizontal")]
public class CameraFilterPack_Distortion_Wave_Horizontal : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(1f, 100f)]
	public float WaveIntensity = 32f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Distortion_Wave_Horizontal");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_WaveIntensity", WaveIntensity);
			material.SetFloat("_TimeX", TimeX);
			material.SetVector("_ScreenResolution", new Vector2(Screen.width, Screen.height));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Drawing/BluePrint")]
public class CameraFilterPack_Drawing_BluePrint : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	public Color Pencil_Color = new Color(1f, 1f, 1f, 1f);

	[Range(0.0001f, 0.0022f)]
	public float Pencil_Size = 0.0008f;

	[Range(0f, 2f)]
	public float Pencil_Correction = 0.76f;

	[Range(0f, 1f)]
	public float Intensity = 1f;

	[Range(0f, 2f)]
	public float Speed_Animation = 1f;

	[Range(0f, 1f)]
	public float Corner_Lose = 0.5f;

	[Range(0f, 1f)]
	public float Fade_Paper_to_BackColor = 0.2f;

	[Range(0f, 1f)]
	public float Fade_With_Original = 1f;

	public Color Back_Color = new Color(0.175f, 0.402f, 0.687f, 1f);

	private Material SCMaterial;

	private Texture2D Texture2;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		Texture2 = Resources.Load("CameraFilterPack_Paper2") as Texture2D;
		SCShader = Shader.Find("CameraFilterPack/Drawing_BluePrint");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetColor("_PColor", Pencil_Color);
			material.SetFloat("_Value1", Pencil_Size);
			material.SetFloat("_Value2", Pencil_Correction);
			material.SetFloat("_Value3", Intensity);
			material.SetFloat("_Value4", Speed_Animation);
			material.SetFloat("_Value5", Corner_Lose);
			material.SetFloat("_Value6", Fade_Paper_to_BackColor);
			material.SetFloat("_Value7", Fade_With_Original);
			material.SetColor("_PColor2", Back_Color);
			material.SetTexture("_MainTex2", Texture2);
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Drawing/CellShading")]
public class CameraFilterPack_Drawing_CellShading : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	public float EdgeSize = 0.1f;

	[Range(0f, 10f)]
	public float ColorLevel = 4f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Drawing_CellShading");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_EdgeSize", EdgeSize);
			material.SetFloat("_ColorLevel", ColorLevel);
			material.SetVector("_ScreenResolution", new Vector2(Screen.width, Screen.height));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Drawing/CellShading2")]
public class CameraFilterPack_Drawing_CellShading2 : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	public float EdgeSize = 0.1f;

	[Range(0f, 10f)]
	public float ColorLevel = 4f;

	[Range(0f, 1f)]
	public float Blur = 1f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Drawing_CellShading2");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_EdgeSize", EdgeSize);
			material.SetFloat("_ColorLevel", ColorLevel);
			material.SetFloat("_Distortion", Blur);
			material.SetVector("_ScreenResolution", new Vector2(Screen.width, Screen.height));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Drawing/Comics")]
public class CameraFilterPack_Drawing_Comics : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	public float DotSize = 0.5f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Drawing_Comics");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_DotSize", DotSize);
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Drawing/Crosshatch")]
public class CameraFilterPack_Drawing_Crosshatch : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(1f, 10f)]
	public float Width = 2f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Drawing_Crosshatch");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Distortion", Width);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Drawing/Curve")]
public class CameraFilterPack_Drawing_Curve : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(3f, 5f)]
	public float Size = 1f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Drawing_Curve");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", Size);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Drawing/EnhancedComics")]
public class CameraFilterPack_Drawing_EnhancedComics : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	public float DotSize = 0.15f;

	[Range(0f, 1f)]
	public float _ColorR = 0.9f;

	[Range(0f, 1f)]
	public float _ColorG = 0.4f;

	[Range(0f, 1f)]
	public float _ColorB = 0.4f;

	[Range(0f, 1f)]
	public float _Blood = 0.5f;

	[Range(0f, 1f)]
	public float _SmoothStart = 0.02f;

	[Range(0f, 1f)]
	public float _SmoothEnd = 0.1f;

	public Color ColorRGB = new Color(1f, 0f, 0f);

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Drawing_EnhancedComics");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_DotSize", DotSize);
			material.SetFloat("_ColorR", _ColorR);
			material.SetFloat("_ColorG", _ColorG);
			material.SetFloat("_ColorB", _ColorB);
			material.SetFloat("_Blood", _Blood);
			material.SetColor("_ColorRGB", ColorRGB);
			material.SetFloat("_SmoothStart", _SmoothStart);
			material.SetFloat("_SmoothEnd", _SmoothEnd);
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Drawing/Halftone")]
public class CameraFilterPack_Drawing_Halftone : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	public float Threshold = 0.6f;

	[Range(1f, 16f)]
	public float DotSize = 4f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Drawing_Halftone");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Distortion", Threshold);
			material.SetFloat("_DotSize", DotSize);
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Drawing/Laplacian")]
public class CameraFilterPack_Drawing_Laplacian : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Drawing_Laplacian");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
		_ = Application.isPlaying;
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Drawing/Lines")]
public class CameraFilterPack_Drawing_Lines : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0.1f, 10f)]
	public float Number = 1f;

	[Range(0f, 1f)]
	public float Random = 0.5f;

	[Range(0f, 10f)]
	private float PositionY = 1f;

	[Range(0f, 10f)]
	private float Value4 = 1f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Drawing_Lines");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", Number);
			material.SetFloat("_Value2", Random);
			material.SetFloat("_Value3", PositionY);
			material.SetFloat("_Value4", Value4);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Drawing/Manga")]
public class CameraFilterPack_Drawing_Manga : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(1f, 8f)]
	public float DotSize = 4.72f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Drawing_Manga");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_DotSize", DotSize);
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Drawing/Manga2")]
public class CameraFilterPack_Drawing_Manga2 : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(1f, 8f)]
	public float DotSize = 4.72f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Drawing_Manga2");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_DotSize", DotSize);
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Drawing/Manga3")]
public class CameraFilterPack_Drawing_Manga3 : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(1f, 8f)]
	public float DotSize = 4.72f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Drawing_Manga3");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_DotSize", DotSize);
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Drawing/Manga4")]
public class CameraFilterPack_Drawing_Manga4 : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(1f, 8f)]
	public float DotSize = 4.72f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Drawing_Manga4");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_DotSize", DotSize);
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Drawing/Manga5")]
public class CameraFilterPack_Drawing_Manga5 : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(1f, 8f)]
	public float DotSize = 4.72f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Drawing_Manga5");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_DotSize", DotSize);
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Drawing/Manga_Color")]
public class CameraFilterPack_Drawing_Manga_Color : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(1f, 8f)]
	public float DotSize = 1.6f;

	public static float ChangeDotSize;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Drawing_Manga_Color");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_DotSize", DotSize);
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Drawing/Manga_Flash")]
public class CameraFilterPack_Drawing_Manga_Flash : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(1f, 10f)]
	public float Size = 1f;

	[Range(0f, 30f)]
	public int Speed = 5;

	[Range(-1f, 1f)]
	public float PosX = 0.5f;

	[Range(-1f, 1f)]
	public float PosY = 0.5f;

	[Range(0f, 1f)]
	public float Intensity = 1f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Drawing_Manga_Flash");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", Size);
			material.SetFloat("_Value2", Speed);
			material.SetFloat("_Value3", PosX);
			material.SetFloat("_Value4", PosY);
			material.SetFloat("_Intensity", Intensity);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Drawing/Manga_FlashWhite")]
public class CameraFilterPack_Drawing_Manga_FlashWhite : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(1f, 10f)]
	public float Size = 1f;

	[Range(0f, 30f)]
	public int Speed = 5;

	[Range(-1f, 1f)]
	public float PosX = 0.5f;

	[Range(-1f, 1f)]
	public float PosY = 0.5f;

	[Range(0f, 1f)]
	public float Intensity = 1f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Drawing_Manga_FlashWhite");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", Size);
			material.SetFloat("_Value2", Speed);
			material.SetFloat("_Value3", PosX);
			material.SetFloat("_Value4", PosY);
			material.SetFloat("_Intensity", Intensity);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Drawing/Manga_Flash_Color")]
public class CameraFilterPack_Drawing_Manga_Flash_Color : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(1f, 10f)]
	public float Size = 1f;

	public Color Color = new Color(0f, 0.7f, 1f, 1f);

	[Range(0f, 30f)]
	public int Speed = 5;

	[Range(0f, 1f)]
	public float PosX = 0.5f;

	[Range(0f, 1f)]
	public float PosY = 0.5f;

	[Range(0f, 1f)]
	public float Intensity = 1f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Drawing_Manga_Flash_Color");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", Size);
			material.SetFloat("_Value2", Speed);
			material.SetFloat("_Value3", PosX);
			material.SetFloat("_Value4", PosY);
			material.SetFloat("_Intensity", Intensity);
			material.SetColor("Color", Color);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Drawing/NewCellShading")]
public class CameraFilterPack_Drawing_NewCellShading : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	public float Threshold = 0.2f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Drawing_NewCellShading");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Threshold", Threshold);
			material.SetVector("_ScreenResolution", new Vector2(Screen.width, Screen.height));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Drawing/Paper")]
public class CameraFilterPack_Drawing_Paper : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	public Color Pencil_Color = new Color(0.156f, 0.3f, 0.738f, 1f);

	[Range(0.0001f, 0.0022f)]
	public float Pencil_Size = 0.0008f;

	[Range(0f, 2f)]
	public float Pencil_Correction = 0.76f;

	[Range(0f, 1f)]
	public float Intensity = 1f;

	[Range(0f, 2f)]
	public float Speed_Animation = 1f;

	[Range(0f, 1f)]
	public float Corner_Lose = 0.5f;

	[Range(0f, 1f)]
	public float Fade_Paper_to_BackColor;

	[Range(0f, 1f)]
	public float Fade_With_Original = 1f;

	public Color Back_Color = new Color(1f, 1f, 1f, 1f);

	private Material SCMaterial;

	private Texture2D Texture2;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		Texture2 = Resources.Load("CameraFilterPack_Paper1") as Texture2D;
		SCShader = Shader.Find("CameraFilterPack/Drawing_Paper");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetColor("_PColor", Pencil_Color);
			material.SetFloat("_Value1", Pencil_Size);
			material.SetFloat("_Value2", Pencil_Correction);
			material.SetFloat("_Value3", Intensity);
			material.SetFloat("_Value4", Speed_Animation);
			material.SetFloat("_Value5", Corner_Lose);
			material.SetFloat("_Value6", Fade_Paper_to_BackColor);
			material.SetFloat("_Value7", Fade_With_Original);
			material.SetColor("_PColor2", Back_Color);
			material.SetTexture("_MainTex2", Texture2);
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Drawing/Paper2")]
public class CameraFilterPack_Drawing_Paper2 : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	public Color Pencil_Color = new Color(0f, 0.371f, 0.78f, 1f);

	[Range(0.0001f, 0.0022f)]
	public float Pencil_Size = 0.0008f;

	[Range(0f, 2f)]
	public float Pencil_Correction = 0.76f;

	[Range(0f, 1f)]
	public float Intensity = 1f;

	[Range(0f, 2f)]
	public float Speed_Animation = 1f;

	[Range(0f, 1f)]
	public float Corner_Lose = 0.85f;

	[Range(0f, 1f)]
	public float Fade_Paper_to_BackColor;

	[Range(0f, 1f)]
	public float Fade_With_Original = 1f;

	public Color Back_Color = new Color(1f, 1f, 1f, 1f);

	private Material SCMaterial;

	private Texture2D Texture2;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		Texture2 = Resources.Load("CameraFilterPack_Paper3") as Texture2D;
		SCShader = Shader.Find("CameraFilterPack/Drawing_Paper2");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetColor("_PColor", Pencil_Color);
			material.SetFloat("_Value1", Pencil_Size);
			material.SetFloat("_Value2", Pencil_Correction);
			material.SetFloat("_Value3", Intensity);
			material.SetFloat("_Value4", Speed_Animation);
			material.SetFloat("_Value5", Corner_Lose);
			material.SetFloat("_Value6", Fade_Paper_to_BackColor);
			material.SetFloat("_Value7", Fade_With_Original);
			material.SetColor("_PColor2", Back_Color);
			material.SetTexture("_MainTex2", Texture2);
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Drawing/Paper3")]
public class CameraFilterPack_Drawing_Paper3 : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	public Color Pencil_Color = new Color(0f, 0f, 0f, 0f);

	[Range(0.0001f, 0.0022f)]
	public float Pencil_Size = 0.00125f;

	[Range(0f, 2f)]
	public float Pencil_Correction = 0.35f;

	[Range(0f, 1f)]
	public float Intensity = 1f;

	[Range(0f, 2f)]
	public float Speed_Animation = 1f;

	[Range(0f, 1f)]
	public float Corner_Lose = 1f;

	[Range(0f, 1f)]
	public float Fade_Paper_to_BackColor;

	[Range(0f, 1f)]
	public float Fade_With_Original = 1f;

	public Color Back_Color = new Color(1f, 1f, 1f, 1f);

	private Material SCMaterial;

	private Texture2D Texture2;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		Texture2 = Resources.Load("CameraFilterPack_Paper4") as Texture2D;
		SCShader = Shader.Find("CameraFilterPack/Drawing_Paper3");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetColor("_PColor", Pencil_Color);
			material.SetFloat("_Value1", Pencil_Size);
			material.SetFloat("_Value2", Pencil_Correction);
			material.SetFloat("_Value3", Intensity);
			material.SetFloat("_Value4", Speed_Animation);
			material.SetFloat("_Value5", Corner_Lose);
			material.SetFloat("_Value6", Fade_Paper_to_BackColor);
			material.SetFloat("_Value7", Fade_With_Original);
			material.SetColor("_PColor2", Back_Color);
			material.SetTexture("_MainTex2", Texture2);
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Drawing/Toon")]
public class CameraFilterPack_Drawing_Toon : MonoBehaviour
{
	public Shader SCShader;

	private Material SCMaterial;

	private float TimeX = 1f;

	[Range(0f, 2f)]
	public float Threshold = 1f;

	[Range(0f, 8f)]
	public float DotSize = 1f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Drawing_Toon");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Distortion", Threshold);
			material.SetFloat("_DotSize", DotSize);
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/EXTRA/Rotation")]
public class CameraFilterPack_EXTRA_Rotation : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(-360f, 360f)]
	public float Rotation;

	[Range(-1f, 2f)]
	public float PositionX = 0.5f;

	[Range(-1f, 2f)]
	public float PositionY = 0.5f;

	[Range(0f, 10f)]
	private float Value4 = 1f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/EXTRA_Rotation");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", 0f - Rotation);
			material.SetFloat("_Value2", PositionX);
			material.SetFloat("_Value3", PositionY);
			material.SetFloat("_Value4", Value4);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/EXTRA/SHOWFPS")]
public class CameraFilterPack_EXTRA_SHOWFPS : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(8f, 42f)]
	public float Size = 12f;

	[Range(0f, 100f)]
	private int FPS = 1;

	[Range(0f, 10f)]
	private float Value3 = 1f;

	[Range(0f, 10f)]
	private float Value4 = 1f;

	private float accum;

	private int frames;

	public float frequency = 0.5f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		FPS = 0;
		StartCoroutine(FPSX());
		SCShader = Shader.Find("CameraFilterPack/EXTRA_SHOWFPS");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", Size);
			material.SetFloat("_Value2", FPS);
			material.SetFloat("_Value3", Value3);
			material.SetFloat("_Value4", Value4);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private IEnumerator FPSX()
	{
		while (true)
		{
			float num = accum / (float)frames;
			FPS = (int)num;
			accum = 0f;
			frames = 0;
			yield return new WaitForSeconds(frequency);
		}
	}

	private void Update()
	{
		accum += Time.timeScale / Time.deltaTime;
		frames++;
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Edge/BlackLine")]
public class CameraFilterPack_Edge_BlackLine : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Edge_BlackLine");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetVector("_ScreenResolution", new Vector2(Screen.width, Screen.height));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Edge/Edge_filter")]
public class CameraFilterPack_Edge_Edge_filter : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 10f)]
	public float RedAmplifier;

	[Range(0f, 10f)]
	public float GreenAmplifier = 2f;

	[Range(0f, 10f)]
	public float BlueAmplifier;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Edge_Edge_filter");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_RedAmplifier", RedAmplifier);
			material.SetFloat("_GreenAmplifier", GreenAmplifier);
			material.SetFloat("_BlueAmplifier", BlueAmplifier);
			material.SetVector("_ScreenResolution", new Vector2(Screen.width, Screen.height));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Edge/Golden")]
public class CameraFilterPack_Edge_Golden : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Edge_Golden");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetVector("_ScreenResolution", new Vector2(Screen.width, Screen.height));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Edge/Neon")]
public class CameraFilterPack_Edge_Neon : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(1f, 10f)]
	public float EdgeWeight = 1f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Edge_Neon");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_EdgeWeight", EdgeWeight);
			material.SetVector("_ScreenResolution", new Vector2(Screen.width, Screen.height));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Edge/Sigmoid")]
public class CameraFilterPack_Edge_Sigmoid : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(1f, 10f)]
	public float Gain = 3f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Edge_Sigmoid");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Gain", Gain);
			material.SetVector("_ScreenResolution", new Vector2(Screen.width, Screen.height));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Edge/Sobel")]
public class CameraFilterPack_Edge_Sobel : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Edge_Sobel");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Vision/Eyes 1")]
public class CameraFilterPack_EyesVision_1 : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	[Range(1f, 32f)]
	public float _EyeWave = 15f;

	[Range(0f, 10f)]
	public float _EyeSpeed = 1f;

	[Range(0f, 8f)]
	public float _EyeMove = 2f;

	[Range(0f, 1f)]
	public float _EyeBlink = 1f;

	private Material SCMaterial;

	private Texture2D Texture2;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		Texture2 = Resources.Load("CameraFilterPack_eyes_vision_1") as Texture2D;
		SCShader = Shader.Find("CameraFilterPack/EyesVision_1");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", _EyeWave);
			material.SetFloat("_Value2", _EyeSpeed);
			material.SetFloat("_Value3", _EyeMove);
			material.SetFloat("_Value4", _EyeBlink);
			material.SetTexture("_MainTex2", Texture2);
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Vision/Eyes 2")]
public class CameraFilterPack_EyesVision_2 : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	[Range(1f, 32f)]
	public float _EyeWave = 15f;

	[Range(0f, 10f)]
	public float _EyeSpeed = 1f;

	[Range(0f, 8f)]
	public float _EyeMove = 2f;

	[Range(0f, 1f)]
	public float _EyeBlink = 1f;

	private Material SCMaterial;

	private Texture2D Texture2;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		Texture2 = Resources.Load("CameraFilterPack_eyes_vision_2") as Texture2D;
		SCShader = Shader.Find("CameraFilterPack/EyesVision_2");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", _EyeWave);
			material.SetFloat("_Value2", _EyeSpeed);
			material.SetFloat("_Value3", _EyeMove);
			material.SetFloat("_Value4", _EyeBlink);
			material.SetTexture("_MainTex2", Texture2);
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Pixel/8bits")]
public class CameraFilterPack_FX_8bits : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(-1f, 1f)]
	public float Brightness;

	[Range(80f, 640f)]
	public int ResolutionX = 160;

	[Range(60f, 480f)]
	public int ResolutionY = 240;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/FX_8bits");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			if (Brightness == 0f)
			{
				Brightness = 0.001f;
			}
			material.SetFloat("_Distortion", Brightness);
			RenderTexture temporary = RenderTexture.GetTemporary(ResolutionX, ResolutionY, 0);
			Graphics.Blit(sourceTexture, temporary, material);
			temporary.filterMode = FilterMode.Point;
			Graphics.Blit(temporary, destTexture);
			RenderTexture.ReleaseTemporary(temporary);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Pixel/8bits_gb")]
public class CameraFilterPack_FX_8bits_gb : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(-1f, 1f)]
	public float Brightness;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/FX_8bits_gb");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			if (Brightness == 0f)
			{
				Brightness = 0.001f;
			}
			material.SetFloat("_Distortion", Brightness);
			RenderTexture temporary = RenderTexture.GetTemporary(160, 144, 0);
			Graphics.Blit(sourceTexture, temporary, material);
			temporary.filterMode = FilterMode.Point;
			Graphics.Blit(temporary, destTexture);
			RenderTexture.ReleaseTemporary(temporary);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/FX/Ascii")]
public class CameraFilterPack_FX_Ascii : MonoBehaviour
{
	public Shader SCShader;

	[Range(0f, 2f)]
	public float Value = 1f;

	[Range(0.01f, 1f)]
	public float Fade = 1f;

	private float TimeX = 1f;

	private Material SCMaterial;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/FX_Ascii");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("Value", Value);
			material.SetFloat("Fade", Fade);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/FX/DarkMatter")]
public class CameraFilterPack_FX_DarkMatter : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(-10f, 10f)]
	public float Speed = 0.8f;

	[Range(0f, 1f)]
	public float Intensity = 1f;

	[Range(-1f, 2f)]
	public float PosX = 0.5f;

	[Range(-1f, 2f)]
	public float PosY = 0.5f;

	[Range(-2f, 2f)]
	public float Zoom = 0.33f;

	[Range(0f, 5f)]
	public float DarkIntensity = 2f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/FX_DarkMatter");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", Speed);
			material.SetFloat("_Value2", Intensity);
			material.SetFloat("_Value3", PosX);
			material.SetFloat("_Value4", PosY);
			material.SetFloat("_Value5", Zoom);
			material.SetFloat("_Value6", DarkIntensity);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/FX/DigitalMatrix")]
public class CameraFilterPack_FX_DigitalMatrix : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0.4f, 5f)]
	public float Size = 1f;

	[Range(-10f, 10f)]
	public float Speed = 1f;

	[Range(-1f, 1f)]
	public float ColorR = -1f;

	[Range(-1f, 1f)]
	public float ColorG = 1f;

	[Range(-1f, 1f)]
	public float ColorB = -1f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/FX_DigitalMatrix");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", Size);
			material.SetFloat("_Value2", ColorR);
			material.SetFloat("_Value3", ColorG);
			material.SetFloat("_Value4", ColorB);
			material.SetFloat("_Value5", Speed);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/FX/DigitalMatrixDistortion")]
public class CameraFilterPack_FX_DigitalMatrixDistortion : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0.4f, 5f)]
	public float Size = 1.4f;

	[Range(-2f, 2f)]
	public float Speed = 0.5f;

	[Range(-5f, 5f)]
	public float Distortion = 2.3f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/FX_DigitalMatrixDistortion");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", Size);
			material.SetFloat("_Value2", Distortion);
			material.SetFloat("_Value5", Speed);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/FX/Dot_Circle")]
public class CameraFilterPack_FX_Dot_Circle : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(4f, 32f)]
	public float Value = 7f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/FX_Dot_Circle");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			material.SetFloat("_Value", Value);
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/FX/Drunk")]
public class CameraFilterPack_FX_Drunk : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[HideInInspector]
	[Range(0f, 20f)]
	public float Value = 6f;

	[Range(0f, 10f)]
	public float Speed = 1f;

	[Range(0f, 1f)]
	public float Wavy = 1f;

	[Range(0f, 1f)]
	public float Distortion;

	[Range(0f, 1f)]
	public float DistortionWave;

	[Range(0f, 1f)]
	public float Fade = 1f;

	[Range(-2f, 2f)]
	public float ColoredSaturate = 1f;

	[Range(-1f, 2f)]
	public float ColoredChange;

	[Range(-1f, 1f)]
	public float ChangeRed;

	[Range(-1f, 1f)]
	public float ChangeGreen;

	[Range(-1f, 1f)]
	public float ChangeBlue;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/FX_Drunk");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", Value);
			material.SetFloat("_Speed", Speed);
			material.SetFloat("_Distortion", Distortion);
			material.SetFloat("_DistortionWave", DistortionWave);
			material.SetFloat("_Wavy", Wavy);
			material.SetFloat("_Fade", Fade);
			material.SetFloat("_ColoredChange", ColoredChange);
			material.SetFloat("_ChangeRed", ChangeRed);
			material.SetFloat("_ChangeGreen", ChangeGreen);
			material.SetFloat("_ChangeBlue", ChangeBlue);
			material.SetFloat("_Colored", ColoredSaturate);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/FX/Drunk2")]
public class CameraFilterPack_FX_Drunk2 : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 10f)]
	private float Value = 1f;

	[Range(0f, 10f)]
	private float Value2 = 1f;

	[Range(0f, 10f)]
	private float Value3 = 1f;

	[Range(0f, 10f)]
	private float Value4 = 1f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/FX_Drunk2");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", Value);
			material.SetFloat("_Value2", Value2);
			material.SetFloat("_Value3", Value3);
			material.SetFloat("_Value4", Value4);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/FX/Earth Quake")]
public class CameraFilterPack_FX_EarthQuake : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 100f)]
	public float Speed = 15f;

	[Range(0f, 0.2f)]
	public float X = 0.008f;

	[Range(0f, 0.2f)]
	public float Y = 0.008f;

	[Range(0f, 0.2f)]
	private float Value4 = 1f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/FX_EarthQuake");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", Speed);
			material.SetFloat("_Value2", X);
			material.SetFloat("_Value3", Y);
			material.SetFloat("_Value4", Value4);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/FX/Funk")]
public class CameraFilterPack_FX_Funk : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/FX_Funk");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Glitch/Glitch1")]
public class CameraFilterPack_FX_Glitch1 : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	public float Glitch = 1f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/FX_Glitch1");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Glitch", Glitch);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Glitch/Glitch2")]
public class CameraFilterPack_FX_Glitch2 : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	public float Glitch = 1f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/FX_Glitch2");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Glitch", Glitch);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Glitch/Glitch3")]
public class CameraFilterPack_FX_Glitch3 : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	public float _Glitch = 1f;

	[Range(0f, 1f)]
	public float _Noise = 1f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/FX_Glitch3");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Glitch", _Glitch);
			material.SetFloat("_Noise", _Noise);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/FX/Grid")]
public class CameraFilterPack_FX_Grid : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 5f)]
	public float Distortion = 1f;

	public static float ChangeDistortion;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/FX_Grid");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Distortion", Distortion);
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/FX/Hexagon")]
public class CameraFilterPack_FX_Hexagon : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/FX_Hexagon");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/FX/Hexagon_Black")]
public class CameraFilterPack_FX_Hexagon_Black : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0.2f, 10f)]
	public float Value = 1f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/FX_Hexagon_Black");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", Value);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/FX/Hypno")]
public class CameraFilterPack_FX_Hypno : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	public float Speed = 1f;

	[Range(-2f, 2f)]
	public float Red;

	[Range(-2f, 2f)]
	public float Green = 1f;

	[Range(-2f, 2f)]
	public float Blue = 1f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/FX_Hypno");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", Speed);
			material.SetFloat("_Value2", Red);
			material.SetFloat("_Value3", Green);
			material.SetFloat("_Value4", Blue);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/FX/InverChromiLum")]
public class CameraFilterPack_FX_InverChromiLum : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/FX_InverChromiLum");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/FX/Mirror")]
public class CameraFilterPack_FX_Mirror : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/FX_Mirror");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/FX/Plasma")]
public class CameraFilterPack_FX_Plasma : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 20f)]
	private float Value = 6f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/FX_Plasma");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", Value);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/FX/Psycho")]
public class CameraFilterPack_FX_Psycho : MonoBehaviour
{
	public Shader SCShader;

	private Material SCMaterial;

	private float TimeX = 1f;

	[Range(0f, 1f)]
	public float Distortion = 1f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/FX_Psycho");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Distortion", Distortion);
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/FX/Scan")]
public class CameraFilterPack_FX_Scan : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0.001f, 0.1f)]
	public float Size = 0.025f;

	[Range(0f, 10f)]
	public float Speed = 1f;

	[Range(0f, 10f)]
	private float Value3 = 1f;

	[Range(0f, 10f)]
	private float Value4 = 1f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/FX_Scan");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", Size);
			material.SetFloat("_Value2", Speed);
			material.SetFloat("_Value3", Value3);
			material.SetFloat("_Value4", Value4);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/FX/Screens")]
public class CameraFilterPack_FX_Screens : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 256f)]
	public float Tiles = 8f;

	[Range(0f, 5f)]
	public float Speed = 0.25f;

	public Color color = new Color(0f, 1f, 1f, 1f);

	[Range(-1f, 1f)]
	public float PosX;

	[Range(-1f, 1f)]
	public float PosY;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/FX_Screens");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", Tiles);
			material.SetFloat("_Value2", Speed);
			material.SetFloat("_Value3", PosX);
			material.SetFloat("_Value4", PosY);
			material.SetColor("_color", color);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/FX/Spot")]
public class CameraFilterPack_FX_Spot : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	public Vector2 center = new Vector2(0.5f, 0.5f);

	public float Radius = 0.2f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/FX_Spot");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_PositionX", center.x);
			material.SetFloat("_PositionY", center.y);
			material.SetFloat("_Radius", Radius);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/FX/ZebraColor")]
public class CameraFilterPack_FX_ZebraColor : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(1f, 10f)]
	public float Value = 3f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/FX_ZebraColor");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", Value);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/FX/SuperDot")]
public class CameraFilterPack_FX_superDot : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/FX_superDot");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Film/ColorPerfection")]
public class CameraFilterPack_Film_ColorPerfection : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 4f)]
	public float Gamma = 0.55f;

	[Range(0f, 10f)]
	private float Value2 = 1f;

	[Range(0f, 10f)]
	private float Value3 = 1f;

	[Range(0f, 10f)]
	private float Value4 = 1f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Film_ColorPerfection");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", Gamma);
			material.SetFloat("_Value2", Value2);
			material.SetFloat("_Value3", Value3);
			material.SetFloat("_Value4", Value4);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Film/Grain")]
public class CameraFilterPack_Film_Grain : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(-64f, 64f)]
	public float Value = 32f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Film_Grain");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", Value);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Vision/Fly_Vision")]
public class CameraFilterPack_Fly_Vision : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0.04f, 1.5f)]
	public float Zoom = 0.25f;

	[Range(0f, 1f)]
	public float Distortion = 0.4f;

	[Range(0f, 1f)]
	public float Fade = 0.4f;

	[Range(0f, 10f)]
	private float Value4 = 1f;

	private Texture2D Texture2;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		Texture2 = Resources.Load("CameraFilterPack_Fly_VisionFX") as Texture2D;
		SCShader = Shader.Find("CameraFilterPack/Fly_Vision");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", Zoom);
			material.SetFloat("_Value2", Distortion);
			material.SetFloat("_Value3", Fade);
			material.SetFloat("_Value4", Value4);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			material.SetTexture("Texture2", Texture2);
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Glasses/Classic Glasses")]
public class CameraFilterPack_Glasses_On : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	[Range(0f, 1f)]
	public float Fade = 0.2f;

	[Range(0f, 0.1f)]
	public float VisionBlur = 0.0095f;

	public Color GlassesColor = new Color(0f, 0f, 0f, 1f);

	public Color GlassesColor2 = new Color(0.25f, 0.25f, 0.25f, 0.25f);

	[Range(0f, 1f)]
	public float GlassDistortion = 0.45f;

	[Range(0f, 1f)]
	public float GlassAberration = 0.5f;

	[Range(0f, 1f)]
	public float UseFinalGlassColor;

	[Range(0f, 1f)]
	public float UseScanLine;

	[Range(1f, 512f)]
	public float UseScanLineSize = 1f;

	public Color GlassColor = new Color(0f, 0f, 0f, 1f);

	private Material SCMaterial;

	private Texture2D Texture2;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		Texture2 = Resources.Load("CameraFilterPack_Glasses_On2") as Texture2D;
		SCShader = Shader.Find("CameraFilterPack/Glasses_On");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("UseFinalGlassColor", UseFinalGlassColor);
			material.SetFloat("Fade", Fade);
			material.SetFloat("VisionBlur", VisionBlur);
			material.SetFloat("GlassDistortion", GlassDistortion);
			material.SetFloat("GlassAberration", GlassAberration);
			material.SetColor("GlassesColor", GlassesColor);
			material.SetColor("GlassesColor2", GlassesColor2);
			material.SetColor("GlassColor", GlassColor);
			material.SetFloat("UseScanLineSize", UseScanLineSize);
			material.SetFloat("UseScanLine", UseScanLine);
			material.SetTexture("_MainTex2", Texture2);
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Glasses/Vampire")]
public class CameraFilterPack_Glasses_On_2 : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	[Range(0f, 1f)]
	public float Fade = 0.2f;

	[Range(0f, 0.1f)]
	public float VisionBlur = 0.005f;

	public Color GlassesColor = new Color(0f, 0f, 0f, 1f);

	public Color GlassesColor2 = new Color(0.25f, 0.25f, 0.25f, 0.25f);

	[Range(0f, 1f)]
	public float GlassDistortion = 0.6f;

	[Range(0f, 1f)]
	public float GlassAberration = 0.5f;

	[Range(0f, 1f)]
	public float UseFinalGlassColor = 1f;

	[Range(0f, 1f)]
	public float UseScanLine;

	[Range(1f, 512f)]
	public float UseScanLineSize = 358f;

	public Color GlassColor = new Color(1f, 0f, 0f, 1f);

	private Material SCMaterial;

	private Texture2D Texture2;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		Texture2 = Resources.Load("CameraFilterPack_Glasses_On3") as Texture2D;
		SCShader = Shader.Find("CameraFilterPack/Glasses_OnX");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("UseFinalGlassColor", UseFinalGlassColor);
			material.SetFloat("Fade", Fade);
			material.SetFloat("VisionBlur", VisionBlur);
			material.SetFloat("GlassDistortion", GlassDistortion);
			material.SetFloat("GlassAberration", GlassAberration);
			material.SetColor("GlassesColor", GlassesColor);
			material.SetColor("GlassesColor2", GlassesColor2);
			material.SetColor("GlassColor", GlassColor);
			material.SetFloat("UseScanLineSize", UseScanLineSize);
			material.SetFloat("UseScanLine", UseScanLine);
			material.SetTexture("_MainTex2", Texture2);
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Glasses/Night Glasses")]
public class CameraFilterPack_Glasses_On_3 : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	[Range(0f, 1f)]
	public float Fade = 0.3f;

	[Range(0f, 0.1f)]
	public float VisionBlur = 0.005f;

	public Color GlassesColor = new Color(0.7f, 0.7f, 0.7f, 1f);

	public Color GlassesColor2 = new Color(1f, 1f, 1f, 1f);

	[Range(0f, 1f)]
	public float GlassDistortion = 0.6f;

	[Range(0f, 1f)]
	public float GlassAberration = 0.3f;

	[Range(0f, 1f)]
	public float UseFinalGlassColor;

	[Range(0f, 1f)]
	public float UseScanLine = 0.4f;

	[Range(1f, 512f)]
	public float UseScanLineSize = 358f;

	public Color GlassColor = new Color(0f, 0.5f, 0f, 1f);

	private Material SCMaterial;

	private Texture2D Texture2;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		Texture2 = Resources.Load("CameraFilterPack_Glasses_On4") as Texture2D;
		SCShader = Shader.Find("CameraFilterPack/Glasses_On");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("UseFinalGlassColor", UseFinalGlassColor);
			material.SetFloat("Fade", Fade);
			material.SetFloat("VisionBlur", VisionBlur);
			material.SetFloat("GlassDistortion", GlassDistortion);
			material.SetFloat("GlassAberration", GlassAberration);
			material.SetColor("GlassesColor", GlassesColor);
			material.SetColor("GlassesColor2", GlassesColor2);
			material.SetColor("GlassColor", GlassColor);
			material.SetFloat("UseScanLineSize", UseScanLineSize);
			material.SetFloat("UseScanLine", UseScanLine);
			material.SetTexture("_MainTex2", Texture2);
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Glasses/Futuristic Desert")]
public class CameraFilterPack_Glasses_On_4 : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	[Range(0f, 1f)]
	public float Fade = 0.2f;

	[Range(0f, 0.1f)]
	public float VisionBlur = 0.005f;

	public Color GlassesColor = new Color(0f, 0f, 0f, 1f);

	public Color GlassesColor2 = new Color(0.25f, 0.25f, 0.25f, 0.25f);

	[Range(0f, 1f)]
	public float GlassDistortion = 0.6f;

	[Range(0f, 1f)]
	public float GlassAberration = 0.3f;

	[Range(0f, 1f)]
	public float UseFinalGlassColor;

	[Range(0f, 1f)]
	public float UseScanLine = 0.4f;

	[Range(1f, 512f)]
	public float UseScanLineSize = 358f;

	public Color GlassColor = new Color(1f, 0.4f, 0f, 1f);

	private Material SCMaterial;

	private Texture2D Texture2;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		Texture2 = Resources.Load("CameraFilterPack_Glasses_On5") as Texture2D;
		SCShader = Shader.Find("CameraFilterPack/Glasses_On");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("UseFinalGlassColor", UseFinalGlassColor);
			material.SetFloat("Fade", Fade);
			material.SetFloat("VisionBlur", VisionBlur);
			material.SetFloat("GlassDistortion", GlassDistortion);
			material.SetFloat("GlassAberration", GlassAberration);
			material.SetColor("GlassesColor", GlassesColor);
			material.SetColor("GlassesColor2", GlassesColor2);
			material.SetColor("GlassColor", GlassColor);
			material.SetFloat("UseScanLineSize", UseScanLineSize);
			material.SetFloat("UseScanLine", UseScanLine);
			material.SetTexture("_MainTex2", Texture2);
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Glasses/Futuristic Montain")]
public class CameraFilterPack_Glasses_On_5 : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	[Range(0f, 1f)]
	public float Fade = 0.2f;

	[Range(0f, 0.1f)]
	public float VisionBlur = 0.005f;

	public Color GlassesColor = new Color(0.1f, 0.1f, 0.1f, 1f);

	public Color GlassesColor2 = new Color(0.45f, 0.45f, 0.45f, 0.25f);

	[Range(0f, 1f)]
	public float GlassDistortion = 0.6f;

	[Range(0f, 1f)]
	public float GlassAberration = 0.3f;

	[Range(0f, 1f)]
	public float UseFinalGlassColor;

	[Range(0f, 1f)]
	public float UseScanLine = 0.4f;

	[Range(1f, 512f)]
	public float UseScanLineSize = 358f;

	public Color GlassColor = new Color(0.1f, 0.3f, 1f, 1f);

	private Material SCMaterial;

	private Texture2D Texture2;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		Texture2 = Resources.Load("CameraFilterPack_Glasses_On6") as Texture2D;
		SCShader = Shader.Find("CameraFilterPack/Glasses_On");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("UseFinalGlassColor", UseFinalGlassColor);
			material.SetFloat("Fade", Fade);
			material.SetFloat("VisionBlur", VisionBlur);
			material.SetFloat("GlassDistortion", GlassDistortion);
			material.SetFloat("GlassAberration", GlassAberration);
			material.SetColor("GlassesColor", GlassesColor);
			material.SetColor("GlassesColor2", GlassesColor2);
			material.SetColor("GlassColor", GlassColor);
			material.SetFloat("UseScanLineSize", UseScanLineSize);
			material.SetFloat("UseScanLine", UseScanLine);
			material.SetTexture("_MainTex2", Texture2);
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Glasses/Spy")]
public class CameraFilterPack_Glasses_On_6 : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	[Range(0f, 1f)]
	public float Fade = 0.2f;

	[Range(0f, 0.1f)]
	public float VisionBlur = 0.005f;

	public Color GlassesColor = new Color(0f, 0f, 0f, 1f);

	public Color GlassesColor2 = new Color(0.25f, 0.25f, 0.45f, 0.25f);

	[Range(0f, 1f)]
	public float GlassDistortion = 0.6f;

	[Range(0f, 1f)]
	public float GlassAberration = 0.3f;

	[Range(0f, 1f)]
	public float UseFinalGlassColor;

	[Range(0f, 1f)]
	public float UseScanLine = 0.4f;

	[Range(1f, 512f)]
	public float UseScanLineSize = 358f;

	public Color GlassColor = new Color(1f, 0.9f, 0f, 1f);

	private Material SCMaterial;

	private Texture2D Texture2;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		Texture2 = Resources.Load("CameraFilterPack_Glasses_On7") as Texture2D;
		SCShader = Shader.Find("CameraFilterPack/Glasses_On");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("UseFinalGlassColor", UseFinalGlassColor);
			material.SetFloat("Fade", Fade);
			material.SetFloat("VisionBlur", VisionBlur);
			material.SetFloat("GlassDistortion", GlassDistortion);
			material.SetFloat("GlassAberration", GlassAberration);
			material.SetColor("GlassesColor", GlassesColor);
			material.SetColor("GlassesColor2", GlassesColor2);
			material.SetColor("GlassColor", GlassColor);
			material.SetFloat("UseScanLineSize", UseScanLineSize);
			material.SetFloat("UseScanLine", UseScanLine);
			material.SetTexture("_MainTex2", Texture2);
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Glitch/Mozaic")]
public class CameraFilterPack_Glitch_Mozaic : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0.001f, 10f)]
	public float Intensity = 1f;

	[Range(0f, 10f)]
	private float Value2 = 1f;

	[Range(0f, 10f)]
	private float Value3 = 1f;

	[Range(0f, 10f)]
	private float Value4 = 1f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Glitch_Mozaic");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", Intensity);
			material.SetFloat("_Value2", Value2);
			material.SetFloat("_Value3", Value3);
			material.SetFloat("_Value4", Value4);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Glow/Glow")]
public class CameraFilterPack_Glow_Glow : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 20f)]
	public float Amount = 4f;

	[Range(2f, 16f)]
	public int FastFilter = 4;

	[Range(0f, 1f)]
	public float Threshold = 0.5f;

	[Range(0f, 1f)]
	public float Intensity = 0.75f;

	[Range(-1f, 1f)]
	public float Precision = 0.56f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Glow_Glow");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			int fastFilter = FastFilter;
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Amount", Amount);
			material.SetFloat("_Value1", Threshold);
			material.SetFloat("_Value2", Intensity);
			material.SetFloat("_Value3", Precision);
			material.SetVector("_ScreenResolution", new Vector2(Screen.width / fastFilter, Screen.height / fastFilter));
			int width = sourceTexture.width / fastFilter;
			int height = sourceTexture.height / fastFilter;
			if (FastFilter > 1)
			{
				RenderTexture temporary = RenderTexture.GetTemporary(width, height, 0);
				RenderTexture temporary2 = RenderTexture.GetTemporary(width, height, 0);
				temporary.filterMode = FilterMode.Trilinear;
				Graphics.Blit(sourceTexture, temporary, material, 3);
				Graphics.Blit(temporary, temporary2, material, 2);
				Graphics.Blit(temporary2, temporary, material, 0);
				material.SetFloat("_Amount", Amount * 2f);
				Graphics.Blit(temporary, temporary2, material, 2);
				Graphics.Blit(temporary2, temporary, material, 0);
				material.SetTexture("_MainTex2", temporary);
				RenderTexture.ReleaseTemporary(temporary);
				RenderTexture.ReleaseTemporary(temporary2);
				Graphics.Blit(sourceTexture, destTexture, material, 1);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture, material, 0);
			}
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Glow/Glow_Color")]
public class CameraFilterPack_Glow_Glow_Color : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 20f)]
	public float Amount = 4f;

	[Range(2f, 16f)]
	public int FastFilter = 4;

	[Range(0f, 1f)]
	public float Threshold = 0.5f;

	[Range(0f, 3f)]
	public float Intensity = 2.25f;

	[Range(-1f, 1f)]
	public float Precision = 0.56f;

	public Color GlowColor = new Color(0f, 0.7f, 1f, 1f);

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Glow_Glow_Color");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			int fastFilter = FastFilter;
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Amount", Amount);
			material.SetFloat("_Value1", Threshold);
			material.SetFloat("_Value2", Intensity);
			material.SetFloat("_Value3", Precision);
			material.SetColor("_GlowColor", GlowColor);
			material.SetVector("_ScreenResolution", new Vector2(Screen.width / fastFilter, Screen.height / fastFilter));
			int width = sourceTexture.width / fastFilter;
			int height = sourceTexture.height / fastFilter;
			if (FastFilter > 1)
			{
				RenderTexture temporary = RenderTexture.GetTemporary(width, height, 0);
				RenderTexture temporary2 = RenderTexture.GetTemporary(width, height, 0);
				temporary.filterMode = FilterMode.Trilinear;
				Graphics.Blit(sourceTexture, temporary, material, 3);
				Graphics.Blit(temporary, temporary2, material, 2);
				Graphics.Blit(temporary2, temporary, material, 0);
				material.SetFloat("_Amount", Amount * 2f);
				Graphics.Blit(temporary, temporary2, material, 2);
				Graphics.Blit(temporary2, temporary, material, 0);
				material.SetTexture("_MainTex2", temporary);
				RenderTexture.ReleaseTemporary(temporary);
				RenderTexture.ReleaseTemporary(temporary2);
				Graphics.Blit(sourceTexture, destTexture, material, 1);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture, material, 0);
			}
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Gradients/Ansi")]
public class CameraFilterPack_Gradients_Ansi : MonoBehaviour
{
	public Shader SCShader;

	private string ShaderName = "CameraFilterPack/Gradients_Ansi";

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	public float Switch = 1f;

	[Range(0f, 1f)]
	public float Fade = 1f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find(ShaderName);
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", Switch);
			material.SetFloat("_Value2", Fade);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Gradients/Desert")]
public class CameraFilterPack_Gradients_Desert : MonoBehaviour
{
	public Shader SCShader;

	private string ShaderName = "CameraFilterPack/Gradients_Desert";

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	public float Switch = 1f;

	[Range(0f, 1f)]
	public float Fade = 1f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find(ShaderName);
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", Switch);
			material.SetFloat("_Value2", Fade);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Gradients/Electric")]
public class CameraFilterPack_Gradients_ElectricGradient : MonoBehaviour
{
	public Shader SCShader;

	private string ShaderName = "CameraFilterPack/Gradients_ElectricGradient";

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	public float Switch = 1f;

	[Range(0f, 1f)]
	public float Fade = 1f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find(ShaderName);
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", Switch);
			material.SetFloat("_Value2", Fade);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Gradients/Fire")]
public class CameraFilterPack_Gradients_FireGradient : MonoBehaviour
{
	public Shader SCShader;

	private string ShaderName = "CameraFilterPack/Gradients_FireGradient";

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	public float Switch = 1f;

	[Range(0f, 1f)]
	public float Fade = 1f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find(ShaderName);
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", Switch);
			material.SetFloat("_Value2", Fade);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Gradients/Hue")]
public class CameraFilterPack_Gradients_Hue : MonoBehaviour
{
	public Shader SCShader;

	private string ShaderName = "CameraFilterPack/Gradients_Hue";

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	public float Switch = 1f;

	[Range(0f, 1f)]
	public float Fade = 1f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find(ShaderName);
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", Switch);
			material.SetFloat("_Value2", Fade);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Gradients/Neon")]
public class CameraFilterPack_Gradients_NeonGradient : MonoBehaviour
{
	public Shader SCShader;

	private string ShaderName = "CameraFilterPack/Gradients_NeonGradient";

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	public float Switch = 1f;

	[Range(0f, 1f)]
	public float Fade = 1f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find(ShaderName);
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", Switch);
			material.SetFloat("_Value2", Fade);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Gradients/Rainbow")]
public class CameraFilterPack_Gradients_Rainbow : MonoBehaviour
{
	public Shader SCShader;

	private string ShaderName = "CameraFilterPack/Gradients_Rainbow";

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	public float Switch = 1f;

	[Range(0f, 1f)]
	public float Fade = 1f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find(ShaderName);
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", Switch);
			material.SetFloat("_Value2", Fade);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Gradients/Stripe")]
public class CameraFilterPack_Gradients_Stripe : MonoBehaviour
{
	public Shader SCShader;

	private string ShaderName = "CameraFilterPack/Gradients_Stripe";

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	public float Switch = 1f;

	[Range(0f, 1f)]
	public float Fade = 1f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find(ShaderName);
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", Switch);
			material.SetFloat("_Value2", Fade);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Gradients/Tech")]
public class CameraFilterPack_Gradients_Tech : MonoBehaviour
{
	public Shader SCShader;

	private string ShaderName = "CameraFilterPack/Gradients_Tech";

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	public float Switch = 1f;

	[Range(0f, 1f)]
	public float Fade = 1f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find(ShaderName);
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", Switch);
			material.SetFloat("_Value2", Fade);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Gradients/Thermal")]
public class CameraFilterPack_Gradients_Therma : MonoBehaviour
{
	public Shader SCShader;

	private string ShaderName = "CameraFilterPack/Gradients_Therma";

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	public float Switch = 1f;

	[Range(0f, 1f)]
	public float Fade = 1f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find(ShaderName);
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", Switch);
			material.SetFloat("_Value2", Fade);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Light/Rainbow")]
public class CameraFilterPack_Light_Rainbow : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0.01f, 5f)]
	public float Value = 1.5f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Light_Rainbow");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", Value);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Light/Rainbow2")]
public class CameraFilterPack_Light_Rainbow2 : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0.01f, 5f)]
	public float Value = 1.5f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Light_Rainbow2");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", Value);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Light/Water")]
public class CameraFilterPack_Light_Water : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	public float Size = 4f;

	[Range(0f, 2f)]
	public float Alpha = 0.07f;

	[Range(0f, 32f)]
	public float Distance = 10f;

	[Range(-2f, 2f)]
	public float Speed = 0.4f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Light_Water");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime * Speed;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Alpha", Alpha);
			material.SetFloat("_Distance", Distance);
			material.SetFloat("_Size", Size);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Light/Water2")]
public class CameraFilterPack_Light_Water2 : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 10f)]
	public float Speed = 0.2f;

	[Range(0f, 10f)]
	public float Speed_X = 0.2f;

	[Range(0f, 1f)]
	public float Speed_Y = 0.3f;

	[Range(0f, 10f)]
	public float Intensity = 2.4f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Light_Water2");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", Speed);
			material.SetFloat("_Value2", Speed_X);
			material.SetFloat("_Value3", Speed_Y);
			material.SetFloat("_Value4", Intensity);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Lut/Lut 2 Lut")]
public class CameraFilterPack_Lut_2_Lut : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Vector4 ScreenResolution;

	private Material SCMaterial;

	public Texture2D LutTexture;

	public Texture2D LutTexture2;

	private Texture3D converted3DLut;

	private Texture3D converted3DLut2;

	[Range(0f, 1f)]
	public float Blend = 1f;

	[Range(0f, 1f)]
	public float Fade = 1f;

	private string MemoPath;

	private string MemoPath2;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Lut_2_lut");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	public void SetIdentityLut()
	{
		int num = 16;
		Color[] array = new Color[num * num * num];
		float num2 = 1f / (1f * (float)num - 1f);
		for (int i = 0; i < num; i++)
		{
			for (int j = 0; j < num; j++)
			{
				for (int k = 0; k < num; k++)
				{
					array[i + j * num + k * num * num] = new Color((float)i * 1f * num2, (float)j * 1f * num2, (float)k * 1f * num2, 1f);
				}
			}
		}
		if ((bool)converted3DLut)
		{
			UnityEngine.Object.DestroyImmediate(converted3DLut);
		}
		converted3DLut = new Texture3D(num, num, num, TextureFormat.ARGB32, mipChain: false);
		converted3DLut.SetPixels(array);
		converted3DLut.Apply();
		if ((bool)converted3DLut2)
		{
			UnityEngine.Object.DestroyImmediate(converted3DLut2);
		}
		converted3DLut2 = new Texture3D(num, num, num, TextureFormat.ARGB32, mipChain: false);
		converted3DLut2.SetPixels(array);
		converted3DLut2.Apply();
	}

	public bool ValidDimensions(Texture2D tex2d)
	{
		if (!tex2d)
		{
			return false;
		}
		if (tex2d.height != Mathf.FloorToInt(Mathf.Sqrt(tex2d.width)))
		{
			return false;
		}
		return true;
	}

	public Texture3D Convert(Texture2D temp2DTex, Texture3D cv3D)
	{
		int num = 4096;
		if ((bool)temp2DTex)
		{
			num = temp2DTex.width * temp2DTex.height;
			num = temp2DTex.height;
			if (!ValidDimensions(temp2DTex))
			{
				UnityEngine.Debug.LogWarning("The given 2D texture " + temp2DTex.name + " cannot be used as a 3D LUT.");
				return cv3D;
			}
		}
		Color[] pixels = temp2DTex.GetPixels();
		Color[] array = new Color[pixels.Length];
		for (int i = 0; i < num; i++)
		{
			for (int j = 0; j < num; j++)
			{
				for (int k = 0; k < num; k++)
				{
					int num2 = num - j - 1;
					array[i + j * num + k * num * num] = pixels[k * num + i + num2 * num * num];
				}
			}
		}
		if ((bool)cv3D)
		{
			UnityEngine.Object.DestroyImmediate(cv3D);
		}
		cv3D = new Texture3D(num, num, num, TextureFormat.ARGB32, mipChain: false);
		cv3D.SetPixels(array);
		cv3D.Apply();
		return cv3D;
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null || !SystemInfo.supports3DTextures)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			if (converted3DLut == null)
			{
				if (!LutTexture)
				{
					SetIdentityLut();
				}
				if ((bool)LutTexture)
				{
					converted3DLut = Convert(LutTexture, converted3DLut);
				}
			}
			if (converted3DLut2 == null)
			{
				if (!LutTexture2)
				{
					SetIdentityLut();
				}
				if ((bool)LutTexture2)
				{
					converted3DLut2 = Convert(LutTexture2, converted3DLut2);
				}
			}
			if ((bool)LutTexture)
			{
				converted3DLut.wrapMode = TextureWrapMode.Clamp;
			}
			if ((bool)LutTexture2)
			{
				converted3DLut2.wrapMode = TextureWrapMode.Clamp;
			}
			material.SetFloat("_Blend", Blend);
			material.SetFloat("_Fade", Fade);
			material.SetTexture("_LutTex", converted3DLut);
			material.SetTexture("_LutTex2", converted3DLut2);
			Graphics.Blit(sourceTexture, destTexture, material, (QualitySettings.activeColorSpace == ColorSpace.Linear) ? 1 : 0);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void OnValidate()
	{
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Lut/Lut 2 Lut Extra")]
public class CameraFilterPack_Lut_2_Lut_Extra : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Vector4 ScreenResolution;

	private Material SCMaterial;

	public Texture2D LutTexture;

	public Texture2D LutTexture2;

	private Texture3D converted3DLut;

	private Texture3D converted3DLut2;

	[Range(0f, 1f)]
	public float FadeLut1 = 1f;

	[Range(0f, 1f)]
	public float FadeLut2 = 1f;

	[Range(0f, 1f)]
	public float Pos;

	[Range(0f, 1f)]
	public float Smooth = 1f;

	private string MemoPath;

	private string MemoPath2;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Lut_2_lut_Extra");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	public void SetIdentityLut()
	{
		int num = 16;
		Color[] array = new Color[num * num * num];
		float num2 = 1f / (1f * (float)num - 1f);
		for (int i = 0; i < num; i++)
		{
			for (int j = 0; j < num; j++)
			{
				for (int k = 0; k < num; k++)
				{
					array[i + j * num + k * num * num] = new Color((float)i * 1f * num2, (float)j * 1f * num2, (float)k * 1f * num2, 1f);
				}
			}
		}
		if ((bool)converted3DLut)
		{
			UnityEngine.Object.DestroyImmediate(converted3DLut);
		}
		converted3DLut = new Texture3D(num, num, num, TextureFormat.ARGB32, mipChain: false);
		converted3DLut.SetPixels(array);
		converted3DLut.Apply();
		if ((bool)converted3DLut2)
		{
			UnityEngine.Object.DestroyImmediate(converted3DLut2);
		}
		converted3DLut2 = new Texture3D(num, num, num, TextureFormat.ARGB32, mipChain: false);
		converted3DLut2.SetPixels(array);
		converted3DLut2.Apply();
	}

	public bool ValidDimensions(Texture2D tex2d)
	{
		if (!tex2d)
		{
			return false;
		}
		if (tex2d.height != Mathf.FloorToInt(Mathf.Sqrt(tex2d.width)))
		{
			return false;
		}
		return true;
	}

	public Texture3D Convert(Texture2D temp2DTex, Texture3D cv3D)
	{
		int num = 4096;
		if ((bool)temp2DTex)
		{
			num = temp2DTex.width * temp2DTex.height;
			num = temp2DTex.height;
			if (!ValidDimensions(temp2DTex))
			{
				UnityEngine.Debug.LogWarning("The given 2D texture " + temp2DTex.name + " cannot be used as a 3D LUT.");
				return cv3D;
			}
		}
		Color[] pixels = temp2DTex.GetPixels();
		Color[] array = new Color[pixels.Length];
		for (int i = 0; i < num; i++)
		{
			for (int j = 0; j < num; j++)
			{
				for (int k = 0; k < num; k++)
				{
					int num2 = num - j - 1;
					array[i + j * num + k * num * num] = pixels[k * num + i + num2 * num * num];
				}
			}
		}
		if ((bool)cv3D)
		{
			UnityEngine.Object.DestroyImmediate(cv3D);
		}
		cv3D = new Texture3D(num, num, num, TextureFormat.ARGB32, mipChain: false);
		cv3D.SetPixels(array);
		cv3D.Apply();
		return cv3D;
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null || !SystemInfo.supports3DTextures)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			if (converted3DLut == null)
			{
				if (!LutTexture)
				{
					SetIdentityLut();
				}
				if ((bool)LutTexture)
				{
					converted3DLut = Convert(LutTexture, converted3DLut);
				}
			}
			if (converted3DLut2 == null)
			{
				if (!LutTexture2)
				{
					SetIdentityLut();
				}
				if ((bool)LutTexture2)
				{
					converted3DLut2 = Convert(LutTexture2, converted3DLut2);
				}
			}
			if ((bool)LutTexture)
			{
				converted3DLut.wrapMode = TextureWrapMode.Clamp;
			}
			if ((bool)LutTexture2)
			{
				converted3DLut2.wrapMode = TextureWrapMode.Clamp;
			}
			material.SetFloat("_Fade", FadeLut1);
			material.SetFloat("_Fade2", FadeLut2);
			material.SetFloat("_Pos", Pos);
			material.SetFloat("_Smooth", Smooth);
			material.SetTexture("_LutTex", converted3DLut);
			material.SetTexture("_LutTex2", converted3DLut2);
			Graphics.Blit(sourceTexture, destTexture, material, (QualitySettings.activeColorSpace == ColorSpace.Linear) ? 1 : 0);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void OnValidate()
	{
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Lut/Mask")]
public class CameraFilterPack_Lut_Mask : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Vector4 ScreenResolution;

	private Material SCMaterial;

	public Texture2D LutTexture;

	private Texture3D converted3DLut;

	[Range(0f, 1f)]
	public float Blend = 1f;

	public Texture2D Mask;

	[Range(0f, 1f)]
	public float Inverse = 1f;

	private string MemoPath;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Lut_Mask");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	public void SetIdentityLut()
	{
		int num = 16;
		Color[] array = new Color[num * num * num];
		float num2 = 1f / (1f * (float)num - 1f);
		for (int i = 0; i < num; i++)
		{
			for (int j = 0; j < num; j++)
			{
				for (int k = 0; k < num; k++)
				{
					array[i + j * num + k * num * num] = new Color((float)i * 1f * num2, (float)j * 1f * num2, (float)k * 1f * num2, 1f);
				}
			}
		}
		if ((bool)converted3DLut)
		{
			UnityEngine.Object.DestroyImmediate(converted3DLut);
		}
		converted3DLut = new Texture3D(num, num, num, TextureFormat.ARGB32, mipChain: false);
		converted3DLut.SetPixels(array);
		converted3DLut.Apply();
	}

	public bool ValidDimensions(Texture2D tex2d)
	{
		if (!tex2d)
		{
			return false;
		}
		if (tex2d.height != Mathf.FloorToInt(Mathf.Sqrt(tex2d.width)))
		{
			return false;
		}
		return true;
	}

	public void Convert(Texture2D temp2DTex)
	{
		if ((bool)temp2DTex)
		{
			int num = temp2DTex.width * temp2DTex.height;
			num = temp2DTex.height;
			if (!ValidDimensions(temp2DTex))
			{
				UnityEngine.Debug.LogWarning("The given 2D texture " + temp2DTex.name + " cannot be used as a 3D LUT.");
				return;
			}
			Color[] pixels = temp2DTex.GetPixels();
			Color[] array = new Color[pixels.Length];
			for (int i = 0; i < num; i++)
			{
				for (int j = 0; j < num; j++)
				{
					for (int k = 0; k < num; k++)
					{
						int num2 = num - j - 1;
						array[i + j * num + k * num * num] = pixels[k * num + i + num2 * num * num];
					}
				}
			}
			if ((bool)converted3DLut)
			{
				UnityEngine.Object.DestroyImmediate(converted3DLut);
			}
			converted3DLut = new Texture3D(num, num, num, TextureFormat.ARGB32, mipChain: false);
			converted3DLut.SetPixels(array);
			converted3DLut.Apply();
		}
		else
		{
			SetIdentityLut();
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null || !SystemInfo.supports3DTextures)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			if (converted3DLut == null)
			{
				Convert(LutTexture);
			}
			converted3DLut.wrapMode = TextureWrapMode.Clamp;
			material.SetFloat("_Blend", Blend);
			material.SetTexture("_LutTex", converted3DLut);
			material.SetTexture("_MaskTex", Mask);
			material.SetFloat("_Inverse", Inverse);
			Graphics.Blit(sourceTexture, destTexture, material, (QualitySettings.activeColorSpace == ColorSpace.Linear) ? 1 : 0);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void OnValidate()
	{
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Lut/PlayWith")]
public class CameraFilterPack_Lut_PlayWith : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	public Texture2D LutTexture;

	private Texture3D converted3DLut;

	[Range(0f, 1f)]
	public float Blend = 1f;

	[Range(0f, 3f)]
	public float OriginalIntensity = 1f;

	[Range(-1f, 1f)]
	public float ResultIntensity;

	[Range(-1f, 1f)]
	public float FinalIntensity;

	private string MemoPath;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Lut_PlayWith");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	public void SetIdentityLut()
	{
		int num = 16;
		Color[] array = new Color[num * num * num];
		float num2 = 1f / (1f * (float)num - 1f);
		for (int i = 0; i < num; i++)
		{
			for (int j = 0; j < num; j++)
			{
				for (int k = 0; k < num; k++)
				{
					array[i + j * num + k * num * num] = new Color((float)i * 1f * num2, (float)j * 1f * num2, (float)k * 1f * num2, 1f);
				}
			}
		}
		if ((bool)converted3DLut)
		{
			UnityEngine.Object.DestroyImmediate(converted3DLut);
		}
		converted3DLut = new Texture3D(num, num, num, TextureFormat.ARGB32, mipChain: false);
		converted3DLut.SetPixels(array);
		converted3DLut.Apply();
	}

	public bool ValidDimensions(Texture2D tex2d)
	{
		if (!tex2d)
		{
			return false;
		}
		if (tex2d.height != Mathf.FloorToInt(Mathf.Sqrt(tex2d.width)))
		{
			return false;
		}
		return true;
	}

	public void Convert(Texture2D temp2DTex)
	{
		if ((bool)temp2DTex)
		{
			int num = temp2DTex.width * temp2DTex.height;
			num = temp2DTex.height;
			if (!ValidDimensions(temp2DTex))
			{
				UnityEngine.Debug.LogWarning("The given 2D texture " + temp2DTex.name + " cannot be used as a 3D LUT.");
				return;
			}
			Color[] pixels = temp2DTex.GetPixels();
			Color[] array = new Color[pixels.Length];
			for (int i = 0; i < num; i++)
			{
				for (int j = 0; j < num; j++)
				{
					for (int k = 0; k < num; k++)
					{
						int num2 = num - j - 1;
						array[i + j * num + k * num * num] = pixels[k * num + i + num2 * num * num];
					}
				}
			}
			if ((bool)converted3DLut)
			{
				UnityEngine.Object.DestroyImmediate(converted3DLut);
			}
			converted3DLut = new Texture3D(num, num, num, TextureFormat.ARGB32, mipChain: false);
			converted3DLut.SetPixels(array);
			converted3DLut.Apply();
		}
		else
		{
			SetIdentityLut();
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null || !SystemInfo.supports3DTextures)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			if (converted3DLut == null)
			{
				Convert(LutTexture);
			}
			converted3DLut.wrapMode = TextureWrapMode.Clamp;
			material.SetTexture("_LutTex", converted3DLut);
			material.SetFloat("_Blend", Blend);
			material.SetFloat("_Intensity", OriginalIntensity);
			material.SetFloat("_Extra", ResultIntensity);
			material.SetFloat("_Extra2", FinalIntensity);
			Graphics.Blit(sourceTexture, destTexture, material, (QualitySettings.activeColorSpace == ColorSpace.Linear) ? 1 : 0);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void OnValidate()
	{
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Lut/Plus")]
public class CameraFilterPack_Lut_Plus : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Vector4 ScreenResolution;

	private Material SCMaterial;

	public Texture2D LutTexture;

	private Texture3D converted3DLut;

	[Range(0f, 1f)]
	public float Blend = 1f;

	private string MemoPath;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Lut_Plus");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	public void SetIdentityLut()
	{
		int num = 16;
		Color[] array = new Color[num * num * num];
		float num2 = 1f / (1f * (float)num - 1f);
		for (int i = 0; i < num; i++)
		{
			for (int j = 0; j < num; j++)
			{
				for (int k = 0; k < num; k++)
				{
					array[i + j * num + k * num * num] = new Color((float)i * 1f * num2, (float)j * 1f * num2, (float)k * 1f * num2, 1f);
				}
			}
		}
		if ((bool)converted3DLut)
		{
			UnityEngine.Object.DestroyImmediate(converted3DLut);
		}
		converted3DLut = new Texture3D(num, num, num, TextureFormat.ARGB32, mipChain: false);
		converted3DLut.SetPixels(array);
		converted3DLut.Apply();
	}

	public bool ValidDimensions(Texture2D tex2d)
	{
		if (!tex2d)
		{
			return false;
		}
		if (tex2d.height != Mathf.FloorToInt(Mathf.Sqrt(tex2d.width)))
		{
			return false;
		}
		return true;
	}

	public void Convert(Texture2D temp2DTex)
	{
		if ((bool)temp2DTex)
		{
			int num = temp2DTex.width * temp2DTex.height;
			num = temp2DTex.height;
			if (!ValidDimensions(temp2DTex))
			{
				UnityEngine.Debug.LogWarning("The given 2D texture " + temp2DTex.name + " cannot be used as a 3D LUT.");
				return;
			}
			Color[] pixels = temp2DTex.GetPixels();
			Color[] array = new Color[pixels.Length];
			for (int i = 0; i < num; i++)
			{
				for (int j = 0; j < num; j++)
				{
					for (int k = 0; k < num; k++)
					{
						int num2 = num - j - 1;
						array[i + j * num + k * num * num] = pixels[k * num + i + num2 * num * num];
					}
				}
			}
			if ((bool)converted3DLut)
			{
				UnityEngine.Object.DestroyImmediate(converted3DLut);
			}
			converted3DLut = new Texture3D(num, num, num, TextureFormat.ARGB32, mipChain: false);
			converted3DLut.SetPixels(array);
			converted3DLut.Apply();
		}
		else
		{
			SetIdentityLut();
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null || !SystemInfo.supports3DTextures)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			if (converted3DLut == null)
			{
				Convert(LutTexture);
			}
			converted3DLut.wrapMode = TextureWrapMode.Clamp;
			material.SetFloat("_Blend", Blend);
			material.SetTexture("_LutTex", converted3DLut);
			Graphics.Blit(sourceTexture, destTexture, material, (QualitySettings.activeColorSpace == ColorSpace.Linear) ? 1 : 0);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void OnValidate()
	{
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Lut/Simple")]
public class CameraFilterPack_Lut_Simple : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	public Texture2D LutTexture;

	private Texture3D converted3DLut;

	private string MemoPath;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Lut_Simple");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	public void SetIdentityLut()
	{
		int num = 16;
		Color[] array = new Color[num * num * num];
		float num2 = 1f / (1f * (float)num - 1f);
		for (int i = 0; i < num; i++)
		{
			for (int j = 0; j < num; j++)
			{
				for (int k = 0; k < num; k++)
				{
					array[i + j * num + k * num * num] = new Color((float)i * 1f * num2, (float)j * 1f * num2, (float)k * 1f * num2, 1f);
				}
			}
		}
		if ((bool)converted3DLut)
		{
			UnityEngine.Object.DestroyImmediate(converted3DLut);
		}
		converted3DLut = new Texture3D(num, num, num, TextureFormat.ARGB32, mipChain: false);
		converted3DLut.SetPixels(array);
		converted3DLut.Apply();
	}

	public bool ValidDimensions(Texture2D tex2d)
	{
		if (!tex2d)
		{
			return false;
		}
		if (tex2d.height != Mathf.FloorToInt(Mathf.Sqrt(tex2d.width)))
		{
			return false;
		}
		return true;
	}

	public void Convert(Texture2D temp2DTex)
	{
		if ((bool)temp2DTex)
		{
			int num = temp2DTex.width * temp2DTex.height;
			num = temp2DTex.height;
			if (!ValidDimensions(temp2DTex))
			{
				UnityEngine.Debug.LogWarning("The given 2D texture " + temp2DTex.name + " cannot be used as a 3D LUT.");
				return;
			}
			Color[] pixels = temp2DTex.GetPixels();
			Color[] array = new Color[pixels.Length];
			for (int i = 0; i < num; i++)
			{
				for (int j = 0; j < num; j++)
				{
					for (int k = 0; k < num; k++)
					{
						int num2 = num - j - 1;
						array[i + j * num + k * num * num] = pixels[k * num + i + num2 * num * num];
					}
				}
			}
			if ((bool)converted3DLut)
			{
				UnityEngine.Object.DestroyImmediate(converted3DLut);
			}
			converted3DLut = new Texture3D(num, num, num, TextureFormat.ARGB32, mipChain: false);
			converted3DLut.SetPixels(array);
			converted3DLut.Apply();
		}
		else
		{
			SetIdentityLut();
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null || !SystemInfo.supports3DTextures)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			if (converted3DLut == null)
			{
				Convert(LutTexture);
			}
			converted3DLut.wrapMode = TextureWrapMode.Clamp;
			material.SetTexture("_LutTex", converted3DLut);
			Graphics.Blit(sourceTexture, destTexture, material, (QualitySettings.activeColorSpace == ColorSpace.Linear) ? 1 : 0);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void OnValidate()
	{
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Lut/TestMode")]
public class CameraFilterPack_Lut_TestMode : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	public Texture2D LutTexture;

	private Texture3D converted3DLut;

	[Range(0f, 1f)]
	public float Blend = 1f;

	[Range(0f, 3f)]
	public float OriginalIntensity = 1f;

	[Range(-1f, 1f)]
	public float ResultIntensity;

	[Range(-1f, 1f)]
	public float FinalIntensity;

	[Range(0f, 1f)]
	public float TestMode = 0.5f;

	private string MemoPath;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Lut_TestMode");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	public void SetIdentityLut()
	{
		int num = 16;
		Color[] array = new Color[num * num * num];
		float num2 = 1f / (1f * (float)num - 1f);
		for (int i = 0; i < num; i++)
		{
			for (int j = 0; j < num; j++)
			{
				for (int k = 0; k < num; k++)
				{
					array[i + j * num + k * num * num] = new Color((float)i * 1f * num2, (float)j * 1f * num2, (float)k * 1f * num2, 1f);
				}
			}
		}
		if ((bool)converted3DLut)
		{
			UnityEngine.Object.DestroyImmediate(converted3DLut);
		}
		converted3DLut = new Texture3D(num, num, num, TextureFormat.ARGB32, mipChain: false);
		converted3DLut.SetPixels(array);
		converted3DLut.Apply();
	}

	public bool ValidDimensions(Texture2D tex2d)
	{
		if (!tex2d)
		{
			return false;
		}
		if (tex2d.height != Mathf.FloorToInt(Mathf.Sqrt(tex2d.width)))
		{
			return false;
		}
		return true;
	}

	public void Convert(Texture2D temp2DTex)
	{
		if ((bool)temp2DTex)
		{
			int num = temp2DTex.width * temp2DTex.height;
			num = temp2DTex.height;
			if (!ValidDimensions(temp2DTex))
			{
				UnityEngine.Debug.LogWarning("The given 2D texture " + temp2DTex.name + " cannot be used as a 3D LUT.");
				return;
			}
			Color[] pixels = temp2DTex.GetPixels();
			Color[] array = new Color[pixels.Length];
			for (int i = 0; i < num; i++)
			{
				for (int j = 0; j < num; j++)
				{
					for (int k = 0; k < num; k++)
					{
						int num2 = num - j - 1;
						array[i + j * num + k * num * num] = pixels[k * num + i + num2 * num * num];
					}
				}
			}
			if ((bool)converted3DLut)
			{
				UnityEngine.Object.DestroyImmediate(converted3DLut);
			}
			converted3DLut = new Texture3D(num, num, num, TextureFormat.ARGB32, mipChain: false);
			converted3DLut.SetPixels(array);
			converted3DLut.Apply();
		}
		else
		{
			SetIdentityLut();
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null || !SystemInfo.supports3DTextures)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			if (converted3DLut == null)
			{
				Convert(LutTexture);
			}
			converted3DLut.wrapMode = TextureWrapMode.Clamp;
			material.SetTexture("_LutTex", converted3DLut);
			material.SetFloat("_Blend", Blend);
			material.SetFloat("_Intensity", OriginalIntensity);
			material.SetFloat("_Extra", ResultIntensity);
			material.SetFloat("_Extra2", FinalIntensity);
			material.SetFloat("_Extra3", TestMode);
			Graphics.Blit(sourceTexture, destTexture, material, (QualitySettings.activeColorSpace == ColorSpace.Linear) ? 1 : 0);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void OnValidate()
	{
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Glitch/NewGlitch1")]
public class CameraFilterPack_NewGlitch1 : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	public float _Seed = 1f;

	[Range(0f, 1f)]
	public float _Size = 1f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/CameraFilterPack_NewGlitch1");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("Seed", _Seed);
			material.SetFloat("Size", _Size);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Glitch/NewGlitch2")]
public class CameraFilterPack_NewGlitch2 : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	public float __Speed = 1f;

	[Range(0f, 1f)]
	public float _RedFade = 1f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/CameraFilterPack_NewGlitch2");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Speed", __Speed);
			material.SetFloat("RedFade", _RedFade);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Glitch/NewGlitch3")]
public class CameraFilterPack_NewGlitch3 : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	public float __Speed = 1f;

	[Range(0f, 1f)]
	public float _RedFade = 1f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/CameraFilterPack_NewGlitch3");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Speed", __Speed);
			material.SetFloat("RedFade", _RedFade);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Glitch/NewGlitch4")]
public class CameraFilterPack_NewGlitch4 : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	public float __Speed = 1f;

	[Range(0f, 1f)]
	public float _Fade = 1f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/CameraFilterPack_NewGlitch4");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Speed", __Speed);
			material.SetFloat("Fade", _Fade);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Glitch/NewGlitch5")]
public class CameraFilterPack_NewGlitch5 : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	public float __Speed = 1f;

	[Range(0f, 1f)]
	public float _Fade = 1f;

	[Range(0f, 1f)]
	public float _Parasite = 1f;

	[Range(0f, 0f)]
	public float _ZoomX = 1f;

	[Range(0f, 0f)]
	public float _ZoomY = 1f;

	[Range(0f, 0f)]
	public float _PosX = 1f;

	[Range(0f, 0f)]
	public float _PosY = 1f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/CameraFilterPack_NewGlitch5");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Speed", __Speed);
			material.SetFloat("Fade", _Fade);
			material.SetFloat("Parasite", _Parasite);
			material.SetFloat("ZoomX", _ZoomX);
			material.SetFloat("ZoomY", _ZoomY);
			material.SetFloat("PosX", _PosX);
			material.SetFloat("PosY", _PosY);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Glitch/NewGlitch6")]
public class CameraFilterPack_NewGlitch6 : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	public float __Speed = 1f;

	[Range(0f, 1f)]
	public float _FadeLight = 1f;

	[Range(0f, 1f)]
	public float _FadeDark = 1f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/CameraFilterPack_NewGlitch6");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Speed", __Speed);
			material.SetFloat("FadeLight", _FadeLight);
			material.SetFloat("FadeDark", _FadeDark);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Glitch/Glitch Drawing")]
public class CameraFilterPack_NewGlitch7 : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	public float __Speed = 1f;

	[Range(0f, 1f)]
	public float _LightMin;

	[Range(0f, 1f)]
	public float _LightMax = 1f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/CameraFilterPack_NewGlitch7");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Speed", __Speed);
			material.SetFloat("LightMin", _LightMin);
			material.SetFloat("LightMax", _LightMax);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Night Vision/Night Vision FX")]
public class CameraFilterPack_NightVisionFX : MonoBehaviour
{
	public enum preset
	{
		Night_Vision_Personalized = -1,
		Night_Vision_FX,
		Night_Vision_Classic,
		Night_Vision_Full,
		Night_Vision_Dark,
		Night_Vision_Sharp,
		Night_Vision_BlueSky,
		Night_Vision_Low_Light,
		Night_Vision_Pinky,
		Night_Vision_RedBurn,
		Night_Vision_PurpleShadow
	}

	public Shader SCShader;

	public preset Preset;

	private preset PresetMemo;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	public float OnOff;

	[Range(0.2f, 2f)]
	public float Greenness = 1f;

	[Range(0f, 1f)]
	public float Vignette = 1f;

	[Range(0f, 1f)]
	public float Vignette_Alpha = 1f;

	[Range(-10f, 10f)]
	public float Distortion = 1f;

	[Range(0f, 1f)]
	public float Noise = 1f;

	[Range(-2f, 1f)]
	public float Intensity = -1f;

	[Range(0f, 2f)]
	public float Light = 1f;

	[Range(0f, 1f)]
	public float Light2 = 1f;

	[Range(0f, 2f)]
	public float Line = 1f;

	[Range(-2f, 2f)]
	public float Color_R;

	[Range(-2f, 2f)]
	public float Color_G;

	[Range(-2f, 2f)]
	public float Color_B;

	[Range(0f, 1f)]
	public float _Binocular_Size = 0.499f;

	[Range(0f, 1f)]
	public float _Binocular_Smooth = 0.113f;

	[Range(0f, 1f)]
	public float _Binocular_Dist = 0.286f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/NightVisionFX");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_OnOff", OnOff);
			material.SetFloat("_Greenness", Greenness);
			material.SetFloat("_Vignette", Vignette);
			material.SetFloat("_Vignette_Alpha", Vignette_Alpha);
			material.SetFloat("_Distortion", Distortion);
			material.SetFloat("_Noise", Noise);
			material.SetFloat("_Intensity", Intensity);
			material.SetFloat("_Light", Light);
			material.SetFloat("_Light2", Light2);
			material.SetFloat("_Line", Line);
			material.SetFloat("_Color_R", Color_R);
			material.SetFloat("_Color_G", Color_G);
			material.SetFloat("_Color_B", Color_B);
			material.SetFloat("_Size", _Binocular_Size);
			material.SetFloat("_Dist", _Binocular_Dist);
			material.SetFloat("_Smooth", _Binocular_Smooth);
			material.SetVector("_ScreenResolution", new Vector2(Screen.width, Screen.height));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
		if (PresetMemo != Preset)
		{
			PresetMemo = Preset;
			float[] array = new float[12]
			{
				0.757f, 0.098f, 0.458f, -2.49f, 0.559f, -0.298f, 1.202f, 0.515f, 1f, 0f,
				0f, 0f
			};
			float[] array2 = new float[12]
			{
				0.2f, 0.202f, 0.68f, -1.49f, 0.084f, -0.019f, 2f, 0.166f, 1.948f, -0.1f,
				0.15f, -0.07f
			};
			float[] array3 = new float[12]
			{
				1.45f, 0.01f, 0.112f, -0.07f, 0.111f, -0.077f, 0.071f, 0f, 0.245f, 0f,
				0f, 0f
			};
			float[] array4 = new float[12]
			{
				0.779f, 0.185f, 0.706f, 1.21f, 0.24f, 0.138f, 2f, 0.07f, 1.224f, -0.21f,
				-0.34f, 0f
			};
			float[] array5 = new float[12]
			{
				0.2f, 0.028f, 0.706f, 1.21f, 0.397f, -0.24f, 2f, 0.298f, 1.224f, -0.08f,
				0.48f, -0.57f
			};
			float[] array6 = new float[12]
			{
				0.2f, 0.159f, 0.622f, -2.28f, 0.409f, -0.24f, 0.166f, 0.028f, 2f, -0.08f,
				0.22f, 0.57f
			};
			float[] array7 = new float[12]
			{
				2f, 0.054f, 1f, -2.28f, 0.409f, -1f, 2f, 0.187f, 0.241f, 0f,
				1.58f, 0.21f
			};
			float[] array8 = new float[12]
			{
				2f, 0.054f, 1f, 1.28f, 0.409f, -1f, 0.41f, 0.656f, 0.427f, 0.95f,
				-0.35f, 1.41f
			};
			float[] array9 = new float[12]
			{
				2f, 0.281f, 0.156f, 1.85f, 0.709f, -1f, 0.41f, 0.109f, 0.34f, 0.95f,
				0.36f, -0.14f
			};
			float[] array10 = new float[12]
			{
				0.905f, 0.281f, 0.156f, 1.85f, 0.558f, -0.974f, 1.639f, 0.252f, 1.074f, 0.46f,
				0.95f, 0.58f
			};
			float[] array11 = new float[12];
			if (Preset == preset.Night_Vision_FX)
			{
				array11 = array;
			}
			if (Preset == preset.Night_Vision_Classic)
			{
				array11 = array2;
			}
			if (Preset == preset.Night_Vision_Full)
			{
				array11 = array3;
			}
			if (Preset == preset.Night_Vision_Dark)
			{
				array11 = array4;
			}
			if (Preset == preset.Night_Vision_Sharp)
			{
				array11 = array5;
			}
			if (Preset == preset.Night_Vision_BlueSky)
			{
				array11 = array6;
			}
			if (Preset == preset.Night_Vision_Low_Light)
			{
				array11 = array7;
			}
			if (Preset == preset.Night_Vision_Pinky)
			{
				array11 = array8;
			}
			if (Preset == preset.Night_Vision_RedBurn)
			{
				array11 = array9;
			}
			if (Preset == preset.Night_Vision_PurpleShadow)
			{
				array11 = array10;
			}
			if (Preset != preset.Night_Vision_Personalized)
			{
				Greenness = array11[0];
				Vignette = array11[1];
				Vignette_Alpha = array11[2];
				Distortion = array11[3];
				Noise = array11[4];
				Intensity = array11[5];
				Light = array11[6];
				Light2 = array11[7];
				Line = array11[8];
				Color_R = array11[9];
				Color_G = array11[10];
				Color_B = array11[11];
			}
		}
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Night Vision/Night Vision 4")]
public class CameraFilterPack_NightVision_4 : MonoBehaviour
{
	private string ShaderName = "CameraFilterPack/NightVision_4";

	public Shader SCShader;

	[Range(0f, 1f)]
	public float FadeFX = 1f;

	private float TimeX = 1f;

	private Material SCMaterial;

	private float[] Matrix9;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void ChangeFilters()
	{
		Matrix9 = new float[12]
		{
			200f, -200f, -200f, 195f, 4f, -160f, 200f, -200f, -200f, -200f,
			10f, -200f
		};
	}

	private void Start()
	{
		ChangeFilters();
		SCShader = Shader.Find(ShaderName);
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Red_R", Matrix9[0] / 100f);
			material.SetFloat("_Red_G", Matrix9[1] / 100f);
			material.SetFloat("_Red_B", Matrix9[2] / 100f);
			material.SetFloat("_Green_R", Matrix9[3] / 100f);
			material.SetFloat("_Green_G", Matrix9[4] / 100f);
			material.SetFloat("_Green_B", Matrix9[5] / 100f);
			material.SetFloat("_Blue_R", Matrix9[6] / 100f);
			material.SetFloat("_Blue_G", Matrix9[7] / 100f);
			material.SetFloat("_Blue_B", Matrix9[8] / 100f);
			material.SetFloat("_Red_C", Matrix9[9] / 100f);
			material.SetFloat("_Green_C", Matrix9[10] / 100f);
			material.SetFloat("_Blue_C", Matrix9[11] / 100f);
			material.SetFloat("_FadeFX", FadeFX);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void OnValidate()
	{
		ChangeFilters();
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Noise/TV")]
public class CameraFilterPack_Noise_TV : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	public float Fade = 1f;

	[Range(0f, 10f)]
	private float Value2 = 1f;

	[Range(0f, 10f)]
	private float Value3 = 1f;

	[Range(0f, 10f)]
	private float Value4 = 1f;

	private Texture2D Texture2;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		Texture2 = Resources.Load("CameraFilterPack_TV_Noise") as Texture2D;
		SCShader = Shader.Find("CameraFilterPack/Noise_TV");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", Fade);
			material.SetFloat("_Value2", Value2);
			material.SetFloat("_Value3", Value3);
			material.SetFloat("_Value4", Value4);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			material.SetTexture("Texture2", Texture2);
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Noise/TV_2")]
public class CameraFilterPack_Noise_TV_2 : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	public float Fade = 1f;

	[Range(0f, 1f)]
	public float Fade_Additive;

	[Range(0f, 1f)]
	public float Fade_Distortion;

	[Range(0f, 10f)]
	private float Value4 = 1f;

	private Texture2D Texture2;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		Texture2 = Resources.Load("CameraFilterPack_TV_Noise2") as Texture2D;
		SCShader = Shader.Find("CameraFilterPack/Noise_TV_2");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", Fade);
			material.SetFloat("_Value2", Fade_Additive);
			material.SetFloat("_Value3", Fade_Distortion);
			material.SetFloat("_Value4", Value4);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			material.SetTexture("Texture2", Texture2);
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Noise/TV_3")]
public class CameraFilterPack_Noise_TV_3 : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	public float Fade = 1f;

	[Range(0f, 1f)]
	public float Fade_Additive;

	[Range(0f, 1f)]
	public float Fade_Distortion;

	[Range(0f, 10f)]
	private float Value4 = 1f;

	private Texture2D Texture2;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		Texture2 = Resources.Load("CameraFilterPack_TV_Noise3") as Texture2D;
		SCShader = Shader.Find("CameraFilterPack/Noise_TV_3");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", Fade);
			material.SetFloat("_Value2", Fade_Additive);
			material.SetFloat("_Value3", Fade_Distortion);
			material.SetFloat("_Value4", Value4);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			material.SetTexture("Texture2", Texture2);
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Night Vision/Night Vision 1")]
public class CameraFilterPack_Oculus_NightVision1 : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private float Distortion = 1f;

	private Material SCMaterial;

	[Range(0f, 100f)]
	public float Vignette = 1.3f;

	[Range(1f, 150f)]
	public float Linecount = 90f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Oculus_NightVision1");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Distortion", Distortion);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			material.SetFloat("_Vignette", Vignette);
			material.SetFloat("_Linecount", Linecount);
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Night Vision/Night Vision 2")]
public class CameraFilterPack_Oculus_NightVision2 : MonoBehaviour
{
	private string ShaderName = "CameraFilterPack/Oculus_NightVision2";

	public Shader SCShader;

	[Range(0f, 1f)]
	public float FadeFX = 1f;

	private float TimeX = 1f;

	private Material SCMaterial;

	private float[] Matrix9;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void ChangeFilters()
	{
		Matrix9 = new float[12]
		{
			200f, -200f, -200f, 195f, 4f, -160f, 200f, -200f, -200f, -200f,
			10f, -200f
		};
	}

	private void Start()
	{
		ChangeFilters();
		SCShader = Shader.Find(ShaderName);
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Red_R", Matrix9[0] / 100f);
			material.SetFloat("_Red_G", Matrix9[1] / 100f);
			material.SetFloat("_Red_B", Matrix9[2] / 100f);
			material.SetFloat("_Green_R", Matrix9[3] / 100f);
			material.SetFloat("_Green_G", Matrix9[4] / 100f);
			material.SetFloat("_Green_B", Matrix9[5] / 100f);
			material.SetFloat("_Blue_R", Matrix9[6] / 100f);
			material.SetFloat("_Blue_G", Matrix9[7] / 100f);
			material.SetFloat("_Blue_B", Matrix9[8] / 100f);
			material.SetFloat("_Red_C", Matrix9[9] / 100f);
			material.SetFloat("_Green_C", Matrix9[10] / 100f);
			material.SetFloat("_Blue_C", Matrix9[11] / 100f);
			material.SetFloat("_FadeFX", FadeFX);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void OnValidate()
	{
		ChangeFilters();
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Night Vision/Night Vision 3")]
public class CameraFilterPack_Oculus_NightVision3 : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0.2f, 2f)]
	public float Greenness = 1f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Oculus_NightVision3");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Greenness", Greenness);
			material.SetVector("_ScreenResolution", new Vector2(Screen.width, Screen.height));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Night Vision/Night Vision 5")]
public class CameraFilterPack_Oculus_NightVision5 : MonoBehaviour
{
	private string ShaderName = "CameraFilterPack/Oculus_NightVision5";

	public Shader SCShader;

	[Range(0f, 1f)]
	public float FadeFX = 1f;

	[Range(0f, 1f)]
	public float _Size = 0.37f;

	[Range(0f, 1f)]
	public float _Smooth = 0.15f;

	[Range(0f, 1f)]
	public float _Dist = 0.285f;

	private float TimeX = 1f;

	private Material SCMaterial;

	private float[] Matrix9;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void ChangeFilters()
	{
		Matrix9 = new float[12]
		{
			200f, -200f, -200f, 195f, 4f, -160f, 200f, -200f, -200f, -200f,
			10f, -200f
		};
	}

	private void Start()
	{
		ChangeFilters();
		SCShader = Shader.Find(ShaderName);
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Red_R", Matrix9[0] / 100f);
			material.SetFloat("_Red_G", Matrix9[1] / 100f);
			material.SetFloat("_Red_B", Matrix9[2] / 100f);
			material.SetFloat("_Green_R", Matrix9[3] / 100f);
			material.SetFloat("_Green_G", Matrix9[4] / 100f);
			material.SetFloat("_Green_B", Matrix9[5] / 100f);
			material.SetFloat("_Blue_R", Matrix9[6] / 100f);
			material.SetFloat("_Blue_G", Matrix9[7] / 100f);
			material.SetFloat("_Blue_B", Matrix9[8] / 100f);
			material.SetFloat("_Red_C", Matrix9[9] / 100f);
			material.SetFloat("_Green_C", Matrix9[10] / 100f);
			material.SetFloat("_Blue_C", Matrix9[11] / 100f);
			material.SetFloat("_FadeFX", FadeFX);
			material.SetFloat("_Size", _Size);
			material.SetFloat("_Dist", _Dist);
			material.SetFloat("_Smooth", _Smooth);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void OnValidate()
	{
		ChangeFilters();
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Vision/ThermaVision")]
public class CameraFilterPack_Oculus_ThermaVision : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	public float Therma_Variation = 0.5f;

	[Range(0f, 8f)]
	private float Contrast = 3f;

	[Range(0f, 4f)]
	private float Burn;

	[Range(0f, 16f)]
	private float SceneCut = 1f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Oculus_ThermaVision");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", Therma_Variation);
			material.SetFloat("_Value2", Contrast);
			material.SetFloat("_Value3", Burn);
			material.SetFloat("_Value4", SceneCut);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Old Film/Cutting 1")]
public class CameraFilterPack_OldFilm_Cutting1 : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	[Range(0f, 10f)]
	public float Speed = 1f;

	[Range(0f, 2f)]
	public float Luminosity = 1.5f;

	[Range(0f, 1f)]
	public float Vignette = 1f;

	[Range(0f, 2f)]
	public float Negative;

	private Material SCMaterial;

	private Texture2D Texture2;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		Texture2 = Resources.Load("CameraFilterPack_OldFilm1") as Texture2D;
		SCShader = Shader.Find("CameraFilterPack/OldFilm_Cutting1");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", Luminosity);
			material.SetFloat("_Value2", 1f - Vignette);
			material.SetFloat("_Value3", Negative);
			material.SetFloat("_Speed", Speed);
			material.SetTexture("_MainTex2", Texture2);
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Old Film/Cutting 2")]
public class CameraFilterPack_OldFilm_Cutting2 : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	[Range(0f, 10f)]
	public float Speed = 5f;

	[Range(0f, 2f)]
	public float Luminosity = 1f;

	[Range(0f, 1f)]
	public float Vignette = 1f;

	[Range(0f, 1f)]
	public float Negative;

	private Material SCMaterial;

	private Texture2D Texture2;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		Texture2 = Resources.Load("CameraFilterPack_OldFilm2") as Texture2D;
		SCShader = Shader.Find("CameraFilterPack/OldFilm_Cutting2");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", 2f - Luminosity);
			material.SetFloat("_Value2", 1f - Vignette);
			material.SetFloat("_Value3", Negative);
			material.SetFloat("_Speed", Speed);
			material.SetTexture("_MainTex2", Texture2);
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Pixel/Pixelisation")]
public class CameraFilterPack_Pixel_Pixelisation : MonoBehaviour
{
	public Shader SCShader;

	[Range(0.6f, 120f)]
	public float _Pixelisation = 8f;

	[Range(0.6f, 120f)]
	public float _SizeX = 1f;

	[Range(0.6f, 120f)]
	public float _SizeY = 1f;

	private Material SCMaterial;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Pixel_Pixelisation");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			material.SetFloat("_Val", _Pixelisation);
			material.SetFloat("_Val2", _SizeX);
			material.SetFloat("_Val3", _SizeY);
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Pixelisation/Deep OilPaint HQ")]
public class CameraFilterPack_Pixelisation_DeepOilPaintHQ : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	public bool _Visualize;

	private Material SCMaterial;

	[Range(0f, 100f)]
	public float _FixDistance = 1.5f;

	[Range(-0.99f, 0.99f)]
	public float _Distance = 0.4f;

	[Range(0f, 0.5f)]
	public float _Size = 0.5f;

	[Range(0f, 8f)]
	public float Intensity = 1f;

	public bool AutoAnimatedNear;

	[Range(-5f, 5f)]
	public float AutoAnimatedNearSpeed = 0.5f;

	public static Color ChangeColorRGB;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Deep_OilPaintHQ");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			if (AutoAnimatedNear)
			{
				_Distance += Time.deltaTime * AutoAnimatedNearSpeed;
				if (_Distance > 1f)
				{
					_Distance = -1f;
				}
				if (_Distance < -1f)
				{
					_Distance = 1f;
				}
				material.SetFloat("_Near", _Distance);
			}
			else
			{
				material.SetFloat("_Near", _Distance);
			}
			material.SetFloat("_Far", _Size);
			material.SetFloat("_FixDistance", _FixDistance);
			material.SetFloat("_LightIntensity", Intensity);
			material.SetFloat("_Visualize", _Visualize ? 1 : 0);
			float farClipPlane = GetComponent<Camera>().farClipPlane;
			material.SetFloat("_FarCamera", 1000f / farClipPlane);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			GetComponent<Camera>().depthTextureMode = DepthTextureMode.Depth;
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Pixelisation/Dot")]
public class CameraFilterPack_Pixelisation_Dot : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0.0001f, 0.5f)]
	public float Size = 0.005f;

	[Range(0f, 1f)]
	public float LightBackGround = 0.3f;

	[Range(0f, 10f)]
	private float Speed = 1f;

	[Range(0f, 10f)]
	private float Size2 = 1f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Pixelisation_Dot");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", Size);
			material.SetFloat("_Value2", LightBackGround);
			material.SetFloat("_Value3", Speed);
			material.SetFloat("_Value4", Size2);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Pixelisation/OilPaint")]
public class CameraFilterPack_Pixelisation_OilPaint : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 5f)]
	public float Value = 1f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Pixelisation_OilPaint");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			material.SetFloat("_Value", Value);
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Pixelisation/OilPaintHQ")]
public class CameraFilterPack_Pixelisation_OilPaintHQ : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 5f)]
	public float Value = 2f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Pixelisation_OilPaintHQ");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			material.SetFloat("_Value", Value);
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Pixelisation/Pixelisation_Sweater")]
public class CameraFilterPack_Pixelisation_Sweater : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(16f, 128f)]
	public float SweaterSize = 64f;

	[Range(0f, 2f)]
	public float _Intensity = 1.4f;

	[Range(0f, 1f)]
	public float Fade = 1f;

	private Texture2D Texture2;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		Texture2 = Resources.Load("CameraFilterPack_Sweater") as Texture2D;
		SCShader = Shader.Find("CameraFilterPack/Pixelisation_Sweater");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Fade", Fade);
			material.SetFloat("_SweaterSize", SweaterSize);
			material.SetFloat("_Intensity", _Intensity);
			material.SetTexture("Texture2", Texture2);
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Weather/New Rain FX")]
public class CameraFilterPack_Rain_RainFX : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(-8f, 8f)]
	public float Speed = 1f;

	[Range(0f, 1f)]
	public float Fade = 1f;

	[HideInInspector]
	public int Count;

	private Vector4[] Coord = new Vector4[4];

	public static Color ChangeColorRGB;

	private Texture2D Texture2;

	private Texture2D Texture3;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		Texture2 = Resources.Load("CameraFilterPack_RainFX_Anm2") as Texture2D;
		Texture3 = Resources.Load("CameraFilterPack_RainFX_Anm") as Texture2D;
		SCShader = Shader.Find("CameraFilterPack/RainFX");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", Fade);
			material.SetFloat("_Speed", Speed);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			GetComponent<Camera>().depthTextureMode = DepthTextureMode.Depth;
			AnimationCurve animationCurve = new AnimationCurve();
			animationCurve = new AnimationCurve();
			animationCurve.AddKey(0f, 0.01f);
			animationCurve.AddKey(64f, 5f);
			animationCurve.AddKey(128f, 80f);
			animationCurve.AddKey(255f, 255f);
			animationCurve.AddKey(300f, 255f);
			for (int i = 0; i < 4; i++)
			{
				Coord[i].z += 0.5f;
				if (Coord[i].w == -1f)
				{
					Coord[i].x = -5f;
				}
				if (Coord[i].z > 254f)
				{
					Coord[i] = new Vector4(UnityEngine.Random.Range(0f, 0.9f), UnityEngine.Random.Range(0.2f, 1.1f), 0f, UnityEngine.Random.Range(0, 3));
				}
				material.SetVector("Coord" + (i + 1), new Vector4(Coord[i].x, Coord[i].y, (int)animationCurve.Evaluate(Coord[i].z), Coord[i].w));
			}
			material.SetTexture("Texture2", Texture2);
			material.SetTexture("Texture3", Texture3);
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/VHS/Real VHS HQ")]
public class CameraFilterPack_Real_VHS : MonoBehaviour
{
	public Shader SCShader;

	private Material SCMaterial;

	private Texture2D VHS;

	private Texture2D VHS2;

	[Range(0f, 1f)]
	public float TRACKING = 0.212f;

	[Range(0f, 1f)]
	public float JITTER = 1f;

	[Range(0f, 1f)]
	public float GLITCH = 1f;

	[Range(0f, 1f)]
	public float NOISE = 1f;

	[Range(-1f, 1f)]
	public float Brightness;

	[Range(0f, 1.5f)]
	public float Constrast = 1f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Real_VHS");
		VHS = Resources.Load("CameraFilterPack_VHS1") as Texture2D;
		VHS2 = Resources.Load("CameraFilterPack_VHS2") as Texture2D;
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	public static Texture2D GetRTPixels(Texture2D t, RenderTexture rt, int sx, int sy)
	{
		RenderTexture active = RenderTexture.active;
		RenderTexture.active = rt;
		t.ReadPixels(new Rect(0f, 0f, t.width, t.height), 0, 0);
		RenderTexture.active = active;
		return t;
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			material.SetTexture("VHS", VHS);
			material.SetTexture("VHS2", VHS2);
			material.SetFloat("TRACKING", TRACKING);
			material.SetFloat("JITTER", JITTER);
			material.SetFloat("GLITCH", GLITCH);
			material.SetFloat("NOISE", NOISE);
			material.SetFloat("Brightness", Brightness);
			material.SetFloat("CONTRAST", 1f - Constrast);
			int height = 576;
			RenderTexture temporary = RenderTexture.GetTemporary(382, height, 0);
			temporary.filterMode = FilterMode.Trilinear;
			Graphics.Blit(sourceTexture, temporary, material);
			Graphics.Blit(temporary, destTexture);
			RenderTexture.ReleaseTemporary(temporary);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Retro/Loading")]
public class CameraFilterPack_Retro_Loading : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0.1f, 10f)]
	public float Speed = 1f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Retro_Loading");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", Speed);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Sharpen/Sharpen")]
public class CameraFilterPack_Sharpen_Sharpen : MonoBehaviour
{
	public Shader SCShader;

	[Range(0.001f, 100f)]
	public float Value = 4f;

	[Range(0.001f, 32f)]
	public float Value2 = 1f;

	private float TimeX = 1f;

	private Material SCMaterial;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Sharpen_Sharpen");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			material.SetFloat("_Value", Value);
			material.SetFloat("_Value2", Value2);
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Special/Bubble")]
public class CameraFilterPack_Special_Bubble : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(-4f, 4f)]
	public float X = 0.5f;

	[Range(-4f, 4f)]
	public float Y = 0.5f;

	[Range(0f, 5f)]
	public float Rate = 1f;

	[Range(0f, 10f)]
	private float Value4 = 1f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Special_Bubble");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", X);
			material.SetFloat("_Value2", Y);
			material.SetFloat("_Value3", Rate);
			material.SetFloat("_Value4", Value4);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/TV/50s")]
public class CameraFilterPack_TV_50 : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	public float Fade = 1f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/TV_50");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Fade", Fade);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/TV/80s")]
public class CameraFilterPack_TV_80 : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	public float Fade = 1f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/TV_80");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Fade", Fade);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/TV/ARCADE")]
public class CameraFilterPack_TV_ARCADE : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	public float Fade = 1f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/TV_ARCADE");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("Fade", Fade);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/TV/ARCADE_2")]
public class CameraFilterPack_TV_ARCADE_2 : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 10f)]
	public float Interferance_Size = 1f;

	[Range(0f, 10f)]
	public float Interferance_Speed = 0.5f;

	[Range(0f, 10f)]
	public float Contrast = 1f;

	[Range(0f, 1f)]
	public float Fade = 1f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/TV_ARCADE_2");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", Interferance_Size);
			material.SetFloat("_Value2", Interferance_Speed);
			material.SetFloat("_Value3", Contrast);
			material.SetFloat("Fade", Fade);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/TV/ARCADE_Fast")]
public class CameraFilterPack_TV_ARCADE_Fast : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 0.05f)]
	public float Interferance_Size = 0.02f;

	[Range(0f, 4f)]
	public float Interferance_Speed = 0.5f;

	[Range(0f, 10f)]
	public float Contrast = 1f;

	[Range(0f, 1f)]
	public float Fade = 1f;

	private Texture2D Texture2;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		Texture2 = Resources.Load("CameraFilterPack_TV_Arcade1") as Texture2D;
		SCShader = Shader.Find("CameraFilterPack/TV_ARCADE_Fast");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", Interferance_Size);
			material.SetFloat("_Value2", Interferance_Speed);
			material.SetFloat("_Value3", Contrast);
			material.SetFloat("Fade", Fade);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			material.SetTexture("_MainTex2", Texture2);
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/TV/Artefact")]
public class CameraFilterPack_TV_Artefact : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	[Range(0f, 1f)]
	public float Fade = 1f;

	[Range(-10f, 10f)]
	public float Colorisation = 1f;

	[Range(-10f, 10f)]
	public float Parasite = 1f;

	[Range(-10f, 10f)]
	public float Noise = 1f;

	private Material SCMaterial;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/TV_Artefact");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Colorisation", Colorisation);
			material.SetFloat("_Parasite", Parasite);
			material.SetFloat("_Noise", Noise);
			material.SetFloat("Fade", Fade);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/TV/Broken Glass")]
public class CameraFilterPack_TV_BrokenGlass : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	[Range(0f, 128f)]
	public float Broken_Small;

	[Range(0f, 128f)]
	public float Broken_Medium;

	[Range(0f, 128f)]
	public float Broken_High;

	[Range(0f, 128f)]
	public float Broken_Big = 1f;

	[Range(0f, 0.004f)]
	public float LightReflect = 0.002f;

	private Material SCMaterial;

	private Texture2D Texture2;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		Texture2 = Resources.Load("CameraFilterPack_TV_BrokenGlass1") as Texture2D;
		SCShader = Shader.Find("CameraFilterPack/TV_BrokenGlass");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", LightReflect);
			material.SetFloat("_Value2", Broken_Small);
			material.SetFloat("_Value3", Broken_Medium);
			material.SetFloat("_Value4", Broken_High);
			material.SetFloat("_Value5", Broken_Big);
			material.SetTexture("_MainTex2", Texture2);
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/TV/Broken Glass2")]
public class CameraFilterPack_TV_BrokenGlass2 : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	[Range(0f, 1f)]
	public float Bullet_1;

	[Range(0f, 1f)]
	public float Bullet_2;

	[Range(0f, 1f)]
	public float Bullet_3;

	[Range(0f, 1f)]
	public float Bullet_4 = 1f;

	[Range(0f, 1f)]
	public float Bullet_5;

	[Range(0f, 1f)]
	public float Bullet_6;

	[Range(0f, 1f)]
	public float Bullet_7;

	[Range(0f, 1f)]
	public float Bullet_8;

	[Range(0f, 1f)]
	public float Bullet_9;

	[Range(0f, 1f)]
	public float Bullet_10;

	[Range(0f, 1f)]
	public float Bullet_11;

	[Range(0f, 1f)]
	public float Bullet_12;

	private Material SCMaterial;

	private Texture2D Texture2;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		Texture2 = Resources.Load("CameraFilterPack_TV_BrokenGlass_2") as Texture2D;
		SCShader = Shader.Find("CameraFilterPack/TV_BrokenGlass2");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			if (Bullet_1 < 0f)
			{
				Bullet_1 = 0f;
			}
			if (Bullet_2 < 0f)
			{
				Bullet_2 = 0f;
			}
			if (Bullet_3 < 0f)
			{
				Bullet_3 = 0f;
			}
			if (Bullet_4 < 0f)
			{
				Bullet_4 = 0f;
			}
			if (Bullet_5 < 0f)
			{
				Bullet_5 = 0f;
			}
			if (Bullet_6 < 0f)
			{
				Bullet_6 = 0f;
			}
			if (Bullet_7 < 0f)
			{
				Bullet_7 = 0f;
			}
			if (Bullet_8 < 0f)
			{
				Bullet_8 = 0f;
			}
			if (Bullet_9 < 0f)
			{
				Bullet_9 = 0f;
			}
			if (Bullet_10 < 0f)
			{
				Bullet_10 = 0f;
			}
			if (Bullet_11 < 0f)
			{
				Bullet_11 = 0f;
			}
			if (Bullet_12 < 0f)
			{
				Bullet_12 = 0f;
			}
			if (Bullet_1 > 1f)
			{
				Bullet_1 = 1f;
			}
			if (Bullet_2 > 1f)
			{
				Bullet_2 = 1f;
			}
			if (Bullet_3 > 1f)
			{
				Bullet_3 = 1f;
			}
			if (Bullet_4 > 1f)
			{
				Bullet_4 = 1f;
			}
			if (Bullet_5 > 1f)
			{
				Bullet_5 = 1f;
			}
			if (Bullet_6 > 1f)
			{
				Bullet_6 = 1f;
			}
			if (Bullet_7 > 1f)
			{
				Bullet_7 = 1f;
			}
			if (Bullet_8 > 1f)
			{
				Bullet_8 = 1f;
			}
			if (Bullet_9 > 1f)
			{
				Bullet_9 = 1f;
			}
			if (Bullet_10 > 1f)
			{
				Bullet_10 = 1f;
			}
			if (Bullet_11 > 1f)
			{
				Bullet_11 = 1f;
			}
			if (Bullet_12 > 1f)
			{
				Bullet_12 = 1f;
			}
			material.SetFloat("_Bullet_1", Bullet_1);
			material.SetFloat("_Bullet_2", Bullet_2);
			material.SetFloat("_Bullet_3", Bullet_3);
			material.SetFloat("_Bullet_4", Bullet_4);
			material.SetFloat("_Bullet_5", Bullet_5);
			material.SetFloat("_Bullet_6", Bullet_6);
			material.SetFloat("_Bullet_7", Bullet_7);
			material.SetFloat("_Bullet_8", Bullet_8);
			material.SetFloat("_Bullet_9", Bullet_9);
			material.SetFloat("_Bullet_10", Bullet_10);
			material.SetFloat("_Bullet_11", Bullet_11);
			material.SetFloat("_Bullet_12", Bullet_12);
			material.SetTexture("_MainTex2", Texture2);
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/TV/Chromatical")]
public class CameraFilterPack_TV_Chromatical : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	[Range(0f, 1f)]
	public float Fade = 1f;

	[Range(0f, 1f)]
	public float Intensity = 1f;

	[Range(0f, 3f)]
	public float Speed = 1f;

	private Material SCMaterial;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/TV_Chromatical");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime * 2f;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("Fade", Fade);
			material.SetFloat("Intensity", Intensity);
			material.SetFloat("Speed", Speed);
			material.SetVector("_ScreenResolution", new Vector2(Screen.width, Screen.height));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/TV/Chromatical2")]
public class CameraFilterPack_TV_Chromatical2 : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 10f)]
	public float Aberration = 2f;

	[Range(0f, 1f)]
	public float Fade = 1f;

	[Range(0f, 1f)]
	public float ZoomFade = 1f;

	[Range(0f, 8f)]
	public float ZoomSpeed = 1f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/TV_Chromatical2");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", Aberration);
			material.SetFloat("Fade", Fade);
			material.SetFloat("ZoomFade", ZoomFade);
			material.SetFloat("ZoomSpeed", ZoomSpeed);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Glitch/Compression FX")]
public class CameraFilterPack_TV_CompressionFX : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	[Range(-10f, 10f)]
	public float Parasite = 1f;

	private Material SCMaterial;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/TV_CompressionFX");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Parasite", Parasite);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/TV/Distorted")]
public class CameraFilterPack_TV_Distorted : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	[Range(0f, 10f)]
	public float Distortion = 1f;

	[Range(-0.01f, 0.01f)]
	public float RGB = 0.002f;

	private Material SCMaterial;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/TV_Distorted");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Distortion", Distortion);
			material.SetFloat("_RGB", RGB);
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/TV/Horror")]
public class CameraFilterPack_TV_Horror : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	public float Fade = 1f;

	[Range(0f, 1f)]
	public float Distortion = 1f;

	private Texture2D Texture2;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		Texture2 = Resources.Load("CameraFilterPack_TV_HorrorFX") as Texture2D;
		SCShader = Shader.Find("CameraFilterPack/TV_Horror");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("Fade", Fade);
			material.SetFloat("Distortion", Distortion);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			material.SetTexture("Texture2", Texture2);
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/TV/LED")]
public class CameraFilterPack_TV_LED : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	[Range(0f, 1f)]
	public float Fade;

	[Range(1f, 10f)]
	private float Distortion = 1f;

	[Range(1f, 15f)]
	public int Size = 5;

	private Material SCMaterial;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/TV_LED");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Size", Size);
			material.SetFloat("Fade", Fade);
			material.SetFloat("_Distortion", Distortion);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/TV/Movie Noise")]
public class CameraFilterPack_TV_MovieNoise : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0.0001f, 1f)]
	public float Fade = 0.01f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/TV_MovieNoise");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Fade", Fade);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/TV/Noise")]
public class CameraFilterPack_TV_Noise : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0.0001f, 1f)]
	public float Fade = 0.01f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/TV_Noise");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Fade", Fade);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Old Film/Old")]
public class CameraFilterPack_TV_Old : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	[Range(1f, 10f)]
	public float Distortion = 1f;

	private Material SCMaterial;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/TV_Old");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Distortion", Distortion);
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Old Film/Old_Movie")]
public class CameraFilterPack_TV_Old_Movie : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	[Range(1f, 10f)]
	public float Distortion = 1f;

	private Material SCMaterial;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/TV_Old_Movie");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Distortion", Distortion);
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Old Film/Old_Movie_2")]
public class CameraFilterPack_TV_Old_Movie_2 : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(1f, 60f)]
	public float FramePerSecond = 15f;

	[Range(0f, 5f)]
	public float Contrast = 1f;

	[Range(0f, 4f)]
	public float Burn;

	[Range(0f, 16f)]
	public float SceneCut = 1f;

	[Range(0f, 1f)]
	public float Fade = 1f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/TV_Old_Movie_2");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", FramePerSecond);
			material.SetFloat("_Value2", Contrast);
			material.SetFloat("_Value3", Burn);
			material.SetFloat("_Value4", SceneCut);
			material.SetFloat("_Fade", Fade);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/TV/Planet Mars")]
public class CameraFilterPack_TV_PlanetMars : MonoBehaviour
{
	public Shader SCShader;

	[Range(0f, 1f)]
	public float Fade = 1f;

	private float TimeX = 1f;

	[Range(-10f, 10f)]
	public float Distortion = 1f;

	private Material SCMaterial;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/TV_PlanetMars");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Distortion", Distortion);
			material.SetFloat("Fade", Fade);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/TV/Posterize")]
public class CameraFilterPack_TV_Posterize : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	[Range(1f, 256f)]
	public float Posterize = 64f;

	[Range(0f, 1f)]
	public float Fade = 1f;

	private Material SCMaterial;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/TV_Posterize");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("Fade", Fade);
			material.SetFloat("_Distortion", Posterize);
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/TV/RGB Display")]
public class CameraFilterPack_TV_Rgb : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	[Range(0.01f, 4f)]
	public float Distortion = 1f;

	private Material SCMaterial;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/TV_Rgb");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Distortion", Distortion);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/TV/Tiles")]
public class CameraFilterPack_TV_Tiles : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0.5f, 2f)]
	public float Size = 1f;

	[Range(0f, 10f)]
	public float Intensity = 4f;

	[Range(0f, 1f)]
	public float StretchX = 0.6f;

	[Range(0f, 1f)]
	public float StretchY = 0.4f;

	[Range(0f, 1f)]
	public float Fade = 0.6f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/TV_Tiles");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", Size);
			material.SetFloat("_Value2", Intensity);
			material.SetFloat("_Value3", StretchX);
			material.SetFloat("_Value4", StretchY);
			material.SetFloat("Fade", Fade);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/VHS/VHS")]
public class CameraFilterPack_TV_VHS : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(1f, 256f)]
	public float Cryptage = 64f;

	[Range(1f, 100f)]
	public float Parasite = 32f;

	[Range(0f, 3f)]
	public float Calibrage;

	[Range(0f, 1f)]
	public float WhiteParasite = 1f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/TV_VHS");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", Cryptage);
			material.SetFloat("_Value2", Parasite);
			material.SetFloat("_Value3", Calibrage);
			material.SetFloat("_Value4", WhiteParasite);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/VHS/VHS_Rewind")]
public class CameraFilterPack_TV_VHS_Rewind : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	public float Cryptage = 1f;

	[Range(-20f, 20f)]
	public float Parasite = 9f;

	[Range(-20f, 20f)]
	public float Parasite2 = 12f;

	[Range(0f, 1f)]
	private float WhiteParasite = 1f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/TV_VHS_Rewind");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", Cryptage);
			material.SetFloat("_Value2", Parasite);
			material.SetFloat("_Value3", Parasite2);
			material.SetFloat("_Value4", WhiteParasite);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/VHS/VCR Distortion")]
public class CameraFilterPack_TV_Vcr : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	[Range(1f, 10f)]
	public float Distortion = 1f;

	private Material SCMaterial;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/TV_Vcr");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Distortion", Distortion);
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/TV/Video3D")]
public class CameraFilterPack_TV_Video3D : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/TV_Video3D");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/TV/Videoflip")]
public class CameraFilterPack_TV_Videoflip : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/TV_Videoflip");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/TV/Vignetting")]
public class CameraFilterPack_TV_Vignetting : MonoBehaviour
{
	public Shader SCShader;

	private Material SCMaterial;

	private Texture2D Vignette;

	[Range(0f, 1f)]
	public float Vignetting = 1f;

	[Range(0f, 1f)]
	public float VignettingFull;

	[Range(0f, 1f)]
	public float VignettingDirt;

	public Color VignettingColor = new Color(0f, 0f, 0f, 1f);

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/TV_Vignetting");
		Vignette = Resources.Load("CameraFilterPack_TV_Vignetting1") as Texture2D;
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			material.SetTexture("Vignette", Vignette);
			material.SetFloat("_Vignetting", Vignetting);
			material.SetFloat("_Vignetting2", VignettingFull);
			material.SetColor("_VignettingColor", VignettingColor);
			material.SetFloat("_VignettingDirt", VignettingDirt);
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/TV/Vintage")]
public class CameraFilterPack_TV_Vintage : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	[Range(1f, 10f)]
	public float Distortion = 1f;

	private Material SCMaterial;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/TV_Vintage");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Distortion", Distortion);
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/TV/WideScreenCircle")]
public class CameraFilterPack_TV_WideScreenCircle : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 0.8f)]
	public float Size = 0.55f;

	[Range(0.01f, 0.4f)]
	public float Smooth = 0.01f;

	[Range(0f, 10f)]
	private float StretchX = 1f;

	[Range(0f, 10f)]
	private float StretchY = 1f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/TV_WideScreenCircle");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", Size);
			material.SetFloat("_Value2", Smooth);
			material.SetFloat("_Value3", StretchX);
			material.SetFloat("_Value4", StretchY);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/TV/WideScreenHV")]
public class CameraFilterPack_TV_WideScreenHV : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 0.8f)]
	public float Size = 0.55f;

	[Range(0.001f, 0.4f)]
	public float Smooth = 0.01f;

	[Range(0f, 10f)]
	private float StretchX = 1f;

	[Range(0f, 10f)]
	private float StretchY = 1f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/TV_WideScreenHV");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", Size);
			material.SetFloat("_Value2", Smooth);
			material.SetFloat("_Value3", StretchX);
			material.SetFloat("_Value4", StretchY);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/TV/WideScreenHorizontal")]
public class CameraFilterPack_TV_WideScreenHorizontal : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 0.8f)]
	public float Size = 0.55f;

	[Range(0.001f, 0.4f)]
	public float Smooth = 0.01f;

	[Range(0f, 10f)]
	private float StretchX = 1f;

	[Range(0f, 10f)]
	private float StretchY = 1f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/TV_WideScreenHorizontal");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", Size);
			material.SetFloat("_Value2", Smooth);
			material.SetFloat("_Value3", StretchX);
			material.SetFloat("_Value4", StretchY);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/TV/WideScreenVertical")]
public class CameraFilterPack_TV_WideScreenVertical : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 0.8f)]
	public float Size = 0.55f;

	[Range(0.001f, 0.4f)]
	public float Smooth = 0.01f;

	[Range(0f, 10f)]
	private float StretchX = 1f;

	[Range(0f, 10f)]
	private float StretchY = 1f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/TV_WideScreenVertical");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", Size);
			material.SetFloat("_Value2", Smooth);
			material.SetFloat("_Value3", StretchX);
			material.SetFloat("_Value4", StretchY);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/VHS/Tracking")]
public class CameraFilterPack_VHS_Tracking : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 2f)]
	public float Tracking = 1f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/VHS_Tracking");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", Tracking);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Vision/Aura")]
public class CameraFilterPack_Vision_Aura : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 2f)]
	public float Twist = 1f;

	[Range(-4f, 4f)]
	public float Speed = 1f;

	public Color Color = new Color(0.16f, 0.57f, 0.19f);

	[Range(-1f, 2f)]
	public float PosX = 0.5f;

	[Range(-1f, 2f)]
	public float PosY = 0.5f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Vision_Aura");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", Twist);
			material.SetColor("_Value2", Color);
			material.SetFloat("_Value3", PosX);
			material.SetFloat("_Value4", PosY);
			material.SetFloat("_Value5", Speed);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Vision/AuraDistortion")]
public class CameraFilterPack_Vision_AuraDistortion : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 2f)]
	public float Twist = 1f;

	[Range(-4f, 4f)]
	public float Speed = 1f;

	public Color Color = new Color(0.16f, 0.57f, 0.19f);

	[Range(-1f, 2f)]
	public float PosX = 0.5f;

	[Range(-1f, 2f)]
	public float PosY = 0.5f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Vision_AuraDistortion");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", Twist);
			material.SetColor("_Value2", Color);
			material.SetFloat("_Value3", PosX);
			material.SetFloat("_Value4", PosY);
			material.SetFloat("_Value5", Speed);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Vision/Blood")]
public class CameraFilterPack_Vision_Blood : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0.01f, 1f)]
	public float HoleSize = 0.6f;

	[Range(-1f, 1f)]
	public float HoleSmooth = 0.3f;

	[Range(-2f, 2f)]
	public float Color1 = 0.2f;

	[Range(-2f, 2f)]
	public float Color2 = 0.9f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Vision_Blood");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", HoleSize);
			material.SetFloat("_Value2", HoleSmooth);
			material.SetFloat("_Value3", Color1);
			material.SetFloat("_Value4", Color2);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Vision/Blood_Fast")]
public class CameraFilterPack_Vision_Blood_Fast : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0.01f, 1f)]
	public float HoleSize = 0.6f;

	[Range(-1f, 1f)]
	public float HoleSmooth = 0.3f;

	[Range(-2f, 2f)]
	public float Color1 = 0.2f;

	[Range(-2f, 2f)]
	public float Color2 = 0.9f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Vision_Blood_Fast");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", HoleSize);
			material.SetFloat("_Value2", HoleSmooth);
			material.SetFloat("_Value3", Color1);
			material.SetFloat("_Value4", Color2);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Vision/Crystal")]
public class CameraFilterPack_Vision_Crystal : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(-10f, 10f)]
	public float Value = 1f;

	[Range(-1f, 1f)]
	public float X = 1f;

	[Range(-1f, 1f)]
	public float Y = 1f;

	[Range(-1f, 1f)]
	private float Value4 = 1f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Vision_Crystal");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", Value);
			material.SetFloat("_Value2", X);
			material.SetFloat("_Value3", Y);
			material.SetFloat("_Value4", Value4);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Vision/Drost")]
public class CameraFilterPack_Vision_Drost : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 0.4f)]
	public float Intensity = 0.4f;

	[Range(0f, 10f)]
	public float Speed = 1f;

	[Range(0f, 10f)]
	private float Value3 = 1f;

	[Range(0f, 10f)]
	private float Value4 = 1f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Vision_Drost");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", Intensity);
			material.SetFloat("_Value2", Speed);
			material.SetFloat("_Value3", Value3);
			material.SetFloat("_Value4", Value4);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Vision/Hell_Blood")]
public class CameraFilterPack_Vision_Hell_Blood : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	public float Hole_Size = 0.57f;

	[Range(0f, 0.5f)]
	public float Hole_Smooth = 0.362f;

	[Range(-2f, 2f)]
	public float Hole_Speed = 0.85f;

	[Range(-10f, 10f)]
	public float Intensity = 0.24f;

	public Color ColorBlood = new Color(1f, 0f, 0f, 1f);

	[Range(-1f, 1f)]
	public float BloodAlternative1;

	[Range(-1f, 1f)]
	public float BloodAlternative2;

	[Range(-1f, 1f)]
	public float BloodAlternative3 = -1f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Vision_Hell_Blood");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", Hole_Size);
			material.SetFloat("_Value2", Hole_Smooth);
			material.SetFloat("_Value3", Hole_Speed * 15f);
			material.SetColor("ColorBlood", ColorBlood);
			material.SetFloat("_Value4", Intensity);
			material.SetFloat("BloodAlternative1", BloodAlternative1);
			material.SetFloat("BloodAlternative2", BloodAlternative2);
			material.SetFloat("BloodAlternative3", BloodAlternative3);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Vision/Plasma")]
public class CameraFilterPack_Vision_Plasma : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(-2f, 2f)]
	public float Value = 0.6f;

	[Range(-2f, 2f)]
	public float Value2 = 0.2f;

	[Range(0f, 60f)]
	public float Intensity = 15f;

	[Range(0f, 10f)]
	private float Value4 = 1f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Vision_Plasma");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", Value);
			material.SetFloat("_Value2", Value2);
			material.SetFloat("_Value3", Intensity);
			material.SetFloat("_Value4", Value4);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Vision/Psycho")]
public class CameraFilterPack_Vision_Psycho : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0.01f, 1f)]
	public float HoleSize = 0.6f;

	[Range(-1f, 1f)]
	public float HoleSmooth = 0.3f;

	[Range(-2f, 2f)]
	public float Color1 = 0.2f;

	[Range(-2f, 2f)]
	public float Color2 = 0.9f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Vision_Psycho");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", HoleSize);
			material.SetFloat("_Value2", HoleSmooth);
			material.SetFloat("_Value3", Color1);
			material.SetFloat("_Value4", Color2);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Vision/Rainbow")]
public class CameraFilterPack_Vision_Rainbow : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 10f)]
	public float Speed = 1f;

	[Range(0f, 1f)]
	public float PosX = 0.5f;

	[Range(0f, 1f)]
	public float PosY = 0.5f;

	[Range(0f, 5f)]
	public float Colors = 0.5f;

	[Range(0f, 1f)]
	public float Vision = 0.5f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Vision_Rainbow");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", Speed);
			material.SetFloat("_Value2", PosX);
			material.SetFloat("_Value3", PosY);
			material.SetFloat("_Value4", Colors);
			material.SetFloat("_Value5", Vision);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Vision/SniperScore")]
public class CameraFilterPack_Vision_SniperScore : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	public float Fade = 1f;

	[Range(0f, 1f)]
	public float Size = 0.45f;

	[Range(0.01f, 0.4f)]
	public float Smooth = 0.045f;

	[Range(0f, 1f)]
	public float _Cible = 0.5f;

	[Range(0f, 1f)]
	public float _Distortion = 0.5f;

	[Range(0f, 1f)]
	public float _ExtraColor = 0.5f;

	[Range(0f, 1f)]
	public float _ExtraLight = 0.35f;

	public Color _Tint = new Color(0f, 0.6f, 0f, 0.25f);

	[Range(0f, 10f)]
	private float StretchX = 1f;

	[Range(0f, 10f)]
	private float StretchY = 1f;

	[Range(-1f, 1f)]
	public float _PosX;

	[Range(-1f, 1f)]
	public float _PosY;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Vision_SniperScore");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_Fade", Fade);
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", Size);
			material.SetFloat("_Value2", Smooth);
			material.SetFloat("_Value3", StretchX);
			material.SetFloat("_Value4", StretchY);
			material.SetFloat("_Cible", _Cible);
			material.SetFloat("_ExtraColor", _ExtraColor);
			material.SetFloat("_Distortion", _Distortion);
			material.SetFloat("_PosX", _PosX);
			material.SetFloat("_PosY", _PosY);
			material.SetColor("_Tint", _Tint);
			material.SetFloat("_ExtraLight", _ExtraLight);
			Vector2 vector = new Vector2(Screen.width, Screen.height);
			material.SetVector("_ScreenResolution", new Vector4(vector.x, vector.y, vector.y / vector.x, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Vision/Tunnel")]
public class CameraFilterPack_Vision_Tunnel : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	public float Value = 0.6f;

	[Range(0f, 1f)]
	public float Value2 = 0.4f;

	[Range(0f, 1f)]
	public float Intensity = 1f;

	[Range(0f, 10f)]
	private float Value4 = 1f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Vision_Tunnel");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", Value);
			material.SetFloat("_Value2", Value2);
			material.SetFloat("_Value3", Intensity);
			material.SetFloat("_Value4", Value4);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Vision/Warp")]
public class CameraFilterPack_Vision_Warp : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	public float Value = 0.6f;

	[Range(0f, 1f)]
	public float Value2 = 0.6f;

	[Range(0f, 10f)]
	private float Value3 = 1f;

	[Range(0f, 10f)]
	private float Value4 = 1f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Vision_Warp");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", Value);
			material.SetFloat("_Value2", Value2);
			material.SetFloat("_Value3", Value3);
			material.SetFloat("_Value4", Value4);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Vision/Warp2")]
public class CameraFilterPack_Vision_Warp2 : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Material SCMaterial;

	[Range(0f, 1f)]
	public float Value = 0.5f;

	[Range(0f, 1f)]
	public float Value2 = 0.2f;

	[Range(-1f, 2f)]
	public float Intensity = 1f;

	[Range(0f, 10f)]
	private float Value4 = 1f;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		SCShader = Shader.Find("CameraFilterPack/Vision_Warp2");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_Value", Value);
			material.SetFloat("_Value2", Value2);
			material.SetFloat("_Value3", Intensity);
			material.SetFloat("_Value4", Value4);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
public class CameraEyeLidsController : MonoBehaviour
{
	[Range(0f, 1f)]
	public float closedPerc;

	public float openAmount = 45f;

	public Transform topLid;

	public Transform bottomLid;

	[Range(0f, 1f)]
	public float blurAmount;

	public Color concussColour;

	public Color sicknessColour;

	[Range(0f, 1f)]
	public float vignetteAmount;

	[Range(0f, 1f)]
	public float redAmount;

	[Range(0f, 1f)]
	public float sicknessAmount;

	[Range(0f, 1f)]
	public float slowMoAmount;

	public Color slowMoColor;

	public bool bloodEnabled;

	public float bloodAngle;

	public MeshRenderer vignette;

	public MeshRenderer red;

	public MeshRenderer sickness;

	public MeshRenderer slowMo;

	public MeshRenderer concuss;

	public MeshRenderer blood;

	private void Start()
	{
		slowMoColor = slowMo.material.color;
		concussColour = concuss.material.color;
		sicknessColour = sickness.material.color;
	}

	private void Update()
	{
		if (Fader.fading || Fader.paused)
		{
			closedPerc = Fader.vignettingBlink;
		}
		float num = closedPerc;
		topLid.transform.localRotation = Quaternion.Euler(-90f - openAmount * (1f - num), 0f, 0f);
		bottomLid.transform.localRotation = Quaternion.Euler(90f - openAmount * (1f - num), 180f, 0f);
		topLid.transform.localPosition = Vector3.up * -0.03f * closedPerc;
		bottomLid.transform.localPosition = Vector3.up * 0.03f * closedPerc;
		vignette.gameObject.SetActive(vignetteAmount > 0f);
		red.gameObject.SetActive(redAmount > 0f);
		sickness.gameObject.SetActive(sicknessAmount > 0f);
		slowMo.gameObject.SetActive(slowMoAmount > 0f);
		concuss.gameObject.SetActive(value: false);
		blood.gameObject.SetActive(bloodEnabled);
		vignette.material.SetColor("_Color", Color.Lerp(Color.clear, Color.white, Mathf.Clamp01(vignetteAmount * 2f)));
		red.material.SetColor("_Color", Color.Lerp(Color.clear, Color.white, redAmount));
		sickness.material.SetColor("_Color", Color.Lerp(Color.clear, sicknessColour, sicknessAmount));
		slowMo.material.SetColor("_Color", Color.Lerp(Color.black, slowMoColor, slowMoAmount));
		concuss.material.SetColor("_Color", Color.Lerp(Color.black, concussColour, blurAmount));
		blood.transform.localRotation = Quaternion.Euler(bloodAngle, -90f, 90f);
	}
}
public class CameraSwitcher : MonoBehaviour
{
	public Camera[] cameras;

	public Canvas spectatorCanvas;

	public int spectateMode = -1;

	public TextMeshProUGUI canvasLabel;

	public float labelAlpha;

	private int onCam = -1;

	private void Start()
	{
		spectateMode = -1;
	}

	private void switchCam()
	{
		for (int i = 0; i < cameras.Length; i++)
		{
			cameras[i].gameObject.SetActive(i == onCam);
		}
		canvasLabel.text = "Spectate Camera: ";
		canvasLabel.text += ((onCam < 0) ? "POV" : cameras[onCam].name);
		canvasLabel.text += " - Press Space to Change.";
		if (onCam > -1)
		{
			canvasLabel.text += " P to toggle POV";
		}
		labelAlpha = 1f;
	}

	private void Update()
	{
		if (onCam != spectateMode)
		{
			switchCam();
		}
		canvasLabel.color = Color.white * labelAlpha;
		if (labelAlpha > 0f)
		{
			labelAlpha -= Time.deltaTime / 4f;
		}
		if (!Application.isEditor)
		{
			return;
		}
		if (Input.GetKeyDown(KeyCode.H))
		{
			OptionData.getOption("Spectator HUD").next();
		}
		if (Input.GetKeyDown(KeyCode.Space))
		{
			spectateMode++;
			if (spectateMode >= cameras.Length)
			{
				spectateMode = 0;
			}
			if (!XRSettings.enabled && OptionData.getOption("Spectator Mode").value == -1)
			{
				OptionData.getOption("Spectator Mode").next();
			}
			switchCam();
		}
	}
}
public class CanvasController : MonoBehaviour
{
	public static CanvasController instance;

	public FloatingTextNew floatingTextNewPrefab;

	public List<FloatingTextNew> floatingTexts;

	private float spacing = 0.05f;

	private void Start()
	{
		instance = this;
	}

	public static void addText(bool localise, string text, Vector3 position, Color color, float displayTime, Transform attachTo = null)
	{
		if (localise)
		{
			text = LocalisationController.getText("Floating Text", text);
		}
		instance.addFloatingText(text, position, color, displayTime, attachTo);
	}

	protected void addFloatingText(string text, Vector3 position, Color color, float displayTime, Transform attachTo)
	{
		if (!(Camera.main == null))
		{
			UnityEngine.Debug.Log("Floating: " + text);
			Vector3 forward = position - Camera.main.transform.position;
			forward.y = 0f;
			Quaternion rotation = Quaternion.LookRotation(forward);
			FloatingTextNew floatingTextNew = UnityEngine.Object.Instantiate(floatingTextNewPrefab, position, rotation, base.transform);
			floatingTextNew.displayTime = displayTime;
			floatingTextNew.txt.text = text;
			floatingTextNew.txt.color = color;
			floatingTextNew.attachTo = attachTo?.gameObject;
			floatingTexts.Add(floatingTextNew);
		}
	}

	private void Update()
	{
		if (floatingTexts.Count <= 0)
		{
			return;
		}
		float num = 0f;
		for (int num2 = floatingTexts.Count - 1; num2 >= 0; num2--)
		{
			if (floatingTexts[num2] == null)
			{
				floatingTexts.RemoveAt(num2);
			}
			else
			{
				floatingTexts[num2].moveUp = num * spacing;
				num += 1f;
			}
		}
	}
}
public class ChamberController : MonoBehaviour
{
	public int id;

	public GameObject contents;

	public GameObject contentsPrefab;

	public ChamberDoorController exit;

	public StandPositionIndicator resetButton;

	public bool isComplete;

	public bool skip = true;

	public bool perfect = true;

	[Header("Settings...")]
	public bool leftHandMeter;

	public bool rightHandMeter;

	public int observerPosition;

	private void Start()
	{
		MeshRenderer[] componentsInChildren = base.gameObject.GetComponentsInChildren<MeshRenderer>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			componentsInChildren[i].shadowCastingMode = ShadowCastingMode.Off;
		}
		SkinnedMeshRenderer[] componentsInChildren2 = base.gameObject.GetComponentsInChildren<SkinnedMeshRenderer>();
		for (int i = 0; i < componentsInChildren2.Length; i++)
		{
			componentsInChildren2[i].shadowCastingMode = ShadowCastingMode.Off;
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		ChambersController.instance.playerInChamber = id;
	}

	private void Reset()
	{
		if (!(contents == null))
		{
			UnityEngine.Object.Destroy(contents);
			contents = UnityEngine.Object.Instantiate(contentsPrefab, base.transform);
		}
	}

	private void Update()
	{
	}
}
public class ChamberDoorController : MonoBehaviour
{
	private float openZ = -2.5f;

	private float closedZ;

	public bool open;

	public bool exit = true;

	private float openSpeed = 1f;

	public Transform door;

	public AudioSource audioSource;

	public ChamberController chamber;

	public bool openOnProximity;

	public ParticleSystem particles;

	private void Start()
	{
		chamber = GetComponentInParent<ChamberController>();
		if (chamber == null)
		{
			UnityEngine.Debug.LogError("Chamber is null");
		}
		if (exit)
		{
			chamber.exit = this;
		}
	}

	private void OnCollisionEnter(Collision collision)
	{
	}

	private void Update()
	{
		if (GameController.instance == null || GameController.instance.player == null)
		{
			return;
		}
		Vector3 vector = GameController.instance.player.standPosition - base.transform.position;
		vector.y = 0f;
		if (chamber != null && !openOnProximity && !chamber.skip)
		{
			open = chamber.isComplete && (ChambersController.instance.playerInChamber == chamber.id || ChambersController.instance.playerInChamber == -1);
			if (!open && Mathf.Abs(door.localPosition.z - openZ) < 0.1f && vector.magnitude < 2f)
			{
				open = true;
			}
		}
		else
		{
			open = vector.magnitude < 5f;
		}
		Vector3 vector2 = new Vector3(door.localPosition.x, door.localPosition.y, open ? openZ : closedZ);
		bool flag = Vector3.Distance(door.localPosition, vector2) != 0f;
		if (audioSource.isPlaying)
		{
			if (!flag)
			{
				audioSource.Stop();
				if (particles != null)
				{
					particles.Stop();
				}
			}
		}
		else if (flag)
		{
			audioSource.Play();
			if (particles != null)
			{
				particles.transform.position = new Vector3(particles.transform.position.x, 0f, particles.transform.position.z);
				particles.Play();
			}
		}
		door.localPosition = Vector3.MoveTowards(door.localPosition, vector2, Time.deltaTime * openSpeed);
	}
}
public class ChamberExit : MonoBehaviour
{
	public float timer = 1f;

	private bool hasQuit;

	private void OnTriggerEnter(Collider other)
	{
		if (!hasQuit)
		{
			GeneralSounds.playSound(0, 0.7f);
			Invoke("quit", 1f);
			hasQuit = true;
		}
	}

	private void quit()
	{
		if (!Saving.instance.saveGameData.exists())
		{
			GameController.instance.gameMode = GameController.GameMode.Normal;
			GameController.instance.specialMode = GameController.instance.gameData.specialModes[0];
			WebLogging.log("New Game After Chambers", GameController.instance.specialMode.name, 0f);
			GameController.instance.gameData.setupNewGame(-1);
			GameController.instance.scenes.pickCharacter();
		}
		else
		{
			GameController.instance.scenes.mainMenu();
		}
		hasQuit = false;
	}
}
public class ChamberFighter : MonoBehaviour
{
	public ChamberController chamber;

	public int characterID;

	public GameCharacter character;

	private bool setup;

	public float showDistance = 5f;

	public float fighterHealth = 0.75f;

	private void Start()
	{
	}

	private void Update()
	{
		if (GameController.instance == null)
		{
			return;
		}
		bool flag = false;
		if (GameController.instance.player != null)
		{
			flag = (GameController.instance.player.transform.position - base.transform.position).magnitude < showDistance;
		}
		if (flag)
		{
			if (character == null)
			{
				character = GameController.instance.addFighter(2, characterID, 1, base.transform.position, base.transform.rotation.eulerAngles.y, 0f, aboveGround: false);
				character.lives = 1;
				character.rigidBodies.maxHealth = fighterHealth;
				character.aiControl.chamberArea = this;
				GameController.instance.hud.setup();
			}
			else if (character.rigidBodies.isDown(allTheWay: true))
			{
				chamber.isComplete = true;
			}
		}
		else if (character != null)
		{
			GameController.instance.removeFighter(character);
			GameController.instance.hud.setup();
		}
	}
}
public class ChambersController : MonoBehaviour
{
	public static ChambersController instance;

	public ChamberController[] chambers;

	public bool hasEntered;

	public bool hasQuit;

	public bool refreshTips;

	public int playerInChamber = -1;

	private int prevChamber = -1;

	public int completed;

	public AudioClip[] instructionSounds;

	private AudioSource audioSource;

	public GameObject observer;

	public Transform[] observerPositions;

	public bool hasJumped;

	public bool hasTurned;

	public ChamberDoorController startDoor;

	public ChamberDoorController endDoor;

	public TipCanvasController[] tips;

	private void Start()
	{
		audioSource = GetComponent<AudioSource>();
		instance = this;
		chambers = GetComponentsInChildren<ChamberController>();
		tips = GetComponentsInChildren<TipCanvasController>();
		for (int i = 0; i < chambers.Length; i++)
		{
			chambers[i].id = i;
		}
		base.gameObject.SetActive(GameController.instance.gameMode == GameController.GameMode.Chambers);
	}

	public void setup()
	{
		if (GameController.instance.gameMode == GameController.GameMode.Chambers)
		{
			setObserverPosition(0);
			WebLogging.log("Chamber", "Started", 0f);
			Invoke("startVoice", 1.5f);
			Invoke("StartTip", 2f);
		}
		else
		{
			observer.gameObject.SetActive(value: false);
		}
	}

	private void checkDuplicate(MeshRenderer mesh, MeshRenderer[] mr)
	{
		if (!mesh.gameObject.activeInHierarchy)
		{
			return;
		}
		foreach (MeshRenderer meshRenderer in mr)
		{
			if (meshRenderer != mesh && meshRenderer.gameObject.activeInHierarchy && (mesh.transform.position - meshRenderer.transform.position).magnitude < 0.01f && mesh.GetComponent<MeshFilter>().sharedMesh == meshRenderer.GetComponent<MeshFilter>().sharedMesh)
			{
				UnityEngine.Debug.LogError("Duplicate Mesh Hidden: " + meshRenderer.name + " (" + mesh.name + ")");
				meshRenderer.gameObject.SetActive(value: false);
			}
		}
	}

	public void setObserverPosition(int pos)
	{
		if (pos >= 0 && pos < chambers.Length)
		{
			observer.transform.position = observerPositions[chambers[pos].observerPosition].position;
			observer.transform.rotation = observerPositions[chambers[pos].observerPosition].rotation;
			observer.gameObject.SetActive(value: true);
		}
	}

	public void StartTip()
	{
		GameCharacter player = GameController.instance.player;
		player.playerController.controllerTips.tip(Pvr_KeyCode.Thumbrest, left: true, "Move");
		player.playerController.controllerTips.showLeftArrows(up: true, down: true, left: true, right: true);
	}

	private void startVoice()
	{
		if (!(GameController.instance.player == null))
		{
			audioSource.clip = instructionSounds[0];
			audioSource.Play();
			SubtitlesController.instance.say(startDoor.transform.position + Vector3.up * 1.5f, LocalisationController.getText("General", "Enter the first chamber..."), audioSource.clip.length);
		}
	}

	public void completeVoice()
	{
		Invoke("doCompleteVoice", 1f);
		WebLogging.log("Chamber", "Completed", 0f);
	}

	private void doCompleteVoice()
	{
		audioSource.clip = instructionSounds[2];
		audioSource.Play();
		SubtitlesController.instance.say(endDoor.transform.position + Vector3.up * 1.5f, LocalisationController.getText("General", "Your training is now complete. You may leave."), audioSource.clip.length);
	}

	public void nextVoice()
	{
		Invoke("doNextVoice", 1f);
	}

	private void doNextVoice()
	{
		audioSource.clip = instructionSounds[1];
		audioSource.Play();
		SubtitlesController.instance.say(chambers[playerInChamber].exit.transform.position + Vector3.up * 1.5f, LocalisationController.getText("General", "Proceed to the next chamber..."), audioSource.clip.length);
	}

	private void Update()
	{
		if (refreshTips)
		{
			refreshTips = false;
			TipCanvasController[] array = tips;
			for (int i = 0; i < array.Length; i++)
			{
				_ = array[i];
			}
		}
		if (GameController.instance == null)
		{
			return;
		}
		GameCharacter player = GameController.instance.player;
		if (!(player == null) && !(player.standPosition.z < 20f))
		{
			Vector3 standPosition = player.standPosition;
			for (int j = 0; j < chambers.Length; j++)
			{
				Vector3 vector = chambers[j].transform.position - standPosition;
				bool flag = false;
				if (chambers[j].isComplete && j > completed)
				{
					completed = j;
					flag = true;
				}
				if (flag)
				{
					if (completed >= chambers.Length - 1)
					{
						completeVoice();
					}
					else
					{
						nextVoice();
					}
				}
				if (Mathf.Abs(vector.x) < 3f && Mathf.Abs(vector.z) < 4f && playerInChamber != prevChamber)
				{
					prevChamber = playerInChamber;
					WebLogging.log("Chamber", "Enter Chamber", prevChamber);
					setObserverPosition(playerInChamber);
					switch (playerInChamber)
					{
					case 0:
						player.playerController.controllerTips.tip(Pvr_KeyCode.Thumbrest, left: false, "Turn / Jump");
						player.playerController.controllerTips.showRightArrows(up: true, down: false, left: true, right: true);
						break;
					case 1:
						player.playerController.controllerTips.clearTip();
						break;
					case 2:
						player.playerController.controllerTips.fistTip();
						break;
					case 4:
						player.playerController.controllerTips.tip(Pvr_KeyCode.Thumbrest, left: false, "Kick");
						player.playerController.controllerTips.showRightArrows(up: false, down: true, left: false, right: false);
						break;
					case 5:
						player.playerController.controllerTips.clearTip();
						break;
					case 9:
						player.playerController.controllerTips.tip(player.playerController.vrActions.dashAction_pico, left: false, "Dash");
						break;
					case 10:
						player.playerController.controllerTips.clearTip();
						break;
					case 12:
						player.playerController.controllerTips.tip(player.playerController.vrActions.specialMoveAction_pico, left: false, "Special Move");
						break;
					}
					if (prevChamber > 0)
					{
						chambers[prevChamber].isComplete = false;
					}
				}
			}
		}
		if (playerInChamber > -1)
		{
			hasEntered = true;
			hasQuit = false;
			switch (playerInChamber)
			{
			case 0:
				if (player.playerController.vrActions.jump())
				{
					hasJumped = true;
				}
				if (Mathf.Abs(player.playerController.vrActions.turn()) > 0.75f)
				{
					hasTurned = true;
				}
				if (hasJumped && hasTurned)
				{
					player.playerController.controllerTips.clearTip();
				}
				break;
			case 2:
				if (player.rigidBodies.hands.l_squeezeAmount + player.rigidBodies.hands.r_squeezeAmount + player.rigidBodies.hands.l_squeezeAmount_secondary + player.rigidBodies.hands.r_squeezeAmount_secondary >= 2f)
				{
					player.playerController.controllerTips.clearFistTip();
				}
				break;
			case 4:
				if (player.playerController.vrActions.kick())
				{
					player.playerController.controllerTips.clearTip();
				}
				break;
			case 5:
				if (player.playerController.vrActions.kick())
				{
					player.playerController.controllerTips.clearTip();
				}
				break;
			case 9:
				if (player.playerController.vrActions.dash())
				{
					player.playerController.controllerTips.clearTip();
				}
				break;
			case 10:
				player.playerController.controllerTips.clearTip();
				break;
			case 1:
			case 3:
			case 6:
			case 7:
			case 8:
			case 11:
			case 12:
				break;
			}
		}
		else
		{
			_ = hasEntered;
		}
	}
}
public class CharacterButtonController : MonoBehaviour
{
	public MeshRenderer mesh;

	public int materialID = 1;

	public Texture defaultTexture;

	public string textureName = "_MainTex";

	public RawImage pic;

	public Image circle;

	public Image tick;

	public Sprite tick_green;

	public Sprite tick_grey;

	public Sprite circle_green;

	public Sprite circle_grey;

	private MenuButtonContoller menuButton;

	public void setTo(CharacterData character)
	{
		pic.texture = ((character.thumbnail == null) ? defaultTexture : character.thumbnail);
		if (character.playable(allowUnlockedBosses: true, blockLevelLocked: true) && character.puppet != null)
		{
			pic.color = Color.white;
		}
		else
		{
			pic.color = ((character.requiresCustomUnlock != "") ? Color.black : Color.grey);
		}
		menuButton = GetComponent<MenuButtonContoller>();
		menuButton.disabled = !character.playable(allowUnlockedBosses: true, blockLevelLocked: true) || character.puppet == null;
		menuButton.unbreakable = !character.playable(allowUnlockedBosses: true, blockLevelLocked: true) || character.puppet == null;
		if (character.completedAllLevel >= GameController.instance.difficultyLevel.id)
		{
			tick.sprite = tick_green;
		}
		else if (character.completedAllLevel > -1)
		{
			tick.sprite = tick_grey;
		}
		else
		{
			tick.gameObject.SetActive(value: false);
		}
		if (character.beatenBossLevel >= GameController.instance.difficultyLevel.id)
		{
			circle.sprite = circle_green;
		}
		else if (character.beatenBossLevel > -1)
		{
			circle.sprite = circle_grey;
		}
		else
		{
			circle.gameObject.SetActive(value: false);
		}
	}

	public void setTo(LocationData location)
	{
		Material[] materials = mesh.materials;
		materials[materialID].SetTexture(textureName, (location.thumbnail == null) ? defaultTexture : location.thumbnail);
		mesh.materials = materials;
	}

	public void setTo(Material material)
	{
		Material[] materials = mesh.materials;
		materials[materialID] = material;
		mesh.materials = materials;
	}

	private void Start()
	{
		menuButton = GetComponent<MenuButtonContoller>();
	}

	private void Update()
	{
		if (pic != null)
		{
			Color color = pic.color;
			color.a = Mathf.MoveTowards(color.a, (!menuButton.broken) ? 1 : 0, Time.deltaTime * 2f);
			pic.color = color;
		}
	}
}
[Serializable]
public class CharacterData : Exportable
{
	public enum Race
	{
		Chinese,
		Japanese,
		Western
	}

	public enum DifficultyTier
	{
		Easy,
		Medium,
		Hard,
		Boss,
		SubBoss,
		FinalBoss
	}

	public string pluralName;

	public int id;

	public bool lockedByDefault;

	public bool wacky;

	[Header("Categories for Voices")]
	public bool female;

	public bool young;

	public Race race;

	[TextArea(2, 10)]
	public string bio;

	[TextArea(2, 10)]
	public string ending;

	[NonSerialized]
	public Texture thumbnail;

	public RigidBodies puppet;

	[Header("Fight Settings")]
	public int amount = 1;

	[Range(0f, 1f)]
	public float willgoLow = 1f;

	public float heightScale = 1f;

	public float healthPerc = 1f;

	public string friend;

	public string otherFriend;

	public LocationData.HomeLocation home;

	public bool includeInDemo;

	public string fightStyleName;

	public HandPosition.Position secondaryPalmPosition;

	public string specialMoveName;

	public string perkName;

	public string weaknessName;

	public PerkData perk;

	public PerkData weakness;

	[Header("AI Settings")]
	public DifficultyTier difficultyTier;

	[Range(0f, 1f)]
	public float kickFrequency = 0.5f;

	public int unlockDifficultyRequirement = -1;

	public string requiresCustomUnlock;

	public string onlyInMode;

	public bool includeInMainGame;

	[NonSerialized]
	public int fightingStyle = -1;

	[NonSerialized]
	public int specialMove = -1;

	public Color healthBarColour = Color.white;

	public bool test;

	public CharacterVoice voice;

	public int fightsFinished;

	public bool playedAs;

	[Header("Game Settings - set by code")]
	[Range(0f, 1f)]
	public float difficulty;

	[NonSerialized]
	public float rndOrder;

	public int hasStars;

	public bool unlocked;

	public int unlockStars;

	public int completedAllLevel;

	public int beatenBossLevel;

	[NonSerialized]
	public SavedCompletedGame completedGameData;

	public void checkLocalise()
	{
		UnityEngine.Debug.LogError(name + ": " + LocalisationController.getChinese(bio));
		UnityEngine.Debug.LogError(name + " (end): " + LocalisationController.getChinese(ending));
		UnityEngine.Debug.LogError(name + " (end): " + LocalisationController.replaceText("Unlock", "Character: [x] Unlocked", LocalisationController.getText("Character: " + name, name)));
	}

	public void localise()
	{
		doCleanUp();
		LocalisationController.clearText("Character: " + name);
		LocalisationController.getText("Character: " + name, name, suppressError: true);
		LocalisationController.getText("Character: " + name, pluralName, suppressError: true);
		LocalisationController.getText("Character: " + name, bio, suppressError: true);
		LocalisationController.getText("Character: " + name, ending, suppressError: true);
		VoiceData[] phrases = voice.phrases;
		foreach (VoiceData voiceData in phrases)
		{
			LocalisationController.getText("Character Voice: " + name, voiceData.words);
		}
	}

	private void doCleanUp()
	{
		bio = cleanUp(bio);
		ending = cleanUp(ending);
	}

	private string cleanUp(string txt)
	{
		txt = txt.Replace('’', '\'');
		txt = txt.Replace("…", "...");
		txt = txt.Replace("“", "'");
		txt = txt.Replace("”", "'");
		txt = txt.Replace("\"", "'");
		return txt;
	}

	public void setup(GameData data, MoveRecorder recorder)
	{
		doCleanUp();
		voice.characterData = this;
		if (secondaryPalmPosition == HandPosition.Position.None)
		{
			secondaryPalmPosition = HandPosition.Position.Claw;
		}
		if (fightStyleName != "" && fightStyleName != "All")
		{
			int num = 0;
			foreach (FightingStyle fightingStyle in recorder.actions.fightingStyles)
			{
				if (fightingStyle.name == fightStyleName)
				{
					this.fightingStyle = num;
					break;
				}
				num++;
			}
			if (this.fightingStyle == -1)
			{
				UnityEngine.Debug.LogError("Couldnt find style: " + fightStyleName);
			}
		}
		if (specialMoveName != "" && specialMoveName != "All")
		{
			int num = 0;
			SpecialMoveData[] specialMoves = data.specialMoves;
			for (int i = 0; i < specialMoves.Length; i++)
			{
				if (specialMoves[i].name == specialMoveName)
				{
					specialMove = num;
					break;
				}
				num++;
			}
			if (specialMove == -1)
			{
				UnityEngine.Debug.LogError("Couldnt find special move: " + specialMoveName);
			}
		}
		perk = GameData.instance.getPerkByName(perkName);
		weakness = GameData.instance.getPerkByName(weaknessName);
	}

	public int getUnlockStars()
	{
		if (difficultyTier == DifficultyTier.Boss || difficultyTier == DifficultyTier.SubBoss || difficultyTier == DifficultyTier.FinalBoss)
		{
			return unlockStars;
		}
		int num = Mathf.RoundToInt((float)unlockStars * GameController.instance.difficultyLevel.unlockRequirementMod);
		if (num < 0)
		{
			num = 0;
		}
		return num;
	}

	public bool hasPerk(string name)
	{
		if (perkName == name)
		{
			return true;
		}
		if (weaknessName == name)
		{
			return true;
		}
		return false;
	}

	public bool isNinja()
	{
		return pluralName == "Ninja";
	}

	public float perkMod(string name, string characterName)
	{
		if (name == perkName)
		{
			if (OptionData.getBool("Show Perks"))
			{
				UnityEngine.Debug.Log("Perk: " + name + ", " + characterName);
			}
			return perk.perc;
		}
		if (name == weaknessName)
		{
			if (OptionData.getBool("Show Perks"))
			{
				UnityEngine.Debug.Log("Weakness: " + name + ", " + characterName);
			}
			return weakness.perc;
		}
		return 1f;
	}

	public float perkMod(string name, Vector3 hitPoint)
	{
		if (name == perkName)
		{
			if (OptionData.getBool("Show Perks"))
			{
				CanvasController.addText(localise: false, "Perk: " + name + " " + perk.perc * 100f + "%", hitPoint, Color.yellow, 2f);
			}
			return perk.perc;
		}
		if (name == weaknessName)
		{
			if (OptionData.getBool("Show Perks"))
			{
				CanvasController.addText(localise: false, "Weakness: " + name + " " + weakness.perc * 100f + "%", hitPoint, Color.yellow, 2f);
			}
			return weakness.perc;
		}
		return 1f;
	}

	public CharacterData getFriend()
	{
		return GameController.instance.gameData.getCharactersByName(friend);
	}

	public bool seeable()
	{
		if (GameController.instance.specialMode.specialCharacters)
		{
			return onlyInMode == GameController.instance.specialMode.name;
		}
		return onlyInMode == "";
	}

	public bool playable(bool allowUnlockedBosses, bool blockLevelLocked, bool allowSpecials = true)
	{
		if (requiresCustomUnlock != "" && !allowSpecials)
		{
			return false;
		}
		if (!seeable())
		{
			return false;
		}
		if (unlockDifficultyRequirement > -1)
		{
			if (!allowUnlockedBosses)
			{
				return false;
			}
			if (!OptionData.getBool("Playable Bosses"))
			{
				return GameData.instance.difficultyLevelCompleted >= unlockDifficultyRequirement;
			}
			return true;
		}
		if (requiresCustomUnlock != "")
		{
			return Saving.instance.savedProgress.hasCustomUnlock(requiresCustomUnlock);
		}
		if (lockedByDefault)
		{
			if (!blockLevelLocked)
			{
				return true;
			}
			return GameData.instance.locations[(int)home].charactersUnlocked;
		}
		return true;
	}

	public bool beaten()
	{
		return hasStars > 0;
	}

	public int getFightingStyleID()
	{
		return fightingStyle;
	}

	public int getSpecialMoveID()
	{
		return specialMove;
	}

	public float moveSpeedPerc()
	{
		return 1f / heightScale;
	}

	public float getRndOrder()
	{
		return difficultyTier switch
		{
			DifficultyTier.FinalBoss => 4f, 
			DifficultyTier.SubBoss => 3f, 
			DifficultyTier.Boss => 2f, 
			DifficultyTier.Hard => UnityEngine.Random.Range(0.75f, 1f), 
			DifficultyTier.Medium => UnityEngine.Random.Range(0.4f, 0.9f), 
			DifficultyTier.Easy => UnityEngine.Random.Range(0f, 0.5f), 
			_ => UnityEngine.Random.value, 
		};
	}

	public SpecialMoveData specialMoveData(bool isPlayer)
	{
		if (specialMove == -1)
		{
			specialMove = 0;
		}
		return GameController.instance.gameData.specialMoves[specialMove];
	}

	public void getThumb()
	{
		if (!(thumbnail != null))
		{
			thumbnail = Resources.Load<Texture>("newPortraits/" + name);
			if (thumbnail == null)
			{
				thumbnail = Resources.Load<Texture>("newPortraits/" + name + "_1");
			}
			if (thumbnail == null)
			{
				thumbnail = Resources.Load<Texture>("newPortraits/" + name + "_2");
			}
		}
	}

	public void reset()
	{
		unlocked = false;
		unlockStars = 0;
		hasStars = 0;
		fightsFinished = 0;
		playedAs = false;
		rndOrder = getRndOrder();
	}
}
[Serializable]
public class CharacterEffect
{
	public enum Effect
	{
		None,
		IronArmor,
		Sickness,
		Weakness,
		L_ArmDisabled,
		R_ArmDisabled,
		Slowness,
		Blinded,
		Paralysed,
		SpeedHands,
		CantWalk,
		QuickWalk,
		Pain,
		Ghost,
		Winded,
		L_ArmNumb,
		R_ArmNumb,
		BlindLite,
		SlowWalk,
		SpeedKick,
		InterceptingFist,
		Strength,
		ViperLeavesCave,
		ScissorKick,
		Drunk,
		TigerClaws,
		ShadowBoxing,
		IronFists,
		Stunned,
		RapidPunch,
		HighImpact
	}

	public string name;

	public Effect effect;

	public float amount;

	public SlowMo slowMo;

	public float startTime;

	public CharacterEffectData effectData;

	public SpecialMoveAttachedEffect visualEffect;

	public bool timeReduce;

	public bool preventSpecialCharge;

	public HandPosition.Position l_handPosition;

	public HandPosition.Position r_handPosition;

	public Vector3 startPos;

	public float perc;

	public CharacterEffect(Vector3 startPos, Effect effect, float amount, bool isTest)
	{
		effectData = GameController.instance.gameData.getCharacterEffect(effect);
		this.startPos = startPos;
		name = effect.ToString();
		this.effect = effect;
		this.amount = amount;
		if (effectData != null && effectData.endViaHit && !isTest)
		{
			timeReduce = false;
		}
		else
		{
			timeReduce = true;
		}
		startTime = Time.time;
	}

	public float edgePerc(float smoothTime)
	{
		return edgePerc(smoothTime, start: true, end: true);
	}

	public float edgePerc(float smoothTime, bool start, bool end)
	{
		float num = existed();
		if (num < smoothTime && start)
		{
			return num / smoothTime;
		}
		if (amount < smoothTime && end)
		{
			return amount / smoothTime;
		}
		return 1f;
	}

	public float existed()
	{
		return Time.time - startTime;
	}
}
[Serializable]
public class CharacterEffectData
{
	public enum AIType
	{
		Normal,
		ChargeIn,
		RunAway
	}

	public string name;

	public CharacterEffect.Effect effect;

	public Sprite icon;

	public SpecialMoveAttachedEffect onStartEffect;

	public SpecialMoveAttachedEffect onEndEffect;

	public Material material;

	public AudioClip startSound;

	public AudioClip endSound;

	public AudioClip hitSound;

	public AudioClip overrideSwipeSound;

	public TimeSlow timeSlow;

	public bool endViaHit;

	public AIType whenHasEffect;

	public AIType whenOpponentHasEffect;

	public void setup()
	{
	}

	public void localise()
	{
		LocalisationController.getText("Character Effect", name);
	}

	public bool kickEffect()
	{
		if (effect == CharacterEffect.Effect.SpeedKick)
		{
			return true;
		}
		if (effect == CharacterEffect.Effect.ScissorKick)
		{
			return true;
		}
		return false;
	}
}
public class CharacterGridController : MonoBehaviour
{
	public CharacterGridPicController picPrefab;

	public Vector3 size;

	private void Start()
	{
		Vector3 zero = Vector3.zero;
		CharacterData[] characters = GameController.instance.gameData.characters;
		foreach (CharacterData to in characters)
		{
			CharacterGridPicController characterGridPicController = UnityEngine.Object.Instantiate(picPrefab, base.transform);
			characterGridPicController.transform.localPosition = zero - new Vector3(size.x, 0f - size.y, 0f) / 2f;
			characterGridPicController.SetTo(to);
			zero.x += 256f;
			if (zero.x >= size.x)
			{
				zero.y -= 255f;
				zero.x = 0f;
			}
		}
	}

	private void Update()
	{
	}
}
public class CharacterGridPicController : MonoBehaviour
{
	public TextMeshProUGUI label;

	public RawImage pic;

	public void SetTo(CharacterData character)
	{
		pic.texture = character.thumbnail;
		label.text = character.name;
	}
}
public class CharacterMover : MonoBehaviour
{
	public GameCharacter gameCharacter;

	[Header("Dash Settings")]
	public float walkSpeed = 2.5f;

	public float dashSpeed = 0.5f;

	public float dashDuration = 0.3f;

	private float dashTime;

	private float nextDashTime;

	private Vector3 dashDirection;

	[Header("General")]
	public Vector3 velocity;

	public Vector3 moving;

	public Vector3 actuallyMoving;

	public Vector3 slide;

	public float colliderPerc;

	public float centreY = 0.9f;

	public LayerMask scenery;

	public bool debug;

	public GameObject debugGameObject;

	public float y;

	public LayerMask floorMask;

	private void Start()
	{
		gameCharacter = GetComponentInParent<GameCharacter>();
	}

	private void reduceEffects()
	{
		CharacterEffect effect = gameCharacter.getEffect(CharacterEffect.Effect.SpeedHands);
		if (effect != null && effect.slowMo != null)
		{
			float amount = moving.magnitude / 20f * Time.deltaTime;
			effect.slowMo.reduceBy(amount);
		}
		effect = gameCharacter.getEffect(CharacterEffect.Effect.InterceptingFist);
		if (effect != null && effect.slowMo != null)
		{
			float amount2 = moving.magnitude / 50f * Time.deltaTime;
			effect.slowMo.reduceBy(amount2);
		}
		effect = gameCharacter.getEffect(CharacterEffect.Effect.SpeedKick);
		if (effect != null && effect.slowMo != null)
		{
			if (gameCharacter.vrCharacterController.onGround)
			{
				float amount3 = moving.magnitude / 20f * Time.deltaTime;
				effect.slowMo.reduceBy(amount3);
			}
			if (gameCharacter.kickController.kicking)
			{
				float amount4 = moving.magnitude / 5f * Time.deltaTime;
				effect.slowMo.reduceBy(amount4);
			}
		}
	}

	public bool dashing()
	{
		return dashTime > 0f;
	}

	public bool canDash()
	{
		if (Time.time < nextDashTime)
		{
			return false;
		}
		if (gameCharacter.kickController.kicking)
		{
			return false;
		}
		return true;
	}

	public void dash(Vector3 direction)
	{
		if (!(direction.magnitude <= 0.1f))
		{
			gameCharacter.trackers.turn();
			nextDashTime = Time.time + dashDuration + 1f;
			dashTime = dashDuration;
			dashDirection = direction.normalized;
		}
	}

	private void updateColliderSize()
	{
		if (gameCharacter.isPlayer())
		{
			gameCharacter.vrCharacterController.colliderRadius = 0.2f;
			return;
		}
		if (slide.magnitude > 0.1f && !gameCharacter.vrCharacterController.onGround)
		{
			colliderPerc = Mathf.MoveTowards(colliderPerc, 0f, Time.deltaTime * 2f);
		}
		else
		{
			colliderPerc = Mathf.MoveTowards(colliderPerc, 1f, Time.deltaTime / 3f);
		}
		gameCharacter.vrCharacterController.colliderRadius = Mathf.Lerp(0.2f, 0.5f, colliderPerc);
		if (gameCharacter.closestEnemy != null)
		{
			float num = (gameCharacter.closestEnemy.standPosition - gameCharacter.standPosition).magnitude / 2f;
			if (num < 0.15f)
			{
				num = 0.15f;
			}
			if (num < gameCharacter.vrCharacterController.colliderRadius)
			{
				gameCharacter.vrCharacterController.colliderRadius = num;
			}
		}
	}

	private void Update()
	{
		if (GameController.instance == null || GameController.instance.paused)
		{
			return;
		}
		if (dashTime > 0f)
		{
			float num = dashTime / dashDuration;
			moving = Vector3.Lerp(Vector3.zero, dashDirection, num) * (1f + dashSpeed * num) * gameCharacter.data.perkMod("Short Dash", gameCharacter.standPosition);
			dashTime -= Time.deltaTime;
		}
		updateColliderSize();
		float num2 = Mathf.Clamp01((gameCharacter.trackers.transforms[0].localPosition.y - 0.6f) / 0.6f);
		if (gameCharacter.vrCharacterController.onGround)
		{
			if (gameCharacter.kickController.kicking || GameController.instance.fightState == GameController.FightState.Ready || gameCharacter.rigidBodies.isDown(allTheWay: true) || !gameCharacter.rigidBodies.fall.gotUp)
			{
				actuallyMoving = Vector3.MoveTowards(actuallyMoving, Vector3.zero, Time.deltaTime * 3f);
			}
			else
			{
				actuallyMoving = moving * walkSpeed * num2;
			}
		}
		debugGameObject.SetActive(debug);
		debugGameObject.transform.position = gameCharacter.standPosition;
		if (gameCharacter.vrCharacterController.ySpeed > 0f)
		{
			gameCharacter.rigidBodies.jumpPerc = Mathf.MoveTowards(gameCharacter.rigidBodies.jumpPerc, 1f, Time.deltaTime * 5f);
		}
		else
		{
			gameCharacter.rigidBodies.jumpPerc = Mathf.MoveTowards(gameCharacter.rigidBodies.jumpPerc, 0f, Time.deltaTime * 3f);
		}
		if (!GameController.instance.movingAllowed)
		{
			moving = Vector3.zero;
		}
		velocity = actuallyMoving * gameCharacter.walkSpeedMod() + slide;
		reduceEffects();
		if (velocity != Vector3.zero && gameCharacter.vrCharacterController != null)
		{
			gameCharacter.vrCharacterController.Move(velocity * gameCharacter.rigidBodies.fall.speedMod * Time.deltaTime);
		}
		slide = Vector3.MoveTowards(slide, Vector3.zero, Time.deltaTime * Settings.instance.recoverySpeed);
	}
}
public class CharacterNumDependant : MonoBehaviour
{
	public RigidBodies rigidbodies;

	private void Start()
	{
		rigidbodies = GetComponentInParent<RigidBodies>();
		int num = ((!(rigidbodies == null) && !(rigidbodies.character == null)) ? rigidbodies.character.id : 0);
		num %= base.transform.childCount;
		for (int i = 0; i < base.transform.childCount; i++)
		{
			base.transform.GetChild(i).gameObject.SetActive(i == num);
		}
	}

	private void Update()
	{
	}
}
public class CharacterPickerController : StandButtonsController
{
	public MenuButtonContoller buttonPrefab;

	public float radius = 2f;

	public float arc = 180f;

	private bool setup;

	public int rows = 4;

	public Transform buttonContainer;

	public List<MenuButtonContoller> buttons;

	public Material disabledMaterial;

	public StoryController story;

	public bool showingButtons;

	public float rotationSpeed;

	public GameObject heading;

	public AudioSource audioSource;

	public AudioClip disabledHitSound;

	private static float nextVoice;

	private int perRow = 10;

	private void Start()
	{
		GameData.instance.getCompleted();
		buttonContainer.position = Vector3.up * -2f;
		List<CharacterData> list = new List<CharacterData>();
		list.AddRange(GameController.instance.gameData.characters);
		list.Sort(doSort);
		float num = arc / 10f;
		int num2 = 0;
		float num3 = 1.5f;
		buttons = new List<MenuButtonContoller>();
		if (GameController.instance.specialMode.name == "One Armed Boxer")
		{
			arc = 40f;
			num = arc / 2f;
		}
		for (int i = 0; i < list.Count; i++)
		{
			if (list[i].seeable())
			{
				MenuButtonContoller menuButtonContoller = UnityEngine.Object.Instantiate(buttonPrefab, buttonContainer);
				buttons.Add(menuButtonContoller);
				float y = (0f - arc) / 2f + num * ((float)num2 + 0.5f);
				TextMeshProUGUI[] componentsInChildren = menuButtonContoller.GetComponentsInChildren<TextMeshProUGUI>();
				menuButtonContoller.setup(localise: false, LocalisationController.getText("Character: " + list[i].name, list[i].name), list[i].name, "SelectChar", selectChar, i);
				menuButtonContoller.transform.localRotation = Quaternion.Euler(-90f, y, 0f);
				menuButtonContoller.transform.localPosition = Quaternion.Euler(0f, y, 0f) * Vector3.forward * radius + Vector3.up * num3;
				componentsInChildren[0].text = LocalisationController.getText("Character: " + list[i].name, list[i].name);
				if (list[i].specialMoveName == "")
				{
					componentsInChildren[0].color = Color.grey;
				}
				CharacterButtonController component = menuButtonContoller.GetComponent<CharacterButtonController>();
				component.setTo(list[i]);
				menuButtonContoller.id = list[i].id;
				if (list[i].playable(allowUnlockedBosses: true, blockLevelLocked: true) && list[i].puppet != null)
				{
					menuButtonContoller.onSmash = disableAll;
				}
				else
				{
					menuButtonContoller.disabled = true;
					menuButtonContoller.hitSound = disabledHitSound;
					component.setTo(disabledMaterial);
					componentsInChildren[0].enabled = false;
				}
				num2++;
				if (num2 >= perRow)
				{
					num3 -= 0.33f;
					num2 = 0;
				}
			}
		}
		story.cancelButton.setup(localise: true, "Choose Another", "Choose Another", "", cancel);
		showingButtons = true;
		if (Time.time >= nextVoice)
		{
			nextVoice = Time.time + 240f;
			Invoke("voice", 0.2f);
		}
	}

	private int doSort(CharacterData char1, CharacterData char2)
	{
		if (char1.playable(allowUnlockedBosses: false, blockLevelLocked: false) && !char2.playable(allowUnlockedBosses: false, blockLevelLocked: false))
		{
			return -1;
		}
		if (!char1.playable(allowUnlockedBosses: false, blockLevelLocked: false) && char2.playable(allowUnlockedBosses: false, blockLevelLocked: false))
		{
			return 1;
		}
		if (char1.home < char2.home)
		{
			return -1;
		}
		if (char1.home > char2.home)
		{
			return 1;
		}
		if (char1.difficultyTier < char2.difficultyTier)
		{
			return -1;
		}
		if (char1.difficultyTier > char2.difficultyTier)
		{
			return 1;
		}
		return char1.name.CompareTo(char2.name);
	}

	private void voice()
	{
		GetComponent<AudioSource>().Play();
	}

	private void disableAll()
	{
	}

	private void enableAll()
	{
		foreach (MenuButtonContoller button in buttons)
		{
			button.disabled = true;
		}
	}

	private void cancel(MenuButtonContoller b)
	{
		showingButtons = true;
		story.hide();
	}

	private void selectChar(MenuButtonContoller button)
	{
		if (showingButtons)
		{
			showingButtons = false;
			GameController.instance.characterID = (GameController.instance.gameData.characterID = button.id);
			GameController.instance.costume = 0;
			WebLogging.log("Select Character", GameController.instance.selectedCharacter().name, 0f);
			story.show(GameController.instance.gameData.characters[GameController.instance.characterID]);
		}
	}

	private void Update()
	{
		noticeBoard.SetActive(OptionData.getOption("Noticeboard").value == 0);
		heading.SetActive(showingButtons);
		if (GameController.instance.player == null && GameController.instance.gameMode != 0 && !setup)
		{
			setup = true;
			if (spawnPoints.Length == 0)
			{
				spawnPoints = GetComponentsInChildren<SpawnPointController>();
			}
			GameController.instance.standButtons = this;
			if (editCam != null)
			{
				editCam.gameObject.SetActive(value: false);
			}
		}
		if (!(GameController.instance.player != null))
		{
			return;
		}
		_ = GameController.instance.player.standPosition;
		float magnitude = buttonContainer.position.magnitude;
		foreach (MenuButtonContoller button in buttons)
		{
			button.disabled = magnitude > 0f;
		}
		Vector3 vector = ((!showingButtons) ? (Vector3.up * -2f) : Vector3.zero);
		float target = 1f;
		if ((vector - buttonContainer.transform.position).magnitude == 0f)
		{
			target = 0f;
		}
		buttonContainer.position = Vector3.MoveTowards(buttonContainer.position, vector, Time.deltaTime * 1f);
		rotationSpeed = Mathf.MoveTowards(rotationSpeed, target, Time.deltaTime);
		rotationSpeed = 0f;
		buttonContainer.transform.rotation *= Quaternion.Euler(0f, 90f * rotationSpeed * Time.deltaTime, 0f);
	}
}
public class CharacterPortraitController : StandButtonsController
{
	public float timer;

	public int onChar;

	private int onStage;

	private int onCam;

	private GameCharacter character;

	public TakePhoto[] cameras;

	public bool done;

	public List<CharacterData> queue = new List<CharacterData>();

	public string folder;

	private void Start()
	{
		cameras = GetComponentsInChildren<TakePhoto>();
		timer = 1f;
		GameCharacter componentInChildren = GetComponentInChildren<GameCharacter>();
		if (componentInChildren != null)
		{
			UnityEngine.Object.Destroy(componentInChildren.gameObject);
		}
		GameController.instance.gameMode = GameController.GameMode.Edit;
		GameController.instance.aiMode = 5;
		CharacterData[] characters = GameController.instance.gameData.characters;
		foreach (CharacterData characterData in characters)
		{
			if (!File.Exists(folder + "\\" + characterData.name + ".png") && !File.Exists(folder + "\\" + characterData.name + "_1.png") && !File.Exists(folder + "\\" + characterData.name + "_2.png"))
			{
				queue.Add(characterData);
			}
		}
	}

	private void Update()
	{
		if (done)
		{
			return;
		}
		if (onStage == 1)
		{
			if (onCam < cameras.Length)
			{
				if (character != null)
				{
					cameras[onCam].transform.LookAt(character.rigidBodies.head.position - Vector3.up * 0.1f + character.rigidBodies.head.forward * 0.2f);
				}
			}
			else
			{
				onStage++;
			}
		}
		if (timer < 0f)
		{
			switch (onStage)
			{
			case 0:
				character = GameController.instance.addFighter(1, queue[onChar], 1, base.transform.position, 180f, 1f, aboveGround: false);
				GameController.instance.hud.setup();
				timer = 2f;
				onStage++;
				onCam = 0;
				break;
			case 1:
				cameras[onCam].GetComponent<Camera>().backgroundColor = Color.Lerp(Color.white - character.data.healthBarColour, Color.black, 0.5f);
				if (onCam > 0)
				{
					cameras[onCam].fileName = character.data.name + "_" + onCam + ".png";
				}
				else
				{
					cameras[onCam].fileName = character.data.name + ".png";
				}
				cameras[onCam].takePhoto = true;
				onCam++;
				timer = 0.3f;
				break;
			case 2:
				GameController.instance.removeFighter(character);
				timer = 0.2f;
				onStage = 0;
				onChar++;
				if (onChar >= queue.Count)
				{
					onChar = 0;
					done = true;
				}
				break;
			}
		}
		timer -= Time.deltaTime;
	}
}
[Serializable]
public class CharacterVoice
{
	[Range(0f, 1f)]
	public float volume = 0.5f;

	public VoiceData[] phrases;

	[NonSerialized]
	public CharacterData characterData;

	public VoiceData IntroPhrase(bool returning)
	{
		List<VoiceData> list = new List<VoiceData>();
		VoiceData[] array = phrases;
		foreach (VoiceData voiceData in array)
		{
			if ((voiceData.type == VoiceData.Type.Intro || (returning && voiceData.type == VoiceData.Type.IntroOnReturn)) && voiceData.restrictionAllow(characterData, GameController.instance.selectedCharacter(), 1f))
			{
				list.Add(voiceData);
			}
		}
		if (list.Count == 0)
		{
			return null;
		}
		list.Sort(delegate(VoiceData v1, VoiceData v2)
		{
			v1.orderNum = (float)v1.useCount + UnityEngine.Random.value / 2f;
			v2.orderNum = (float)v2.useCount + UnityEngine.Random.value / 2f;
			if (v1.type != VoiceData.Type.IntroOnReturn)
			{
				v1.orderNum *= 2f;
			}
			if (v2.type != VoiceData.Type.IntroOnReturn)
			{
				v2.orderNum *= 2f;
			}
			return v1.orderNum.CompareTo(v2.orderNum);
		});
		int index = UnityEngine.Random.Range(0, UnityEngine.Random.Range(0, list.Count));
		return list[index];
	}

	public VoiceData PhraseOfType(VoiceData.Type type, float randomAmount)
	{
		if (!OptionData.getBool("Voices"))
		{
			return null;
		}
		List<VoiceData> list = new List<VoiceData>();
		VoiceData[] array = phrases;
		foreach (VoiceData voiceData in array)
		{
			if (voiceData.type == type && voiceData.restrictionAllow(characterData, GameController.instance.selectedCharacter(), randomAmount))
			{
				list.Add(voiceData);
			}
		}
		if (list.Count == 0)
		{
			return null;
		}
		list.Sort(delegate(VoiceData v1, VoiceData v2)
		{
			v1.orderNum = v1.useCount;
			v2.orderNum = v2.useCount;
			return v1.orderNum.CompareTo(v2.orderNum);
		});
		int index = UnityEngine.Random.Range(0, UnityEngine.Random.Range(0, list.Count));
		list[index].useCount++;
		return list[index];
	}
}
public class ChiBallController : ProjectileController
{
	public Light light;

	private float intensity;

	public Transform[] transforms;

	public float forwardDist = 0.15f;

	public ParticleSystem summon;

	public ParticleSystem[] handSummon;

	public ParticleSystem burst;

	public Transform scalable;

	public Transform handParticles;

	public float life = 6f;

	private Quaternion lastAngle;

	private float nextImpact;

	private void Start()
	{
		intensity = light.intensity;
		light.intensity = 0f;
		scalable.localScale = Vector3.zero;
		transforms = new Transform[2];
		transforms[0] = following.character.rigidBodies.leftHand.transform;
		transforms[1] = following.character.rigidBodies.rightHand.transform;
		Vector3 position = Vector3.Lerp(transforms[0].position, transforms[1].position, 0.5f);
		lastAngle = Quaternion.LookRotation(transforms[1].position - transforms[0].position);
		base.transform.position = position;
		rb.isKinematic = true;
	}

	public override void OnCollisionEnter(Collision collision)
	{
		if (!(nextImpact > Time.time))
		{
			nextImpact = Time.time + 0.25f;
			audioSource.PlayOneShot(hitSound);
			base.OnCollisionEnter(collision);
		}
	}

	public Vector3 targetPos()
	{
		return Vector3.Lerp(transforms[0].position, transforms[1].position, 0.5f) + GameController.flatVector(firer.trackers.transforms[0].forward * forwardDist);
	}

	private void Update()
	{
		ParticleSystem.MainModule main = summon.main;
		ParticleSystem.EmissionModule emission = summon.emission;
		if (transforms[0] == null && transforms[1] == null)
		{
			if (life > 0f)
			{
				explode(isPerson: false);
				life = 0f;
			}
			return;
		}
		if (scalable.localScale.x < 1f)
		{
			light.intensity = scalable.localScale.x * intensity * (UnityEngine.Random.value * 0.5f + 0.5f);
			audioSource.volume = scalable.localScale.x;
			handParticles.rotation = Quaternion.LookRotation(transforms[1].position - transforms[0].position);
			float num = Quaternion.Angle(lastAngle, handParticles.rotation);
			scalable.localScale = Vector3.MoveTowards(scalable.localScale, Vector3.one, Time.deltaTime / 10f + num / 360f);
			lastAngle = handParticles.rotation;
			if (scalable.localScale.x == 1f)
			{
				rb.isKinematic = false;
				emission.rateOverTime = 0f;
				handParticles.gameObject.SetActive(value: false);
				burst.Play();
			}
			else
			{
				ParticleSystem[] array = handSummon;
				for (int i = 0; i < array.Length; i++)
				{
					emission = array[i].emission;
					emission.rateOverTime = 10f * scalable.localScale.x;
				}
			}
		}
		else
		{
			life -= Time.deltaTime;
			if (life < 0f)
			{
				explode(isPerson: false);
			}
		}
		main.simulationSpeed = Mathf.MoveTowards(main.simulationSpeed, 1f, Time.deltaTime);
		float num2 = Mathf.Clamp01(1f - scalable.localScale.x) * 20f;
		base.transform.rotation = Quaternion.RotateTowards(base.transform.rotation, Quaternion.LookRotation(transforms[1].position - transforms[0].position), 360f * num2);
		base.transform.position = Vector3.MoveTowards(base.transform.position, targetPos(), Time.deltaTime * num2);
	}
}
public class ColliderCheck : MonoBehaviour
{
}
public class ContentBreakAllController : MonoBehaviour
{
	private ChamberController chamber;

	public Breakable[] breakables;

	public bool allBroken;

	private void Start()
	{
		chamber = GetComponentInParent<ChamberController>();
		if (chamber != null)
		{
			chamber.isComplete = false;
		}
		breakables = GetComponentsInChildren<Breakable>();
	}

	private void Update()
	{
		if (chamber != null && chamber.isComplete)
		{
			return;
		}
		allBroken = true;
		Breakable[] array = breakables;
		foreach (Breakable breakable in array)
		{
			if (breakable.hasFailed && chamber != null)
			{
				chamber.perfect = false;
			}
			if (breakable != null && !breakable.broken)
			{
				allBroken = false;
			}
		}
		if (chamber != null)
		{
			chamber.isComplete = allBroken;
		}
	}
}
public class ControllerArrowController : MonoBehaviour
{
	public GameObject[] arrows;

	private void Start()
	{
	}

	public void show(bool up, bool down, bool left, bool right)
	{
		arrows[0].SetActive(up);
		arrows[1].SetActive(left);
		arrows[2].SetActive(down);
		arrows[3].SetActive(right);
		base.gameObject.SetActive(value: true);
	}

	public void hide()
	{
		base.gameObject.SetActive(value: false);
	}

	private void Update()
	{
	}
}
public class ControllerTipController : MonoBehaviour
{
	public Material highlightMaterial;

	public Material ghostBodyMaterial;

	public bool hide;

	public Color onColour = Color.white;

	private float colourPerc = 1f;

	public Transform head;

	public ButtonPositionsController rController;

	public ButtonPositionsController lController;

	public VRRig rig;

	public string currentLabel;

	private void Start()
	{
		rig = GetComponent<VRRig>();
	}

	public void refresh()
	{
		if (!(rController == null) && !(lController == null))
		{
			rController.refresh();
			lController.refresh();
		}
	}

	public void showLeftArrows(bool up, bool down, bool left, bool right)
	{
	}

	public void showRightArrows(bool up, bool down, bool left, bool right)
	{
	}

	public void tip(VRControlTip controlTip, float time)
	{
		if (controlTip.seen < controlTip.maxSeen && !(Time.time < controlTip.nextSeeTime))
		{
			controlTip.seen++;
			controlTip.nextSeeTime = Time.time + 30f;
			clearArrows();
			tip(controlTip.leftButtons, controlTip.rightButtons, controlTip.tip, time);
			if (controlTip.leftArrows)
			{
				showLeftArrows(controlTip.arrow_up, controlTip.arrow_down, controlTip.arrow_left, controlTip.arrow_right);
			}
			if (controlTip.rightArrows)
			{
				showRightArrows(controlTip.arrow_up, controlTip.arrow_down, controlTip.arrow_left, controlTip.arrow_right);
			}
			Saving.instance.gameSettings.saveControllerTips();
		}
	}

	private void clearArrows()
	{
	}

	public void clearFistTip()
	{
		clearTip();
	}

	public void fistTip()
	{
		tip(new Pvr_KeyCode[2]
		{
			Pvr_KeyCode.TRIGGER,
			Pvr_KeyCode.Left
		}, new Pvr_KeyCode[2]
		{
			Pvr_KeyCode.TRIGGER,
			Pvr_KeyCode.Right
		}, "Make Fists");
	}

	public void tip(Pvr_KeyCode[] leftActions, Pvr_KeyCode[] rightActions, string label, float time = 10f)
	{
		currentLabel = LocalisationController.getText("Control Tip", label);
		if (lController == null || rController == null)
		{
			UnityEngine.Debug.LogError("Controller tips are null");
			return;
		}
		lController.show(leftActions, time);
		rController.show(rightActions, time);
	}

	public void tip(Pvr_KeyCode action, bool left, string label, float time = 10f)
	{
		Pvr_KeyCode[] leftActions;
		Pvr_KeyCode[] rightActions;
		if (left)
		{
			leftActions = new Pvr_KeyCode[1] { action };
			rightActions = new Pvr_KeyCode[0];
		}
		else
		{
			rightActions = new Pvr_KeyCode[1] { action };
			leftActions = new Pvr_KeyCode[0];
		}
		tip(leftActions, rightActions, label, time);
	}

	public void clearTip()
	{
		if (!(lController == null) && !(rController == null))
		{
			currentLabel = "";
			lController.clear();
			rController.clear();
			clearArrows();
		}
	}

	private void Update()
	{
		if (lController == null)
		{
			lController = rig.trackers[1].parent.GetComponentInChildren<ButtonPositionsController>();
		}
		if (rController == null)
		{
			rController = rig.trackers[2].parent.GetComponentInChildren<ButtonPositionsController>();
		}
		if (!(lController == null) && !(rController == null))
		{
			colourPerc -= Time.deltaTime;
			if (colourPerc < 0f)
			{
				colourPerc += 1f;
			}
			ControllerTipTextController.instance.UpdatePosition(this);
		}
	}
}
public class ControllerTipTextController : MonoBehaviour
{
	public static ControllerTipTextController instance;

	public TextMeshProUGUI tip;

	public LineRenderer[] lines;

	private void Start()
	{
		instance = this;
	}

	public void UpdatePosition(ControllerTipController tip)
	{
		if (!tip.lController.showing() && !tip.rController.showing())
		{
			base.gameObject.SetActive(value: false);
			return;
		}
		this.tip.text = tip.currentLabel;
		base.gameObject.SetActive(value: true);
		Vector3 vector = ((tip.lController.showing() && tip.rController.showing()) ? Vector3.Lerp(tip.lController.transform.position, tip.rController.transform.position, 0.5f) : ((!tip.lController.showing()) ? (tip.rController.transform.position - tip.head.right * 0.1f * tip.transform.localScale.x) : (tip.lController.transform.position + tip.head.right * 0.1f * tip.transform.localScale.x)));
		float magnitude = (vector - tip.head.position).magnitude;
		magnitude = 0.35f * tip.transform.localScale.x;
		Vector3 b = tip.head.position + tip.head.forward * magnitude;
		if (vector.y < 0.25f)
		{
			vector.y = 0.25f;
		}
		float num = Mathf.Clamp01(Quaternion.Angle(Quaternion.LookRotation(tip.head.forward), Quaternion.LookRotation(vector - tip.head.position)) / 90f);
		if (num < 0.1f)
		{
			num = 0.1f;
		}
		lines[1].enabled = tip.rController.showing();
		base.transform.position = Vector3.Lerp(vector, b, num);
		for (int i = 0; i < 2; i++)
		{
			ButtonPositionsController buttonPositionsController = ((i == 0) ? tip.lController : tip.rController);
			lines[i].enabled = buttonPositionsController.showing();
			if (lines[i].enabled)
			{
				lines[i].SetPosition(0, base.transform.position + tip.head.forward * 0.01f);
				lines[i].SetPosition(1, buttonPositionsController.highlightedPosition());
			}
		}
		base.transform.LookAt(tip.head.position);
		base.transform.localScale = tip.transform.localScale;
	}

	private void Update()
	{
	}
}
public class CopyPuppets : MonoBehaviour
{
	public RigidBodies source;

	public RigidBodies[] copyTo;

	public MaterialSwap[] materials;

	public AudioClip swipe;

	public string[] hideFromVRCam;

	private void Start()
	{
		source.pm = source.GetComponentInChildren<PuppetMaster>();
		RigidBodies[] array = copyTo;
		foreach (RigidBodies rigidBodies in array)
		{
			if (rigidBodies == source)
			{
				UnityEngine.Debug.LogError("Cant copy to itself");
				continue;
			}
			copy(rigidBodies);
			swapMaterials(rigidBodies);
		}
	}

	private void swapMaterials(RigidBodies target)
	{
		if (target == null)
		{
			UnityEngine.Debug.LogError("Skipped, cos null");
			return;
		}
		Animator componentInChildren = target.gameObject.GetComponentInChildren<Animator>();
		componentInChildren.cullingMode = AnimatorCullingMode.AlwaysAnimate;
		SkinnedMeshRenderer[] componentsInChildren = componentInChildren.GetComponentsInChildren<SkinnedMeshRenderer>();
		UnityEngine.Debug.Log("Checking: " + componentsInChildren.Length + " meshes " + target.name);
		SkinnedMeshRenderer[] array = componentsInChildren;
		foreach (SkinnedMeshRenderer skinnedMeshRenderer in array)
		{
			Material[] sharedMaterials = skinnedMeshRenderer.sharedMaterials;
			skinnedMeshRenderer.updateWhenOffscreen = true;
			UnityEngine.Debug.Log("Checking: " + skinnedMeshRenderer.name + " mats " + sharedMaterials.Length);
			for (int j = 0; j < sharedMaterials.Length; j++)
			{
				MaterialSwap[] array2 = materials;
				foreach (MaterialSwap materialSwap in array2)
				{
					if (sharedMaterials[j] == null)
					{
						UnityEngine.Debug.LogError(skinnedMeshRenderer.name + " in " + target.name + " has null material");
					}
					UnityEngine.Debug.Log("Checking: " + sharedMaterials[j].name + " contains " + materialSwap.name + ": " + sharedMaterials[j].name.Contains(materialSwap.name));
					if (sharedMaterials[j].name.Contains(materialSwap.name))
					{
						if (sharedMaterials[j].name != materialSwap.material.name)
						{
							UnityEngine.Debug.LogError("Swap mat: " + sharedMaterials[j].name + " > " + materialSwap.material?.ToString() + " (" + target.name + ")");
						}
						sharedMaterials[j] = materialSwap.material;
					}
				}
			}
			skinnedMeshRenderer.sharedMaterials = sharedMaterials;
		}
	}

	private string norm(string name)
	{
		return name.ToLower().Replace("hips", "pelvis").Replace("unity compliant skeleton", "pelvis")
			.Replace("spine_02", "chest")
			.Replace("calf", "shin")
			.Replace("upper_arm", "upperarm")
			.Replace("lowerarm", "forearm")
			.Replace("head 1", "head")
			.Replace('_', '.');
	}

	private Muscle getMuscleByName(Muscle[] muscles, string name, string puppetName)
	{
		string text = "";
		foreach (Muscle muscle in muscles)
		{
			if (norm(muscle.name) == norm(name))
			{
				return muscle;
			}
			text = text + norm(muscle.name) + "==" + norm(name) + ", ";
		}
		UnityEngine.Debug.LogError(puppetName + " - Couldnt find: " + norm(name) + " (" + name + ") : " + text);
		return null;
	}

	private void removeSwooshes(GameObject go, string name)
	{
		SwooshIfFast component = go.GetComponent<SwooshIfFast>();
		AudioSource component2 = go.GetComponent<AudioSource>();
		if (component != null)
		{
			UnityEngine.Debug.LogError("Removing swoosh  from " + name);
			UnityEngine.Object.DestroyImmediate(component, allowDestroyingAssets: true);
		}
		if (component2 != null)
		{
			UnityEngine.Debug.LogError("Removing audio from " + name);
			UnityEngine.Object.DestroyImmediate(component2, allowDestroyingAssets: true);
		}
	}

	private void copy(RigidBodies target)
	{
		if (target == null)
		{
			UnityEngine.Debug.LogError("Skipped, cos null");
			return;
		}
		target.transform.localPosition = Vector3.zero;
		target.pm = target.GetComponentInChildren<PuppetMaster>();
		target.pm.humanoidConfig = source.pm.humanoidConfig;
		Muscle muscleByName = getMuscleByName(target.pm.muscles, "foot_l", target.name);
		Muscle muscleByName2 = getMuscleByName(target.pm.muscles, "foot_r", target.name);
		muscleByName.joint.GetComponent<BoxCollider>().enabled = true;
		muscleByName2.joint.GetComponent<BoxCollider>().enabled = true;
		Muscle muscleByName3 = getMuscleByName(source.pm.muscles, "head", target.name);
		Muscle muscleByName4 = getMuscleByName(target.pm.muscles, "head", target.name);
		FaceController component = muscleByName3.target.gameObject.GetComponent<FaceController>();
		FaceController faceController = muscleByName4.target.gameObject.GetComponent<FaceController>();
		if (faceController == null)
		{
			faceController = muscleByName4.target.gameObject.AddComponent<FaceController>();
		}
		faceController.eyelids = new Eyelid[2];
		faceController.puppet = target;
		foreach (Transform item in faceController.transform)
		{
			if (item.gameObject.name == "uplid.L" || item.gameObject.name == "uplid.R")
			{
				int num = ((!(item.gameObject.name == "uplid.L")) ? 1 : 0);
				Eyelid eyelid = item.gameObject.GetComponent<Eyelid>();
				if (eyelid == null)
				{
					eyelid = item.gameObject.AddComponent<Eyelid>();
				}
				component.eyelids = component.GetComponentsInChildren<Eyelid>();
				Eyelid eyelid2 = component.eyelids[num];
				eyelid.openPos = eyelid2.openPos;
				eyelid.closedPos = eyelid2.closedPos;
			}
		}
		getMuscleByName(target.pm.muscles, "hand_l", target.name);
		getMuscleByName(target.pm.muscles, "hand_r", target.name);
		for (int i = 0; i < target.pm.muscles.Length; i++)
		{
			Muscle muscle = source.pm.muscles[i];
			Muscle muscleByName5 = getMuscleByName(target.pm.muscles, muscle.name, target.name);
			if (muscleByName5 == null)
			{
				UnityEngine.Debug.Log("Null muscle on: " + target.name);
				continue;
			}
			BoxCollider component2 = muscle.joint.GetComponent<BoxCollider>();
			BoxCollider component3 = muscleByName5.joint.GetComponent<BoxCollider>();
			CapsuleCollider component4 = muscle.joint.GetComponent<CapsuleCollider>();
			CapsuleCollider component5 = muscleByName5.joint.GetComponent<CapsuleCollider>();
			if (component2 != null)
			{
				component3.center = component2.center;
				component3.size = component2.size;
			}
			else
			{
				component5.center = component4.center;
				component5.radius = component4.radius;
				component5.height = component4.height;
			}
		}
		GameObject gameObject = source.GetComponentInChildren<Animator>().gameObject;
		GameObject gameObject2 = target.GetComponentInChildren<Animator>().gameObject;
		VRIK component6 = gameObject.GetComponent<VRIK>();
		VRIK vRIK = gameObject2.GetComponent<VRIK>();
		if (vRIK == null)
		{
			vRIK = gameObject2.AddComponent<VRIK>();
		}
		vRIK.solver.plantFeet = component6.solver.plantFeet;
		vRIK.solver.locomotion.footDistance = component6.solver.locomotion.footDistance;
		vRIK.solver.locomotion.stepThreshold = component6.solver.locomotion.stepThreshold;
		vRIK.solver.locomotion.angleThreshold = component6.solver.locomotion.angleThreshold;
		vRIK.solver.locomotion.comAngleMlp = component6.solver.locomotion.comAngleMlp;
		vRIK.solver.locomotion.maxVelocity = component6.solver.locomotion.maxVelocity;
		vRIK.solver.locomotion.velocityFactor = component6.solver.locomotion.velocityFactor;
		vRIK.solver.locomotion.maxLegStretch = component6.solver.locomotion.maxLegStretch;
		vRIK.solver.locomotion.rootSpeed = component6.solver.locomotion.rootSpeed;
		vRIK.solver.locomotion.stepSpeed = component6.solver.locomotion.stepSpeed;
		foreach (Transform item2 in gameObject2.transform)
		{
			string[] array = hideFromVRCam;
			foreach (string value in array)
			{
				if (item2.gameObject.name.Contains(value) && item2.gameObject.layer == 0)
				{
					item2.gameObject.layer = 15;
				}
			}
		}
	}
}
public class CrowdAnimation : MonoBehaviour
{
	public float clapTime;

	private Animator anim;

	public int idle;

	public bool setup;

	public MeshRenderer billboard;

	public GameObject bodyParts;

	public CrowdPersonMaterials materials;

	private void Start()
	{
		anim = GetComponent<Animator>();
		anim.speed = UnityEngine.Random.value * 0.5f + 0.5f;
		anim.Play("Idle", 0, UnityEngine.Random.value);
		materials = GetComponent<CrowdPersonMaterials>();
		Invoke("fr", 0.5f);
		idle = UnityEngine.Random.Range(0, 2);
		anim.SetInteger("Idle", idle);
	}

	private void fr()
	{
		if (GameController.instance != null)
		{
			anim.enabled = UnityEngine.Random.value > 0.8f;
		}
		else
		{
			anim.enabled = materials.takePic;
		}
		billboard.gameObject.SetActive(!anim.enabled);
		if (!anim.enabled)
		{
			billboard.material.SetTexture("_MainTex", materials.billBoardTexture);
		}
		bodyParts.gameObject.SetActive(anim.enabled);
		setup = true;
	}

	public void clap()
	{
		clapTime = UnityEngine.Random.Range(2, 5);
	}

	private void Update()
	{
		clapTime = Mathf.MoveTowards(clapTime, 0f, Time.deltaTime);
		anim.SetBool("Clapping", clapTime > 0f);
	}
}
public class CrowdArray : MonoBehaviour
{
	public CrowdAnimation prefab;

	public Vector3 spacing;

	public Vector3 randomise;

	public int amount = 10;

	public Vector2 size;

	public float likelihood = 0.5f;

	public CrowdAnimation[] people;

	public List<CrowdPersonMaterials> queue;

	private float picTimer = 2f;

	private void Start()
	{
		List<CrowdAnimation> list = new List<CrowdAnimation>();
		int num = UnityEngine.Random.Range(1, 15);
		num = 100;
		for (int i = 0; (float)i < size.y; i++)
		{
			for (int j = 0; (float)j < size.x; j++)
			{
				if (num > 0)
				{
					CrowdAnimation crowdAnimation = UnityEngine.Object.Instantiate(prefab, base.transform);
					crowdAnimation.transform.localPosition = new Vector3(spacing.x * (float)j, spacing.y * (float)i, spacing.z * (float)i) + new Vector3(randomise.x * (UnityEngine.Random.value - UnityEngine.Random.value), randomise.y * (UnityEngine.Random.value - UnityEngine.Random.value), randomise.z * (UnityEngine.Random.value - UnityEngine.Random.value));
					num--;
					list.Add(crowdAnimation);
					CrowdPersonMaterials component = crowdAnimation.GetComponent<CrowdPersonMaterials>();
					component.Setup();
					if (component.takePic)
					{
						queue.Add(component);
					}
				}
				else
				{
					num = UnityEngine.Random.Range(1, 3);
				}
			}
		}
		people = list.ToArray();
	}

	private void Update()
	{
		if (queue.Count <= 0)
		{
			return;
		}
		if (picTimer > 0f)
		{
			picTimer -= Time.deltaTime;
			return;
		}
		picTimer = 1.5f;
		CrowdAnimation[] array = people;
		foreach (CrowdAnimation crowdAnimation in array)
		{
			crowdAnimation.gameObject.SetActive(crowdAnimation.GetComponent<CrowdPersonMaterials>() == queue[0]);
		}
		queue[0].billboardMaker.fileName = queue[0].GetComponent<CrowdPersonMaterials>().code;
		queue[0].billboardMaker.direction = queue[0].GetComponent<CrowdPersonMaterials>().direction;
		queue[0].billboardMaker.gameObject.SetActive(value: true);
		queue.RemoveAt(0);
	}

	public void ShowAngle(Transform head)
	{
		if (queue.Count <= 0)
		{
			Quaternion b = Quaternion.LookRotation(GameController.flatVector(head.forward));
			CrowdAnimation[] array = people;
			foreach (CrowdAnimation crowdAnimation in array)
			{
				float num = Quaternion.Angle(Quaternion.LookRotation(GameController.flatVector(crowdAnimation.transform.position - head.position)), b);
				crowdAnimation.gameObject.SetActive(num <= 50f || crowdAnimation.clapTime > 0f || !crowdAnimation.setup);
			}
		}
	}

	public void clap()
	{
		CrowdAnimation[] array = people;
		foreach (CrowdAnimation crowdAnimation in array)
		{
			if (crowdAnimation.gameObject.activeInHierarchy)
			{
				crowdAnimation.clap();
			}
		}
	}
}
public class CrowdController : MonoBehaviour
{
	public static CrowdController instance;

	public AudioClip clapSound;

	public CrowdArray[] crowd;

	public bool doClap;

	private AudioSource audioSource;

	public int showAngle;

	private void Start()
	{
		instance = this;
		audioSource = GetComponent<AudioSource>();
	}

	public static void applause()
	{
		if (!(instance == null))
		{
			instance.clap();
		}
	}

	public void clap()
	{
		audioSource.PlayOneShot(clapSound);
		CrowdArray[] array = crowd;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].clap();
		}
	}

	private void Update()
	{
		if (doClap)
		{
			doClap = false;
			clap();
		}
		if (GameController.instance == null)
		{
			return;
		}
		Transform transform = ((GameController.instance.player != null && GameController.instance.player.playerController.inBody) ? GameController.instance.player.trackers.transforms[0] : GameController.instance.noPlayer.activeRig.trackers[0]);
		int num = Mathf.RoundToInt(transform.rotation.eulerAngles.y);
		if (num != showAngle)
		{
			showAngle = num;
			CrowdArray[] array = crowd;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].ShowAngle(transform);
			}
		}
	}
}
[Serializable]
public class CrowdMaterial
{
	public Material material;

	[Range(0f, 1f)]
	public float likelihood = 1f;
}
public class CrowdPersonMaterials : MonoBehaviour
{
	public Material hairMaterial;

	public Material mainMaterial;

	public Material trimMaterial;

	public CrowdMaterial[] hairMaterials;

	public CrowdMaterial[] mainMaterials;

	public CrowdMaterial[] trimMaterials;

	public CrowdPersonMesh[] meshes;

	public bool setupOnLoad;

	public string direction;

	public string code;

	public bool takePic;

	public BillboardMaker billboardMaker;

	public Texture billBoardTexture;

	private static int onTexture;

	private void Start()
	{
		if (setupOnLoad)
		{
			Setup();
		}
	}

	public void Setup()
	{
		direction = Mathf.Round(base.transform.rotation.eulerAngles.y / 90f).ToString();
		code = "crowd";
		hairMaterial = randomMaterial(hairMaterials);
		mainMaterial = randomMaterial(mainMaterials);
		trimMaterial = randomMaterial(trimMaterials);
		meshes = GetComponentsInChildren<CrowdPersonMesh>();
		CrowdPersonMesh[] array = meshes;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].Setup(this);
		}
		if (GameController.instance == null)
		{
			if (!Directory.Exists("C:/Users/djsta/Dropbox/GameDev/Unity/DragonFist/Assets/Resources/crowd/" + direction))
			{
				UnityEngine.Debug.LogError("Create directory: C:/Users/djsta/Dropbox/GameDev/Unity/DragonFist/Assets/Resources/crowd/" + direction);
				Directory.CreateDirectory("C:/Users/djsta/Dropbox/GameDev/Unity/DragonFist/Assets/Resources/crowd/" + direction);
			}
			else
			{
				UnityEngine.Debug.LogError("Exists: C:/Users/djsta/Dropbox/GameDev/Unity/DragonFist/Assets/Resources/crowd/" + direction);
			}
		}
		billBoardTexture = Resources.Load<Texture>("crowd/" + direction + "/" + code);
		if (billBoardTexture == null)
		{
			Texture[] array2 = Resources.LoadAll<Texture>("crowd/" + direction);
			if (onTexture >= array2.Length || UnityEngine.Random.value < 0.2f)
			{
				onTexture = 0;
			}
			billBoardTexture = array2[onTexture];
			onTexture++;
		}
		if (billBoardTexture == null)
		{
			takePic = GameController.instance == null;
		}
	}

	private Material randomMaterial(CrowdMaterial[] mats)
	{
		List<CrowdMaterial> list = new List<CrowdMaterial>();
		foreach (CrowdMaterial crowdMaterial in mats)
		{
			if (crowdMaterial.likelihood == 0f)
			{
				crowdMaterial.likelihood = 1f;
			}
			if (UnityEngine.Random.value < crowdMaterial.likelihood)
			{
				list.Add(crowdMaterial);
			}
		}
		int num;
		if (list.Count == 0)
		{
			num = UnityEngine.Random.Range(0, mats.Length);
			code = code + "_" + num;
			return mats[UnityEngine.Random.Range(0, mats.Length)].material;
		}
		num = UnityEngine.Random.Range(0, list.Count);
		code = code + "_" + num;
		return list[UnityEngine.Random.Range(0, list.Count)].material;
	}

	private void Update()
	{
	}
}
public class CrowdPersonMesh : MonoBehaviour
{
	public CrowdPersonMesh ifNot;

	public float likelihood;

	public float random;

	public string debug;

	public CrowdPersonMeshMaterial.Type[] setMaterials;

	private SkinnedMeshRenderer mesh;

	public bool hidden;

	private void Start()
	{
	}

	public void Setup(CrowdPersonMaterials crowdMaterials)
	{
		random = UnityEngine.Random.value;
		if (ifNot != null && !ifNot.hidden)
		{
			base.gameObject.SetActive(value: false);
			debug = "other is active";
			hidden = true;
		}
		else if (random >= likelihood)
		{
			base.gameObject.SetActive(value: false);
			debug = random + "<" + likelihood;
			hidden = true;
		}
		else
		{
			base.gameObject.SetActive(value: true);
			debug = "active";
			hidden = false;
		}
		if (setMaterials.Length == 0)
		{
			return;
		}
		mesh = GetComponent<SkinnedMeshRenderer>();
		Material[] materials = mesh.materials;
		for (int i = 0; i < setMaterials.Length; i++)
		{
			switch (setMaterials[i])
			{
			case CrowdPersonMeshMaterial.Type.Hair:
				materials[i] = crowdMaterials.hairMaterial;
				break;
			case CrowdPersonMeshMaterial.Type.Main:
				materials[i] = crowdMaterials.mainMaterial;
				break;
			case CrowdPersonMeshMaterial.Type.Trim:
				materials[i] = crowdMaterials.trimMaterial;
				break;
			}
		}
		mesh.materials = materials;
	}

	private void Update()
	{
	}
}
public class CrowdPersonMeshMaterial : MonoBehaviour
{
	public enum Type
	{
		None,
		Hair,
		Main,
		Trim
	}

	public Type type;

	public int materialNum;

	private void Start()
	{
	}

	private void Update()
	{
	}
}
public class CustomHandPose : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
	}
}
public class DaggerGameController : MonoBehaviour
{
	public Transform innerContainer;

	public GrabSpecialMove[] daggers;

	public TextMeshProUGUI text;

	public int score;

	public int best;

	public int daggerCount;

	public bool over = true;

	public Light spotLight;

	private float restartTimer;

	private float finishTime;

	private void Start()
	{
		best = Mathf.RoundToInt(Saving.instance.savedProgress.stats.getStat("Dagger Targets Score").value);
	}

	private void Restart()
	{
		score = 0;
		over = false;
		GrabSpecialMove[] array = daggers;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].gameObject.SetActive(value: true);
		}
	}

	private void Update()
	{
		bool flag = GameController.instance.fightState == GameController.FightState.Pre && GameController.instance.player != null;
		if (flag)
		{
			flag = (base.transform.position - GameController.instance.player.standPosition).magnitude < 3f;
		}
		innerContainer.gameObject.SetActive(flag);
		spotLight.gameObject.SetActive(flag);
		if (over)
		{
			restartTimer -= Time.deltaTime;
			if (restartTimer < 0f)
			{
				Restart();
			}
		}
		else
		{
			if (GameController.instance.player == null || GameController.instance.player.rigidBodies.rightHand.specialMove != null || GameController.instance.player.rigidBodies.leftHand.specialMove != null)
			{
				return;
			}
			bool flag2 = false;
			foreach (ProjectileController projectile in GameController.instance.projectiles)
			{
				if (projectile != null && projectile.inMotion)
				{
					flag2 = true;
				}
			}
			if (flag2)
			{
				text.text = LocalisationController.getText("Dagger Targets", "Thrown...");
				return;
			}
			daggerCount = 0;
			GrabSpecialMove[] array = daggers;
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i].gameObject.activeInHierarchy)
				{
					daggerCount++;
				}
			}
			if (daggerCount == 0)
			{
				text.text = LocalisationController.replaceText("Dagger Targets", "Final Score: [x]", score.ToString());
				GeneralSounds.playSound(2);
				WebLogging.log("Dagger Targets", "Finish", score);
				if (score >= 100)
				{
					AchievementsController.achievement("Target Practice");
				}
				if (score > best)
				{
					TextMeshProUGUI textMeshProUGUI = text;
					textMeshProUGUI.text = textMeshProUGUI.text + "\n" + LocalisationController.getText("Dagger Targets", "New Best!");
					Saving.instance.maxStat("Dagger Targets Score", score, onlyInFight: false, isInt: true);
				}
				else if (best > 0)
				{
					TextMeshProUGUI textMeshProUGUI2 = text;
					textMeshProUGUI2.text = textMeshProUGUI2.text + "\n" + LocalisationController.replaceText("Dagger Targets", "Best: [x]", best.ToString());
				}
				over = true;
				restartTimer = 8f;
			}
			else
			{
				text.text = LocalisationController.replaceText("Dagger Targets", "Score: [x]", score.ToString()) + "\n" + LocalisationController.replaceText("Dagger Targets", "[x] daggers left", daggerCount.ToString());
			}
		}
	}
}
public class DamageWithinCone : MonoBehaviour
{
	public SpecialMoveController specialMoveController;

	public float angle = 55f;

	public MinMax range;

	private void Start()
	{
		specialMoveController = GetComponentInParent<SpecialMoveController>();
		GameCharacter character = specialMoveController.character;
		foreach (GameCharacter player in GameController.instance.players)
		{
			if (player.team == character.team)
			{
				continue;
			}
			Vector3 vector = player.standPosition - base.transform.position;
			if (!(vector.magnitude < range.max))
			{
				continue;
			}
			float num = 360f;
			Hittable hittable = null;
			BodyPartData[] bodyParts = player.rigidBodies.bodyParts;
			foreach (BodyPartData bodyPartData in bodyParts)
			{
				if (bodyPartData.knockDownPerc > 0.1f)
				{
					float num2 = Quaternion.Angle(Quaternion.LookRotation(base.transform.forward), Quaternion.LookRotation(bodyPartData.hittable.transform.position - base.transform.position));
					if (num2 < num)
					{
						num = num2;
						hittable = bodyPartData.hittable;
					}
				}
			}
			if (hittable != null)
			{
				float num3 = 1f - (vector.magnitude - range.min) / (range.max - range.min);
				player.rigidBodies.Hit(base.transform.forward, hittable, player, num3 * character.specialMove.slideMod, num3 * character.specialMove.damageMod, hittable.transform.position, Hittable.HandHitType.General, skipPressurePoints: true, "Blast");
				player.addEffect(hittable.transform.position, specialMoveController.character.specialMove, preventSpecialCharge: false, isTest: false);
			}
		}
	}

	private void Update()
	{
	}
}
public class DebugLine : MonoBehaviour
{
	public LineRenderer line;

	public Material lineMaterial;

	public Color toColour;

	private void Start()
	{
		toColour = Color.white;
	}

	public void SetColor(Color toColour)
	{
		this.toColour = toColour;
	}

	public void LineTo(Vector3 to)
	{
		LineTo(base.transform.position, to);
	}

	public void LineTo(Vector3 from, Vector3 to)
	{
		if (!base.enabled)
		{
			if (line != null)
			{
				UnityEngine.Object.Destroy(line);
			}
			return;
		}
		if (line == null)
		{
			line = base.gameObject.AddComponent<LineRenderer>();
			line.positionCount = 2;
			LineRenderer lineRenderer = line;
			float startWidth = (line.endWidth = 0.03f);
			lineRenderer.startWidth = startWidth;
			line.startColor = Color.black;
			line.material = lineMaterial;
		}
		line.endColor = toColour;
		line.SetPosition(0, from);
		line.SetPosition(1, to);
	}
}
[Serializable]
public class DifficultyLevel : Exportable
{
	public enum Level
	{
		None,
		Easy,
		Medium,
		Hard,
		Harder,
		Master
	}

	public int id;

	public Level level;

	public bool enemyHealthBar;

	public bool yourHealthBar;

	public bool yourQiBar;

	public float unlockRequirementMod = 1f;

	public MinMax minDistance = new MinMax(0.5f, 0.5f);

	public MinMax aiThinkTime;

	public MinMax aiSpeed;

	public MinMax aiTurnSpeed;

	public MinMax aiWalkSpeed;

	public MinMax aiChangeDirSpeed;

	public MinMax aiCaution;

	public MinMax aiSpecialMoveSpeed;

	public MinMax aiMoveChoiceVariance;

	public MinMax aiDodgeLikelihood;

	public MinMax aiDashFrequency;

	public MinMax enemyMuscleWeight;

	public MinMax massMultiplyBySpeed;

	public MinMax handOffsetPauseTime;

	public MinMax handOffsetRecoveryTime;

	public float slowMoDuration = 1f;

	public MinMax damageAutobalance;

	public void localise()
	{
		LocalisationController.getText("Difficulty Level", name);
	}

	public string moreDifficultThan(DifficultyLevel other)
	{
		string text = "";
		if (aiThinkTime.MoreDifficultThan(other.aiThinkTime, smallerIsHarder: true))
		{
			text += " aiThinkTime";
		}
		if (aiSpeed.MoreDifficultThan(other.aiSpeed, smallerIsHarder: false))
		{
			text += " aiSpeed";
		}
		if (aiTurnSpeed.MoreDifficultThan(other.aiTurnSpeed, smallerIsHarder: false))
		{
			text = text + " aiTurnSpeed " + aiTurnSpeed.ToString() + ">" + other.aiTurnSpeed.ToString();
		}
		if (aiChangeDirSpeed.MoreDifficultThan(other.aiChangeDirSpeed, smallerIsHarder: false))
		{
			text += " aiChangeDirSpeed";
		}
		if (aiCaution.MoreDifficultThan(other.aiCaution, smallerIsHarder: false))
		{
			text += " aiCaution";
		}
		if (aiSpecialMoveSpeed.MoreDifficultThan(other.aiSpecialMoveSpeed, smallerIsHarder: true))
		{
			text += " aiSpecialMoveSpeed";
		}
		if (aiMoveChoiceVariance.MoreDifficultThan(other.aiMoveChoiceVariance, smallerIsHarder: true))
		{
			text += " aiMoveChoiceVariance";
		}
		if (aiDodgeLikelihood.MoreDifficultThan(other.aiDodgeLikelihood, smallerIsHarder: false))
		{
			text += " aiDodgeLikelihood";
		}
		if (enemyMuscleWeight.MoreDifficultThan(other.enemyMuscleWeight, smallerIsHarder: false))
		{
			text += " enemyMuscleWeight";
		}
		if (massMultiplyBySpeed.MoreDifficultThan(other.massMultiplyBySpeed, smallerIsHarder: false))
		{
			text += " massMultiplyBySpeed";
		}
		if (handOffsetPauseTime.MoreDifficultThan(other.handOffsetPauseTime, smallerIsHarder: true))
		{
			text += " handOffsetPauseTime";
		}
		if (handOffsetRecoveryTime.MoreDifficultThan(other.handOffsetRecoveryTime, smallerIsHarder: true))
		{
			text += " handOffsetRecoveryTime";
		}
		if (damageAutobalance.MoreDifficultThan(other.damageAutobalance, smallerIsHarder: false))
		{
			text += " damageAutobalance";
		}
		return text;
	}

	public bool isMaster()
	{
		return name == "Master";
	}
}
public class DifficultyPickerController : StandButtonsController
{
	public Breakable[] breakBoards;

	private bool setup;

	private int doneChoice = -1;

	private void Start()
	{
		int num = 0;
		Breakable[] array = breakBoards;
		foreach (Breakable b in array)
		{
			b.onSmash = delegate
			{
				choose(b);
			};
			num++;
		}
		breakBoards[breakBoards.Length - 1].breakLimitation = ((GameData.instance.stars > 0) ? Breakable.BreakLimitation.NewGameOnly : Breakable.BreakLimitation.SpecialMove);
	}

	private void choose(Breakable b)
	{
		if (doneChoice <= -1)
		{
			doneChoice = Array.IndexOf(breakBoards, b);
			GameController.instance.difficultyLevel = Settings.instance.difficultyLevels[doneChoice];
			WebLogging.log("Choose Difficulty", GameController.instance.difficultyLevel.name, 0f);
			GameController.instance.gameData.chooseDifficulty = false;
			Invoke("gotoNext", 1f);
		}
	}

	private void gotoNext()
	{
		GameController.instance.scenes.pickLevel();
	}

	private void Update()
	{
		if (GameController.instance.player == null && GameController.instance.gameMode != 0 && !setup)
		{
			setup = true;
			if (spawnPoints.Length == 0)
			{
				spawnPoints = GetComponentsInChildren<SpawnPointController>();
			}
			GameController.instance.standButtons = this;
			if (editCam != null)
			{
				editCam.gameObject.SetActive(value: false);
			}
		}
		noticeBoard.SetActive(OptionData.getOption("Noticeboard").value == 0);
	}
}
public class DontDestroy : MonoBehaviour
{
	private void Awake()
	{
		UnityEngine.Object.DontDestroyOnLoad(this);
	}
}
[Serializable]
public class DummyHitType
{
	public string name;

	public Hittable.HandHitType handHitType;

	public TextMeshProUGUI label;

	public bool done;

	public bool complete()
	{
		if (done)
		{
			return false;
		}
		done = true;
		label.color = Color.white;
		return true;
	}

	public void setup()
	{
		label.text = LocalisationController.getText("Chamber", name);
		label.color = Color.red;
	}
}
public class DynamicBoneDemo1 : MonoBehaviour
{
	public GameObject m_Player;

	private float m_weight = 1f;

	private float m_sleepTime;

	private void Update()
	{
		m_Player.transform.Rotate(new Vector3(0f, Input.GetAxis("Horizontal") * Time.deltaTime * 200f, 0f));
		m_Player.transform.Translate(base.transform.forward * Input.GetAxis("Vertical") * Time.deltaTime * 4f);
	}

	private void OnGUI()
	{
		float num = 50f;
		float num2 = 50f;
		float width = 100f;
		float width2 = 200f;
		float num3 = 24f;
		GUI.Label(new Rect(num, num2, width2, num3), "Press arrow key to move");
		Animation componentInChildren = m_Player.GetComponentInChildren<Animation>();
		num2 += num3;
		componentInChildren.enabled = GUI.Toggle(new Rect(num, num2, width2, num3), componentInChildren.enabled, "Play Animation");
		num2 += num3 * 2f;
		DynamicBone[] components = m_Player.GetComponents<DynamicBone>();
		GUI.Label(new Rect(num, num2, width2, num3), "Choose dynamic bone:");
		num2 += num3;
		DynamicBone obj = components[0];
		bool flag2 = (components[1].enabled = GUI.Toggle(new Rect(num, num2, width, num3), components[0].enabled, "Breasts"));
		obj.enabled = flag2;
		num2 += num3;
		components[2].enabled = GUI.Toggle(new Rect(num, num2, width, num3), components[2].enabled, "Tail");
		num2 += num3;
		GUI.Label(new Rect(num, num2, width2, num3), "Weight");
		m_weight = GUI.HorizontalSlider(new Rect(num + 50f, num2, width, num3), m_weight, 0f, 1f);
		DynamicBone[] array = components;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetWeight(m_weight);
		}
	}
}
[AddComponentMenu("Dynamic Bone/Dynamic Bone")]
public class DynamicBone : MonoBehaviour
{
	public enum UpdateMode
	{
		Normal,
		AnimatePhysics,
		UnscaledTime,
		Default
	}

	public enum FreezeAxis
	{
		None,
		X,
		Y,
		Z
	}

	private class Particle
	{
		public Transform m_Transform;

		public int m_ParentIndex = -1;

		public float m_Damping;

		public float m_Elasticity;

		public float m_Stiffness;

		public float m_Inert;

		public float m_Friction;

		public float m_Radius;

		public float m_BoneLength;

		public bool m_isCollide;

		public Vector3 m_Position = Vector3.zero;

		public Vector3 m_PrevPosition = Vector3.zero;

		public Vector3 m_EndOffset = Vector3.zero;

		public Vector3 m_InitLocalPosition = Vector3.zero;

		public Quaternion m_InitLocalRotation = Quaternion.identity;
	}

	[Tooltip("The root of the transform hierarchy to apply physics.")]
	public Transform m_Root;

	[Tooltip("Internal physics simulation rate.")]
	public float m_UpdateRate = 60f;

	public UpdateMode m_UpdateMode = UpdateMode.Default;

	[Tooltip("How much the bones slowed down.")]
	[Range(0f, 1f)]
	public float m_Damping = 0.1f;

	public AnimationCurve m_DampingDistrib;

	[Tooltip("How much the force applied to return each bone to original orientation.")]
	[Range(0f, 1f)]
	public float m_Elasticity = 0.1f;

	public AnimationCurve m_ElasticityDistrib;

	[Tooltip("How much bone's original orientation are preserved.")]
	[Range(0f, 1f)]
	public float m_Stiffness = 0.1f;

	public AnimationCurve m_StiffnessDistrib;

	[Tooltip("How much character's position change is ignored in physics simulation.")]
	[Range(0f, 1f)]
	public float m_Inert;

	public AnimationCurve m_InertDistrib;

	[Tooltip("How much the bones slowed down when collide.")]
	public float m_Friction;

	public AnimationCurve m_FrictionDistrib;

	[Tooltip("Each bone can be a sphere to collide with colliders. Radius describe sphere's size.")]
	public float m_Radius;

	public AnimationCurve m_RadiusDistrib;

	[Tooltip("If End Length is not zero, an extra bone is generated at the end of transform hierarchy.")]
	public float m_EndLength;

	[Tooltip("If End Offset is not zero, an extra bone is generated at the end of transform hierarchy.")]
	public Vector3 m_EndOffset = Vector3.zero;

	[Tooltip("The force apply to bones. Partial force apply to character's initial pose is cancelled out.")]
	public Vector3 m_Gravity = Vector3.zero;

	[Tooltip("The force apply to bones.")]
	public Vector3 m_Force = Vector3.zero;

	[Tooltip("Collider objects interact with the bones.")]
	public List<DynamicBoneColliderBase> m_Colliders;

	[Tooltip("Bones exclude from physics simulation.")]
	public List<Transform> m_Exclusions;

	[Tooltip("Constrain bones to move on specified plane.")]
	public FreezeAxis m_FreezeAxis;

	[Tooltip("Disable physics simulation automatically if character is far from camera or player.")]
	public bool m_DistantDisable;

	public Transform m_ReferenceObject;

	public float m_DistanceToObject = 20f;

	private Vector3 m_LocalGravity = Vector3.zero;

	private Vector3 m_ObjectMove = Vector3.zero;

	private Vector3 m_ObjectPrevPosition = Vector3.zero;

	private float m_BoneTotalLength;

	private float m_ObjectScale = 1f;

	private float m_Time;

	private float m_Weight = 1f;

	private bool m_DistantDisabled;

	private List<Particle> m_Particles = new List<Particle>();

	private void Start()
	{
		SetupParticles();
	}

	private void FixedUpdate()
	{
		if (m_UpdateMode == UpdateMode.AnimatePhysics)
		{
			PreUpdate();
		}
	}

	private void Update()
	{
		if (m_UpdateMode != UpdateMode.AnimatePhysics)
		{
			PreUpdate();
		}
	}

	private void LateUpdate()
	{
		if (m_DistantDisable)
		{
			CheckDistance();
		}
		if (m_Weight > 0f && (!m_DistantDisable || !m_DistantDisabled))
		{
			float t = ((m_UpdateMode == UpdateMode.UnscaledTime) ? Time.unscaledDeltaTime : Time.deltaTime);
			UpdateDynamicBones(t);
		}
	}

	private void PreUpdate()
	{
		if (m_Weight > 0f && (!m_DistantDisable || !m_DistantDisabled))
		{
			InitTransforms();
		}
	}

	private void CheckDistance()
	{
		Transform referenceObject = m_ReferenceObject;
		if (referenceObject == null && Camera.main != null)
		{
			referenceObject = Camera.main.transform;
		}
		if (!(referenceObject != null))
		{
			return;
		}
		bool flag = (referenceObject.position - base.transform.position).sqrMagnitude > m_DistanceToObject * m_DistanceToObject;
		if (flag != m_DistantDisabled)
		{
			if (!flag)
			{
				ResetParticlesPosition();
			}
			m_DistantDisabled = flag;
		}
	}

	private void OnEnable()
	{
		ResetParticlesPosition();
	}

	private void OnDisable()
	{
		InitTransforms();
	}

	private void OnValidate()
	{
		m_UpdateRate = Mathf.Max(m_UpdateRate, 0f);
		m_Damping = Mathf.Clamp01(m_Damping);
		m_Elasticity = Mathf.Clamp01(m_Elasticity);
		m_Stiffness = Mathf.Clamp01(m_Stiffness);
		m_Inert = Mathf.Clamp01(m_Inert);
		m_Friction = Mathf.Clamp01(m_Friction);
		m_Radius = Mathf.Max(m_Radius, 0f);
		if (Application.isEditor && Application.isPlaying)
		{
			InitTransforms();
			SetupParticles();
		}
	}

	private void OnDrawGizmosSelected()
	{
		if (!base.enabled || m_Root == null)
		{
			return;
		}
		if (Application.isEditor && !Application.isPlaying && base.transform.hasChanged)
		{
			InitTransforms();
			SetupParticles();
		}
		Gizmos.color = Color.white;
		for (int i = 0; i < m_Particles.Count; i++)
		{
			Particle particle = m_Particles[i];
			if (particle.m_ParentIndex >= 0)
			{
				Particle particle2 = m_Particles[particle.m_ParentIndex];
				Gizmos.DrawLine(particle.m_Position, particle2.m_Position);
			}
			if (particle.m_Radius > 0f)
			{
				Gizmos.DrawWireSphere(particle.m_Position, particle.m_Radius * m_ObjectScale);
			}
		}
	}

	public void SetWeight(float w)
	{
		if (m_Weight != w)
		{
			if (w == 0f)
			{
				InitTransforms();
			}
			else if (m_Weight == 0f)
			{
				ResetParticlesPosition();
			}
			m_Weight = w;
		}
	}

	public float GetWeight()
	{
		return m_Weight;
	}

	private void UpdateDynamicBones(float t)
	{
		if (m_Root == null)
		{
			return;
		}
		m_ObjectScale = Mathf.Abs(base.transform.lossyScale.x);
		m_ObjectMove = base.transform.position - m_ObjectPrevPosition;
		m_ObjectPrevPosition = base.transform.position;
		int num = 1;
		float timeVar = 1f;
		if (m_UpdateMode == UpdateMode.Default)
		{
			timeVar = ((!(m_UpdateRate > 0f)) ? Time.deltaTime : (Time.deltaTime * m_UpdateRate));
		}
		else if (m_UpdateRate > 0f)
		{
			float num2 = 1f / m_UpdateRate;
			m_Time += t;
			num = 0;
			while (m_Time >= num2)
			{
				m_Time -= num2;
				if (++num >= 3)
				{
					m_Time = 0f;
					break;
				}
			}
		}
		if (num > 0)
		{
			for (int i = 0; i < num; i++)
			{
				UpdateParticles1(timeVar);
				UpdateParticles2(timeVar);
				m_ObjectMove = Vector3.zero;
			}
		}
		else
		{
			SkipUpdateParticles();
		}
		ApplyParticlesToTransforms();
	}

	public void SetupParticles()
	{
		m_Particles.Clear();
		if (!(m_Root == null))
		{
			m_LocalGravity = m_Root.InverseTransformDirection(m_Gravity);
			m_ObjectScale = Mathf.Abs(base.transform.lossyScale.x);
			m_ObjectPrevPosition = base.transform.position;
			m_ObjectMove = Vector3.zero;
			m_BoneTotalLength = 0f;
			AppendParticles(m_Root, -1, 0f);
			UpdateParameters();
		}
	}

	private void AppendParticles(Transform b, int parentIndex, float boneLength)
	{
		Particle particle = new Particle();
		particle.m_Transform = b;
		particle.m_ParentIndex = parentIndex;
		if (b != null)
		{
			particle.m_Position = (particle.m_PrevPosition = b.position);
			particle.m_InitLocalPosition = b.localPosition;
			particle.m_InitLocalRotation = b.localRotation;
		}
		else
		{
			Transform transform = m_Particles[parentIndex].m_Transform;
			if (m_EndLength > 0f)
			{
				Transform parent = transform.parent;
				if (parent != null)
				{
					particle.m_EndOffset = transform.InverseTransformPoint(transform.position * 2f - parent.position) * m_EndLength;
				}
				else
				{
					particle.m_EndOffset = new Vector3(m_EndLength, 0f, 0f);
				}
			}
			else
			{
				particle.m_EndOffset = transform.InverseTransformPoint(base.transform.TransformDirection(m_EndOffset) + transform.position);
			}
			particle.m_Position = (particle.m_PrevPosition = transform.TransformPoint(particle.m_EndOffset));
		}
		if (parentIndex >= 0)
		{
			boneLength += (m_Particles[parentIndex].m_Transform.position - particle.m_Position).magnitude;
			particle.m_BoneLength = boneLength;
			m_BoneTotalLength = Mathf.Max(m_BoneTotalLength, boneLength);
		}
		int count = m_Particles.Count;
		m_Particles.Add(particle);
		if (!(b != null))
		{
			return;
		}
		for (int i = 0; i < b.childCount; i++)
		{
			Transform child = b.GetChild(i);
			bool flag = false;
			if (m_Exclusions != null)
			{
				flag = m_Exclusions.Contains(child);
			}
			if (!flag)
			{
				AppendParticles(child, count, boneLength);
			}
			else if (m_EndLength > 0f || m_EndOffset != Vector3.zero)
			{
				AppendParticles(null, count, boneLength);
			}
		}
		if (b.childCount == 0 && (m_EndLength > 0f || m_EndOffset != Vector3.zero))
		{
			AppendParticles(null, count, boneLength);
		}
	}

	public void UpdateParameters()
	{
		if (m_Root == null)
		{
			return;
		}
		m_LocalGravity = m_Root.InverseTransformDirection(m_Gravity);
		for (int i = 0; i < m_Particles.Count; i++)
		{
			Particle particle = m_Particles[i];
			particle.m_Damping = m_Damping;
			particle.m_Elasticity = m_Elasticity;
			particle.m_Stiffness = m_Stiffness;
			particle.m_Inert = m_Inert;
			particle.m_Friction = m_Friction;
			particle.m_Radius = m_Radius;
			if (m_BoneTotalLength > 0f)
			{
				float time = particle.m_BoneLength / m_BoneTotalLength;
				if (m_DampingDistrib != null && m_DampingDistrib.keys.Length != 0)
				{
					particle.m_Damping *= m_DampingDistrib.Evaluate(time);
				}
				if (m_ElasticityDistrib != null && m_ElasticityDistrib.keys.Length != 0)
				{
					particle.m_Elasticity *= m_ElasticityDistrib.Evaluate(time);
				}
				if (m_StiffnessDistrib != null && m_StiffnessDistrib.keys.Length != 0)
				{
					particle.m_Stiffness *= m_StiffnessDistrib.Evaluate(time);
				}
				if (m_InertDistrib != null && m_InertDistrib.keys.Length != 0)
				{
					particle.m_Inert *= m_InertDistrib.Evaluate(time);
				}
				if (m_FrictionDistrib != null && m_FrictionDistrib.keys.Length != 0)
				{
					particle.m_Friction *= m_FrictionDistrib.Evaluate(time);
				}
				if (m_RadiusDistrib != null && m_RadiusDistrib.keys.Length != 0)
				{
					particle.m_Radius *= m_RadiusDistrib.Evaluate(time);
				}
			}
			particle.m_Damping = Mathf.Clamp01(particle.m_Damping);
			particle.m_Elasticity = Mathf.Clamp01(particle.m_Elasticity);
			particle.m_Stiffness = Mathf.Clamp01(particle.m_Stiffness);
			particle.m_Inert = Mathf.Clamp01(particle.m_Inert);
			particle.m_Friction = Mathf.Clamp01(particle.m_Friction);
			particle.m_Radius = Mathf.Max(particle.m_Radius, 0f);
		}
	}

	private void InitTransforms()
	{
		for (int i = 0; i < m_Particles.Count; i++)
		{
			Particle particle = m_Particles[i];
			if (particle.m_Transform != null)
			{
				particle.m_Transform.localPosition = particle.m_InitLocalPosition;
				particle.m_Transform.localRotation = particle.m_InitLocalRotation;
			}
		}
	}

	private void ResetParticlesPosition()
	{
		for (int i = 0; i < m_Particles.Count; i++)
		{
			Particle particle = m_Particles[i];
			if (particle.m_Transform != null)
			{
				particle.m_Position = (particle.m_PrevPosition = particle.m_Transform.position);
			}
			else
			{
				Transform transform = m_Particles[particle.m_ParentIndex].m_Transform;
				particle.m_Position = (particle.m_PrevPosition = transform.TransformPoint(particle.m_EndOffset));
			}
			particle.m_isCollide = false;
		}
		m_ObjectPrevPosition = base.transform.position;
	}

	private void UpdateParticles1(float timeVar)
	{
		Vector3 gravity = m_Gravity;
		Vector3 normalized = m_Gravity.normalized;
		Vector3 lhs = m_Root.TransformDirection(m_LocalGravity);
		Vector3 vector = normalized * Mathf.Max(Vector3.Dot(lhs, normalized), 0f);
		gravity -= vector;
		gravity = (gravity + m_Force) * (m_ObjectScale * timeVar);
		for (int i = 0; i < m_Particles.Count; i++)
		{
			Particle particle = m_Particles[i];
			if (particle.m_ParentIndex >= 0)
			{
				Vector3 vector2 = particle.m_Position - particle.m_PrevPosition;
				Vector3 vector3 = m_ObjectMove * particle.m_Inert;
				particle.m_PrevPosition = particle.m_Position + vector3;
				float num = particle.m_Damping;
				if (particle.m_isCollide)
				{
					num += particle.m_Friction;
					if (num > 1f)
					{
						num = 1f;
					}
					particle.m_isCollide = false;
				}
				particle.m_Position += vector2 * (1f - num) + gravity + vector3;
			}
			else
			{
				particle.m_PrevPosition = particle.m_Position;
				particle.m_Position = particle.m_Transform.position;
			}
		}
	}

	private void UpdateParticles2(float timeVar)
	{
		Plane plane = default(Plane);
		for (int i = 1; i < m_Particles.Count; i++)
		{
			Particle particle = m_Particles[i];
			Particle particle2 = m_Particles[particle.m_ParentIndex];
			float num = ((!(particle.m_Transform != null)) ? particle2.m_Transform.localToWorldMatrix.MultiplyVector(particle.m_EndOffset).magnitude : (particle2.m_Transform.position - particle.m_Transform.position).magnitude);
			float num2 = Mathf.Lerp(1f, particle.m_Stiffness, m_Weight);
			if (num2 > 0f || particle.m_Elasticity > 0f)
			{
				Matrix4x4 localToWorldMatrix = particle2.m_Transform.localToWorldMatrix;
				localToWorldMatrix.SetColumn(3, particle2.m_Position);
				Vector3 vector = ((!(particle.m_Transform != null)) ? localToWorldMatrix.MultiplyPoint3x4(particle.m_EndOffset) : localToWorldMatrix.MultiplyPoint3x4(particle.m_Transform.localPosition));
				Vector3 vector2 = vector - particle.m_Position;
				particle.m_Position += vector2 * (particle.m_Elasticity * timeVar);
				if (num2 > 0f)
				{
					vector2 = vector - particle.m_Position;
					float magnitude = vector2.magnitude;
					float num3 = num * (1f - num2) * 2f;
					if (magnitude > num3)
					{
						particle.m_Position += vector2 * ((magnitude - num3) / magnitude);
					}
				}
			}
			if (m_Colliders != null)
			{
				float particleRadius = particle.m_Radius * m_ObjectScale;
				for (int j = 0; j < m_Colliders.Count; j++)
				{
					DynamicBoneColliderBase dynamicBoneColliderBase = m_Colliders[j];
					if (dynamicBoneColliderBase != null && dynamicBoneColliderBase.enabled)
					{
						particle.m_isCollide |= dynamicBoneColliderBase.Collide(ref particle.m_Position, particleRadius);
					}
				}
			}
			if (m_FreezeAxis != 0)
			{
				switch (m_FreezeAxis)
				{
				case FreezeAxis.X:
					plane.SetNormalAndPosition(particle2.m_Transform.right, particle2.m_Position);
					break;
				case FreezeAxis.Y:
					plane.SetNormalAndPosition(particle2.m_Transform.up, particle2.m_Position);
					break;
				case FreezeAxis.Z:
					plane.SetNormalAndPosition(particle2.m_Transform.forward, particle2.m_Position);
					break;
				}
				particle.m_Position -= plane.normal * plane.GetDistanceToPoint(particle.m_Position);
			}
			Vector3 vector3 = particle2.m_Position - particle.m_Position;
			float magnitude2 = vector3.magnitude;
			if (magnitude2 > 0f)
			{
				particle.m_Position += vector3 * ((magnitude2 - num) / magnitude2);
			}
		}
	}

	private void SkipUpdateParticles()
	{
		for (int i = 0; i < m_Particles.Count; i++)
		{
			Particle particle = m_Particles[i];
			if (particle.m_ParentIndex >= 0)
			{
				particle.m_PrevPosition += m_ObjectMove;
				particle.m_Position += m_ObjectMove;
				Particle particle2 = m_Particles[particle.m_ParentIndex];
				float num = ((!(particle.m_Transform != null)) ? particle2.m_Transform.localToWorldMatrix.MultiplyVector(particle.m_EndOffset).magnitude : (particle2.m_Transform.position - particle.m_Transform.position).magnitude);
				float num2 = Mathf.Lerp(1f, particle.m_Stiffness, m_Weight);
				if (num2 > 0f)
				{
					Matrix4x4 localToWorldMatrix = particle2.m_Transform.localToWorldMatrix;
					localToWorldMatrix.SetColumn(3, particle2.m_Position);
					Vector3 vector = ((!(particle.m_Transform != null)) ? localToWorldMatrix.MultiplyPoint3x4(particle.m_EndOffset) : localToWorldMatrix.MultiplyPoint3x4(particle.m_Transform.localPosition));
					Vector3 vector2 = vector - particle.m_Position;
					float magnitude = vector2.magnitude;
					float num3 = num * (1f - num2) * 2f;
					if (magnitude > num3)
					{
						particle.m_Position += vector2 * ((magnitude - num3) / magnitude);
					}
				}
				Vector3 vector3 = particle2.m_Position - particle.m_Position;
				float magnitude2 = vector3.magnitude;
				if (magnitude2 > 0f)
				{
					particle.m_Position += vector3 * ((magnitude2 - num) / magnitude2);
				}
			}
			else
			{
				particle.m_PrevPosition = particle.m_Position;
				particle.m_Position = particle.m_Transform.position;
			}
		}
	}

	private static Vector3 MirrorVector(Vector3 v, Vector3 axis)
	{
		return v - axis * (Vector3.Dot(v, axis) * 2f);
	}

	private void ApplyParticlesToTransforms()
	{
		for (int i = 1; i < m_Particles.Count; i++)
		{
			Particle particle = m_Particles[i];
			Particle particle2 = m_Particles[particle.m_ParentIndex];
			if (particle2.m_Transform.childCount <= 1)
			{
				Vector3 direction = ((!(particle.m_Transform != null)) ? particle.m_EndOffset : particle.m_Transform.localPosition);
				Vector3 toDirection = particle.m_Position - particle2.m_Position;
				Quaternion quaternion = Quaternion.FromToRotation(particle2.m_Transform.TransformDirection(direction), toDirection);
				particle2.m_Transform.rotation = quaternion * particle2.m_Transform.rotation;
			}
			if (particle.m_Transform != null)
			{
				particle.m_Transform.position = particle.m_Position;
			}
		}
	}
}
[AddComponentMenu("Dynamic Bone/Dynamic Bone Collider")]
public class DynamicBoneCollider : DynamicBoneColliderBase
{
	[Tooltip("The radius of the sphere or capsule.")]
	public float m_Radius = 0.5f;

	[Tooltip("The height of the capsule.")]
	public float m_Height;

	private void OnValidate()
	{
		m_Radius = Mathf.Max(m_Radius, 0f);
		m_Height = Mathf.Max(m_Height, 0f);
	}

	public override bool Collide(ref Vector3 particlePosition, float particleRadius)
	{
		float num = m_Radius * Mathf.Abs(base.transform.lossyScale.x);
		float num2 = m_Height * 0.5f - m_Radius;
		if (num2 <= 0f)
		{
			if (m_Bound == Bound.Outside)
			{
				return OutsideSphere(ref particlePosition, particleRadius, base.transform.TransformPoint(m_Center), num);
			}
			return InsideSphere(ref particlePosition, particleRadius, base.transform.TransformPoint(m_Center), num);
		}
		Vector3 center = m_Center;
		Vector3 center2 = m_Center;
		switch (m_Direction)
		{
		case Direction.X:
			center.x -= num2;
			center2.x += num2;
			break;
		case Direction.Y:
			center.y -= num2;
			center2.y += num2;
			break;
		case Direction.Z:
			center.z -= num2;
			center2.z += num2;
			break;
		}
		if (m_Bound == Bound.Outside)
		{
			return OutsideCapsule(ref particlePosition, particleRadius, base.transform.TransformPoint(center), base.transform.TransformPoint(center2), num);
		}
		return InsideCapsule(ref particlePosition, particleRadius, base.transform.TransformPoint(center), base.transform.TransformPoint(center2), num);
	}

	private static bool OutsideSphere(ref Vector3 particlePosition, float particleRadius, Vector3 sphereCenter, float sphereRadius)
	{
		float num = sphereRadius + particleRadius;
		float num2 = num * num;
		Vector3 vector = particlePosition - sphereCenter;
		float sqrMagnitude = vector.sqrMagnitude;
		if (sqrMagnitude > 0f && sqrMagnitude < num2)
		{
			float num3 = Mathf.Sqrt(sqrMagnitude);
			particlePosition = sphereCenter + vector * (num / num3);
			return true;
		}
		return false;
	}

	private static bool InsideSphere(ref Vector3 particlePosition, float particleRadius, Vector3 sphereCenter, float sphereRadius)
	{
		float num = sphereRadius - particleRadius;
		float num2 = num * num;
		Vector3 vector = particlePosition - sphereCenter;
		float sqrMagnitude = vector.sqrMagnitude;
		if (sqrMagnitude > num2)
		{
			float num3 = Mathf.Sqrt(sqrMagnitude);
			particlePosition = sphereCenter + vector * (num / num3);
			return true;
		}
		return false;
	}

	private static bool OutsideCapsule(ref Vector3 particlePosition, float particleRadius, Vector3 capsuleP0, Vector3 capsuleP1, float capsuleRadius)
	{
		float num = capsuleRadius + particleRadius;
		float num2 = num * num;
		Vector3 vector = capsuleP1 - capsuleP0;
		Vector3 vector2 = particlePosition - capsuleP0;
		float num3 = Vector3.Dot(vector2, vector);
		if (num3 <= 0f)
		{
			float sqrMagnitude = vector2.sqrMagnitude;
			if (sqrMagnitude > 0f && sqrMagnitude < num2)
			{
				float num4 = Mathf.Sqrt(sqrMagnitude);
				particlePosition = capsuleP0 + vector2 * (num / num4);
				return true;
			}
		}
		else
		{
			float sqrMagnitude2 = vector.sqrMagnitude;
			if (num3 >= sqrMagnitude2)
			{
				vector2 = particlePosition - capsuleP1;
				float sqrMagnitude3 = vector2.sqrMagnitude;
				if (sqrMagnitude3 > 0f && sqrMagnitude3 < num2)
				{
					float num5 = Mathf.Sqrt(sqrMagnitude3);
					particlePosition = capsuleP1 + vector2 * (num / num5);
					return true;
				}
			}
			else if (sqrMagnitude2 > 0f)
			{
				num3 /= sqrMagnitude2;
				vector2 -= vector * num3;
				float sqrMagnitude4 = vector2.sqrMagnitude;
				if (sqrMagnitude4 > 0f && sqrMagnitude4 < num2)
				{
					float num6 = Mathf.Sqrt(sqrMagnitude4);
					particlePosition += vector2 * ((num - num6) / num6);
					return true;
				}
			}
		}
		return false;
	}

	private static bool InsideCapsule(ref Vector3 particlePosition, float particleRadius, Vector3 capsuleP0, Vector3 capsuleP1, float capsuleRadius)
	{
		float num = capsuleRadius - particleRadius;
		float num2 = num * num;
		Vector3 vector = capsuleP1 - capsuleP0;
		Vector3 vector2 = particlePosition - capsuleP0;
		float num3 = Vector3.Dot(vector2, vector);
		if (num3 <= 0f)
		{
			float sqrMagnitude = vector2.sqrMagnitude;
			if (sqrMagnitude > num2)
			{
				float num4 = Mathf.Sqrt(sqrMagnitude);
				particlePosition = capsuleP0 + vector2 * (num / num4);
				return true;
			}
		}
		else
		{
			float sqrMagnitude2 = vector.sqrMagnitude;
			if (num3 >= sqrMagnitude2)
			{
				vector2 = particlePosition - capsuleP1;
				float sqrMagnitude3 = vector2.sqrMagnitude;
				if (sqrMagnitude3 > num2)
				{
					float num5 = Mathf.Sqrt(sqrMagnitude3);
					particlePosition = capsuleP1 + vector2 * (num / num5);
					return true;
				}
			}
			else if (sqrMagnitude2 > 0f)
			{
				num3 /= sqrMagnitude2;
				vector2 -= vector * num3;
				float sqrMagnitude4 = vector2.sqrMagnitude;
				if (sqrMagnitude4 > num2)
				{
					float num6 = Mathf.Sqrt(sqrMagnitude4);
					particlePosition += vector2 * ((num - num6) / num6);
					return true;
				}
			}
		}
		return false;
	}

	private void OnDrawGizmosSelected()
	{
		if (!base.enabled)
		{
			return;
		}
		if (m_Bound == Bound.Outside)
		{
			Gizmos.color = Color.yellow;
		}
		else
		{
			Gizmos.color = Color.magenta;
		}
		float radius = m_Radius * Mathf.Abs(base.transform.lossyScale.x);
		float num = m_Height * 0.5f - m_Radius;
		if (num <= 0f)
		{
			Gizmos.DrawWireSphere(base.transform.TransformPoint(m_Center), radius);
			return;
		}
		Vector3 center = m_Center;
		Vector3 center2 = m_Center;
		switch (m_Direction)
		{
		case Direction.X:
			center.x -= num;
			center2.x += num;
			break;
		case Direction.Y:
			center.y -= num;
			center2.y += num;
			break;
		case Direction.Z:
			center.z -= num;
			center2.z += num;
			break;
		}
		Gizmos.DrawWireSphere(base.transform.TransformPoint(center), radius);
		Gizmos.DrawWireSphere(base.transform.TransformPoint(center2), radius);
	}
}
public class DynamicBoneColliderBase : MonoBehaviour
{
	public enum Direction
	{
		X,
		Y,
		Z
	}

	public enum Bound
	{
		Outside,
		Inside
	}

	[Tooltip("The axis of the capsule's height.")]
	public Direction m_Direction = Direction.Y;

	[Tooltip("The center of the sphere or capsule, in the object's local space.")]
	public Vector3 m_Center = Vector3.zero;

	[Tooltip("Constrain bones to outside bound or inside bound.")]
	public Bound m_Bound;

	public virtual bool Collide(ref Vector3 particlePosition, float particleRadius)
	{
		return false;
	}
}
[AddComponentMenu("Dynamic Bone/Dynamic Bone Plane Collider")]
public class DynamicBonePlaneCollider : DynamicBoneColliderBase
{
	private void OnValidate()
	{
	}

	public override bool Collide(ref Vector3 particlePosition, float particleRadius)
	{
		Vector3 vector = Vector3.up;
		switch (m_Direction)
		{
		case Direction.X:
			vector = base.transform.right;
			break;
		case Direction.Y:
			vector = base.transform.up;
			break;
		case Direction.Z:
			vector = base.transform.forward;
			break;
		}
		Vector3 inPoint = base.transform.TransformPoint(m_Center);
		float distanceToPoint = new Plane(vector, inPoint).GetDistanceToPoint(particlePosition);
		if (m_Bound == Bound.Outside)
		{
			if (distanceToPoint < 0f)
			{
				particlePosition -= vector * distanceToPoint;
				return true;
			}
		}
		else if (distanceToPoint > 0f)
		{
			particlePosition -= vector * distanceToPoint;
			return true;
		}
		return false;
	}

	private void OnDrawGizmosSelected()
	{
		if (base.enabled)
		{
			if (m_Bound == Bound.Outside)
			{
				Gizmos.color = Color.yellow;
			}
			else
			{
				Gizmos.color = Color.magenta;
			}
			Vector3 vector = Vector3.up;
			switch (m_Direction)
			{
			case Direction.X:
				vector = base.transform.right;
				break;
			case Direction.Y:
				vector = base.transform.up;
				break;
			case Direction.Z:
				vector = base.transform.forward;
				break;
			}
			Vector3 vector2 = base.transform.TransformPoint(m_Center);
			Gizmos.DrawLine(vector2, vector2 + vector);
		}
	}
}
public class DynamicTracker : MonoBehaviour
{
	public bool isLeft;

	public MoveWithController playerController;

	public Collider collider;

	public LayerMask layerMask;

	private float lastMag;

	private float speedPerc = 1f;

	private bool stuck;

	private void FixedUpdate()
	{
		if (playerController.activeRig == null)
		{
			return;
		}
		float magnitude = GameController.flatVector(base.transform.position - playerController.activeRig.trackers[0].transform.position).magnitude;
		lastMag = magnitude;
		Transform transform = playerController.activeRig.trackers[isLeft ? 1 : 2];
		Vector3 direction = transform.position - base.transform.position;
		if (true && Physics.Raycast(new Ray(base.transform.position - direction.normalized * 0.05f, direction), out var hitInfo, direction.magnitude * 1.1f, layerMask))
		{
			if (!stuck)
			{
				stuck = true;
				if (hitInfo.collider.isTrigger)
				{
					base.transform.position = transform.position;
				}
				else
				{
					base.transform.position = hitInfo.point;
				}
			}
		}
		else if (stuck)
		{
			stuck = false;
		}
		else if (speedPerc == 1f)
		{
			base.transform.position = transform.position;
			base.transform.rotation = transform.rotation;
		}
		else
		{
			base.transform.position = Vector3.MoveTowards(base.transform.position, transform.position, Time.deltaTime * 100f * speedPerc * speedPerc);
			base.transform.rotation = Quaternion.RotateTowards(base.transform.rotation, transform.rotation, Time.deltaTime * 1000f * speedPerc * speedPerc);
		}
		speedPerc = Mathf.MoveTowards(speedPerc, (!stuck) ? 1 : 0, Time.deltaTime * 5f);
	}
}
public class EffectCircleController : MonoBehaviour
{
	public CharacterEffectData effectData;

	public Image icon;

	[NonSerialized]
	public Vector3 targetPos;

	public void setup(CharacterEffectData effectData)
	{
		this.effectData = effectData;
		if (effectData != null && !(effectData.icon == null))
		{
			icon.sprite = effectData.icon;
		}
	}

	private void Update()
	{
	}
}
public class EffectCirclesController : MonoBehaviour
{
	public enum Type
	{
		Line,
		Radial
	}

	public GameCharacter player;

	public EffectCircleController effectCirclePrefab;

	public List<EffectCircleController> circles;

	public Type type;

	public bool targetEnemy;

	public float maxScale = 1f;

	public float minScale = 1f;

	private void Start()
	{
		foreach (Transform item in base.transform)
		{
			UnityEngine.Object.Destroy(item.gameObject);
		}
	}

	private EffectCircleController getCircle(CharacterEffect.Effect effect)
	{
		CharacterEffectData characterEffect = GameData.instance.getCharacterEffect(effect);
		if (characterEffect == null)
		{
			return null;
		}
		if (characterEffect.icon == null)
		{
			return null;
		}
		foreach (EffectCircleController circle in circles)
		{
			if (circle.effectData.effect == effect)
			{
				return circle;
			}
		}
		EffectCircleController effectCircleController = UnityEngine.Object.Instantiate(effectCirclePrefab, base.transform);
		effectCircleController.setup(characterEffect);
		circles.Add(effectCircleController);
		return effectCircleController;
	}

	private void Update()
	{
		if (player == null || GameController.instance.player == null)
		{
			return;
		}
		if (targetEnemy)
		{
			player = GameController.instance.player.targetEnemy;
			if (GameController.instance.player.targetEnemy != player)
			{
				foreach (EffectCircleController circle2 in circles)
				{
					UnityEngine.Object.Destroy(circle2.gameObject);
				}
				circles.Clear();
			}
		}
		int num = 0;
		foreach (CharacterEffect effect in player.effects)
		{
			EffectCircleController circle = getCircle(effect.effect);
			if (circle != null)
			{
				Vector3 vector = ((type != 0) ? (Quaternion.Euler(0f, 0f, (float)num * -30f) * Vector3.up * 135f) : (Vector3.left * (55f * (float)num + 32f)));
				if (circle.targetPos.magnitude == 0f)
				{
					circle.targetPos = vector;
				}
				else
				{
					circle.targetPos = Vector3.MoveTowards(circle.targetPos, vector, Time.deltaTime * 100f);
				}
				circle.transform.localPosition = circle.targetPos;
				circle.transform.position = Vector3.Lerp(effect.startPos, circle.transform.position, effect.perc);
				circle.transform.localScale = Mathf.Lerp(maxScale, minScale, effect.perc) * Vector3.one;
				num++;
			}
		}
		foreach (EffectCircleController circle3 in circles)
		{
			if (!player.hasEffect(circle3.effectData.effect))
			{
				circle3.transform.localScale = Vector3.MoveTowards(circle3.transform.localScale, Vector3.zero, Time.deltaTime * 2f);
				if (circle3.transform.localScale.magnitude < 0.001f)
				{
					circles.Remove(circle3);
					UnityEngine.Object.Destroy(circle3.gameObject);
					break;
				}
			}
			else
			{
				circle3.transform.LookAt(Camera.main.transform.position);
			}
		}
	}
}
public class ExplosionController : MonoBehaviour
{
	public Light fadeLight;

	public float life;

	private float maxLife;

	private float maxIntensity;

	private void Start()
	{
		maxIntensity = fadeLight.intensity;
		maxLife = life;
	}

	private void Update()
	{
		if (life > 0f)
		{
			life -= Time.deltaTime;
			fadeLight.intensity = life / maxLife * maxIntensity;
		}
		else
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}
}
public class Exportable
{
	public string name;

	public string exportString()
	{
		string text = "";
		_ = new string[4] { "String", "Int32", "Boolean", "MinMax" };
		FieldInfo[] fields = GetType().GetFields();
		foreach (FieldInfo fieldInfo in fields)
		{
			if (fieldInfo.IsPublic && !fieldInfo.IsNotSerialized && fieldInfo.GetValue(this) != null)
			{
				if (text != "")
				{
					text += "|";
				}
				if (fieldInfo.GetValue(this) == null)
				{
					UnityEngine.Debug.LogError("FSdsd  aa: " + fieldInfo.FieldType.Name);
				}
				string inStr = fieldInfo.GetValue(this).ToString();
				text = text + fieldInfo.FieldType.Name + "," + fieldInfo.Name + "," + replaceChars(inStr);
			}
		}
		return text;
	}

	public string replaceChars(string inStr)
	{
		inStr = inStr.Replace(",", "^");
		inStr = inStr.Replace("\n", "<b>");
		return inStr;
	}

	public string replaceCharsBack(string inStr)
	{
		inStr = inStr.Replace("^", ",");
		inStr = inStr.Replace("<b>", "\n");
		return inStr;
	}

	public void importFromString(string importString)
	{
		string[] array = importString.Split('|');
		for (int i = 0; i < array.Length; i++)
		{
			if (!(array[i] != ""))
			{
				continue;
			}
			string[] array2 = array[i].Split(',');
			string text = array2[0];
			string text2 = array2[1];
			string text3 = replaceCharsBack(array2[2]);
			FieldInfo field = GetType().GetField(text2);
			switch (text)
			{
			case "String":
				if ((string)field.GetValue(this) != text3)
				{
					UnityEngine.Debug.LogError(text2 + " changed to: " + text3);
					field.SetValue(this, text3);
				}
				break;
			case "Int32":
				if ((int)field.GetValue(this) != int.Parse(text3))
				{
					UnityEngine.Debug.LogError(text2 + " changed to: " + text3);
					field.SetValue(this, int.Parse(text3));
				}
				break;
			case "Boolean":
				if ((bool)field.GetValue(this) != bool.Parse(text3))
				{
					UnityEngine.Debug.LogError(text2 + " changed to: " + text3);
					field.SetValue(this, bool.Parse(text3));
				}
				break;
			case "Single":
				if ((float)field.GetValue(this) != float.Parse(text3))
				{
					UnityEngine.Debug.LogError(text2 + " changed to: " + text3);
					field.SetValue(this, float.Parse(text3));
				}
				break;
			case "MinMax":
			{
				MinMax minMax = field.GetValue(this) as MinMax;
				if (minMax.FromString(text3))
				{
					UnityEngine.Debug.LogError(text2 + " changed to: " + minMax.ToString());
				}
				break;
			}
			case "Vector3":
			{
				string[] array3 = text3.Substring(1, text3.Length - 2).Split(',');
				float x = float.Parse(array3[0]);
				float y = float.Parse(array3[1]);
				float z = float.Parse(array3[2]);
				field.SetValue(this, new Vector3(x, y, z));
				break;
			}
			default:
				if (field.GetType().IsEnum)
				{
					field.SetValue(this, Enum.Parse(field.GetType(), text3));
				}
				break;
			}
		}
	}
}
public class Eyelid : MonoBehaviour
{
	public Vector3 openPos;

	public Vector3 oldOpenPos;

	public Vector3 closedPos;

	public float openPerc = 1f;

	private void Start()
	{
		oldOpenPos = openPos;
		openPos = base.transform.localRotation.eulerAngles;
	}

	private void Update()
	{
		base.transform.localRotation = Quaternion.Lerp(Quaternion.Euler(closedPos), Quaternion.Euler(openPos), openPerc);
	}
}
public class FaceCanvasController : MonoBehaviour
{
	private static FaceCanvasController instance;

	public TextMeshProUGUI text;

	public float alpha;

	private void Start()
	{
		instance = this;
		text.enabled = false;
	}

	public static void addText(string message)
	{
		if (!(instance == null))
		{
			instance.text.text = message;
			instance.text.enabled = true;
			instance.alpha = 1f;
			instance.text.color = Color.cyan;
		}
	}

	private void Update()
	{
		if (alpha > 0f)
		{
			text.color = Color.white * alpha;
			alpha -= Time.deltaTime;
			if (alpha < 0f)
			{
				text.enabled = false;
			}
		}
	}
}
public class FaceController : MonoBehaviour
{
	public RigidBodies puppet;

	public Eyelid[] eyelids;

	private Transform[] eyes;

	public Transform lookTarget;

	public Vector3[] eyesRotated;

	public float closeTime;

	public bool blinking;

	public float blinkSpeed = 10f;

	public float blinkFrequency = 5f;

	private float blinkAmount;

	private float nextBlinkTime;

	public Vector3 rotationOffset;

	public Vector3 eyeLimits;

	public Transform jaw;

	public float closedX = 133.147f;

	private float openX = 144f;

	private float targetX = 133f;

	public AudioSource audioSource;

	private float minLoudness = 0.05f;

	private float maxLoudness = 0.1f;

	private float clipLoudness;

	private float[] clipSampleData;

	private float mouthSpeed = 400f;

	private float updateStep = 0.05f;

	private int sampleDataLength = 1024;

	private float audioSourcePitch;

	public float openMouthTimer;

	private float currentUpdateTime;

	public bool justLookForward;

	private int lastHurt;

	private bool setup;

	public GameObject dazedEffect;

	private float changeLooktimer = 3f;

	private bool isSetup;

	private float openPerc;

	public void Setup()
	{
		audioSource = base.gameObject.AddComponent<AudioSource>();
		audioSource.spatialBlend = 1f;
		audioSource.playOnAwake = false;
		GameController.instance.setAudioMixerGroup(audioSource, "Voice");
		rotationOffset = new Vector3(90f, 0f, 0f);
		base.gameObject.AddComponent<AudioHighPassFilter>().cutoffFrequency = 150f;
		eyeLimits = new Vector3(10f, 30f, 45f);
		dazedEffect = UnityEngine.Object.Instantiate(Settings.instance.dazedEffect, base.transform);
		dazedEffect.transform.localPosition = Vector3.zero;
		dazedEffect.transform.localRotation = Quaternion.identity;
		dazedEffect.SetActive(value: false);
		clipSampleData = new float[sampleDataLength];
		eyelids = GetComponentsInChildren<Eyelid>();
		nextBlinkTime = Time.time + UnityEngine.Random.value * blinkFrequency;
		eyes = new Transform[2];
		foreach (Transform item in base.transform)
		{
			if (item.gameObject.name == "eye.L" || item.gameObject.name == "eye_l")
			{
				eyes[0] = item;
			}
			if (item.gameObject.name == "eye.R" || item.gameObject.name == "eye_r")
			{
				eyes[1] = item;
			}
		}
		if (eyelids.Length == 0)
		{
			UnityEngine.Debug.LogError("No Eyelids: " + puppet);
		}
		lookTarget = null;
		base.name = "head with face";
		isSetup = true;
	}

	private void OnDestroy()
	{
		if (dazedEffect != null)
		{
			UnityEngine.Object.Destroy(dazedEffect);
		}
	}

	private void getLookTarget()
	{
		changeLooktimer -= Time.deltaTime;
		if (changeLooktimer < 0f)
		{
			changeLooktimer = UnityEngine.Random.value * 2f;
			justLookForward = UnityEngine.Random.value < 0.3f;
		}
		lookTarget = null;
		if (puppet == null || puppet.character == null)
		{
			if (GameController.instance.player != null)
			{
				lookTarget = GameController.instance.player.rigidBodies.head;
			}
		}
		else
		{
			foreach (Transform item in base.transform)
			{
				item.gameObject.layer = ((!puppet.character.isPlayer()) ? 15 : 0);
			}
			if (puppet.character.targetEnemy != null)
			{
				lookTarget = puppet.character.targetEnemy.rigidBodies.head;
			}
		}
		Vector3 vector = Vector3.Lerp(eyes[0].transform.position, eyes[1].transform.position, 0.5f);
		Quaternion rotation = Quaternion.LookRotation(base.transform.forward);
		if (!(lookTarget == null))
		{
			Quaternion quaternion = Quaternion.LookRotation(lookTarget.position - vector) * Quaternion.Inverse(rotation);
			if (Mathf.Abs(quaternion.x) > 30f || Mathf.Abs(quaternion.y) > 45f)
			{
				lookTarget = null;
			}
		}
	}

	private void updateJaw()
	{
		if (!setup)
		{
			jaw = base.transform.Find("jaw");
			if (jaw == null)
			{
				UnityEngine.Debug.LogError("Couldnt find jaw!");
			}
			closedX = 0f - (jaw.localRotation.eulerAngles.x - 180f);
			setup = true;
		}
		if (!audioSource.isPlaying)
		{
			openPerc = 0f;
		}
		else
		{
			currentUpdateTime += Time.deltaTime;
			if (currentUpdateTime >= updateStep)
			{
				currentUpdateTime = 0f;
				audioSource.clip.GetData(clipSampleData, audioSource.timeSamples);
				clipLoudness = 0f;
				float[] array = clipSampleData;
				foreach (float f in array)
				{
					clipLoudness += Mathf.Abs(f);
				}
				clipLoudness /= sampleDataLength;
				openPerc = Mathf.Clamp01((clipLoudness - minLoudness) / (maxLoudness - minLoudness));
			}
		}
		if (openMouthTimer > openPerc)
		{
			openPerc = Mathf.Clamp01(openMouthTimer);
		}
		openMouthTimer = Mathf.MoveTowards(openMouthTimer, 0f, Time.deltaTime);
		targetX = Mathf.Lerp(closedX, openX, openPerc);
		jaw.localRotation = Quaternion.RotateTowards(jaw.localRotation, Quaternion.Euler(targetX, 0f, 0f), Time.deltaTime * mouthSpeed);
	}

	public float say(VoiceData voice)
	{
		if (voice == null)
		{
			return 0f;
		}
		string text = LocalisationController.getText("Character Voice: " + puppet.character.data.name, voice.words);
		return say(voice.clip, halfSpacial: true, text, onlyInterupt: false);
	}

	public float say(AudioClip clip, bool halfSpacial, string sayText, bool onlyInterupt)
	{
		if (clip == null)
		{
			return 0f;
		}
		if (audioSource == null)
		{
			audioSource = GetComponent<AudioSource>();
		}
		if (audioSource == null)
		{
			UnityEngine.Debug.LogError("Audio source is null on " + puppet.name);
		}
		if (audioSource.isPlaying)
		{
			SubtitlesController.instance.cutOff(audioSource.time / audioSource.clip.length, sayText);
		}
		else
		{
			if (onlyInterupt)
			{
				return 0f;
			}
			SubtitlesController.instance.say(this, sayText, clip.length, Vector3.zero);
		}
		float num2 = (audioSource.pitch = 1f);
		audioSourcePitch = num2;
		audioSource.volume = puppet.character.data.voice.volume;
		audioSource.clip = clip;
		audioSource.spatialBlend = (halfSpacial ? 0.5f : 1f);
		audioSource.Play();
		return clip.length;
	}

	public float hurt(bool female)
	{
		VoiceData[] array = (female ? GeneralSounds.instance.femaleHurt_voice : GeneralSounds.instance.maleHurt_voice);
		int num = UnityEngine.Random.Range(0, array.Length);
		if (num == lastHurt)
		{
			num++;
			if (num >= array.Length)
			{
				num = 0;
			}
		}
		lastHurt = num;
		return say(array[num].clip, halfSpacial: false, array[num].words, onlyInterupt: true);
	}

	private void Update()
	{
		if (GameController.instance == null || GameController.instance.paused || !isSetup)
		{
			return;
		}
		if (!(puppet == null) && !(puppet.character == null))
		{
			float num = puppet.character.rigidBodies.staminaPerc(inverse: true);
			if (!dazedEffect.activeInHierarchy && puppet.character.rigidBodies.dazed() && (GameController.instance.difficultyLevel.yourHealthBar || puppet.character.hasEffect(CharacterEffect.Effect.Stunned) || puppet.character.isPlayer()))
			{
				dazedEffect.SetActive(value: true);
				GeneralSounds.playSound(6);
				MusicController.pause();
			}
			else if (dazedEffect.activeInHierarchy && !puppet.character.rigidBodies.dazed())
			{
				dazedEffect.SetActive(value: false);
			}
			if (puppet.character.rigidBodies.fall.falling)
			{
				audioSource.Stop();
			}
			else if (!audioSource.isPlaying && num > 0.3f)
			{
				audioSource.clip = Settings.instance.breaths[UnityEngine.Random.Range(0, Settings.instance.breaths.Length)];
				float num3 = (audioSource.pitch = (puppet.character.data.female ? Settings.instance.femaleBreathPitch : 1f));
				audioSourcePitch = num3;
				audioSource.spatialBlend = 1f;
				audioSource.volume = puppet.character.rigidBodies.staminaPerc(inverse: true) * Settings.instance.maxBreathVolume;
				audioSource.Play();
			}
		}
		audioSource.pitch = Time.timeScale * audioSourcePitch;
		updateJaw();
		getLookTarget();
		if (eyesRotated.Length != 2)
		{
			eyesRotated = new Vector3[2];
		}
		int num4 = 0;
		Transform[] array = eyes;
		foreach (Transform transform in array)
		{
			Quaternion to = ((!(lookTarget != null) || justLookForward) ? (Quaternion.LookRotation(base.transform.forward) * Quaternion.Euler(rotationOffset)) : (Quaternion.LookRotation(lookTarget.position + lookTarget.up * 0.07f - transform.position) * Quaternion.Euler(rotationOffset)));
			transform.transform.rotation = Quaternion.RotateTowards(transform.transform.rotation, to, Time.deltaTime * 180f);
			eyesRotated[num4] = (transform.transform.localRotation * Quaternion.Inverse(Quaternion.Euler(rotationOffset))).eulerAngles;
			if (eyesRotated[num4].x >= 180f)
			{
				eyesRotated[num4].x -= 360f;
			}
			if (eyesRotated[num4].y >= 180f)
			{
				eyesRotated[num4].y -= 360f;
			}
			if (eyesRotated[num4].z >= 180f)
			{
				eyesRotated[num4].z -= 360f;
			}
			if (eyesRotated[num4].x < -180f)
			{
				eyesRotated[num4].x += 360f;
			}
			if (eyesRotated[num4].y < -180f)
			{
				eyesRotated[num4].y += 360f;
			}
			if (eyesRotated[num4].z < -180f)
			{
				eyesRotated[num4].z += 360f;
			}
			eyesRotated[num4].x = Mathf.Clamp(eyesRotated[num4].x, 0f - eyeLimits.x, eyeLimits.x);
			eyesRotated[num4].y = Mathf.Clamp(eyesRotated[num4].y, 0f - eyeLimits.y, eyeLimits.y);
			eyesRotated[num4].z = Mathf.Clamp(eyesRotated[num4].z, 0f - eyeLimits.z, eyeLimits.z);
			transform.transform.localRotation = Quaternion.Euler(eyesRotated[num4]) * Quaternion.Euler(rotationOffset);
			num4++;
		}
		if (blinking || closeTime > 0f || (puppet != null && puppet.character != null && (puppet.standUpPerc < 0f || puppet.dazed())))
		{
			blinkAmount += Time.deltaTime * blinkSpeed;
			if (closeTime > 0f)
			{
				closeTime -= Time.deltaTime;
			}
			if (blinkAmount >= 1f)
			{
				blinking = false;
			}
		}
		else if (blinkAmount > 0f)
		{
			blinkAmount -= Time.deltaTime * blinkSpeed;
			if (blinkAmount <= 0f)
			{
				nextBlinkTime = Time.time + UnityEngine.Random.value * blinkFrequency;
			}
		}
		else if (Time.time > nextBlinkTime && !blinking)
		{
			blinking = true;
		}
		blinkAmount = Mathf.Clamp01(blinkAmount);
		Eyelid[] array2 = eyelids;
		foreach (Eyelid eyelid in array2)
		{
			eyelid.openPerc = 1f - blinkAmount;
			if (puppet != null && puppet.character != null)
			{
				if (puppet.character.hasEffect(CharacterEffect.Effect.Blinded))
				{
					eyelid.openPerc *= 0.25f;
				}
				else if (puppet.character.hasEffect(CharacterEffect.Effect.BlindLite))
				{
					eyelid.openPerc *= 0.45f;
				}
			}
		}
	}
}
public class FaceDirection : MonoBehaviour
{
	public Vector3 worldRotation;

	private void Start()
	{
	}

	private void Update()
	{
		base.transform.rotation = Quaternion.Euler(worldRotation);
	}
}
public class FaceHitEffect : MonoBehaviour
{
	public CameraEyeLidsController[] eyeLids;

	public float brightness;

	public float blur;

	public float bloodHitPerc;

	public float bloodAngle;

	public Vector3 hitRotation;

	public float flashSpeed = 1f;

	public float flashMax = 2f;

	public Color staminaBest;

	public Color staminaWorst;

	[Range(0f, 1f)]
	public float blinkPerc;

	private float startDelay = 0.5f;

	[Range(0f, 1f)]
	public float blurAmount;

	[Range(0f, 1f)]
	public float vignetteAmount;

	[Range(0f, 1f)]
	public float redAmount;

	[Range(0f, 1f)]
	public float sicknessAmount;

	[Range(0f, 1f)]
	public float slowMoAmount;

	public bool updateFromCharacter;

	private float throb;

	private float throbAngle;

	public Material bloodMaterial;

	private void Start()
	{
	}

	public void hit(float knockBackPerc, float damagePerc, Vector3 hitPos, bool isHead)
	{
		Quaternion quaternion = Quaternion.LookRotation(hitPos - base.transform.position);
		Quaternion rotation = Quaternion.LookRotation(base.transform.forward);
		hitRotation = (quaternion * Quaternion.Inverse(rotation)).eulerAngles;
		blinkPerc += knockBackPerc * 2f;
		if (blinkPerc > 1f)
		{
			blinkPerc = 1f;
		}
		if (knockBackPerc > 0.5f && isHead)
		{
			blurAmount += knockBackPerc * 4f;
			if (blurAmount > 1f)
			{
				blurAmount = 1f;
			}
		}
		int num = Mathf.RoundToInt(Mathf.DeltaAngle(0f, hitRotation.y) / 90f);
		if (damagePerc > 0f && bloodHitPerc == 0f)
		{
			bloodAngle = ((num > 0) ? 180 : 0);
			bloodAngle += UnityEngine.Random.Range(-45, 45);
		}
		bloodHitPerc += damagePerc;
		bloodHitPerc = Mathf.Clamp01(bloodHitPerc);
	}

	private void Update()
	{
		if (startDelay > 0f)
		{
			startDelay -= Time.deltaTime;
			return;
		}
		if (bloodHitPerc > 0f)
		{
			bloodMaterial.SetColor("_Color", Color.Lerp(Color.clear, Color.white, bloodHitPerc));
			bloodHitPerc -= Time.deltaTime / 2f;
			if (bloodHitPerc < 0f)
			{
				bloodHitPerc = 0f;
			}
		}
		if (updateFromCharacter)
		{
			bool num = GameController.instance.player != null && GameController.instance.player.hasEffect(CharacterEffect.Effect.Blinded);
			bool flag = GameController.instance.player != null && GameController.instance.player.hasEffect(CharacterEffect.Effect.BlindLite);
			float target = 0f;
			if (GameController.instance.player != null)
			{
				if (GameController.instance.player.hasEffect(CharacterEffect.Effect.Drunk))
				{
					Mathf.Clamp01(GameController.instance.player.getEffect(CharacterEffect.Effect.Drunk).amount / 5f);
				}
				if (GameController.instance.player.hasEffect(CharacterEffect.Effect.Pain))
				{
					float amount = GameController.instance.player.getEffect(CharacterEffect.Effect.Pain).amount;
					throbAngle += Time.deltaTime * 360f;
					throbAngle %= 360f;
					throb = Mathf.Abs(Mathf.Sin(throbAngle * ((float)Math.PI / 180f)));
					redAmount = Mathf.Clamp01(amount * throb) * 0.75f;
				}
			}
			slowMoAmount = Mathf.Clamp01(1f - Time.timeScale);
			float num2 = 1f;
			if (GameController.instance.player != null && !GameController.instance.player.rigidBodies.isDown(allTheWay: true))
			{
				num2 = GameController.instance.player.rigidBodies.staminaPerc();
			}
			vignetteAmount = 1f - num2;
			if (num)
			{
				target = 0.7f;
				blurAmount = Mathf.MoveTowards(blurAmount, 1f, Time.deltaTime * 4f);
			}
			else if (flag)
			{
				target = 0.45f;
				blurAmount = Mathf.MoveTowards(blurAmount, 0.25f, Time.deltaTime * 2f);
			}
			else
			{
				blurAmount = Mathf.MoveTowards(blurAmount, 0f, Time.deltaTime / 2f);
			}
			blinkPerc = Mathf.MoveTowards(blinkPerc, target, Time.deltaTime * flashSpeed);
			sicknessAmount = ((GameController.instance.player != null) ? GameController.instance.player.sicknessAmount : 0f);
		}
		CameraEyeLidsController[] array = eyeLids;
		foreach (CameraEyeLidsController obj in array)
		{
			obj.closedPerc = Mathf.Clamp01(blinkPerc * 1.25f);
			obj.blurAmount = blurAmount;
			obj.vignetteAmount = vignetteAmount;
			obj.redAmount = redAmount;
			obj.sicknessAmount = sicknessAmount;
			obj.slowMoAmount = slowMoAmount;
			obj.bloodEnabled = bloodHitPerc > 0f;
			obj.bloodAngle = bloodAngle;
		}
		if (blurAmount > HitEffects.instance.muffleAmount)
		{
			HitEffects.instance.muffleAmount = blurAmount;
		}
	}
}
public class FadeOutLight : MonoBehaviour
{
	public bool fadeOut = true;

	public float duration = 2f;

	private Light light;

	private float timer;

	private float intensity;

	private void Start()
	{
		light = GetComponent<Light>();
		timer = duration;
		intensity = light.intensity;
		light.intensity = 0f;
	}

	private void Update()
	{
		if (timer != 0f)
		{
			timer -= Time.deltaTime;
			if (timer < 0f)
			{
				timer = 0f;
			}
			light.intensity = Mathf.MoveTowards(light.intensity, intensity * (timer / duration), Time.deltaTime * 20f);
		}
	}
}
public class Fader : MonoBehaviour
{
	public static Fader instance;

	public float fadeTime = 3f;

	public static bool fading;

	public static bool fadeOut;

	public static bool paused = true;

	public static float vignettingBlink = 1f;

	public bool display_fading;

	public bool display_fadeOut;

	public bool display_paused = true;

	public float display_vignettingBlink = 1f;

	private void Awake()
	{
		instance = this;
		fadeOut = false;
	}

	public static void fade(bool fadeOut, float fadeTime = 3f)
	{
		if (instance == null)
		{
			UnityEngine.Debug.LogError("Fader null!");
		}
		Fader.fadeOut = fadeOut;
		fading = true;
		instance.fadeTime = fadeTime;
	}

	private void Update()
	{
		display_fading = fading;
		display_fadeOut = fadeOut;
		display_paused = paused;
		display_vignettingBlink = vignettingBlink;
		if (paused)
		{
			vignettingBlink = 1f;
			return;
		}
		if (fadeOut)
		{
			if (vignettingBlink < 1f)
			{
				vignettingBlink += Time.deltaTime / fadeTime;
				if (vignettingBlink > 1f)
				{
					vignettingBlink = 1f;
				}
			}
			return;
		}
		fading = vignettingBlink > 0f;
		if (vignettingBlink > 0f)
		{
			vignettingBlink -= Time.deltaTime / fadeTime;
			if (vignettingBlink < 0f)
			{
				vignettingBlink = 0f;
			}
		}
	}
}
public class FallAndGetUp : MonoBehaviour
{
	private GameCharacter character;

	public bool falling;

	public bool fallen;

	public bool gotUp = true;

	public Animator animator;

	public PuppetMaster puppetMaster;

	public VRIK ik;

	private float unpinnedTimer;

	private float getUpTimer;

	private Vector3 hipsForward;

	private Vector3 hipsUp;

	private Vector3 getUpPosition;

	public float getupAnimationBlendWeight;

	public float getupAnimationBlendWeightV;

	private bool getUpTargetFixed;

	public LayerMask groundLayers;

	public Transform ikTrackerContainer;

	public float speedMod = 1f;

	public bool recovering;

	public float canRecoverMin = -1f;

	private float recoverHealth = 0.02f;

	private float stuckTimer;

	private bool feetSet;

	public void Setup(GameCharacter character, PuppetMaster puppetMaster, VRIK ik)
	{
		this.character = character;
		this.puppetMaster = puppetMaster;
		this.ik = ik;
		animator = ik.gameObject.GetComponent<Animator>();
		hipsForward = Quaternion.Inverse(puppetMaster.muscles[0].transform.rotation) * puppetMaster.targetRoot.forward;
		hipsUp = Quaternion.Inverse(puppetMaster.muscles[0].transform.rotation) * puppetMaster.targetRoot.up;
		canRecoverMin = -1f;
		animator.enabled = false;
	}

	private void Start()
	{
		hipsForward = Quaternion.Inverse(puppetMaster.muscles[0].transform.rotation) * puppetMaster.targetRoot.forward;
		hipsUp = Quaternion.Inverse(puppetMaster.muscles[0].transform.rotation) * puppetMaster.targetRoot.up;
	}

	public bool willRecover()
	{
		if (!character.vrCharacterController.onGround)
		{
			return false;
		}
		if (!fallen && character.rigidBodies.standUpPerc > canRecoverMin)
		{
			return character.rigidBodies.standUpPerc <= 0f;
		}
		return false;
	}

	private void keepInBounds()
	{
		Transform transform = puppetMaster.muscles[0].rigidbody.transform;
		switch (GameController.instance.standButtons.boundsType)
		{
		case StandButtonsController.BoundsType.Circle:
			if (GameController.flatVector(transform.position).magnitude > GameController.instance.standButtons.boundsSize)
			{
				Vector3 vector2 = GameController.flatVector(transform.position);
				float num = vector2.magnitude - GameController.instance.standButtons.boundsSize;
				base.transform.parent.position -= num * vector2.normalized;
			}
			break;
		case StandButtonsController.BoundsType.Square:
			if (Mathf.Abs(transform.position.x) > GameController.instance.standButtons.boundsSize || Mathf.Abs(transform.position.z) > GameController.instance.standButtons.boundsSize)
			{
				Vector3 vector3 = GameController.flatVector(transform.position);
				Vector3 zero2 = Vector3.zero;
				if (vector3.x > GameController.instance.standButtons.boundsSize)
				{
					zero2.x = vector3.x - GameController.instance.standButtons.boundsSize;
				}
				if (vector3.z > GameController.instance.standButtons.boundsSize)
				{
					zero2.z = vector3.z - GameController.instance.standButtons.boundsSize;
				}
				if (0f - vector3.x > GameController.instance.standButtons.boundsSize)
				{
					zero2.x = 0f - (0f - vector3.x - GameController.instance.standButtons.boundsSize);
				}
				if (0f - vector3.z > GameController.instance.standButtons.boundsSize)
				{
					zero2.z = 0f - (0f - vector3.z - GameController.instance.standButtons.boundsSize);
				}
				base.transform.parent.position -= zero2;
			}
			break;
		case StandButtonsController.BoundsType.Rect:
			if (Mathf.Abs(transform.position.x) > GameController.instance.standButtons.bounds.x || Mathf.Abs(transform.position.z) > GameController.instance.standButtons.bounds.z)
			{
				Vector3 vector = GameController.flatVector(transform.position);
				Vector3 zero = Vector3.zero;
				if (vector.x > GameController.instance.standButtons.bounds.x)
				{
					zero.x = vector.x - GameController.instance.standButtons.bounds.x;
				}
				if (vector.z > GameController.instance.standButtons.bounds.z)
				{
					zero.z = vector.z - GameController.instance.standButtons.bounds.z;
				}
				if (0f - vector.x > GameController.instance.standButtons.bounds.x)
				{
					zero.x = 0f - (0f - vector.x - GameController.instance.standButtons.bounds.x);
				}
				if (0f - vector.z > GameController.instance.standButtons.bounds.z)
				{
					zero.z = 0f - (0f - vector.z - GameController.instance.standButtons.bounds.z);
				}
				base.transform.parent.position -= zero;
			}
			break;
		}
	}

	private void Update()
	{
		speedMod = 1f;
		fallen = puppetMaster.pinWeight == 0f;
		updateFeet(falling && puppetMaster.pinWeight < 0.5f);
		if (puppetMaster != null && character != null && character.rigidBodies != null && (!fallen || gotUp || puppetMaster.mode != PuppetMaster.Mode.Kinematic) && puppetMaster.pinWeight == 1f && character.rigidBodies.createTime < Time.time - 1f)
		{
			if ((character.trackers.transforms[0].transform.position - character.rigidBodies.headHittable.transform.position).magnitude > 0.15f)
			{
				stuckTimer += Time.deltaTime;
				if (stuckTimer > 0.2f && puppetMaster.mode == PuppetMaster.Mode.Active)
				{
					puppetMaster.mode = PuppetMaster.Mode.Kinematic;
				}
			}
			else
			{
				stuckTimer = 0f;
				if (puppetMaster.mode == PuppetMaster.Mode.Kinematic)
				{
					puppetMaster.mode = PuppetMaster.Mode.Active;
				}
			}
		}
		if (falling)
		{
			if (!recovering || character.rigidBodies.standUpPerc <= canRecoverMin)
			{
				puppetMaster.pinWeight = Mathf.MoveTowards(puppetMaster.pinWeight, 0f, Time.deltaTime / 2f);
			}
			else
			{
				puppetMaster.pinWeight = Mathf.MoveTowards(puppetMaster.pinWeight, 1f, Time.deltaTime / 2f);
				if (puppetMaster.pinWeight == 1f && puppetMaster.muscleWeight == 1f)
				{
					if (character.isPlayer())
					{
						FaceCanvasController.addText(LocalisationController.getText("General", "Recovered..."));
						Saving.instance.incrementStat("Recoveries", onlyInFight: true);
					}
					character.rigidBodies.downSettings(up: true);
					falling = false;
					recovering = false;
					character.rigidBodies.standUpPerc = recoverHealth;
					if (character.data.hasPerk("Come Back Kid"))
					{
						character.rigidBodies.standUpPerc = character.data.perkMod("Come Back Kid", character.data.name);
					}
					if (character.data.hasPerk("One Last Trick"))
					{
						character.rigidBodies.specialPerc = 1f;
					}
					character.rigidBodies.standUpPercMax = character.rigidBodies.standUpPerc;
					character.rigidBodies.recoveries--;
				}
			}
			if (!character.vrCharacterController.onGround)
			{
				puppetMaster.pinWeight = 0f;
				puppetMaster.muscleWeight = 0f;
				if (!fallen)
				{
					fallen = true;
					character.knockedOutFall();
				}
			}
			else if (willRecover() && puppetMaster.pinWeight < 0.5f && !recovering && character.rigidBodies.recoveries > 0)
			{
				recovering = true;
				canRecoverMin /= 1.5f;
			}
			float num = 10f;
			if (puppetMaster.muscles[0].rigidbody.velocity.magnitude > num)
			{
				UnityEngine.Debug.Log("Set velocity to " + num + ": " + puppetMaster.muscles[0].rigidbody.velocity.magnitude);
				Muscle[] muscles = puppetMaster.muscles;
				foreach (Muscle muscle in muscles)
				{
					muscle.rigidbody.velocity = Vector3.ClampMagnitude(muscle.rigidbody.velocity, num - 1f);
					muscle.rigidbody.angularVelocity = Vector3.ClampMagnitude(muscle.rigidbody.angularVelocity, 360f);
				}
			}
			if (character.lives > 0)
			{
				keepInBounds();
			}
			else if (GameData.instance.locations[GameController.instance.selectedLevel].name == "Boxing Arena" && !character.isPlayer())
			{
				Transform transform = puppetMaster.muscles[0].rigidbody.transform;
				if (Mathf.Abs(transform.position.x) > GameController.instance.standButtons.boundsSize + 0.5f || Mathf.Abs(transform.position.z) > GameController.instance.standButtons.boundsSize + 0.5f)
				{
					AchievementsController.achievement("Ring Out");
				}
			}
			if (!fallen && recovering)
			{
				puppetMaster.muscleWeight = Mathf.MoveTowards(puppetMaster.muscleWeight, 1f, Time.deltaTime / 2f);
			}
			else
			{
				puppetMaster.muscleWeight = Mathf.MoveTowards(puppetMaster.muscleWeight, 0f, Time.deltaTime / 3f);
			}
			speedMod = puppetMaster.muscleWeight;
			animator.enabled = true;
			animator.speed = 1f;
			if (puppetMaster.pinWeight == 0f)
			{
				if (ik.solver.IKPositionWeight == 1f && character != null && !fallen)
				{
					fallen = true;
					character.knockedOutFall();
				}
				ik.solver.IKPositionWeight = Mathf.MoveTowards(ik.solver.IKPositionWeight, puppetMaster.pinWeight, Time.deltaTime * 3f);
			}
			else
			{
				ik.solver.IKPositionWeight = Mathf.MoveTowards(ik.solver.IKPositionWeight, 1f, Time.deltaTime);
			}
			return;
		}
		puppetMaster.pinWeight = Mathf.MoveTowards(puppetMaster.pinWeight, 1f, Time.deltaTime);
		puppetMaster.muscleWeight = Mathf.MoveTowards(puppetMaster.muscleWeight, 1f, Time.deltaTime);
		if (puppetMaster.pinWeight >= 0.75f)
		{
			ik.solver.IKPositionWeight = Mathf.MoveTowards(ik.solver.IKPositionWeight, 1f, Time.deltaTime * 2f);
		}
		if (puppetMaster.pinWeight >= 1f && ik.solver.IKPositionWeight >= 1f)
		{
			animator.enabled = false;
			animator.speed = 0f;
			if (puppetMaster.muscleWeight == 1f && !gotUp)
			{
				gotUp = true;
				character?.backStanding();
			}
		}
	}

	public void updateFeet(bool feetEnabled)
	{
		if (feetEnabled == feetSet)
		{
			return;
		}
		feetSet = feetEnabled;
		Muscle[] muscles = character.rigidBodies.pm.muscles;
		foreach (Muscle muscle in muscles)
		{
			if (muscle.name.Contains("foot"))
			{
				if (!feetEnabled)
				{
					muscle.DisableColliders();
				}
				else
				{
					muscle.EnableColliders();
				}
			}
		}
	}

	public void Fall()
	{
		if (falling)
		{
			canRecoverMin /= 2f;
			puppetMaster.pinWeight = 0f;
			if (!fallen)
			{
				fallen = true;
				character.knockedOutFall();
			}
			recovering = false;
			return;
		}
		if (ikTrackerContainer == null)
		{
			if (character.isPlayer())
			{
				ikTrackerContainer = character.playerController.activeRig.transform;
			}
			else
			{
				ikTrackerContainer = character.aiControl.aiTrackerContainer;
			}
		}
		falling = true;
		gotUp = false;
		character.knockedOutEarly();
	}

	public void GetUp()
	{
		if (!falling)
		{
			return;
		}
		canRecoverMin = -1f;
		Quaternion rotation = Quaternion.identity;
		_ = Vector3.zero;
		if (ikTrackerContainer == null)
		{
			if (character.isPlayer())
			{
				ikTrackerContainer = character.playerController.activeRig.transform;
			}
			else
			{
				ikTrackerContainer = character.aiControl.aiTrackerContainer;
			}
		}
		if (character.isPlayer())
		{
			rotation = Quaternion.LookRotation(GameController.flatVector(GameController.instance.noPlayer.activeRig.trackers[0].localRotation * Vector3.forward));
		}
		falling = false;
		bool flag = IsProne();
		Vector3 tangent = puppetMaster.muscles[0].rigidbody.rotation * hipsUp;
		Vector3 normal = puppetMaster.targetRoot.up;
		Vector3.OrthoNormalize(ref normal, ref tangent);
		RotateTarget(Quaternion.LookRotation(flag ? tangent : (-tangent), puppetMaster.targetRoot.up));
		puppetMaster.SampleTargetMappedState();
		Vector3 vector = (flag ? Settings.instance.getUpOffsetProne : Settings.instance.getUpOffsetSupine);
		Vector3 forward = (flag ? puppetMaster.muscles[0].rigidbody.transform.up : (-puppetMaster.muscles[0].rigidbody.transform.up));
		forward.y = 0f;
		Quaternion quaternion = Quaternion.LookRotation(forward);
		getUpPosition = puppetMaster.muscles[0].rigidbody.position + quaternion * vector;
		getUpPosition.y = ((character == null) ? 0f : character.mover.transform.position.y);
		ikTrackerContainer.transform.position = getUpPosition;
		ikTrackerContainer.transform.rotation = quaternion * Quaternion.Inverse(rotation);
		ik.transform.position = getUpPosition;
		ik.transform.rotation = Quaternion.LookRotation(forward);
		getupAnimationBlendWeight = 1f;
		getUpTargetFixed = false;
		if (flag)
		{
			animator.Play("GetUpProne");
		}
		else
		{
			animator.Play("GetUpSupine");
		}
	}

	protected bool IsProne()
	{
		return Vector3.Dot(puppetMaster.muscles[0].transform.forward, Vector3.up) < 0f;
	}

	protected void GroundTarget(LayerMask layers)
	{
		if (Physics.Raycast(new Ray(puppetMaster.targetRoot.position + puppetMaster.targetRoot.up, -puppetMaster.targetRoot.up), out var hitInfo, 4f, layers))
		{
			if (!float.IsNaN(hitInfo.point.x) && !float.IsNaN(hitInfo.point.y) && !float.IsNaN(hitInfo.point.z))
			{
				puppetMaster.targetRoot.position = hitInfo.point;
			}
			else
			{
				UnityEngine.Debug.LogWarning("Raycasting against a large collider has produced a NaN hit point.", base.transform);
			}
		}
	}

	protected void RotateTarget(Quaternion rotation)
	{
		puppetMaster.targetRoot.rotation = rotation;
	}

	protected void MoveTarget(Vector3 position)
	{
		puppetMaster.targetRoot.position = position;
	}
}
[Serializable]
public class FightingStyle
{
	public string name;

	public RecordAction idle;

	public RecordAction taunt;

	public List<FightingStyle_Stance> stances;

	public static FightingStyle createNew()
	{
		return new FightingStyle
		{
			name = "New Style",
			idle = new RecordAction(""),
			taunt = new RecordAction(""),
			stances = new List<FightingStyle_Stance>()
		};
	}

	public void setup(bool clean)
	{
		idle.setup(clean, name + " Idle");
		taunt.setup(clean, name + " Taunt");
		int num = 0;
		foreach (FightingStyle_Stance stance in stances)
		{
			num++;
			stance.setup(this, clean, num);
		}
	}

	public bool randomAllowed()
	{
		if (name == "Zombie")
		{
			return false;
		}
		if (name == "Practice")
		{
			return false;
		}
		if (name == "Dark Dragon")
		{
			return false;
		}
		return true;
	}
}
[Serializable]
public class FightingStyleCounter
{
	public string name;

	public RecordAction action;

	public bool left;

	public bool right;

	public bool frontLeft;

	public bool frontRight;

	public bool head;

	public bool body;

	public FightingStyleCounter(string name)
	{
		this.name = name;
		action = new RecordAction(name);
	}

	public void setup(bool clean, string defaultName)
	{
		action.setup(clean, defaultName);
	}

	public bool kickViable()
	{
		if (frontLeft || frontRight)
		{
			return body;
		}
		return false;
	}

	public bool viable(float angle, float hitHeight, float headHeight)
	{
		if (head && body)
		{
			if ((double)(hitHeight - headHeight) > 0.4)
			{
				return false;
			}
		}
		else if (head)
		{
			if (Mathf.Abs(hitHeight - headHeight) > 0.4f)
			{
				return false;
			}
		}
		else if ((double)(hitHeight - headHeight) > -0.6)
		{
			return false;
		}
		if (frontRight && angle >= Settings.instance.aiCounterMiddleRange.min && angle <= Settings.instance.aiCounterMiddleRange.max)
		{
			return true;
		}
		if (frontLeft && angle <= 0f - Settings.instance.aiCounterMiddleRange.min && angle >= 0f - Settings.instance.aiCounterMiddleRange.max)
		{
			return true;
		}
		if (right && angle >= Settings.instance.aiCounterOuterRange.min && angle <= Settings.instance.aiCounterOuterRange.max)
		{
			return true;
		}
		if (left && angle <= 0f - Settings.instance.aiCounterOuterRange.min && angle >= 0f - Settings.instance.aiCounterOuterRange.max)
		{
			return true;
		}
		return false;
	}
}
[Serializable]
public class FightingStyle_Stance
{
	public RecordAction stance;

	public List<RecordAction> attacks = new List<RecordAction>();

	public List<FightingStyleCounter> counters = new List<FightingStyleCounter>();

	public float stanceAngle;

	private bool isSetup;

	public void setup(FightingStyle style, bool clean, int num)
	{
		isSetup = true;
		if (stance == null)
		{
			stance = new RecordAction("Stance");
		}
		if (attacks == null)
		{
			attacks = new List<RecordAction>();
		}
		if (counters == null)
		{
			counters = new List<FightingStyleCounter>();
		}
		if (stanceAngle == 0f)
		{
			UnityEngine.Debug.LogError(style.name + " has stance with 0 angle");
		}
		stance.setup(clean, style.name + " Stance " + num);
		int num2 = 0;
		foreach (RecordAction attack in attacks)
		{
			num2++;
			attack.setup(clean, "Attack " + num2);
		}
		num2 = 0;
		foreach (FightingStyleCounter counter in counters)
		{
			num2++;
			counter.setup(clean, "Counter " + num2);
		}
	}
}
public class FinalStoryController : StandButtonsController
{
	public TextMeshProUGUI storyText;

	public Transform charSpawnPos;

	public GameCharacter storyChar;

	private bool setup;

	private void Start()
	{
		if (spawnPoints.Length == 0)
		{
			spawnPoints = GetComponentsInChildren<SpawnPointController>();
		}
		GameController.instance.standButtons = this;
		GameController.instance.aiMode = 5;
		Saving.instance.savedProgress.CompleteGame();
		Saving.saveProgress();
	}

	private void Update()
	{
		noticeBoard.SetActive(OptionData.getOption("Noticeboard").value == 0);
		if (!setup && GameController.instance.player != null)
		{
			setup = true;
			storyChar = GameController.instance.addFighter(2, GameController.instance.characterID, 1, charSpawnPos.position, charSpawnPos.rotation.eulerAngles.y, 1f, aboveGround: true);
			storyChar.lives = 1;
			GameController.instance.hud.setup();
			CharacterData characterData = GameController.instance.gameData.characters[GameController.instance.characterID];
			storyText.text = LocalisationController.getText("Character: " + characterData.name, characterData.ending);
			if (storyText.text == "")
			{
				storyText.text = "End story for " + characterData.name + " not done yet.\n\nSorry about that";
			}
		}
	}
}
public class FireOnSqueeze : MonoBehaviour
{
	private SpecialMoveController move;

	public Transform shotSpawn;

	public GameObject particles;

	public ProjectileController bulletPrefab;

	public TimeSlow timeSlow;

	private bool done;

	private float doneTimer;

	private void Start()
	{
		move = GetComponent<SpecialMoveController>();
	}

	private void Update()
	{
		if (done)
		{
			if (!move.character.isPlayer())
			{
				if (doneTimer > 3f)
				{
					move.activateMove();
				}
				doneTimer += Time.deltaTime;
			}
		}
		else if (move.character.rigidBodies.hands.r_squeezeAmount > 0.98f)
		{
			done = true;
			particles.gameObject.SetActive(value: true);
			ProjectileController projectileController = UnityEngine.Object.Instantiate(bulletPrefab, GameController.instance.transform);
			projectileController.setup(move.character, shotSpawn.position, shotSpawn.rotation, shotSpawn.forward, fromGrab: false);
			projectileController.deleteTimer = 2f;
			timeSlow.doIt();
		}
	}
}
public class FlameController : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
		base.transform.rotation = Quaternion.Euler(-90f, 0f, UnityEngine.Random.value * 360f);
		base.transform.localScale = Vector3.one * (UnityEngine.Random.value + 0.5f);
	}
}
public class FlickerLight : MonoBehaviour
{
	private Light light;

	public Vector3 startPos;

	public Vector3 move;

	public float minIntensity = 0.5f;

	public float maxIntensity = 2f;

	public float heightSpeed;

	public float intensitySpeed;

	public float targetIntensity;

	private float heightPerc;

	private void Start()
	{
		startPos = base.transform.position;
		light = GetComponent<Light>();
		targetIntensity = UnityEngine.Random.Range(minIntensity, maxIntensity);
		heightPerc = UnityEngine.Random.value;
	}

	private void Update()
	{
		base.transform.position = startPos + move * heightPerc;
		light.intensity = Mathf.MoveTowards(light.intensity, targetIntensity, Time.deltaTime * intensitySpeed);
		if (light.intensity == targetIntensity)
		{
			targetIntensity = UnityEngine.Random.Range(minIntensity, maxIntensity);
		}
		heightPerc += heightSpeed * Time.deltaTime;
		heightPerc = Mathf.Repeat(heightPerc, 1f);
	}

	private float rnd()
	{
		return UnityEngine.Random.value * 2f - 1f;
	}
}
public class FloatingCanvasController : MonoBehaviour
{
	public float distance;

	public float angleThreshold;

	public float moveSpeed = 1f;

	public float rotateSpeed = 180f;

	private Quaternion targetRotation;

	public TextMeshProUGUI text;

	public Image ring;

	private Vector3 origScale;

	private void Start()
	{
		origScale = base.transform.localScale;
	}

	public void show(string message, float perc, float scale)
	{
		ring.fillAmount = perc;
		text.text = message;
		LocalisationController.getText("Floating Text", text);
		bool flag = false;
		if (!base.gameObject.activeInHierarchy)
		{
			flag = true;
			base.gameObject.SetActive(value: true);
		}
		Quaternion.LookRotation(base.transform.position - Camera.main.transform.position);
		base.transform.position = Camera.main.transform.position + Camera.main.transform.forward * distance * scale;
		base.transform.localScale = origScale * scale;
		targetRotation = Quaternion.LookRotation(base.transform.position - Camera.main.transform.position);
		if (flag)
		{
			base.transform.rotation = targetRotation;
		}
		else
		{
			base.transform.rotation = Quaternion.RotateTowards(base.transform.rotation, targetRotation, Time.deltaTime * rotateSpeed);
		}
	}

	private void Update()
	{
	}
}
public class FloatingHealthBarController : MonoBehaviour
{
	public GameObject contents;

	public HealthBarController healthBar;

	private GameCharacter target;

	private void Start()
	{
	}

	private void Update()
	{
		if (GameController.instance == null || Camera.main == null)
		{
			return;
		}
		if ((GameController.instance.difficultyLevel.enemyHealthBar || OptionData.getBool("Always Meters")) && GameController.instance.player != null)
		{
			if (GameController.instance.player.targetEnemy != null)
			{
				target = GameController.instance.player.targetEnemy;
				if (target.hasEffect(CharacterEffect.Effect.Ghost))
				{
					target = null;
				}
			}
		}
		else
		{
			target = null;
		}
		if (target == null || target.rigidBodies.isDown(allTheWay: true))
		{
			contents.SetActive(value: false);
			return;
		}
		contents.SetActive(value: true);
		healthBar.update(target);
		base.transform.position = target.trackers.transforms[0].position;
		Vector3 forward = Camera.main.transform.position - base.transform.position;
		forward.y = 0f;
		float num = Mathf.Clamp01((forward.magnitude - 2f) / 3f);
		healthBar.transform.localScale = Vector3.one * (1f + num);
		base.transform.rotation = Quaternion.LookRotation(forward);
	}
}
public class FloatingPointerController : MonoBehaviour
{
	public static FloatingPointerController instance;

	public TextMeshProUGUI info;

	private LineRenderer line;

	public GameObject contents;

	public Transform pointingAt;

	public string displayText;

	private void Start()
	{
		line = GetComponent<LineRenderer>();
		instance = this;
	}

	private void Update()
	{
		if (pointingAt == null)
		{
			contents.SetActive(value: false);
			line.enabled = false;
			return;
		}
		Transform transform = ((GameController.instance.player != null) ? GameController.instance.player.trackers.transforms[0] : GameController.instance.noPlayer.activeRig.trackers[0].transform);
		base.transform.position = Vector3.Lerp(transform.position, pointingAt.position - pointingAt.right * 0.3f + pointingAt.up * 0.2f, 0.75f);
		base.transform.LookAt(transform.position);
		line.SetPosition(0, base.transform.position);
		line.SetPosition(1, pointingAt.position);
		line.enabled = true;
		info.text = displayText;
		contents.SetActive(value: true);
	}
}
public class FloatingText : MonoBehaviour
{
	public float floatUpSpeed = 0.1f;

	public float displayTime = 2f;

	public TextMeshProUGUI txt;

	public Vector3 anchorPos;

	public Vector3 moved;

	public Vector3 moveVelocity;

	public float forwardSpeed = 0.5f;

	public Transform attachTo;

	private Vector3 origPos;

	private Color color;

	private float alpha = 1f;

	private void Start()
	{
		anchorPos = base.transform.position;
		moveVelocity = -base.transform.forward * forwardSpeed;
		if (attachTo != null)
		{
			origPos = attachTo.position;
		}
	}

	private void Update()
	{
		moved += moveVelocity * Time.deltaTime;
		moveVelocity = new Vector3(Mathf.MoveTowards(moveVelocity.x, 0f, Time.deltaTime), Mathf.MoveTowards(moveVelocity.y, floatUpSpeed, Time.deltaTime), Mathf.MoveTowards(moveVelocity.z, 0f, Time.deltaTime));
		Vector3 vector = Vector3.zero;
		if (attachTo != null)
		{
			vector = attachTo.position - origPos;
		}
		base.transform.position = anchorPos + moved + vector;
		Vector3 forward = base.transform.position - Camera.main.transform.position;
		forward.y = 0f;
		Quaternion rotation = Quaternion.LookRotation(forward);
		base.transform.rotation = rotation;
		if (displayTime > 0f)
		{
			displayTime -= Time.deltaTime;
			color = txt.color;
		}
		else if (alpha <= 0f)
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
		else
		{
			alpha -= Time.deltaTime;
			txt.color = Color.Lerp(Color.clear, color, alpha);
		}
	}
}
public class FloatingTextNew : MonoBehaviour
{
	public float displayTime = 2f;

	public TextMeshProUGUI txt;

	public Vector3 moveVelocity;

	public float startSpeed = 0.1f;

	public float maxMoveSpeed = 1.5f;

	public float viewInFront = 1.5f;

	public GameObject attachTo;

	private Vector3 origPos;

	private Color color;

	private float alpha = 1f;

	public float moveUp;

	private bool isAttached;

	private void Start()
	{
		moveVelocity = -base.transform.forward * startSpeed;
		isAttached = attachTo != null;
	}

	private void Update()
	{
		if (isAttached && (attachTo == null || !attachTo.activeInHierarchy))
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
		else if (!(Camera.main == null))
		{
			base.transform.position += moveVelocity * Time.deltaTime;
			Vector3 vector = Camera.main.transform.position + Camera.main.transform.forward * viewInFront + Vector3.up * moveUp;
			if (Physics.Raycast(new Ray(Camera.main.transform.position, Camera.main.transform.forward), out var hitInfo, viewInFront))
			{
				vector = Camera.main.transform.position + Camera.main.transform.forward * (hitInfo.distance - 0.05f);
			}
			Vector3 vector2 = vector - base.transform.position;
			moveVelocity = vector2 * maxMoveSpeed;
			vector2 = base.transform.position - Camera.main.transform.position;
			vector2.y = 0f;
			Quaternion rotation = Quaternion.LookRotation(vector2);
			base.transform.rotation = rotation;
			if (displayTime > 0f)
			{
				displayTime -= Time.deltaTime;
				color = txt.color;
			}
			else if (alpha <= 0f)
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
			else
			{
				alpha -= Time.deltaTime;
				txt.color = Color.Lerp(Color.clear, color, alpha);
			}
		}
	}
}
public class FloorController : MonoBehaviour
{
	public FootstepController.Surface surface;

	public bool hasCreaks;

	public bool outOfBounds;

	public ChamberController chamber;

	private void Start()
	{
		chamber = base.transform.GetComponentInParent<ChamberController>();
		if (GetComponent<Collider>() == null)
		{
			UnityEngine.Debug.LogError("Floor has no collider: " + base.name);
		}
	}

	public void chamberStep()
	{
		if (!(chamber == null))
		{
			_ = ChambersController.instance.playerInChamber;
			_ = chamber.id;
			ChambersController.instance.playerInChamber = chamber.id;
		}
	}
}
public class FolloMainCamera : MonoBehaviour
{
	public Vector3 offset;

	private void Start()
	{
	}

	private void Update()
	{
		if (!(Camera.main == null))
		{
			base.transform.position = Camera.main.transform.position + offset;
		}
	}
}
public class FollowMainCamera : MonoBehaviour
{
	public Vector3 offset;

	public bool ignoreHeight;

	private void Start()
	{
		offset = base.transform.position;
	}

	private void Update()
	{
		Vector3 vector = ((Camera.main == null) ? Vector3.zero : Camera.main.transform.position);
		if (ignoreHeight)
		{
			vector.y = 0f;
		}
		base.transform.position = vector + offset;
	}
}
public class FollowTransform : MonoBehaviour
{
	public Transform follow;

	private void Start()
	{
	}

	private void Update()
	{
		base.transform.position = follow.position;
		base.transform.localRotation = follow.rotation;
	}
}
public class FootstepController : MonoBehaviour
{
	public enum Surface
	{
		Concrete,
		Carpet,
		Wood,
		Grass,
		Leaf,
		Wet,
		Snow
	}

	private AudioSource audioSource;

	public CharacterMover mover;

	public AudioClip[] concrete;

	public AudioClip[] carpet;

	public AudioClip[] wood;

	public AudioClip[] grass;

	public AudioClip[] leaf;

	public AudioClip[] wet;

	public AudioClip[] snow;

	public AudioClip[] floorboardCreak;

	public AudioClip jumpSound;

	public AudioClip landSound;

	private static int rnd;

	private float lastStepTime;

	private Vector3 lastStepPos;

	public float minTime = 0.25f;

	public float minMagnitude = 0.2f;

	public float volumeVarianceBySpeed = 0.5f;

	public float volumeVarianceRandom = 0.1f;

	public float pitchVarianceRandom = 0.1f;

	private float lastCreak;

	private void Start()
	{
		audioSource = GetComponent<AudioSource>();
		lastStepTime = Time.time;
		lastCreak = Time.time;
	}

	private AudioClip[] getSurfaceSounds(FloorController floor)
	{
		if (floor == null)
		{
			return concrete;
		}
		return floor.surface switch
		{
			Surface.Carpet => carpet, 
			Surface.Concrete => concrete, 
			Surface.Wet => wet, 
			Surface.Wood => carpet, 
			Surface.Grass => grass, 
			Surface.Leaf => leaf, 
			Surface.Snow => snow, 
			_ => concrete, 
		};
	}

	private void creak()
	{
		AudioClip[] array = floorboardCreak;
		int num = UnityEngine.Random.Range(0, array.Length);
		audioSource.PlayOneShot(array[num]);
	}

	public void playJumpSound(bool start)
	{
		audioSource.PlayOneShot(start ? jumpSound : landSound);
	}

	public void footstepSound(bool isPlayer)
	{
		if (Time.time - lastStepTime < minTime || (base.transform.position - lastStepPos).magnitude < minMagnitude)
		{
			return;
		}
		Ray ray = new Ray(base.transform.position + Vector3.up * 0.5f, -Vector3.up);
		FloorController floorController = null;
		if (Physics.Raycast(ray, out var hitInfo, 2f))
		{
			floorController = hitInfo.collider.GetComponent<FloorController>();
			if (isPlayer && floorController != null)
			{
				floorController.chamberStep();
			}
		}
		AudioClip[] surfaceSounds = getSurfaceSounds(floorController);
		lastStepTime = Time.time;
		lastStepPos = base.transform.position;
		int num = UnityEngine.Random.Range(0, surfaceSounds.Length);
		if (rnd == num)
		{
			num = UnityEngine.Random.Range(0, surfaceSounds.Length);
		}
		if (rnd == num)
		{
			num = UnityEngine.Random.Range(0, surfaceSounds.Length);
		}
		if (rnd == num)
		{
			num = UnityEngine.Random.Range(0, surfaceSounds.Length);
		}
		rnd = num;
		audioSource.volume = Mathf.Lerp(1f - volumeVarianceBySpeed, 1f, mover.velocity.magnitude / 1f) - UnityEngine.Random.value * volumeVarianceRandom;
		audioSource.pitch = 1f + pitchVarianceRandom * (UnityEngine.Random.value * 2f - 1f);
		audioSource.PlayOneShot(surfaceSounds[rnd]);
		if (floorController != null && floorController.hasCreaks && Time.time > lastCreak + 0.5f && UnityEngine.Random.value < 0.25f)
		{
			Invoke("creak", 0.25f);
		}
	}
}
public class GameCharacter : MonoBehaviour
{
	public int id;

	public int team;

	public int standingIndex;

	public int fightingStyle = -1;

	public SpecialMoveData specialMove;

	public SpecialMoveData doingSpecialData;

	public CharacterData data;

	[Range(0f, 1f)]
	public float difficulty;

	private float wasDifficulty = -1f;

	public List<CharacterEffect> effects;

	public MoveWithController playerController;

	public AIController aiControl;

	public RigidBodies rigidBodies;

	public KickController kickController;

	public HandPositions hands;

	public GameCharacter closestEnemy;

	public GameCharacter targetEnemy;

	public VRTrackerContainer trackers;

	public int maxLives = 3;

	public int lives = 3;

	public int puppetId;

	public Vector3 standPosition;

	public FaceHitEffect faceHit;

	public float doingSpecial;

	public float pinWeight;

	public GameObject handForwardPrefab;

	private float nextTargetTime;

	public HeadRecoil headRecoil;

	public AudioClip specialMoveFailSound;

	public AudioClip specialMoveFailHitSound;

	public CharacterMover mover;

	public HandMeterController rightHandMeterPrefab;

	public HandMeterController leftHandMeterPrefab;

	public RuntimeAnimatorController animatorController;

	public PressurePointData[] pressurePoints;

	public Transform effectParticleContainer;

	public DynamicTracker[] dynamicTrackers;

	public float damageAutobalance;

	public float comboDamage;

	public int comboCount;

	private float comboTimer;

	private Vector3 comboPosition;

	private bool switchSpecial;

	public VRCharacterController vrCharacterController;

	private float nextStyleSwitch;

	public bool specialRechargeAllowed;

	public float sicknessAmount;

	public HandPosition.Position override_l_handPosition;

	public HandPosition.Position override_r_handPosition;

	public AudioClip overrideSwipeSound;

	public MinMax muscleSpring;

	private float[] sidePins;

	public void setup(int id, int team, CharacterData characterData)
	{
		pressurePoints = GameData.instance.pressurePoints;
		sidePins = new float[2];
		if (characterData != data)
		{
			data = characterData;
			UnityEngine.Debug.Log("Setup: " + characterData.name);
			this.team = team;
			UnityEngine.Object.Destroy(rigidBodies.gameObject);
			rigidBodies = UnityEngine.Object.Instantiate(characterData.puppet, base.transform);
			rigidBodies.character = this;
			rigidBodies.rb = GetComponent<Rigidbody>();
			rigidBodies.transform.localScale = Vector3.one * 1.1f;
			rigidBodies.transform.localPosition = Vector3.zero;
			hands = GetComponent<HandPositions>();
			hands.setup(rigidBodies, rigidBodies.GetComponentInChildren<PuppetMaster>(), characterData);
			rigidBodies.setIK(hands, playerController.scaledTrackers);
			kickController.ik = rigidBodies.ik;
			kickController.gameCharacter = this;
			this.id = id;
			fightingStyle = data.getFightingStyleID();
			int num = 0;
			if (data.specialMoveName == "All")
			{
				specialMove = GameController.instance.gameData.randomSpecialMove(isPlayer());
			}
			else
			{
				int num2 = ((data.getSpecialMoveID() == -1) ? num : data.getSpecialMoveID());
				specialMove = GameController.instance.gameData.specialMoves[num2];
			}
			if (fightingStyle == -1)
			{
				randomFightingStyle();
			}
			if (!isPlayer())
			{
				aiControl.reset();
			}
		}
		damageAutobalance = 1f;
		playerController.gameObject.SetActive(isPlayer());
		aiControl.gameObject.SetActive(!isPlayer());
		rigidBodies.setupLayers(isPlayer());
		vrCharacterController.ik = rigidBodies.ik;
		if (isPlayer())
		{
			playerController.refreshScale();
		}
	}

	public bool kickingMove()
	{
		if (doingSpecialData.kickMove && doingSpecial > 0f)
		{
			return true;
		}
		foreach (CharacterEffect effect in effects)
		{
			if (effect != null && effect.effectData != null && effect.effectData.kickEffect())
			{
				return true;
			}
		}
		return false;
	}

	public void teleport(Vector3 to)
	{
		rigidBodies.ik.solver.locomotion.weight = 0f;
		base.transform.position = to;
	}

	public void toggleIndicators(bool on)
	{
		trackers.debug = on;
		mover.debug = on;
		rigidBodies.hands.l_offset.showLine = on;
		rigidBodies.hands.r_offset.showLine = on;
	}

	public void randomFightingStyle()
	{
		if (Time.time < nextStyleSwitch)
		{
			return;
		}
		for (int i = 0; i < 100; i++)
		{
			fightingStyle = UnityEngine.Random.Range(0, MoveRecorder.instance.actions.fightingStyles.Count);
			if (aiControl.fightingStyle().randomAllowed())
			{
				break;
			}
		}
		nextStyleSwitch = Time.time + 10f;
	}

	public float getDamageAutoBalance()
	{
		if (isPlayer())
		{
			damageAutobalance = 1f;
			return damageAutobalance;
		}
		if (GameController.instance.teamLives(targetEnemy.team) > GameController.instance.teamLives(team))
		{
			damageAutobalance = 1f;
			return damageAutobalance;
		}
		float value = targetEnemy.rigidBodies.standUpPerc / rigidBodies.standUpPerc;
		value = Mathf.Clamp01(value);
		damageAutobalance = Mathf.Max(GameController.instance.difficultyLevel.damageAutobalance.lerp(difficulty), value);
		return damageAutobalance;
	}

	public void addToCombo(float damage, Vector3 position)
	{
		if (isPlayer())
		{
			comboCount++;
			comboDamage += damage;
			comboTimer = Settings.instance.comboTimer;
			comboPosition = position;
		}
	}

	private void endCombo()
	{
		if (!isPlayer())
		{
			return;
		}
		if (comboCount > 1)
		{
			string text = LocalisationController.replaceText("General", "[x]x Combo:", comboCount.ToString()) + " " + Mathf.Round(comboDamage * 100f) + "%";
			CanvasController.addText(localise: false, text, comboPosition, Color.white, 2f, playerController.scaledTrackers[0]);
			if (comboCount >= 15)
			{
				AchievementsController.achievement("Mega Combo");
			}
			Saving.instance.maxStat("Longest Combo", comboCount, onlyInFight: true, isInt: true);
		}
		comboDamage = 0f;
		comboCount = 0;
	}

	public void reset()
	{
		rigidBodies.specialPerc = (Settings.instance.startWithSpecials ? 1f : 0f);
		lives = maxLives;
		rigidBodies.standUpPerc = (rigidBodies.standUpPercMax = rigidBodies.maxHealth);
		rigidBodies.recoveries = 2;
		if (data.hasPerk("Third Chance"))
		{
			rigidBodies.recoveries++;
		}
		if (data.hasPerk("No Second Chance"))
		{
			rigidBodies.recoveries = 0;
		}
	}

	public void clearEffects()
	{
		foreach (CharacterEffect effect in effects)
		{
			effect.amount = 0f;
		}
		updateEffects();
	}

	public void removeEffect(CharacterEffect.Effect effect)
	{
		foreach (CharacterEffect effect2 in effects)
		{
			if (effect2.effect == effect)
			{
				effect2.amount = 0f;
			}
		}
		updateEffects();
	}

	public bool hasVisibleEffect()
	{
		foreach (CharacterEffect effect in effects)
		{
			if (effect.effectData != null && effect.effectData.icon != null && effect.perc < 1f)
			{
				return true;
			}
		}
		return false;
	}

	public bool hasEffect(CharacterEffect.Effect effect)
	{
		return getEffect(effect) != null;
	}

	public CharacterEffect getEffect(CharacterEffect.Effect effect)
	{
		foreach (CharacterEffect effect2 in effects)
		{
			if (effect2.effect == effect)
			{
				return effect2;
			}
		}
		return null;
	}

	public void knockedOutEarly()
	{
		if (isPlayer())
		{
			playerController.outOfBody(inBody: false);
		}
	}

	public void knockedOutFall()
	{
		if (GameController.instance.gameMode != 0 && !Settings.instance.infiniteLives)
		{
			lives--;
		}
		if (GameController.instance.specialMode.singleRound)
		{
			GameController.instance.specialModeScore++;
		}
		if (data.id == 39 && GameController.instance.specialMode.singleRound && !Saving.instance.savedProgress.hasCustomUnlock("Kurayami"))
		{
			GameController.instance.customUnlock = "Kurayami";
		}
		GameController.instance.checkWin();
	}

	public void backStanding()
	{
		if (isPlayer())
		{
			playerController.outOfBody(inBody: true);
		}
		else
		{
			Invoke("restartVoice", 1f);
		}
		GameController.instance.beginAgain();
	}

	public void ProjectileHitVoice()
	{
		VoiceData voice = data.voice.PhraseOfType(VoiceData.Type.AfterWeaponHit, 1f);
		rigidBodies.say(voice);
	}

	public void SpecialMoveHit(string specialMoveName)
	{
		VoiceData voiceData = data.voice.PhraseOfType(VoiceData.Type.AfterSpecialHit, 1f);
		if (voiceData != null && !(voiceData.extraParameter != specialMoveName))
		{
			rigidBodies.say(voiceData);
		}
	}

	private void restartVoice()
	{
		rigidBodies.say(data.voice.PhraseOfType(VoiceData.Type.OnRestart, 0.4f));
	}

	public void updateEffects()
	{
		if (effects.Count == 0 && switchSpecial && doingSpecial == 0f)
		{
			switchSpecial = false;
			specialMove = GameController.instance.gameData.randomSpecialMove(isPlayer());
		}
		float num = ((GameController.instance.specialMode.name == "Stamina") ? 0.2f : 1f);
		foreach (CharacterEffect effect in effects)
		{
			if (effect.effect == CharacterEffect.Effect.SpeedHands || effect.effect == CharacterEffect.Effect.SpeedKick)
			{
				if (effect.slowMo != null && effect.slowMo.finished())
				{
					effect.amount = 0f;
				}
			}
			else if (effect.timeReduce || targetEnemy == null)
			{
				effect.amount -= Time.deltaTime;
				if (effect.effect == CharacterEffect.Effect.Pain && rigidBodies.standUpPercMax > 0.01f)
				{
					if (PracticeMoveController.isActive(-1))
					{
						rigidBodies.standUpPerc -= Time.deltaTime / 10f * num;
						if (rigidBodies.standUpPercMax < 0.01f)
						{
							rigidBodies.standUpPercMax = 0.01f;
						}
						rigidBodies.hitRecovery = 0.5f;
					}
					else
					{
						if (isPlayer())
						{
							AchievementsController.instance.perfect = false;
						}
						rigidBodies.standUpPercMax -= Time.deltaTime / 10f * num;
						if (rigidBodies.standUpPercMax < 0.01f)
						{
							rigidBodies.standUpPercMax = 0.01f * num;
						}
						if (rigidBodies.standUpPerc > rigidBodies.standUpPercMax)
						{
							rigidBodies.standUpPerc = rigidBodies.standUpPercMax;
						}
					}
				}
			}
			if (!(effect.amount <= 0f))
			{
				continue;
			}
			if (effect.visualEffect != null)
			{
				effect.visualEffect.GetComponent<SpecialMoveAttachedEffect>()?.end();
				effect.visualEffect = null;
			}
			if (effect.effectData != null)
			{
				if (effect.effectData.endSound != null)
				{
					GeneralSounds.playSound(effect.effectData.endSound);
				}
				if (effect.effectData.onEndEffect != null)
				{
					SpecialMoveAttachedEffect specialMoveAttachedEffect = UnityEngine.Object.Instantiate(effect.effectData.onEndEffect, standPosition, Quaternion.identity, null);
					specialMoveAttachedEffect.setup(this);
					UnityEngine.Object.Destroy(specialMoveAttachedEffect, 5f);
				}
			}
			effects.Remove(effect);
			refreshMaterials();
			break;
		}
	}

	public void addEffect(Vector3 hitPoint, SpecialMoveData specialMove, bool preventSpecialCharge, bool isTest)
	{
		addEffect(hitPoint, specialMove.addEffect, specialMove.effectDuration, preventSpecialCharge, isTest, specialMove.l_handPosition, specialMove.r_handPosition);
	}

	public float kickSpeedMod()
	{
		float num = Time.timeScale * Time.timeScale;
		if (hasEffect(CharacterEffect.Effect.SpeedKick))
		{
			num = 1f / Time.timeScale;
		}
		if (hasEffect(CharacterEffect.Effect.Paralysed))
		{
			CharacterEffect effect = getEffect(CharacterEffect.Effect.Paralysed);
			num = 1f - Mathf.Clamp01(effect.amount / 2f);
		}
		if (hasEffect(CharacterEffect.Effect.Slowness))
		{
			num /= 2f;
		}
		if (hasEffect(CharacterEffect.Effect.Sickness))
		{
			num /= 1.5f;
		}
		return num;
	}

	public float moveSpeedMod()
	{
		float num = Time.timeScale * Time.timeScale;
		if (hasEffect(CharacterEffect.Effect.SpeedHands) || hasEffect(CharacterEffect.Effect.InterceptingFist))
		{
			num = 1f / Time.timeScale;
		}
		if (hasEffect(CharacterEffect.Effect.Paralysed))
		{
			CharacterEffect effect = getEffect(CharacterEffect.Effect.Paralysed);
			num = 1f - Mathf.Clamp01(effect.amount / 2f);
		}
		if (hasEffect(CharacterEffect.Effect.Slowness))
		{
			num /= 10f;
		}
		if (hasEffect(CharacterEffect.Effect.ShadowBoxing))
		{
			CharacterEffect effect2 = getEffect(CharacterEffect.Effect.ShadowBoxing);
			num = 1f - Mathf.Clamp01(effect2.amount / 1f);
		}
		float num2 = 1f + (float)OptionData.getInt("AI Speed") * 0.1f;
		return num * num2;
	}

	public float walkSpeedMod()
	{
		float num = 1f;
		if (hasEffect(CharacterEffect.Effect.CantWalk))
		{
			num *= 1f - getEffect(CharacterEffect.Effect.CantWalk).edgePerc(5f, start: false, end: true);
		}
		if (hasEffect(CharacterEffect.Effect.QuickWalk))
		{
			num *= 2f;
		}
		if (hasEffect(CharacterEffect.Effect.SlowWalk))
		{
			num /= 2f;
		}
		if (hasEffect(CharacterEffect.Effect.Slowness))
		{
			num /= 3f;
		}
		if (hasEffect(CharacterEffect.Effect.Sickness))
		{
			num /= 2f;
		}
		num *= data.perkMod("Fast Mover", data.name);
		return num * data.perkMod("Slow Walker", data.name);
	}

	public void addEffect(Vector3 addPoint, CharacterEffect.Effect effect, float amount, bool preventSpecialRecharge, bool isTest, HandPosition.Position l_handPosition = HandPosition.Position.None, HandPosition.Position r_handPosition = HandPosition.Position.None)
	{
		if (effect == CharacterEffect.Effect.None)
		{
			return;
		}
		if (GameController.instance.fightState != GameController.FightState.During && preventSpecialRecharge)
		{
			isTest = true;
		}
		CharacterEffect characterEffect = getEffect(effect);
		if (characterEffect == null)
		{
			characterEffect = new CharacterEffect(addPoint, effect, isTest ? 5f : amount, isTest);
			characterEffect.preventSpecialCharge = preventSpecialRecharge;
			characterEffect.l_handPosition = l_handPosition;
			characterEffect.r_handPosition = r_handPosition;
			effects.Add(characterEffect);
		}
		else
		{
			characterEffect.amount += amount;
			if (characterEffect.amount < 1f)
			{
				characterEffect.amount = 1f;
			}
		}
		if (characterEffect.effectData != null)
		{
			if (characterEffect.effectData.startSound != null)
			{
				GeneralSounds.playSound(characterEffect.effectData.startSound);
			}
			if (characterEffect.effectData.effect == CharacterEffect.Effect.IronFists && rigidBodies.ironFistSkin != null)
			{
				characterEffect.effectData.material = rigidBodies.ironFistSkin;
			}
			characterEffect.slowMo = characterEffect.effectData.timeSlow.doIt();
			if (characterEffect.visualEffect == null && characterEffect.effectData.onStartEffect != null)
			{
				characterEffect.visualEffect = UnityEngine.Object.Instantiate(characterEffect.effectData.onStartEffect, standPosition, Quaternion.identity, null);
				characterEffect.visualEffect.GetComponent<SpecialMoveAttachedEffect>()?.setup(this);
			}
		}
		refreshMaterials();
	}

	private void refreshMaterials()
	{
		foreach (CharacterEffect effect in effects)
		{
			if (effect.effectData != null && effect.effectData.material != null)
			{
				rigidBodies.setSkin(effect.effectData.material);
				return;
			}
		}
		rigidBodies.setSkin(rigidBodies.defaultSkinMaterial);
	}

	public void doSpecial()
	{
		if (doingSpecial > 0f)
		{
			return;
		}
		if (specialMove.timeSlowMode == SpecialMoveData.TimeSlowMode.OnActivate && (GameController.instance.teamCounts[team] <= 1 || data.amount <= 2))
		{
			specialMove.timeSlow.doIt();
		}
		if (Settings.instance.moveVoices && OptionData.getBool("Voices"))
		{
			rigidBodies.say(specialMove.voice, halfSpacial: false, specialMove.voiceText);
		}
		GeneralSounds.playSound(specialMove.sound);
		if (data.specialMoveName == "All")
		{
			switchSpecial = true;
		}
		if (specialMove.moveType == SpecialMoveData.Type.NoHands && specialMove.prefab == null)
		{
			addEffect(rigidBodies.head.position + rigidBodies.head.forward * 0.5f, specialMove, preventSpecialCharge: true, isTest: false);
			doingSpecial = 0f;
			PoseDisplay.instance.instruction.showFinished(this, specialMove.shortInstruction);
		}
		else
		{
			doingSpecial = 15f;
			PoseDisplay.instance.instruction.show(this);
		}
		doingSpecialData = specialMove;
		if (specialMove.prefab != null)
		{
			switch (specialMove.moveType)
			{
			case SpecialMoveData.Type.RightHand:
				specialMove.addToHand(this, hands.rightHand, rigidBodies.rightHand);
				break;
			case SpecialMoveData.Type.LeftHand:
				specialMove.addToHand(this, hands.leftHand, rigidBodies.leftHand);
				break;
			case SpecialMoveData.Type.BothHands:
			{
				SpecialMoveController specialMoveController3 = specialMove.addToHand(this, hands.rightHand, rigidBodies.rightHand);
				SpecialMoveController specialMoveController4 = (specialMoveController3.other = specialMove.addToHand(this, hands.leftHand, rigidBodies.leftHand));
				specialMoveController4.other = specialMoveController3;
				specialMoveController4.disableSounds = true;
				break;
			}
			case SpecialMoveData.Type.BothFeet:
			{
				SpecialMoveController specialMoveController = specialMove.addToHand(this, rigidBodies.leftFoot.transform, rigidBodies.leftFoot);
				SpecialMoveController specialMoveController2 = (specialMoveController.other = specialMove.addToHand(this, rigidBodies.rightFoot.transform, rigidBodies.rightFoot));
				specialMoveController2.other = specialMoveController;
				specialMoveController2.disableSounds = true;
				break;
			}
			case SpecialMoveData.Type.Mouth:
				specialMove.addToHand(this, rigidBodies.face.transform, rigidBodies.headHittable);
				rigidBodies.face.openMouthTimer = 3f;
				aiControl.headTurnTimer = 4f;
				break;
			}
		}
		rigidBodies.specialPerc = 0f;
	}

	public bool isPlayer()
	{
		return this == GameController.instance.player;
	}

	public void setDifficulty(float newDiff)
	{
		wasDifficulty = newDiff;
		rigidBodies.pm.pinWeight = Settings.instance.pinWeight;
		if (isPlayer())
		{
			pinWeight = Settings.instance.playerMuscleWeight;
		}
		else
		{
			pinWeight = GameController.instance.difficultyLevel.enemyMuscleWeight.lerp(newDiff);
		}
		rigidBodies.pm.SetMuscleWeights(Muscle.Group.Arm, 0.1f, pinWeight);
		rigidBodies.pm.muscleSpring = muscleSpring.max;
		base.name = rigidBodies.character.data.name + " Diff: " + newDiff;
	}

	public void refreshPowers()
	{
		specialRechargeAllowed = true;
		if (!rigidBodies.isDown(allTheWay: false) && !hasEffect(CharacterEffect.Effect.Stunned))
		{
			float num = (isPlayer() ? muscleSpring.max : (GameController.instance.difficultyLevel.enemyMuscleWeight.lerp(difficulty) * muscleSpring.max));
			rigidBodies.pm.muscleSpring = Mathf.MoveTowards(rigidBodies.pm.muscleSpring, num, num * Time.deltaTime);
			float num2 = (isPlayer() ? Settings.instance.playerMuscleWeight : (GameController.instance.difficultyLevel.enemyMuscleWeight.lerp(difficulty) * GameController.instance.difficultyLevel.enemyMuscleWeight.lerp(difficulty)));
			if (closestEnemy == null)
			{
				pinWeight = 1f;
			}
			else
			{
				if (isPlayer())
				{
					pinWeight = Settings.instance.playerMuscleWeight;
				}
				else
				{
					pinWeight = GameController.instance.difficultyLevel.enemyMuscleWeight.lerp(difficulty);
				}
				float t = ((closestEnemy.standPosition - standPosition).magnitude - 1.5f) / 2.5f;
				if (rigidBodies.armCollisions[0] == 0 && rigidBodies.armCollisions[1] == 0)
				{
					t = 1f;
				}
				pinWeight = Mathf.Lerp(pinWeight, 1f, t);
			}
			if (hasEffect(CharacterEffect.Effect.Strength))
			{
				pinWeight = Mathf.Clamp01(pinWeight * 3f);
				num2 *= 3f;
			}
			pinWeight *= Mathf.Clamp01(1f - headRecoil.recoilPerc() * 2f);
			rigidBodies.pm.SetMuscleWeights(Muscle.Group.Arm, num2, pinWeight);
			rigidBodies.pm.SetMuscleWeights(Muscle.Group.Hand, num2, pinWeight);
			for (int i = 0; i < 2; i++)
			{
				sidePins[i] = Mathf.MoveTowards(sidePins[i], (!rigidBodies.notTouching(i == 0)) ? 1 : 0, Time.deltaTime * 4f * num2);
			}
			Muscle[] muscles = rigidBodies.pm.muscles;
			foreach (Muscle muscle in muscles)
			{
				if (muscle.props.group != Muscle.Group.Arm && muscle.props.group != Muscle.Group.Hand)
				{
					continue;
				}
				int num3 = ((!muscle.name.Contains(".L") && !muscle.name.Contains("_l")) ? 1 : 0);
				if (num3 != 0)
				{
					_ = rigidBodies.hands.r_offset.offsetPerc;
				}
				else
				{
					_ = rigidBodies.hands.l_offset.offsetPerc;
				}
				float num4 = 5000f;
				float angularDrag;
				if (sidePins[num3] > 0f)
				{
					Rigidbody rigidbody = muscle.rigidbody;
					angularDrag = (muscle.rigidbody.drag = num4);
					rigidbody.angularDrag = angularDrag;
					muscle.props.pinWeight = 0f;
				}
				else
				{
					muscle.props.pinWeight *= 0f + (1f - sidePins[num3]) * 1f;
					Rigidbody rigidbody2 = muscle.rigidbody;
					angularDrag = (muscle.rigidbody.drag = Mathf.MoveTowards(muscle.rigidbody.drag, 0f, Time.deltaTime * num4));
					rigidbody2.angularDrag = angularDrag;
				}
				float num7 = 0.05f;
				Rigidbody rigidbody3 = muscle.rigidbody;
				angularDrag = (muscle.rigidbody.drag = Mathf.Lerp(muscle.rigidbody.drag, (sidePins[num3] > 0f) ? num4 : 0f, Time.deltaTime * num4 * num7));
				rigidbody3.angularDrag = angularDrag;
				if ((hasEffect(CharacterEffect.Effect.L_ArmNumb) && num3 == 0) || (hasEffect(CharacterEffect.Effect.R_ArmNumb) && num3 == 1) || hasEffect(CharacterEffect.Effect.Weakness))
				{
					muscle.props.pinWeight = 0f;
					float num9 = num / muscleSpring.max;
					muscle.props.muscleWeight *= 0.005f / num9 / num9;
					muscle.rigidbody.angularDrag = 25f;
					muscle.rigidbody.drag = 1f;
				}
				else if (hasEffect(CharacterEffect.Effect.Strength))
				{
					muscle.props.pinWeight = 1f;
					muscle.props.muscleWeight = 1f;
					Rigidbody rigidbody4 = muscle.rigidbody;
					angularDrag = (muscle.rigidbody.drag = 0f);
					rigidbody4.angularDrag = angularDrag;
				}
				if ((hasEffect(CharacterEffect.Effect.L_ArmDisabled) && num3 == 0) || (hasEffect(CharacterEffect.Effect.R_ArmDisabled) && num3 == 1))
				{
					muscle.rigidbody.angularDrag = 5f;
					muscle.rigidbody.drag = 1f;
				}
				if (rigidBodies.grabbed[num3])
				{
					muscle.props.pinWeight = 0f;
					muscle.props.muscleWeight *= 0.002f;
					Rigidbody rigidbody5 = muscle.rigidbody;
					angularDrag = (muscle.rigidbody.drag = 500f);
					rigidbody5.angularDrag = angularDrag;
					Vector3 target = GameController.flatVector(rigidBodies.head.transform.position - rigidBodies.ik.solver.spine.headTarget.position) * 3f;
					if (target.magnitude > rigidBodies.slide.magnitude)
					{
						rigidBodies.slide = Vector3.MoveTowards(rigidBodies.slide, target, Time.deltaTime);
					}
				}
				else if (rigidBodies.grabbing[num3])
				{
					muscle.props.pinWeight = 1f;
					muscle.props.muscleWeight = 1f;
					Rigidbody rigidbody6 = muscle.rigidbody;
					angularDrag = (muscle.rigidbody.drag = 500f);
					rigidbody6.angularDrag = angularDrag;
				}
			}
			float num13 = ((rigidBodies.grabbed[0] || rigidBodies.grabbed[1]) ? 0.025f : 1f);
			rigidBodies.pm.SetMuscleWeights(Muscle.Group.Spine, num13, num13);
			float num14 = num / muscleSpring.max;
			if (rigidBodies.headHittable.rigidBody != null)
			{
				if (headRecoil.wobbleTimer == 0f)
				{
					headRecoil.wobblePin = Mathf.MoveTowards(headRecoil.wobblePin, 1f, Time.deltaTime / 5f);
					headRecoil.wobbleMuscle = Mathf.MoveTowards(headRecoil.wobbleMuscle, 1f, Time.deltaTime / 5f);
					rigidBodies.pm.SetMuscleWeights(Muscle.Group.Head, headRecoil.wobblePin, headRecoil.wobbleMuscle);
					Rigidbody rigidBody = rigidBodies.headHittable.rigidBody;
					float angularDrag = (rigidBodies.headHittable.rigidBody.angularDrag = Mathf.MoveTowards(rigidBodies.headHittable.rigidBody.drag, 0f, Time.deltaTime * 6f));
					rigidBody.drag = angularDrag;
				}
				else
				{
					headRecoil.wobblePin = Mathf.Lerp(0.001f, 5E-05f, Mathf.Clamp01(headRecoil.wobbleTimer)) / num14;
					headRecoil.wobbleMuscle = num13 * Mathf.Clamp01(1f - headRecoil.wobbleTimer) * (1f - headRecoil.wobbleTimer);
					rigidBodies.pm.SetMuscleWeights(Muscle.Group.Head, headRecoil.wobblePin, headRecoil.wobbleMuscle);
					Rigidbody rigidBody2 = rigidBodies.headHittable.rigidBody;
					float angularDrag = (rigidBodies.headHittable.rigidBody.angularDrag = 30f);
					rigidBody2.drag = angularDrag;
				}
			}
		}
		else
		{
			pinWeight = Mathf.MoveTowards(pinWeight, 0f, Time.deltaTime);
			rigidBodies.pm.SetMuscleWeights(Muscle.Group.Spine, 0.05f, pinWeight);
			rigidBodies.pm.SetMuscleWeights(Muscle.Group.Head, 1f);
			float angularDrag;
			if (rigidBodies.headHittable.rigidBody != null)
			{
				Rigidbody rigidBody3 = rigidBodies.headHittable.rigidBody;
				angularDrag = (rigidBodies.headHittable.rigidBody.angularDrag = 0f);
				rigidBody3.drag = angularDrag;
			}
			rigidBodies.pm.SetMuscleWeights(Muscle.Group.Arm, 0.05f, pinWeight);
			rigidBodies.pm.SetMuscleWeights(Muscle.Group.Hand, 0.05f, pinWeight);
			rigidBodies.pm.muscleSpring = Mathf.MoveTowards(rigidBodies.pm.muscleSpring, muscleSpring.min, (muscleSpring.max - muscleSpring.min) * Time.deltaTime * 2f);
			Rigidbody rigidBody4 = rigidBodies.headHittable.rigidBody;
			angularDrag = (rigidBodies.headHittable.rigidBody.angularDrag = 0f);
			rigidBody4.drag = angularDrag;
			Muscle[] muscles = rigidBodies.pm.muscles;
			foreach (Muscle muscle2 in muscles)
			{
				if (muscle2.props.group == Muscle.Group.Arm || muscle2.props.group == Muscle.Group.Hand)
				{
					muscle2.rigidbody.drag = 0f;
				}
			}
		}
		if (headRecoil.wobbleTimer == 0f)
		{
			headRecoil.wobblePin = Mathf.MoveTowards(headRecoil.wobblePin, 1f, Time.deltaTime / 5f);
			headRecoil.wobbleMuscle = Mathf.MoveTowards(headRecoil.wobbleMuscle, 1f, Time.deltaTime / 5f);
		}
		bool flag = false;
		if (rigidBodies.dazed())
		{
			flag = true;
		}
		else
		{
			_ = rigidBodies.slide.magnitude;
			_ = 0.2f;
			if (hasEffect(CharacterEffect.Effect.L_ArmDisabled) || hasEffect(CharacterEffect.Effect.R_ArmDisabled) || hasEffect(CharacterEffect.Effect.Stunned))
			{
				flag = true;
			}
		}
		rigidBodies.pm.internalCollisions = flag || rigidBodies.isDown(allTheWay: false);
		rigidBodies.pm.angularLimits = rigidBodies.isDown(allTheWay: true);
		bool flag2 = false;
		overrideSwipeSound = null;
		override_l_handPosition = HandPosition.Position.None;
		override_r_handPosition = HandPosition.Position.None;
		foreach (CharacterEffect effect in effects)
		{
			effect.perc = Mathf.MoveTowards(effect.perc, 1f, Time.deltaTime);
			if (effect.preventSpecialCharge)
			{
				specialRechargeAllowed = false;
			}
			if (effect.l_handPosition != 0)
			{
				override_l_handPosition = effect.l_handPosition;
			}
			if (effect.r_handPosition != 0)
			{
				override_r_handPosition = effect.r_handPosition;
			}
			if (effect.effectData != null && effect.effectData.overrideSwipeSound != null)
			{
				overrideSwipeSound = effect.effectData.overrideSwipeSound;
			}
			switch (effect.effect)
			{
			case CharacterEffect.Effect.L_ArmDisabled:
				rigidBodies.pm.SetMuscleWeightsRecursive(HumanBodyBones.LeftUpperArm, 0f, 0f);
				break;
			case CharacterEffect.Effect.R_ArmDisabled:
				rigidBodies.pm.SetMuscleWeightsRecursive(HumanBodyBones.RightUpperArm, 0f, 0f);
				break;
			case CharacterEffect.Effect.Sickness:
				flag2 = true;
				break;
			}
		}
		sicknessAmount = Mathf.MoveTowards(sicknessAmount, flag2 ? 1 : 0, Time.deltaTime / 2f);
		if (data.weaknessName == "Right Armed")
		{
			rigidBodies.pm.SetMuscleWeightsRecursive(HumanBodyBones.LeftUpperArm, 0f, 0f);
		}
		if (data.weaknessName == "Left Armed")
		{
			rigidBodies.pm.SetMuscleWeightsRecursive(HumanBodyBones.RightUpperArm, 0f, 0f);
		}
		rigidBodies.defaultSkinMaterial.SetColor("_Mask2_Gchannel_ColorAmountA", Color.Lerp(Color.clear, Settings.instance.colour_sickness, sicknessAmount));
	}

	private void Update()
	{
		if (GameController.instance.paused || rigidBodies == null || rigidBodies.head == null)
		{
			return;
		}
		updateEffects();
		refreshPowers();
		if (comboTimer > 0f)
		{
			comboTimer -= Time.deltaTime;
			if (comboTimer <= 0f)
			{
				endCombo();
			}
		}
		standPosition = new Vector3(rigidBodies.head.position.x, base.transform.position.y, rigidBodies.head.position.z);
		closestEnemy = GameController.instance.getClosestEnemy(this);
		if (nextTargetTime > 0f)
		{
			nextTargetTime -= Time.deltaTime;
		}
		else
		{
			nextTargetTime = UnityEngine.Random.Range(1, 4);
			targetEnemy = closestEnemy;
		}
		if (difficulty != wasDifficulty)
		{
			setDifficulty(difficulty);
		}
	}
}
public class GameCharacterForPlinthController : MonoBehaviour
{
	public RigidBodies rigidBodies;

	public HandPositions hands;

	public VRTrackerContainer trackers;

	public CharacterData characterData;

	public MoveReplayer replayer;

	private bool isSetup;

	private FightingStyle fightingStyle;

	public float heightOffset = 1f;

	private void Start()
	{
		if (rigidBodies != null)
		{
			UnityEngine.Object.Destroy(rigidBodies.gameObject);
		}
	}

	public void setup(CharacterData characterData)
	{
		if (rigidBodies != null)
		{
			UnityEngine.Object.Destroy(rigidBodies.gameObject);
		}
		rigidBodies = UnityEngine.Object.Instantiate(characterData.puppet, base.transform);
		rigidBodies.setIK(hands, trackers.transforms, forPlinth: true);
		rigidBodies.setupLayers(povView: false);
		SkinnedMeshRenderer[] componentsInChildren = rigidBodies.ik.GetComponentsInChildren<SkinnedMeshRenderer>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			componentsInChildren[i].updateWhenOffscreen = false;
		}
		this.characterData = characterData;
		hands = GetComponent<HandPositions>();
		hands.setup(rigidBodies, rigidBodies.GetComponentInChildren<PuppetMaster>(), characterData);
		if (characterData.fightingStyle == -1 || characterData.fightStyleName == "All")
		{
			fightingStyle = MoveRecorder.instance.actions.fightingStyles[UnityEngine.Random.Range(0, MoveRecorder.instance.actions.fightingStyles.Count)];
		}
		else
		{
			fightingStyle = MoveRecorder.instance.actions.fightingStyles[characterData.fightingStyle];
		}
		int index = UnityEngine.Random.Range(0, fightingStyle.stances.Count);
		replayer.doAction(fightingStyle.stances[index].stance, loop: true, offsetHeight: false, 0.5f, "Plinth");
		rigidBodies.ik.solver.spine.rootHeadingOffset = fightingStyle.stances[index].stanceAngle;
		isSetup = true;
	}

	private void Update()
	{
		if (isSetup && !(replayer.transitionTo.name == ""))
		{
			MoveRecorder.instance.playback(replayer, 1f, heightOffset * characterData.heightScale, 1f, null, hands, 0f);
		}
	}
}
public class GameController : MonoBehaviour
{
	public enum FightState
	{
		Pre,
		Ready,
		During,
		Over
	}

	public enum GameMode
	{
		None,
		Normal,
		Edit,
		No_Fight,
		Chambers,
		Quick
	}

	public float fps;

	[Range(0f, 1f)]
	public float timeScale;

	public List<GameCharacter> players;

	public GameCharacter player;

	public GameCharacter characterPrefab;

	public GameData gameData;

	public int selectedLevel;

	public HUDController hud;

	public FloatingCanvasController floatingCanvas;

	public static GameController instance;

	public FightState fightState;

	public float healthDamage = 0.1f;

	public float healthRecharge = 0.1f;

	public int firstTo = 3;

	public int selectedPos = -1;

	public int characterID;

	public int costume;

	public int aiMode;

	public AIMode[] ai_Modes;

	public DifficultyLevel difficultyLevel;

	public int lowestDifficultyLevel;

	public GameMode gameMode;

	public GameModeData specialMode;

	public string customUnlock;

	public SceneController scenes;

	public KeyCode nextAIModeKey;

	public MenuController menu;

	public StandButtonsController standButtons;

	public SwooshIfFast swooshPrefab;

	public FootstepController footstepPrefab;

	private float fightOverTime;

	public AudioMixer mixer;

	public NoPlayerControl noPlayer;

	public WinLoseDisplay winLose;

	public PortraitCameraController portraitCamera;

	public bool movingAllowed;

	public CharacterData[] levelCharacters;

	public GameObject debugSphere;

	public int[] teamCounts;

	private bool initSetup;

	private bool wereAllDown;

	public bool calibrating;

	private float quitTimer;

	private float fpsTime;

	public List<ProjectileController> projectiles;

	public bool canGetUp;

	public LayerMask groundLayers;

	public bool paused;

	private bool indicatorsOn;

	public int ninjaCount;

	public float headY;

	private float specialModeTimer;

	private float specialModeDifficulty;

	public int specialModeScore;

	public int specialModeSpawnCount;

	public int specialModeSpawnCountTotal;

	public int pressurePointCount;

	public bool finalBoss;

	public bool winner;

	private int m_frameCounter;

	private float m_timeCounter;

	public float m_refreshTime = 2f;

	public float uberHitTimer;

	private void Start()
	{
		instance = this;
		gameData.setupCharacters();
		teamCounts = new int[4];
		noPlayer.gameObject.SetActive(player == null);
		levelCharacters = gameData.getLevelCharacters(LocationData.HomeLocation.ShaolinTemple);
		Saving.loadSettings();
		Saving.loadProgress();
		noPlayer.initSetup();
		GameData.instance.getCompleted();
		difficultyLevel = Settings.instance.difficultyLevels[3];
	}

	private void fpsCounter()
	{
		if (m_timeCounter < m_refreshTime)
		{
			m_timeCounter += Time.deltaTime;
			m_frameCounter++;
		}
		else
		{
			fps = (float)m_frameCounter / m_timeCounter;
			m_frameCounter = 0;
			m_timeCounter = 0f;
		}
	}

	public static Vector3 flatVector(Vector3 inVector, bool normalize = false)
	{
		if (normalize)
		{
			return new Vector3(inVector.x, 0f, inVector.z).normalized;
		}
		return new Vector3(inVector.x, 0f, inVector.z);
	}

	public void toggleIndicators()
	{
		indicatorsOn = !indicatorsOn;
		foreach (GameCharacter player in players)
		{
			player.toggleIndicators(indicatorsOn);
		}
	}

	public void unpause()
	{
		if (paused)
		{
			paused = false;
			if (player != null)
			{
				player.playerController.nextPause = Time.time + 1f;
				player.playerController.outOfBody(inBody: true);
			}
			menu.hide();
		}
	}

	public void calibrate()
	{
		quitTimer = 0f;
		calibrating = true;
	}

	public bool outOfBounds(Vector3 position)
	{
		switch (standButtons.boundsType)
		{
		case StandButtonsController.BoundsType.Circle:
			return flatVector(position).magnitude > standButtons.boundsSize;
		case StandButtonsController.BoundsType.Square:
			if (!(Mathf.Abs(position.x) > standButtons.boundsSize))
			{
				return Mathf.Abs(position.z) > standButtons.boundsSize;
			}
			return true;
		default:
			return false;
		}
	}

	public string difficultyText(float difficulty)
	{
		return Mathf.Round(difficulty * 100f) + "%";
	}

	public void setAudioMixerGroup(AudioSource audioSource, string group = "Sound Effects")
	{
		if (mixer == null)
		{
			mixer = Resources.Load("MainAudioMixer") as AudioMixer;
		}
		AudioMixerGroup[] array = mixer.FindMatchingGroups(group);
		if (array.Length == 0)
		{
			UnityEngine.Debug.LogError("Couldnt find mixer group: " + group);
		}
		else
		{
			audioSource.outputAudioMixerGroup = array[0];
		}
	}

	private void startFight()
	{
		if (fightState == FightState.Ready)
		{
			fightState = FightState.During;
			movingAllowed = true;
			AchievementsController.instance.perfect = true;
			pressurePointCount = 0;
			PressurePointData[] pressurePoints = GameData.instance.pressurePoints;
			for (int i = 0; i < pressurePoints.Length; i++)
			{
				pressurePoints[i].hitInRound = false;
			}
			if (player.targetEnemy != null)
			{
				winLose.show(LocalisationController.getText("Win/Lose", "Fight!"), player.targetEnemy.rigidBodies.head.transform, halfWay: true, fadeOut: true, 1);
				Saving.instance.incrementStat("Fights", onlyInFight: true);
			}
			resetCharacters();
			CrowdController.applause();
			standButtons.startSound();
			if (specialMode.singleRound)
			{
				player.rigidBodies.specialPerc = 1f;
			}
			getAllStandingIndeces();
			MusicController.playMusic();
		}
	}

	public void beginAgain()
	{
		if (!wereAllDown)
		{
			return;
		}
		wereAllDown = false;
		if (player != null)
		{
			winLose.show(LocalisationController.getText("Win/Lose", "Fight!"), player.targetEnemy.rigidBodies.head.transform, halfWay: true, fadeOut: true, 1);
			MusicController.playMusic();
		}
		standButtons.startSound();
		AchievementsController.instance.perfect = true;
		foreach (GameCharacter player in players)
		{
			player.clearEffects();
			if (specialMode.name == "Dragon Doubles" && player.rigidBodies.isDown(allTheWay: true))
			{
				player.rigidBodies.standUpPerc = (player.rigidBodies.standUpPercMax = player.rigidBodies.maxHealth);
			}
			if (!player.isPlayer())
			{
				player.aiControl.fightAI_keepAwayTime = UnityEngine.Random.Range(5f, 10f);
				if (player.rigidBodies.standUpPercMax < player.rigidBodies.maxHealth)
				{
					AchievementsController.instance.perfect = false;
				}
			}
		}
	}

	public void smashAction(StandPositionIndicator standPos)
	{
		string text = standPos.buttonAction;
		if (text != null && text == "Fight")
		{
			resetCharacters();
			movingAllowed = false;
		}
	}

	private void resetCharacters()
	{
		foreach (GameCharacter player in players)
		{
			player.reset();
		}
	}

	public void buttonAction(StandPositionIndicator standPos)
	{
		switch (standPos.buttonAction)
		{
		case "Fight":
		{
			aiMode = ((gameMode == GameMode.Normal || gameMode == GameMode.Quick) ? 4 : 5);
			wereAllDown = false;
			fightState = FightState.Ready;
			AchievementsController.instance.fightReset();
			if (player.targetEnemy == null)
			{
				foreach (GameCharacter player in players)
				{
					if (player.team > 0)
					{
						this.player.targetEnemy = player;
					}
				}
			}
			if (this.player.targetEnemy != null)
			{
				winLose.show(LocalisationController.getText("Win/Lose", "Ready..."), (this.player.targetEnemy == null) ? null : this.player.targetEnemy.rigidBodies.head.transform, halfWay: true, fadeOut: true, 0);
				if (Settings.instance.outOfBodyCam_start)
				{
					this.player.playerController.outOfBodyTimer = 3.5f;
				}
				if (specialMode.singleRound)
				{
					WebLogging.log("Special Mode: " + specialMode.name, "Start", 0f);
				}
				else
				{
					WebLogging.log("Fight - " + specialMode.name, this.player.data.name + " vs " + players[1].data.name + " (" + difficultyLevel.name + " - " + Mathf.Round(this.player.targetEnemy.difficulty * 100f) + ")", 0f);
				}
			}
			else
			{
				WebLogging.log("Fight - " + specialMode.name, this.player.data.name + " vs ? " + specialMode.name, 0f);
			}
			bool flag = false;
			bool speak = true;
			float num = 0f;
			foreach (GameCharacter player2 in players)
			{
				if (!player2.isPlayer())
				{
					num = player2.aiControl.taunt(speak) + 0.5f;
					speak = false;
					if (!flag && player2.data.thumbnail == null)
					{
						portraitCamera.setToFollow(player2.data, player2.rigidBodies.head.transform);
						flag = true;
					}
				}
			}
			if (num < 5f)
			{
				num = 5f;
			}
			Invoke("startFight", num);
			break;
		}
		case "Go":
			selectedLevel = standPos.id;
			noPlayer.transform.rotation = Quaternion.Euler(0f, this.player.rigidBodies.head.transform.rotation.eulerAngles.y, 0f);
			clearFighters();
			noPlayer.gameObject.SetActive(value: true);
			scenes.loadLevel(selectedLevel);
			levelCharacters = gameData.getLevelCharacters((LocationData.HomeLocation)selectedLevel);
			break;
		case "practiceMode":
			PracticeMoveController.instance.nextPracticeMode();
			break;
		case "practiceMove":
			scenes.practiceMove();
			break;
		case "changeCharacter":
			scenes.pickCharacter();
			break;
		case "chooseLevel":
			if (specialMode.fixedLevel == -2)
			{
				scenes.randomLevel();
			}
			else if (specialMode.fixedLevel > -1)
			{
				scenes.loadLevel(specialMode.fixedLevel);
			}
			else
			{
				scenes.pickLevel();
			}
			break;
		case "finalStory":
			scenes.finalStory();
			break;
		case "skipLevels":
			scenes.skipLevels(back: false);
			break;
		case "skipLevelsBack":
			scenes.skipLevels(back: true);
			break;
		case "mainMenu":
			scenes.mainMenu();
			break;
		case "nextCharacter":
			characterID = (gameData.characterID = getNextCharacterID());
			removeFighter(this.player);
			scenes.practiceMove();
			break;
		case "changeDifficulty":
			scenes.chooseDifficulty();
			break;
		default:
			UnityEngine.Debug.LogError("Button action:" + standPos.buttonAction);
			FaceCanvasController.addText("Button action:" + standPos.buttonAction);
			break;
		}
	}

	public int getNextCharacterID()
	{
		int num = characterID + 1;
		if (num >= gameData.characters.Length)
		{
			num = 0;
		}
		while (!gameData.characters[num].playable(allowUnlockedBosses: true, blockLevelLocked: true, allowSpecials: false))
		{
			num++;
			if (num >= gameData.characters.Length)
			{
				num = 0;
			}
		}
		return num;
	}

	public void standAction(StandPositionIndicator standPos, bool on)
	{
		if (!on)
		{
			standButtons.fighterSet = -1;
			clearEnemies();
			return;
		}
		string text = standPos.standAction;
		if (text == null || !(text == "Spawn") || standButtons.fighterSet == standPos.id)
		{
			return;
		}
		specialModeTimer = 0f;
		specialModeDifficulty = 0f;
		specialModeScore = 0;
		specialModeSpawnCount = 0;
		specialModeSpawnCountTotal = 0;
		aiMode = 3;
		standButtons.fighterSet = standPos.id;
		clearEnemies();
		specialModeDifficulty = 0f;
		if (specialMode.singleRound)
		{
			standPos.heading.text = LocalisationController.getText("Game Mode", specialMode.name);
			standPos.extra.text = LocalisationController.getText("Game Description", specialMode.description);
		}
		finalBoss = false;
		winner = false;
		if (specialMode.name == "Ninja Challenge")
		{
			CharacterData character = GameData.instance.characters[32];
			int num = ninjaCount;
			for (int i = 0; i < num; i++)
			{
				float num2 = 360 / num * i;
				GameCharacter gameCharacter = addFighter(i + 1, character, 1, Quaternion.Euler(0f, num2, 0f) * Vector3.forward * 3f, 180f + num2, 0f, aboveGround: true);
				gameCharacter.fightingStyle = GameData.instance.randomCharacter(allowUnlockedBosses: false, allowSpecials: false).fightingStyle;
				gameCharacter.difficulty = 0f;
				gameCharacter.rigidBodies.specialPerc = UnityEngine.Random.value;
				gameCharacter.rigidBodies.maxHealth = (gameCharacter.rigidBodies.standUpPerc = (gameCharacter.rigidBodies.standUpPercMax = 0.1f));
			}
			specialModeSpawnCount = num;
			specialModeSpawnCountTotal = num;
			player.maxLives = (player.lives = 1);
			hud.setup();
			return;
		}
		if (specialMode.name == "Arcade")
		{
			CharacterData character2 = GameData.instance.characterOrder[0];
			float rotation = Mathf.RoundToInt(Mathf.Repeat(standPos.transform.rotation.eulerAngles.y + 180f, 360f));
			GameCharacter gameCharacter2 = addFighter(1, character2, 1, standPos.projected(0f), rotation, specialModeDifficulty, aboveGround: true);
			gameCharacter2.rigidBodies.standUpPerc = (gameCharacter2.rigidBodies.standUpPercMax = (gameCharacter2.rigidBodies.maxHealth = 0.25f));
			gameCharacter2.rigidBodies.specialPerc = 0f;
			gameCharacter2.setDifficulty(specialModeDifficulty);
			hud.setup();
			specialModeSpawnCount++;
			specialModeSpawnCountTotal++;
			player.maxLives = (player.lives = 1);
			return;
		}
		float rotation2 = Mathf.RoundToInt(Mathf.Repeat(standPos.transform.rotation.eulerAngles.y + 180f, 360f));
		CharacterData characterData = levelCharacters[standPos.id];
		if (!standPos.disabled)
		{
			selectedPos = standPos.id;
			int num3 = characterData.amount;
			if (num3 < 1)
			{
				num3 = 1;
			}
			if (specialMode.name == "Dragon Doubles")
			{
				num3 = 2;
			}
			for (int j = 0; j < num3; j++)
			{
				float num4 = j;
				if (num3 > 1)
				{
					num4 -= (float)(num3 - 1) / 2f;
				}
				float difficultyMod = 1f / (float)num3;
				if (specialMode.name == "Dragon Doubles")
				{
					difficultyMod = 1f;
					num4 *= -1f;
				}
				if (specialMode.name == "Dragon Doubles" && j > 0)
				{
					addFighter(j + 1, characterData.getFriend(), 1, standPos.projected(num4), rotation2, difficultyMod, aboveGround: true);
					continue;
				}
				addFighter(j + 1, characterData, 1, standPos.projected(num4), rotation2, difficultyMod, aboveGround: true);
				if (characterData.difficultyTier == CharacterData.DifficultyTier.FinalBoss)
				{
					finalBoss = true;
				}
			}
			hud.setup();
		}
		standPos.heading.text = LocalisationController.getText("Character: " + base.name, (characterData.amount > 1) ? characterData.pluralName : characterData.name);
		if (specialMode.name == "Dragon Doubles")
		{
			standPos.heading.text = LocalisationController.getText("Character: " + base.name, characterData.name) + " & " + LocalisationController.getText("Character: " + base.name, characterData.friend);
		}
		float difficulty = characterData.difficulty;
		if (gameMode == GameMode.Quick)
		{
			standPos.extra.text = LocalisationController.getText("General", "Difficulty:") + " " + difficultyText(difficulty);
			return;
		}
		if (characterData.unlocked)
		{
			standPos.extra.text = characterData.hasStars + "/3";
		}
		else
		{
			standPos.extra.text = LocalisationController.replaceText("Location Requirement", "[x] to unlock", (characterData.getUnlockStars() - instance.gameData.stars).ToString());
		}
		TextMeshProUGUI extra = standPos.extra;
		extra.text = extra.text + "\n" + LocalisationController.getText("General", "Difficulty:") + " " + difficultyText(difficulty);
	}

	public GameCharacter addFighter(int fighterID, CharacterData character, int teamIndex, Vector3 position, float rotation, float difficultyMod, bool aboveGround)
	{
		UnityEngine.Debug.Log("Add Character: " + character.name);
		if (character == null)
		{
			UnityEngine.Debug.LogError("Invalid Character");
			FaceCanvasController.addText("Invalid Character");
			return null;
		}
		GameCharacter gameCharacter = UnityEngine.Object.Instantiate(characterPrefab, aboveGround ? (position + Vector3.up * 0.5f) : position, Quaternion.Euler(0f, rotation, 0f), base.transform);
		gameCharacter.setup(fighterID, teamIndex, character);
		gameCharacter.difficulty = ((gameMode == GameMode.Edit) ? 1f : character.difficulty);
		gameCharacter.maxLives = (gameCharacter.lives = Mathf.Max(Mathf.CeilToInt(3f * difficultyMod), 1));
		gameCharacter.rigidBodies.maxHealth = (0.65f + 0.35f * difficultyMod) * character.healthPerc;
		players.Add(gameCharacter);
		getAllStandingIndeces();
		return gameCharacter;
	}

	public int teamLives(int team)
	{
		int num = 0;
		foreach (GameCharacter player in players)
		{
			if (player.team == team)
			{
				num += player.lives;
			}
		}
		return num;
	}

	public void removeFighter(GameCharacter fighter)
	{
		if (!(fighter == null))
		{
			UnityEngine.Object.Destroy(fighter.gameObject);
			players.Remove(fighter);
		}
	}

	public GameCharacter addFighter(int fighterID, int characterIndex, int teamIndex, Vector3 position, float rotation, float difficultyMod, bool aboveGround)
	{
		CharacterData character = gameData.characters[characterIndex];
		return addFighter(fighterID, character, teamIndex, position, rotation, difficultyMod, aboveGround);
	}

	public void clearEnemies()
	{
		movingAllowed = true;
		for (int num = players.Count - 1; num >= 0; num--)
		{
			if (!players[num].isPlayer())
			{
				UnityEngine.Object.Destroy(players[num].gameObject);
				players.RemoveAt(num);
			}
		}
	}

	public void clearFighters()
	{
		foreach (GameCharacter player in players)
		{
			UnityEngine.Object.Destroy(player.gameObject);
		}
		players.Clear();
		this.player = null;
		foreach (Transform item in base.transform)
		{
			UnityEngine.Object.Destroy(item.gameObject);
		}
	}

	public CharacterData selectedCharacter()
	{
		if (characterID == -1)
		{
			return null;
		}
		return gameData.characters[characterID];
	}

	public LocationData selectedLevelData()
	{
		return gameData.locations[selectedLevel];
	}

	public void retry()
	{
		addPlayer();
	}

	public void addPlayer(int spawnPoint = 0)
	{
		if (standButtons.spawnPoints == null || standButtons.spawnPoints[spawnPoint] == null)
		{
			if (standButtons.spawnPoints == null)
			{
				UnityEngine.Debug.Log("Spawnpoints are null, retry... (" + standButtons?.ToString() + ")");
			}
			else
			{
				UnityEngine.Debug.Log("Spawnpoint " + spawnPoint + " is null, retry... (" + standButtons?.ToString() + ")");
			}
			Invoke("retry", 0.1f);
			return;
		}
		clearFighters();
		Vector3 vector = Quaternion.Inverse(Quaternion.Euler(0f, noPlayer.activeRig.trackers[0].localRotation.eulerAngles.y, 0f)) * noPlayer.activeRig.trackers[0].localPosition;
		vector.y = 0f;
		CharacterData character = selectedCharacter();
		GameCharacter gameCharacter = addFighter(0, character, 0, standButtons.spawnPoints[spawnPoint].transform.position - vector, 0f - noPlayer.activeRig.trackers[0].transform.localRotation.eulerAngles.y, 1f, aboveGround: false);
		if (specialMode.singleRound)
		{
			gameCharacter.lives = 1;
		}
		joinGame(0.1f);
		movingAllowed = true;
		hud.setup();
	}

	public void joinGame(float difficulty)
	{
		UnityEngine.Debug.Log("Join Game!");
		for (int i = 0; i < players.Count; i++)
		{
			players[i].difficulty = difficulty;
		}
		player = players[0];
		player.setup(player.id, 0, player.data);
		player.difficulty = 1f;
		noPlayer.gameObject.SetActive(player == null);
	}

	private void resetGetUp()
	{
		canGetUp = true;
	}

	public void getStandingIndeces(int team)
	{
		int num = 0;
		teamCounts[team] = 0;
		foreach (GameCharacter player in players)
		{
			if (player.team == team && !player.rigidBodies.isDown(allTheWay: false))
			{
				teamCounts[team]++;
				player.standingIndex = num;
				num++;
			}
		}
	}

	public void getAllStandingIndeces()
	{
		for (int i = 0; i < 4; i++)
		{
			getStandingIndeces(i);
		}
	}

	public void checkWin()
	{
		standButtons.onKnockout();
		if (gameMode == GameMode.Chambers || fightState != FightState.During)
		{
			return;
		}
		canGetUp = false;
		if (fightState == FightState.Pre && Settings.instance.testButtonFunction == Settings.TestButtonFunction.Fall)
		{
			return;
		}
		List<int> list = new List<int>();
		List<int> list2 = new List<int>();
		foreach (GameCharacter player in players)
		{
			if (!player.rigidBodies.isDown(allTheWay: false))
			{
				if (!list.Contains(player.team))
				{
					list.Add(player.team);
				}
			}
			else
			{
				player.rigidBodies.standUpPerc = 0f;
			}
			if (player.lives > 0 && !list2.Contains(player.team))
			{
				list2.Add(player.team);
			}
		}
		CharacterData characterData = null;
		if (!specialMode.singleRound)
		{
			characterData = levelCharacters[selectedPos];
		}
		if (list2.Count > 1 && !specialMode.singleRound)
		{
			if (list.Count != 1)
			{
				return;
			}
			Invoke("resetGetUp", 3f);
			wereAllDown = true;
			MusicController.stopMusic();
			if (this.player != null)
			{
				bool flag = !this.player.rigidBodies.isDown(allTheWay: true);
				GeneralSounds.playSound(flag ? 2 : 3);
				Saving.instance.incrementStat("Rounds " + (flag ? "Won" : "Lost"), onlyInFight: false);
				WebLogging.log("Round " + (flag ? "Won" : "Lost"), "Round " + (flag ? "Won" : "Lost") + " against " + characterData.name + " (" + difficultyLevel.name + ")", instance.player.lives);
				if (flag && AchievementsController.instance.perfect)
				{
					Saving.instance.incrementStat("Perfect Rounds", onlyInFight: false);
				}
			}
			return;
		}
		bool flag2 = this.player != null && this.player.rigidBodies.isDown(allTheWay: true);
		if (!specialMode.singleRound)
		{
			HitEffects.timeSlow(1f, 2f);
			MusicController.stopMusic();
			this.player.data.playedAs = true;
		}
		else if (flag2)
		{
			MusicController.stopMusic();
		}
		GeneralSounds.playSound(flag2 ? 3 : 2);
		if (this.player != null)
		{
			if (this.player.lives > 0)
			{
				if (specialMode.singleRound)
				{
					return;
				}
				int hasStars = characterData.hasStars;
				if (this.player.lives > characterData.hasStars)
				{
					characterData.hasStars = this.player.lives;
				}
				int hasStars2 = characterData.hasStars;
				WebLogging.log("Fight - " + specialMode.name, "Win against " + characterData.name + " (" + difficultyLevel.name + ") " + characterData.hasStars + " Stars", hasStars2);
				Saving.instance.incrementStat("Rounds " + ((this.player.lives > 0) ? "Won" : "Lost"), onlyInFight: false);
				Saving.instance.incrementStat("Fights Won", onlyInFight: false);
				if (AchievementsController.instance.perfect)
				{
					Saving.instance.incrementStat("Perfect Rounds", onlyInFight: false);
				}
				CharacterData characterData2 = gameData.unlockLocationChar(characterData.home);
				string extra = "";
				if (characterData.pluralName == "Ninja" && !gameData.getSpecialModeByName("Ninja Challenge").unlocked)
				{
					extra = gameData.getSpecialModeByName("Ninja Challenge").unlock();
					extra = LocalisationController.getText("Unlock", extra);
				}
				else if (characterData.amount > 1 && gameData.getSpecialModeByName("Dragon Doubles").enabled && !gameData.getSpecialModeByName("Dragon Doubles").unlocked)
				{
					extra = gameData.getSpecialModeByName("Dragon Doubles").unlock();
					extra = LocalisationController.getText("Unlock", extra);
				}
				else if (!gameData.getSpecialModeByName("Arcade").unlocked && Saving.instance.savedProgress.stats.getStat("Fights Won").value >= 3f)
				{
					extra = gameData.getSpecialModeByName("Arcade").unlock();
					extra = LocalisationController.getText("Unlock", extra);
				}
				else if (gameData.getSpecialModeByName("One Armed Boxer") != null && !gameData.getSpecialModeByName("Stamina").unlocked && (difficultyLevel.name == "Harder" || difficultyLevel.name == "Master"))
				{
					extra = gameData.getSpecialModeByName("Stamina").unlock();
					extra = LocalisationController.getText("Unlock", extra);
				}
				else if (gameData.getSpecialModeByName("One Armed Boxer") != null && !gameData.getSpecialModeByName("One Armed Boxer").unlocked && Saving.instance.savedProgress.stats.getStat("Fights Won").value >= 30f)
				{
					extra = gameData.getSpecialModeByName("One Armed Boxer").unlock();
					extra = LocalisationController.getText("Unlock", extra);
				}
				else if (characterData2 != null)
				{
					extra = LocalisationController.replaceText("Unlock", "Character: [x] Unlocked", LocalisationController.getText("Character: " + characterData2.name, characterData2.name));
				}
				winLose.showWin(hasStars, hasStars2, extra);
				winner = true;
				if (finalBoss && winner)
				{
					AchievementsController.instance.onCompleteChecks();
				}
				zoomOut();
			}
			else
			{
				this.player.targetEnemy.aiControl.FinalWinVoice();
				if (specialMode.singleRound)
				{
					WebLogging.log("Special Mode: " + specialMode.name, "Finish", specialModeScore);
					string text = customUnlock;
					if (text != "")
					{
						text += " Unlocked";
					}
					if (specialMode.name == "Arcade" && specialModeScore >= 25)
					{
						AchievementsController.achievement("Arcade Fire");
					}
					if (specialMode.name == "Ninja Challenge" && specialModeScore >= 40)
					{
						AchievementsController.achievement("Ninja Hunter");
					}
					if (specialModeScore > specialMode.best)
					{
						winLose.show(LocalisationController.replaceText("Win/Lose", "New Best: [x]", specialModeScore.ToString()), null, halfWay: false, fadeOut: false, 1, text);
						specialMode.best = specialModeScore;
					}
					else
					{
						winLose.show(LocalisationController.replaceText("Win/Lose", "Final Score: [x]", specialModeScore.ToString()), null, halfWay: false, fadeOut: false, 1, text);
					}
					Saving.instance.savedProgress.stats.maxStat(specialMode.name, specialMode.best, checkAchievement: true, isInt: true);
					if (customUnlock != "")
					{
						Saving.instance.savedProgress.customUnlock(customUnlock);
						customUnlock = "";
					}
				}
				else
				{
					winLose.show(LocalisationController.getText("Win/Lose", "You Lose"), null, halfWay: false, fadeOut: false, 1);
					Saving.instance.incrementStat("Fights Lost", onlyInFight: false);
					if (characterData != null)
					{
						WebLogging.log("Fight", "Lose against " + characterData.name + " (" + difficultyLevel.name + ")", 0f);
					}
				}
			}
			if (difficultyLevel.id < lowestDifficultyLevel || lowestDifficultyLevel == -1)
			{
				lowestDifficultyLevel = difficultyLevel.id;
			}
			GameData.instance.unlockChars();
			Saving.saveGame();
			Saving.saveProgress();
			if (characterData != null)
			{
				characterData.fightsFinished++;
			}
		}
		fightState = FightState.Over;
		fightOverTime = 8f;
	}

	private void zoomOut()
	{
		movingAllowed = false;
		player.playerController.outOfBody(inBody: false);
	}

	public GameCharacter getToFollow(bool prioritizePlayer)
	{
		if (prioritizePlayer && player != null)
		{
			return player;
		}
		if (players.Count == 0)
		{
			return null;
		}
		return players[UnityEngine.Random.Range(0, players.Count)];
	}

	public GameCharacter getClosestEnemy(GameCharacter to)
	{
		GameCharacter gameCharacter = null;
		float num = float.PositiveInfinity;
		foreach (GameCharacter player in players)
		{
			if (!player.rigidBodies.isDown(allTheWay: true) && player.team != to.team)
			{
				Vector3 vector = player.standPosition - to.standPosition;
				if (vector.magnitude < num)
				{
					gameCharacter = player;
					num = vector.magnitude;
				}
			}
		}
		if (gameCharacter != null)
		{
			return gameCharacter;
		}
		foreach (GameCharacter player2 in players)
		{
			if (player2.team != to.team)
			{
				Vector3 vector2 = player2.standPosition - to.standPosition;
				if (vector2.magnitude < num)
				{
					gameCharacter = player2;
					num = vector2.magnitude;
				}
			}
		}
		return gameCharacter;
	}

	public AIMode currentAIMode()
	{
		return ai_Modes[aiMode];
	}

	public void init()
	{
		if (!initSetup)
		{
			initSetup = true;
			if (Settings.instance.mainMenuFighters)
			{
				addFighter(0, gameData.randomCharacter(allowUnlockedBosses: false, allowSpecials: false), 0, Vector3.right * -3f, 90f, 1f, aboveGround: false).setDifficulty(1f);
				addFighter(1, gameData.randomCharacter(allowUnlockedBosses: false, allowSpecials: false), 1, Vector3.right * 3f, -90f, 1f, aboveGround: false).setDifficulty(1f);
				Invoke("taunts", 0.1f * UnityEngine.Random.value * 0.2f);
			}
			hud.setup();
		}
	}

	private void taunts()
	{
		players[0].aiControl.taunt(speak: false);
		players[1].aiControl.taunt(speak: false);
	}

	private int getFreeFighterID()
	{
		for (int i = 0; i < 30; i++)
		{
			bool flag = true;
			foreach (GameCharacter player in players)
			{
				if (player.id == i)
				{
					flag = false;
					break;
				}
			}
			if (flag)
			{
				return i;
			}
		}
		UnityEngine.Debug.LogError("couldnt find free fighter ID");
		return 30;
	}

	public void abandonFight()
	{
		clearEnemies();
		aiMode = 3;
		fightState = FightState.Pre;
		standButtons.fighterSet = -1;
		GeneralSounds.playSound(5);
		MusicController.stopMusic();
		standButtons.gameObject.SetActive(value: true);
		StandPositionIndicator[] positions = standButtons.positions;
		foreach (StandPositionIndicator obj in positions)
		{
			obj.standingOn = false;
			obj.on = false;
			obj.minTime = Time.time + 1f;
		}
	}

	private void updateSpecialMode()
	{
		if (!specialMode.singleRound || fightState != FightState.During)
		{
			return;
		}
		specialModeTimer += Time.deltaTime;
		if (specialModeTimer < 1f)
		{
			return;
		}
		specialModeTimer -= 1f;
		switch (specialMode.name)
		{
		case "Arcade":
		{
			foreach (GameCharacter player in players)
			{
				if (!player.isPlayer() && player.rigidBodies.downTimer > 3f)
				{
					removeFighter(player);
					float num6 = (1f - specialModeDifficulty) / 4f;
					this.player.rigidBodies.standUpPercMax += num6;
					this.player.rigidBodies.standUpPercMax = Mathf.Clamp01(this.player.rigidBodies.standUpPercMax);
					this.player.rigidBodies.standUpPerc += num6;
					this.player.rigidBodies.standUpPerc = Mathf.Clamp01(this.player.rigidBodies.standUpPerc);
					string text2 = LocalisationController.replaceText("General", "+[x]% Health", Mathf.Round(num6 * 100f).ToString());
					CanvasController.addText(localise: false, text2, this.player.hands.rightHand.position, Color.white, 5f);
					return;
				}
			}
			int num7 = specialModeSpawnCount;
			int num8 = 1;
			while (num7 >= GameData.instance.characterOrder.Length)
			{
				num7 -= GameData.instance.characterOrder.Length;
				num8++;
			}
			if (UnityEngine.Random.value < 0.02f)
			{
				num8++;
			}
			if (players.Count > num8)
			{
				break;
			}
			specialModeSpawnCount++;
			specialModeSpawnCountTotal++;
			GeneralSounds.playSound(5);
			CharacterData character = GameData.instance.characterOrder[num7];
			_ = UnityEngine.Random.value;
			specialModeDifficulty = Mathf.Clamp01((float)specialModeSpawnCount / ((float)GameData.instance.characterOrder.Length / 2f));
			Vector3 position = standButtons.positions[0].enemySpawnPoint.position;
			_ = (position - this.player.standPosition).magnitude;
			List<StandPositionIndicator> list = new List<StandPositionIndicator>();
			StandPositionIndicator[] positions = standButtons.positions;
			foreach (StandPositionIndicator standPositionIndicator in positions)
			{
				if ((standPositionIndicator.enemySpawnPoint.position - this.player.standPosition).magnitude > 2f)
				{
					list.Add(standPositionIndicator);
				}
			}
			if (list.Count > 0)
			{
				position = list[UnityEngine.Random.Range(0, list.Count)].enemySpawnPoint.position;
			}
			GameCharacter gameCharacter2 = addFighter(1, character, 1, position, Quaternion.LookRotation(this.player.standPosition - position).eulerAngles.y, specialModeDifficulty, aboveGround: true);
			gameCharacter2.setDifficulty(specialModeDifficulty);
			gameCharacter2.rigidBodies.standUpPerc = (gameCharacter2.rigidBodies.standUpPercMax = (gameCharacter2.rigidBodies.maxHealth = 0.3f + specialModeDifficulty * 0.7f));
			gameCharacter2.rigidBodies.specialPerc = specialModeDifficulty;
			hud.setup();
			gameCharacter2.aiControl.taunt(0.1f);
			MusicController.pause();
			break;
		}
		case "Ninja Challenge":
			foreach (GameCharacter player2 in players)
			{
				if (!player2.isPlayer() && player2.rigidBodies.downTimer > 5f)
				{
					float num = 0.05f;
					this.player.rigidBodies.standUpPercMax += num;
					this.player.rigidBodies.standUpPercMax = Mathf.Clamp01(this.player.rigidBodies.standUpPercMax);
					this.player.rigidBodies.standUpPerc += num;
					this.player.rigidBodies.standUpPerc = Mathf.Clamp01(this.player.rigidBodies.standUpPerc);
					string text = LocalisationController.replaceText("General", "+[x]% Health", Mathf.Round(num * 100f).ToString());
					CanvasController.addText(localise: false, text, player2.headRecoil.transform.position, Color.white, 5f);
					removeFighter(player2);
					hud.setup();
					return;
				}
			}
			if (players.Count < ninjaCount + 1)
			{
				CharacterData characterData = GameData.instance.characters[32];
				float num2 = 0.125f;
				if (specialModeSpawnCountTotal == 30)
				{
					characterData = GameData.instance.characters[39];
					num2 = 0.5f;
				}
				else if (specialModeSpawnCount >= 6)
				{
					characterData = GameData.instance.characters[33];
					specialModeSpawnCount = 0;
					num2 *= 2f;
				}
				float num3 = UnityEngine.Random.value * 360f;
				specialModeDifficulty += 0.02f;
				num2 *= 5f / (float)ninjaCount;
				float num4 = Mathf.Round((float)(Settings.instance.beltColours.Length - 1) * specialModeDifficulty) / (float)(Settings.instance.beltColours.Length - 1);
				Vector3[] array = new Vector3[6]
				{
					new Vector3(-5f, 3f, -5f),
					new Vector3(5f, 3f, -5f),
					new Vector3(-5f, 3f, 5f),
					new Vector3(5f, 3f, 5f),
					new Vector3(-2.5f, 3f, 0f),
					new Vector3(2.5f, 3f, 0f)
				};
				float num5 = Mathf.Clamp01(num4 - Mathf.Clamp01(num4));
				GameCharacter gameCharacter = addFighter(getFreeFighterID(), characterData, 1, array[UnityEngine.Random.Range(0, array.Length)], 180f + num3, 0.1f, aboveGround: true);
				if (characterData.id != 39)
				{
					gameCharacter.fightingStyle = GameData.instance.randomCharacter(allowUnlockedBosses: false, allowSpecials: false).fightingStyle;
				}
				gameCharacter.rigidBodies.standUpPerc = (gameCharacter.rigidBodies.maxHealth = num2 + num5);
				gameCharacter.rigidBodies.specialPerc = ((characterData.id == 39) ? 1f : Mathf.Clamp01(UnityEngine.Random.value + num4));
				gameCharacter.difficulty = Mathf.Clamp01((characterData.id == 39) ? (num4 * 2.5f) : num4);
				hud.setup();
				GeneralSounds.playSound((characterData.id == 39) ? 7 : 5);
				specialModeSpawnCount++;
				specialModeSpawnCountTotal++;
			}
			break;
		}
	}

	private void Update()
	{
		noPlayer.gameObject.SetActive(player == null || !player.playerController.inBody);
		timeScale = 1f;
		uberHitTimer = Mathf.MoveTowards(uberHitTimer, 1f, Time.deltaTime / Settings.instance.uberHitTimerMax);
		if (Time.time > fpsTime)
		{
			fps = 1f / Time.unscaledDeltaTime;
			fpsTime = Time.time + 0.5f;
		}
		floatingCanvas.gameObject.SetActive(value: false);
		if (scenes.loading)
		{
			return;
		}
		if (calibrating)
		{
			if (OptionData.getInt("Mode") == 0)
			{
				floatingCanvas.show(((double)quitTimer < 0.5) ? "Face Forward" : "Stand Straight", quitTimer, 4f);
			}
			else
			{
				floatingCanvas.show(((double)quitTimer < 0.5) ? "Face Forward" : "Sit Straight", quitTimer, 4f);
			}
			quitTimer += Time.deltaTime / 3f;
			if (quitTimer >= 1f)
			{
				noPlayer.calibrate();
				calibrating = false;
				quitTimer = 0f;
			}
			return;
		}
		if (fightState == FightState.Over)
		{
			fightOverTime -= Time.deltaTime;
			if (fightOverTime < 0f)
			{
				fightState = FightState.Pre;
				winLose.gameObject.SetActive(value: false);
				if (finalBoss && winner)
				{
					scenes.finalStory();
				}
				else if (winner)
				{
					scenes.endOfLevel();
				}
				else
				{
					scenes.endOfLevel();
				}
			}
			return;
		}
		updateSpecialMode();
		if (standButtons != null)
		{
			init();
			standButtons.gameObject.SetActive(player != null && (gameMode == GameMode.None || gameMode == GameMode.Normal || gameMode == GameMode.Quick || gameMode == GameMode.No_Fight) && fightState == FightState.Pre);
		}
		if (OptionData.getBool("Allow AI Change") && ((player != null && player.playerController.vrActions.nextAIMode()) || Input.GetKeyDown(nextAIModeKey)) && gameMode != GameMode.Edit)
		{
			aiMode++;
			if (aiMode >= ai_Modes.Length)
			{
				aiMode = 0;
			}
			for (int i = 0; i < ai_Modes.Length; i++)
			{
				if (!currentAIMode().editMode && gameMode == GameMode.Edit)
				{
					aiMode++;
				}
				if (!currentAIMode().fightMode && gameMode != GameMode.Edit)
				{
					aiMode++;
				}
				if (aiMode >= ai_Modes.Length)
				{
					aiMode = 0;
				}
			}
			string text = ai_Modes[aiMode].name;
			FaceCanvasController.addText(ai_Modes[aiMode].name);
			MoveRecorder.alwaysLoop = text == "Playback";
			if (text == "Fight")
			{
				foreach (GameCharacter player in players)
				{
					player.aiControl.reset();
				}
			}
		}
		if (!(this.player != null))
		{
			return;
		}
		if (this.player.playerController.vrActions.pauseUnity())
		{
			UnityEngine.Debug.Break();
		}
		if (gameMode == GameMode.Edit)
		{
			if (this.player.playerController.vrActions.pause() && !MoveRecorder.instance.recording)
			{
				menu.toggle(0.4f);
			}
			return;
		}
		if (this.player.playerController.vrActions.showMenu() && gameMode != 0)
		{
			if (quitTimer < 1f)
			{
				quitTimer += Time.deltaTime;
			}
			else
			{
				quitTimer = 0f;
				if (fightState != 0)
				{
					abandonFight();
				}
				else
				{
					scenes.endOfLevel();
				}
			}
		}
		else if (quitTimer > 0f)
		{
			quitTimer -= Time.deltaTime;
		}
		floatingCanvas.gameObject.SetActive(quitTimer > 0f);
		if (quitTimer > 0f)
		{
			if (gameMode == GameMode.Chambers || gameMode == GameMode.Edit || standButtons.isLevelPicker)
			{
				floatingCanvas.show("Quit to Menu", quitTimer, 1f);
			}
			else
			{
				floatingCanvas.show((fightState != 0) ? "Abandoning..." : "Leaving Level...", quitTimer, 1f);
			}
		}
	}
}
public class GameData : MonoBehaviour
{
	public static GameData instance;

	public Version version;

	public bool audioTest;

	private AudioSource audioSource;

	private int audioTestNum;

	public bool devModeEnabled;

	public float calibrateScale = 1f;

	public OptionCategory[] options;

	public CharacterData[] characters;

	public SpecialMoveData[] specialMoves;

	public PerkData[] perks;

	public PerkData[] weaknesses;

	public LocationData[] locations;

	public PressurePointData[] pressurePoints;

	public CharacterEffectData[] characterEffects;

	public string[] tips;

	public GameModeData[] specialModes;

	[Header("VR Settings")]
	public bool isKnuckles;

	public bool fingerTracking;

	public VRProfile vrProfile;

	public VRProfile[] vrProfileOverrides;

	public VRControlTip[] vrControlTips;

	[Header("Current Game")]
	public int characterID;

	public int stars;

	public CharacterData[] characterOrder;

	public int totalStars;

	public int finalStars;

	public int difficultyLevelCompleted;

	[Header("Progression Setup")]
	public int increaseStart = 2;

	public int increaseDiffAfter = 3;

	public MoveRecorder moveRecorder;

	public bool defaultDevsOn;

	private int onTip;

	public bool chooseDifficulty;

	public bool demoVersion;

	public bool exportData;

	public bool importData;

	public string webPageFolderPath;

	private float nextErrorTime;

	private string loggedProfile = "";

	public float logOptions = 10f;

	private void Start()
	{
		instance = this;
		Application.logMessageReceived += ReceivedLog;
		_ = Application.persistentDataPath + "\\devmode.dat";
		resetOptions();
		GameModeData[] array = specialModes;
		foreach (GameModeData obj in array)
		{
			obj.unlocked = obj.name == "Normal";
		}
		onTip = UnityEngine.Random.Range(0, tips.Length);
		LocationData[] array2 = locations;
		for (int i = 0; i < array2.Length; i++)
		{
			array2[i].includeInDemo = false;
		}
		PerkData[] array3 = perks;
		for (int i = 0; i < array3.Length; i++)
		{
			array3[i].used = 0;
		}
		array3 = weaknesses;
		for (int i = 0; i < array3.Length; i++)
		{
			array3[i].used = 0;
		}
		CharacterData[] array4 = characters;
		foreach (CharacterData characterData in array4)
		{
			characterData.getThumb();
			PerkData perkByName = getPerkByName(characterData.perkName);
			if (perkByName != null)
			{
				perkByName.used++;
			}
			PerkData perkByName2 = getPerkByName(characterData.weaknessName);
			if (perkByName2 != null)
			{
				perkByName2.used++;
			}
			if (demoVersion && !characterData.includeInDemo)
			{
				characterData.puppet = null;
			}
			else
			{
				locations[(int)characterData.home].includeInDemo = true;
			}
		}
		for (int j = 0; j < locations.Length; j++)
		{
			locations[j].id = j;
		}
		string text = "";
		CharacterEffectData[] array5 = characterEffects;
		for (int i = 0; i < array5.Length; i++)
		{
			array5[i].setup();
		}
		if (text != "")
		{
			UnityEngine.Debug.LogError("Special Move Actions missing: " + text);
		}
		Settings.instance.setToDefault();
	}

	public string optionsLog()
	{
		string text = "";
		OptionCategory[] array = options;
		for (int i = 0; i < array.Length; i++)
		{
			OptionData[] array2 = array[i].options;
			foreach (OptionData optionData in array2)
			{
				if (optionData.values.Length != 0)
				{
					if (text != "")
					{
						text += " ";
					}
					text = text + optionData.name + ":" + optionData.displayValue().Replace("%", "p");
				}
			}
		}
		return text;
	}

	public CharacterData unlockLocationChar(LocationData.HomeLocation location)
	{
		CharacterData[] array = characters;
		foreach (CharacterData characterData in array)
		{
			if (characterData.home == location && characterData.lockedByDefault && characterData.lockedByDefault && !characterData.playable(allowUnlockedBosses: true, blockLevelLocked: true))
			{
				locations[(int)location].charactersUnlocked = true;
				return characterData;
			}
		}
		return null;
	}

	public StreamReader readFile(string filename)
	{
		return new StreamReader(webPageFolderPath + "/" + filename);
	}

	public void exportWebPage(string filename, string toWrite, string extenstion = "htm", bool andOpen = false)
	{
		string text = webPageFolderPath + "/" + filename + "." + extenstion;
		StreamWriter streamWriter = File.CreateText(text);
		streamWriter.Write(toWrite);
		streamWriter.Close();
		if (andOpen)
		{
			Application.OpenURL(text);
		}
	}

	public GameModeData getSpecialModeByName(string name)
	{
		if (name == "" || name == null)
		{
			name = "Normal";
		}
		GameModeData[] array = specialModes;
		foreach (GameModeData gameModeData in array)
		{
			if (gameModeData.name == name)
			{
				return gameModeData;
			}
		}
		return null;
	}

	public PerkData getPerkByName(string name)
	{
		PerkData[] array = perks;
		foreach (PerkData perkData in array)
		{
			if (perkData.name == name)
			{
				return perkData;
			}
		}
		array = weaknesses;
		foreach (PerkData perkData2 in array)
		{
			if (perkData2.name == name)
			{
				return perkData2;
			}
		}
		UnityEngine.Debug.LogError("couldnt find perk/weakness: " + name);
		return null;
	}

	public void resetOptions()
	{
		defaultDevsOn = false;
		OptionCategory[] array = options;
		foreach (OptionCategory optionCategory in array)
		{
			OptionData[] array2 = optionCategory.options;
			foreach (OptionData optionData in array2)
			{
				optionData.reset();
				if (optionCategory.name == "Dev")
				{
					if (optionData.value != 1 && optionData.values.Length != 0)
					{
						UnityEngine.Debug.LogError(optionData.name + " is on by default");
						defaultDevsOn = true;
					}
					if (!devModeEnabled)
					{
						optionData.value = 1;
					}
				}
			}
		}
	}

	public void ShowVRTip(int index)
	{
		VRControlTip controlTip = vrControlTips[index];
		GameController.instance.player.playerController.controllerTips.tip(controlTip, 5f);
	}

	public void ShowVRTip()
	{
		VRControlTip[] array = vrControlTips;
		foreach (VRControlTip vRControlTip in array)
		{
			if (vRControlTip.seen == 0 && vRControlTip.type == VRControlTip.Type.OnMenu && GameController.instance.player == null)
			{
				break;
			}
			if (vRControlTip.seen == 0 && vRControlTip.type == VRControlTip.Type.LevelStart && GameController.instance.player != null)
			{
				GameController.instance.player.playerController.controllerTips.tip(vRControlTip, 5f);
				break;
			}
		}
	}

	public CharacterData getCharactersByName(string name)
	{
		CharacterData[] array = characters;
		foreach (CharacterData characterData in array)
		{
			if (characterData.name == name)
			{
				return characterData;
			}
		}
		UnityEngine.Debug.LogError("Couldn't Find Character: " + name);
		return null;
	}

	public CharacterEffectData getCharacterEffect(CharacterEffect.Effect effect)
	{
		CharacterEffectData[] array = characterEffects;
		foreach (CharacterEffectData characterEffectData in array)
		{
			if (characterEffectData.effect == effect)
			{
				return characterEffectData;
			}
		}
		return null;
	}

	public void vrProfileSearch(string modelName)
	{
		VRProfile[] array = vrProfileOverrides;
		foreach (VRProfile vRProfile in array)
		{
			if (modelName.Contains(vRProfile.modelSearch))
			{
				vrProfile = vRProfile;
				if (loggedProfile != "VR Profile")
				{
					WebLogging.log("VR Profile", vRProfile.name + " " + modelName, 0f);
					loggedProfile = "VR Profile";
				}
				return;
			}
		}
		if (loggedProfile != "VR Profile Default")
		{
			WebLogging.log("VR Profile Default", modelName, 0f);
			loggedProfile = "VR Profile Default";
		}
	}

	public SpecialMoveData randomSpecialMove(bool isPlayer)
	{
		return randomCharacter(allowUnlockedBosses: false, allowSpecials: false).specialMoveData(isPlayer);
	}

	public string getTip()
	{
		onTip++;
		if (onTip >= tips.Length)
		{
			onTip = 0;
		}
		return LocalisationController.getText("Tip", tips[onTip]);
	}

	public void unlockChars()
	{
		stars = 0;
		totalStars = 0;
		LocationData[] array = locations;
		foreach (LocationData obj in array)
		{
			obj.gotStars = 0;
			obj.availableStars = 0;
			obj.totalStars = 0;
			obj.unlocked = false;
			obj.nextUnlock = 100;
		}
		CharacterData[] array2 = characterOrder;
		foreach (CharacterData characterData in array2)
		{
			stars += characterData.hasStars;
			totalStars += 3;
			characterData.unlocked = false;
			locations[(int)characterData.home].gotStars += characterData.hasStars;
		}
		Saving.instance.saveGameData.stats.maxStat("Stars", stars, checkAchievement: false, isInt: true, "/" + totalStars);
		if (GameController.instance.difficultyLevel.isMaster())
		{
			Saving.instance.savedProgress.stats.maxStat("Master Stars", stars, checkAchievement: true, isInt: true);
		}
		int num = 0;
		array2 = characterOrder;
		foreach (CharacterData characterData2 in array2)
		{
			if (stars >= characterData2.getUnlockStars() || OptionData.getBool("Unlock All") || GameController.instance.difficultyLevel.isMaster())
			{
				if (!characterData2.unlocked)
				{
					characterData2.unlocked = true;
					num++;
				}
				locations[(int)characterData2.home].unlocked = true;
			}
			if (characterData2.unlocked)
			{
				locations[(int)characterData2.home].availableStars += 3;
			}
			locations[(int)characterData2.home].totalStars += 3;
			if (characterData2.unlockStars < locations[(int)characterData2.home].nextUnlock && !characterData2.unlocked)
			{
				locations[(int)characterData2.home].nextUnlock = characterData2.getUnlockStars();
			}
		}
	}

	public void getCompleted()
	{
		CharacterData[] array = characters;
		foreach (CharacterData obj in array)
		{
			obj.beatenBossLevel = -1;
			obj.completedAllLevel = -1;
		}
		difficultyLevelCompleted = -1;
		SavedCompletedGame[] completedGames = Saving.instance.savedProgress.completedGames;
		foreach (SavedCompletedGame savedCompletedGame in completedGames)
		{
			CharacterData characterData = characters[savedCompletedGame.characterId];
			if (savedCompletedGame.difficultyLevel > difficultyLevelCompleted)
			{
				difficultyLevelCompleted = savedCompletedGame.difficultyLevel;
			}
			if (savedCompletedGame.specialMode == GameController.instance.specialMode.name)
			{
				if (savedCompletedGame.singleCharacter && savedCompletedGame.difficultyLevel > characterData.completedAllLevel)
				{
					characterData.completedAllLevel = savedCompletedGame.difficultyLevel;
				}
				if (savedCompletedGame.difficultyLevel > characterData.beatenBossLevel)
				{
					characterData.beatenBossLevel = savedCompletedGame.difficultyLevel;
				}
			}
		}
	}

	public void setupNewGame(int slot)
	{
		Saving.instance.selectedSlot = slot;
		if (slot < 0)
		{
			List<SaveGame> list = new List<SaveGame>();
			list.AddRange(Saving.instance.saveSlots);
			list.Add(new SaveGame());
			Saving.instance.saveSlots = list.ToArray();
			slot = Saving.instance.saveSlots.Length - 1;
		}
		Saving.instance.saveGameData = Saving.instance.saveSlots[slot];
		if (!GameController.instance.specialMode.hasDifficultyLevels)
		{
			GameController.instance.difficultyLevel = Settings.instance.generalDifficultyLevel;
			GameController.instance.gameData.chooseDifficulty = false;
		}
		else
		{
			GameController.instance.lowestDifficultyLevel = -1;
			GameController.instance.gameData.chooseDifficulty = true;
		}
		Saving.instance.saveGameData.stats.clear();
		for (int i = 0; i < characters.Length; i++)
		{
			characters[i].id = i;
		}
		LocationData[] array = locations;
		for (int j = 0; j < array.Length; j++)
		{
			array[j].reset();
		}
		List<CharacterData> list2 = new List<CharacterData>();
		CharacterData[] array2 = characters;
		foreach (CharacterData characterData in array2)
		{
			if (characterData.includeInMainGame)
			{
				list2.Add(characterData);
			}
		}
		foreach (CharacterData item in list2)
		{
			item.reset();
			if (item.puppet == null)
			{
				item.rndOrder += 1000f;
			}
		}
		list2.Sort((CharacterData c1, CharacterData c2) => c1.rndOrder.CompareTo(c2.rndOrder));
		characterOrder = list2.ToArray();
		totalStars = list2.Count * 3;
		finalStars = list2[list2.Count - 1].unlockStars;
		if (finalStars > totalStars)
		{
			UnityEngine.Debug.LogError("Final stars: " + finalStars + "/" + totalStars);
		}
		setupUnlocks();
		Saving.saveGame();
	}

	private void reshuffle()
	{
		LocationData[] array = locations;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].reset();
		}
		List<CharacterData> list = new List<CharacterData>();
		CharacterData[] array2 = characters;
		foreach (CharacterData characterData in array2)
		{
			if (characterData.includeInMainGame)
			{
				list.Add(characterData);
			}
		}
		foreach (CharacterData item in list)
		{
			item.reset();
			if (item.puppet == null)
			{
				item.rndOrder += 1000f;
			}
		}
		list.Sort((CharacterData c1, CharacterData c2) => c1.rndOrder.CompareTo(c2.rndOrder));
		characterOrder = list.ToArray();
		totalStars = list.Count * 3;
		finalStars = list[list.Count - 1].unlockStars;
		if (finalStars > totalStars)
		{
			UnityEngine.Debug.LogError("Final stars: " + finalStars + "/" + totalStars);
		}
		setupUnlocks();
		Saving.saveGame();
	}

	public int remainingStars()
	{
		int num = 0;
		CharacterData[] array = characterOrder;
		foreach (CharacterData characterData in array)
		{
			if (characterData.unlockDifficultyRequirement < 0 && characterData.fightsFinished == 0)
			{
				num += 3;
			}
		}
		return num;
	}

	public void setupCharacters()
	{
		CharacterData[] array = characters;
		foreach (CharacterData characterData in array)
		{
			characterData.setup(this, moveRecorder);
			getCharactersByName(characterData.name).otherFriend = "";
		}
		array = characters;
		foreach (CharacterData characterData2 in array)
		{
			if (characterData2.friend == "")
			{
				UnityEngine.Debug.LogError(characterData2.name + " has no friend");
				continue;
			}
			CharacterData charactersByName = getCharactersByName(characterData2.friend);
			if (charactersByName == null)
			{
				UnityEngine.Debug.LogError("Couldnt find: " + characterData2.friend + " - " + characterData2.name);
			}
			if (charactersByName.otherFriend != "")
			{
				UnityEngine.Debug.LogError(characterData2.friend + " already occupied by: " + getCharactersByName(characterData2.friend).otherFriend + " (" + characterData2.name + ")");
			}
			else
			{
				getCharactersByName(characterData2.friend).otherFriend = characterData2.name;
			}
		}
		array = characters;
		foreach (CharacterData characterData3 in array)
		{
			if (characterData3.otherFriend == "")
			{
				UnityEngine.Debug.LogError(characterData3.name + " is available");
			}
		}
	}

	public void setupUnlocks()
	{
		int num = increaseStart;
		int num2 = -1;
		int num3 = 0;
		float num4 = 0f;
		float num5 = 1f / ((float)characters.Length * 0.7f);
		int unlockStars = 0;
		LocationData[] array = locations;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].reset();
		}
		CharacterData[] array2 = characterOrder;
		foreach (CharacterData characterData in array2)
		{
			characterData.difficulty = num4;
			num4 += num5;
			if (num4 > 1f)
			{
				num4 = 1f;
			}
			characterData.unlockStars = ((!(GameController.instance.difficultyLevel.name == "Master")) ? num2 : 0);
			if (characterData.difficultyTier == CharacterData.DifficultyTier.Boss || characterData.difficultyTier == CharacterData.DifficultyTier.SubBoss || characterData.difficultyTier == CharacterData.DifficultyTier.FinalBoss)
			{
				characterData.unlockStars = unlockStars;
			}
			else
			{
				unlockStars = characterData.unlockStars;
				num2 += num;
			}
			num3++;
			if (num3 >= increaseDiffAfter)
			{
				num++;
				num3 = 0;
			}
			if (characterData.unlockStars < 0)
			{
				characterData.unlockStars = 0;
			}
			LocationData locationData = locations[(int)characterData.home];
			if (characterData.unlockStars < locationData.toUnlock)
			{
				locationData.toUnlock = characterData.getUnlockStars();
			}
		}
		unlockChars();
	}

	private void ReceivedLog(string logString, string stackTrace, LogType logType)
	{
		if (logType != 0 && logType != LogType.Exception)
		{
			return;
		}
		if (OptionData.getBool("Display Errors"))
		{
			FaceCanvasController.addText("Error: " + logString);
			GeneralSounds.playSound(9);
		}
		if (Time.time > nextErrorTime)
		{
			string text = stackTrace;
			if (text.Length > 200)
			{
				text = text.Substring(0, 200);
			}
			WebLogging.log("Error", logString + "\n" + text, 0f);
		}
		nextErrorTime = Time.time + 5f;
	}

	public CharacterData[] getLevelCharacters(LocationData.HomeLocation level)
	{
		List<CharacterData> list = new List<CharacterData>();
		CharacterData[] array = characterOrder;
		foreach (CharacterData characterData in array)
		{
			if (characterData.home == level)
			{
				list.Add(characterData);
			}
		}
		return list.ToArray();
	}

	public CharacterData randomCharacter(bool allowUnlockedBosses, bool allowSpecials, bool tests = true, bool allowWacky = true)
	{
		List<CharacterData> list = new List<CharacterData>();
		CharacterData[] array = characters;
		foreach (CharacterData characterData in array)
		{
			if (((!tests && characterData.playable(allowUnlockedBosses, blockLevelLocked: false, allowSpecials) && characterData.puppet != null) || characterData.test) && (allowWacky || !characterData.wacky))
			{
				list.Add(characterData);
			}
		}
		if (list.Count == 0 && tests)
		{
			return randomCharacter(allowUnlockedBosses, allowSpecials, tests: false, allowWacky);
		}
		return list[UnityEngine.Random.Range(0, list.Count)];
	}

	public SpecialMoveData getSpecialMoveByName(string name)
	{
		SpecialMoveData[] array = specialMoves;
		foreach (SpecialMoveData specialMoveData in array)
		{
			if (specialMoveData.name == name)
			{
				return specialMoveData;
			}
		}
		return null;
	}

	private void exportPerks()
	{
		string text = "";
		PerkData[] array = perks;
		foreach (PerkData perkData in array)
		{
			text = text + perkData.exportString() + "\n";
		}
		exportWebPage("perks", text, "txt", andOpen: true);
		text = "";
		array = weaknesses;
		foreach (PerkData perkData2 in array)
		{
			text = text + perkData2.exportString() + "\n";
		}
		exportWebPage("weaknesses", text, "txt", andOpen: true);
	}

	private void exportSpecialMoves()
	{
		string text = "";
		SpecialMoveData[] array = specialMoves;
		foreach (SpecialMoveData specialMoveData in array)
		{
			text = text + specialMoveData.exportString() + "\n";
		}
		exportWebPage("specialMoves", text, "txt", andOpen: true);
	}

	private void exportAchievements()
	{
		string text = "";
		AchievementData[] achievements = AchievementsController.instance.achievements;
		foreach (Exportable exportable in achievements)
		{
			text = text + exportable.exportString() + "\n";
		}
		exportWebPage("achievements", text, "txt", andOpen: true);
	}

	private void exportPressurePoints()
	{
		string text = "";
		PressurePointData[] array = pressurePoints;
		foreach (PressurePointData pressurePointData in array)
		{
			text = text + pressurePointData.exportString() + "\n";
		}
		exportWebPage("pressurePoints", text, "txt", andOpen: true);
	}

	private void exportDifficultyLevels()
	{
		string text = "";
		string text2 = "<table>";
		text2 += "<tr>";
		text2 += "<th>name</th>";
		text2 += "<td>moveRangeBias</td>";
		text2 += "<td>minDistance</td>";
		text2 += "<td>aiThinkTime</td>";
		text2 += "<td>aiSpeed</td>";
		text2 += "<td>aiTurnSpeed</td>";
		text2 += "<td>aiWalkSpeed</td>";
		text2 += "<td>aiChangeDirSpeed</td>";
		text2 += "<td>aiCaution</td>";
		text2 += "<td>aiSpecialMoveSpeed</td>";
		text2 += "<td>aiMoveChoiceVariance</td>";
		text2 += "<td>aiDodgeLikelihood</td>";
		text2 += "<td>enemyMuscleWeight</td>";
		text2 += "<td>massMultiplyBySpeed</td>";
		text2 += "<td>handOffsetPauseTime</td>";
		text2 += "<td>handOffsetRecoveryTime</td>";
		text2 += "<td>damageAutobalance</td>";
		text2 += "</tr>";
		DifficultyLevel[] difficultyLevels = Settings.instance.difficultyLevels;
		foreach (DifficultyLevel difficultyLevel in difficultyLevels)
		{
			text = text + difficultyLevel.exportString() + "\n";
			text2 += "<tr>";
			text2 = text2 + "<th>" + difficultyLevel.name + "</th>";
			text2 = text2 + "<td>" + difficultyLevel.minDistance.ToString() + "</td>";
			text2 = text2 + "<td>" + difficultyLevel.aiThinkTime.ToString() + "</td>";
			text2 = text2 + "<td>" + difficultyLevel.aiSpeed.ToString() + "</td>";
			text2 = text2 + "<td>" + difficultyLevel.aiTurnSpeed.ToString() + "</td>";
			text2 = text2 + "<td>" + difficultyLevel.aiWalkSpeed.ToString() + "</td>";
			text2 = text2 + "<td>" + difficultyLevel.aiChangeDirSpeed.ToString() + "</td>";
			text2 = text2 + "<td>" + difficultyLevel.aiCaution.ToString() + "</td>";
			text2 = text2 + "<td>" + difficultyLevel.aiSpecialMoveSpeed.ToString() + "</td>";
			text2 = text2 + "<td>" + difficultyLevel.aiMoveChoiceVariance.ToString() + "</td>";
			text2 = text2 + "<td>" + difficultyLevel.aiDodgeLikelihood.ToString() + "</td>";
			text2 = text2 + "<td>" + difficultyLevel.enemyMuscleWeight.ToString() + "</td>";
			text2 = text2 + "<td>" + difficultyLevel.massMultiplyBySpeed.ToString() + "</td>";
			text2 = text2 + "<td>" + difficultyLevel.handOffsetPauseTime.ToString() + "</td>";
			text2 = text2 + "<td>" + difficultyLevel.handOffsetRecoveryTime.ToString() + "</td>";
			text2 = text2 + "<td>" + difficultyLevel.damageAutobalance.ToString() + "</td>";
			text2 += "</tr>";
		}
		text2 += "</table>";
		exportWebPage("difficulties", text2, "htm", andOpen: true);
		exportWebPage("difficulties", text, "txt", andOpen: true);
	}

	private void importSpecialMoves()
	{
		StreamReader streamReader = readFile("specialMoves.txt");
		string[] array = streamReader.ReadToEnd().Split('\n');
		UnityEngine.Debug.LogError("Read " + array.Length + " special moves");
		for (int i = 0; i < array.Length; i++)
		{
			if (array[i] != "")
			{
				if (i >= specialModes.Length)
				{
					UnityEngine.Debug.LogError(i + ": " + array[i]);
				}
				specialMoves[i].importFromString(array[i]);
			}
		}
		streamReader.Close();
	}

	private void importAchievements()
	{
		StreamReader streamReader = readFile("achievements.txt");
		string[] array = streamReader.ReadToEnd().Split('\n');
		UnityEngine.Debug.LogError("Read " + array.Length + " achievements");
		for (int i = 0; i < array.Length; i++)
		{
			if (array[i] != "")
			{
				AchievementsController.instance.achievements[i].importFromString(array[i]);
			}
		}
		streamReader.Close();
	}

	private void importPerks()
	{
		StreamReader streamReader = readFile("perks.txt");
		string[] array = streamReader.ReadToEnd().Split('\n');
		UnityEngine.Debug.LogError("Read " + array.Length + " perks");
		for (int i = 0; i < array.Length; i++)
		{
			if (array[i] != "")
			{
				perks[i].importFromString(array[i]);
			}
		}
		streamReader.Close();
		streamReader = readFile("weaknesses.txt");
		array = streamReader.ReadToEnd().Split('\n');
		UnityEngine.Debug.LogError("Read " + array.Length + " weaknesses");
		for (int j = 0; j < array.Length; j++)
		{
			if (array[j] != "")
			{
				weaknesses[j].importFromString(array[j]);
			}
		}
		streamReader.Close();
	}

	private void importPressurePoints()
	{
		StreamReader streamReader = readFile("pressurePoints.txt");
		string[] array = streamReader.ReadToEnd().Split('\n');
		UnityEngine.Debug.LogError("Read " + array.Length + " pressure points");
		pressurePoints = new PressurePointData[array.Length - 1];
		for (int i = 0; i < array.Length - 1; i++)
		{
			if (array[i] != "")
			{
				if (pressurePoints[i] == null)
				{
					pressurePoints[i] = new PressurePointData();
				}
				pressurePoints[i].importFromString(array[i]);
			}
		}
		streamReader.Close();
	}

	private void importDifficultyLevels()
	{
		StreamReader streamReader = readFile("difficulties.txt");
		string[] array = streamReader.ReadToEnd().Split('\n');
		UnityEngine.Debug.LogError("Read " + array.Length + " lines");
		for (int i = 0; i < array.Length; i++)
		{
			if (array[i] != "")
			{
				Settings.instance.difficultyLevels[i].importFromString(array[i]);
			}
		}
		streamReader.Close();
	}

	private void importCharacters()
	{
		StreamReader streamReader = readFile("characters.txt");
		string[] array = streamReader.ReadToEnd().Split('\n');
		UnityEngine.Debug.LogError("Read characters, " + array.Length + " lines");
		for (int i = 0; i < array.Length; i++)
		{
			if (array[i] != "")
			{
				characters[i].importFromString(array[i]);
			}
		}
		streamReader.Close();
	}

	private void exportCharacters()
	{
		string text = "";
		string text2 = "<table>";
		string text3 = "<h1>Character Stories</h1>";
		text2 += "<tr>";
		text2 += "<th>Name</th>";
		text2 += "<th>Race</th>";
		text2 += "<th>Female</th>";
		text2 += "<th>Young</th>";
		text2 += "<th>Has Bio</th>";
		text2 += "<th>Has Ending</th>";
		text2 += "<th>Friend</th>";
		text2 += "<th>Special Move</th>";
		text2 += "<th>Perk</th>";
		text2 += "<th>Weakness</th>";
		text2 += "<th>Difficulty Tier</th>";
		text2 += "<th>Kick Amount</th>";
		text2 += "</tr>";
		CharacterData[] array = characters;
		foreach (CharacterData characterData in array)
		{
			text = text + characterData.exportString() + "\n";
			text3 = text3 + "<hr /><h2>" + characterData.name + "</h2>";
			text3 = text3 + "<p>" + characterData.bio + "</p>";
			text3 += "<h3>Ending</h3>";
			text3 = text3 + "<p>" + characterData.ending + "</p>";
			text2 += "<tr>";
			text2 = text2 + "<td>" + characterData.name + "</th>";
			text2 = text2 + "<td>" + characterData.race.ToString() + "</th>";
			text2 += boolTableCell(characterData.female);
			text2 += boolTableCell(characterData.young);
			text2 += boolTableCell(characterData.bio.Length > 10);
			text2 += boolTableCell(characterData.ending.Length > 10);
			text2 = text2 + "<td>" + characterData.friend + "</th>";
			text2 = text2 + "<td>" + characterData.specialMoveData(isPlayer: false).name + "</th>";
			text2 = text2 + "<td>" + characterData.perkName + "</th>";
			text2 = text2 + "<td>" + characterData.weaknessName + "</th>";
			text2 = text2 + "<td>" + characterData.difficultyTier.ToString() + "</th>";
			text2 = text2 + "<td>" + Mathf.Round(characterData.kickFrequency * 100f) + "%</th>";
			text2 += "</tr>";
		}
		text2 += "</table>";
		exportWebPage("characters", text2, "htm", andOpen: true);
		exportWebPage("characters", text, "txt", andOpen: true);
		exportWebPage("characterBios", text3, "htm", andOpen: true);
	}

	private string boolTableCell(bool value)
	{
		return "<td style=\"background-color:" + (value ? "#00FF00" : "#FF0000") + "\">&nbsp;</td>";
	}

	private void Update()
	{
		if (exportData)
		{
			exportData = false;
			if (Application.isEditor)
			{
				AchievementsController.instance.export();
				exportPerks();
				exportAchievements();
				exportSpecialMoves();
				exportPressurePoints();
				exportDifficultyLevels();
				exportCharacters();
			}
		}
		if (importData)
		{
			importData = false;
			if (Application.isEditor)
			{
				importPerks();
				importAchievements();
				importSpecialMoves();
				importPressurePoints();
				importSpecialMoves();
				importDifficultyLevels();
				importCharacters();
			}
		}
		if (logOptions > 0f)
		{
			logOptions -= Time.deltaTime;
			if (logOptions <= 0f)
			{
				WebLogging.log("Options", instance.optionsLog(), 0f);
				OptionData.changed = false;
			}
		}
		if (audioTest)
		{
			if (audioSource == null)
			{
				audioSource = base.gameObject.AddComponent<AudioSource>();
			}
			if (Input.GetKeyDown(KeyCode.V))
			{
				characters[audioTestNum].test = true;
				audioTestNum++;
				audioTestNum %= characters.Length;
			}
			CharacterData[] array = characters;
			foreach (CharacterData characterData in array)
			{
				if (characterData.test)
				{
					VoiceData voiceData = characterData.voice.IntroPhrase(UnityEngine.Random.value < 0.5f);
					if (voiceData != null)
					{
						audioSource.clip = voiceData.clip;
						GameController.instance.setAudioMixerGroup(audioSource, "Voice");
						audioSource.volume = characterData.voice.volume;
						audioSource.Play();
						UnityEngine.Debug.LogError(characterData.name + " voice");
					}
					else
					{
						UnityEngine.Debug.LogError(characterData.name + " has no intros");
					}
					characterData.test = false;
				}
			}
		}
		else if (audioSource != null)
		{
			UnityEngine.Object.Destroy(audioSource);
		}
	}
}
[Serializable]
public class GameModeData
{
	public string name;

	public string description;

	public string unlockInfo;

	public string[] tips;

	public bool saves;

	public int fixedLevel = -1;

	public bool enabled;

	public bool specialCharacters;

	public bool hasDifficultyLevels;

	public bool singleRound;

	public bool centralSpawn;

	public Texture thumbnail;

	public int best;

	public bool unlocked;

	public void localise()
	{
		LocalisationController.getText("Game Mode", name);
		LocalisationController.getText("Game Mode Description", description);
		LocalisationController.getText("Game Mode Unlock", unlockInfo);
		LocalisationController.getText("Unlock", name + " Mode Unlocked");
		if (singleRound)
		{
			LocalisationController.getText("Game Mode", name + " Leaderboard");
		}
		string[] array = tips;
		foreach (string text in array)
		{
			LocalisationController.getText("Game Mode (" + name + ") Tip", text);
		}
	}

	public string unlock()
	{
		unlocked = true;
		List<string> list = new List<string>();
		if (Saving.instance.savedProgress.unlockedModes != null)
		{
			string[] unlockedModes = Saving.instance.savedProgress.unlockedModes;
			foreach (string item in unlockedModes)
			{
				if (!list.Contains(item))
				{
					list.Add(item);
				}
			}
		}
		if (!list.Contains(name))
		{
			list.Add(name);
		}
		Saving.instance.savedProgress.unlockedModes = list.ToArray();
		Saving.saveProgress();
		return name + " Mode Unlocked";
	}
}
public class GameOverBoard : MonoBehaviour
{
	public TextMeshProUGUI lostReason;

	public TextMeshProUGUI finalScore;

	public TextMeshProUGUI best;

	private void Start()
	{
	}

	public void show(string message)
	{
		lostReason.text = message;
		finalScore.text = LocalisationController.getText("General", "Final Score:") + " " + GameData.instance.stars;
		best.text = LocalisationController.getText("General", "Best:") + " " + Saving.instance.savedProgress.stats.getStat("Master Stars").value;
	}

	private void Update()
	{
	}
}
[Serializable]
public class GameStat
{
	public string name;

	public float value;

	public string suffix;

	public string difficulty;

	public GameStat(string name)
	{
		this.name = name;
	}

	public string display()
	{
		return value + suffix;
	}
}
[Serializable]
public class GameStats
{
	public GameStat[] stats;

	public float saveTimer;

	public void incrementStat(string name, bool checkAchievement)
	{
		GameStat orAddStat = GetOrAddStat(name);
		orAddStat.value += 1f;
		saveTimer = 1f;
		if (checkAchievement)
		{
			AchievementsController.instance.checkStat(orAddStat);
		}
	}

	public void maxStat(string name, float value, bool checkAchievement, bool isInt, string suffix = "")
	{
		GameStat orAddStat = GetOrAddStat(name);
		if (value > orAddStat.value)
		{
			orAddStat.value = value;
		}
		orAddStat.suffix = suffix;
		saveTimer = 1f;
		if (checkAchievement)
		{
			AchievementsController.instance.checkStat(orAddStat);
		}
	}

	public void minStat(string name, float value, bool checkAchievement, bool isInt)
	{
		GameStat orAddStat = GetOrAddStat(name);
		if (value < orAddStat.value || orAddStat.value == 0f)
		{
			orAddStat.value = value;
		}
		saveTimer = 1f;
		if (checkAchievement)
		{
			AchievementsController.instance.checkStat(orAddStat);
		}
	}

	public GameStat getStat(string name, float defaultValue = 0f)
	{
		if (stats == null)
		{
			stats = new GameStat[0];
		}
		GameStat[] array = stats;
		foreach (GameStat gameStat in array)
		{
			if (gameStat.name == name)
			{
				return gameStat;
			}
		}
		return new GameStat(name)
		{
			value = defaultValue
		};
	}

	private GameStat GetOrAddStat(string name)
	{
		if (stats == null)
		{
			stats = new GameStat[0];
		}
		GameStat[] array = stats;
		foreach (GameStat gameStat in array)
		{
			if (gameStat.name == name)
			{
				return gameStat;
			}
		}
		GameStat[] array2 = new GameStat[stats.Length + 1];
		for (int j = 0; j < stats.Length; j++)
		{
			array2[j] = stats[j];
		}
		array2[stats.Length] = new GameStat(name);
		stats = array2;
		return array2[^1];
	}

	public void clear()
	{
		stats = new GameStat[0];
		saveTimer = 1f;
	}
}
public class GauntletTrackController : MonoBehaviour
{
	public Rigidbody block;

	public float accel = 1f;

	public float maxSpeed = 1f;

	public float maxDistance = 2.2f;

	public float threshHold = 0.5f;

	public float speed;

	private void Start()
	{
		block.transform.localPosition = Vector3.right * UnityEngine.Random.Range(0f - maxDistance, maxDistance);
	}

	private void Update()
	{
		if (GameController.instance == null)
		{
			return;
		}
		if (GameController.instance.player == null)
		{
			speed = Mathf.MoveTowards(speed, 0f, accel * Time.deltaTime / 5f);
		}
		else
		{
			Vector3 vector = GameController.instance.player.transform.transform.position - block.transform.position;
			float target = 0f;
			if (vector.z > 0f && vector.z < 2.5f)
			{
				if (vector.x > threshHold)
				{
					target = maxSpeed;
				}
				if (vector.x < 0f - threshHold)
				{
					target = 0f - maxSpeed;
				}
				speed = Mathf.MoveTowards(speed, target, accel * Time.deltaTime);
			}
			else
			{
				speed = Mathf.MoveTowards(speed, 0f, accel * Time.deltaTime / 5f);
			}
		}
		float x = block.transform.localPosition.x;
		x += speed * Time.deltaTime;
		if (x > maxDistance)
		{
			x = maxDistance;
			speed *= -1f;
		}
		if (x < 0f - maxDistance)
		{
			x = 0f - maxDistance;
			speed *= -1f;
		}
		block.transform.localPosition = new Vector3(x, block.transform.localPosition.y, block.transform.localPosition.z);
	}
}
public class GeneralCameraController : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
	}
}
public class GeneralChamberController : MonoBehaviour
{
	public StandButtonsController[] chamberContents;

	private void Start()
	{
		chamberContents[GameController.instance.scenes.generalChamber].gameObject.SetActive(value: true);
	}

	private void Update()
	{
	}
}
public class GeneralSounds : MonoBehaviour
{
	public static GeneralSounds instance;

	public static AudioSource audioSource;

	[Header("General Sounds")]
	public AudioClip[] sounds;

	[Header("Other Sounds")]
	public VoiceData[] femaleHurt_voice;

	public VoiceData[] maleHurt_voice;

	public AudioClip grab;

	public AudioClip release;

	private void Start()
	{
		instance = this;
		audioSource = GetComponent<AudioSource>();
	}

	public static void playSound(AudioClip clip, float volume = 1f)
	{
		if (!(clip == null))
		{
			audioSource.PlayOneShot(clip, volume);
		}
	}

	public static void playSound(int clip, float volume = 1f)
	{
		audioSource.PlayOneShot(instance.sounds[clip], volume);
	}
}
public class GlassesController : MonoBehaviour
{
	public LensController leftLens;

	public LensController rightLens;

	public bool test;

	public AudioSource audioSource;

	public void Start()
	{
	}

	public void smash(bool left)
	{
		if ((!left || !leftLens.gone) && (left || !rightLens.gone))
		{
			if ((bool)audioSource)
			{
				audioSource.Play();
			}
			if (left)
			{
				leftLens.nextStage();
			}
			else
			{
				rightLens.nextStage();
			}
		}
	}

	public void show(bool visible)
	{
		leftLens.gameObject.SetActive(visible);
		rightLens.gameObject.SetActive(visible);
	}

	private void Update()
	{
		if (test)
		{
			test = false;
			smash(left: true);
			smash(left: false);
		}
	}
}
public class GrabSpecialMove : Grabbable
{
	public string specialMoveName;

	public string specialMoveName_left;

	public SpecialMoveData specialMove;

	public SpecialMoveData specialMove_Left;

	private void Start()
	{
		if (!(GameController.instance == null))
		{
			if (grabCollider == null)
			{
				grabCollider = base.gameObject.AddComponent<SphereCollider>();
				grabCollider.radius *= 1.1f;
			}
			grabCollider.isTrigger = true;
			specialMove = GameController.instance.gameData.getSpecialMoveByName(specialMoveName);
			specialMove_Left = GameController.instance.gameData.getSpecialMoveByName(specialMoveName_left);
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		Hittable component = other.GetComponent<Hittable>();
		if (!(component == null) && component.isHand)
		{
			component.grabbables.Add(this);
		}
	}

	private void OnTriggerExit(Collider other)
	{
		Hittable component = other.GetComponent<Hittable>();
		if (!(component == null) && component.isHand)
		{
			component.grabbables.Remove(this);
		}
	}

	public override void grab(Muscle muscle)
	{
		Hittable component = muscle.transform.gameObject.GetComponent<Hittable>();
		GameCharacter character = component.rb.character;
		bool isLeftHand = component.bodyPart.isLeftHand;
		Transform attachTo = (isLeftHand ? character.hands.leftHand : character.hands.rightHand);
		Hittable hittable = (isLeftHand ? character.rigidBodies.leftHand : character.rigidBodies.rightHand);
		if (isLeftHand && specialMoveName_left != "")
		{
			specialMove_Left.addToHand(character, attachTo, hittable, fromGrab: true);
		}
		else
		{
			specialMove.addToHand(character, attachTo, hittable, fromGrab: true);
		}
		character.doingSpecial = 15f;
		base.gameObject.SetActive(value: false);
		component.grabbables.Remove(this);
	}

	public override void release()
	{
	}
}
public class Grabbable : MonoBehaviour
{
	public string gripName;

	private Transform originalParent;

	private Collider mainCollider;

	public SphereCollider grabCollider;

	private Rigidbody rb;

	private Vector3 velocity;

	private Vector3 lastPos;

	public float bounceSpeed;

	public float smashSpeed;

	public GrabbleSmashEffect smashEffect;

	public AudioClip[] bounceSounds;

	private AudioSource audioSource;

	private float smashTime;

	private bool smashed;

	public bool isCrockery;

	private Hittable thrower;

	private void Start()
	{
		audioSource = GetComponent<AudioSource>();
		if (audioSource == null)
		{
			UnityEngine.Debug.LogError("Grabbable: " + base.name + " has null audio source");
		}
		rb = GetComponent<Rigidbody>();
		if (rb == null)
		{
			UnityEngine.Debug.LogError("Null rigidbody on " + base.name + " (init)");
		}
		originalParent = base.transform.parent;
		mainCollider = GetComponent<Collider>();
		if (grabCollider == null)
		{
			grabCollider = base.gameObject.AddComponent<SphereCollider>();
			grabCollider.radius *= 1.1f;
			if (grabCollider.radius < 0.1f)
			{
				grabCollider.radius = 0.1f;
			}
		}
		grabCollider.isTrigger = true;
	}

	public void reset()
	{
		base.transform.SetParent(originalParent, worldPositionStays: true);
	}

	private void OnTriggerEnter(Collider other)
	{
		Hittable component = other.GetComponent<Hittable>();
		if (!(component == null) && component.isHand && !component.grabbables.Contains(this))
		{
			component.grabbables.Add(this);
		}
	}

	private void OnTriggerExit(Collider other)
	{
		Hittable component = other.GetComponent<Hittable>();
		if (!(component == null) && component.isHand)
		{
			component.grabbables.Remove(this);
		}
	}

	public virtual void grab(Muscle muscle)
	{
		if (!smashed)
		{
			base.transform.SetParent(muscle.target, worldPositionStays: true);
			rb.isKinematic = true;
			mainCollider.enabled = false;
			lastPos = base.transform.position;
			thrower = muscle.colliders[0].GetComponent<Hittable>();
		}
	}

	public virtual void release()
	{
		if (!smashed)
		{
			base.transform.SetParent(originalParent, worldPositionStays: true);
			mainCollider.enabled = true;
			rb.isKinematic = false;
			rb.velocity = velocity;
		}
	}

	private void smash()
	{
		UnityEngine.Object.Instantiate(smashEffect, base.transform.position, base.transform.rotation, GameController.instance.transform);
		UnityEngine.Object.Destroy(base.gameObject);
		smashed = true;
	}

	private void OnCollisionEnter(Collision collision)
	{
		if (rb == null || rb.isKinematic)
		{
			return;
		}
		Hittable component = collision.collider.GetComponent<Hittable>();
		if (component == null || component.rb == null || thrower == null || component.rb.character.team == thrower.rb.character.team || Time.time < smashTime)
		{
			return;
		}
		smashTime = Time.time + 0.2f;
		if (component.bodyPart != null)
		{
			float num = component.bodyPart.knockDownPerc * rb.velocity.magnitude * 0.05f;
			component.rb.Hit(rb.velocity, component, thrower.rb.character, num, num * 2f, collision.contacts[0].point, Hittable.HandHitType.General, skipPressurePoints: true, "");
			HitSoundsController.playSound(audioSource, component.bodyPart.hitType, num);
			HitEffects.addHitEffect(component.bodyPart.knockDownPerc > 0f, num, num * 2f, collision.contacts[0].point, collision.contacts[0].normal, base.gameObject.name + ">" + component.bodyPart.friendlyName, component.rb.character, component.bodyPart.knockDownPerc > 0f);
			if (isCrockery)
			{
				component.rb.setLastHit(RigidBodies.LastHit.Crockery, collision.contacts[0].point);
				if (component.bodyPart.isHead)
				{
					AchievementsController.achievement("Bad Waiter");
				}
			}
		}
		if (smashEffect == null)
		{
			smashTime += 2f;
		}
		else if (collision.relativeVelocity.magnitude > smashSpeed)
		{
			smash();
		}
		else if (collision.relativeVelocity.magnitude > bounceSpeed)
		{
			audioSource.PlayOneShot(bounceSounds[UnityEngine.Random.Range(0, bounceSounds.Length)]);
		}
	}

	private void Update()
	{
		velocity = (base.transform.position - lastPos) * 2f / Time.deltaTime;
		lastPos = base.transform.position;
	}
}
public class GrabbleSmashEffect : MonoBehaviour
{
	public AudioClip[] sounds;

	private AudioSource audioSource;

	public float lifeTime = 4f;

	private void Start()
	{
		audioSource = GetComponent<AudioSource>();
		audioSource.PlayOneShot(sounds[UnityEngine.Random.Range(0, sounds.Length)]);
		UnityEngine.Object.Destroy(base.gameObject, lifeTime);
		MeshCollider[] componentsInChildren = GetComponentsInChildren<MeshCollider>();
		foreach (MeshCollider meshCollider in componentsInChildren)
		{
			_ = lifeTime;
			_ = UnityEngine.Random.value;
			meshCollider.transform.SetParent(base.transform.parent, worldPositionStays: true);
			meshCollider.sharedMesh = meshCollider.GetComponent<MeshFilter>().sharedMesh;
			Rigidbody component = meshCollider.GetComponent<Rigidbody>();
			component.centerOfMass = meshCollider.transform.InverseTransformPoint(meshCollider.bounds.center);
			component.velocity = component.worldCenterOfMass - base.transform.position;
			component.velocity *= UnityEngine.Random.value * 20f + 10f;
			UnityEngine.Debug.DrawLine(component.worldCenterOfMass, component.worldCenterOfMass + component.velocity, Color.green, 1f);
		}
	}
}
[Serializable]
public class GripCode
{
	public string objectName;

	public string code;

	public GameObject gripping;
}
public class GripController : MonoBehaviour
{
	[Header("Settings")]
	public Collider toGrip;

	public int gripID = -1;

	private int wasGrip = -1;

	private Grips grips;

	[Header("Output")]
	public bool setFromCode;

	public GripFinger[] fingers;

	public Vector3[] gripRotations;

	public Vector3 relativePosition;

	public Vector3 relativeRotation;

	public bool done;

	private GripCode gc;

	public bool flip;

	private void Start()
	{
		grips = GetComponent<Grips>();
		wasGrip = gripID;
		grips.gripRotations = gripRotations;
		setFromCode = gripID > -1;
		fingers = new GripFinger[5];
		int num = 0;
		foreach (Transform item in base.transform)
		{
			fingers[num] = new GripFinger(item, gripRotations[num]);
			fingers[num].addDownTransform(new GameObject("DownDirection"));
			num++;
		}
		if (!setFromCode)
		{
			relativeRotation = (Quaternion.Inverse(base.transform.rotation) * toGrip.transform.rotation).eulerAngles;
			Vector3 vector = toGrip.transform.position - base.transform.position;
			relativePosition = Quaternion.Inverse(base.transform.rotation) * vector;
			relativeRotation = Tools.RoundVector3(relativeRotation);
			relativePosition = Tools.RoundVector3(relativePosition, 3);
			gc = new GripCode();
			gc.objectName = toGrip.name;
			gc.gripping = toGrip.gameObject;
			grips.codes.Add(gc);
			return;
		}
		SetGripFromCode(grips.codes[gripID].code);
		num = 0;
		foreach (GripCode code in grips.codes)
		{
			code.gripping.SetActive(num == gripID);
			num++;
		}
	}

	public void SetGripFromCode(string code)
	{
		string[] array = code.Split('|');
		if (array.Length < 3)
		{
			UnityEngine.Debug.LogError("Error with code: " + code);
			return;
		}
		relativePosition = stringToVect(array[0], flip: false);
		if (flip)
		{
			relativePosition.x *= -1f;
		}
		relativeRotation = stringToVect(array[1], flip);
		int num = 2;
		GripFinger[] array2 = fingers;
		for (int i = 0; i < array2.Length; i++)
		{
			array2[i].SetFromCode(array[num], flip);
			num++;
		}
	}

	public static Vector3 stringToVect(string s, bool flip)
	{
		string[] array = s.Split(':');
		Vector3 result = new Vector3(float.Parse(array[0], CultureInfo.CreateSpecificCulture("en-US")), float.Parse(array[1], CultureInfo.CreateSpecificCulture("en-US")), float.Parse(array[2], CultureInfo.CreateSpecificCulture("en-US")));
		if (flip)
		{
			result.y *= -1f;
			result.z *= -1f;
		}
		return result;
	}

	private void Update()
	{
		if (!setFromCode)
		{
			string text = "";
			text = text + relativePosition.x + ":" + relativePosition.y + ":" + relativePosition.z + "|";
			text = text + relativeRotation.x + ":" + relativeRotation.y + ":" + relativeRotation.z;
			done = true;
			GripFinger[] array = fingers;
			foreach (GripFinger gripFinger in array)
			{
				gripFinger.Update(Time.deltaTime, toGrip);
				text = text + "|" + gripFinger.code;
				if (gripFinger.code == "")
				{
					done = false;
				}
			}
			if (done)
			{
				gc.code = text;
			}
		}
		else if (wasGrip != gripID)
		{
			wasGrip = gripID;
			int num = 0;
			foreach (GripCode code in grips.codes)
			{
				code.gripping.SetActive(num == gripID);
				num++;
			}
			SetGripFromCode(grips.codes[gripID].code);
		}
		toGrip.transform.position = base.transform.position + base.transform.rotation * relativePosition;
		toGrip.transform.rotation = base.transform.rotation * Quaternion.Euler(relativeRotation);
	}
}
[Serializable]
public class GripFinger
{
	public string name;

	public Transform[] joints;

	public Vector3[] rotations;

	public Vector3 gripRotation;

	[Range(0f, 1f)]
	public float gripPerc;

	public float curling;

	public bool isThumb;

	public string code;

	private Transform downDirection;

	public GripFinger(Transform root, Vector3 gripRotation)
	{
		name = root.name;
		isThumb = root.name.Contains("thumb");
		curling = 1f;
		this.gripRotation = gripRotation;
		List<Transform> list = new List<Transform>();
		List<Vector3> list2 = new List<Vector3>();
		Transform transform = root;
		for (int i = 0; i < 10; i++)
		{
			list.Add(transform);
			list2.Add(transform.localRotation.eulerAngles);
			if (transform.childCount == 0)
			{
				break;
			}
			transform = transform.GetChild(0);
		}
		joints = list.ToArray();
		rotations = list2.ToArray();
	}

	public void addDownTransform(GameObject newDir)
	{
		newDir.transform.SetParent(joints[joints.Length - 1], worldPositionStays: false);
		newDir.transform.localPosition = (isThumb ? new Vector3(0f, -0.1f, 0f) : Vector3.zero);
		newDir.transform.rotation = Quaternion.LookRotation(isThumb ? Vector3.right : Vector3.down);
		downDirection = newDir.transform;
	}

	public void SetFromCode(string code, bool flip)
	{
		string[] array = code.Split(',');
		for (int i = 0; i < array.Length; i++)
		{
			joints[i].localRotation = Quaternion.Euler(GripController.stringToVect(array[i], flip));
		}
	}

	public void Update(float delta, Collider collider)
	{
		if (curling > 0f)
		{
			if (Physics.Raycast(downDirection.position, downDirection.forward, 0.1f * curling) || Physics.Raycast(downDirection.position, downDirection.up, 0.1f * curling) || Physics.Raycast(downDirection.position, downDirection.right, 0.1f * curling))
			{
				curling /= 2f;
				if ((double)curling < 0.01)
				{
					curling = 0f;
				}
			}
			else
			{
				gripPerc += delta * curling;
				if (gripPerc >= 1f)
				{
					gripPerc = 1f;
					curling = 0f;
				}
			}
		}
		code = "";
		bool flag = true;
		for (int i = 0; i < joints.Length - 1; i++)
		{
			joints[i].localRotation = Quaternion.Euler(rotations[i]) * Quaternion.Euler(gripRotation * gripPerc);
			if (code != "")
			{
				code += ",";
			}
			if (curling == 0f)
			{
				Vector3 eulerAngles = joints[i].localRotation.eulerAngles;
				eulerAngles.x = Mathf.Round(eulerAngles.x);
				eulerAngles.y = Mathf.Round(eulerAngles.y);
				eulerAngles.z = Mathf.Round(eulerAngles.z);
				joints[i].localRotation = Quaternion.Euler(eulerAngles);
				code = code + eulerAngles.x + ":" + eulerAngles.y + ":" + eulerAngles.z;
			}
			else
			{
				code += "...";
				flag = false;
			}
			if (!flag)
			{
				code = "";
			}
		}
	}
}
[Serializable]
public class GripFingerSimple
{
	public string name;

	public Transform[] joints;

	public Vector3[] rotations;

	public Vector3 gripRotation;

	public bool isThumb;

	public GripFingerSimple(Transform root, Vector3 gripRotation)
	{
		name = root.name;
		isThumb = root.name.Contains("thumb");
		this.gripRotation = gripRotation;
		List<Transform> list = new List<Transform>();
		List<Vector3> list2 = new List<Vector3>();
		Transform transform = root;
		for (int i = 0; i < 10; i++)
		{
			list.Add(transform);
			list2.Add(transform.localRotation.eulerAngles);
			if (transform.childCount == 0)
			{
				break;
			}
			transform = transform.GetChild(0);
		}
		joints = list.ToArray();
		rotations = list2.ToArray();
	}

	public void SetFromCode(string code, bool flip)
	{
		string[] array = code.Split(',');
		for (int i = 0; i < array.Length; i++)
		{
			joints[i].localRotation = Quaternion.Euler(GripController.stringToVect(array[i], flip));
		}
	}
}
public class Grips : MonoBehaviour
{
	public List<GripCode> codes;

	public Vector3[] gripRotations;

	[Header("Current Grip")]
	private Transform leftHand;

	private Transform rightHand;

	public Vector3 r_relativePosition;

	public Vector3 r_relativeRotation;

	public Vector3 l_relativePosition;

	public Vector3 l_relativeRotation;

	public GripFingerSimple[] l_fingers;

	public GripFingerSimple[] r_fingers;

	public void Setup(Transform leftHand, Transform rightHand)
	{
		this.leftHand = leftHand;
		this.rightHand = rightHand;
		if (l_fingers.Length == 0)
		{
			l_fingers = new GripFingerSimple[5];
			int num = 0;
			foreach (Transform item in leftHand)
			{
				l_fingers[num] = new GripFingerSimple(item, gripRotations[num]);
				num++;
				if (num >= l_fingers.Length)
				{
					break;
				}
			}
		}
		if (r_fingers.Length != 0)
		{
			return;
		}
		r_fingers = new GripFingerSimple[5];
		int num2 = 0;
		foreach (Transform item2 in rightHand)
		{
			r_fingers[num2] = new GripFingerSimple(item2, gripRotations[num2]);
			num2++;
			if (num2 >= r_fingers.Length)
			{
				break;
			}
		}
	}

	public void SetFromCode(string name, bool rightHand, Grabbable itemGrab = null)
	{
		string[] array = GetCodeByName(name).code.Split('|');
		r_relativePosition = stringToVect(array[0], flip: false);
		r_relativeRotation = stringToVect(array[1], flip: false);
		l_relativePosition = stringToVect(array[0], flip: false);
		l_relativePosition.x *= -1f;
		l_relativeRotation = stringToVect(array[1], flip: true);
		GripFingerSimple[] obj = (rightHand ? r_fingers : l_fingers);
		int num = 2;
		GripFingerSimple[] array2 = obj;
		for (int i = 0; i < array2.Length; i++)
		{
			array2[i].SetFromCode(array[num], !rightHand);
			num++;
		}
		if (itemGrab != null)
		{
			Transform transform = (rightHand ? this.rightHand : leftHand);
			if (rightHand)
			{
				itemGrab.transform.position = transform.position + transform.rotation * r_relativePosition;
				itemGrab.transform.rotation = transform.rotation * Quaternion.Euler(r_relativeRotation);
			}
			else
			{
				itemGrab.transform.position = transform.position + transform.rotation * l_relativePosition;
				itemGrab.transform.rotation = transform.rotation * Quaternion.Euler(l_relativeRotation);
			}
		}
	}

	public GripCode GetCodeByName(string name)
	{
		foreach (GripCode code in codes)
		{
			if (code.objectName == name)
			{
				return code;
			}
		}
		UnityEngine.Debug.LogError("Couldn't find grip: " + name);
		return null;
	}

	public static Vector3 stringToVect(string s, bool flip)
	{
		string[] array = s.Split(':');
		Vector3 result = new Vector3(float.Parse(array[0], CultureInfo.CreateSpecificCulture("en-US")), float.Parse(array[1], CultureInfo.CreateSpecificCulture("en-US")), float.Parse(array[2], CultureInfo.CreateSpecificCulture("en-US")));
		if (flip)
		{
			result.y *= -1f;
			result.z *= -1f;
		}
		return result;
	}
}
public class GuillotineController : ProjectileController
{
	public Transform blades;

	public float bladeSpinPerc;

	public float bladeSpinWindupTime;

	public float bladeSpinSpeed;

	public GameCharacter target;

	private float targetTimer = 0.5f;

	public float maxSpeed = 5f;

	public float accelerate = 5f;

	private void Start()
	{
	}

	private void getTarget()
	{
		float num = 1000f;
		target = null;
		Quaternion a = Quaternion.LookRotation(velocity);
		foreach (GameCharacter player in GameController.instance.players)
		{
			if (player.team != firer.team && !player.rigidBodies.isDown(allTheWay: true))
			{
				Quaternion b = Quaternion.LookRotation(player.rigidBodies.head.transform.position - base.transform.position);
				float num2 = Quaternion.Angle(a, b);
				if (num2 < num)
				{
					num = num2;
					target = player;
				}
			}
		}
	}

	public override void OnCollisionEnter(Collision collision)
	{
		if (!(Time.time < startTime + minTime) && !(collision.contacts[0].thisCollider.name != "BladeCollider"))
		{
			collideWith(collision.collider, collision.contacts[0].point, collision.contacts[0].normal);
		}
	}

	public override void OnHit(Hittable hittable, Collider collider, Vector3 point, Vector3 normal)
	{
		if (revertTimer < 0f)
		{
			return;
		}
		bladeSpinPerc /= 2f;
		revertTimer -= 0.5f;
		if (hittable != null)
		{
			if (hitPersonEffect != null)
			{
				UnityEngine.Object.Instantiate(hitPersonEffect, point, Quaternion.LookRotation(normal), null);
			}
			audioSource.PlayOneShot(hitSound, 1f);
			hittable.rb.Hit(velocity, hittable, firer, damage * bladeSpinPerc, damage * bladeSpinPerc, point, Hittable.HandHitType.Blade, skipPressurePoints: true, "Guillotine");
			velocity = -velocity.normalized * maxSpeed / 2f;
		}
		else
		{
			velocity = -velocity.normalized * maxSpeed / 2f;
			audioSource.PlayOneShot(hitFloorSound);
		}
	}

	public override void flyingMovement()
	{
		targetTimer -= Time.deltaTime;
		if (targetTimer < 0f)
		{
			targetTimer += 0.25f;
			getTarget();
		}
		if (target != null)
		{
			Vector3 vector = target.rigidBodies.head.transform.position - base.transform.position;
			velocity = Vector3.MoveTowards(velocity, vector.normalized * maxSpeed, Time.deltaTime * accelerate);
		}
		base.transform.rotation = Quaternion.RotateTowards(base.transform.rotation, Quaternion.identity, Time.deltaTime * 45f);
		bladeSpinPerc = Mathf.MoveTowards(bladeSpinPerc, 1f, Time.deltaTime / bladeSpinWindupTime);
		blades.localRotation *= Quaternion.Euler(0f, 0f, bladeSpinSpeed * bladeSpinPerc * Time.deltaTime);
		continualAudio.volume = bladeSpinPerc;
		base.transform.position += velocity * Time.deltaTime;
	}
}
public class HUDController : MonoBehaviour
{
	public GameController game;

	public HealthBarController healthBarPrefab;

	public float healthBarSpacing;

	public HealthBarController[] healthBars;

	public TextMeshProUGUI fps;

	public void setup()
	{
		HealthBarController[] array = healthBars;
		for (int i = 0; i < array.Length; i++)
		{
			UnityEngine.Object.Destroy(array[i].gameObject);
		}
		healthBars = new HealthBarController[game.players.Count];
		for (int j = 0; j < game.players.Count; j++)
		{
			healthBars[j] = UnityEngine.Object.Instantiate(healthBarPrefab, base.transform);
			healthBars[j].transform.localPosition = new Vector3(0f, (float)(-j) * healthBarSpacing);
			healthBars[j].update(game.players[j]);
		}
	}

	private void Update()
	{
		for (int i = 0; i < game.players.Count; i++)
		{
			healthBars[i].update(game.players[i]);
		}
		fps.text = "FPS: " + Mathf.Round(game.fps);
	}
}
public class HandMeterController : MonoBehaviour
{
	public Vector3 pos;

	public Vector3 rot;

	public Canvas container;

	public Image bar;

	public Image maxBar;

	public Image kickBar;

	public TextMeshProUGUI scoreText;

	public Image[] otherImages;

	private bool isHealth;

	private RigidBodies rigidBodies;

	public Color offColour;

	public Color highlightColour;

	public float highlightPerc = 1f;

	public TextMeshProUGUI fps;

	public EffectCirclesController circles;

	private bool moveReady;

	private float fpsInterval;

	private float pulseTime;

	private void Start()
	{
		base.transform.localPosition = pos;
		base.transform.localRotation = Quaternion.Euler(rot);
	}

	public void reposition()
	{
		Invoke("doRepo", 0.1f);
	}

	private void doRepo()
	{
		base.transform.localPosition *= base.transform.localScale.x;
	}

	public void setup(RigidBodies rigidBodies, bool isHealth)
	{
		this.rigidBodies = rigidBodies;
		this.isHealth = isHealth;
		if (scoreText != null)
		{
			scoreText.gameObject.SetActive(GameController.instance.specialMode.singleRound);
		}
	}

	public void setToHealth()
	{
		circles.player = rigidBodies.character;
		bar.fillAmount = rigidBodies.standUpPerc;
		maxBar.fillAmount = rigidBodies.standUpPercMax;
		Color healthBarColour = rigidBodies.character.data.healthBarColour;
		Color a = healthBarColour;
		pulseTime -= Time.deltaTime * 5f;
		if (pulseTime < 0f)
		{
			pulseTime = 1f;
		}
		if (circles.player.hasEffect(CharacterEffect.Effect.Drunk))
		{
			a = Color.Lerp(healthBarColour, Color.yellow, pulseTime * circles.player.getEffect(CharacterEffect.Effect.Drunk).perc);
		}
		else if (circles.player.hasEffect(CharacterEffect.Effect.Pain))
		{
			a = Color.Lerp(healthBarColour, Color.red, pulseTime * circles.player.getEffect(CharacterEffect.Effect.Pain).perc);
		}
		else if (circles.player.hasEffect(CharacterEffect.Effect.Sickness))
		{
			a = Color.Lerp(healthBarColour, Color.green, pulseTime * circles.player.getEffect(CharacterEffect.Effect.Sickness).perc);
		}
		Color color = Color.Lerp(a, Color.white, rigidBodies.hitRecovery);
		bar.color = color;
		maxBar.color = healthBarColour * 0.65f;
		kickBar.fillAmount = rigidBodies.character.kickController.kickStamina;
		for (int i = 0; i < otherImages.Length; i++)
		{
			otherImages[i].color = ((rigidBodies.character.lives > i) ? Color.white : Color.black);
			if (GameController.instance.specialMode.singleRound)
			{
				otherImages[i].gameObject.SetActive(value: false);
			}
		}
		if (scoreText != null && scoreText.gameObject.activeInHierarchy)
		{
			scoreText.text = GameController.instance.specialModeScore.ToString();
		}
	}

	public void highlight(Color highlightColour)
	{
		highlightPerc = 1f;
		this.highlightColour = highlightColour;
	}

	public void setToQi()
	{
		bar.fillAmount = rigidBodies.specialPerc;
		Color color = Color.Lerp((rigidBodies.specialPerc < 1f) ? Settings.instance.colour_qi_empty : Settings.instance.colour_qi, highlightColour, highlightPerc);
		Image image = bar;
		Color color3 = (otherImages[0].color = color);
		image.color = color3;
		if (rigidBodies.specialPerc >= 1f)
		{
			if (!moveReady)
			{
				GeneralSounds.playSound(4);
				GameController.instance.gameData.ShowVRTip(5);
				moveReady = true;
			}
		}
		else
		{
			moveReady = false;
		}
		fpsInterval -= Time.deltaTime;
		if (fpsInterval < 0f)
		{
			fps.text = (OptionData.getBool("FPS Display") ? ("FPS:\n" + Mathf.Round(1f / Time.deltaTime)) : "");
			fpsInterval = 0.5f;
		}
		highlightPerc = Mathf.MoveTowards(highlightPerc, 0f, Time.deltaTime);
	}

	public void Update()
	{
		if (rigidBodies == null)
		{
			container.gameObject.SetActive(value: false);
			UnityEngine.Object.Destroy(base.gameObject);
			return;
		}
		bool flag = false;
		if (Camera.main != null && rigidBodies.character.isPlayer() && rigidBodies.character.playerController.inBody && !rigidBodies.fall.falling)
		{
			Quaternion a = Quaternion.LookRotation(Camera.main.transform.position - base.transform.position);
			Quaternion b = Quaternion.LookRotation(base.transform.forward);
			flag = Quaternion.Angle(a, b) < 45f;
			if (!flag && isHealth && rigidBodies.character.hasVisibleEffect())
			{
				flag = true;
			}
			if (flag)
			{
				if ((!OptionData.getBool("Always Meters") && GameController.instance.fightState != GameController.FightState.During) || !rigidBodies.character.isPlayer())
				{
					flag = false;
				}
				else if (isHealth)
				{
					setToHealth();
					flag = GameController.instance.difficultyLevel.yourHealthBar || OptionData.getBool("Always Meters");
				}
				else
				{
					setToQi();
					flag = OptionData.getBool("Special Moves") && (GameController.instance.difficultyLevel.yourQiBar || OptionData.getBool("Always Meters"));
				}
			}
		}
		container.gameObject.SetActive(flag);
	}
}
public class HandOrFootEffect : SpecialMoveAttachedEffect
{
	public bool hands;

	public Transform[] toAttach;

	private bool done;

	public override void setup(GameCharacter character)
	{
		Vector3[] array = new Vector3[2]
		{
			toAttach[0].transform.localPosition,
			toAttach[1].transform.localPosition
		};
		if (!hands)
		{
			toAttach[0].SetParent(character.rigidBodies.leftFoot.transform, worldPositionStays: false);
			toAttach[1].SetParent(character.rigidBodies.rightFoot.transform, worldPositionStays: false);
		}
		else
		{
			toAttach[0].SetParent(character.rigidBodies.leftHand.transform, worldPositionStays: false);
			toAttach[1].SetParent(character.rigidBodies.rightHand.transform, worldPositionStays: false);
		}
		toAttach[0].transform.localPosition = array[0];
		toAttach[1].transform.localPosition = array[1];
		base.setup(character);
	}

	public override void end()
	{
		if (!done)
		{
			done = true;
			UnityEngine.Object.Destroy(toAttach[0].gameObject);
			UnityEngine.Object.Destroy(toAttach[1].gameObject);
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}
}
[Serializable]
public class HandPosition
{
	public enum Position
	{
		None,
		Open,
		Fist,
		Claw,
		Finger,
		TwoFinger,
		Knuckle,
		SnakeTakeToad,
		Custom
	}

	public string name;

	public Position position;

	[Header("Editing")]
	public bool update_l;

	public bool update_r;

	public bool copyRtoL;

	public bool copyLtoR;

	public bool test;

	[Header("Skeleton")]
	public bool replacesPalm;

	public bool replacesFist;

	public bool replacesClaw;

	public bool index;

	public bool middle;

	public bool ring;

	public bool pinky;

	[Header("Data")]
	public Vector3[] r_rotations;

	public Vector3[] l_rotations;

	public bool match(int pos, float indexCurl, float middleCurl, float ringCurl, float pinkyCurl)
	{
		if ((pos != 0 || !replacesPalm) && (pos != 2 || !replacesClaw))
		{
			return false;
		}
		float num = 0.5f;
		if (indexCurl < num != index)
		{
			return false;
		}
		if (middleCurl < num != middle)
		{
			return false;
		}
		if (ringCurl < num != ring)
		{
			return false;
		}
		if (pinkyCurl < num != pinky)
		{
			return false;
		}
		return true;
	}
}
public class HandPositions : MonoBehaviour
{
	public bool[] curlTest = new bool[4];

	public RigidBodies puppet;

	public CharacterData characterData;

	public Transform rightHand;

	public Transform leftHand;

	public bool active = true;

	public Transform[] r_bones;

	public Transform[] l_bones;

	public HandPosition[] handPositions;

	public int setTo = -1;

	public VRCharacterActions vrActions;

	public bool useSkeleton;

	public float r_squeezeAmount;

	public float l_squeezeAmount;

	public float r_squeezeAmount_secondary;

	public float l_squeezeAmount_secondary;

	public PuppetTrackerHandOffset l_offset;

	public PuppetTrackerHandOffset r_offset;

	public float squeezeSensitivity = 1f;

	public float rotateSpeed = 45f;

	public Vector3 r_handRotation_Offset;

	public Vector3 r_handRotation;

	public Vector3 l_handRotation_Offset;

	public Vector3 l_handRotation;

	public Grips grips;

	private void Start()
	{
		if (!(puppet == null))
		{
			if (r_bones.Length == 0)
			{
				r_bones = getBones(rightHand);
			}
			if (l_bones.Length == 0)
			{
				l_bones = getBones(leftHand);
			}
			r_handRotation_Offset = rightHand.transform.localRotation.eulerAngles;
			l_handRotation_Offset = leftHand.transform.localRotation.eulerAngles;
		}
	}

	public void setup(RigidBodies puppet, PuppetMaster puppetMaster, CharacterData characterData)
	{
		this.characterData = characterData;
		this.puppet = puppet;
		Muscle[] muscles = puppetMaster.muscles;
		foreach (Muscle muscle in muscles)
		{
			if (muscle.name == "hand_r")
			{
				rightHand = muscle.target;
			}
			if (muscle.name == "hand_l")
			{
				leftHand = muscle.target;
			}
			if (muscle.name == "hand.R")
			{
				rightHand = muscle.target;
			}
			if (muscle.name == "hand.L")
			{
				leftHand = muscle.target;
			}
		}
		r_bones = getBones(rightHand);
		l_bones = getBones(leftHand);
		r_handRotation_Offset = rightHand.transform.localRotation.eulerAngles;
		l_handRotation_Offset = leftHand.transform.localRotation.eulerAngles;
	}

	private Transform[] getBones(Transform hand)
	{
		Transform[] componentsInChildren = hand.GetComponentsInChildren<Transform>();
		List<Transform> list = new List<Transform>();
		Transform[] array = componentsInChildren;
		foreach (Transform transform in array)
		{
			if (!transform.name.Contains("Prop M") && !transform.name.Contains("Additional"))
			{
				list.Add(transform);
			}
		}
		return list.ToArray();
	}

	private float snapSqueeze(float squeeze, bool index = false)
	{
		float num = (index ? 0.6f : 0.6f);
		float num2 = ((!index) ? 1 : 2);
		if (squeeze < num)
		{
			return 0f;
		}
		return Mathf.Clamp01((squeeze - num) * num2 / (1f - num));
	}

	private Quaternion fingerBoneTarget(float handSqueeze, int i, Transform[] bones, bool isLeft)
	{
		int num = 0;
		int num2 = 1;
		float t = snapSqueeze(handSqueeze);
		if (isLeft)
		{
			if (0f - l_handRotation.y > 30f && 0f - l_handRotation.y < 90f)
			{
				num = (int)(characterData.secondaryPalmPosition - 1);
			}
		}
		else if (r_handRotation.y > 30f && r_handRotation.y < 90f)
		{
			num = (int)(characterData.secondaryPalmPosition - 1);
		}
		if (num < 0 || num >= handPositions.Length)
		{
			UnityEngine.Debug.LogError("Open pos: " + num);
		}
		if (num2 < 0 || num2 >= handPositions.Length)
		{
			UnityEngine.Debug.LogError("closedPos pos: " + num);
		}
		if (isLeft)
		{
			return Quaternion.Lerp(Quaternion.Euler(handPositions[num].l_rotations[i]), Quaternion.Euler(handPositions[num2].l_rotations[i]), t);
		}
		return Quaternion.Lerp(Quaternion.Euler(handPositions[num].r_rotations[i]), Quaternion.Euler(handPositions[num2].r_rotations[i]), t);
	}

	private void Update()
	{
		if (rightHand == null || GameController.instance == null || GameController.instance.paused)
		{
			return;
		}
		useSkeleton = puppet.character != null && puppet.character.isPlayer() && GameController.instance.gameData.vrProfile.allowFingerTracking && OptionData.getBool("Finger Tracking");
		useSkeleton = puppet.character != null && puppet.character.isPlayer() && OptionData.getBool("Finger Tracking");
		r_handRotation = rightHand.transform.localRotation.eulerAngles - r_handRotation_Offset;
		r_handRotation.x = Mathf.Round(r_handRotation.x);
		r_handRotation.y = Mathf.Round(r_handRotation.y);
		r_handRotation.z = Mathf.Round(r_handRotation.z);
		l_handRotation = leftHand.transform.localRotation.eulerAngles - l_handRotation_Offset;
		l_handRotation.x = Mathf.Round(l_handRotation.x);
		l_handRotation.y = Mathf.Round(l_handRotation.y);
		l_handRotation.z = Mathf.Round(l_handRotation.z);
		int num = -1;
		HandPosition[] array = handPositions;
		foreach (HandPosition handPosition in array)
		{
			num++;
			if (handPosition.test)
			{
				setTo = num;
				handPosition.test = false;
			}
			if (handPosition.copyRtoL)
			{
				handPosition.copyRtoL = false;
				UnityEngine.Debug.LogError("Copy right hand to left hand");
				for (int j = 0; j < r_bones.Length; j++)
				{
					Vector3 eulerAngles = r_bones[j].localRotation.eulerAngles;
					l_bones[j].localRotation = Quaternion.Euler(eulerAngles.x, 0f - eulerAngles.y, 0f - eulerAngles.z);
				}
			}
			if (handPosition.copyLtoR)
			{
				handPosition.copyLtoR = false;
				UnityEngine.Debug.LogError("Copy right hand to left hand");
				for (int k = 0; k < r_bones.Length; k++)
				{
					Vector3 eulerAngles2 = l_bones[k].localRotation.eulerAngles;
					r_bones[k].localRotation = Quaternion.Euler(eulerAngles2.x, 0f - eulerAngles2.y, 0f - eulerAngles2.z);
				}
			}
			if (handPosition.update_l)
			{
				handPosition.update_l = false;
				UnityEngine.Debug.LogError("Copy left hand data to editor");
				if (active)
				{
					UnityEngine.Debug.LogError("Cant update in active mode");
				}
				else
				{
					handPosition.l_rotations = new Vector3[l_bones.Length];
					for (int l = 0; l < l_bones.Length; l++)
					{
						handPosition.l_rotations[l] = l_bones[l].localRotation.eulerAngles;
					}
				}
			}
			if (!handPosition.update_r)
			{
				continue;
			}
			handPosition.update_r = false;
			UnityEngine.Debug.LogError("Copy right hand data to editor");
			if (active)
			{
				UnityEngine.Debug.LogError("Cant update in active mode");
				continue;
			}
			handPosition.r_rotations = new Vector3[r_bones.Length];
			for (int m = 0; m < r_bones.Length; m++)
			{
				handPosition.r_rotations[m] = r_bones[m].localRotation.eulerAngles;
			}
		}
		if (puppet.character != null && puppet.character.isPlayer() && !puppet.character.hasEffect(CharacterEffect.Effect.Paralysed))
		{
			r_squeezeAmount = Mathf.Clamp01(vrActions.squeeze(right: true) * squeezeSensitivity);
			l_squeezeAmount = Mathf.Clamp01(vrActions.squeeze(right: false) * squeezeSensitivity);
			r_squeezeAmount_secondary = Mathf.Clamp01(vrActions.squeezeSecondary(right: true) * squeezeSensitivity);
			l_squeezeAmount_secondary = Mathf.Clamp01(vrActions.squeezeSecondary(right: false) * squeezeSensitivity);
		}
		if (!active && setTo != -1)
		{
			if (handPositions[setTo].r_rotations.Length != 0)
			{
				for (int n = 0; n < r_bones.Length; n++)
				{
					float t = r_squeezeAmount;
					Quaternion localRotation = Quaternion.Lerp(Quaternion.Euler(handPositions[setTo].r_rotations[n]), Quaternion.Euler(handPositions[1].r_rotations[n]), t);
					r_bones[n].localRotation = localRotation;
				}
			}
			if (handPositions[setTo].l_rotations.Length != 0)
			{
				for (int num2 = 0; num2 < l_bones.Length; num2++)
				{
					float t2 = l_squeezeAmount;
					Quaternion localRotation2 = Quaternion.Lerp(Quaternion.Euler(handPositions[setTo].l_rotations[num2]), Quaternion.Euler(handPositions[1].l_rotations[num2]), t2);
					l_bones[num2].localRotation = localRotation2;
				}
			}
			setTo = -1;
		}
		if (!active)
		{
			return;
		}
		SpecialMoveData specialMoveData = null;
		if (puppet != null && puppet.character != null && puppet.character.doingSpecial > 0f)
		{
			specialMoveData = puppet.character.doingSpecialData;
		}
		for (int num3 = 0; num3 < 2; num3++)
		{
			Transform[] array2 = ((num3 == 0) ? l_bones : r_bones);
			HandPosition.Position position = HandPosition.Position.None;
			if (specialMoveData != null)
			{
				position = ((num3 == 0) ? specialMoveData.l_handPosition : specialMoveData.r_handPosition);
			}
			if (puppet.character != null)
			{
				if (puppet.character.override_l_handPosition != 0 && num3 == 0)
				{
					position = puppet.character.override_l_handPosition;
				}
				if (puppet.character.override_r_handPosition != 0 && num3 == 1)
				{
					position = puppet.character.override_r_handPosition;
				}
			}
			Grabbable grabbable = null;
			bool flag = false;
			if (puppet != null && puppet.leftHand != null)
			{
				if (num3 == 0 && puppet.leftHand.grabbed != null)
				{
					grabbable = puppet.leftHand.grabbed;
				}
				if (num3 == 1 && puppet.rightHand.grabbed != null)
				{
					grabbable = puppet.rightHand.grabbed;
				}
				if (num3 == 0 && puppet.leftHand.grabHittable != null)
				{
					flag = true;
				}
				if (num3 == 1 && puppet.rightHand.grabHittable != null)
				{
					flag = true;
				}
			}
			if (flag)
			{
				grips.Setup(leftHand, rightHand);
				grips.SetFromCode("Cup", num3 != 0);
			}
			else if (position == HandPosition.Position.Custom)
			{
				grips.Setup(leftHand, rightHand);
				grips.SetFromCode(specialMoveData.customPosition, num3 != 0);
			}
			else if (grabbable != null)
			{
				if (grabbable.gripName != "")
				{
					grips.Setup(leftHand, rightHand);
					grips.SetFromCode(grabbable.gripName, num3 != 0, grabbable);
				}
			}
			else
			{
				for (int num4 = 0; num4 < array2.Length; num4++)
				{
					Quaternion to = ((position == HandPosition.Position.None) ? ((num3 != 0) ? fingerBoneTarget((num4 <= 4) ? r_squeezeAmount : r_squeezeAmount_secondary, num4, array2, isLeft: false) : fingerBoneTarget((num4 <= 4) ? l_squeezeAmount : l_squeezeAmount_secondary, num4, array2, isLeft: true)) : ((num3 != 0) ? Quaternion.Euler(handPositions[(int)(position - 1)].r_rotations[num4]) : Quaternion.Euler(handPositions[(int)(position - 1)].l_rotations[num4])));
					array2[num4].localRotation = Quaternion.RotateTowards(array2[num4].localRotation, to, Time.deltaTime * rotateSpeed * ((puppet.character == null) ? 1f : puppet.character.moveSpeedMod()));
				}
			}
		}
	}
}
public class HeadRecoil : MonoBehaviour
{
	public Vector3 recoilDirection;

	public Vector3 offset;

	public Vector3 angleOffset;

	public float recoilSpeed = 0.5f;

	public float recoilDist = 0.5f;

	public float minRecoilPower = 0.25f;

	private float recoilMaxAngle = 55f;

	[Range(0f, 1f)]
	public float recoilTarget;

	public float recoverySpeed = 0.5f;

	public float recoilTargetAngle;

	public float wobbleTimer;

	public float wobblePin = 1f;

	public float wobbleMuscle = 1f;

	private void Start()
	{
	}

	public void hit(Vector3 direction, float hitPower)
	{
		recoilDirection += direction;
		if (recoilDirection.y > 0f)
		{
			recoilDirection.y = 0f;
		}
		recoilDirection = recoilDirection.normalized;
		if (hitPower < minRecoilPower)
		{
			hitPower = minRecoilPower;
		}
		recoilTarget += Mathf.Clamp01(hitPower);
		recoilTargetAngle = recoilMaxAngle * (UnityEngine.Random.value * 2f - 1f);
		wobbleTimer = hitPower * 2f;
	}

	public float recoilPerc()
	{
		return angleOffset.y / recoilMaxAngle * offset.magnitude;
	}

	private void Update()
	{
		offset = Vector3.MoveTowards(offset, recoilDirection * recoilTarget * recoilDist, recoilSpeed * recoilTarget * Time.deltaTime);
		angleOffset = Vector3.MoveTowards(angleOffset, new Vector3(0f, recoilTargetAngle * recoilTarget, 0f), 1800f * Time.deltaTime);
		recoilTarget = Mathf.MoveTowards(recoilTarget, 0f, Time.deltaTime * recoverySpeed);
		recoilDirection.y = Mathf.MoveTowards(recoilDirection.y, 0f, Time.deltaTime);
		wobbleTimer = Mathf.MoveTowards(wobbleTimer, 0f, Time.deltaTime * 2f);
	}
}
public class HealthBarController : MonoBehaviour
{
	public Image bar;

	public Image maxBar;

	public Image specialBar;

	public Image bgBar;

	public TextMeshProUGUI playerName;

	public bool aiDisplay;

	public Image aiTargetPlayer;

	public Image aiKeepAway;

	public Image aiSizeUp;

	public Image[] hearts;

	public EffectCirclesController circle;

	public Color bgBar_off;

	public Color bgBar_on;

	private float barPerc;

	private float pulseTime;

	private void Start()
	{
	}

	public void update(GameCharacter player)
	{
		Color color = player.data.healthBarColour;
		playerName.text = ((GameController.instance.teamCounts[player.team] > 1 && player.data.pluralName != "") ? player.data.pluralName : player.data.name);
		if (GameController.instance.specialMode.name == "Ninja Challenge" && player.data.pluralName != "")
		{
			Color[] beltColours = Settings.instance.beltColours;
			int num = Mathf.RoundToInt((float)(beltColours.Length - 1) * player.difficulty);
			color = beltColours[num];
			if (color == Color.black)
			{
				color = Color.white;
			}
			playerName.text = player.data.pluralName;
		}
		else if (GameController.instance.specialMode.name == "Dragon Doubles")
		{
			playerName.text = player.data.name;
		}
		LocalisationController.getText("Character: " + playerName.text, playerName);
		Color a = color;
		pulseTime -= Time.deltaTime * 5f;
		if (pulseTime < 0f)
		{
			pulseTime = 1f;
		}
		if (player.hasEffect(CharacterEffect.Effect.Drunk))
		{
			a = Color.Lerp(color, Color.yellow, pulseTime * player.getEffect(CharacterEffect.Effect.Drunk).perc);
		}
		else if (player.hasEffect(CharacterEffect.Effect.Pain))
		{
			a = Color.Lerp(color, Color.red, pulseTime * player.getEffect(CharacterEffect.Effect.Pain).perc);
		}
		else if (player.hasEffect(CharacterEffect.Effect.Sickness))
		{
			a = Color.Lerp(color, Color.green, pulseTime * player.getEffect(CharacterEffect.Effect.Sickness).perc);
		}
		Color color2 = Color.Lerp(a, Color.white, player.rigidBodies.hitRecovery);
		bar.color = color2;
		maxBar.color = color * 0.65f;
		bar.fillAmount = player.rigidBodies.standUpPerc;
		maxBar.fillAmount = player.rigidBodies.standUpPercMax;
		specialBar.fillAmount = player.rigidBodies.specialPerc;
		if (player.rigidBodies.dazed())
		{
			barPerc += Time.deltaTime;
			if (barPerc >= 1f)
			{
				barPerc -= 1f;
			}
		}
		else
		{
			barPerc = Mathf.MoveTowards(barPerc, 0f, Time.deltaTime / 2f);
		}
		bgBar.color = Color.Lerp(bgBar_off, bgBar_on, barPerc);
		if (aiDisplay)
		{
			if (player.aiControl.gameObject.activeInHierarchy)
			{
				aiKeepAway.color = ((player.aiControl.fightAI_keepAway != "") ? Color.green : Color.red);
				aiTargetPlayer.color = (player.aiControl.fightAI_targetPlayer ? Color.green : Color.red);
				aiSizeUp.color = ((player.aiControl.fightAI_sizeupTime > 0f) ? Color.green : Color.red);
				aiKeepAway.gameObject.SetActive(value: true);
				aiTargetPlayer.gameObject.SetActive(value: true);
			}
		}
		else
		{
			aiKeepAway.gameObject.SetActive(value: false);
			aiTargetPlayer.gameObject.SetActive(value: false);
			aiSizeUp.gameObject.SetActive(value: false);
		}
		for (int i = 0; i < hearts.Length; i++)
		{
			if (GameController.instance.specialMode.singleRound)
			{
				hearts[i].enabled = false;
				continue;
			}
			hearts[i].color = ((i < player.lives) ? Color.white : Color.black);
			hearts[i].enabled = i < player.maxLives;
		}
		circle.player = player;
	}
}
public class HideInChambers : MonoBehaviour
{
	public GameObject objectToHide;

	private void Start()
	{
	}

	private void Update()
	{
		bool flag = GameController.instance.gameMode != GameController.GameMode.Chambers || GameController.instance.paused || GameController.instance.player == null;
		objectToHide.SetActive(flag);
		ChambersController.instance.gameObject.SetActive(!flag);
	}
}
public class HitEffect : MonoBehaviour
{
	public ParticleSystem dust;

	public int minDust;

	public int maxDust;

	public ParticleSystem sparks;

	public int minSparks;

	public int maxSparks;

	public Color minColor;

	public Color maxColor;

	public ParticleSystem presureDisplay;

	public void setup(bool success, float perc, bool pressurePoint)
	{
		presureDisplay.gameObject.SetActive(pressurePoint);
		ParticleSystem.EmissionModule emission = dust.emission;
		ParticleSystem.Burst burst = dust.emission.GetBurst(0);
		burst.count = Mathf.Lerp(minDust, maxDust, perc);
		emission.SetBurst(0, burst);
		sparks.gameObject.SetActive(success);
		if (success)
		{
			emission = sparks.emission;
			burst = emission.GetBurst(0);
			ParticleSystem.MainModule main = sparks.main;
			main.startColor = Color.Lerp(minColor, maxColor, perc);
			burst.count = Mathf.Lerp(minSparks, maxSparks, perc);
			emission.SetBurst(0, burst);
			sparks.gameObject.SetActive(success);
		}
	}
}
public class HitEffects : MonoBehaviour
{
	public List<SlowMo> slowMos;

	public float timeSlowTarget = 1f;

	public float timeSlowPerc;

	public static HitEffects instance;

	public float minHitPower = 1f;

	public HitEffect hitEffectPrefab;

	public float timeSlowAmount = 0.05f;

	public float minPitch = 0.5f;

	public float echoAmount;

	public float echoAmountRecharge = 0.3f;

	public float muffleAmount;

	public float muffleMinFreq;

	public bool disabled;

	private void Start()
	{
		instance = this;
	}

	private void Update()
	{
		Application.targetFrameRate = 72;
		Time.fixedDeltaTime = 1f / 144f * Time.timeScale;
		if (GameController.instance.player == null && !Settings.instance.timeSlowOnMenu)
		{
			Time.timeScale = GameController.instance.timeScale;
			return;
		}
		float num = 1f;
		foreach (SlowMo slowMo in slowMos)
		{
			if (slowMo.timeScale < num)
			{
				num = slowMo.timeScale;
			}
			slowMo.update(Time.deltaTime);
		}
		num *= GameController.instance.timeScale;
		Time.timeScale = num;
		timeSlowPerc = Mathf.Clamp01(1f - (Time.timeScale - timeSlowAmount) / (1f - timeSlowAmount));
		GameController.instance.mixer.SetFloat("Pitch", Mathf.Lerp(1f, minPitch, timeSlowPerc));
		GameController.instance.mixer.SetFloat("Echo", timeSlowPerc);
		muffleAmount = Mathf.MoveTowards(muffleAmount, 0f, Time.deltaTime / 2f);
		GameController.instance.mixer.SetFloat("LowPass", Mathf.Lerp(22000f, muffleMinFreq, muffleAmount));
		foreach (SlowMo slowMo2 in slowMos)
		{
			if (slowMo2.finished())
			{
				slowMos.Remove(slowMo2);
				break;
			}
		}
	}

	public static SlowMo timeSlow(float perc, float changeSpeed, bool instant = false)
	{
		if (GameController.instance.player == null && !Settings.instance.timeSlowOnMenu)
		{
			Time.timeScale = GameController.instance.timeScale;
			return null;
		}
		perc = Mathf.Clamp01(perc);
		SlowMo slowMo = new SlowMo(1f - perc * instance.timeSlowAmount, changeSpeed, instant);
		instance.slowMos.Add(slowMo);
		return slowMo;
	}

	public static void addHitEffect(bool success, float hitPerc, Vector3 hitPoint, Vector3 hitNormal, bool showPerc)
	{
		if (!instance.disabled)
		{
			HitEffect hitEffect = UnityEngine.Object.Instantiate(instance.hitEffectPrefab, hitPoint, Quaternion.LookRotation(hitNormal), instance.transform);
			hitEffect.setup(success, hitPerc, pressurePoint: false);
			if (OptionData.getBool("Show Hit Percentages") && showPerc)
			{
				CanvasController.addText(localise: false, Mathf.Ceil(hitPerc * 100f) + "%", hitPoint, Color.gray, 1f);
			}
			UnityEngine.Object.Destroy(hitEffect.gameObject, 1f);
		}
	}

	public static void addHitEffect(bool success, float hitPerc, float damagePerc, Vector3 hitPoint, Vector3 hitNormal, string bodyPart, GameCharacter character, bool showPerc, bool wasPressurePoint = false)
	{
		if (!instance.disabled)
		{
			HitEffect hitEffect = UnityEngine.Object.Instantiate(instance.hitEffectPrefab, hitPoint, Quaternion.LookRotation(hitNormal), instance.transform);
			hitEffect.transform.position = hitPoint;
			hitEffect.setup(success, hitPerc, wasPressurePoint && !character.isPlayer());
			UnityEngine.Object.Destroy(hitEffect.gameObject, 2.5f);
		}
	}
}
public class HitSoundsController : MonoBehaviour
{
	private static HitSoundsController instance;

	public AudioClip[] stoneSounds;

	public AudioClip[] woodSounds;

	public AudioClip[] metalSounds;

	public AudioClip[] bodySounds;

	public AudioClip[] armSounds;

	public AudioClip[] headSounds;

	public AudioClip[] fallSounds;

	public AudioClip[] clangSounds;

	private void Start()
	{
		instance = this;
	}

	public static void playSound(AudioSource src, Hittable.HitType hitType, float volume)
	{
		AudioClip[] array = null;
		if (hitType == Hittable.HitType.Stone)
		{
			array = instance.stoneSounds;
		}
		if (hitType == Hittable.HitType.Wood)
		{
			array = instance.woodSounds;
		}
		if (hitType == Hittable.HitType.Metal)
		{
			array = instance.metalSounds;
		}
		if (hitType == Hittable.HitType.Body)
		{
			array = instance.bodySounds;
		}
		if (hitType == Hittable.HitType.Arm)
		{
			array = instance.armSounds;
		}
		if (hitType == Hittable.HitType.Head)
		{
			array = instance.headSounds;
		}
		if (hitType == Hittable.HitType.Leg)
		{
			array = instance.bodySounds;
		}
		if (hitType == Hittable.HitType.FallToGround)
		{
			array = instance.fallSounds;
		}
		if (hitType == Hittable.HitType.Clang)
		{
			array = instance.clangSounds;
		}
		if (array == null)
		{
			UnityEngine.Debug.LogError("Unknown Type: " + src.name);
		}
		else if (array.Length != 0)
		{
			src.volume = volume;
			src.PlayOneShot(array[UnityEngine.Random.Range(0, array.Length)]);
		}
	}

	private void Update()
	{
	}
}
[RequireComponent(typeof(Collider))]
public class HitSurface : MonoBehaviour
{
	public delegate void HitDummy(Vector3 point, Hittable.HandHitType hitType);

	public Hittable.HitType surface;

	public AudioClip[] overrideSounds;

	public float bounce = 1f;

	private float hitTime;

	private float[] sideHits;

	private int lastRnd = -1;

	public HitDummy onSuccessHit;

	private Collider lastHit;

	private List<Collider> colliding = new List<Collider>();

	private void Start()
	{
		hitTime = Time.time + 2f;
	}

	private void Update()
	{
		foreach (Collider item in colliding)
		{
			if (item == null)
			{
				colliding.Remove(item);
				break;
			}
			Hittable component = item.GetComponent<Hittable>();
			if (component != null && component.bodyPart != null && component.bodyPart.isHandOrLowerArm)
			{
				int num = ((component.bodyPart.source != BodyPartData.Source.LeftHand) ? 1 : 0);
				component.rb.armTouchTime[num] = Time.time;
			}
		}
	}

	public virtual void OnHit(Hittable hitBy, Hittable.HandHitType hitType, float force, Vector3 point, Vector3 normal)
	{
		PlaySound(hitBy.audioSource);
		HitEffects.addHitEffect(success: false, force, point, normal, showPerc: false);
		if (onSuccessHit != null)
		{
			onSuccessHit(point, hitType);
		}
	}

	private void OnCollisionExit(Collision collision)
	{
		if (colliding.Contains(collision.collider))
		{
			colliding.Remove(collision.collider);
		}
	}

	private void OnCollisionEnter(Collision collision)
	{
		if (hitTime > Time.time && lastHit == collision.collider)
		{
			hitTime = Time.time + 0.1f * Time.timeScale;
			return;
		}
		lastHit = collision.collider;
		Hittable component = collision.collider.GetComponent<Hittable>();
		if (component == null || component.bodyPart.weaponForce == 0f || component.rb.isDown(allTheWay: false))
		{
			return;
		}
		float num = Mathf.Clamp01(collision.relativeVelocity.magnitude / 10f);
		if (num < 0.1f)
		{
			return;
		}
		if (component.bodyPart != null && component.bodyPart.isHandOrLowerArm)
		{
			int num2 = ((component.bodyPart.source != BodyPartData.Source.LeftHand) ? 1 : 0);
			if (sideHits == null)
			{
				sideHits = new float[2];
				sideHits[0] = Time.time;
				sideHits[1] = Time.time;
			}
			if (sideHits[num2] > Time.time)
			{
				sideHits[num2] = Time.time + 0.1f * Time.timeScale;
				return;
			}
			sideHits[num2] = Time.time + 0.25f * Time.timeScale;
			if (colliding.Contains(collision.collider))
			{
				return;
			}
			colliding.Add(collision.collider);
		}
		component.rb.buzz(collision.relativeVelocity.magnitude, component.bodyPart.source);
		hitTime = Time.time + 0.25f;
		if (!component.rb.character.vrCharacterController.onGround)
		{
			float num3 = bounce;
			num3 *= (component.bodyPart.isFoot ? 1f : 0.5f);
			num3 *= component.bodyPart.weaponForce;
			if (num * num3 > component.rb.slide.magnitude)
			{
				component.rb.slide = -GameController.flatVector(collision.contacts[0].normal) * num * num3;
				component.rb.slide = Vector3.ClampMagnitude(component.rb.slide, Settings.instance.slideClamp);
			}
		}
		HitEffects.addHitEffect(success: false, num, collision.contacts[0].point, collision.contacts[0].normal, showPerc: false);
		OnHit(component, component.handHitType(collision), num, collision.contacts[0].point, collision.contacts[0].normal);
	}

	public virtual void ProjectileHit(ProjectileController projectile, Vector3 point, Vector3 normal)
	{
	}

	public void PlaySound(AudioSource audioSource)
	{
		if (overrideSounds.Length != 0)
		{
			int num = UnityEngine.Random.Range(0, overrideSounds.Length);
			if (overrideSounds.Length > 1)
			{
				if (lastRnd == num)
				{
					num = UnityEngine.Random.Range(0, overrideSounds.Length);
				}
				if (lastRnd == num)
				{
					num = UnityEngine.Random.Range(0, overrideSounds.Length);
				}
				if (lastRnd == num)
				{
					num = UnityEngine.Random.Range(0, overrideSounds.Length);
				}
			}
			lastRnd = num;
			audioSource.PlayOneShot(overrideSounds[num]);
		}
		else
		{
			HitSoundsController.playSound(audioSource, surface, 1f);
		}
	}

	public bool bouncesProjectiles()
	{
		if (surface == Hittable.HitType.Metal)
		{
			return true;
		}
		if (surface == Hittable.HitType.Stone)
		{
			return true;
		}
		return false;
	}
}
public class Hittable : MonoBehaviour
{
	public enum HitType
	{
		Stone,
		Wood,
		Metal,
		Body,
		Head,
		Arm,
		Leg,
		FallToGround,
		Clang
	}

	public enum HandHitType
	{
		General,
		Punch,
		FingerJab,
		Palm,
		Foot,
		Blade
	}

	public RigidBodies rb;

	public Rigidbody rigidBody;

	public Collider collider;

	public Muscle muscle;

	public BodyPartData bodyPart;

	public AudioSource audioSource;

	public float speed;

	private float l_nextHitTime;

	private float r_nextHitTime;

	public SpecialMoveController specialMove;

	[NonSerialized]
	public Transform forwardAngle;

	public bool isHand;

	public int collisionCount;

	public bool grabbing;

	public Grabbable grabbed;

	public List<Grabbable> grabbables = new List<Grabbable>();

	public List<Hittable> grabLimbs = new List<Hittable>();

	public Hittable grabHittable;

	public float grabTimer;

	private ConfigurableJoint grabJoint;

	private float grabDist;

	private const float grabMassMlp = 5f;

	private const int solverIterationMlp = 10;

	public float baseMass;

	public float massPerc;

	private void Start()
	{
		collider = GetComponent<Collider>();
		rigidBody = GetComponent<Rigidbody>();
		baseMass = rigidBody.mass;
	}

	public bool canGrab()
	{
		if (rigidBody == null)
		{
			return false;
		}
		return bodyPart.isHandOrLowerArm;
	}

	public bool speedCheck()
	{
		if (specialMove != null && specialMove.data.ignoreSpeed)
		{
			return true;
		}
		if (bodyPart.isFoot)
		{
			return true;
		}
		if (bodyPart.source == BodyPartData.Source.RightHand)
		{
			return rb.character.trackers.speedCheck(right: true, rb.character.isPlayer());
		}
		if (bodyPart.source == BodyPartData.Source.LeftHand)
		{
			return rb.character.trackers.speedCheck(right: false, rb.character.isPlayer());
		}
		return false;
	}

	public float speedPerc()
	{
		if (specialMove != null)
		{
			_ = specialMove.data.ignoreSpeed;
			return 1f;
		}
		return 1f;
	}

	public float getSqueeze()
	{
		if (bodyPart.isRightHand)
		{
			return rb.hands.r_squeezeAmount;
		}
		if (bodyPart.isLeftHand)
		{
			return rb.hands.l_squeezeAmount;
		}
		UnityEngine.Debug.LogError("Cant get squeeze of " + bodyPart.name);
		return 0f;
	}

	public bool damageTimeCheck(bool left)
	{
		if (left)
		{
			if (Time.time < l_nextHitTime)
			{
				return false;
			}
			l_nextHitTime = Time.time + 0.25f * Time.timeScale;
		}
		else
		{
			if (Time.time < r_nextHitTime)
			{
				return false;
			}
			r_nextHitTime = Time.time + 0.25f * Time.timeScale;
		}
		return true;
	}

	public void updateGrab()
	{
		if (!isHand)
		{
			return;
		}
		float num = (bodyPart.isLeftHand ? rb.hands.l_squeezeAmount : rb.hands.r_squeezeAmount);
		for (int i = 0; i < grabbables.Count; i++)
		{
			if (grabbables[0] == null)
			{
				grabbables.RemoveAt(0);
				break;
			}
		}
		if (!grabbing)
		{
			if (!((double)num > 0.75))
			{
				return;
			}
			grabbing = true;
			if (grabbables.Count > 0)
			{
				grabbed = grabbables[0];
				grabbed.grab(muscle);
			}
			else
			{
				if (!OptionData.getBool("Arm Grabs") || grabLimbs.Count <= 0 || !(grabJoint == null) || !isHand)
				{
					return;
				}
				grabHittable = grabLimbs[grabLimbs.Count - 1];
				grabTimer = 1f;
				int num2 = ((grabHittable.bodyPart.source != BodyPartData.Source.LeftHand) ? 1 : 0);
				BodyPartData[] bodyParts = grabHittable.rb.bodyParts;
				foreach (BodyPartData bodyPartData in bodyParts)
				{
					if (bodyPartData.source == grabHittable.bodyPart.source && bodyPartData.isHandOrLowerArm)
					{
						Physics.IgnoreCollision(collider, grabHittable.bodyPart.hittable.collider, ignore: true);
					}
				}
				grabJoint = base.gameObject.AddComponent<ConfigurableJoint>();
				grabJoint.connectedBody = grabHittable.rigidBody;
				grabJoint.anchor = new Vector3(-0.35f, 0f, 0f);
				grabJoint.xMotion = ConfigurableJointMotion.Locked;
				grabJoint.yMotion = ConfigurableJointMotion.Locked;
				grabJoint.zMotion = ConfigurableJointMotion.Locked;
				grabJoint.angularXMotion = ConfigurableJointMotion.Locked;
				grabJoint.angularYMotion = ConfigurableJointMotion.Locked;
				grabJoint.angularZMotion = ConfigurableJointMotion.Locked;
				grabJoint.projectionMode = JointProjectionMode.PositionAndRotation;
				grabDist = (grabHittable.transform.position - base.transform.position).magnitude;
				grabHittable.rb.grabbed[num2] = true;
				rb.grabbing[(!bodyPart.isLeftHand) ? 1u : 0u] = true;
				rigidBody.mass *= 5f;
				audioSource.PlayOneShot(GeneralSounds.instance.grab);
			}
			return;
		}
		if (grabHittable != null)
		{
			grabTimer -= Time.deltaTime;
			if ((grabHittable.transform.position - base.transform.position).magnitude > grabDist + 0.02f || grabJoint == null || grabTimer <= 0f)
			{
				releaseLimbGrab();
			}
		}
		if (num < 0.25f)
		{
			grabbing = false;
			grabbed?.release();
			grabbed = null;
			releaseLimbGrab();
		}
		else
		{
			_ = grabbed != null;
		}
	}

	private void releaseLimbGrab()
	{
		if (grabJoint != null)
		{
			UnityEngine.Object.Destroy(grabJoint);
			grabJoint = null;
		}
		if (grabHittable == null)
		{
			return;
		}
		BodyPartData[] bodyParts = grabHittable.rb.bodyParts;
		foreach (BodyPartData bodyPartData in bodyParts)
		{
			if (bodyPartData.source == grabHittable.bodyPart.source && bodyPartData.isHandOrLowerArm)
			{
				Physics.IgnoreCollision(collider, grabHittable.collider, ignore: false);
			}
		}
		grabHittable.rb.grabbed[(grabHittable.bodyPart.source != BodyPartData.Source.LeftHand) ? 1u : 0u] = false;
		rb.grabbing[(!bodyPart.isLeftHand) ? 1u : 0u] = false;
		grabHittable = null;
		rigidBody.mass /= 5f;
		audioSource.PlayOneShot(GeneralSounds.instance.release);
	}

	private void OnCollisionExit(Collision collision)
	{
		Hittable component = collision.collider.transform.GetComponent<Hittable>();
		if (component == null)
		{
			return;
		}
		if (grabLimbs.Contains(component))
		{
			grabLimbs.Remove(component);
		}
		if (component.rb.character.team != rb.character.team && bodyPart.isHandOrLowerArm)
		{
			rb.armCollisions[(bodyPart.source != BodyPartData.Source.LeftHand) ? 1u : 0u]--;
			if (rb.armCollisions[(bodyPart.source != BodyPartData.Source.LeftHand) ? 1u : 0u] < 0)
			{
				rb.armCollisions[(bodyPart.source != BodyPartData.Source.LeftHand) ? 1u : 0u] = 0;
			}
		}
	}

	private void OnCollisionEnter(Collision collision)
	{
		Hittable component = collision.collider.transform.GetComponent<Hittable>();
		if (component == null)
		{
			if (!rb.isDown(allTheWay: false) && bodyPart.isFoot)
			{
				rb.character.kickController.abandon(bodyPart.source == BodyPartData.Source.LeftHand);
			}
			int num = ((bodyPart.source != BodyPartData.Source.LeftHand) ? 1 : 0);
			rb.armTouchTime[num] = Time.time;
			if (collision.collider.transform.GetComponent<FloorController>() != null && base.name.Contains("chest") && !base.name.Contains("spine"))
			{
				rb.hitGroundSound();
			}
			return;
		}
		string text = "";
		int num2 = ((component.bodyPart.source != BodyPartData.Source.LeftHand) ? 1 : 0);
		if (component.rb.grabbing[num2])
		{
			text = "Grabbing";
		}
		if (OptionData.getBool("Arm Grabs") && !grabLimbs.Contains(component) && component.canGrab())
		{
			grabLimbs.Add(component);
		}
		if (component.rb.isDown(allTheWay: false) && !rb.hitsDisabled)
		{
			text = "Dead";
		}
		if (component.rb.character.team == rb.character.team)
		{
			text = "Friendly";
		}
		if (bodyPart.isHandOrLowerArm)
		{
			int num3 = ((bodyPart.source != BodyPartData.Source.LeftHand) ? 1 : 0);
			rb.armCollisions[num3]++;
			rb.armTouchTime[num3] = Time.time;
		}
		rb.character.aiControl.attacksDone = 0;
		component.rb.touchTime = Time.time;
		rb.touchTime = Time.time;
		Vector3 point = collision.contacts[0].point;
		if (component.bodyPart.weaponForce == 0f && text == "")
		{
			text = "Not weapon: " + component.bodyPart.name + " (" + component.rb.character.name + ", " + bodyPart.name + ")";
		}
		if (component.bodyPart.isFoot && text == "" && !component.rb.character.kickController.hitCheck(component.bodyPart.source == BodyPartData.Source.LeftHand))
		{
			text = "wrong part of kick";
			component.rb.character.kickController.abandon(component.bodyPart.source == BodyPartData.Source.LeftHand);
		}
		if (text == "" && component.rb == rb)
		{
			text = "hitting self";
		}
		if (text == "" && bodyPart.hitType == HitType.Leg && bodyPart.source == BodyPartData.Source.LeftHand && rb.character.kickController.legs[0].play)
		{
			text = "cant hit leg while kicking";
		}
		if (text == "" && bodyPart.hitType == HitType.Leg && bodyPart.source == BodyPartData.Source.RightHand && rb.character.kickController.legs[1].play)
		{
			text = "cant hit leg while kicking";
		}
		if (text == "" && !component.speedCheck())
		{
			text = "failed speed test";
		}
		float num4 = 1f;
		if (Settings.instance.stopGlancingBlows && component.isHand)
		{
			num4 = 1f - Mathf.Clamp01((Vector3.Angle(rigidBody.velocity, collision.contacts[0].normal) - 25f) / 45f);
			if (num4 <= 0f)
			{
				text = "Too glancing";
			}
		}
		if (text != "")
		{
			return;
		}
		Vector3 hitDir = Vector3.Lerp(collision.relativeVelocity, collision.contacts[0].normal, 0.5f);
		float num5 = 1f;
		if (!component.rb.character.isPlayer())
		{
			num5 = component.rb.character.getDamageAutoBalance();
		}
		if (bodyPart.source == BodyPartData.Source.LeftHand)
		{
			rb.leftWeaponHitTime = Time.time;
		}
		if (bodyPart.source == BodyPartData.Source.RightHand)
		{
			rb.rightWeaponHitTime = Time.time;
		}
		if (component.bodyPart.source == BodyPartData.Source.LeftHand)
		{
			component.rb.leftWeaponHitTime = Time.time;
		}
		if (component.bodyPart.source == BodyPartData.Source.RightHand)
		{
			component.rb.rightWeaponHitTime = Time.time;
		}
		bool skipPressurePoints = false;
		float num6 = Mathf.Clamp01(collision.relativeVelocity.magnitude * component.bodyPart.weaponForce * bodyPart.knockDownPerc * num5 / Settings.instance.maxMagnitude) * component.speedPerc();
		float num7 = num6;
		Mathf.Clamp01(collision.relativeVelocity.magnitude * component.bodyPart.weaponForce / Settings.instance.maxMagnitude);
		component.speedPerc();
		bool flag = true;
		if (component.specialMove != null && !component.specialMove.isFinished && component.specialMove.data.skipHitSound)
		{
			flag = false;
		}
		if (component.rb.character.hasEffect(CharacterEffect.Effect.IronFists))
		{
			flag = false;
		}
		if (component.specialMove != null)
		{
			component.rb.specialSlide = Vector3.zero;
			component.specialMove.onHitActivate(bodyPart);
			if (component.rb.character.specialMove.addEffect != 0 && !component.rb.character.specialMove.addEffectToSelf)
			{
				skipPressurePoints = true;
			}
			SpecialMoveData specialMoveData = component.rb.character.specialMove;
			if (specialMoveData.name == "Unstoppable Punch")
			{
				num6 = Mathf.Clamp01(1f * component.rb.character.specialMove.slideMod);
				num7 = Mathf.Clamp01(1f * component.rb.character.specialMove.damageMod);
			}
			else if (specialMoveData.ignoreSpeed)
			{
				num6 = Mathf.Clamp01(bodyPart.knockDownPerc * component.rb.character.specialMove.slideMod);
				num7 = Mathf.Clamp01(bodyPart.knockDownPerc * component.rb.character.specialMove.damageMod);
			}
			else
			{
				num6 = Mathf.Clamp01(bodyPart.knockDownPerc * component.rb.character.specialMove.slideMod) * num6 * component.speedPerc();
				num7 = Mathf.Clamp01(bodyPart.knockDownPerc * component.rb.character.specialMove.damageMod) * num6 * component.speedPerc();
			}
			if (!rb.character.isPlayer())
			{
				rb.character.SpecialMoveHit(specialMoveData.name);
			}
		}
		float num8 = Mathf.Clamp01(collision.relativeVelocity.magnitude / Settings.instance.maxMagnitude) * component.speedPerc();
		if ((double)num8 < 0.2)
		{
			skipPressurePoints = true;
		}
		if (bodyPart.knockDownPerc > 0f)
		{
			if (num6 < Settings.instance.minHitPerc)
			{
				num6 = Settings.instance.minHitPerc;
			}
			if (num7 < Settings.instance.minHitPerc)
			{
				num7 = Settings.instance.minHitPerc;
			}
			if (component.bodyPart.isFoot)
			{
				if (num6 < 0.5f)
				{
					num6 = 0.5f;
				}
				if (num8 < 0.5f)
				{
					num8 = 0.5f;
				}
			}
			if (num6 < bodyPart.knockDownPerc / 2f)
			{
				num6 = bodyPart.knockDownPerc / 2f;
			}
			if (bodyPart.isHead && (double)num8 < 0.5)
			{
				num8 = 0.5f;
			}
		}
		HandHitType handHitType = HandHitType.General;
		if (component.isHand)
		{
			Vector3 relativeVelocity = collision.relativeVelocity;
			relativeVelocity = collision.contacts[0].point - component.forwardAngle.position;
			float num9 = Quaternion.Angle(Quaternion.LookRotation(component.forwardAngle.forward), Quaternion.LookRotation(relativeVelocity));
			handHitType = (((component.bodyPart.isLeftHand ? component.rb.hands.l_squeezeAmount : component.rb.hands.r_squeezeAmount) > 0.9f) ? HandHitType.Punch : ((!(num9 < 15f)) ? HandHitType.Palm : HandHitType.FingerJab));
			UnityEngine.Debug.DrawLine(component.forwardAngle.transform.position, component.forwardAngle.transform.position + relativeVelocity, Color.yellow, 1f);
			UnityEngine.Debug.DrawLine(component.forwardAngle.transform.position, component.forwardAngle.transform.position + component.forwardAngle.forward.normalized * relativeVelocity.magnitude, Color.cyan, 1f);
		}
		else if (component.bodyPart.isFoot)
		{
			handHitType = HandHitType.Foot;
		}
		float num10 = 0f;
		if (component.bodyPart.source == BodyPartData.Source.LeftHand)
		{
			num10 = component.rb.leftWeaponDamageTime + 0.25f * Time.timeScale;
		}
		if (component.bodyPart.source == BodyPartData.Source.RightHand)
		{
			num10 = component.rb.rightWeaponDamageTime + 0.25f * Time.timeScale;
		}
		if (Time.time < num10)
		{
			return;
		}
		if (bodyPart.knockDownPerc > 0f && component.bodyPart.weaponForce > 0f)
		{
			if (component.bodyPart.source == BodyPartData.Source.LeftHand)
			{
				component.rb.leftWeaponDamageTime = Time.time;
			}
			if (component.bodyPart.source == BodyPartData.Source.RightHand)
			{
				component.rb.rightWeaponDamageTime = Time.time;
			}
		}
		if (!rb.isDown(allTheWay: false))
		{
			if (num6 > 0.5f && num8 >= 0.95f && GameController.instance.uberHitTimer > 0f && (rb.character.isPlayer() || component.rb.character.isPlayer()))
			{
				HitEffects.timeSlow(num6 * GameController.instance.uberHitTimer, 1f / GameController.instance.difficultyLevel.slowMoDuration);
				GameController.instance.uberHitTimer = 0f;
			}
			if (rb.character.specialRechargeAllowed && num8 > 0.2f)
			{
				float num11 = num8 * Settings.instance.specialHitCharge * component.bodyPart.weaponForce / rb.character.doingSpecialData.qiUsage;
				if (rb.character.data.specialMoveName == "All")
				{
					num11 *= 2f;
				}
				rb.specialChargeSpeed = 0f;
				if (rb.character.isPlayer())
				{
					float t = Mathf.Clamp01((GameController.instance.difficultyLevel.aiThinkTime.lerp(component.rb.character.difficulty) - 0.5f) / 2.5f);
					num11 *= Mathf.Lerp(1f, 3f, t);
				}
				rb.specialPerc += num11;
				if (!OptionData.getBool("Special Moves"))
				{
					rb.specialPerc = 0f;
				}
				if (rb.character.isPlayer())
				{
					rb.character.rigidBodies.rightHandMeter.highlight(Color.white);
				}
			}
		}
		foreach (CharacterEffect effect in rb.character.effects)
		{
			if (!effect.timeReduce)
			{
				effect.amount -= num6;
			}
		}
		if (bodyPart.knockDownPerc > 0f)
		{
			if (component.rb.character.hasEffect(CharacterEffect.Effect.IronFists) && component.isHand)
			{
				num7 *= 2f;
				num6 *= 2f;
				component.hitSound(component.rb.character.getEffect(CharacterEffect.Effect.IronFists).effectData.hitSound, 1f);
			}
			else if (component.rb.character.hasEffect(CharacterEffect.Effect.RapidPunch) && component.isHand)
			{
				num7 *= 1.5f;
				num6 *= 1.5f;
			}
		}
		float num12 = 1f;
		if (bodyPart.isHead)
		{
			num12 *= rb.character.data.perkMod("Iron Head", point);
		}
		if (bodyPart.isHead)
		{
			num12 *= rb.character.data.perkMod("Glass Jaw", point);
		}
		if (bodyPart.hitType == HitType.Leg)
		{
			num12 *= rb.character.data.perkMod("Weak Legs", point);
		}
		if (handHitType == HandHitType.Palm)
		{
			num12 *= component.rb.character.data.perkMod("Power Palms", point);
		}
		if (handHitType == HandHitType.FingerJab)
		{
			num12 *= component.rb.character.data.perkMod("Fingers of Steel", point);
		}
		if (handHitType == HandHitType.Foot)
		{
			num12 *= component.rb.character.data.perkMod("Hammer Heel", point);
		}
		if (handHitType == HandHitType.Foot && bodyPart.isHead)
		{
			num12 *= component.rb.character.data.perkMod("Head Kicker", point);
		}
		if (component.rb.firstStrikeTime == 0f)
		{
			component.rb.firstStrikeTime = Time.time;
		}
		if (component.rb.firstStrikeTime == 0f || component.rb.firstStrikeTime > Time.time - 0.5f)
		{
			num12 *= component.rb.character.data.perkMod("First Strike", point);
		}
		num7 *= num4;
		num6 *= num4;
		num7 *= num12;
		num6 *= num12;
		if (rb.character.hasEffect(CharacterEffect.Effect.IronArmor) && bodyPart.knockDownPerc > 0f)
		{
			component.hitSound(HitType.Clang, num8);
			if (component.isHand)
			{
				if (component.bodyPart.isLeftHand)
				{
					rb.hands.l_offset.pause = 2f;
				}
				if (component.bodyPart.isRightHand)
				{
					component.rb.hands.r_offset.pause = 2f;
					component.rb.hands.r_offset.offset = -hitDir.normalized * 0.1f;
				}
			}
			component.rb.slide -= hitDir.normalized * num6 * 0.75f;
			if (component.bodyPart.source == BodyPartData.Source.LeftHand || component.bodyPart.source == BodyPartData.Source.RightHand)
			{
				component.rb.buzz(num8 * 1.5f * component.bodyPart.hapticAmount, component.bodyPart.source);
			}
		}
		else
		{
			if (bodyPart.knockDownPerc > 0f)
			{
				foreach (CharacterEffect effect2 in component.rb.character.effects)
				{
					if (effect2.visualEffect != null && effect2.visualEffect.onHitEffect != null)
					{
						UnityEngine.Object.Destroy(UnityEngine.Object.Instantiate(effect2.visualEffect.onHitEffect, collision.contacts[0].point, Quaternion.LookRotation(collision.contacts[0].normal), null), 5f);
					}
				}
			}
			rb.Hit(hitDir, this, component.rb.character, num6, num7, collision.contacts[0].point, handHitType, skipPressurePoints, "");
			if (flag)
			{
				int num13 = ((component.bodyPart.source != BodyPartData.Source.LeftHand) ? 1 : 0);
				if (component.bodyPart.source != BodyPartData.Source.LeftHand && component.bodyPart.source != BodyPartData.Source.RightHand)
				{
					UnityEngine.Debug.LogError("Hitting wrong thinsk");
				}
				if (rb.armHitTime[num13] < Time.time - 0.25f || bodyPart.knockDownPerc > 0f)
				{
					if (rb.overrideSound != null)
					{
						component.hitSound(rb.overrideSound, 1f);
						rb.overrideSound = null;
					}
					else
					{
						component.hitSound(bodyPart.hitType, num8);
					}
					rb.armHitTime[num13] = Time.time;
				}
			}
			if (component.bodyPart.hapticAmount > 0f && (component.bodyPart.source == BodyPartData.Source.LeftHand || component.bodyPart.source == BodyPartData.Source.RightHand))
			{
				component.rb.buzz(num8 * component.bodyPart.hapticAmount, component.bodyPart.source);
			}
			if (component.rb.character.isPlayer())
			{
				if ((double)num7 > 0.05 && bodyPart.knockDownPerc > 0f)
				{
					if (bodyPart.isHead)
					{
						if (!AchievementsController.instance.hasHitHead)
						{
							AchievementsController.instance.hasHitHead = true;
						}
					}
					else if (!AchievementsController.instance.hasHitOther)
					{
						AchievementsController.instance.hasHitOther = true;
					}
				}
				if (component.bodyPart.isHandOrLowerArm)
				{
					if (component.bodyPart.source == BodyPartData.Source.LeftHand)
					{
						AchievementsController.instance.hasUsedLeftArm = true;
					}
					else
					{
						AchievementsController.instance.hasUsedRightArm = true;
					}
				}
			}
			if (bodyPart.hapticAmount > 0f && (bodyPart.source == BodyPartData.Source.LeftHand || bodyPart.source == BodyPartData.Source.RightHand))
			{
				rb.buzz(num8 * bodyPart.hapticAmount, bodyPart.source);
			}
		}
		string text2 = component.bodyPart.friendlyName;
		if (handHitType == HandHitType.FingerJab)
		{
			text2 = "Fingers";
		}
		if (handHitType == HandHitType.Palm)
		{
			text2 = "Palm";
		}
		if (handHitType == HandHitType.Punch)
		{
			text2 = "Fist";
		}
		text2 += ">";
		text2 += ((rb.wasPressurePoint != "") ? rb.wasPressurePoint : bodyPart.friendlyName);
		HitEffects.addHitEffect(bodyPart.knockDownPerc > 0f, num7, num7, collision.contacts[0].point, collision.contacts[0].normal, text2, rb.character, bodyPart.knockDownPerc > 0f, rb.wasPressurePoint != "");
		rb.wasPressurePoint = "";
	}

	public HandHitType handHitType(Collision collision)
	{
		if (bodyPart.isFoot)
		{
			return HandHitType.Foot;
		}
		if (forwardAngle == null)
		{
			return HandHitType.General;
		}
		Vector3 relativeVelocity = collision.relativeVelocity;
		relativeVelocity = collision.contacts[0].point - forwardAngle.position;
		float num = Quaternion.Angle(Quaternion.LookRotation(forwardAngle.forward), Quaternion.LookRotation(relativeVelocity));
		if ((bodyPart.isLeftHand ? rb.hands.l_squeezeAmount : rb.hands.r_squeezeAmount) > 0.9f)
		{
			return HandHitType.Punch;
		}
		if (num < 15f)
		{
			return HandHitType.FingerJab;
		}
		return HandHitType.Palm;
	}

	public void hitSound(HitType hitType, float volume, AudioSource audioSource)
	{
		if (!(audioSource == null))
		{
			HitSoundsController.playSound(audioSource, hitType, volume);
		}
	}

	public void hitSound(HitType hitType, float volume)
	{
		if (!(audioSource == null))
		{
			HitSoundsController.playSound(audioSource, hitType, volume);
		}
	}

	public void hitSound(AudioClip clip, float volume)
	{
		if (!(audioSource == null))
		{
			audioSource.volume = volume;
			audioSource.PlayOneShot(clip, volume);
		}
	}
}
public class MaterialAlteration : MonoBehaviour
{
	private Renderer rend;

	[Tooltip("Control Make-up Values : RGBA/XYZW : Color(vector3) Glitter Amount(Float)")]
	public Vector4 makeUp1;

	public Vector4 makeUp2;

	public Vector4 makeUp3;

	[Tooltip("Control Make-up channel amounts")]
	public Vector3 colorPower;

	private void Start()
	{
		rend = GetComponent<Renderer>();
		makeUp1 = rend.material.GetVector("_MakeUpColor1GlitterAlpha");
		makeUp2 = rend.material.GetVector("_MakeUpColor2GlitterAlpha");
		makeUp3 = rend.material.GetVector("_MakeUpColor3GlitterAlpha");
		colorPower = rend.material.GetVector("_ColorPowerRGB");
	}

	private void Update()
	{
		rend.material.SetVector("_MakeUpColor1GlitterAlpha", makeUp1);
		rend.material.SetVector("_MakeUpColor2GlitterAlpha", makeUp2);
		rend.material.SetVector("_MakeUpColor3GlitterAlpha", makeUp3);
		rend.material.SetVector("_ColorPowerRGB", colorPower);
	}
}
public class IdlePoseCharacter : MonoBehaviour
{
	public FaceController face;

	public PuppetMaster pm;

	private void Start()
	{
		face.Setup();
		pm.pinWeight = 0.6f;
	}

	private void Update()
	{
	}
}
public class ItemArray : MonoBehaviour
{
	public GameObject itemPrefab;

	public Vector3 spacing;

	public float spacingVariance;

	public int count = 10;

	public Vector3 offset;

	public Vector3 random;

	private void Start()
	{
		SceneryBreakable componentInChildren = itemPrefab.GetComponentInChildren<SceneryBreakable>();
		if (TableSmashAchievementCheck.instance != null && componentInChildren != null)
		{
			TableSmashAchievementCheck.instance.breakables.Add(componentInChildren);
		}
		_ = base.transform.position;
		for (int i = 1; i < count; i++)
		{
			GameObject obj = UnityEngine.Object.Instantiate(itemPrefab, base.transform);
			obj.transform.localPosition = i * spacing + Vector3.forward * spacingVariance * UnityEngine.Random.value;
			obj.transform.localRotation = Quaternion.Euler(offset) * Quaternion.Euler(random.x * UnityEngine.Random.value, random.y * UnityEngine.Random.value, random.z * UnityEngine.Random.value);
			componentInChildren = obj.GetComponentInChildren<SceneryBreakable>();
			if (TableSmashAchievementCheck.instance != null && componentInChildren != null)
			{
				TableSmashAchievementCheck.instance.breakables.Add(componentInChildren);
			}
		}
	}

	private void Update()
	{
	}
}
public class Jig : MonoBehaviour
{
	public Transform[] bones;

	public Transform[] lookTarget;

	public Transform[] pTarget;

	public Vector3[] restPositions;

	public Vector3 rotateOffset;

	public Vector3 speed;

	public float accelerate = 10f;

	public float dampen = 1f;

	private void Start()
	{
		for (int i = 0; i < bones.Length; i++)
		{
			lookTarget[i].position = bones[i].transform.position + bones[i].transform.up * 0.5f;
			restPositions[i] = base.transform.InverseTransformPoint(lookTarget[i].position);
		}
	}

	private void LateUpdate()
	{
		for (int i = 0; i < bones.Length; i++)
		{
			pTarget[i].position = base.transform.TransformPoint(restPositions[i]);
			bones[i].rotation = Quaternion.LookRotation(lookTarget[i].position - bones[i].position);
			bones[i].localRotation *= Quaternion.Euler(rotateOffset);
			Vector3 vector = pTarget[i].position - lookTarget[i].position;
			speed += vector * Time.deltaTime * accelerate;
			speed = Vector3.MoveTowards(speed, Vector3.zero, Time.deltaTime * dampen);
			lookTarget[i].position += speed;
		}
	}
}
public class KickController : MonoBehaviour
{
	public GameCharacter gameCharacter;

	public VRIK ik;

	public bool kickingHeld;

	public KickLegController[] legs;

	public Transform rig;

	public Transform aimAt;

	public Transform head;

	public float[] stageSpeeds;

	public float speedMod = 1f;

	public float aimDist = 2f;

	public float abandonSpeed = 2f;

	public float abandonPause = 0.5f;

	public bool kicking;

	public float kickStamina = 1f;

	public float kickPause;

	public float kickSpeed;

	public bool wasSpecial;

	private float pause;

	public AudioClip kickStartSound;

	public AudioClip kickSound;

	private bool doneSound;

	public LayerMask layerMask;

	private void Start()
	{
	}

	public void Kick()
	{
		if (kicking || (!OptionData.getBool("Kicks") && !gameCharacter.kickingMove() && GameController.instance.gameMode != GameController.GameMode.Chambers) || gameCharacter.trackers.transforms[0].localPosition.y < 1.2f || gameCharacter.mover.slide.magnitude > 0.1f || gameCharacter.mover.dashing())
		{
			return;
		}
		kicking = true;
		doneSound = false;
		kickSpeed = gameCharacter.data.moveSpeedPerc();
		kickSpeed *= gameCharacter.data.perkMod("Fast Feet", aimAt.transform.position);
		kickSpeed *= gameCharacter.data.perkMod("Slow Kicker", aimAt.transform.position);
		if (!gameCharacter.data.hasPerk("Kicker"))
		{
			kickStamina -= 0.2f;
			if (kickStamina < 0f)
			{
				kickStamina = 0f;
			}
		}
		kickPause = 0.25f;
		Vector3 vector = ((gameCharacter == null || gameCharacter.isPlayer()) ? head.forward : gameCharacter.aiControl.aiTrackerContainer.forward);
		if (Physics.Raycast(new Ray(head.position, vector), out var hitInfo, aimDist, layerMask))
		{
			aimAt.transform.position = hitInfo.point + vector * 0.3f;
		}
		else
		{
			aimAt.transform.position = head.position + vector * aimDist;
		}
		if (!gameCharacter.isPlayer() && aimAt.transform.localPosition.y > gameCharacter.aiControl.enemyHeadY)
		{
			aimAt.transform.localPosition = new Vector3(aimAt.transform.localPosition.x, gameCharacter.aiControl.enemyHeadY, aimAt.transform.localPosition.z);
		}
		if (gameCharacter.data.hasPerk("Low Kicker") && aimAt.transform.localPosition.y > 1f)
		{
			aimAt.transform.localPosition = new Vector3(aimAt.transform.localPosition.x, 1f, aimAt.transform.localPosition.z);
		}
		Transform transform = gameCharacter.rigidBodies.bodyParts[0].hittable.transform;
		float num = Mathf.DeltaAngle(Quaternion.LookRotation(GameController.flatVector(transform.forward)).eulerAngles.y, Quaternion.LookRotation(GameController.flatVector(aimAt.transform.position - transform.position)).eulerAngles.y);
		bool sideKick = Mathf.Abs(num) >= 20f;
		int num2 = ((!(num < 0f)) ? 1 : 0);
		wasSpecial = gameCharacter.hasEffect(CharacterEffect.Effect.ScissorKick);
		if (gameCharacter.hasEffect(CharacterEffect.Effect.ScissorKick))
		{
			doKick(num2, sideKick: false, 0.25f, specialBoost: true);
			doKick((num2 == 0) ? 1 : 0, sideKick: false, 0f, specialBoost: true);
			gameCharacter.removeEffect(CharacterEffect.Effect.ScissorKick);
		}
		else
		{
			doKick(num2, sideKick, 0f, specialBoost: false);
		}
	}

	private void doKick(int legID, bool sideKick, float delay, bool specialBoost)
	{
		KickLegController obj = legs[legID];
		obj.kickPosition.localRotation = Quaternion.Euler(0f, 0f, sideKick ? ((legID == 0) ? (-90) : 90) : 0);
		obj.delay = delay;
		obj.play = true;
		obj.nextHitTime = 0f;
		obj.specialBoost = specialBoost;
	}

	public void abandon(bool isLeft)
	{
		int num = ((!isLeft) ? 1 : 0);
		if (legs[num].onStage != 0)
		{
			legs[num].abandon = true;
			legs[num].foot.DisableColliders();
		}
	}

	public bool hitCheck(bool isLeft)
	{
		int num = ((!isLeft) ? 1 : 0);
		if (legs[num].onStage > 2)
		{
			return false;
		}
		if (legs[num].nextHitTime > Time.time)
		{
			return false;
		}
		legs[num].nextHitTime = Time.time + 2f;
		return true;
	}

	private void Update()
	{
		if (GameController.instance.paused)
		{
			return;
		}
		if (!kicking)
		{
			if (kickPause > 0f)
			{
				kickPause -= Time.deltaTime;
			}
			else
			{
				kickStamina = Mathf.Clamp01(kickStamina);
				kickStamina = Mathf.MoveTowards(kickStamina, 1f, Time.deltaTime / 5f);
			}
			base.transform.rotation = Quaternion.LookRotation(GameController.flatVector(ik.solver.spine.headTarget.forward), ik.solver.spine.headTarget.up);
		}
		base.transform.position = gameCharacter.standPosition;
		if (!legs[0].play && !legs[1].play)
		{
			kicking = false;
		}
		for (int i = 0; i < legs.Length; i++)
		{
			KickLegController kickLegController = legs[i];
			kickLegController.transform.rotation = Quaternion.LookRotation(aimAt.position - kickLegController.transform.position) * Quaternion.Euler(0f, (i == 0) ? (-2) : 2, 0f);
			kickLegController.onStage = Mathf.FloorToInt(kickLegController.totalLerp * 5f);
			if (kickLegController.onStage >= 5)
			{
				kickLegController.onStage = 0;
			}
			kickLegController.speed = stageSpeeds[kickLegController.onStage];
			kickLegController.stageLerp = kickLegController.totalLerp * 5f - (float)kickLegController.onStage;
			IKSolverVR.Leg leg = ((i == 0) ? ik.solver.leftLeg : ik.solver.rightLeg);
			if (kickLegController.abandon)
			{
				leg.positionWeight = (leg.rotationWeight = Mathf.MoveTowards(leg.positionWeight, 0f, Time.deltaTime * abandonSpeed));
				if (leg.positionWeight == 0f)
				{
					kickLegController.abandon = false;
					kickLegController.totalLerp = 0f;
					kickLegController.play = false;
					kickLegController.foot.DisableColliders();
				}
			}
			else
			{
				if (kickLegController.onStage > 1 && !doneSound)
				{
					doneSound = true;
					kickLegController.foot.joint.GetComponent<AudioSource>().PlayOneShot(kickSound);
				}
				switch (kickLegController.onStage)
				{
				case 0:
					leg.target.position = kickLegController.chamberPosition.position;
					leg.target.rotation = kickLegController.chamberRotation.rotation;
					leg.positionWeight = (leg.rotationWeight = kickLegController.stageLerp);
					break;
				case 1:
					leg.target.position = Vector3.Lerp(kickLegController.chamberPosition.position, kickLegController.kickPosition.position, kickLegController.stageLerp);
					leg.target.rotation = Quaternion.Slerp(kickLegController.chamberRotation.rotation, kickLegController.kickRotation.rotation, kickLegController.stageLerp);
					if (kickLegController.stageLerp > 0.2f)
					{
						kickLegController.foot.EnableColliders();
					}
					break;
				case 3:
					leg.target.position = Vector3.Lerp(kickLegController.kickPosition.position, kickLegController.jumpPosition.position, kickLegController.stageLerp);
					leg.target.rotation = Quaternion.Lerp(kickLegController.kickRotation.rotation, kickLegController.jumpPosition.rotation, kickLegController.stageLerp);
					leg.positionWeight = (leg.rotationWeight = (1f - kickLegController.stageLerp) * (1f - gameCharacter.rigidBodies.jumpPerc));
					if (leg.positionWeight < 0.3f)
					{
						kickLegController.foot.DisableColliders();
					}
					break;
				case 4:
					kickLegController.foot.DisableColliders();
					break;
				}
			}
			if (kickLegController.play)
			{
				if (kickLegController.delay > 0f)
				{
					kickLegController.delay -= Time.deltaTime;
					continue;
				}
				if (kickLegController.specialBoost)
				{
					kickStamina = 1f;
					Vector3 forward = gameCharacter.trackers.transforms[0].forward;
					gameCharacter.rigidBodies.slide = forward * 0.4f;
					kickLegController.specialBoost = false;
				}
				float num = 1f;
				if (gameCharacter.doingSpecial > 0f && gameCharacter.specialMove.name == "Thunderfoot")
				{
					num *= 1.5f;
				}
				num *= kickSpeed;
				if (gameCharacter.hasEffect(CharacterEffect.Effect.QuickWalk))
				{
					kickStamina = 1f;
				}
				if (kickLegController.onStage >= 2 && kickingHeld)
				{
					num /= 2f;
				}
				if (kickLegController.totalLerp == 0f)
				{
					AudioSource component = kickLegController.foot.joint.GetComponent<AudioSource>();
					component.volume = kickStamina;
					component.PlayOneShot(kickStartSound);
				}
				if (gameCharacter.rigidBodies.specialSlide.magnitude < 0.1f)
				{
					kickLegController.totalLerp += Time.deltaTime * kickLegController.speed * speedMod * Mathf.Lerp(0.7f, 1f, kickStamina) * gameCharacter.kickSpeedMod() * num;
				}
				if (kickLegController.totalLerp >= 1f)
				{
					kickLegController.totalLerp = 0f;
					kickLegController.play = false;
				}
				else if (gameCharacter.rigidBodies.slide.magnitude > 0.5f)
				{
					abandon(i == 0);
				}
			}
			else if (kickLegController.totalLerp > 0f)
			{
				kickLegController.totalLerp -= Time.deltaTime * kickLegController.speed * speedMod * Mathf.Lerp(0.5f, 1f, kickStamina) * gameCharacter.kickSpeedMod();
				if (kickLegController.totalLerp < 0f)
				{
					kickLegController.totalLerp = 0f;
				}
			}
			else
			{
				leg.target.position = kickLegController.jumpPosition.position;
				leg.target.rotation = kickLegController.jumpPosition.rotation;
				leg.positionWeight = (leg.rotationWeight = gameCharacter.rigidBodies.jumpPerc);
			}
		}
	}
}
public class KickLegController : MonoBehaviour
{
	public bool play;

	public Transform chamberPosition;

	public Transform kickPosition;

	public Transform jumpPosition;

	public Transform chamberRotation;

	public Transform kickRotation;

	public float rotate;

	[Range(0f, 1f)]
	public float totalLerp;

	public bool abandon;

	public bool specialBoost;

	public int onStage;

	public float stageLerp;

	public float speed = 2f;

	public float delay;

	public Muscle foot;

	public float nextHitTime;

	private void Start()
	{
	}

	private void Update()
	{
	}
}
public class LensController : MonoBehaviour
{
	public bool gone;

	public int onStage;

	public GameObject[] stages;

	public void Start()
	{
		for (int i = 0; i < stages.Length; i++)
		{
			stages[i].SetActive(i == onStage);
		}
	}

	public void nextStage()
	{
		onStage++;
		for (int i = 0; i < stages.Length; i++)
		{
			stages[i].SetActive(i == onStage);
		}
		if (onStage >= stages.Length)
		{
			gone = true;
		}
	}
}
public class LevelPickerController : StandButtonsController
{
	public TextMeshProUGUI heading;

	public TextMeshProUGUI lowest;

	public GameOverBoard gameOverDisplay;

	public StandPositionIndicator standPosPrefab;

	private StandPositionIndicator[] standPositions;

	public StandPositionIndicator changeChar;

	public StandPositionIndicator practiceMove;

	public StandPositionIndicator[] skipButtons;

	public float radius = 2f;

	public float arc = 180f;

	public Material disabledMaterial;

	public Color gotAllColour;

	private bool setup;

	private void Start()
	{
		GameData.instance.setupUnlocks();
		List<LocationData> list = new List<LocationData>();
		LocationData[] locations = GameController.instance.gameData.locations;
		foreach (LocationData locationData in locations)
		{
			if (locationData.characters().Length != 0)
			{
				list.Add(locationData);
			}
		}
		list.Sort(SortByUnlockStars);
		if (GameController.instance.specialMode.hasDifficultyLevels)
		{
			heading.text = LocalisationController.getText("General", (GameController.instance.specialMode.name == "Normal") ? "Difficulty" : GameController.instance.specialMode.name);
			TextMeshProUGUI textMeshProUGUI = heading;
			textMeshProUGUI.text = textMeshProUGUI.text + ": " + LocalisationController.getText("Difficulty", GameController.instance.difficultyLevel.name);
		}
		else
		{
			heading.text = LocalisationController.getText("Game Mode", GameController.instance.specialMode.name);
		}
		string text = "";
		if (GameController.instance.difficultyLevel.name == "Master")
		{
			LocalisationController.replaceText("General", "[x] stars remaining", GameData.instance.remainingStars().ToString());
			lowest.text = "";
			if (GameData.instance.stars >= Settings.instance.masterStarRequirement)
			{
				CharacterData[] characterOrder = GameData.instance.characterOrder;
				foreach (CharacterData characterData in characterOrder)
				{
					if (!characterData.playable(allowUnlockedBosses: false, blockLevelLocked: false) && characterData.fightsFinished > 0 && characterData.hasStars == 0)
					{
						text = LocalisationController.replaceText("Game Over", "You were defeated by [x]", LocalisationController.getText("Character: " + characterData.name, characterData.name));
					}
				}
			}
			else if (GameData.instance.remainingStars() + GameData.instance.stars < Settings.instance.masterStarRequirement)
			{
				text = LocalisationController.getText("Game Over", "There are no longer enough available stars for you to be able to face Feng Xiu");
			}
			if (text == "")
			{
				gameOverDisplay.gameObject.SetActive(value: false);
			}
			else
			{
				gameOverDisplay.show(text);
			}
		}
		else
		{
			if (GameController.instance.lowestDifficultyLevel < GameController.instance.difficultyLevel.id && GameController.instance.lowestDifficultyLevel > -1)
			{
				lowest.text = LocalisationController.getText("General", "Lowest:") + " " + LocalisationController.getText("Difficulty Level", Settings.instance.difficultyLevels[GameController.instance.lowestDifficultyLevel].name);
			}
			else
			{
				lowest.gameObject.SetActive(value: false);
			}
			gameOverDisplay.gameObject.SetActive(value: false);
		}
		float num = arc / (float)list.Count;
		if (text != "")
		{
			standPositions = new StandPositionIndicator[0];
		}
		else
		{
			standPositions = new StandPositionIndicator[list.Count];
			for (int j = 0; j < list.Count; j++)
			{
				StandPositionIndicator standPositionIndicator = UnityEngine.Object.Instantiate(standPosPrefab, base.transform);
				float y = (0f - arc) / 2f + num * (float)j;
				standPositionIndicator.transform.rotation = Quaternion.Euler(-90f, y, 0f);
				standPositionIndicator.transform.position = Quaternion.Euler(0f, y, 0f) * Vector3.forward * radius;
				string text2 = list[j].specialRequirementError();
				if (GameController.instance.specialMode.singleRound)
				{
					standPositionIndicator.buttonLabel = "";
				}
				else if (text2 != "")
				{
					standPositionIndicator.buttonLabel = text2;
				}
				else
				{
					standPositionIndicator.buttonLabel = (list[j].unlocked ? "" : LocalisationController.replaceText("Location Requirement", "[x] to unlock", (list[j].toUnlock - GameController.instance.gameData.stars).ToString()));
				}
				string text3 = list[j].specialRequirementError();
				if (list[j].unlocked && text3 != "")
				{
					standPositionIndicator.buttonLabel = text3;
				}
				standPositionIndicator.buttonAction = "Go";
				standPositions[j] = standPositionIndicator;
				if (GameController.instance.specialMode.singleRound)
				{
					standPositionIndicator.button.GetComponent<CharacterButtonController>().setTo(list[j]);
					standPositionIndicator.extra.text = "";
				}
				else if (list[j].unlocked && text3 == "")
				{
					if (list[j].gotStars >= list[j].availableStars)
					{
						standPositionIndicator.extra.color = gotAllColour;
					}
					standPositionIndicator.button.GetComponent<CharacterButtonController>().setTo(list[j]);
					standPositionIndicator.extra.text = list[j].gotStars + "/" + list[j].availableStars;
					standPositionIndicator.starDisplay.setTo(list[j]);
				}
				else
				{
					standPositionIndicator.button.GetComponent<CharacterButtonController>().setTo(disabledMaterial);
					standPositionIndicator.extra.text = "";
				}
				standPositionIndicator.disabled = (!list[j].unlocked || text3 != "") && !GameController.instance.specialMode.singleRound;
				standPositionIndicator.id = list[j].id;
				standPositionIndicator.manual = true;
				standPositionIndicator.headingText = LocalisationController.getText("Location", list[j].name);
				if (!GameController.instance.scenes.levelExists(list[j].id))
				{
					standPositionIndicator.disabled = true;
				}
			}
		}
		StandPositionIndicator[] array = skipButtons;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].gameObject.SetActive(OptionData.getBool("Skip Buttons"));
		}
		Saving.saveGame();
	}

	public int SortByUnlockStars(LocationData l1, LocationData l2)
	{
		return l1.starOrder().CompareTo(l2.starOrder());
	}

	private void Update()
	{
		if (GameController.instance.player != null)
		{
			_ = GameController.instance.player.standPosition;
			StandPositionIndicator[] array = standPositions;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].on = true;
			}
		}
		noticeBoard.SetActive(OptionData.getBool("Noticeboard"));
		if (!setup && GameController.instance.player == null && GameController.instance.gameMode != 0)
		{
			setup = true;
			if (spawnPoints.Length == 0)
			{
				spawnPoints = GetComponentsInChildren<SpawnPointController>();
			}
			GameController.instance.standButtons = this;
			if (editCam != null)
			{
				editCam.gameObject.SetActive(value: false);
			}
		}
	}
}
public class LevelStarDisplay : MonoBehaviour
{
	public Sprite onSprite;

	public Sprite offSprite;

	public Sprite disabledSprite;

	public Transform starContainer;

	public StarPortraitController starPrefab;

	public Vector2 spacing;

	public bool set;

	public void setTo(LocationData location)
	{
		foreach (Transform item in starContainer)
		{
			UnityEngine.Object.Destroy(item.gameObject);
		}
		Vector2 vector = default(Vector2);
		for (int i = 0; i < location.characters().Length; i++)
		{
			StarPortraitController starPortraitController = UnityEngine.Object.Instantiate(starPrefab, starContainer);
			starPortraitController.transform.localPosition = new Vector3(-150f, 100f + vector.y * spacing.y, 0f);
			starPortraitController.setTo(location.characters()[i]);
			vector.y -= 1f;
		}
		set = true;
	}

	public void setTo(CharacterData character)
	{
		foreach (Transform item in starContainer)
		{
			UnityEngine.Object.Destroy(item.gameObject);
		}
		StarPortraitController starPortraitController = UnityEngine.Object.Instantiate(starPrefab, starContainer);
		starPortraitController.transform.localPosition = new Vector3(-150f, 100f, 0f);
		starPortraitController.setTo(character);
		set = true;
	}
}
public class LoadScene : MonoBehaviour
{
	public int sceneID;

	public float delay;

	private void Start()
	{
		if (delay > 0f)
		{
			Invoke("delayedStart", delay);
			return;
		}
		Fader.paused = true;
		SceneManager.LoadSceneAsync(sceneID);
	}

	private void delayedStart()
	{
		SceneManager.LoadSceneAsync(sceneID);
	}
}
public class LoadingTextLanguage : MonoBehaviour
{
	private TextMeshProUGUI txt;

	public TMP_FontAsset chineseFont;

	public TMP_FontAsset englishFont;

	public string englishText;

	public string chineseText;

	private void Awake()
	{
		bool flag = Application.systemLanguage == SystemLanguage.Chinese || Application.systemLanguage == SystemLanguage.ChineseSimplified || Application.systemLanguage == SystemLanguage.ChineseTraditional;
		txt = GetComponent<TextMeshProUGUI>();
		txt.font = (flag ? chineseFont : englishFont);
		txt.text = (flag ? chineseText : englishText);
	}

	private void Update()
	{
	}
}
public class LocalisationController : MonoBehaviour
{
	public enum Language
	{
		English,
		Test,
		Chinese
	}

	public enum Action
	{
		None,
		ImportChinese,
		Validate
	}

	public static LocalisationController instance;

	public Language language;

	public bool refresh;

	public GameData gameData;

	public string[] extraPhrases;

	[TextArea(5, 5)]
	public string[] extraPhrases_Long;

	public List<LocaliseText> added;

	public LocalisationData data;

	private Dictionary<string, LocaliseText> localised = new Dictionary<string, LocaliseText>();

	public string filePath;

	[Range(0f, 1f)]
	public float saveTimer;

	private AudioSource audioSource;

	public Action action;

	public TMP_FontAsset defaultFont;

	public TMP_FontAsset chineseFont;

	[Header("Importing")]
	[TextArea(5, 15)]
	public string chineseCharacters;

	public bool addingEnabled;

	private void Start()
	{
		foreach (LocaliseText item in added)
		{
			if (item.englishPhrase.Contains("Qing Soldiers"))
			{
				item.englishPhrase = item.englishPhrase.Replace("Qing Soldiers", "Soldiers");
				UnityEngine.Debug.LogError("Swapped: " + item.englishPhrase);
			}
			else if (item.englishPhrase.Contains("Qing"))
			{
				UnityEngine.Debug.LogError("?" + item.englishPhrase);
			}
			if (item.chinesePhrase.Contains("清兵"))
			{
				item.chinesePhrase = item.chinesePhrase.Replace("清兵", "卫兵");
				UnityEngine.Debug.LogError("Swapped: " + item.chinesePhrase);
			}
		}
		language = ((Application.systemLanguage == SystemLanguage.Chinese || Application.systemLanguage == SystemLanguage.ChineseSimplified || Application.systemLanguage == SystemLanguage.ChineseTraditional) ? Language.Chinese : Language.English);
		filePath = "Assets/Resources/localisation.dat";
		audioSource = GetComponent<AudioSource>();
		instance = this;
		Load();
		refresh = true;
		string[] array = extraPhrases;
		foreach (string text in array)
		{
			getText("General", text);
		}
		array = extraPhrases_Long;
		foreach (string text2 in array)
		{
			getText("Game Description", text2);
		}
		Invoke("localiseData", 1f);
	}

	private void Update()
	{
		if (refresh)
		{
			refresh = false;
		}
		if (saveTimer > 0f)
		{
			saveTimer -= Time.deltaTime;
			if (saveTimer <= 0f)
			{
				Save();
				saveTimer = 0f;
			}
		}
		Action action = this.action;
		if (this.action == Action.None)
		{
			return;
		}
		this.action = Action.None;
		switch (action)
		{
		case Action.ImportChinese:
			importChineseCharacters(GameData.instance.webPageFolderPath);
			break;
		case Action.Validate:
		{
			foreach (LocaliseText item in added)
			{
				if (item.chinesePhrase == "??" || item.chinesePhrase == "")
				{
					UnityEngine.Debug.LogError(item.englishPhrase + " has no chinese");
				}
			}
			break;
		}
		}
	}

	private void Load()
	{
		if (File.Exists(filePath) && added.Count == 0)
		{
			BinaryFormatter binaryFormatter = new BinaryFormatter();
			new TextAsset();
			FileStream fileStream = File.Open(filePath, FileMode.Open);
			instance.data = (LocalisationData)binaryFormatter.Deserialize(fileStream);
			added.Clear();
			added.AddRange(instance.data.phrases);
			fileStream.Close();
		}
		foreach (LocaliseText item in added)
		{
			localised[item.englishPhrase] = item;
			item.getName();
		}
	}

	private void Save()
	{
		audioSource.Play();
		BinaryFormatter binaryFormatter = new BinaryFormatter();
		FileStream fileStream = File.Create(filePath);
		instance.data.phrases = added.ToArray();
		binaryFormatter.Serialize(fileStream, instance.data);
		fileStream.Close();
	}

	public string[] parseText(string allText)
	{
		List<string> list = new List<string>();
		list.Add("");
		bool flag = false;
		int num = 0;
		for (int i = 0; i < allText.Length; i++)
		{
			char c = allText[i];
			if (c == '"')
			{
				flag = !flag;
			}
			if (c == ',' && flag)
			{
				list[num] += "<comma>";
			}
			else if (c == '\n')
			{
				if (flag)
				{
					list[list.Count - 1] += "<br>";
					continue;
				}
				num++;
				list.Add("");
			}
			else
			{
				list[list.Count - 1] += c;
			}
		}
		return list.ToArray();
	}

	public void importChineseCharacters(string webPageFolderPath)
	{
		string path = webPageFolderPath + "/localisation_chinese.csv";
		string[] array = parseText(File.ReadAllText(path));
		int num = 0;
		string[] array2 = array;
		foreach (string text in array2)
		{
			if (!(text != ""))
			{
				continue;
			}
			if (num >= 2)
			{
				int num2 = 0;
				bool flag = false;
				List<string> list = new List<string>();
				list.Add("");
				string text2 = text;
				for (int j = 0; j < text2.Length; j++)
				{
					char c = text2[j];
					if (c == '"')
					{
						flag = !flag;
					}
					if (c == ',')
					{
						if (flag)
						{
							list[num2] += "<comma>";
						}
						else
						{
							num2++;
						}
					}
					else
					{
						list[num2] += c;
						if (!chineseCharacters.Contains(c.ToString()))
						{
							chineseCharacters += c;
						}
					}
					if (num2 >= list.Count)
					{
						list.Add("");
					}
				}
				if (list.Count > 2)
				{
					list[1] = list[1].Replace("\"", "");
					list[1] = list[1].Replace("<br>", "\n");
					list[1] = list[1].Replace("<comma>", ",");
					list[2] = list[2].Replace("\"", "");
					list[2] = list[2].Replace("<br>", "\n");
					list[2] = list[2].Replace("<comma>", ",");
					if (list[1] != "")
					{
						if (instance.localised.ContainsKey(list[1]))
						{
							if (instance.localised[list[1]].chinesePhrase != list[2])
							{
								instance.localised[list[1]].chinesePhrase = list[2];
								UnityEngine.Debug.LogError(num + " added:" + list[1] + " > " + list[2] + " (" + list[0] + ")");
							}
						}
						else if (list[0] == "")
						{
							UnityEngine.Debug.LogError("Coulndt find: " + list[1] + " - no category, so not adding");
						}
						else
						{
							UnityEngine.Debug.LogError("Coulndt find: " + list[1] + "(" + list[0] + ") adding...");
							LocaliseText localiseText = new LocaliseText();
							localiseText.category = list[0];
							localiseText.englishPhrase = list[1];
							localiseText.chinesePhrase = list[2];
							added.Add(localiseText);
						}
					}
				}
			}
			num++;
		}
		UnityEngine.Debug.LogError(chineseCharacters.Length + " chinese characters");
	}

	public void exportCSV(string webPageFolderPath)
	{
		StreamWriter streamWriter = File.CreateText(webPageFolderPath + "/localisation.csv");
		streamWriter.WriteLine("Category,English,Localized");
		string text = "";
		LocaliseText[] phrases = data.phrases;
		foreach (LocaliseText localiseText in phrases)
		{
			if (text != localiseText.category)
			{
				streamWriter.WriteLine("");
				text = localiseText.category;
			}
			string value = "\"" + localiseText.category + "\",\"" + localiseText.englishPhrase + "\",\"" + localiseText.chinesePhrase + "\"";
			streamWriter.WriteLine(value);
		}
		streamWriter.Close();
	}

	public void localiseData()
	{
		if (addingEnabled)
		{
			PressurePointData[] pressurePoints = gameData.pressurePoints;
			for (int i = 0; i < pressurePoints.Length; i++)
			{
				pressurePoints[i].localise();
			}
			CharacterData[] characters = gameData.characters;
			for (int i = 0; i < characters.Length; i++)
			{
				characters[i].localise();
			}
			SpecialMoveData[] specialMoves = gameData.specialMoves;
			for (int i = 0; i < specialMoves.Length; i++)
			{
				specialMoves[i].localise();
			}
			PerkData[] perks = gameData.perks;
			for (int i = 0; i < perks.Length; i++)
			{
				perks[i].localise("Perk");
			}
			perks = gameData.weaknesses;
			for (int i = 0; i < perks.Length; i++)
			{
				perks[i].localise("Weakness");
			}
			pressurePoints = gameData.pressurePoints;
			for (int i = 0; i < pressurePoints.Length; i++)
			{
				pressurePoints[i].localise();
			}
			LocationData[] locations = gameData.locations;
			for (int i = 0; i < locations.Length; i++)
			{
				locations[i].localise();
			}
			CharacterEffectData[] characterEffects = gameData.characterEffects;
			for (int i = 0; i < characterEffects.Length; i++)
			{
				characterEffects[i].localise();
			}
			string[] tips = gameData.tips;
			foreach (string text in tips)
			{
				getText("Tip", text);
			}
			GameModeData[] specialModes = gameData.specialModes;
			for (int i = 0; i < specialModes.Length; i++)
			{
				specialModes[i].localise();
			}
			VRControlTip[] vrControlTips = gameData.vrControlTips;
			for (int i = 0; i < vrControlTips.Length; i++)
			{
				vrControlTips[i].localise();
			}
			OptionCategory[] options = gameData.options;
			for (int i = 0; i < options.Length; i++)
			{
				options[i].localise();
			}
			DifficultyLevel[] difficultyLevels = Settings.instance.difficultyLevels;
			for (int i = 0; i < difficultyLevels.Length; i++)
			{
				difficultyLevels[i].localise();
			}
			clearText("Achievement Description");
			AchievementData[] achievements = AchievementsController.instance.achievements;
			for (int i = 0; i < achievements.Length; i++)
			{
				achievements[i].localise();
			}
			GameStat[] stats = Saving.instance.savedProgress.stats.stats;
			foreach (GameStat gameStat in stats)
			{
				getText("Statistic", gameStat.name);
			}
			added.Sort(sortAdded);
		}
	}

	private int sortAdded(LocaliseText t1, LocaliseText t2)
	{
		return t1.category.CompareTo(t2.category);
	}

	public static void getText(string category, TextMeshProUGUI textMesh)
	{
		if (!(textMesh == null) && !(textMesh.text == ""))
		{
			textMesh.text = getText(category, textMesh.text);
		}
	}

	public static void clearText(string category)
	{
		if (instance.language == Language.English || instance.added.Count == 0)
		{
			return;
		}
		for (int num = instance.added.Count - 1; num >= 0; num--)
		{
			LocaliseText localiseText = instance.added[num];
			if (localiseText.category == category)
			{
				instance.added.RemoveAt(num);
				if (!instance.localised.ContainsKey(localiseText.englishPhrase))
				{
					UnityEngine.Debug.LogError("Counldt find: " + localiseText.englishPhrase);
				}
				instance.localised.Remove(localiseText.englishPhrase);
			}
		}
	}

	public static string replaceText(string category, string text, string replace)
	{
		return getText(category, text).Replace("[x]", replace);
	}

	public static string getChinese(string text)
	{
		if (!instance.localised.ContainsKey(text))
		{
			UnityEngine.Debug.LogError("Couldnt find: " + text + " (out of " + instance.localised.Count + ")");
			return "???";
		}
		return instance.localised[text].chinesePhrase;
	}

	public static string getText(string category, string text, bool suppressError = false)
	{
		if (instance.language == Language.English)
		{
			return text;
		}
		if (text == "")
		{
			return "";
		}
		if (Application.isEditor && text.Length > 2 && text.Substring(0, 2) == "??")
		{
			UnityEngine.Debug.LogError("Double localise: " + text);
			return "!!!";
		}
		if (instance.localised.ContainsKey(text))
		{
			if (instance.localised[text].chinesePhrase == "??" || instance.language == Language.Test)
			{
				if (instance.localised[text].englishPhrase.Length < 2)
				{
					return "?" + instance.localised[text].englishPhrase + "?";
				}
				return "??" + instance.localised[text].englishPhrase.Substring(2, instance.localised[text].englishPhrase.Length - 2);
			}
			return instance.localised[text].chinesePhrase;
		}
		LocaliseText localiseText = new LocaliseText();
		localiseText.category = category;
		localiseText.englishPhrase = text;
		localiseText.chinesePhrase = "??";
		localiseText.name = category + ": ";
		if (text.Length > 30)
		{
			localiseText.name += text.Substring(0, 30);
		}
		else
		{
			localiseText.name += text;
		}
		instance.localised[text] = localiseText;
		instance.added.Add(localiseText);
		if (instance.addingEnabled)
		{
			instance.saveTimer = 1f;
		}
		if (!suppressError)
		{
			UnityEngine.Debug.LogError("Localise couldnt find: " + localiseText.name);
		}
		if (text.Length < 2)
		{
			return "?" + text + "?";
		}
		return "??" + text.Substring(2, text.Length - 2);
	}
}
[Serializable]
public class LocalisationData
{
	public LocaliseText[] phrases;
}
[Serializable]
public class LocaliseText
{
	public string name;

	[TextArea(1, 15)]
	public string englishPhrase;

	public string category;

	[TextArea(1, 15)]
	public string chinesePhrase;

	public void getName()
	{
		if (name.Length <= 1)
		{
			name = category + ": ";
			if (englishPhrase.Length > 30)
			{
				name += englishPhrase.Substring(0, 30);
			}
			else
			{
				name += englishPhrase;
			}
		}
	}
}
public class LocaliseThis : MonoBehaviour
{
	public string category;

	private void Start()
	{
		TextMeshProUGUI component = GetComponent<TextMeshProUGUI>();
		if (component != null)
		{
			if (category == null)
			{
				UnityEngine.Debug.LogError("No category for localisation: " + base.name);
			}
			LocalisationController.getText(category, component);
		}
		else if (category == null)
		{
			UnityEngine.Debug.LogError("No text area for localisation: " + base.name);
		}
	}

	private void Update()
	{
	}
}
public class LocalisedFont : MonoBehaviour
{
	public TMP_Text[] txt;

	public float[] origSize;

	public bool overrideLanguage;

	public LocalisationController.Language overrideLanguageWith;

	public LocalisationController.Language language;

	public bool debug;

	private void Start()
	{
		if (txt.Length == 0)
		{
			txt = GetComponentsInChildren<TMP_Text>();
		}
		setFont();
		if (debug)
		{
			UnityEngine.Debug.LogError("here start");
		}
	}

	private void setFont()
	{
		if (LocalisationController.instance == null)
		{
			return;
		}
		language = LocalisationController.instance.language;
		if (overrideLanguage)
		{
			language = overrideLanguageWith;
		}
		bool flag = origSize == null || origSize.Length == 0;
		if (flag)
		{
			origSize = new float[txt.Length];
		}
		int num = 0;
		TMP_Text[] array = txt;
		for (int i = 0; i < array.Length; i++)
		{
			TextMeshProUGUI textMeshProUGUI = (TextMeshProUGUI)array[i];
			if (flag)
			{
				origSize[num] = textMeshProUGUI.fontSizeMax;
			}
			textMeshProUGUI.font = ((language == LocalisationController.Language.Chinese) ? LocalisationController.instance.chineseFont : LocalisationController.instance.defaultFont);
			textMeshProUGUI.fontSizeMax = ((language == LocalisationController.Language.Chinese) ? 90f : origSize[num]);
		}
	}

	private void Update()
	{
		if (debug)
		{
			UnityEngine.Debug.LogError(LocalisationController.instance.language.ToString() + "!=" + language);
		}
		if (LocalisationController.instance.language != language)
		{
			if (debug)
			{
				UnityEngine.Debug.LogError("here");
			}
			setFont();
		}
	}
}
[Serializable]
public class LocationData
{
	public enum HomeLocation
	{
		ShaolinTemple,
		BambooForest,
		Restaurant,
		Dojo,
		Cult,
		WingChunSchool,
		ChengSchool,
		BoxingRing,
		ImperialPalace,
		LeiTai,
		NinjaCamp,
		ChamberOfDespair,
		SnowyMountain,
		DragonTemple
	}

	public enum SpecialRequirement
	{
		None,
		BeatOthers,
		BeatFengXiu,
		BeatHighPriest
	}

	[Header("Level Settings")]
	public string name;

	public int id;

	public SpecialRequirement specialRequirement;

	public Texture thumbnail;

	[Header("Game Variables")]
	public bool unlocked;

	public int toUnlock;

	public int nextUnlock;

	public bool includeInDemo;

	public int gotStars;

	public int availableStars;

	public int totalStars;

	[NonSerialized]
	public bool charactersUnlocked;

	public void localise()
	{
		LocalisationController.getText("Location", name);
	}

	public CharacterData[] characters()
	{
		List<CharacterData> list = new List<CharacterData>();
		CharacterData[] characterOrder = GameController.instance.gameData.characterOrder;
		foreach (CharacterData characterData in characterOrder)
		{
			if (characterData.home == (HomeLocation)id)
			{
				list.Add(characterData);
			}
		}
		return list.ToArray();
	}

	public void reset()
	{
		toUnlock = 100;
		unlocked = false;
		nextUnlock = 100;
	}

	public string specialRequirementError()
	{
		if (!OptionData.getBool("Unlock All"))
		{
			switch (specialRequirement)
			{
			case SpecialRequirement.BeatFengXiu:
				if (!GameController.instance.gameData.getCharactersByName("Feng Xiu").beaten())
				{
					return LocalisationController.getText("Location Requirement", "Beat Feng Xiu");
				}
				break;
			case SpecialRequirement.BeatHighPriest:
				if (!GameController.instance.gameData.getCharactersByName("High Priest").beaten())
				{
					return LocalisationController.getText("Location Requirement", "Beat High Priest");
				}
				break;
			case SpecialRequirement.BeatOthers:
			{
				if (GameController.instance.difficultyLevel.name == "Master")
				{
					int num = Settings.instance.masterStarRequirement - GameData.instance.stars;
					if (num <= 0)
					{
						return "";
					}
					return LocalisationController.replaceText("Location Requirement", "[x] to unlock", num.ToString());
				}
				int num2 = toUnlock - GameController.instance.gameData.stars;
				if (num2 > 0)
				{
					return LocalisationController.replaceText("Location Requirement", "[x] to unlock", num2.ToString());
				}
				CharacterData[] characterOrder = GameController.instance.gameData.characterOrder;
				foreach (CharacterData characterData in characterOrder)
				{
					if (!characterData.beaten() && characterData.playable(allowUnlockedBosses: false, blockLevelLocked: false))
					{
						return LocalisationController.getText("Location Requirement", "Beat All Others");
					}
				}
				break;
			}
			}
		}
		return "";
	}

	public int starOrder()
	{
		return toUnlock - gotStars;
	}
}
public class MLPForceSaveProbes : MonoBehaviour
{
}
public class MaterialColourByDifficulty : MonoBehaviour
{
	public RigidBodies rb;

	public int materialIndex;

	public int index = -1;

	public bool showIfMain;

	public bool showIfAlt;

	public float difficulty = -1f;

	public Color setToColor;

	private void Start()
	{
	}

	private void Update()
	{
		if (!(rb.character == null) && !rb.character.isPlayer() && !(GameController.instance.specialMode.name != "Ninja Challenge") && difficulty != rb.character.difficulty && ((showIfAlt && rb.altCostume() == 1) || (showIfMain && rb.altCostume() == 0)))
		{
			difficulty = rb.character.difficulty;
			Color[] beltColours = Settings.instance.beltColours;
			index = Mathf.RoundToInt((float)(beltColours.Length - 1) * difficulty);
			GetComponent<SkinnedMeshRenderer>().materials[materialIndex].SetColor("_Color", beltColours[index]);
			setToColor = beltColours[index];
		}
	}
}
[Serializable]
public class MaterialSwap
{
	public string name;

	public Material material;
}
public class MenuButtonContoller : Breakable
{
	public delegate void OnPress(MenuButtonContoller button);

	public TextMeshProUGUI label;

	public TextMeshProUGUI englishLabel;

	public bool allowPointer;

	public Color offColour;

	public Color hoverColour;

	public float highlight;

	[NonSerialized]
	public RecordAction hoverAction;

	public string hoverText;

	public string action;

	public int id;

	public KeyCode shortcutKey;

	public Material emphasizeMaterial;

	private OnPress onPress;

	public static List<MenuButtonContoller> allButtons = new List<MenuButtonContoller>();

	public bool extraSpaceBefore;

	public void setup(bool localise, string labelText, string englishText, string action, OnPress onPress, int id = 0, bool empty = false)
	{
		if (label != null)
		{
			label.text = labelText;
			label.color = offColour;
			englishLabel.text = englishText;
			englishLabel.gameObject.SetActive(value: false);
			if (localise)
			{
				LocalisationController.getText("Button Label", label);
			}
		}
		if (empty)
		{
			offColour = Color.gray;
		}
		this.action = action;
		this.id = id;
		this.onPress = onPress;
		onNext = delegate
		{
			resetButton();
		};
		onSmash = delegate
		{
			disableAllButtons(disable: true);
		};
		allButtons.Add(this);
		for (int num = allButtons.Count - 1; num >= 0; num--)
		{
			if (allButtons[num] == null)
			{
				allButtons.RemoveAt(num);
			}
		}
	}

	public void emphasize()
	{
		label.fontSizeMax = 80f;
		mesh.material = emphasizeMaterial;
	}

	public bool highLight()
	{
		if (!allowPointer)
		{
			return false;
		}
		if (highlight == 1f)
		{
			return false;
		}
		highlight = 1f;
		label.color = hoverColour;
		return true;
	}

	public void smash()
	{
		hit(10f, special: false, Vector3.zero, Vector3.zero, "", wasPlayer: true);
	}

	public static void disableAllButtons(bool disable)
	{
		for (int num = allButtons.Count - 1; num >= 0; num--)
		{
			if (allButtons[num] == null)
			{
				allButtons.RemoveAt(num);
			}
			else
			{
				allButtons[num].disabled = disable;
			}
		}
	}

	private void resetButton()
	{
		disableAllButtons(disable: false);
		onPress(this);
		reset();
		highlight = 1f;
	}

	private void Update()
	{
		if (!disabled)
		{
			highlight = Mathf.MoveTowards(highlight, 0f, Time.deltaTime * 2f);
			if (shortcutKey != 0 && Input.GetKeyDown(shortcutKey))
			{
				smash();
			}
			if (label != null)
			{
				label.color = Color.Lerp(offColour, hoverColour, highlight);
			}
			if (englishLabel != null && OptionData.getBool("English Overlays"))
			{
				englishLabel.color = Color.Lerp(Color.clear, Color.green, highlight);
				englishLabel.gameObject.SetActive(highlight > 0f);
			}
		}
	}
}
public class MenuController : MonoBehaviour
{
	public GameObject title;

	public GameObject title_chinese;

	public TextMeshProUGUI heading;

	public TextMeshProUGUI extra;

	public TextMeshProUGUI version;

	public VRMenuActions vrActions;

	public MenuButtonContoller menuButtonPrefab;

	public List<MenuButtonContoller> buttons;

	public float spacing = 1f;

	public bool showing;

	public LineRenderer pointer;

	public Transform pointerFollowing;

	public LayerMask layerPress;

	private MenuButtonContoller hover;

	public int selectedStyle;

	public int selectedStance;

	public int selectedSpecialMove;

	public FightingStyle style;

	public float dist;

	public Color steamColour;

	public LayerMask layerMask;

	private int selectedOptionCat;

	private int selectedOption;

	private string onMenu;

	private string prevMenu;

	private int prevMenuID;

	public static bool firstTime = true;

	public bool mainMenu;

	private bool holding;

	public Collider colliding;

	public int debugModeCount;

	private void Awake()
	{
		clear();
		if (firstTime)
		{
			firstTime = false;
			Invoke("checkVersion", 0.25f);
		}
		holding = false;
	}

	private void checkVersion()
	{
		initShow();
	}

	public void mainMenuPosition()
	{
		setPos(4f, 3f, Vector3.zero);
		base.transform.position = new Vector3(base.transform.position.x, base.transform.position.y, 6f);
	}

	private void initShow()
	{
		mainMenuPosition();
		mainMenu = true;
		showMenu("");
	}

	public void fadeIn()
	{
		Fader.paused = false;
		WebLogging.log("Init Game", "FPS", Mathf.Round(GameController.instance.fps));
	}

	public void hide()
	{
		clear();
	}

	private void clear()
	{
		foreach (MenuButtonContoller button in buttons)
		{
			UnityEngine.Object.Destroy(button.gameObject);
		}
		buttons.Clear();
		showing = false;
		version.gameObject.SetActive(value: false);
		heading.gameObject.SetActive(value: false);
		title.gameObject.SetActive(value: false);
		title_chinese.gameObject.SetActive(value: false);
		extra.gameObject.SetActive(value: false);
	}

	public void setPos(float scale, float yOffset, Vector3 menuPosition)
	{
		if (scale > 1f)
		{
			base.transform.position = menuPosition + Vector3.up * yOffset;
			base.transform.rotation = Quaternion.identity;
		}
		else
		{
			Vector3 forward = Camera.main.transform.forward;
			forward.y = 0f;
			forward = forward.normalized;
			Vector3 vector = Camera.main.transform.position + Camera.main.transform.forward * scale;
			vector.y = yOffset;
			dist = (base.transform.position - vector).magnitude;
			base.transform.position = vector;
			base.transform.rotation = Quaternion.LookRotation(forward);
		}
		base.transform.localScale = scale / 2f * Vector3.one;
	}

	public void toggle(float scale)
	{
		if (showing)
		{
			clear();
			return;
		}
		setPos(scale, 1.6f, Vector3.zero);
		showMenu("");
	}

	private MenuButtonContoller addButton(bool localise, string label, string englishLabel, string action, int id = 0, bool empty = false, RecordAction hoverAction = null, string hoverText = "")
	{
		MenuButtonContoller menuButtonContoller = UnityEngine.Object.Instantiate(menuButtonPrefab, base.transform);
		menuButtonContoller.allowPointer = true;
		menuButtonContoller.setup(localise && GameController.instance.gameMode != GameController.GameMode.Edit, label, englishLabel, action, pressButtonNext, id, empty);
		menuButtonContoller.hoverAction = hoverAction;
		menuButtonContoller.hoverText = hoverText;
		menuButtonContoller.transform.localScale = Vector3.one;
		menuButtonContoller.impactDisabled = true;
		buttons.Add(menuButtonContoller);
		menuButtonContoller.background.GetComponent<MeshRenderer>().shadowCastingMode = ShadowCastingMode.Off;
		menuButtonContoller.background.GetComponent<MeshRenderer>().receiveShadows = false;
		return menuButtonContoller;
	}

	public void showMenu(string type, int extraID = 0)
	{
		onMenu = type;
		clear();
		extra.color = Color.white;
		showing = true;
		int num = 0;
		bool flag = true;
		debugModeCount = 0;
		prevMenuID = 0;
		switch (type)
		{
		case "option":
		{
			OptionData optionData2 = GameController.instance.gameData.options[selectedOptionCat].options[extraID];
			heading.text = optionData2.name;
			selectedOption = extraID;
			string[] values = optionData2.values;
			foreach (string text in values)
			{
				addButton(localise: false, LocalisationController.getText("Option", text), text, "chooseOptionValue", num);
				num++;
			}
			prevMenu = "optionCategory";
			prevMenuID = selectedOptionCat;
			break;
		}
		case "specialModes":
		{
			heading.text = "Choose Game Mode...";
			GameModeData[] specialModes = GameController.instance.gameData.specialModes;
			foreach (GameModeData gameModeData in specialModes)
			{
				if (gameModeData.enabled)
				{
					addButton(localise: false, LocalisationController.getText("Game Mode", gameModeData.name), gameModeData.name, "chooseSpecialMode", num, !gameModeData.unlocked, null, (!gameModeData.unlocked) ? (LocalisationController.getText("General", "To Unlock:") + " " + LocalisationController.getText("Game Mode Unlock", gameModeData.unlockInfo)) : LocalisationController.getText("Game Mode Description", gameModeData.description));
				}
				num++;
			}
			prevMenu = "play";
			break;
		}
		case "newSlots":
		{
			heading.text = "Choose Save Slot...";
			int num2 = 0;
			SaveGame[] saveSlots = Saving.instance.saveSlots;
			foreach (SaveGame saveGame in saveSlots)
			{
				addButton(localise: false, LocalisationController.replaceText("General", "Overwrite Slot [x]", (num2 + 1).ToString()), "Overwrite Slot " + (num2 + 1), "newSlot", num2, empty: false, null, saveGame.summary());
				num2++;
			}
			if (num2 < Settings.instance.maxSaveSlots)
			{
				addButton(localise: true, "New Slot", "New Slot", "newSlot", -1, empty: false, null, LocalisationController.getText("General", "Create a new game"));
			}
			break;
		}
		case "continueSlots":
		{
			heading.text = "Choose Save Slot...";
			int num3 = 0;
			SaveGame[] saveSlots = Saving.instance.saveSlots;
			foreach (SaveGame saveGame2 in saveSlots)
			{
				addButton(localise: false, LocalisationController.replaceText("General", "Save Slot [x]", (num3 + 1).ToString()), "Save Slot " + (num3 + 1), "continueSlot", num3, empty: false, null, saveGame2.summary());
				num3++;
			}
			break;
		}
		case "optionCategory":
		{
			OptionCategory optionCategory = GameController.instance.gameData.options[extraID];
			num = 0;
			heading.text = optionCategory.name;
			OptionData[] options = optionCategory.options;
			foreach (OptionData optionData in options)
			{
				if (!optionData.hideFromMenu)
				{
					if (optionData.values.Length == 0)
					{
						addButton(localise: true, optionData.name, optionData.name, "optionAction", num);
					}
					else
					{
						addButton(localise: false, LocalisationController.getText("Option", optionData.name) + ": " + LocalisationController.getText("Option", optionData.displayValue()), optionData.name + ": " + optionData.displayValue(), "optionToggle", num);
					}
				}
				num++;
			}
			prevMenu = "optionCategories";
			break;
		}
		case "optionCategories":
		{
			heading.text = "Options";
			if (mainMenu)
			{
				MenuButtonContoller menuButtonContoller = addButton(localise: true, "Quit Game", "Quit Game", "quit", 5, empty: false, null, LocalisationController.getText("General", "Quit to Desktop"));
			}
			OptionCategory[] options2 = GameController.instance.gameData.options;
			foreach (OptionCategory optionCategory2 in options2)
			{
				if (optionCategory2.options.Length != 0 && (optionCategory2.name != "Dev" || GameData.instance.devModeEnabled))
				{
					addButton(localise: true, optionCategory2.name, optionCategory2.name, "optionCategory", num);
				}
				num++;
			}
			prevMenu = "";
			break;
		}
		case "difficulty":
		{
			prevMenu = "";
			heading.text = "Choose Difficulty...";
			DifficultyLevel[] difficultyLevels = Settings.instance.difficultyLevels;
			foreach (DifficultyLevel difficultyLevel in difficultyLevels)
			{
				addButton(localise: true, difficultyLevel.name, difficultyLevel.name, "difficulty", num);
				num++;
			}
			break;
		}
		case "stance":
		{
			heading.text = currentStyle().name + " - Stance: " + selectedStance;
			prevMenu = "style";
			addButton(localise: true, "Stance", "Stance", "move", -1, currentStance().stance == null || currentStance().stance.isEmpty(), currentStance().stance);
			foreach (RecordAction attack in currentStyle().stances[selectedStance].attacks)
			{
				addButton(localise: true, attack.name, attack.name, "move", num, attack.isEmpty(), attack);
				num++;
			}
			MenuButtonContoller menuButtonContoller = addButton(localise: true, "+Attack", "+Attack", "addAttack", num);
			num = 0;
			foreach (FightingStyleCounter counter in currentStyle().stances[selectedStance].counters)
			{
				addButton(localise: true, counter.name, counter.name, "counter", num, counter.action.isEmpty(), counter.action);
				num++;
			}
			menuButtonContoller = addButton(localise: true, "+Counter", "+Counter", "addCounter", num);
			break;
		}
		case "style":
		{
			prevMenu = "styles";
			heading.text = currentStyle().name;
			addButton(localise: true, "Idle", "Idle", "move", 0, currentStyle().idle.isEmpty(), currentStyle().idle);
			addButton(localise: true, "Taunt", "Taunt", "move", 0, currentStyle().taunt.isEmpty(), currentStyle().taunt);
			MenuButtonContoller menuButtonContoller;
			foreach (FightingStyle_Stance stance in currentStyle().stances)
			{
				menuButtonContoller = addButton(localise: false, "Stance " + num, "Stance " + num, "stance", num, stance.attacks.Count == 0 && stance.counters.Count == 0, stance.stance);
				num++;
			}
			menuButtonContoller = addButton(localise: true, "+Stance", "+Stance", "addStance", num);
			break;
		}
		case "styles":
		{
			prevMenu = "";
			heading.text = "Edit Fighting Styles";
			MenuButtonContoller menuButtonContoller;
			foreach (FightingStyle fightingStyle in MoveRecorder.instance.actions.fightingStyles)
			{
				menuButtonContoller = addButton(localise: false, fightingStyle.name, fightingStyle.name, "style", num, fightingStyle.stances.Count == 0, (fightingStyle.stances.Count == 0) ? null : fightingStyle.stances[0].stance);
				num++;
			}
			menuButtonContoller = addButton(localise: true, "+Style", "+Style", "addStyle", num);
			break;
		}
		case "specialMove":
		{
			prevMenu = "specialMoves";
			SpecialMove specialMove = currentSpecialMove();
			heading.text = specialMove.name;
			MenuButtonContoller menuButtonContoller = addButton(localise: true, "Pose", "Pose", "pose", 0, specialMove.pose.isEmpty(), specialMove.pose);
			foreach (RecordAction ai_attack in specialMove.ai_attacks)
			{
				menuButtonContoller = addButton(localise: false, "Move " + num, "Move " + num, "aiMove", num, empty: false, ai_attack);
				num++;
			}
			menuButtonContoller = addButton(localise: true, "+AI Move", "+AI Move", "addAIMove", num);
			break;
		}
		case "specialMoves":
		{
			prevMenu = "";
			heading.text = "Edit Special Moves";
			MenuButtonContoller menuButtonContoller;
			foreach (SpecialMove specialMove2 in MoveRecorder.instance.actions.specialMoves)
			{
				menuButtonContoller = addButton(localise: false, specialMove2.name, specialMove2.name, "specialMove", num, specialMove2.pose.isEmpty() || specialMove2.ai_attacks.Count == 0, specialMove2.pose);
				num++;
			}
			menuButtonContoller = addButton(localise: true, "+Special Move", "+Special Move", "addSpecialMove", num);
			break;
		}
		case "quitFight":
		{
			heading.text = "Quit?";
			MenuButtonContoller menuButtonContoller;
			if (GameController.instance.gameMode == GameController.GameMode.Normal)
			{
				if (GameController.instance.fightState == GameController.FightState.During)
				{
					menuButtonContoller = addButton(localise: true, "Abandon Fight", "Abandon Fight", "quit");
				}
				if (!GameController.instance.specialMode.singleRound)
				{
					if (GameController.instance.standButtons.type != StandButtonsController.Type.LevelPick)
					{
						menuButtonContoller = addButton(localise: true, "Choose Level", "Choose Level", "quit", 1);
					}
					if (GameController.instance.standButtons.type != StandButtonsController.Type.CharPick)
					{
						menuButtonContoller = addButton(localise: true, "Choose Character", "Choose Character", "quit", 2);
					}
					if (GameController.instance.standButtons.type != StandButtonsController.Type.Difficulty)
					{
						menuButtonContoller = addButton(localise: true, "Change Difficulty", "Change Difficulty", "quit", 3);
					}
				}
			}
			menuButtonContoller = addButton(localise: true, "Main Menu", "Main Menu", "quit", 4);
			menuButtonContoller = addButton(localise: true, "Quit Game", "Quit Game", "quit", 5, empty: false, null, LocalisationController.getText("General", "Quit to Desktop"));
			break;
		}
		case "quitting":
			heading.text = "Quitting...";
			flag = false;
			break;
		case "play":
		{
			prevMenu = "";
			MenuButtonContoller menuButtonContoller = addButton(localise: true, "Training Chambers", "Training Chambers", "begin", 1, empty: false, null, LocalisationController.getText("General", "Learn how to play in the Shaolin Training Chambers"));
			menuButtonContoller = addButton(localise: true, "New Game", "New Game", "begin", 2, empty: false, null, LocalisationController.getText("General", "Start a new game"));
			menuButtonContoller.extraSpaceBefore = true;
			menuButtonContoller = addButton(localise: true, "Continue", "Continue", "begin", 3, !Saving.gameExists(), null, LocalisationController.replaceText("General", "Continue game ([x] slots)", Saving.instance.saveSlots.Length.ToString()));
			bool flag2 = false;
			GameModeData[] specialModes = GameData.instance.specialModes;
			foreach (GameModeData gameModeData2 in specialModes)
			{
				if (gameModeData2.enabled && gameModeData2.unlocked)
				{
					flag2 = true;
					break;
				}
			}
			menuButtonContoller = addButton(localise: true, "Special Modes", "Special Modes", "begin", 4, !flag2, null, LocalisationController.getText("General", "Play some single round modes or variations on the main game"));
			menuButtonContoller.extraSpaceBefore = true;
			break;
		}
		case "":
			flag = false;
			heading.text = "";
			if (GameController.instance.gameData.defaultDevsOn)
			{
				heading.color = Color.magenta;
			}
			if (GameController.instance.player == null)
			{
				MenuButtonContoller menuButtonContoller;
				if (Application.isEditor)
				{
					menuButtonContoller = addButton(localise: true, "Edit Mode", "Edit Mode", "begin");
				}
				menuButtonContoller = addButton(localise: false, (LocalisationController.instance.language == LocalisationController.Language.Chinese) ? "English" : "简体中文", "", "toggleLanguage");
				menuButtonContoller.GetComponentInChildren<LocalisedFont>().overrideLanguage = true;
				menuButtonContoller.GetComponentInChildren<LocalisedFont>().overrideLanguageWith = ((LocalisationController.instance.language != LocalisationController.Language.Chinese) ? LocalisationController.Language.Chinese : LocalisationController.Language.English);
				menuButtonContoller = addButton(localise: true, "Calibrate", "Calibrate", "calibrate", 0, empty: false, null, LocalisationController.getText("General", "Configure Game to your height"));
				menuButtonContoller.extraSpaceBefore = true;
				menuButtonContoller = addButton(localise: true, "Options", "Options", "options", 0, empty: false, null, LocalisationController.getText("General", "Change Game Settings"));
				menuButtonContoller = addButton(localise: true, "Credits & Stats", "Credits & Stats", "credits", 0, empty: false, null, LocalisationController.getText("General", "See gameplay statistics and info about who made the game"));
				menuButtonContoller = ((!GameController.instance.gameData.demoVersion) ? addButton(localise: true, "Play", "Play", "play", 2, empty: false, null, LocalisationController.getText("General", "Play Dragon Fist: VR Kung Fu")) : addButton(localise: true, "Play Demo", "Play Demo", "begin", 2, empty: false, null, LocalisationController.getText("General", "Play Dragon Fist: VR Kung Fu")));
				menuButtonContoller.extraSpaceBefore = true;
				menuButtonContoller.emphasize();
				extra.text = "";
			}
			else if (!Application.isEditor || GameController.instance.paused)
			{
				heading.text = "Paused";
				if (GameController.instance.gameMode == GameController.GameMode.Chambers)
				{
					extra.text = LocalisationController.getText("Button Label", "Training Chambers");
				}
				else if (GameController.instance.specialMode.singleRound)
				{
					extra.text = LocalisationController.getText("Game Mode", GameController.instance.specialMode.name) + ": " + GameController.instance.specialModeScore;
				}
				else
				{
					extra.text = LocalisationController.getText("Game Mode", GameController.instance.specialMode.name) + " - " + LocalisationController.getText("Difficulty Level", GameController.instance.difficultyLevel.name);
				}
				MenuButtonContoller menuButtonContoller = addButton(localise: true, "Calibrate Height", "Calibrate Height", "calibrate");
				menuButtonContoller = addButton(localise: true, "Options", "Options", "options");
				menuButtonContoller = addButton(localise: true, "Quit", "Quit", "quitFight");
				if (GameController.instance.fightState == GameController.FightState.During)
				{
					menuButtonContoller = addButton(localise: true, "Abandon Fight", "Abandon Fight", "quit");
				}
				menuButtonContoller = addButton(localise: true, "Resume", "Resume", "resume");
			}
			else
			{
				heading.text = "Edit Mode";
				addButton(localise: true, "Styles", "Styles", "styles", num);
				addButton(localise: true, "Special Moves", "Special Moves", "specialMoves", num);
				addButton(localise: true, "Exit", "Exit", "exit", num);
			}
			break;
		case "steamGroup":
		{
			heading.text = "Steam Group";
			prevMenu = "";
			flag = false;
			MenuButtonContoller menuButtonContoller = addButton(localise: true, "Quit Game", "Quit Game", "quit", 5, empty: false, null, LocalisationController.getText("General", "Close the game"));
			menuButtonContoller = addButton(localise: true, "Continue", "Continue", "back", 0, empty: false, null, LocalisationController.getText("General", "Continue playing"));
			break;
		}
		default:
			heading.text = "Unknown: " + type;
			UnityEngine.Debug.LogError("Unknown: " + type);
			prevMenu = "";
			break;
		}
		if (flag)
		{
			addButton(localise: true, "< Back", "< Back", "back").extraSpaceBefore = true;
		}
		title.gameObject.SetActive(GameController.instance.player == null && LocalisationController.instance.language != LocalisationController.Language.Chinese);
		title_chinese.gameObject.SetActive(GameController.instance.player == null && LocalisationController.instance.language == LocalisationController.Language.Chinese);
		heading.gameObject.SetActive(value: true);
		extra.gameObject.SetActive(value: true);
		version.gameObject.SetActive(title_chinese.gameObject.activeInHierarchy || title.gameObject.activeInHierarchy);
		if (GameController.instance.gameMode != GameController.GameMode.Edit)
		{
			LocalisationController.getText("Menu Heading", heading);
		}
		int num4 = 8;
		Vector3 vector = default(Vector3);
		Vector3 vector2 = default(Vector3);
		float num5 = Mathf.Clamp(8f / (float)buttons.Count, 0.5f, 1f);
		foreach (MenuButtonContoller button in buttons)
		{
			if (button.extraSpaceBefore)
			{
				vector.x += spacing / 4f;
			}
			button.transform.localPosition = new Vector3(vector.x, vector.y, 0f) * num5;
			button.transform.localScale = Vector3.one * num5;
			if (vector.x > vector2.x)
			{
				vector2.x = vector.x;
			}
			if (vector.y < vector2.y)
			{
				vector2.y = vector.y;
			}
			vector.x += spacing;
			if (vector.x >= (float)num4 * spacing && GameController.instance.gameMode == GameController.GameMode.Edit)
			{
				vector.y -= spacing;
				vector.x = 0f;
			}
		}
		int num6 = 1;
		foreach (MenuButtonContoller button2 in buttons)
		{
			button2.transform.localPosition -= vector2 / 2f * num5;
			if (num6 < 10)
			{
				button2.shortcutKey = (KeyCode)(48 + num6);
				num6++;
			}
		}
		base.enabled = true;
	}

	public void recordMove(RecordAction action, RecordAction fromStance = null)
	{
		clear();
		string text = currentStyle().name + ": ";
		if (selectedStance > -1)
		{
			text = text + "Stance #" + selectedStance + " - ";
		}
		if (action != null)
		{
			text += action.name;
		}
		FaceCanvasController.addText(text);
		MoveRecorder.instance.setToRecord(action, fromStance);
		foreach (GameCharacter player in GameController.instance.players)
		{
			if (!player.isPlayer())
			{
				player.aiControl.replayer.doAction(action, loop: true, offsetHeight: false, 0.5f, "Replay");
			}
		}
	}

	public SpecialMove currentSpecialMove()
	{
		if (selectedSpecialMove < 0)
		{
			return null;
		}
		return MoveRecorder.instance.actions.specialMoves[selectedSpecialMove];
	}

	public FightingStyle currentStyle()
	{
		if (selectedStyle < 0)
		{
			return null;
		}
		return MoveRecorder.instance.actions.fightingStyles[selectedStyle];
	}

	public FightingStyle_Stance currentStance()
	{
		if (selectedStance < 0)
		{
			return null;
		}
		FightingStyle_Stance fightingStyle_Stance = currentStyle().stances[selectedStance];
		fightingStyle_Stance.setup(currentStyle(), clean: true, selectedStance);
		return fightingStyle_Stance;
	}

	public void pressButton(MenuButtonContoller button)
	{
		button.hit(10f, special: false, Vector3.zero, Vector3.zero, "", wasPlayer: true);
	}

	public void pressButtonNext(MenuButtonContoller button)
	{
		switch (button.action)
		{
		case "difficulty":
			GameController.instance.clearFighters();
			clear();
			GameController.instance.scenes.pickCharacter();
			break;
		case "credits":
			GameController.instance.clearFighters();
			clear();
			GameController.instance.scenes.credits();
			break;
		case "setQuality":
			OptionData.getOption("Quality").setValue(button.id);
			showMenu("optionCategory", selectedOptionCat);
			break;
		case "optionAction":
			GameController.instance.gameData.options[selectedOptionCat].options[button.id].doAction();
			showMenu("optionCategory", selectedOptionCat);
			break;
		case "chooseOptionValue":
			GameController.instance.gameData.options[selectedOptionCat].options[selectedOption].setValue(button.id);
			showMenu("optionCategory", selectedOptionCat);
			break;
		case "optionToggle":
		{
			if (GameController.instance.gameData.options[selectedOptionCat].options[button.id].values.Length > 3)
			{
				showMenu("option", button.id);
				break;
			}
			OptionCategory obj = GameController.instance.gameData.options[selectedOptionCat];
			obj.options[button.id].next();
			obj.options[button.id].doAction();
			showMenu("optionCategory", selectedOptionCat);
			break;
		}
		case "optionCategory":
			selectedOptionCat = button.id;
			showMenu("optionCategory", button.id);
			break;
		case "options":
			showMenu("optionCategories");
			break;
		case "resume":
			GameController.instance.unpause();
			break;
		case "quitFight":
			showMenu("quitFight");
			break;
		case "quitToDesktop":
			Application.Quit();
			break;
		case "quit":
			GameController.instance.abandonFight();
			switch (button.id)
			{
			case 1:
				GameController.instance.scenes.pickLevel();
				break;
			case 2:
				GameController.instance.scenes.pickCharacter();
				break;
			case 3:
				GameController.instance.scenes.chooseDifficulty();
				break;
			case 4:
				GameController.instance.scenes.mainMenu();
				break;
			case 5:
				showMenu("quitting");
				Invoke("quit", 0.5f);
				return;
			}
			GameController.instance.unpause();
			break;
		case "chooseDifficulty":
			GameController.instance.gameMode = GameController.GameMode.Normal;
			showMenu("difficulty");
			break;
		case "chooseSpecialMode":
			if (GameController.instance.gameData.specialModes[button.id].unlocked || OptionData.getBool("Unlock All"))
			{
				GameController.instance.gameMode = GameController.GameMode.Normal;
				GameController.instance.specialMode = GameController.instance.gameData.specialModes[button.id];
				if (GameController.instance.specialMode.saves)
				{
					showMenu("newSlots");
					break;
				}
				GameController.instance.gameData.setupNewGame(0);
				WebLogging.log("New Game", GameController.instance.specialMode.name, 0f);
				GameController.instance.clearFighters();
				clear();
				GameController.instance.scenes.pickCharacter();
			}
			break;
		case "play":
			showMenu("play");
			break;
		case "newSlot":
			GameController.instance.gameMode = GameController.GameMode.Normal;
			WebLogging.log("New Game", GameController.instance.specialMode.name, button.id);
			GameController.instance.gameData.setupNewGame(button.id);
			GameController.instance.clearFighters();
			clear();
			GameController.instance.scenes.pickCharacter();
			break;
		case "continueSlot":
			GameController.instance.gameMode = GameController.GameMode.Normal;
			Saving.loadGame(button.id);
			clear();
			GameController.instance.scenes.pickLevel();
			WebLogging.log("Continue Game - Slot " + button.id, Saving.instance.saveGameData.summary(), button.id);
			break;
		case "toggleLanguage":
			LocalisationController.instance.language = ((LocalisationController.instance.language != LocalisationController.Language.Chinese) ? LocalisationController.Language.Chinese : LocalisationController.Language.English);
			ChambersController.instance.refreshTips = true;
			showMenu("");
			break;
		case "begin":
			if (button.id == 0)
			{
				GameController.instance.gameMode = GameController.GameMode.Edit;
				GameController.instance.aiMode = 2;
				GameController.instance.difficultyLevel = Settings.instance.difficultyLevels[Settings.instance.difficultyLevels.Length - 1];
				GameController.instance.addPlayer();
				GameController.instance.addFighter(1, GameController.instance.gameData.randomCharacter(allowUnlockedBosses: true, allowSpecials: true), 1, Vector3.forward * 5f, 180f, 1f, aboveGround: true);
				GameController.instance.hud.setup();
				clear();
				WebLogging.log("Edit Mode", "", 0f);
			}
			else if (button.id == 1)
			{
				GameController.instance.difficultyLevel = Settings.instance.difficultyLevels[0];
				GameController.instance.gameMode = GameController.GameMode.Chambers;
				GameController.instance.characterID = 0;
				GameController.instance.addPlayer(1);
				WebLogging.log("Begin Game", "Chambers", 0f);
				clear();
			}
			else if (button.id == 2)
			{
				if (Saving.instance.saveSlots.Length != 0 || Settings.instance.allowSaveSlots)
				{
					GameController.instance.specialMode = GameController.instance.gameData.specialModes[0];
					showMenu("newSlots");
					break;
				}
				GameController.instance.gameMode = GameController.GameMode.Normal;
				GameController.instance.specialMode = GameController.instance.gameData.specialModes[0];
				WebLogging.log("New Game", GameController.instance.specialMode.name, 0f);
				GameController.instance.gameData.setupNewGame(0);
				GameController.instance.clearFighters();
				clear();
				GameController.instance.scenes.pickCharacter();
			}
			else if (button.id == 3)
			{
				if (Saving.instance.saveSlots.Length == 0)
				{
					break;
				}
				if (Saving.instance.saveSlots.Length > 1 || Settings.instance.allowSaveSlots)
				{
					showMenu("continueSlots");
					break;
				}
				GameController.instance.gameMode = GameController.GameMode.Normal;
				Saving.loadGame(0);
				clear();
				GameController.instance.scenes.pickLevel();
				WebLogging.log("Continue Game", GameController.instance.difficultyLevel.name + " " + GameController.instance.selectedCharacter().name, 0f);
			}
			else if (button.id == 4)
			{
				showMenu("specialModes");
			}
			else
			{
				showMenu("begin");
			}
			ChambersController.instance.gameObject.SetActive(value: true);
			ChambersController.instance.setup();
			break;
		case "move":
			if (button.label.text == "Idle")
			{
				recordMove(currentStyle().idle);
			}
			else if (button.label.text == "Taunt")
			{
				recordMove(currentStyle().taunt);
			}
			else if (button.id == -1)
			{
				recordMove(currentStance().stance);
			}
			else
			{
				recordMove(currentStance().attacks[button.id], currentStance().stance);
			}
			break;
		case "counter":
			recordMove(currentStance().counters[button.id].action, currentStance().stance);
			break;
		case "pose":
			recordMove(currentSpecialMove().pose);
			break;
		case "stance":
			selectedStance = button.id;
			showMenu("stance");
			break;
		case "style":
			selectedStyle = button.id;
			style = MoveRecorder.instance.actions.fightingStyles[selectedStyle];
			if (GameController.instance.players.Count >= 2)
			{
				GameController.instance.players[1].fightingStyle = selectedStyle;
			}
			showMenu("style");
			break;
		case "addSpecialMove":
			MoveRecorder.instance.actions.specialMoves.Add(new SpecialMove("Special " + MoveRecorder.instance.actions.specialMoves.Count));
			showMenu("specialMoves");
			break;
		case "aiMove":
			recordMove(currentSpecialMove().ai_attacks[button.id], currentSpecialMove().pose);
			break;
		case "addAIMove":
			currentSpecialMove().ai_attacks.Add(new RecordAction("Attack " + (currentSpecialMove().ai_attacks.Count + 1)));
			showMenu("specialMove");
			break;
		case "addStyle":
			MoveRecorder.instance.actions.fightingStyles.Add(FightingStyle.createNew());
			showMenu("styles");
			break;
		case "addStance":
			currentStyle().stances.Add(new FightingStyle_Stance());
			showMenu("style");
			break;
		case "addAttack":
			currentStance().attacks.Add(new RecordAction("Attack " + (currentStance().attacks.Count + 1)));
			showMenu("stance");
			break;
		case "addCounter":
			currentStance().counters.Add(new FightingStyleCounter("Counter " + (currentStance().attacks.Count + 1)));
			showMenu("stance");
			break;
		case "exit":
			clear();
			GameController.instance.scenes.mainMenu();
			break;
		case "specialMove":
			selectedSpecialMove = button.id;
			showMenu("specialMove");
			break;
		case "specialMoves":
			showMenu("specialMoves");
			break;
		case "calibrate":
			GameController.instance.calibrating = true;
			break;
		case "steamGroup":
			openLink("https://steamcommunity.com/app/1722380", "Steam Group", "The steam group has been opened in your web browser");
			break;
		case "styles":
			showMenu("styles");
			break;
		case "back":
			showMenu(prevMenu);
			break;
		default:
			FaceCanvasController.addText("Unknown Action: " + button.action);
			break;
		case "recentre":
			break;
		}
	}

	public void openLink(string strURL, string heading, string message)
	{
		Application.OpenURL(strURL);
		showMenu("steamGroup");
		this.heading.text = heading;
		extra.text = message;
	}

	private void quit()
	{
		UnityEngine.Debug.Log("Quit");
		if (Application.isEditor)
		{
			UnityEngine.Debug.LogError("Quitting...");
		}
		Application.Quit();
	}

	private void Update()
	{
		pointer.gameObject.SetActive(showing);
		if (!showing)
		{
			return;
		}
		version.text = LocalisationController.getText("General", "Version") + ": " + GameData.instance.version.ToString();
		if (GameController.instance.player == null || GameController.instance.paused)
		{
			pointerFollowing = VRMainRigController.instance.pointer;
			if (mainMenu)
			{
				Vector3 position = ((!(GameController.instance.noPlayer.activeRig.trackers[0].position.z > -5f)) ? new Vector3(base.transform.position.x, base.transform.position.y, 0f) : new Vector3(base.transform.position.x, base.transform.position.y, Mathf.Round(GameController.instance.noPlayer.activeRig.trackers[0].transform.position.z * 3f) / 3f + 5f));
				base.transform.position = position;
			}
		}
		else
		{
			pointerFollowing = GameController.instance.player.playerController.menuPointer;
		}
		pointer.SetPosition(0, pointerFollowing.position);
		Ray ray = new Ray(pointerFollowing.position, pointerFollowing.forward);
		hover = null;
		pointer.startColor = Color.red;
		pointer.endColor = Color.clear;
		colliding = null;
		if (Physics.Raycast(ray, out var hitInfo, 100f, layerMask) && !holding)
		{
			colliding = hitInfo.collider;
			hover = hitInfo.collider.transform.parent.GetComponent<MenuButtonContoller>();
			if (hover != null)
			{
				if (hover.highLight())
				{
					if (hover.hoverAction != null)
					{
						GameController.instance.aiMode = 2;
						foreach (GameCharacter player in GameController.instance.players)
						{
							if (!player.isPlayer())
							{
								player.aiControl.replayer.doAction(hover.hoverAction, loop: true, offsetHeight: false, 0.1f, "Replay");
							}
						}
					}
					if (mainMenu)
					{
						extra.text = hover.hoverText;
						extra.color = (hover.disabled ? Color.gray : Color.white);
					}
				}
				pointer.SetPosition(1, hitInfo.point);
				if (hover.allowPointer && (vrActions.press() || (GameController.instance.player == null && vrActions.noPlayer())))
				{
					pressButton(hover);
					holding = true;
					pointer.startColor = Color.white;
					pointer.endColor = Color.white;
				}
			}
			else
			{
				pointer.SetPosition(1, hitInfo.point);
				if (vrActions.press() || (GameController.instance.player == null && vrActions.noPlayer()))
				{
					holding = true;
					debugModeCount++;
					if (GameData.instance.devModeEnabled)
					{
						if (debugModeCount >= 5)
						{
							GeneralSounds.playSound(9);
							GameData.instance.devModeEnabled = false;
							debugModeCount = 0;
						}
					}
					else if (debugModeCount >= 20)
					{
						GeneralSounds.playSound(7);
						GameData.instance.devModeEnabled = true;
						debugModeCount = 0;
					}
				}
			}
		}
		else
		{
			if (!vrActions.press())
			{
				holding = false;
			}
			pointer.SetPosition(1, pointerFollowing.position + pointerFollowing.forward * 10f);
		}
		pointer.enabled = !holding;
	}
}
public class MoveRecorder : MonoBehaviour
{
	public static MoveRecorder instance;

	public bool recording;

	public float recordStep = 0.1f;

	public float recordingElapsed;

	public RecordTracker[] trackDisplays;

	public MeshRenderer leftHandStartPos;

	public MeshRenderer rightHandStartPos;

	public RecordedActions actions;

	public float playBackSpeed = 1f;

	public float lookPerc;

	public static bool alwaysLoop;

	private float startTimer;

	private int announced;

	private bool readyToGo;

	public AIController ai;

	private RecordAction recordingFromStance;

	private RecordAction recordingAction;

	public SavedFightingStyles saved;

	private void Start()
	{
		instance = this;
		RecordTracker[] array = trackDisplays;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].gameObject.SetActive(recording);
		}
		leftHandStartPos.gameObject.SetActive(value: false);
		rightHandStartPos.gameObject.SetActive(value: false);
		Saving.loadFightingStyles();
	}

	public void playback(MoveReplayer replayer, float speed, float heightOffset, float heightPerc, HeadRecoil headRecoil, HandPositions hands, float headLookPerc)
	{
		float num = 0f;
		num = heightOffset;
		replayer.currentAction.play(RecordAction.TrackerType.Head, replayer.playbackElapsed, playBackSpeed, replayer.looping, out var localPosition, out var localRotation, heightPerc + heightOffset);
		replayer.currentAction.play(RecordAction.TrackerType.L_Hand, replayer.playbackElapsed, playBackSpeed, replayer.looping, out var localPosition2, out var localRotation2, heightPerc + num);
		replayer.currentAction.play(RecordAction.TrackerType.R_Hand, replayer.playbackElapsed, playBackSpeed, replayer.looping, out var localPosition3, out var localRotation3, heightPerc + num);
		_ = replayer.head.rotation;
		if (replayer.transitionTo == replayer.currentAction)
		{
			replayer.head.transform.localPosition = localPosition;
			replayer.l_hand.transform.localPosition = localPosition2;
			replayer.r_hand.transform.localPosition = localPosition3;
			replayer.head.transform.localRotation = localRotation;
			replayer.l_hand.transform.localRotation = localRotation2;
			replayer.r_hand.transform.localRotation = localRotation3;
		}
		else
		{
			float e = replayer.playbackElapsed + replayer.transitionElapsed;
			num = (replayer.offsetHeight ? heightOffset : 0f);
			replayer.transitionTo.play(RecordAction.TrackerType.Head, e, playBackSpeed, replayer.looping, out var localPosition4, out var localRotation4, heightPerc + heightOffset);
			replayer.transitionTo.play(RecordAction.TrackerType.L_Hand, e, playBackSpeed, replayer.looping, out var localPosition5, out var localRotation5, heightPerc + num);
			replayer.transitionTo.play(RecordAction.TrackerType.R_Hand, e, playBackSpeed, replayer.looping, out var localPosition6, out var localRotation6, heightPerc + num);
			replayer.head.transform.localPosition = Vector3.Lerp(localPosition, localPosition4, replayer.transitionPerc);
			replayer.l_hand.transform.localPosition = Vector3.Lerp(localPosition2, localPosition5, replayer.transitionPerc);
			replayer.r_hand.transform.localPosition = Vector3.Lerp(localPosition3, localPosition6, replayer.transitionPerc);
			Quaternion.Lerp(localRotation, localRotation4, replayer.transitionPerc);
			replayer.head.transform.localRotation = Quaternion.Lerp(localRotation, localRotation4, replayer.transitionPerc);
			replayer.l_hand.transform.localRotation = Quaternion.Lerp(localRotation2, localRotation5, replayer.transitionPerc);
			replayer.r_hand.transform.localRotation = Quaternion.Lerp(localRotation3, localRotation6, replayer.transitionPerc);
			replayer.transitionPerc += Time.deltaTime / replayer.transitionTime;
			if (replayer.transitionPerc >= 1f)
			{
				replayer.currentAction = replayer.transitionTo;
				replayer.transitionPerc = 0f;
				replayer.playbackElapsed += replayer.transitionElapsed;
			}
		}
		float z = replayer.l_hand.localPosition.z;
		float z2 = replayer.r_hand.localPosition.z;
		replayer.unoffset_lPos = replayer.l_hand.transform.localPosition;
		replayer.unoffset_rPos = replayer.r_hand.transform.localPosition;
		if (replayer.l_offset != null)
		{
			replayer.l_hand.transform.position += replayer.l_offset.offset;
		}
		if (replayer.r_offset != null)
		{
			replayer.r_hand.transform.position += replayer.r_offset.offset;
		}
		if (Settings.instance.offsetRotation)
		{
			if (replayer.l_offset != null && replayer.l_offset.rotationOffset != Quaternion.identity)
			{
				replayer.l_hand.transform.rotation *= replayer.l_offset.rotationOffset;
			}
			if (replayer.r_offset != null && replayer.r_offset.rotationOffset != Quaternion.identity)
			{
				replayer.r_hand.transform.rotation *= replayer.r_offset.rotationOffset;
			}
		}
		if (headRecoil != null)
		{
			replayer.head.transform.position += headRecoil.offset;
			if (replayer.head.transform.localPosition.y < 0.65f)
			{
				replayer.head.transform.localPosition = new Vector3(replayer.head.transform.localPosition.x, 0.65f, replayer.head.transform.localPosition.z);
			}
			replayer.head.transform.rotation *= Quaternion.Euler(headRecoil.angleOffset);
			replayer.l_hand.transform.position += headRecoil.offset * Settings.instance.handHeadOffsetAmount;
			replayer.r_hand.transform.position += headRecoil.offset * Settings.instance.handHeadOffsetAmount;
			limitHand(replayer.l_hand, replayer, headRecoil.offset.magnitude, z);
			limitHand(replayer.r_hand, replayer, headRecoil.offset.magnitude, z2);
		}
		Vector3 vector = ((replayer.character == null) ? Vector3.zero : replayer.character.aiControl.playerLookTarget);
		Quaternion b = Quaternion.LookRotation(vector - replayer.head.transform.position);
		lookPerc = Mathf.MoveTowards(lookPerc, headLookPerc, Time.deltaTime * 2f);
		if (replayer.debugLine != null)
		{
			replayer.debugLine.SetColor(Color.Lerp(Color.green, Color.blue, headLookPerc));
			replayer.debugLine.LineTo(replayer.head.transform.position, vector);
		}
		replayer.head.transform.rotation = Quaternion.Lerp(replayer.head.transform.rotation, b, lookPerc);
		hands.l_squeezeAmount = (hands.l_squeezeAmount_secondary = replayer.currentAction.l_squeezeAmount);
		hands.r_squeezeAmount = (hands.r_squeezeAmount_secondary = replayer.currentAction.r_squeezeAmount);
		replayer.playbackElapsed += Time.deltaTime * speed;
	}

	private void limitHand(Transform hand, MoveReplayer replayer, float amount, float minLocalZ)
	{
		float num = 1.5f - amount;
		if (num < 0.5f)
		{
			num = 0.5f;
		}
		float num2 = 0.25f;
		Vector3 vector = hand.position - replayer.head.transform.position;
		if (vector.magnitude > num)
		{
			float num3 = vector.magnitude - num;
			hand.position -= vector.normalized * num3;
		}
		else if (vector.magnitude < num2)
		{
			float num4 = num2 - vector.magnitude;
			hand.position += vector.normalized * num4;
		}
		if (minLocalZ > 0.2f)
		{
			minLocalZ = 0.2f;
		}
		if (hand.localPosition.z < minLocalZ)
		{
			hand.localPosition = new Vector3(hand.localPosition.x, hand.localPosition.y, minLocalZ);
		}
	}

	public void setToRecord(RecordAction recordAction, RecordAction fromStance)
	{
		recordingFromStance = fromStance;
		recordingAction = recordAction;
		GameController.instance.aiMode = 2;
	}

	private bool checkHandsInPosition()
	{
		leftHandStartPos.gameObject.SetActive(recordingFromStance != null);
		rightHandStartPos.gameObject.SetActive(recordingFromStance != null);
		Transform[] transforms = GameController.instance.player.trackers.transforms;
		int num = 0;
		RecordTracker[] array = trackDisplays;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].setPosition(transforms[num]);
			num++;
		}
		if (recordingFromStance != null)
		{
			leftHandStartPos.transform.localPosition = recordingFromStance.l_hand[0].position;
			rightHandStartPos.transform.localPosition = recordingFromStance.r_hand[0].position;
			Vector3 vector = trackDisplays[1].transform.position - leftHandStartPos.transform.position;
			Vector3 vector2 = trackDisplays[2].transform.position - rightHandStartPos.transform.position;
			leftHandStartPos.material.color = (((double)vector.magnitude > 0.15) ? Color.red : Color.green);
			rightHandStartPos.material.color = (((double)vector2.magnitude > 0.15) ? Color.red : Color.green);
			if ((double)vector.magnitude > 0.15 || (double)vector2.magnitude > 0.15)
			{
				return false;
			}
		}
		return true;
	}

	private void Update()
	{
		if (GameController.instance.gameMode != GameController.GameMode.Edit)
		{
			return;
		}
		if (!recording)
		{
			if (startTimer > 0f)
			{
				bool flag = checkHandsInPosition();
				if (recordingFromStance == null)
				{
					flag = true;
				}
				int num = Mathf.CeilToInt(startTimer);
				if (num != announced)
				{
					FaceCanvasController.addText(num.ToString());
					announced = num;
				}
				if (flag)
				{
					startTimer -= Time.deltaTime;
				}
				else if (startTimer < 3f)
				{
					startTimer = Mathf.MoveTowards(startTimer, 3f, Time.deltaTime / 2f);
				}
				RecordTracker[] array = trackDisplays;
				foreach (RecordTracker obj in array)
				{
					obj.gameObject.SetActive(value: true);
					obj.clear();
				}
				if (startTimer <= 0f)
				{
					FaceCanvasController.addText("Ready....");
					recordingElapsed = 0f;
					readyToGo = true;
				}
			}
			else if (readyToGo && (!checkHandsInPosition() || recordingFromStance == null))
			{
				FaceCanvasController.addText("Go....");
				readyToGo = false;
				recording = true;
				leftHandStartPos.gameObject.SetActive(value: false);
				rightHandStartPos.gameObject.SetActive(value: false);
			}
		}
		if (!recording)
		{
			return;
		}
		if (recordingAction.singleFrame && recordingElapsed > 0f)
		{
			FaceCanvasController.addText("Done");
			recording = false;
			recordingAction.head = trackDisplays[0].getSteps();
			recordingAction.l_hand = trackDisplays[1].getSteps();
			recordingAction.r_hand = trackDisplays[2].getSteps();
			recordingAction.totalTime = 0f;
			recordingAction.setup(clean: true, "");
			GameController.instance.aiMode = 2;
			foreach (GameCharacter player in GameController.instance.players)
			{
				if (!player.isPlayer())
				{
					player.aiControl.replayer.doAction(recordingAction, loop: true, offsetHeight: false, 1f, "Finish Record");
				}
			}
			Saving.saveFightingStyles();
		}
		else
		{
			Transform[] transforms = GameController.instance.player.trackers.transforms;
			int num2 = 0;
			RecordTracker[] array = trackDisplays;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].record(recordingElapsed, recordStep, transforms[num2]);
				num2++;
			}
			recordingElapsed += Time.deltaTime;
		}
	}
}
public class MoveReplayer : MonoBehaviour
{
	public GameCharacter character;

	public Transform head;

	public Transform l_hand;

	public Transform r_hand;

	public PuppetTrackerHandOffset l_offset;

	public PuppetTrackerHandOffset r_offset;

	public float playbackElapsed;

	public RecordAction currentAction;

	public RecordAction transitionTo;

	public float transitionPerc;

	public float transitionTime = 1f;

	public float transitionElapsed;

	public string transitionNote;

	public bool looping;

	public bool offsetHeight;

	public bool verbose;

	public DebugLine debugLine;

	public Collider[] keepOutside;

	public Vector3 unoffset_lPos;

	public Vector3 unoffset_rPos;

	public void Start()
	{
		debugLine = GetComponent<DebugLine>();
		if (MoveRecorder.instance == null)
		{
			UnityEngine.Debug.LogError("Move recorder not setup yet");
		}
		currentAction = MoveRecorder.instance.actions.defaultAction;
		transitionTo = MoveRecorder.instance.actions.defaultAction;
	}

	public bool isTransitioning()
	{
		if (transitionTo.name == "")
		{
			return false;
		}
		return transitionTo != currentAction;
	}

	public void forceAction(RecordAction action)
	{
		transitionNote = "Forced";
		currentAction = (transitionTo = action);
		transitionTime = 0f;
		transitionElapsed = 0f;
	}

	public bool doAction(RecordAction action, bool loop, bool offsetHeight, float time, string note)
	{
		if (action == null)
		{
			if (verbose)
			{
				UnityEngine.Debug.LogError("Null action");
			}
			return false;
		}
		if (isTransitioning())
		{
			if (transitionTo == action)
			{
				return false;
			}
			if (verbose)
			{
				UnityEngine.Debug.LogError("Already Transitioning to: " + transitionTo.name + " attempting: " + action.name + " - " + transitionNote);
			}
			return false;
		}
		if (verbose)
		{
			UnityEngine.Debug.LogError("Play Action: " + action.name);
		}
		looping = loop;
		this.offsetHeight = offsetHeight;
		transitionNote = note;
		transitionTo = action;
		transitionTime = time;
		transitionElapsed = 0f - playbackElapsed;
		return true;
	}
}
public class MoveWithController : MonoBehaviour
{
	[Header("Steam VR Actions")]
	public VRCharacterActions vrActions;

	[Header("Settings")]
	public float jumpForce = 1f;

	public GameCharacter character;

	public MeshRenderer[] debugShapes;

	private Vector3 dir = Vector3.zero;

	public Transform[] scaledTrackers;

	public VRRig activeRig;

	public Transform menuPointer;

	public bool inBody = true;

	public float moveSpeedMod = 1f;

	public HealthBarController healthBar;

	public CharacterEffect.Effect testEffect;

	public float nextPause;

	public ControllerTipController controllerTips;

	private VRRunController runController;

	public float turnAmount;

	public float targetTime;

	public float outOfBodyTimer;

	public bool canTurn = true;

	private float samePosTimer;

	private Vector3 lastPos;

	private void Start()
	{
		activeRig = vrActions.activeRig();
		Transform muscleTransformByName = character.rigidBodies.getMuscleTransformByName("hand.R");
		if (muscleTransformByName == null)
		{
			muscleTransformByName = character.rigidBodies.getMuscleTransformByName("hand_r");
		}
		if (muscleTransformByName == null)
		{
			UnityEngine.Debug.LogError("Couldnt find hand");
		}
		controllerTips = VRMainRigController.controllerTips;
		Invoke("doubleCheck", 0.1f);
		refreshScale();
		runController = GetComponent<VRRunController>();
		GameController.instance.noPlayer.onCam = UnityEngine.Random.Range(0, 5);
	}

	private void doubleCheck()
	{
	}

	public void refreshScale()
	{
		activeRig = vrActions.activeRig();
		if (OptionData.getInt("Mode") == 0)
		{
			activeRig.transform.localScale = GameController.instance.gameData.calibrateScale * Vector3.one * character.data.heightScale;
			activeRig.transform.localPosition = Vector3.zero;
		}
		else
		{
			activeRig.transform.localScale = Vector3.one * character.data.heightScale;
			float num = GameController.instance.noPlayer.defaultY * character.data.heightScale * 0.98f - GameController.instance.noPlayer.headY;
			activeRig.transform.localPosition = Vector3.up * num;
		}
	}

	private void turning()
	{
		if (!inBody)
		{
			return;
		}
		float num = 0f;
		switch (OptionData.getInt("Turning Mode"))
		{
		case 0:
		{
			int num2 = 0;
			if (canTurn)
			{
				if (vrActions.turn() > 0.75f)
				{
					num2 = 1;
				}
				if (vrActions.turn() < -0.75f)
				{
					num2 = -1;
				}
				if (num2 != 0)
				{
					canTurn = false;
				}
			}
			else if (Mathf.Abs(vrActions.turn()) < 0.5f)
			{
				canTurn = true;
			}
			if (num2 == -1)
			{
				turnAmount -= Settings.instance.snapTurnAmount.lerp(OptionData.getPerc("Turning Speed"));
			}
			if (num2 == 1)
			{
				turnAmount += Settings.instance.snapTurnAmount.lerp(OptionData.getPerc("Turning Speed"));
			}
			num = turnAmount * Time.deltaTime / Time.timeScale;
			num *= 30f;
			if (num2 != 0)
			{
				character.trackers.turn();
				character.rigidBodies.swooshes[0].sleep();
				character.rigidBodies.swooshes[1].sleep();
			}
			turnAmount -= num;
			break;
		}
		case 1:
			turnAmount = vrActions.turn() * Settings.instance.smoothTurnSpeed * 2f;
			if (Mathf.Abs(turnAmount) > 0.2f)
			{
				turnAmount -= 0.2f;
				turnAmount /= 0.8f;
			}
			else if (Mathf.Abs(turnAmount) < -0.2f)
			{
				turnAmount += 0.2f;
				turnAmount = 0f - turnAmount / -0.8f;
			}
			else
			{
				turnAmount = 0f;
			}
			turnAmount *= Mathf.Lerp(1f, 3f, OptionData.getPerc("Turning Speed"));
			num = turnAmount * Time.deltaTime / Time.timeScale;
			break;
		}
		if (num != 0f)
		{
			activeRig.transform.RotateAround(character.standPosition, Vector3.up, num);
		}
	}

	public void outOfBody(bool inBody)
	{
		if (this.inBody != inBody)
		{
			this.inBody = inBody;
			activeRig.gameObject.SetActive(inBody);
			character.rigidBodies.setupLayers(inBody);
			refreshScale();
			_ = character.playerController.scaledTrackers[0].transform.localPosition;
			_ = character.playerController.scaledTrackers[0].transform.localPosition;
			_ = character.playerController.scaledTrackers[0].transform.rotation.eulerAngles;
			_ = activeRig.gameObject.transform.localRotation.eulerAngles;
			if (!inBody)
			{
				GameController.instance.noPlayer.gameObject.SetActive(value: true);
				GameController.instance.noPlayer.setupCameraPositions();
			}
			VRMainRigController.instance.refreshFollowing();
			Fader.fade(fadeOut: false, 0.5f);
		}
	}

	private void testButtonAction()
	{
		if (!Application.isEditor || GameController.instance.gameMode == GameController.GameMode.Edit)
		{
			return;
		}
		switch (Settings.instance.testButtonFunction)
		{
		case Settings.TestButtonFunction.Fall:
			if (GameController.instance.player.rigidBodies.fall.falling)
			{
				GameController.instance.player.rigidBodies.fall.GetUp();
			}
			else
			{
				GameController.instance.player.rigidBodies.fall.Fall();
			}
			break;
		case Settings.TestButtonFunction.OutOfBody:
			outOfBody(!inBody);
			break;
		case Settings.TestButtonFunction.AddEffect:
		{
			character.addEffect(character.rigidBodies.head.transform.position + character.rigidBodies.head.transform.forward, (Settings.instance.testParticularEffect != 0) ? Settings.instance.testParticularEffect : testEffect, 5f, preventSpecialRecharge: false, isTest: true);
			FaceCanvasController.addText((Settings.instance.testParticularEffect != 0) ? Settings.instance.testParticularEffect.ToString() : testEffect.ToString());
			string[] names = Enum.GetNames(typeof(CharacterEffect.Effect));
			if (testEffect == (CharacterEffect.Effect)(names.Length - 1))
			{
				testEffect = CharacterEffect.Effect.None;
			}
			else
			{
				testEffect++;
			}
			break;
		}
		case Settings.TestButtonFunction.ToggleIndicators:
			GameController.instance.toggleIndicators();
			break;
		case Settings.TestButtonFunction.Teleport:
			GameController.instance.player.teleport(Vector3.zero);
			break;
		default:
			UnityEngine.Debug.LogError("Unknown Test Action: " + Settings.instance.testButtonFunction);
			break;
		case Settings.TestButtonFunction.None:
			break;
		}
	}

	private void Update()
	{
		vrActions.Activate();
		if (GameController.instance.paused)
		{
			if (inBody)
			{
				outOfBody(inBody: false);
			}
			return;
		}
		if (GameController.instance.fightState == GameController.FightState.During && inBody)
		{
			if (activeRig.trackers[0].transform.position == lastPos && !Application.isEditor)
			{
				samePosTimer += Time.deltaTime;
				if (samePosTimer > 1f)
				{
					WebLogging.log("Auto Pause", "Auto Paused", 0f);
					GameController.instance.paused = true;
					return;
				}
			}
			else
			{
				samePosTimer = 0f;
			}
			lastPos = activeRig.trackers[0].transform.position;
		}
		else
		{
			samePosTimer = 0f;
		}
		turning();
		if (vrActions.specialMove())
		{
			if (character.specialMove.move() == null)
			{
				UnityEngine.Debug.LogError(character.specialMove.name + " has null move?");
			}
			if (PoseDisplay.instance.showPose(character, character.specialMove.move().pose))
			{
				character.doSpecial();
			}
			else
			{
				character.rigidBodies.rightHandMeter.highlight(Color.red);
				GeneralSounds.playSound(character.specialMoveFailSound);
			}
		}
		if (moveSpeedMod < 1f)
		{
			moveSpeedMod = Mathf.MoveTowards(moveSpeedMod, 1f, Time.deltaTime);
		}
		for (int i = 0; i < 3; i++)
		{
			if (!inBody)
			{
				if (i == 0)
				{
					activeRig.trackers[i].localPosition = GameController.instance.noPlayer.activeRig.trackers[i].localPosition;
					activeRig.trackers[i].rotation = activeRig.gameObject.transform.rotation * GameController.instance.noPlayer.activeRig.trackers[i].localRotation;
				}
				else
				{
					activeRig.trackers[i].localPosition = GameController.instance.noPlayer.activeRig.trackers[i].localPosition;
					activeRig.trackers[i].rotation = activeRig.gameObject.transform.rotation * GameController.instance.noPlayer.activeRig.trackers[i].localRotation;
				}
			}
			if (i == 0)
			{
				scaledTrackers[i].position = activeRig.trackers[i].position;
				scaledTrackers[i].rotation = activeRig.trackers[i].rotation;
				continue;
			}
			float num = character.moveSpeedMod();
			bool num2 = inBody;
			Vector3 vector = (num2 ? character.dynamicTrackers[i - 1].transform.position : activeRig.trackers[i].position);
			Quaternion to = (num2 ? character.dynamicTrackers[i - 1].transform.rotation : activeRig.trackers[i].rotation);
			if (character.hasEffect(CharacterEffect.Effect.ViperLeavesCave))
			{
				float num3 = character.getEffect(CharacterEffect.Effect.ViperLeavesCave).edgePerc(1f);
				float num4 = Mathf.Clamp01((GameController.flatVector(vector - scaledTrackers[0].transform.position).magnitude - 0.3f) * 2.5f);
				vector += num4 * GameController.flatVector(scaledTrackers[0].transform.forward).normalized * num3;
			}
			else if (character.hasEffect(CharacterEffect.Effect.RapidPunch))
			{
				float num5 = character.getEffect(CharacterEffect.Effect.RapidPunch).edgePerc(1f);
				float num6 = Mathf.Clamp01((GameController.flatVector(vector - scaledTrackers[0].transform.position).magnitude - 0.3f) * 2.5f);
				vector += num6 * GameController.flatVector(scaledTrackers[0].transform.forward).normalized * num5;
			}
			scaledTrackers[i].position = Vector3.MoveTowards(scaledTrackers[i].position, vector, Time.deltaTime * Settings.instance.maxMoveSpeed * num);
			scaledTrackers[i].rotation = Quaternion.RotateTowards(scaledTrackers[i].rotation, to, Time.deltaTime * Settings.instance.maxRotateSpeed * num);
		}
		if (character.rigidBodies.isDown(allTheWay: false))
		{
			character.mover.moving = Vector3.zero;
			if (inBody)
			{
				outOfBody(inBody: false);
			}
			return;
		}
		outOfBodyTimer = Mathf.MoveTowards(outOfBodyTimer, 0f, Time.deltaTime);
		if (outOfBodyTimer > 0f && outOfBodyTimer < 2f)
		{
			outOfBody(inBody: false);
		}
		else if (vrActions.test())
		{
			testButtonAction();
		}
		else if (vrActions.pause() && Time.time > nextPause && GameController.instance.gameMode != GameController.GameMode.Edit && inBody)
		{
			GameController.instance.paused = true;
		}
		else
		{
			bool flag = (GameController.instance.fightState != GameController.FightState.Over && character.rigidBodies.fall.gotUp && !vrActions.spectate()) || GameController.instance.gameMode == GameController.GameMode.Edit;
			outOfBody(flag);
		}
		character.kickController.kickingHeld = vrActions.kick();
		float controllerDeadZone = Settings.instance.controllerDeadZone;
		Vector3 vector2 = Vector3.ClampMagnitude((vrActions.move().magnitude - controllerDeadZone) / (1f - controllerDeadZone) * vrActions.move() * Settings.instance.controllerSensitivity * GameController.instance.gameData.vrProfile.moveSensitivity, 1f);
		dir = (inBody ? (Quaternion.Euler(0f, scaledTrackers[0].transform.rotation.eulerAngles.y, 0f) * new Vector3(vector2.x, 0f, vector2.y)) : Vector3.zero);
		dir *= character.data.moveSpeedPerc();
		runController.moveDirection = dir;
		character.rigidBodies.ik.solver.locomotion.maxVelocity = (dir.magnitude + runController.runMove.magnitude) * 1f;
		if (vrActions.jump())
		{
			character.vrCharacterController.jump();
		}
		else if (character.kickController.kickingHeld)
		{
			character.kickController.Kick();
		}
		if (runController.ik == null)
		{
			runController.ik = character.rigidBodies.ik;
		}
		character.mover.moving = dir + runController.runMove;
		if (vrActions.dash())
		{
			character.mover.dash(character.mover.moving);
		}
	}
}
public class MovingDummyController : MonoBehaviour
{
	public ChamberController chamber;

	public int hitCount;

	public BronzeDummyHitArea dummy;

	public float squareSize = 0.8f;

	public Vector3 targetPos;

	public float targetRotation;

	public float moveSpeed = 0.5f;

	public float rotateSpeed = 180f;

	public float waitTime = 0.5f;

	public float wait = 0.5f;

	public int hitRequire = 10;

	private void Start()
	{
		chamber = GetComponentInParent<ChamberController>();
		if (chamber != null)
		{
			chamber.isComplete = false;
		}
		dummy.onHit = delegate(Vector3 pos)
		{
			if (!chamber.isComplete)
			{
				hitCount++;
				string text = LocalisationController.replaceText("General", "[x] hits", hitCount.ToString());
				CanvasController.addText(localise: false, text, pos, Color.cyan, 2f, base.transform);
				if (hitCount >= hitRequire)
				{
					chamber.isComplete = true;
				}
			}
		};
	}

	private void Update()
	{
		if (GameController.instance == null || chamber.isComplete)
		{
			return;
		}
		base.transform.localRotation = Quaternion.RotateTowards(base.transform.localRotation, Quaternion.Euler(0f, targetRotation, 0f), rotateSpeed * Time.deltaTime);
		if (wait > 0f)
		{
			wait -= Time.deltaTime;
		}
		else if (base.transform.localPosition == targetPos)
		{
			float num = Mathf.Round(base.transform.localPosition.x / squareSize * 2f) / 2f;
			float num2 = Mathf.Round(base.transform.localPosition.z / squareSize * 2f) / 2f;
			bool flag = num == Mathf.Round(base.transform.localPosition.x / squareSize) && num2 == Mathf.Round(base.transform.localPosition.z / squareSize);
			for (int i = 0; i < 1000; i++)
			{
				Vector3 vector = new Vector3(Mathf.Round(-1f + UnityEngine.Random.value * 2f), 0f, Mathf.Round(-1f + UnityEngine.Random.value * 2f));
				vector.x = Mathf.Clamp(vector.x, -2f, 2f);
				vector.z = Mathf.Clamp(vector.z, -2f, 2f);
				bool flag2 = false;
				bool flag3 = Mathf.Round(vector.x) != 0f && Mathf.Round(vector.z) != 0f;
				if (flag || flag3)
				{
					Vector3 vector2 = base.transform.localPosition / squareSize + vector;
					vector2.x = Mathf.Abs(vector2.x);
					vector2.z = Mathf.Abs(vector2.z);
					flag2 = (vector2.x != 2f || vector2.x != 2f) && ((!(vector2.x > 2f) && !(vector2.z > 2f)) ? true : false);
				}
				if (flag2)
				{
					if (flag3)
					{
						vector /= 2f;
					}
					targetPos = base.transform.localPosition + vector * squareSize;
					break;
				}
				if (i >= 999)
				{
					UnityEngine.Debug.LogError("Gave up");
				}
			}
			if (GameController.instance.player != null)
			{
				Vector3 vector3 = base.transform.position - GameController.instance.player.standPosition;
				vector3.y = 0f;
				targetRotation = 0f - Quaternion.LookRotation(vector3.normalized).eulerAngles.y;
			}
			else
			{
				targetRotation = UnityEngine.Random.value;
			}
			targetRotation = Mathf.Round(targetRotation / 45f) * 45f;
		}
		else
		{
			base.transform.localPosition = Vector3.MoveTowards(base.transform.localPosition, targetPos, Time.deltaTime * moveSpeed);
			if (base.transform.localPosition == targetPos)
			{
				wait = waitTime;
			}
		}
	}
}
public class MusicController : MonoBehaviour
{
	private static MusicController instance;

	public AudioClip[] tracks;

	public AudioClip menu;

	private AudioSource audioSource;

	public static float pauseTime;

	private bool playingMenu;

	private void Start()
	{
		instance = this;
		audioSource = GetComponent<AudioSource>();
	}

	public static void playMusic()
	{
		if (!instance.audioSource.isPlaying)
		{
			instance.audioSource.clip = instance.tracks[UnityEngine.Random.Range(0, instance.tracks.Length)];
			instance.audioSource.Play();
		}
	}

	public static void stopMusic()
	{
		instance.audioSource.Stop();
	}

	public static void pause()
	{
		pauseTime = 1f;
		instance.audioSource.volume = 0f;
	}

	private void Update()
	{
		if (pauseTime > 0f)
		{
			pauseTime -= Time.deltaTime;
		}
		audioSource.volume = Mathf.MoveTowards(audioSource.volume, (!GameController.instance.paused && pauseTime <= 0f && OptionData.getBool("Music")) ? 1 : 0, Time.deltaTime * 2f);
	}
}
public class NewBehaviourScript : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
	}
}
public class NoPlayerControl : MonoBehaviour
{
	public VRNonPlayerCamActions vrActions;

	public float turnAmount;

	public VRRig activeRig;

	public float defaultY = 1.68f;

	public float headY;

	public Material[] materialOptions;

	private int rndMaterial;

	public float withinAngle;

	public Vector3 positionOffset;

	public float rotationOffset;

	public float refreshTimer;

	public int onCam;

	public LayerMask viewObstruction;

	private Vector3 spectatePos;

	public Vector3 lastHeadPos;

	private bool canTurn = true;

	public float viewDist;

	private void Start()
	{
		rndMaterial = UnityEngine.Random.Range(0, materialOptions.Length);
		activeRig = vrActions.activeRig();
	}

	public void initSetup()
	{
		if (OptionData.getInt("Mode") != 0)
		{
			GameController.instance.gameData.calibrateScale = 1f;
			base.transform.localScale = Vector3.one * 4f;
			positionOffset.y = defaultY - 1.32f;
		}
	}

	public void calibrate()
	{
		headY = activeRig.trackers[0].transform.localPosition.y;
		GameController.instance.gameData.calibrateScale = defaultY / headY;
		positionOffset = -activeRig.trackers[0].transform.localPosition;
		if (OptionData.getInt("Mode") == 0)
		{
			positionOffset.y = 0f;
			base.transform.localScale = Vector3.one * 4f * GameController.instance.gameData.calibrateScale;
		}
		else
		{
			GameController.instance.gameData.calibrateScale = 1f;
			base.transform.localScale = Vector3.one * 4f;
			positionOffset.y = defaultY - activeRig.trackers[0].transform.localPosition.y;
		}
		rotationOffset = 0f - activeRig.trackers[0].transform.localRotation.eulerAngles.y;
		Saving.saveSettings();
		GeneralSounds.playSound(5);
	}

	private void OnEnable()
	{
		Invoke("delayedActivate", 0.01f);
		withinAngle = 5f;
		refreshTimer = 0.1f;
	}

	public void delayedActivate()
	{
		withinAngle = 5f;
		refreshTimer = 0.1f;
		vrActions.Activate();
	}

	public void setupCameraPositions()
	{
		viewDist = 0f;
		List<Vector3> list = new List<Vector3>();
		Vector3 vector = GameController.instance.player.standPosition;
		if (vector == Vector3.zero)
		{
			vector = -Vector3.forward;
		}
		Transform transform = GameController.instance.player.playerController.scaledTrackers[0].transform;
		Vector3 vector2 = GameController.flatVector(GameController.instance.noPlayer.transform.position - GameController.instance.noPlayer.activeRig.trackers[0].position);
		list.Add(vector2 + (vector - GameController.flatVector(vector).normalized * 2f));
		list.Add(vector2 + (vector + GameController.flatVector(vector).normalized * 2f));
		list.Add(vector2 + (vector - GameController.flatVector(vector).normalized * 4f));
		list.Add(vector2 + (vector + GameController.flatVector(vector).normalized * 4f));
		list.Add(GameController.instance.standButtons.menuPosition.position - Vector3.forward * 6f);
		list.Add(GameController.instance.standButtons.menuPosition.position + Vector3.forward * 6f);
		list.Add(GameController.instance.standButtons.menuPosition.position);
		list.Add(vector2 + (vector - GameController.flatVector(vector).normalized * 2f));
		list.Add(vector2 + (vector - GameController.flatVector(transform.right).normalized * 2f));
		list.Add(vector2 + (vector + GameController.flatVector(transform.right).normalized * 2f));
		list.Add(vector2 + (vector - GameController.flatVector(transform.forward).normalized * 2f));
		list.Add(vector2 + (vector + GameController.flatVector(transform.forward).normalized * 2f));
		_ = transform.localPosition;
		_ = GameController.instance.player.playerController.scaledTrackers[0].transform.localPosition;
		float y = GameController.instance.player.transform.position.y;
		onCam++;
		onCam %= list.Count;
		Vector3 vector3 = list[onCam];
		spectatePos = new Vector3(vector3.x, headY + y, vector3.z);
		Vector3 vector4 = new Vector3(vector.x, 1.3f + y, vector.z);
		bool flag = false;
		for (int i = 0; i < list.Count; i++)
		{
			if (GameController.flatVector(spectatePos - vector4).magnitude > 2f && GameController.flatVector(spectatePos - vector4).magnitude <= 10f && !Physics.Raycast(spectatePos, vector4 - spectatePos, out var _, (vector4 - spectatePos).magnitude, viewObstruction) && !Physics.Raycast(vector4, spectatePos - vector4, out var _, (vector4 - spectatePos).magnitude + 2f, viewObstruction))
			{
				flag = true;
				break;
			}
			onCam++;
			onCam %= list.Count;
			vector3 = list[onCam];
			spectatePos = new Vector3(vector3.x, headY + y, vector3.z);
		}
		if (!flag)
		{
			for (int j = 0; j < list.Count; j++)
			{
				if (GameController.flatVector(spectatePos - vector4).magnitude > 2f && !Physics.Raycast(spectatePos, vector4 - spectatePos, out var _, (vector4 - spectatePos).magnitude, viewObstruction) && !Physics.Raycast(vector4, spectatePos - vector4, out var _, (vector4 - spectatePos).magnitude, viewObstruction))
				{
					flag = true;
					break;
				}
				onCam++;
				onCam %= list.Count;
				vector3 = list[onCam];
				spectatePos = new Vector3(vector3.x, headY + y, vector3.z);
			}
		}
		refreshTimer = 0.1f;
	}

	private void turnWithin(float within)
	{
		GameCharacter player = GameController.instance.player;
		if (player != null)
		{
			Transform transform = GameController.instance.noPlayer.activeRig.trackers[0];
			Quaternion quaternion = Quaternion.LookRotation(GameController.flatVector(transform.forward));
			float num = Mathf.DeltaAngle(target: Quaternion.LookRotation((!GameController.instance.paused) ? GameController.flatVector(player.rigidBodies.head.position - transform.position) : Vector3.forward).eulerAngles.y, current: quaternion.eulerAngles.y);
			if (Mathf.Abs(num) > within)
			{
				GameController.instance.noPlayer.transform.RotateAround(transform.position, Vector3.up, num);
			}
		}
	}

	private void OnDisable()
	{
		vrActions.Deactivate();
	}

	private void refreshPausedPos()
	{
		if (GameController.instance.standButtons == null)
		{
			return;
		}
		Quaternion quaternion = Quaternion.Euler(0f, 0f - activeRig.trackers[0].transform.localRotation.eulerAngles.y, 0f);
		Vector3 vector = ((GameController.instance.paused || GameController.instance.player == null) ? (new Vector3(0f, 4f, -6f) + GameController.instance.standButtons.menuPosition.position) : spectatePos) - activeRig.trackers[0].transform.position;
		if (vector.magnitude > 0.1f || Quaternion.Angle(quaternion, base.transform.rotation) > 5f)
		{
			if (GameController.instance.paused || GameController.instance.player == null)
			{
				base.transform.rotation = quaternion;
			}
			base.transform.position += vector;
		}
		refreshTimer -= Time.deltaTime;
	}

	public Vector3 RotatePointAroundPivot(Vector3 point, Vector3 pivot, Vector3 angles)
	{
		Vector3 vector = point - pivot;
		vector = Quaternion.Euler(angles) * vector;
		point = vector + pivot;
		return point;
	}

	private void Update()
	{
		if (refreshTimer > 0f)
		{
			refreshPausedPos();
		}
		if (withinAngle < 180f)
		{
			withinAngle = Mathf.MoveTowards(withinAngle, 180f, Time.deltaTime * 180f * 5f);
			turnWithin(withinAngle);
		}
		if (GameController.instance.player == null && GameController.instance.menu.mainMenu)
		{
			Vector3 vector = ((!GameController.instance.menu.mainMenu) ? new Vector3(0f, 0f, 0f) : new Vector3(0f, -4f, -6f));
			if (activeRig.trackers[0].transform.localPosition.y < 1f)
			{
				base.transform.position = new Vector3(vector.x, 0f, vector.z);
			}
			else
			{
				base.transform.position = new Vector3(vector.x, -4f, vector.z);
			}
			float num = 0f;
			switch (OptionData.getInt("Turning Mode"))
			{
			case 0:
			{
				int num2 = 0;
				if (canTurn)
				{
					if (vrActions.turn() > 0.75f)
					{
						num2 = 1;
					}
					if (vrActions.turn() < -0.75f)
					{
						num2 = -1;
					}
					if (num2 != 0)
					{
						canTurn = false;
					}
				}
				else if (Mathf.Abs(vrActions.turn()) < 0.5f)
				{
					canTurn = true;
				}
				if (num2 == -1)
				{
					turnAmount -= Settings.instance.snapTurnAmount.lerp(OptionData.getPerc("Turning Speed"));
				}
				if (num2 == 1)
				{
					turnAmount += Settings.instance.snapTurnAmount.lerp(OptionData.getPerc("Turning Speed"));
				}
				num = turnAmount * Time.deltaTime / Time.timeScale;
				num *= 30f;
				if (num2 != 0)
				{
					vrActions.turn();
				}
				turnAmount -= num;
				break;
			}
			case 1:
				turnAmount = vrActions.turn() * Settings.instance.smoothTurnSpeed * 2f;
				turnAmount *= Mathf.Lerp(1f, 3f, OptionData.getPerc("Turning Speed"));
				num = turnAmount * Time.deltaTime / Time.timeScale;
				break;
			}
			if (num != 0f)
			{
				rotationOffset += num;
			}
			base.transform.position += Quaternion.Euler(0f, rotationOffset, 0f) * positionOffset * base.transform.localScale.x;
			base.transform.rotation = Quaternion.Euler(0f, rotationOffset, 0f);
			return;
		}
		if (GameController.instance.paused || GameController.instance.player == null)
		{
			if (vrActions.pause())
			{
				GameController.instance.unpause();
			}
			else if (GameController.instance.paused && !GameController.instance.menu.showing)
			{
				GameController.instance.menu.setPos(4f, 3f, GameController.instance.standButtons.menuPosition.position);
				GameController.instance.menu.showMenu("");
			}
			return;
		}
		float num3 = 0f;
		switch (OptionData.getInt("Turning Mode"))
		{
		case 0:
		{
			int num4 = 0;
			if (canTurn)
			{
				if (vrActions.turn() > 0.75f)
				{
					num4 = 1;
				}
				if (vrActions.turn() < -0.75f)
				{
					num4 = -1;
				}
				if (num4 != 0)
				{
					canTurn = false;
				}
			}
			else if (Mathf.Abs(vrActions.turn()) < 0.5f)
			{
				canTurn = true;
			}
			if (num4 == -1)
			{
				turnAmount -= Settings.instance.snapTurnAmount.lerp(OptionData.getPerc("Turning Speed"));
			}
			if (num4 == 1)
			{
				turnAmount += Settings.instance.snapTurnAmount.lerp(OptionData.getPerc("Turning Speed"));
			}
			num3 = turnAmount * Time.deltaTime / Time.timeScale;
			num3 *= 30f;
			turnAmount -= num3;
			break;
		}
		case 1:
			turnAmount = vrActions.turn() * Settings.instance.smoothTurnSpeed * 2f;
			turnAmount *= Mathf.Lerp(1f, 3f, OptionData.getPerc("Turning Speed"));
			num3 = turnAmount * Time.deltaTime / Time.timeScale;
			break;
		}
		base.transform.position = RotatePointAroundPivot(base.transform.position, GameController.instance.player.standPosition, new Vector3(0f, num3, 0f));
		base.transform.rotation *= Quaternion.Euler(0f, num3, 0f);
		Vector3 vector2 = GameController.instance.player.standPosition + Vector3.up * 1.7f;
		Vector3 direction = GameController.flatVector(vrActions.activeRig().transform.position - vector2);
		if (viewDist == 0f && num3 != 0f)
		{
			viewDist = direction.magnitude;
		}
		if (Physics.Raycast(new Ray(vector2, direction), out var hitInfo, direction.magnitude + 0.5f, viewObstruction))
		{
			base.transform.position -= (direction.magnitude - (hitInfo.distance - 0.5f)) * direction.normalized;
		}
		else if (direction.magnitude < 1f && direction.magnitude > 1.1f)
		{
			base.transform.position += direction.normalized * Time.deltaTime;
		}
	}
}
[Serializable]
public class OptionCategory
{
	public string name;

	public OptionData[] options;

	public void localise()
	{
		LocalisationController.getText("Option Category", name);
		OptionData[] array = options;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].localise();
		}
	}
}
[Serializable]
public class OptionData
{
	public static bool changed = true;

	public string name;

	public string[] values;

	public int value;

	public int defaultValue;

	public bool hideFromMenu;

	private static Dictionary<string, OptionData> lookup;

	public void localise()
	{
		LocalisationController.getText("Option", name);
		string[] array = values;
		foreach (string text in array)
		{
			LocalisationController.getText("Option Value", text);
		}
	}

	public void doAction()
	{
		switch (name)
		{
		case "Calibrate Height":
			GameController.instance.noPlayer.calibrate();
			break;
		case "Clear Data":
			Saving.instance.clearData();
			GameController.instance.gameData.resetOptions();
			break;
		case "Open Local Files":
			Application.OpenURL(Application.persistentDataPath);
			break;
		case "Open Activity Log":
			break;
		}
	}

	public void reset()
	{
		if (name == "Quality")
		{
			values = QualitySettings.names;
			defaultValue = QualitySettings.GetQualityLevel();
		}
		value = defaultValue;
	}

	public void next()
	{
		setValue(value + 1);
	}

	public string displayValue()
	{
		if (values.Length == 0)
		{
			return "";
		}
		return values[value];
	}

	public void setValue(int value)
	{
		this.value = value;
		if (this.value >= values.Length)
		{
			this.value = 0;
		}
		if (name == "Quality")
		{
			QualitySettings.SetQualityLevel(value);
		}
		if (name == "Text Language")
		{
			LocalisationController.instance.refresh = true;
		}
		if (name == "Mode")
		{
			GameController.instance.calibrate();
		}
		changed = true;
		Saving.saveSettings();
	}

	public static OptionData getOption(string optionName)
	{
		if (lookup == null)
		{
			lookup = new Dictionary<string, OptionData>();
		}
		if (lookup.ContainsKey(optionName))
		{
			return lookup[optionName];
		}
		OptionCategory[] options = GameController.instance.gameData.options;
		for (int i = 0; i < options.Length; i++)
		{
			OptionData[] options2 = options[i].options;
			foreach (OptionData optionData in options2)
			{
				if (optionData.name == optionName)
				{
					lookup.Add(optionData.name, optionData);
					return optionData;
				}
			}
		}
		return null;
	}

	public static float getPerc(string optionName)
	{
		OptionData option = getOption(optionName);
		return (float)option.value / ((float)option.values.Length - 1f);
	}

	public static int getInt(string optionName)
	{
		if (GameController.instance == null || GameController.instance.gameData == null)
		{
			return -1;
		}
		if (lookup == null)
		{
			lookup = new Dictionary<string, OptionData>();
		}
		if (lookup.ContainsKey(optionName))
		{
			return lookup[optionName].value;
		}
		OptionCategory[] options = GameController.instance.gameData.options;
		for (int i = 0; i < options.Length; i++)
		{
			OptionData[] options2 = options[i].options;
			foreach (OptionData optionData in options2)
			{
				if (optionData.name == optionName)
				{
					lookup.Add(optionData.name, optionData);
					return optionData.value;
				}
			}
		}
		UnityEngine.Debug.LogError("Couldn't find: " + optionName);
		return 0;
	}

	public static bool getBool(string optionName)
	{
		return getInt(optionName) == 0;
	}
}
public class OrbitalSphereController : ProjectileController
{
	public float angle;

	public float distance = 2f;

	public float height = 2f;

	public float life = 10f;

	public float impact = 1f;

	public override void flyingMovement()
	{
		angle += Time.deltaTime * 90f * speed * 3f;
		Mathf.Lerp(3f, 7f, (firer.hands.l_squeezeAmount + firer.hands.r_squeezeAmount) / 2f);
		speed = Mathf.MoveTowards(speed, 1f, Time.deltaTime / 2f);
		float num = (firer.trackers.transforms[0].position - firer.standPosition).y * height;
		distance = (GameController.flatVector(firer.trackers.transforms[1].position - firer.trackers.transforms[0].position).magnitude + GameController.flatVector(firer.trackers.transforms[2].position - firer.trackers.transforms[0].position).magnitude) * 2f;
		if (distance < 0.5f)
		{
			distance = 0.5f;
		}
		Vector3 vector = firer.standPosition + Vector3.up * num + Quaternion.Euler(0f, angle, 0f) * Vector3.forward * distance;
		velocity = vector - base.transform.position;
		base.transform.position = Vector3.MoveTowards(base.transform.position, vector, Time.deltaTime * 5f * speed);
		life -= Time.deltaTime;
		if (life < 0f)
		{
			hitEffect();
		}
	}

	private void hitEffect()
	{
		GameObject obj = UnityEngine.Object.Instantiate(hitEffectPrefab, GameController.instance.transform);
		obj.transform.position = base.transform.position;
		obj.transform.rotation = base.transform.rotation;
		UnityEngine.Object.Destroy(obj, 8f);
		UnityEngine.Object.Destroy(base.gameObject);
	}

	private void OnTriggerEnter(Collider other)
	{
		Hittable component = other.GetComponent<Hittable>();
		if (!(component == null) && (component.rb == null || component.rb.character != firer))
		{
			component.rb.Hit(velocity, component, firer, impact, damage, base.transform.position, Hittable.HandHitType.General, skipPressurePoints: true, "Orbital Sphere");
			hitEffect();
		}
	}
}
public class POVSwitchCam : MonoBehaviour
{
	public GameCharacter following;

	public float changeInterval = 8f;

	private float changeTime;

	public float offset = 0.15f;

	private void Start()
	{
		change();
	}

	private void change()
	{
		following = GameController.instance.getToFollow(prioritizePlayer: false);
		changeTime = changeInterval;
	}

	private void Update()
	{
		if (!(following == null))
		{
			Transform transform = following.trackers.transforms[0];
			base.transform.position = transform.position + transform.forward * offset;
			base.transform.rotation = transform.rotation;
			changeTime -= Time.deltaTime;
			if (changeTime < 0f)
			{
				change();
			}
		}
	}
}
public class ParalysedEffect : HandOrFootEffect
{
	public Transform[] fixedPositions;

	public float forwardAngle;

	public float origHeight;

	public override void setup(GameCharacter character)
	{
		base.setup(character);
		base.transform.position = character.standPosition;
		for (int i = 0; i < fixedPositions.Length; i++)
		{
			fixedPositions[i].SetPositionAndRotation(character.trackers.transforms[i].position, character.trackers.transforms[i].rotation);
		}
		Vector3 forward = character.trackers.transforms[0].forward;
		forwardAngle = Quaternion.LookRotation(forward).eulerAngles.y;
		origHeight = character.trackers.transforms[0].transform.position.y;
	}

	private void Update()
	{
		if (character == null)
		{
			UnityEngine.Object.Destroy(base.gameObject);
			return;
		}
		Vector3 forward = character.trackers.transforms[0].forward;
		forward.y = 0f;
		float y = Quaternion.LookRotation(forward).eulerAngles.y - forwardAngle;
		base.transform.position = character.standPosition + (character.trackers.transforms[0].transform.position.y - origHeight) * Vector3.up;
		base.transform.rotation = Quaternion.Euler(0f, y, 0f);
		for (int i = 0; i < fixedPositions.Length; i++)
		{
			character.trackers.transforms[i].SetPositionAndRotation(fixedPositions[i].position, fixedPositions[i].rotation);
		}
	}
}
public class ParticlesAfterIK : MonoBehaviour
{
	public IK ik;

	public ParticleSystem p;

	private void Start()
	{
		p = GetComponent<ParticleSystem>();
		IKSolver iKSolver = ik.GetIKSolver();
		iKSolver.OnPostUpdate = (IKSolver.UpdateDelegate)Delegate.Combine(iKSolver.OnPostUpdate, new IKSolver.UpdateDelegate(OnPostUpdate));
	}

	private void OnPostUpdate()
	{
		if (base.enabled)
		{
			p.Simulate(Time.deltaTime, withChildren: true, restart: false);
		}
	}
}
[Serializable]
public class PerkData : Exportable
{
	public string description;

	public float perc = 1f;

	public int used;

	public void localise(string label)
	{
		LocalisationController.getText(label, name);
		LocalisationController.getText(label + " Description", getDescription(withName: false));
		LocalisationController.getText(label + " Description", getDescription(withName: true));
	}

	public string getDescription(bool withName)
	{
		if (withName)
		{
			return name + ", " + description.Replace("[perc]", Mathf.Round(perc * 100f) + "%");
		}
		return description.Replace("[perc]", Mathf.Round(perc * 100f) + "%");
	}
}
public class AchievementSample : MonoBehaviour
{
	public Text dataOutput;

	public InputField getDefinitionsByNameInputField;

	public InputField getProgressByNameInputField;

	public InputField unLockInputField;

	public InputField addCountInputField;

	public InputField addFieldsInputField;

	private void Start()
	{
		AchievementCore.RegisterNetwork();
	}

	private void OnDestroy()
	{
		AchievementCore.UnRegisterNetwork();
	}

	private void OnApplicationPause(bool pause)
	{
		if (!pause)
		{
			printOutputLine("Achievement Init");
			achievementInit();
		}
	}

	private void Update()
	{
		Request.RunCallbacks();
	}

	public void AsyncInitialize()
	{
		dataOutput.text = "> ";
		printOutputLine("AsyncInitialize");
		achievementInit();
	}

	public void GetDefinitionsByName()
	{
		dataOutput.text = "> ";
		printOutputLine("GetDefinitionsByName");
		string text = getDefinitionsByNameInputField.text;
		if (text != "")
		{
			string[] achievementNames = text.Split(',');
			getAchievementDefinition(achievementNames);
			getDefinitionsByNameInputField.text = "";
		}
		else
		{
			printOutputLine("Invalid Command");
		}
	}

	public void GetProgressByName()
	{
		dataOutput.text = "> ";
		printOutputLine("GetProgressByName");
		string text = getProgressByNameInputField.text;
		if (text != "")
		{
			string[] achievementNames = text.Split(',');
			getAchievementProgress(achievementNames);
			getProgressByNameInputField.text = "";
		}
		else
		{
			printOutputLine("Invalid Command");
		}
	}

	public void GetAllDefinitions()
	{
		dataOutput.text = "> ";
		printOutputLine("GetAllDefinitions");
		getAchievementAllDefinition();
	}

	public void GetAllProgress()
	{
		dataOutput.text = "> ";
		printOutputLine("GetAllProgress");
		getAchievementAllProgress();
	}

	public void UnLock()
	{
		dataOutput.text = "> ";
		printOutputLine("UnLock");
		string text = unLockInputField.text;
		if (text != "")
		{
			unlockAchievement(text);
			unLockInputField.text = "";
		}
		else
		{
			printOutputLine("Invalid Command");
		}
	}

	public void AddCount()
	{
		dataOutput.text = "> ";
		printOutputLine("AddCount");
		string text = addCountInputField.text;
		if (text != "")
		{
			string[] array = text.Split(',');
			if (array.Length > 1)
			{
				try
				{
					Convert.ToInt64(array[1]);
				}
				catch (Exception)
				{
					printOutputLine("Invalid Command");
					throw;
				}
				addCountAchievement(array[0], array[1]);
				addCountInputField.text = "";
			}
			else
			{
				printOutputLine("Invalid Command");
			}
		}
		else
		{
			printOutputLine("Invalid Command");
		}
	}

	public void AddFields()
	{
		dataOutput.text = "> ";
		printOutputLine("AddFields");
		string text = addFieldsInputField.text;
		if (text != "")
		{
			string[] array = text.Split(',');
			if (array.Length > 1)
			{
				addFieldsAchievement(array[0], array[1]);
				addFieldsInputField.text = "";
			}
			else
			{
				printOutputLine("Invalid Command");
			}
		}
		else
		{
			printOutputLine("Invalid Command");
		}
	}

	private void achievementInit()
	{
		Achievements.Init().OnComplete(initAchievementCallback);
	}

	private void getAchievementAllDefinition()
	{
		Achievements.GetAllDefinitions().OnComplete(achievementAllDefinitionCallback);
	}

	private void getAchievementAllProgress()
	{
		Achievements.GetAllProgress().OnComplete(achievementAllProgressCallback);
	}

	private void addFieldsAchievement(string achievementName, string fields)
	{
		Achievements.AddFields(achievementName, fields).OnComplete(achievementFieldsCallback);
	}

	private void addCountAchievement(string achievementName, string count)
	{
		Achievements.AddCount(achievementName, Convert.ToInt64(count)).OnComplete(achievementCountCallback);
	}

	private void unlockAchievement(string achievementName)
	{
		Achievements.Unlock(achievementName).OnComplete(achievementUnlockCallback);
	}

	private void getAchievementProgress(string[] achievementNames)
	{
		Achievements.GetProgressByName(achievementNames).OnComplete(achievementProgressCallback);
	}

	private void getAchievementDefinition(string[] achievementNames)
	{
		Achievements.GetDefinitionsByName(achievementNames).OnComplete(achievementDefinitionCallback);
	}

	private void printOutputLine(string newLine)
	{
		dataOutput.text = "> " + newLine + Environment.NewLine + dataOutput.text;
	}

	private void achievementAllDefinitionCallback(Pvr_Message<Pvr_AchievementDefinitionList> msg)
	{
		if (!msg.IsError)
		{
			printOutputLine("Received achievement definitions success");
			Pvr_AchievementDefinitionList achievementDefinitions = msg.GetAchievementDefinitions();
			if (achievementDefinitions.HasNextPage)
			{
				Achievements.GetNextAchievementDefinitionListPage(achievementDefinitions).OnComplete(achievementAllDefinitionCallback);
			}
			{
				foreach (Pvr_AchievementDefinition item in achievementDefinitions)
				{
					printOutputLine("Bitfield Name: " + item.Name.ToString());
					switch (item.Type)
					{
					case AchievementType.Simple:
						printOutputLine("Achievement Type: Simple");
						break;
					case AchievementType.Bitfield:
						printOutputLine("Achievement Type: Bitfield");
						printOutputLine("Bitfield Length: " + item.BitfieldLength);
						printOutputLine("Target: " + item.Target);
						break;
					case AchievementType.Count:
						printOutputLine("Achievement Type: Count");
						printOutputLine("Target: " + item.Target);
						break;
					default:
						printOutputLine("Achievement Type: Unknown");
						break;
					}
					printOutputLine("Bitfield Title: " + item.Title.ToString());
					printOutputLine("Bitfield Description: " + item.Description.ToString());
					printOutputLine("Bitfield UnlockedDescription: " + item.UnlockedDescription.ToString());
					printOutputLine("Bitfield UnlockedIcon: " + item.UnlockedIcon.ToString());
					printOutputLine("Bitfield LockedIcon: " + item.LockedIcon.ToString());
					printOutputLine("Bitfield IsSecrect: " + item.IsSecrect);
				}
				return;
			}
		}
		printOutputLine("Received achievement definitions error");
		Error error = msg.GetError();
		printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
	}

	private void achievementAllProgressCallback(Pvr_Message<Pvr_AchievementProgressList> msg)
	{
		if (!msg.IsError)
		{
			printOutputLine("Received achievement progress success");
			Pvr_AchievementProgressList achievementProgressList = msg.GetAchievementProgressList();
			if (achievementProgressList.HasNextPage)
			{
				Achievements.GetNextAchievementProgressListPage(achievementProgressList).OnComplete(achievementAllProgressCallback);
			}
			{
				foreach (Pvr_AchievementProgress item in achievementProgressList)
				{
					printOutputLine("Current Name: " + item.Name.ToString());
					if (item.IsUnlocked)
					{
						printOutputLine("Achievement Unlocked");
					}
					else
					{
						printOutputLine("Achievement Locked");
					}
					printOutputLine("Current Bitfield: " + item.Bitfield.ToString());
					printOutputLine("Current Count: " + item.Count);
					printOutputLine("Current UnlockTime: " + item.UnlockTime.ToString());
				}
				return;
			}
		}
		printOutputLine("Received achievement progress error");
		Error error = msg.GetError();
		printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
	}

	private void achievementFieldsCallback(Pvr_Message msg)
	{
		if (!msg.IsError)
		{
			printOutputLine("Achievement fields added.");
			return;
		}
		printOutputLine("Received achievement fields add error");
		Error error = msg.GetError();
		printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
	}

	private void achievementCountCallback(Pvr_Message msg)
	{
		if (!msg.IsError)
		{
			printOutputLine("Achievement count added.");
			return;
		}
		printOutputLine("Received achievement count add error");
		Error error = msg.GetError();
		printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
	}

	private void achievementUnlockCallback(Pvr_Message msg)
	{
		if (!msg.IsError)
		{
			printOutputLine("Achievement unlocked");
			return;
		}
		printOutputLine("Received achievement unlock error");
		Error error = msg.GetError();
		printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
	}

	private void achievementProgressCallback(Pvr_Message<Pvr_AchievementProgressList> msg)
	{
		if (!msg.IsError)
		{
			printOutputLine("Received achievement progress success");
			{
				foreach (Pvr_AchievementProgress achievementProgress in msg.GetAchievementProgressList())
				{
					if (achievementProgress.IsUnlocked)
					{
						printOutputLine("Achievement Unlocked");
					}
					else
					{
						printOutputLine("Achievement Locked");
					}
					printOutputLine("Current Bitfield: " + achievementProgress.Bitfield.ToString());
					printOutputLine("Current Count: " + achievementProgress.Count);
				}
				return;
			}
		}
		printOutputLine("Received achievement progress error");
		Error error = msg.GetError();
		printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
	}

	private void achievementDefinitionCallback(Pvr_Message<Pvr_AchievementDefinitionList> msg)
	{
		if (!msg.IsError)
		{
			printOutputLine("Received achievement definitions success");
			{
				foreach (Pvr_AchievementDefinition achievementDefinition in msg.GetAchievementDefinitions())
				{
					switch (achievementDefinition.Type)
					{
					case AchievementType.Simple:
						printOutputLine("Achievement Type: Simple");
						break;
					case AchievementType.Bitfield:
						printOutputLine("Achievement Type: Bitfield");
						printOutputLine("Bitfield Length: " + achievementDefinition.BitfieldLength);
						printOutputLine("Target: " + achievementDefinition.Target);
						break;
					case AchievementType.Count:
						printOutputLine("Achievement Type: Count");
						printOutputLine("Target: " + achievementDefinition.Target);
						break;
					default:
						printOutputLine("Achievement Type: Unknown");
						break;
					}
				}
				return;
			}
		}
		printOutputLine("Received achievement definitions error");
		Error error = msg.GetError();
		printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
	}

	private void initAchievementCallback(Pvr_Message msg)
	{
		if (!msg.IsError)
		{
			printOutputLine("Received init success");
			return;
		}
		printOutputLine("Received init error");
		Error error = msg.GetError();
		printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
	}

	private void LoginCallback(string LoginInfo)
	{
		UnityEngine.Debug.Log("Received loginCallback:" + LoginInfo);
		printOutputLine("Received loginCallback: " + LoginInfo);
	}
}
public class Pvr_Controller : MonoBehaviour
{
	public enum UserHandNess
	{
		Right,
		Left
	}

	public enum GazeType
	{
		Never,
		DuringMotion,
		Always
	}

	public enum ControllerAxis
	{
		Controller,
		Wrist,
		Elbow,
		Shoulder
	}

	public GameObject controller0;

	public GameObject controller1;

	private static UserHandNess handness;

	public ControllerAxis Axis;

	public GazeType Gazetype;

	[Range(0f, 0.2f)]
	public float ElbowHeight;

	[Range(0f, 0.2f)]
	public float ElbowDepth;

	[Range(0f, 30f)]
	public float PointerTiltAngle = 15f;

	private float mouseX;

	private float mouseY;

	private float mouseZ;

	private Vector3[] inputDirection = new Vector3[2];

	public static Vector3 pointerPosition { get; set; }

	public static Quaternion pointerRotation { get; set; }

	public static Vector3 elbowPosition { get; set; }

	public static Quaternion elbowRotation { get; set; }

	public static Vector3 wristPosition { get; set; }

	public static Quaternion wristRotation { get; set; }

	public static Vector3 shoulderPosition { get; set; }

	public static Quaternion shoulderRotation { get; set; }

	public static Vector3 originOffsetL { get; set; }

	public static Vector3 originOffsetR { get; set; }

	private void Awake()
	{
		Pvr_ControllerManager.PvrServiceStartSuccessEvent += ServiceStartSuccess;
		Pvr_ControllerManager.SetControllerAbilityEvent += CheckControllerState;
		Pvr_ControllerManager.ChangeMainControllerCallBackEvent += MainControllerChanged;
		Pvr_ControllerManager.ChangeHandNessCallBackEvent += HandnessChanged;
	}

	private void Start()
	{
		handness = Controller.UPvr_GetHandNess();
		if (handness == (UserHandNess)(-1))
		{
			handness = UserHandNess.Right;
		}
	}

	private void OnDestroy()
	{
		Pvr_ControllerManager.PvrServiceStartSuccessEvent -= ServiceStartSuccess;
		Pvr_ControllerManager.SetControllerAbilityEvent -= CheckControllerState;
		Pvr_ControllerManager.ChangeMainControllerCallBackEvent -= MainControllerChanged;
		Pvr_ControllerManager.ChangeHandNessCallBackEvent -= HandnessChanged;
	}

	private void MainControllerChanged(string index)
	{
		RefreshHandness();
	}

	private void HandnessChanged(string index)
	{
		RefreshHandness();
	}

	private void ServiceStartSuccess()
	{
		RefreshHandness();
	}

	private void RefreshHandness()
	{
		handness = Controller.UPvr_GetHandNess();
		if (Controller.UPvr_GetMainHandNess() == 1)
		{
			ChangeHandNess();
		}
	}

	private void OnApplicationPause(bool pause)
	{
		if (!pause)
		{
			if (controller0 != null)
			{
				controller0.transform.localScale = Vector3.zero;
			}
			if (controller1 != null)
			{
				controller1.transform.localScale = Vector3.zero;
			}
		}
		Invoke("ShowController", 0.1f * Time.timeScale);
	}

	private void ShowController()
	{
		if (controller0 != null)
		{
			controller0.transform.localScale = Vector3.one;
		}
		if (controller1 != null)
		{
			controller1.transform.localScale = Vector3.one;
		}
	}

	private void CheckControllerState(string data)
	{
		bool num = Convert.ToBoolean(Convert.ToInt16(data.Substring(4, 1)));
		short num2 = Convert.ToInt16(data.Substring(0, 1));
		if (num && num2 == 1)
		{
			RefreshHandness();
		}
	}

	private void Update()
	{
		if (Pvr_UnitySDKManager.SDK.ControllerOnlyrot)
		{
			DoUpdateControler0();
			DoUpdateControler1();
			UpdateControlloerRay();
			return;
		}
		if (Controller.UPvr_GetPreferenceDevice() == 1)
		{
			DoUpdateControler0();
			DoUpdateControler1();
			UpdateControlloerRay();
			return;
		}
		if (controller0 != null)
		{
			controller0.transform.localRotation = Controller.UPvr_GetControllerQUA(0);
			controller0.transform.localPosition = Controller.UPvr_GetControllerPOS(0) + Controller.UPvr_GetControllerQUA(0) * originOffsetL;
			UpdateControlloerRay(update0: true, update1: false);
		}
		if (controller1 != null)
		{
			controller1.transform.localRotation = Controller.UPvr_GetControllerQUA(1);
			controller1.transform.localPosition = Controller.UPvr_GetControllerPOS(1) + Controller.UPvr_GetControllerQUA(1) * originOffsetR;
			UpdateControlloerRay(update0: false);
		}
	}

	public static void ChangeHandNess()
	{
		handness = ((handness == UserHandNess.Right) ? UserHandNess.Left : UserHandNess.Right);
	}

	private void DoUpdateControler0()
	{
		SetArmParaToSo((int)handness, (int)Gazetype, ElbowHeight, ElbowDepth, PointerTiltAngle);
		CalcArmModelfromSo(0);
		UpdateControllerDataSO(0);
	}

	private void DoUpdateControler1()
	{
		int hand = ((handness != UserHandNess.Left) ? 1 : 0);
		SetArmParaToSo(hand, (int)Gazetype, ElbowHeight, ElbowDepth, PointerTiltAngle);
		CalcArmModelfromSo(1);
		UpdateControllerDataSO(1);
	}

	private void UpdateControlloerRay(bool update0 = true, bool update1 = true)
	{
		if (Pvr_ControllerManager.Instance.LengthAdaptiveRay)
		{
			if (update0 && controller0 != null)
			{
				controller0.GetComponent<Pvr_ControllerModuleInit>().UpdateRay();
			}
			if (update1 && controller1 != null)
			{
				controller1.GetComponent<Pvr_ControllerModuleInit>().UpdateRay();
			}
		}
	}

	private Quaternion UpdateSimulatedFrameParams()
	{
		if (Input.GetKey(KeyCode.LeftShift))
		{
			mouseX += Input.GetAxis("Mouse X") * 5f;
			if (mouseX <= -180f)
			{
				mouseX += 360f;
			}
			else if (mouseX > 180f)
			{
				mouseX -= 360f;
			}
			mouseY -= Input.GetAxis("Mouse Y") * 2.4f;
			mouseY = Mathf.Clamp(mouseY, -80f, 80f);
		}
		else if (Input.GetKey(KeyCode.RightShift))
		{
			mouseZ += Input.GetAxis("Mouse X") * 5f;
			mouseZ = Mathf.Clamp(mouseZ, -80f, 80f);
		}
		return Quaternion.Euler(mouseY, mouseX, mouseZ);
	}

	private void SetArmParaToSo(int hand, int gazeType, float elbowHeight, float elbowDepth, float pointerTiltAngle)
	{
		Controller.UPvr_SetArmModelParameters(hand, gazeType, elbowHeight, elbowDepth, pointerTiltAngle);
	}

	private void CalcArmModelfromSo(int hand)
	{
		float[] array = new float[4];
		float[] array2 = new float[4];
		float[] array3 = new float[3];
		Quaternion quaternion = default(Quaternion);
		quaternion = Controller.UPvr_GetControllerQUA(hand);
		Vector3 vector = Controller.UPvr_GetAngularVelocity(hand);
		array2[0] = quaternion.x;
		array2[1] = quaternion.y;
		array2[2] = quaternion.z;
		array2[3] = quaternion.w;
		array3[0] = vector.x;
		array3[1] = vector.y;
		array3[2] = vector.z;
		if (Gazetype == GazeType.DuringMotion)
		{
			Vector3 b = Pvr_UnitySDKSensor.Instance.HeadPose.Orientation * Vector3.forward;
			b.y = 0f;
			b.Normalize();
			float t = Mathf.Clamp((vector.magnitude - 0.2f) / 45f, 0f, 0.1f);
			inputDirection[hand] = Vector3.Slerp(inputDirection[hand], b, t);
			if (Controller.UPvr_GetKeyLongPressed(hand, Pvr_KeyCode.HOME))
			{
				inputDirection[hand] = default(Vector3);
			}
			Quaternion quaternion2 = Quaternion.FromToRotation(Vector3.forward, inputDirection[hand]);
			array[0] = quaternion2.x;
			array[1] = quaternion2.y;
			array[2] = quaternion2.z;
			array[3] = quaternion2.w;
		}
		else
		{
			array[0] = Pvr_UnitySDKSensor.Instance.HeadPose.Orientation.x;
			array[1] = Pvr_UnitySDKSensor.Instance.HeadPose.Orientation.y;
			array[2] = Pvr_UnitySDKSensor.Instance.HeadPose.Orientation.z;
			array[3] = Pvr_UnitySDKSensor.Instance.HeadPose.Orientation.w;
		}
		Controller.UPvr_CalcArmModelParameters(array, array2, array3);
	}

	public void UpdateControllerDataSO(int hand)
	{
		float[] array = new float[4];
		float[] array2 = new float[3];
		Vector3 vector;
		Quaternion localRotation;
		switch (Axis)
		{
		case ControllerAxis.Controller:
			Controller.UPvr_GetPointerPose(array, array2);
			pointerPosition = new Vector3(array2[0], array2[1], array2[2]);
			pointerRotation = new Quaternion(array[0], array[1], array[2], array[3]);
			vector = pointerPosition;
			localRotation = pointerRotation;
			break;
		case ControllerAxis.Wrist:
			Controller.UPvr_GetWristPose(array, array2);
			wristPosition = new Vector3(array2[0], array2[1], array2[2]);
			wristRotation = new Quaternion(array[0], array[1], array[2], array[3]);
			vector = wristPosition;
			localRotation = wristRotation;
			break;
		case ControllerAxis.Elbow:
			Controller.UPvr_GetElbowPose(array, array2);
			elbowPosition = new Vector3(array2[0], array2[1], array2[2]);
			elbowRotation = new Quaternion(array[0], array[1], array[2], array[3]);
			vector = elbowPosition;
			localRotation = elbowRotation;
			break;
		case ControllerAxis.Shoulder:
			Controller.UPvr_GetShoulderPose(array, array2);
			shoulderPosition = new Vector3(array2[0], array2[1], array2[2]);
			shoulderRotation = new Quaternion(array[0], array[1], array[2], array[3]);
			vector = shoulderPosition;
			localRotation = shoulderRotation;
			break;
		default:
			throw new Exception("Invalid FromJoint.");
		}
		if (hand == 0)
		{
			if (controller0 != null)
			{
				if (!Pvr_UnitySDKManager.SDK.HmdOnlyrot)
				{
					controller0.transform.localPosition = vector + Pvr_UnitySDKSensor.Instance.HeadPose.Position;
				}
				else if (Pvr_UnitySDKManager.SDK.TrackingOrigin == TrackingOrigin.FloorLevel)
				{
					controller0.transform.localPosition = vector + Pvr_UnitySDKSensor.Instance.HeadPose.Position;
				}
				else
				{
					controller0.transform.localPosition = vector;
				}
				controller0.transform.localRotation = localRotation;
			}
		}
		else if (controller1 != null)
		{
			if (!Pvr_UnitySDKManager.SDK.HmdOnlyrot)
			{
				controller1.transform.localPosition = vector + Pvr_UnitySDKSensor.Instance.HeadPose.Position;
			}
			else if (Pvr_UnitySDKManager.SDK.TrackingOrigin == TrackingOrigin.FloorLevel)
			{
				controller1.transform.localPosition = vector + Pvr_UnitySDKSensor.Instance.HeadPose.Position;
			}
			else
			{
				controller1.transform.localPosition = vector;
			}
			controller1.transform.localRotation = localRotation;
		}
	}
}
public class Pvr_ControllerDemo : MonoBehaviour
{
	public GameObject HeadSetController;

	public GameObject controller0;

	public GameObject controller1;

	public GameObject cube;

	private Ray ray;

	private GameObject currentController;

	private Transform lastHit;

	private Transform currentHit;

	[SerializeField]
	private Material normat;

	[SerializeField]
	private Material gazemat;

	[SerializeField]
	private Material clickmat;

	private bool noClick;

	private GameObject referenceObj;

	public float rayDefaultLength = 4f;

	private bool isHasController;

	private bool headcontrolmode;

	private RaycastHit hit;

	private GameObject rayLine;

	private GameObject dot;

	private Transform dragObj;

	private float disX;

	private float disY;

	private float disZ;

	private void Start()
	{
		ray = default(Ray);
		hit = default(RaycastHit);
		if (Pvr_UnitySDKManager.SDK.isHasController)
		{
			Pvr_ControllerManager.PvrServiceStartSuccessEvent += ServiceStartSuccess;
			Pvr_ControllerManager.SetControllerStateChangedEvent += ControllerStateListener;
			Pvr_ControllerManager.ControllerStatusChangeEvent += CheckControllerStateForGoblin;
			isHasController = true;
		}
		referenceObj = new GameObject("ReferenceObj");
	}

	private void OnDestroy()
	{
		if (isHasController)
		{
			Pvr_ControllerManager.PvrServiceStartSuccessEvent -= ServiceStartSuccess;
			Pvr_ControllerManager.SetControllerStateChangedEvent -= ControllerStateListener;
			Pvr_ControllerManager.ControllerStatusChangeEvent -= CheckControllerStateForGoblin;
		}
	}

	private void Update()
	{
		if (HeadSetController.activeSelf)
		{
			HeadSetController.transform.parent.localRotation = Quaternion.Euler(Pvr_UnitySDKSensor.Instance.HeadPose.Orientation.eulerAngles.x, Pvr_UnitySDKSensor.Instance.HeadPose.Orientation.eulerAngles.y, 0f);
			HeadSetController.transform.parent.localPosition = Pvr_UnitySDKSensor.Instance.HeadPose.Position;
			ray.direction = HeadSetController.transform.position - HeadSetController.transform.parent.parent.Find("Head").position;
			ray.origin = HeadSetController.transform.parent.parent.Find("Head").position;
			if (Physics.Raycast(ray, out hit))
			{
				if (HeadSetController.name == "SightPointer")
				{
					HeadSetController.transform.localScale = new Vector3(0.09f, 0.09f, 0.09f);
				}
				currentHit = hit.transform;
				if (currentHit != null && lastHit != null && currentHit != lastHit && (bool)lastHit.GetComponent<Pvr_UIGraphicRaycaster>() && lastHit.transform.gameObject.activeInHierarchy && lastHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled)
				{
					lastHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled = false;
				}
				if (currentHit != null && lastHit != null && currentHit == lastHit && (bool)currentHit.GetComponent<Pvr_UIGraphicRaycaster>() && !currentHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled)
				{
					currentHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled = true;
				}
				if (1 << hit.transform.gameObject.layer == LayerMask.GetMask("Water") && !noClick)
				{
					hit.transform.GetComponent<Renderer>().material = gazemat;
				}
				lastHit = hit.transform;
				if (Pvr_ControllerManager.Instance.LengthAdaptiveRay)
				{
					HeadSetController.transform.position = hit.point;
					HeadSetController.transform.position -= (hit.point - HeadSetController.transform.parent.parent.Find("Head").position).normalized * 0.02f;
					float num = 0.008f * hit.distance / 4f;
					Mathf.Clamp(num, 0.002f, 0.008f);
					HeadSetController.transform.localScale = new Vector3(num, num, 1f);
				}
			}
			else
			{
				if (HeadSetController.name == "SightPointer")
				{
					HeadSetController.transform.localScale = Vector3.zero;
				}
				if (lastHit != null && 1 << lastHit.transform.gameObject.layer == LayerMask.GetMask("Water"))
				{
					lastHit.transform.GetComponent<Renderer>().material = normat;
				}
				currentHit = null;
				noClick = false;
				if (Pvr_ControllerManager.Instance.LengthAdaptiveRay)
				{
					HeadSetController.transform.position = HeadSetController.transform.parent.parent.Find("Head").position + ray.direction.normalized * (0.5f + rayDefaultLength);
					HeadSetController.transform.localScale = new Vector3(0.008f, 0.008f, 1f);
				}
			}
			if ((Input.GetKeyDown(KeyCode.JoystickButton0) || Input.GetMouseButtonDown(0)) && lastHit != null && 1 << lastHit.transform.gameObject.layer == LayerMask.GetMask("Water") && currentHit != null)
			{
				lastHit.transform.GetComponent<Renderer>().material = clickmat;
				noClick = true;
			}
			return;
		}
		if (currentController != null)
		{
			ray.direction = currentController.transform.forward - currentController.transform.up * 0.25f;
			ray.origin = currentController.transform.Find("start").position;
			if (Physics.Raycast(ray, out hit))
			{
				currentHit = hit.transform;
				if (currentHit != null && lastHit != null && currentHit != lastHit && (bool)lastHit.GetComponent<Pvr_UIGraphicRaycaster>() && lastHit.transform.gameObject.activeInHierarchy && lastHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled)
				{
					lastHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled = false;
				}
				if (currentHit != null && lastHit != null && currentHit == lastHit && (bool)currentHit.GetComponent<Pvr_UIGraphicRaycaster>() && !currentHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled)
				{
					currentHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled = true;
				}
				if (1 << hit.transform.gameObject.layer == LayerMask.GetMask("Water"))
				{
					if (!noClick)
					{
						hit.transform.GetComponent<Renderer>().material = gazemat;
					}
					if (Controller.UPvr_GetKeyDown(0, Pvr_KeyCode.TOUCHPAD) || Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.TOUCHPAD) || Input.GetMouseButtonDown(0))
					{
						referenceObj.transform.position = hit.point;
						disX = hit.transform.position.x - referenceObj.transform.position.x;
						disY = hit.transform.position.y - referenceObj.transform.position.y;
						dragObj = hit.transform;
					}
					if ((Controller.UPvr_GetKey(0, Pvr_KeyCode.TOUCHPAD) || Controller.UPvr_GetKey(1, Pvr_KeyCode.TOUCHPAD) || Input.GetMouseButton(0)) && hit.transform == dragObj.transform)
					{
						referenceObj.transform.position = new Vector3(hit.point.x, hit.point.y, hit.transform.position.z);
						dragObj.position = new Vector3(referenceObj.transform.position.x + disX, referenceObj.transform.position.y + disY, hit.transform.position.z);
					}
				}
				lastHit = hit.transform;
				currentController.transform.Find("dot").position = hit.point;
				if (Pvr_ControllerManager.Instance.LengthAdaptiveRay)
				{
					float num2 = 0.178f * currentController.transform.Find("dot").localPosition.z / 3.3f;
					Mathf.Clamp(num2, 0.05f, 0.178f);
					currentController.transform.Find("dot").localScale = new Vector3(num2, num2, 1f);
				}
			}
			else
			{
				if (lastHit != null && 1 << lastHit.transform.gameObject.layer == LayerMask.GetMask("Water"))
				{
					lastHit.transform.GetComponent<Renderer>().material = normat;
				}
				currentHit = null;
				noClick = false;
				if (Pvr_ControllerManager.Instance.LengthAdaptiveRay)
				{
					currentController.transform.Find("dot").localScale = new Vector3(0.178f, 0.178f, 1f);
				}
			}
		}
		if ((Controller.UPvr_GetKeyDown(0, Pvr_KeyCode.TOUCHPAD) || Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.TOUCHPAD) || Input.GetMouseButtonDown(0)) && lastHit != null && 1 << lastHit.transform.gameObject.layer == LayerMask.GetMask("Water") && currentHit != null)
		{
			lastHit.transform.GetComponent<Renderer>().material = clickmat;
			noClick = true;
		}
	}

	private void ServiceStartSuccess()
	{
		if (Controller.UPvr_GetControllerState(0) == ControllerState.Connected || Controller.UPvr_GetControllerState(1) == ControllerState.Connected)
		{
			HeadSetController.SetActive(value: false);
		}
		else
		{
			HeadSetController.SetActive(value: true);
		}
		if (Controller.UPvr_GetMainHandNess() == 0)
		{
			currentController = controller0;
		}
		if (Controller.UPvr_GetMainHandNess() == 1)
		{
			currentController = controller1;
		}
	}

	private void ControllerStateListener(string data)
	{
		if (Controller.UPvr_GetControllerState(0) == ControllerState.Connected || Controller.UPvr_GetControllerState(1) == ControllerState.Connected)
		{
			HeadSetController.SetActive(value: false);
		}
		else
		{
			HeadSetController.SetActive(value: true);
		}
		if (Controller.UPvr_GetMainHandNess() == 0)
		{
			currentController = controller0;
		}
		if (Controller.UPvr_GetMainHandNess() == 1)
		{
			currentController = controller1;
		}
	}

	private void CheckControllerStateForGoblin(string state)
	{
		HeadSetController.SetActive(Convert.ToInt16(state) != 1);
	}

	public void SwitchControlMode()
	{
	}
}
public class Pvr_ControllerEventsExamples : MonoBehaviour
{
	private void Start()
	{
		if (!(GetComponent<Pvr_UIPointer>() == null))
		{
			GetComponent<Pvr_UIPointer>().UIPointerElementEnter += UIPointerElementEnter;
			GetComponent<Pvr_UIPointer>().UIPointerElementExit += UIPointerElementExit;
			GetComponent<Pvr_UIPointer>().UIPointerElementClick += UIPointerElementClick;
			GetComponent<Pvr_UIPointer>().UIPointerElementDragStart += UIPointerElementDragStart;
			GetComponent<Pvr_UIPointer>().UIPointerElementDragEnd += UIPointerElementDragEnd;
		}
	}

	private void UIPointerElementEnter(object sender, UIPointerEventArgs e)
	{
		PLOG.I("UI Pointer entered" + e.currentTarget.name);
	}

	private void UIPointerElementExit(object sender, UIPointerEventArgs e)
	{
		PLOG.I("UI Pointer exited" + e.currentTarget.name);
	}

	private void UIPointerElementClick(object sender, UIPointerEventArgs e)
	{
		PLOG.I("UI Pointer clicked" + e.currentTarget.name);
	}

	private void UIPointerElementDragStart(object sender, UIPointerEventArgs e)
	{
		PLOG.I("UI Pointer started dragging" + e.currentTarget.name);
	}

	private void UIPointerElementDragEnd(object sender, UIPointerEventArgs e)
	{
		PLOG.I("UI Pointer stopped dragging" + e.currentTarget.name);
	}
}
public class Pvr_ControllerInit : MonoBehaviour
{
	private ControllerVariety Variety;

	private bool isCustomModel;

	[SerializeField]
	private GameObject goblin;

	[SerializeField]
	private GameObject g2;

	[SerializeField]
	private GameObject neo2L;

	[SerializeField]
	private GameObject neo2R;

	[SerializeField]
	private GameObject neo3L;

	[SerializeField]
	private GameObject neo3R;

	[SerializeField]
	private Material standardMat;

	[SerializeField]
	private Material unlitMat;

	private int controllerType = -1;

	[HideInInspector]
	public bool loadModelSuccess;

	private int systemOrUnity;

	private JsonData curControllerData;

	private string modelName = "";

	private string texFormat = "";

	private string prePath = "";

	private string modelFilePath = "/system/media/PvrRes/controller/";

	private const string goblinTexbasePath = "Controller/controller1/controller1";

	private const string g2TexbasePath = "Controller/controller3/controller3";

	private const string neo2TexbasePath = "Controller/controller4/controller4";

	private const string neo3TexbasePath = "Controller/controller5/controller5";

	private void Awake()
	{
		Render.UPvr_GetIntConfig(15, ref systemOrUnity);
		Variety = base.transform.GetComponentInParent<Pvr_ControllerModuleInit>().Variety;
		isCustomModel = base.transform.GetComponentInParent<Pvr_ControllerModuleInit>().IsCustomModel;
		if (!isCustomModel)
		{
			Pvr_ControllerManager.PvrServiceStartSuccessEvent += ServiceStartSuccess;
			Pvr_ControllerManager.SetControllerAbilityEvent += CheckControllerStateOfAbility;
			Pvr_ControllerManager.ControllerStatusChangeEvent += CheckControllerStateForGoblin;
		}
	}

	private void OnDestroy()
	{
		Pvr_ControllerManager.PvrServiceStartSuccessEvent -= ServiceStartSuccess;
		Pvr_ControllerManager.SetControllerAbilityEvent -= CheckControllerStateOfAbility;
		Pvr_ControllerManager.ControllerStatusChangeEvent -= CheckControllerStateForGoblin;
	}

	private void OnApplicationPause(bool pause)
	{
		if (pause)
		{
			DestroyLocalController();
		}
	}

	private void ServiceStartSuccess()
	{
		int num = Controller.UPvr_GetDeviceType();
		if (controllerType != num && num != 0)
		{
			controllerType = num;
		}
		LoadResFromJson();
		if (Pvr_ControllerManager.controllerlink.neoserviceStarted)
		{
			if (Variety == ControllerVariety.Controller0)
			{
				if (Pvr_ControllerManager.controllerlink.controller0Connected)
				{
					StartCoroutine(RefreshController(0));
				}
				else
				{
					DestroyLocalController();
				}
			}
			if (Variety == ControllerVariety.Controller1)
			{
				if (Pvr_ControllerManager.controllerlink.controller1Connected)
				{
					StartCoroutine(RefreshController(1));
				}
				else
				{
					DestroyLocalController();
				}
			}
		}
		if (Pvr_ControllerManager.controllerlink.goblinserviceStarted && Variety == ControllerVariety.Controller0)
		{
			if (Pvr_ControllerManager.controllerlink.controller0Connected)
			{
				StartCoroutine(RefreshController(0));
			}
			else
			{
				DestroyLocalController();
			}
		}
	}

	private void LoadResFromJson()
	{
		string text = Pvr_UnitySDKAPI.System.UPvr_GetObjectOrArray("config.controller", 7);
		if (text != null)
		{
			JsonData jsonData = JsonMapper.ToObject(text);
			if (controllerType >= 0 && jsonData.Count >= controllerType)
			{
				curControllerData = jsonData[controllerType - 1];
				modelFilePath = (string)curControllerData["base_path"];
				modelName = (string)curControllerData["model_name"] + "_sys";
			}
		}
		else
		{
			PLOG.E("PvrLog LoadJsonFromSystem Error");
		}
	}

	private void CheckControllerStateForGoblin(string state)
	{
		int num = Controller.UPvr_GetDeviceType();
		if (Variety != 0)
		{
			return;
		}
		if (Convert.ToInt16(state) == 1)
		{
			if (controllerType != num)
			{
				DestroySysController();
				controllerType = num;
			}
			StartCoroutine(RefreshController(0));
		}
		else
		{
			DestroyLocalController();
		}
	}

	private void CheckControllerStateOfAbility(string data)
	{
		bool num = Convert.ToBoolean(Convert.ToInt16(data.Substring(4, 1)));
		short num2 = Convert.ToInt16(data.Substring(0, 1));
		int num3 = Controller.UPvr_GetDeviceType();
		if (num)
		{
			controllerType = num3;
			switch (num2)
			{
			case 0:
				if (Variety == ControllerVariety.Controller0)
				{
					StartCoroutine(RefreshController(0));
				}
				break;
			case 1:
				if (Variety == ControllerVariety.Controller1)
				{
					StartCoroutine(RefreshController(1));
				}
				break;
			}
			return;
		}
		switch (num2)
		{
		case 0:
			if (Variety == ControllerVariety.Controller0)
			{
				DestroyLocalController();
			}
			break;
		case 1:
			if (Variety == ControllerVariety.Controller1)
			{
				DestroyLocalController();
			}
			break;
		}
	}

	private void DestroyLocalController()
	{
		foreach (Transform item in base.transform)
		{
			UnityEngine.Object.Destroy(item.gameObject);
			loadModelSuccess = false;
		}
	}

	private void DestroySysController()
	{
		foreach (Transform item in base.transform)
		{
			if (item.name == modelName)
			{
				UnityEngine.Object.Destroy(item.gameObject);
				loadModelSuccess = false;
			}
		}
	}

	private IEnumerator RefreshController(int id)
	{
		yield return null;
		yield return null;
		if (Controller.UPvr_GetControllerState(id) != ControllerState.Connected)
		{
			yield break;
		}
		if (systemOrUnity == 0)
		{
			LoadControllerFromPrefab();
			if (!loadModelSuccess)
			{
				LoadControllerFromSystem(id);
			}
		}
		else
		{
			bool flag = false;
			foreach (Transform item in base.transform)
			{
				if (item.name == modelName)
				{
					flag = true;
				}
			}
			if (!flag)
			{
				LoadControllerFromSystem(id);
				if (!loadModelSuccess)
				{
					LoadControllerFromPrefab();
				}
			}
			else
			{
				base.transform.Find(modelName).gameObject.SetActive(value: true);
			}
		}
		Pvr_ToolTips.RefreshTips();
		PLOG.I("PvrLog Controller Refresh Success");
	}

	private void LoadControllerFromPrefab()
	{
		switch (controllerType)
		{
		case 1:
		{
			Pvr_ControllerVisual pvr_ControllerVisual3 = UnityEngine.Object.Instantiate(goblin, base.transform, worldPositionStays: false).AddComponent<Pvr_ControllerVisual>();
			pvr_ControllerVisual3.currentDevice = ControllerDevice.Goblin;
			LoadTexture(pvr_ControllerVisual3, "Controller/controller1/controller1", fromRes: true);
			loadModelSuccess = true;
			break;
		}
		case 3:
		{
			Pvr_ControllerVisual pvr_ControllerVisual2 = UnityEngine.Object.Instantiate(g2, base.transform, worldPositionStays: false).AddComponent<Pvr_ControllerVisual>();
			pvr_ControllerVisual2.currentDevice = ControllerDevice.G2;
			LoadTexture(pvr_ControllerVisual2, "Controller/controller3/controller3", fromRes: true);
			loadModelSuccess = true;
			break;
		}
		case 4:
		{
			Pvr_ControllerVisual pvr_ControllerVisual4 = UnityEngine.Object.Instantiate((Variety == ControllerVariety.Controller0) ? neo2L : neo2R, base.transform, worldPositionStays: false).AddComponent<Pvr_ControllerVisual>();
			pvr_ControllerVisual4.currentDevice = ControllerDevice.Neo2;
			LoadTexture(pvr_ControllerVisual4, "Controller/controller4/controller4", fromRes: true);
			loadModelSuccess = true;
			break;
		}
		case 5:
		{
			Pvr_ControllerVisual pvr_ControllerVisual = UnityEngine.Object.Instantiate((Variety == ControllerVariety.Controller0) ? neo3L : neo3R, base.transform, worldPositionStays: false).AddComponent<Pvr_ControllerVisual>();
			pvr_ControllerVisual.currentDevice = ControllerDevice.Neo3;
			LoadTexture(pvr_ControllerVisual, "Controller/controller5/controller5", fromRes: true);
			loadModelSuccess = true;
			break;
		}
		default:
			loadModelSuccess = false;
			break;
		}
	}

	private void LoadControllerFromSystem(int id)
	{
		string text = controllerType.ToString() + id + ".obj";
		string text2 = modelFilePath + text;
		if (!File.Exists(text2))
		{
			PLOG.I("PvrLog Obj File does not exist==" + text2);
			return;
		}
		GameObject gameObject = new GameObject();
		gameObject.name = modelName;
		gameObject.AddComponent<MeshFilter>().mesh = Pvr_ObjImporter.Instance.ImportFile(text2);
		gameObject.transform.SetParent(base.transform);
		gameObject.transform.localPosition = Vector3.zero;
		gameObject.AddComponent<MeshRenderer>().material = (((int)curControllerData["material_type"] == 0) ? standardMat : unlitMat);
		loadModelSuccess = true;
		Pvr_ControllerVisual pvr_ControllerVisual = gameObject.AddComponent<Pvr_ControllerVisual>();
		switch (controllerType)
		{
		case 1:
			pvr_ControllerVisual.currentDevice = ControllerDevice.Goblin;
			break;
		case 3:
			pvr_ControllerVisual.currentDevice = ControllerDevice.G2;
			break;
		case 4:
			pvr_ControllerVisual.currentDevice = ControllerDevice.Neo2;
			break;
		case 5:
			pvr_ControllerVisual.currentDevice = ControllerDevice.Neo3;
			break;
		default:
			pvr_ControllerVisual.currentDevice = ControllerDevice.NewController;
			break;
		}
		pvr_ControllerVisual.variety = Variety;
		LoadTexture(pvr_ControllerVisual, controllerType.ToString() + id, fromRes: false);
		gameObject.transform.localRotation = Quaternion.Euler(new Vector3(0f, 180f, 0f));
		gameObject.transform.localScale = new Vector3(-0.01f, 0.01f, 0.01f);
	}

	private void LoadTexture(Pvr_ControllerVisual visual, string controllerName, bool fromRes)
	{
		if (fromRes)
		{
			texFormat = "";
			prePath = controllerName;
		}
		else
		{
			texFormat = "." + (string)curControllerData["tex_format"];
			prePath = modelFilePath + controllerName;
		}
		string filepath = prePath + "_idle" + texFormat;
		visual.m_idle = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_app" + texFormat;
		visual.m_app = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_home" + texFormat;
		visual.m_home = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_touch" + texFormat;
		visual.m_touchpad = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_volume_down" + texFormat;
		visual.m_volDn = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_volume_up" + texFormat;
		visual.m_volUp = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_trigger" + texFormat;
		visual.m_trigger = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_a" + texFormat;
		visual.m_a = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_b" + texFormat;
		visual.m_b = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_x" + texFormat;
		visual.m_x = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_y" + texFormat;
		visual.m_y = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_grip" + texFormat;
		visual.m_grip = LoadOneTexture(filepath, fromRes);
	}

	private Texture2D LoadOneTexture(string filepath, bool fromRes)
	{
		if (fromRes)
		{
			return Resources.Load<Texture2D>(filepath);
		}
		int width = (int)curControllerData["tex_width"];
		int height = (int)curControllerData["tex_height"];
		Texture2D texture2D = new Texture2D(width, height);
		texture2D.LoadImage(ReadPNG(filepath));
		return texture2D;
	}

	private byte[] ReadPNG(string path)
	{
		FileStream fileStream = new FileStream(path, FileMode.Open, FileAccess.Read);
		fileStream.Seek(0L, SeekOrigin.Begin);
		byte[] array = new byte[fileStream.Length];
		fileStream.Read(array, 0, (int)fileStream.Length);
		fileStream.Close();
		fileStream.Dispose();
		fileStream = null;
		return array;
	}
}
public class Pvr_ControllerLink
{
	public AndroidJavaClass javaHummingbirdClass;

	public AndroidJavaClass javaPico2ReceiverClass;

	public AndroidJavaClass javaserviceClass;

	public AndroidJavaClass javavractivityclass;

	public AndroidJavaClass javaCVClass;

	public AndroidJavaObject activity;

	public string gameobjname = "";

	public bool picoDevice;

	public string hummingBirdMac;

	public int hummingBirdRSSI;

	public bool goblinserviceStarted;

	public bool neoserviceStarted;

	public bool controller0Connected;

	public bool controller1Connected;

	public int mainHandID;

	public Pvr_Controller.UserHandNess handness;

	public int controllerType;

	public ControllerHand Controller0;

	public ControllerHand Controller1;

	public int platFormType = -1;

	public int trackingmode = -1;

	public int systemProp = -1;

	public int enablehand6dofbyhead = -1;

	public bool switchHomeKey = true;

	private const float SWITCH_METER = 1000f;

	private int iPhoneHMDModeEnabled;

	private float[] hbPoseData = new float[4];

	private float[] sensorData = new float[28];

	private int[] keyData = new int[134];

	private int[] neo3TouchValue = new int[15];

	private float[] fixedState = new float[7] { 0f, 0f, 0f, 1f, 0f, 0f, 0f };

	private float[] neoposeData = new float[7] { 0f, 0f, 0f, 1f, 0f, 0f, 0f };

	private int[] goblinKeyArray = new int[47];

	private int[] neoKeyArray = new int[67];

	private int[] neotriggerV = new int[9];

	private float[] velocity = new float[3];

	private float[] angularVelocity = new float[3];

	private float[] acceData = new float[3];

	private float[] predictData = new float[7];

	public Pvr_ControllerLink(string name)
	{
		gameobjname = name;
		hummingBirdMac = "";
		hummingBirdRSSI = 0;
		UnityEngine.Debug.Log("PvrLog Controller GameObject:" + gameobjname);
		StartHummingBirdService();
		Controller0 = new ControllerHand();
		Controller0.Position = new Vector3(0f, Pvr_UnitySDKSensor.Instance.HeadPose.Position.y, 0f) + new Vector3(-0.1f, -0.3f, 0.3f);
		Controller1 = new ControllerHand();
		Controller1.Position = new Vector3(0f, Pvr_UnitySDKSensor.Instance.HeadPose.Position.y, 0f) + new Vector3(0.1f, -0.3f, 0.3f);
	}

	private void StartHummingBirdService()
	{
		try
		{
			AndroidJavaClass androidJavaClass = new AndroidJavaClass("com.unity3d.player.UnityPlayer");
			activity = androidJavaClass.GetStatic<AndroidJavaObject>("currentActivity");
			javaHummingbirdClass = new AndroidJavaClass("com.picovr.picovrlib.hummingbirdclient.HbClientActivity");
			javaCVClass = new AndroidJavaClass("com.picovr.picovrlib.cvcontrollerclient.ControllerClient");
			javavractivityclass = new AndroidJavaClass("com.psmart.vrlib.VrActivity");
			javaserviceClass = new AndroidJavaClass("com.picovr.picovrlib.hummingbirdclient.UnityClient");
			Pvr_UnitySDKAPI.System.Pvr_SetInitActivity(activity.GetRawObject(), javaHummingbirdClass.GetRawClass());
			Render.UPvr_GetIntConfig(4, ref platFormType);
			UnityEngine.Debug.Log("PvrLog platform" + platFormType);
			Render.UPvr_GetIntConfig(5, ref trackingmode);
			UnityEngine.Debug.Log("PvrLog trackingmode" + trackingmode);
			systemProp = GetSysproc();
			UnityEngine.Debug.Log("PvrLog systemProp" + systemProp);
			Render.UPvr_GetIntConfig(7, ref enablehand6dofbyhead);
			UnityEngine.Debug.Log("PvrLog enablehand6dofbyhead" + enablehand6dofbyhead);
			if (trackingmode == 0 || trackingmode == 1 || ((trackingmode == 3 || trackingmode == 5 || trackingmode == 6) && (systemProp == 1 || systemProp == 3)))
			{
				picoDevice = platFormType != 0;
				javaPico2ReceiverClass = new AndroidJavaClass("com.picovr.picovrlib.hummingbirdclient.HbClientReceiver");
				Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaPico2ReceiverClass, "startReceiver", activity, gameobjname);
				Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "setPlatformType", platFormType);
			}
			else
			{
				picoDevice = true;
				SetGameObjectToJar(gameobjname);
			}
			Render.UPvr_GetIntConfig(16, ref iPhoneHMDModeEnabled);
			if (iPhoneHMDModeEnabled == 1)
			{
				BindService();
			}
			else if (IsServiceExisted())
			{
				BindService();
			}
		}
		catch (AndroidJavaException ex)
		{
			PLOG.E("ConnectToAndriod--catch" + ex.Message);
		}
	}

	public bool IsServiceExisted()
	{
		bool result = false;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaserviceClass, "isServiceExisted", activity, trackingmode);
		UnityEngine.Debug.Log("PvrLog ServiceExisted ?" + result);
		return result;
	}

	public void SetGameObjectToJar(string name)
	{
		UnityEngine.Debug.Log("PvrLog SetGameObjectToJar " + name);
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "setGameObjectCallback", name);
	}

	public void BindService()
	{
		UnityEngine.Debug.Log("PvrLog Bind Service");
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaserviceClass, "bindService", activity, trackingmode);
	}

	public void UnBindService()
	{
		UnityEngine.Debug.Log("PvrLog UnBind Service");
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaserviceClass, "unbindService", activity, trackingmode);
	}

	public void StopReceiver()
	{
		UnityEngine.Debug.Log("PvrLog StopReceiver");
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaPico2ReceiverClass, "stopReceiver", activity);
	}

	public void StartReceiver()
	{
		UnityEngine.Debug.Log("PvrLog StartReceiver");
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaPico2ReceiverClass, "startReceiver", activity, gameobjname);
	}

	public int getHandness()
	{
		int result = -1;
		if (iPhoneHMDModeEnabled == 0)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javavractivityclass, "getPvrHandness", activity);
		}
		else
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getHbHandednessInSP");
		}
		PLOG.I("PvrLog GetHandness =" + result);
		return result;
	}

	public void setHandness(int hand)
	{
		PLOG.I("PvrLog SetHandness =" + hand);
		if (iPhoneHMDModeEnabled == 1)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "setHbHandednessInSP", hand);
		}
	}

	public void StartScan()
	{
		PLOG.I("PvrLog ScanHBController");
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "scanHbDevice", true);
	}

	public void StopScan()
	{
		PLOG.I("PvrLog StopScanHBController");
		if (iPhoneHMDModeEnabled == 0)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "scanHbDevice", false);
		}
	}

	public int GetSysproc()
	{
		int result = -1;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaserviceClass, "getSysproc");
		PLOG.I("PvrLog GetSysproc" + result);
		return result;
	}

	public void ResetController(int num)
	{
		UnityEngine.Debug.Log("PvrLog ResetController" + num);
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "resetControllerSensorState", num);
		}
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "resetHbSensorState");
		}
	}

	public void ConnectBLE()
	{
		UnityEngine.Debug.Log("PvrLog ConnectHBController" + hummingBirdMac);
		if (hummingBirdMac != "")
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "connectHbController", hummingBirdMac);
		}
	}

	public void DisConnectBLE()
	{
		UnityEngine.Debug.Log("PvrLog DisConnectHBController");
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "disconnectHbController");
	}

	public bool StartUpgrade()
	{
		UnityEngine.Debug.Log("PvrLog StartUpgradeHBController");
		bool result = false;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "startUpgrade");
		return result;
	}

	public void setBinPath(string path, bool isasset)
	{
		UnityEngine.Debug.Log("PvrLog setBinPath" + path + isasset);
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "setBinPath", path, isasset);
	}

	public string GetBLEImageType()
	{
		string result = "";
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getBLEImageType");
		}
		UnityEngine.Debug.Log("PvrLog GetBLEImageType" + result);
		return result;
	}

	public long GetBLEVersion()
	{
		long result = 0L;
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getBLEVersion");
		}
		UnityEngine.Debug.Log("PvrLog GetBLEVersion" + result);
		return result;
	}

	public string GetFileImageType()
	{
		string result = "";
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getFileImageType");
		}
		UnityEngine.Debug.Log("PvrLog GetFileImageType" + result);
		return result;
	}

	public long GetFileVersion()
	{
		long result = 0L;
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getFileVersion");
		}
		UnityEngine.Debug.Log("PvrLog GetFileVersion" + result);
		return result;
	}

	public int GetControllerConnectionState(int num)
	{
		int result = -1;
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getControllerConnectionState", num);
		}
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getHbConnectionState");
		}
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog GetControllerState:" + num + "state:" + result);
		}
		return result;
	}

	public void RebackToLauncher()
	{
		UnityEngine.Debug.Log("PvrLog RebackToLauncher");
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "startLauncher");
		}
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "startLauncher");
		}
	}

	public void TurnUpVolume()
	{
		UnityEngine.Debug.Log("PvrLog TurnUpVolume");
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "turnUpVolume", activity);
		}
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "turnUpVolume", activity);
		}
	}

	public void TurnDownVolume()
	{
		UnityEngine.Debug.Log("PvrLog TurnDownVolume");
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "turnDownVolume", activity);
		}
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "turnDownVolume", activity);
		}
	}

	public float[] GetHBControllerPoseData()
	{
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref hbPoseData, javaHummingbirdClass, "getHBSensorPose");
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog HBControllerData" + hbPoseData[0] + "," + hbPoseData[1] + "," + hbPoseData[2] + "," + hbPoseData[3]);
		}
		return hbPoseData;
	}

	public float[] GetControllerSensorData()
	{
		if (enablehand6dofbyhead == 1)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref sensorData, javaCVClass, "getControllerDataInfoBySharmem", Pvr_UnitySDKManager.SDK.headData);
		}
		else
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref sensorData, javaCVClass, "getControllerDataInfoBySharmem");
		}
		return sensorData;
	}

	public int[] GetControllerKeyData()
	{
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref keyData, javaCVClass, "getDoubleControllerKeyEventUnityExtBySharmem");
		return keyData;
	}

	public int[] GetNeo3TouchData(int hand)
	{
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref neo3TouchValue, javaCVClass, "getControllerTouchEvent", hand);
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog Neo3Touch hand:" + hand + "-" + neo3TouchValue[0] + neo3TouchValue[1] + neo3TouchValue[2] + neo3TouchValue[3] + neo3TouchValue[4] + "," + neo3TouchValue[5] + neo3TouchValue[6] + neo3TouchValue[7] + neo3TouchValue[8] + neo3TouchValue[9] + "," + neo3TouchValue[10] + neo3TouchValue[11] + neo3TouchValue[12] + neo3TouchValue[13] + neo3TouchValue[14]);
		}
		return neo3TouchValue;
	}

	public int GetNeo3GripValue(int hand)
	{
		int result = 0;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getControllerGripValue", hand);
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog Neo3GripValue:" + result);
		}
		return result;
	}

	public float[] GetControllerFixedSensorState(int hand)
	{
		if (trackingmode == 2 || trackingmode == 3)
		{
			return fixedState;
		}
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref fixedState, javaCVClass, "getControllerFixedSensorState", hand);
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog GetControllerFixedSensorState " + hand + "Rotation:" + fixedState[0] + "," + fixedState[1] + "," + fixedState[2] + "," + fixedState[3] + "Position:" + fixedState[4] + "," + fixedState[5] + "," + fixedState[6]);
		}
		return fixedState;
	}

	public float[] GetCvControllerPoseData(int hand)
	{
		if (enablehand6dofbyhead == 1)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref neoposeData, javaCVClass, "getControllerSensorState", hand, Pvr_UnitySDKManager.SDK.headData);
		}
		else
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref neoposeData, javaCVClass, "getControllerSensorState", hand);
		}
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog CVControllerData :" + neoposeData[0] + "," + neoposeData[1] + "," + neoposeData[2] + "," + neoposeData[3] + "," + neoposeData[4] + "," + neoposeData[5] + "," + neoposeData[6]);
		}
		return neoposeData;
	}

	public int[] GetHBControllerKeyData()
	{
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref goblinKeyArray, javaHummingbirdClass, "getHBKeyEventUnityExt");
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog HBControllerKey" + goblinKeyArray[0] + goblinKeyArray[1] + goblinKeyArray[2] + goblinKeyArray[3] + goblinKeyArray[4] + "," + goblinKeyArray[5] + goblinKeyArray[6] + goblinKeyArray[7] + goblinKeyArray[8] + goblinKeyArray[9] + "," + goblinKeyArray[10] + goblinKeyArray[11] + goblinKeyArray[12] + goblinKeyArray[13] + goblinKeyArray[14] + "," + goblinKeyArray[15] + goblinKeyArray[16] + goblinKeyArray[17] + goblinKeyArray[18] + goblinKeyArray[19] + "," + goblinKeyArray[20] + goblinKeyArray[21] + goblinKeyArray[22] + goblinKeyArray[23] + goblinKeyArray[24] + "," + goblinKeyArray[25] + goblinKeyArray[26] + goblinKeyArray[27] + goblinKeyArray[28] + goblinKeyArray[29] + "," + goblinKeyArray[30] + goblinKeyArray[31] + goblinKeyArray[32] + goblinKeyArray[33] + goblinKeyArray[34] + "," + goblinKeyArray[35] + goblinKeyArray[36] + goblinKeyArray[37] + goblinKeyArray[38] + goblinKeyArray[39] + "," + goblinKeyArray[40] + goblinKeyArray[41] + goblinKeyArray[42] + goblinKeyArray[43] + goblinKeyArray[44] + "," + goblinKeyArray[45] + goblinKeyArray[46]);
		}
		return goblinKeyArray;
	}

	public int GetHBKeyValue()
	{
		int result = -1;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getTriggerKeyEvent");
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog GoblinControllerTriggerKey:" + result);
		}
		return result;
	}

	public int[] GetCvControllerKeyData(int hand)
	{
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref neoKeyArray, javaCVClass, "getControllerKeyEventUnityExt", hand);
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog CVControllerKey hand:" + hand + "-" + neoKeyArray[0] + neoKeyArray[1] + neoKeyArray[2] + neoKeyArray[3] + neoKeyArray[4] + "," + neoKeyArray[5] + neoKeyArray[6] + neoKeyArray[7] + neoKeyArray[8] + neoKeyArray[9] + "," + neoKeyArray[10] + neoKeyArray[11] + neoKeyArray[12] + neoKeyArray[13] + neoKeyArray[14] + "," + neoKeyArray[15] + neoKeyArray[16] + neoKeyArray[17] + neoKeyArray[18] + neoKeyArray[19] + "," + neoKeyArray[20] + neoKeyArray[21] + neoKeyArray[22] + neoKeyArray[23] + neoKeyArray[24] + "," + neoKeyArray[25] + neoKeyArray[26] + neoKeyArray[27] + neoKeyArray[28] + neoKeyArray[29] + "," + neoKeyArray[30] + neoKeyArray[31] + neoKeyArray[32] + neoKeyArray[33] + neoKeyArray[34] + "," + neoKeyArray[35] + neoKeyArray[36] + neoKeyArray[37] + neoKeyArray[38] + neoKeyArray[39] + "," + neoKeyArray[40] + neoKeyArray[41] + neoKeyArray[42] + neoKeyArray[43] + neoKeyArray[44] + "," + neoKeyArray[45] + neoKeyArray[46] + neoKeyArray[47] + neoKeyArray[48] + neoKeyArray[49] + "," + neoKeyArray[50] + neoKeyArray[51] + neoKeyArray[52] + neoKeyArray[53] + neoKeyArray[54] + "," + neoKeyArray[55] + neoKeyArray[56] + neoKeyArray[57] + neoKeyArray[58] + neoKeyArray[59] + "," + neoKeyArray[60] + neoKeyArray[61] + neoKeyArray[62] + neoKeyArray[63] + neoKeyArray[64] + "," + neoKeyArray[65] + neoKeyArray[66]);
		}
		return neoKeyArray;
	}

	public int GetCVTriggerValue(int hand)
	{
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref neotriggerV, javaCVClass, "getControllerKeyEvent", hand);
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog CVTriggerValue " + neotriggerV[7]);
		}
		return neotriggerV[7];
	}

	public void AutoConnectHbController(int scanTimeMs)
	{
		PLOG.I("PvrLog AutoConnectHbController" + scanTimeMs);
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "autoConnectHbController", scanTimeMs, gameobjname);
	}

	public void StartControllerThread(int headSensorState, int handSensorState)
	{
		if (BoundarySystem.UPvr_IsBoundaryEnable())
		{
			headSensorState = 1;
			handSensorState = 1;
		}
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "startControllerThread", headSensorState, handSensorState);
		UnityEngine.Debug.Log("PvrLog StartControllerThread" + headSensorState + handSensorState);
	}

	public void StopControllerThread(int headSensorState, int handSensorState)
	{
		if (BoundarySystem.UPvr_IsBoundaryEnable())
		{
			headSensorState = 1;
			handSensorState = 1;
		}
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "stopControllerThread", headSensorState, handSensorState);
		UnityEngine.Debug.Log("PvrLog StopControllerThread" + headSensorState + handSensorState);
	}

	public void SetUnityVersionToJar(string version)
	{
		if (trackingmode == 4 || trackingmode == 5 || trackingmode == 6)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "setUnityVersion", version);
		}
		UnityEngine.Debug.Log("PvrLog SetUnityVersionToJar" + version);
	}

	public Vector3 GetVelocity(int num)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref velocity, javaCVClass, "getControllerLinearVelocity", num);
		}
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog Velocity" + velocity[0] / 1000f + "," + velocity[1] / 1000f + "," + velocity[2] / 1000f);
		}
		return new Vector3(velocity[0] / 1000f, velocity[1] / 1000f, (0f - velocity[2]) / 1000f);
	}

	public Vector3 GetAngularVelocity(int num)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref angularVelocity, javaCVClass, "getControllerAngularVelocity", num);
		}
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref angularVelocity, javaHummingbirdClass, "getHbAngularVelocity");
		}
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog Gyro:" + angularVelocity[0] + "," + angularVelocity[1] + "," + angularVelocity[2]);
		}
		if (!float.IsNaN(angularVelocity[0]) && !float.IsNaN(angularVelocity[1]) && !float.IsNaN(angularVelocity[2]))
		{
			return new Vector3(angularVelocity[0], angularVelocity[1], angularVelocity[2]);
		}
		return new Vector3(0f, 0f, 0f);
	}

	public Vector3 GetAcceleration(int num)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref acceData, javaCVClass, "getControllerAcceleration", num);
		}
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref acceData, javaHummingbirdClass, "getHbAcceleration");
		}
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog Acce:" + acceData[0] / 1000f + acceData[1] / 1000f + acceData[2] / 1000f);
		}
		if (!float.IsNaN(acceData[0]) && !float.IsNaN(acceData[1]) && !float.IsNaN(acceData[2]))
		{
			return new Vector3(acceData[0] / 1000f, acceData[1] / 1000f, (0f - acceData[2]) / 1000f);
		}
		return new Vector3(0f, 0f, 0f);
	}

	public string GetConnectedDeviceMac()
	{
		string result = "";
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getConnectedDeviceMac");
		}
		PLOG.I("PvrLog ConnectedDeviceMac:" + result);
		return result;
	}

	public void VibrateNeo2Controller(float strength, int time, int hand)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "vibrateCV2ControllerStrength", strength, time, hand);
		}
		PLOG.I("PvrLog VibrateNeo2Controller:" + strength + time + hand);
	}

	public void VibrateController(float strength, int time, int hand)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "vibrateCV2ControllerStrength", strength, time, hand);
		}
		PLOG.I("PvrLog VibrateController:" + strength + time + hand);
	}

	public int GetMainControllerIndex()
	{
		int result = 0;
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getMainControllerIndex");
		}
		PLOG.I("PvrLog GetMainControllerIndex:" + result);
		return result;
	}

	public void SetMainController(int index)
	{
		PLOG.I("PvrLog SetMainController:" + index);
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "setMainController", index);
		}
	}

	public void ResetHeadSensorForController()
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "resetHeadSensorForController");
		}
		PLOG.I("PvrLog ResetHeadSensorForController:");
	}

	public void GetDeviceVersion(int deviceType)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "getDeviceVersion", deviceType);
		}
		PLOG.I("PvrLog GetDeviceVersion:" + deviceType);
	}

	public void GetControllerSnCode(int controllerSerialNum)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "getControllerSnCode", controllerSerialNum);
		}
		PLOG.I("PvrLog GetControllerSnCode:" + controllerSerialNum);
	}

	public void SetControllerUnbind(int controllerSerialNum)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "setControllerUnbind", controllerSerialNum);
		}
		PLOG.I("PvrLog SetControllerUnbind:" + controllerSerialNum);
	}

	public void SetStationRestart()
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "setStationRestart");
		}
		PLOG.I("PvrLog SetStationRestart");
	}

	public void StartStationOtaUpdate()
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "startStationOtaUpdate");
		}
		PLOG.I("PvrLog StartStationOtaUpdate");
	}

	public void StartControllerOtaUpdate(int mode, int controllerSerialNum)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "startControllerOtaUpdate", mode, controllerSerialNum);
		}
		PLOG.I("PvrLog StartControllerOtaUpdate" + mode + controllerSerialNum);
	}

	public void EnterPairMode(int controllerSerialNum)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "enterPairMode", controllerSerialNum);
		}
		PLOG.I("PvrLog EnterPairMode" + controllerSerialNum);
	}

	public void SetControllerShutdown(int controllerSerialNum)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "setControllerShutdown", controllerSerialNum);
		}
		PLOG.I("PvrLog SetControllerShutdown" + controllerSerialNum);
	}

	public int GetStationPairState()
	{
		int result = -1;
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getStationPairState");
		}
		PLOG.I("PvrLog StationPairState" + result);
		return result;
	}

	public int GetStationOtaUpdateProgress()
	{
		int result = -1;
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getStationOtaUpdateProgress");
		}
		PLOG.I("PvrLog StationOtaUpdateProgress" + result);
		return result;
	}

	public int GetControllerOtaUpdateProgress()
	{
		int result = -1;
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getControllerOtaUpdateProgress");
		}
		PLOG.I("PvrLog ControllerOtaUpdateProgress" + result);
		return result;
	}

	public void GetControllerVersionAndSN(int controllerSerialNum)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "getControllerVersionAndSN", controllerSerialNum);
		}
		PLOG.I("PvrLog GetControllerVersionAndSN" + controllerSerialNum);
	}

	public void GetControllerUniqueID()
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "getControllerUniqueID");
		}
		PLOG.I("PvrLog GetControllerUniqueID");
	}

	public void InterruptStationPairMode()
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "interruptStationPairMode");
		}
		PLOG.I("PvrLog InterruptStationPairMode");
	}

	public int GetControllerAbility(int controllerSerialNum)
	{
		int result = -1;
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getControllerAbility", controllerSerialNum);
		}
		PLOG.I("PvrLog ControllerAbility:" + result);
		return result;
	}

	public void SwitchHomeKey(bool state)
	{
		PLOG.I("PvrLog SwitchHomeKey:" + state);
		switchHomeKey = state;
	}

	public void SetBootReconnect()
	{
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "setBootReconnect");
		PLOG.I("PvrLog SetBootReconnect");
	}

	public int GetTemperature()
	{
		int result = -1;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getTemperature");
		PLOG.I("PvrLog Temperature:" + result);
		return result;
	}

	public int GetDeviceType()
	{
		int result = -1;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getDeviceType");
		PLOG.I("PvrLog DeviceType:" + result);
		return result;
	}

	public int GetControllerType()
	{
		int result = -1;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getControllerType");
		return result;
	}

	public string GetHummingBird2SN()
	{
		string result = "";
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getHummingBird2SN");
		PLOG.I("PvrLog HummingBird2SN:" + result);
		return result;
	}

	public string GetControllerVersion()
	{
		string result = "";
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getControllerVersion");
		PLOG.I("PvrLog ControllerVersion:" + result);
		return result;
	}

	public bool IsEnbleTrigger()
	{
		bool result = false;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "isEnbleTrigger");
		PLOG.I("PvrLog IsEnbleTrigger:" + result);
		return result;
	}

	public void StartCV2PairingMode(int devicetype)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "startCV2PairingMode", devicetype);
		}
		PLOG.I("PvrLog StartCV2PairingMode:" + devicetype);
	}

	public void StopCV2PairingMode(int devicetype)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "stopCV2PairingMode", devicetype);
		}
		PLOG.I("PvrLog StopCV2PairingMode:" + devicetype);
	}

	public int GetControllerBindingState(int id)
	{
		int result = -1;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getControllerBindingState", id);
		PLOG.I("PvrLog getControllerBindingState:" + result);
		return result;
	}

	public void setIsEnbleHomeKey(bool state)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "setIsEnbleHomeKey", state);
		}
		PLOG.I("PvrLog setIsEnbleHomeKey:" + state);
	}

	public int getControllerSensorStatus(int id)
	{
		int result = -1;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getControllerSensorStatus", id);
		PLOG.I("PvrLog getControllerSensorStatus:" + result);
		return result;
	}

	public float[] GetControllerPredictSensorData(int controllerID, float predictTime)
	{
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "SetHeadDataAndPreTime", Pvr_UnitySDKManager.SDK.headData, predictTime);
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref predictData, javaCVClass, "getControllerSensorStateWithHeadDataAndPreTime", controllerID);
		return predictData;
	}
}
public class Pvr_ControllerManager : MonoBehaviour
{
	public delegate void PvrServiceStartSuccess();

	public delegate void PvrControllerStateChanged(string data);

	public delegate void ChangeMainControllerCallBack(string index);

	public delegate void ChangeHandNessCallBack(string index);

	public delegate void SetHbServiceBindState();

	public delegate void ControllerThreadStartedCallback();

	public delegate void SetControllerServiceBindState();

	public delegate void ControllerStatusChange(string isconnect);

	public delegate void SetControllerAbility(string data);

	public delegate void SetControllerStateChanged(string data);

	public delegate void SetHbControllerMac(string mac);

	public delegate void ControllerDeviceVersionCallback(string data);

	public delegate void ControllerSnCodeCallback(string data);

	public delegate void ControllerUnbindCallback(string status);

	public delegate void ControllerStationStatusCallback(string status);

	public delegate void ControllerStationBusyCallback(string status);

	public delegate void ControllerOtaStartCodeCallback(string data);

	public delegate void ControllerDeviceVersionAndSNCallback(string data);

	public delegate void ControllerUniqueIDCallback(string data);

	public delegate void ControllerCombinedKeyUnbindCallback(string data);

	private static Pvr_ControllerManager instance;

	public static Pvr_ControllerLink controllerlink;

	private float cTime = 1f;

	private bool stopConnect;

	public Text toast;

	private bool controllerServicestate;

	private float disConnectTime;

	public bool LengthAdaptiveRay;

	private float[] sensorData = new float[28];

	private int[] keyData = new int[134];

	private float[] g2SensorData = new float[4];

	private int[] g2KeyData = new int[47];

	private int keyOffset;

	private int rotControllerMode = 1;

	public static Pvr_ControllerManager Instance
	{
		get
		{
			if (instance == null)
			{
				instance = UnityEngine.Object.FindObjectOfType<Pvr_ControllerManager>();
			}
			if (instance == null)
			{
				GameObject obj = new GameObject("GameObject");
				instance = obj.AddComponent<Pvr_ControllerManager>();
				obj.transform.localPosition = Vector3.zero;
			}
			return instance;
		}
	}

	public static event PvrServiceStartSuccess PvrServiceStartSuccessEvent;

	public static event PvrControllerStateChanged PvrControllerStateChangedEvent;

	public static event ChangeMainControllerCallBack ChangeMainControllerCallBackEvent;

	public static event ChangeHandNessCallBack ChangeHandNessCallBackEvent;

	public static event SetHbServiceBindState SetHbServiceBindStateEvent;

	public static event ControllerThreadStartedCallback ControllerThreadStartedCallbackEvent;

	public static event SetControllerServiceBindState SetControllerServiceBindStateEvent;

	public static event ControllerStatusChange ControllerStatusChangeEvent;

	public static event SetControllerAbility SetControllerAbilityEvent;

	public static event SetControllerStateChanged SetControllerStateChangedEvent;

	public static event SetHbControllerMac SetHbControllerMacEvent;

	public static event ControllerDeviceVersionCallback ControllerDeviceVersionCallbackEvent;

	public static event ControllerSnCodeCallback ControllerSnCodeCallbackEvent;

	public static event ControllerUnbindCallback ControllerUnbindCallbackEvent;

	public static event ControllerStationStatusCallback ControllerStationStatusCallbackEvent;

	public static event ControllerStationBusyCallback ControllerStationBusyCallbackEvent;

	public static event ControllerOtaStartCodeCallback ControllerOtaStartCodeCallbackEvent;

	public static event ControllerDeviceVersionAndSNCallback ControllerDeviceVersionAndSNCallbackEvent;

	public static event ControllerUniqueIDCallback ControllerUniqueIDCallbackEvent;

	public static event ControllerCombinedKeyUnbindCallback ControllerCombinedKeyUnbindCallbackEvent;

	private void Awake()
	{
		if (instance == null)
		{
			instance = this;
		}
		if (instance != this)
		{
			PLOG.E("instance object should be a singleton. (" + base.transform.parent.name + ")");
			return;
		}
		if (controllerlink == null)
		{
			controllerlink = new Pvr_ControllerLink(base.gameObject.name);
			return;
		}
		controllerlink.SetGameObjectToJar(base.gameObject.name);
		BindService();
	}

	private void Start()
	{
		if (controllerlink.trackingmode < 2)
		{
			Invoke("CheckControllerService", 10f);
		}
		Render.UPvr_GetIntConfig(23, ref rotControllerMode);
	}

	private void Update()
	{
		if (controllerlink.neoserviceStarted)
		{
			sensorData = controllerlink.GetControllerSensorData();
			keyData = controllerlink.GetControllerKeyData();
			if (controllerlink.controller0Connected)
			{
				if (Pvr_UnitySDKManager.SDK.ShowVideoSeethrough)
				{
					sensorData[2] = 0f - sensorData[2];
					sensorData[3] = 0f - sensorData[3];
					controllerlink.Controller0.Rotation.Set(sensorData[0], sensorData[1], sensorData[2], sensorData[3]);
					if (rotControllerMode == 0)
					{
						controllerlink.Controller0.Rotation *= Quaternion.Euler(34f, 0f, 0f);
					}
					controllerlink.Controller0.Position.Set(sensorData[4] / 1000f, sensorData[5] / 1000f, (0f - sensorData[6]) / 1000f);
				}
				else
				{
					controllerlink.Controller0.Rotation.Set(sensorData[7], sensorData[8], sensorData[9], sensorData[10]);
					if (rotControllerMode == 0)
					{
						controllerlink.Controller0.Rotation *= Quaternion.Euler(34f, 0f, 0f);
					}
					controllerlink.Controller0.Position.Set(sensorData[11] / 1000f, sensorData[12] / 1000f, (0f - sensorData[13]) / 1000f);
				}
				if (!controllerlink.Controller0.isShowBoundary)
				{
					if (controllerlink.getControllerSensorStatus(0) == 0)
					{
						Sensor.UPvr_SetReinPosition(sensorData[0], sensorData[1], sensorData[2], sensorData[3], sensorData[4], sensorData[5], sensorData[6], 0, valid: false, 0);
					}
					else
					{
						controllerlink.Controller0.isShowBoundary = true;
						Sensor.UPvr_SetReinPosition(sensorData[0], sensorData[1], sensorData[2], sensorData[3], sensorData[4], sensorData[5], sensorData[6], 0, valid: true, Convert.ToInt32(Convert.ToString(keyData[35]) + Convert.ToString(keyData[15]) + "00", 2));
					}
				}
				else
				{
					Sensor.UPvr_SetReinPosition(sensorData[0], sensorData[1], sensorData[2], sensorData[3], sensorData[4], sensorData[5], sensorData[6], 0, valid: true, Convert.ToInt32(Convert.ToString(keyData[35]) + Convert.ToString(keyData[15]) + "00", 2));
				}
				TransformData(controllerlink.Controller0, 0, keyData);
			}
			else
			{
				Sensor.UPvr_SetReinPosition(sensorData[0], sensorData[1], sensorData[2], sensorData[3], sensorData[4], sensorData[5], sensorData[6], 0, valid: false, 0);
			}
			if (controllerlink.controller1Connected)
			{
				if (Pvr_UnitySDKManager.SDK.ShowVideoSeethrough)
				{
					sensorData[16] = 0f - sensorData[16];
					sensorData[17] = 0f - sensorData[17];
					controllerlink.Controller1.Rotation.Set(sensorData[14], sensorData[15], sensorData[16], sensorData[17]);
					if (rotControllerMode == 0)
					{
						controllerlink.Controller1.Rotation *= Quaternion.Euler(34f, 0f, 0f);
					}
					controllerlink.Controller1.Position.Set(sensorData[18] / 1000f, sensorData[19] / 1000f, (0f - sensorData[20]) / 1000f);
				}
				else
				{
					controllerlink.Controller1.Rotation.Set(sensorData[21], sensorData[22], sensorData[23], sensorData[24]);
					if (rotControllerMode == 0)
					{
						controllerlink.Controller1.Rotation *= Quaternion.Euler(34f, 0f, 0f);
					}
					controllerlink.Controller1.Position.Set(sensorData[25] / 1000f, sensorData[26] / 1000f, (0f - sensorData[27]) / 1000f);
				}
				if (!controllerlink.Controller1.isShowBoundary)
				{
					if (controllerlink.getControllerSensorStatus(1) == 0)
					{
						Sensor.UPvr_SetReinPosition(sensorData[14], sensorData[15], sensorData[16], sensorData[17], sensorData[18], sensorData[19], sensorData[20], 1, valid: false, 0);
					}
					else
					{
						controllerlink.Controller1.isShowBoundary = true;
						Sensor.UPvr_SetReinPosition(sensorData[14], sensorData[15], sensorData[16], sensorData[17], sensorData[18], sensorData[19], sensorData[20], 1, valid: true, Convert.ToInt32(Convert.ToString(keyData[102]) + Convert.ToString(keyData[82]) + "00", 2));
					}
				}
				else
				{
					Sensor.UPvr_SetReinPosition(sensorData[14], sensorData[15], sensorData[16], sensorData[17], sensorData[18], sensorData[19], sensorData[20], 1, valid: true, Convert.ToInt32(Convert.ToString(keyData[102]) + Convert.ToString(keyData[82]) + "00", 2));
				}
				TransformData(controllerlink.Controller1, 1, keyData);
			}
			else
			{
				Sensor.UPvr_SetReinPosition(sensorData[14], sensorData[15], sensorData[16], sensorData[17], sensorData[18], sensorData[19], sensorData[20], 1, valid: false, 0);
			}
		}
		if (controllerlink.goblinserviceStarted && controllerlink.controller0Connected)
		{
			g2SensorData = controllerlink.GetHBControllerPoseData();
			controllerlink.Controller0.Rotation.Set(g2SensorData[0], g2SensorData[1], g2SensorData[2], g2SensorData[3]);
			g2KeyData = controllerlink.GetHBControllerKeyData();
			TransformData(controllerlink.Controller0, 0, g2KeyData);
		}
		SetSystemKey();
	}

	private void OnApplicationPause(bool pause)
	{
		int headSensorState = ((!Pvr_UnitySDKManager.SDK.HmdOnlyrot) ? 1 : 0);
		int handSensorState = ((!Pvr_UnitySDKManager.SDK.ControllerOnlyrot) ? 1 : 0);
		if (pause)
		{
			if (controllerlink.neoserviceStarted)
			{
				controllerlink.SetGameObjectToJar("");
				controllerlink.StopControllerThread(headSensorState, handSensorState);
			}
			if (controllerlink.goblinserviceStarted)
			{
				controllerlink.StopReceiver();
			}
			return;
		}
		controllerlink.Controller0 = new ControllerHand();
		controllerlink.Controller1 = new ControllerHand();
		if (controllerlink.neoserviceStarted)
		{
			controllerlink.SetGameObjectToJar(base.gameObject.name);
			controllerlink.SetUnityVersionToJar("2.8.10.4");
			controllerlink.StartControllerThread(headSensorState, handSensorState);
		}
		if (controllerlink.goblinserviceStarted)
		{
			controllerlink.StartReceiver();
			controllerlink.controller0Connected = GetControllerConnectionState(0) == 1;
			controllerlink.controllerType = controllerlink.GetControllerType();
			controllerlink.handness = (Pvr_Controller.UserHandNess)controllerlink.getHandness();
			if (Pvr_ControllerManager.PvrServiceStartSuccessEvent != null)
			{
				Pvr_ControllerManager.PvrServiceStartSuccessEvent();
			}
		}
	}

	private void OnDestroy()
	{
		controllerlink.UnBindService();
		Sensor.UPvr_SetReinPosition(0f, 0f, 0f, 1f, 0f, 0f, 0f, 0, valid: false, 0);
		Sensor.UPvr_SetReinPosition(0f, 0f, 0f, 1f, 0f, 0f, 0f, 1, valid: false, 0);
	}

	private void OnApplicationQuit()
	{
		int headSensorState = ((!Pvr_UnitySDKManager.SDK.HmdOnlyrot) ? 1 : 0);
		int handSensorState = ((!Pvr_UnitySDKManager.SDK.ControllerOnlyrot) ? 1 : 0);
		if (controllerlink.neoserviceStarted)
		{
			controllerlink.SetGameObjectToJar("");
			controllerlink.StopControllerThread(headSensorState, handSensorState);
		}
	}

	public Vector3 GetAngularVelocity(int num)
	{
		if (controllerlink != null)
		{
			return controllerlink.GetAngularVelocity(num);
		}
		return new Vector3(0f, 0f, 0f);
	}

	public Vector3 GetAcceleration(int num)
	{
		if (controllerlink != null)
		{
			return controllerlink.GetAcceleration(num);
		}
		return new Vector3(0f, 0f, 0f);
	}

	public void BindService()
	{
		if (controllerlink != null)
		{
			controllerlink.BindService();
		}
	}

	public void StartScan()
	{
		if (controllerlink != null)
		{
			controllerlink.StartScan();
		}
	}

	public void StopScan()
	{
		if (controllerlink != null)
		{
			controllerlink.StopScan();
		}
	}

	public void ResetController(int num)
	{
		if (controllerlink != null)
		{
			controllerlink.ResetController(num);
		}
	}

	public static int GetControllerConnectionState(int num)
	{
		return controllerlink.GetControllerConnectionState(num);
	}

	public void ConnectBLE()
	{
		if (controllerlink != null)
		{
			controllerlink.ConnectBLE();
		}
	}

	public void DisConnectBLE()
	{
		if (controllerlink != null)
		{
			controllerlink.DisConnectBLE();
		}
	}

	public void SetBinPath(string path, bool isAsset)
	{
		if (controllerlink != null)
		{
			controllerlink.setBinPath(path, isAsset);
		}
	}

	public void StartUpgrade()
	{
		if (controllerlink != null)
		{
			controllerlink.StartUpgrade();
		}
	}

	public static string GetBLEImageType()
	{
		return controllerlink.GetBLEImageType();
	}

	public static long GetBLEVersion()
	{
		return controllerlink.GetBLEVersion();
	}

	public static string GetFileImageType()
	{
		return controllerlink.GetFileImageType();
	}

	public static long GetFileVersion()
	{
		return controllerlink.GetFileVersion();
	}

	public static void AutoConnectHbController(int scans)
	{
		if (controllerlink != null)
		{
			controllerlink.AutoConnectHbController(scans);
		}
	}

	public static string GetConnectedDeviceMac()
	{
		string result = "";
		if (controllerlink != null)
		{
			result = controllerlink.GetConnectedDeviceMac();
		}
		return result;
	}

	public void setHbControllerMac(string mac)
	{
		PLOG.I("PvrLog HBMacRSSI" + mac);
		controllerlink.hummingBirdMac = mac.Substring(0, 17);
		controllerlink.hummingBirdRSSI = Convert.ToInt16(mac.Remove(0, 18));
		if (Pvr_ControllerManager.SetHbControllerMacEvent != null)
		{
			Pvr_ControllerManager.SetHbControllerMacEvent(mac.Substring(0, 17));
		}
	}

	public int GetControllerRSSI()
	{
		return controllerlink.hummingBirdRSSI;
	}

	public void setHbServiceBindState(string state)
	{
		PLOG.I("PvrLog HBBindCallBack" + state);
		controllerServicestate = true;
		if (Convert.ToInt16(state) == 0)
		{
			Invoke("BindService", 0.5f);
			controllerlink.goblinserviceStarted = false;
		}
		else if (Convert.ToInt16(state) == 1)
		{
			controllerlink.goblinserviceStarted = true;
			controllerlink.controller0Connected = GetControllerConnectionState(0) == 1;
			controllerlink.controllerType = controllerlink.GetControllerType();
			controllerlink.handness = (Pvr_Controller.UserHandNess)controllerlink.getHandness();
			if (Pvr_ControllerManager.SetHbServiceBindStateEvent != null)
			{
				Pvr_ControllerManager.SetHbServiceBindStateEvent();
			}
			if (Pvr_ControllerManager.PvrServiceStartSuccessEvent != null)
			{
				Pvr_ControllerManager.PvrServiceStartSuccessEvent();
			}
		}
	}

	public void setControllerServiceBindState(string state)
	{
		PLOG.I("PvrLog CVBindCallBack" + state);
		if (Convert.ToInt16(state) == 0)
		{
			Invoke("BindService", 0.5f);
			controllerlink.neoserviceStarted = false;
		}
		else if (Convert.ToInt16(state) == 1)
		{
			controllerlink.SetUnityVersionToJar("2.8.10.4");
			controllerlink.neoserviceStarted = true;
			int headSensorState = ((!Pvr_UnitySDKManager.SDK.HmdOnlyrot) ? 1 : 0);
			int handSensorState = ((!Pvr_UnitySDKManager.SDK.ControllerOnlyrot) ? 1 : 0);
			controllerlink.StartControllerThread(headSensorState, handSensorState);
			if (Pvr_ControllerManager.SetControllerServiceBindStateEvent != null)
			{
				Pvr_ControllerManager.SetControllerServiceBindStateEvent();
			}
		}
	}

	public void setHbControllerConnectState(string isconnect)
	{
		PLOG.I("PvrLog HBControllerConnect" + isconnect);
		controllerlink.controller0Connected = Convert.ToInt16(isconnect) == 1;
		if (!controllerlink.controller0Connected)
		{
			controllerlink.Controller0 = new ControllerHand();
		}
		else
		{
			ResetController(0);
			controllerlink.controllerType = controllerlink.GetControllerType();
			controllerlink.handness = (Pvr_Controller.UserHandNess)controllerlink.getHandness();
		}
		stopConnect = false;
		if (Pvr_ControllerManager.ControllerStatusChangeEvent != null)
		{
			Pvr_ControllerManager.ControllerStatusChangeEvent(isconnect);
		}
		if (Pvr_ControllerManager.PvrControllerStateChangedEvent != null)
		{
			Pvr_ControllerManager.PvrControllerStateChangedEvent(isconnect);
		}
	}

	public void setControllerStateChanged(string state)
	{
		PLOG.I("PvrLog CVControllerStateChanged" + state);
		int num = Convert.ToInt16(state.Substring(0, 1));
		if (num == 0)
		{
			controllerlink.controller0Connected = Convert.ToBoolean(Convert.ToInt16(state.Substring(2, 1)));
			if (!controllerlink.controller0Connected)
			{
				controllerlink.Controller0 = new ControllerHand();
				controllerlink.Controller0.Position = new Vector3(0f, Pvr_UnitySDKSensor.Instance.HeadPose.Position.y, 0f) + new Vector3(-0.1f, -0.3f, 0.3f);
			}
		}
		else
		{
			controllerlink.controller1Connected = Convert.ToBoolean(Convert.ToInt16(state.Substring(2, 1)));
			if (!controllerlink.controller1Connected)
			{
				controllerlink.Controller1 = new ControllerHand();
				controllerlink.Controller1.Position = new Vector3(0f, Pvr_UnitySDKSensor.Instance.HeadPose.Position.y, 0f) + new Vector3(0.1f, -0.3f, 0.3f);
			}
		}
		if (Convert.ToBoolean(Convert.ToInt16(state.Substring(2, 1))))
		{
			controllerlink.controllerType = controllerlink.GetControllerType();
			controllerlink.ResetController(num);
		}
		controllerlink.handness = (Pvr_Controller.UserHandNess)controllerlink.getHandness();
		controllerlink.mainHandID = controllerlink.GetMainControllerIndex();
		if (Pvr_ControllerManager.SetControllerStateChangedEvent != null)
		{
			Pvr_ControllerManager.SetControllerStateChangedEvent(state);
		}
		if (Pvr_ControllerManager.PvrControllerStateChangedEvent != null)
		{
			Pvr_ControllerManager.PvrControllerStateChangedEvent(state);
		}
	}

	public void setControllerAbility(string data)
	{
		PLOG.I("PvrLog setControllerAbility" + data);
		if (Pvr_ControllerManager.SetControllerAbilityEvent != null)
		{
			Pvr_ControllerManager.SetControllerAbilityEvent(data);
		}
	}

	public void controllerThreadStartedCallback()
	{
		PLOG.I("PvrLog ThreadStartSuccess");
		GetCVControllerState();
		if (Pvr_ControllerManager.ControllerThreadStartedCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerThreadStartedCallbackEvent();
		}
		if (Pvr_ControllerManager.PvrServiceStartSuccessEvent != null)
		{
			Pvr_ControllerManager.PvrServiceStartSuccessEvent();
		}
	}

	public void controllerDeviceVersionCallback(string data)
	{
		PLOG.I("PvrLog VersionCallBack" + data);
		if (Pvr_ControllerManager.ControllerDeviceVersionCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerDeviceVersionCallbackEvent(data);
		}
	}

	public void controllerSnCodeCallback(string data)
	{
		PLOG.I("PvrLog SNCodeCallBack" + data);
		if (Pvr_ControllerManager.ControllerSnCodeCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerSnCodeCallbackEvent(data);
		}
	}

	public void controllerUnbindCallback(string status)
	{
		PLOG.I("PvrLog ControllerUnBindCallBack" + status);
		if (Pvr_ControllerManager.ControllerUnbindCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerUnbindCallbackEvent(status);
		}
	}

	public void controllerStationStatusCallback(string status)
	{
		PLOG.I("PvrLog StationStatusCallBack" + status);
		if (Pvr_ControllerManager.ControllerStationStatusCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerStationStatusCallbackEvent(status);
		}
	}

	public void controllerStationBusyCallback(string status)
	{
		PLOG.I("PvrLog StationBusyCallBack" + status);
		if (Pvr_ControllerManager.ControllerStationBusyCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerStationBusyCallbackEvent(status);
		}
	}

	public void controllerOTAStartCodeCallback(string data)
	{
		PLOG.I("PvrLog OTAUpdateCallBack" + data);
		if (Pvr_ControllerManager.ControllerOtaStartCodeCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerOtaStartCodeCallbackEvent(data);
		}
	}

	public void controllerDeviceVersionAndSNCallback(string data)
	{
		PLOG.I("PvrLog DeviceVersionAndSNCallback" + data);
		if (Pvr_ControllerManager.ControllerDeviceVersionAndSNCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerDeviceVersionAndSNCallbackEvent(data);
		}
	}

	public void controllerUniqueIDCallback(string data)
	{
		PLOG.I("PvrLog controllerUniqueIDCallback" + data);
		if (Pvr_ControllerManager.ControllerUniqueIDCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerUniqueIDCallbackEvent(data);
		}
	}

	public void controllerCombinedKeyUnbindCallback(string controllerSerialNum)
	{
		if (Pvr_ControllerManager.ControllerCombinedKeyUnbindCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerCombinedKeyUnbindCallbackEvent(controllerSerialNum);
		}
	}

	public void setupdateFailed()
	{
	}

	public void setupdateSuccess()
	{
	}

	public void setupdateProgress(string progress)
	{
	}

	public void setHbAutoConnectState(string state)
	{
		PLOG.I("PvrLog HBAutoConnectState" + state);
		controllerServicestate = true;
		if (Convert.ToInt16(state) == 0 && GetControllerConnectionState(0) == 0)
		{
			ShowToast(2);
		}
		if (Convert.ToInt16(state) == 2)
		{
			ShowToast(3);
		}
	}

	public void callbackControllerServiceState(string state)
	{
		PLOG.I("PvrLog HBServiceState" + state);
		controllerServicestate = true;
		if (Convert.ToInt16(state) == 0)
		{
			ShowToast(0);
		}
		if (Convert.ToInt16(state) == 1)
		{
			BindService();
		}
		if (Convert.ToInt16(state) == 2)
		{
			ShowToast(1);
		}
	}

	public void changeMainControllerCallback(string index)
	{
		PLOG.I("PvrLog MainControllerCallBack" + index);
		controllerlink.mainHandID = Convert.ToInt16(index);
		if (Pvr_ControllerManager.ChangeMainControllerCallBackEvent != null)
		{
			Pvr_ControllerManager.ChangeMainControllerCallBackEvent(index);
		}
	}

	public void changeHandnessCallback(string index)
	{
		PLOG.I("PvrLog changeHandnessCallback" + index);
		controllerlink.handness = (Pvr_Controller.UserHandNess)Convert.ToInt16(index);
		if (Pvr_ControllerManager.ChangeHandNessCallBackEvent != null)
		{
			Pvr_ControllerManager.ChangeHandNessCallBackEvent(index);
		}
	}

	private void ShowToast(int type)
	{
		if (toast != null)
		{
			switch (type)
			{
			case 0:
				toast.text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("servicetip0");
				Invoke("HideToast", 5f);
				break;
			case 1:
				toast.text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("servicetip1");
				Invoke("HideToast", 5f);
				break;
			case 2:
				toast.text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("servicetip2");
				AutoConnectHbController(6000);
				Invoke("HideToast", 5f);
				break;
			case 3:
				toast.text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("servicetip3");
				AutoConnectHbController(6000);
				Invoke("HideToast", 5f);
				break;
			case 4:
				toast.text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("servicetip4");
				Invoke("HideToast", 10f);
				break;
			}
		}
	}

	private void HideToast()
	{
		if (toast != null)
		{
			toast.text = "";
		}
	}

	private void CheckControllerService()
	{
		if (!controllerServicestate)
		{
			ShowToast(4);
		}
	}

	private void GetCVControllerState()
	{
		int controllerConnectionState = GetControllerConnectionState(0);
		int controllerConnectionState2 = GetControllerConnectionState(1);
		PLOG.I("PvrLog CVconnect" + controllerConnectionState + controllerConnectionState2);
		if (controllerConnectionState == -1 && controllerConnectionState2 == -1)
		{
			Invoke("GetCVControllerState", 0.02f);
		}
		if (controllerConnectionState != -1 && controllerConnectionState2 != -1)
		{
			controllerlink.controller0Connected = controllerConnectionState == 1;
			controllerlink.controller1Connected = controllerConnectionState2 == 1;
			if (!controllerlink.controller0Connected && controllerlink.controller1Connected && controllerlink.GetMainControllerIndex() == 0)
			{
				Controller.UPvr_SetMainHandNess(1);
			}
			if (controllerlink.controller0Connected || controllerlink.controller1Connected)
			{
				controllerlink.controllerType = controllerlink.GetControllerType();
			}
			controllerlink.mainHandID = controllerlink.GetMainControllerIndex();
			controllerlink.handness = (Pvr_Controller.UserHandNess)controllerlink.getHandness();
		}
	}

	private void SetSystemKey()
	{
		if (controllerlink.switchHomeKey && (Controller.UPvr_GetKeyLongPressed(0, Pvr_KeyCode.HOME) || Controller.UPvr_GetKeyLongPressed(1, Pvr_KeyCode.HOME)))
		{
			if (Pvr_UnitySDKManager.SDK.HmdOnlyrot)
			{
				Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 0);
			}
			else if (controllerlink.trackingmode == 0 || controllerlink.trackingmode == 1)
			{
				Pvr_UnitySDKSensor.Instance.ResetUnitySDKSensor();
			}
			else
			{
				Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 1);
			}
			if (Pvr_UnitySDKManager.SDK.ControllerOnlyrot || (controllerlink.controller0Connected && Controller.UPvr_GetControllerPOS(0).Equals(Vector3.zero)) || (controllerlink.controller1Connected && Controller.UPvr_GetControllerPOS(1).Equals(Vector3.zero)))
			{
				if (Controller.UPvr_GetKeyLongPressed(0, Pvr_KeyCode.HOME))
				{
					ResetController(0);
				}
				if (Controller.UPvr_GetKeyLongPressed(1, Pvr_KeyCode.HOME))
				{
					ResetController(1);
				}
			}
		}
		if (controllerlink.picoDevice)
		{
			if (controllerlink.switchHomeKey && (Controller.UPvr_GetKeyClick(0, Pvr_KeyCode.HOME) || (Controller.UPvr_GetKeyClick(1, Pvr_KeyCode.HOME) && !stopConnect)))
			{
				controllerlink.RebackToLauncher();
			}
			if (Controller.UPvr_GetKeyClick(0, Pvr_KeyCode.VOLUMEUP) || Controller.UPvr_GetKeyClick(1, Pvr_KeyCode.VOLUMEUP))
			{
				controllerlink.TurnUpVolume();
			}
			if (Controller.UPvr_GetKeyClick(0, Pvr_KeyCode.VOLUMEDOWN) || Controller.UPvr_GetKeyClick(1, Pvr_KeyCode.VOLUMEDOWN))
			{
				controllerlink.TurnDownVolume();
			}
			if (!Controller.UPvr_GetKey(0, Pvr_KeyCode.VOLUMEUP) && !Controller.UPvr_GetKey(0, Pvr_KeyCode.VOLUMEDOWN) && !Controller.UPvr_GetKey(1, Pvr_KeyCode.VOLUMEUP) && !Controller.UPvr_GetKey(1, Pvr_KeyCode.VOLUMEDOWN))
			{
				cTime = 1f;
			}
			if (Controller.UPvr_GetKey(0, Pvr_KeyCode.VOLUMEUP) || Controller.UPvr_GetKey(1, Pvr_KeyCode.VOLUMEUP))
			{
				cTime -= Time.deltaTime;
				if (cTime <= 0f)
				{
					cTime = 0.2f;
					controllerlink.TurnUpVolume();
				}
			}
			if (!Controller.UPvr_GetKey(0, Pvr_KeyCode.HOME) && !Controller.UPvr_GetKey(1, Pvr_KeyCode.HOME) && (Controller.UPvr_GetKey(0, Pvr_KeyCode.VOLUMEDOWN) || Controller.UPvr_GetKey(1, Pvr_KeyCode.VOLUMEDOWN)))
			{
				cTime -= Time.deltaTime;
				if (cTime <= 0f)
				{
					cTime = 0.2f;
					controllerlink.TurnDownVolume();
				}
			}
		}
		if (controllerlink.goblinserviceStarted && Controller.UPvr_GetKey(0, Pvr_KeyCode.HOME) && Controller.UPvr_GetKey(0, Pvr_KeyCode.VOLUMEDOWN) && !stopConnect)
		{
			disConnectTime += Time.deltaTime;
			if ((double)disConnectTime > 1.0)
			{
				DisConnectBLE();
				controllerlink.hummingBirdMac = "";
				stopConnect = true;
				disConnectTime = 0f;
			}
		}
	}

	private void TransformData(ControllerHand hand, int handId, int[] data)
	{
		keyOffset = ((handId == 1) ? 67 : 0);
		hand.TouchPadPosition.x = data[keyOffset];
		hand.TouchPadPosition.y = data[5 + keyOffset];
		TransSingleKey(hand.Home, 10 + keyOffset, data);
		TransSingleKey(hand.App, 15 + keyOffset, data);
		TransSingleKey(hand.Touch, 20 + keyOffset, data);
		TransSingleKey(hand.VolumeUp, 25 + keyOffset, data);
		TransSingleKey(hand.VolumeDown, 30 + keyOffset, data);
		TransSingleKey(hand.Trigger, 35 + keyOffset, data);
		if (controllerlink.goblinserviceStarted && !controllerlink.neoserviceStarted)
		{
			hand.TriggerNum = controllerlink.GetHBKeyValue();
		}
		if (!controllerlink.goblinserviceStarted && controllerlink.neoserviceStarted)
		{
			hand.TriggerNum = controllerlink.GetCVTriggerValue(handId);
		}
		hand.Battery = data[40 + keyOffset];
		if (data.Length == 47)
		{
			hand.SwipeDirection = (SwipeDirection)data[45];
			hand.TouchPadClick = (TouchPadClick)data[46];
		}
		else
		{
			switch (handId)
			{
			case 0:
				TransSingleKey(hand.X, 45 + keyOffset, data);
				TransSingleKey(hand.Y, 50 + keyOffset, data);
				TransSingleKey(hand.Left, 60 + keyOffset, data);
				break;
			case 1:
				TransSingleKey(hand.A, 45 + keyOffset, data);
				TransSingleKey(hand.B, 50 + keyOffset, data);
				TransSingleKey(hand.Right, 55 + keyOffset, data);
				break;
			}
			hand.SwipeDirection = (SwipeDirection)data[65 + keyOffset];
			hand.TouchPadClick = (TouchPadClick)data[66 + keyOffset];
		}
		hand.GripValue = controllerlink.GetNeo3GripValue(handId);
		TransformTouchData(hand, handId, controllerlink.GetNeo3TouchData(handId));
	}

	private void TransSingleKey(PvrControllerKey key, int beginIndex, int[] data)
	{
		key.State = Convert.ToBoolean(data[beginIndex]);
		key.PressedDown = Convert.ToBoolean(data[beginIndex + 1]);
		key.PressedUp = Convert.ToBoolean(data[beginIndex + 2]);
		key.LongPressed = Convert.ToBoolean(data[beginIndex + 3]);
		key.Click = Convert.ToBoolean(data[beginIndex + 4]);
	}

	private void TransformTouchData(ControllerHand hand, int handId, int[] data)
	{
		switch (handId)
		{
		case 0:
			TransSingleTouchValue(hand.X, 0, data);
			TransSingleTouchValue(hand.Y, 3, data);
			break;
		case 1:
			TransSingleTouchValue(hand.A, 0, data);
			TransSingleTouchValue(hand.B, 3, data);
			break;
		}
		TransSingleTouchValue(hand.Touch, 6, data);
		TransSingleTouchValue(hand.Trigger, 9, data);
		TransSingleTouchValue(hand.Thumbrest, 12, data);
	}

	private void TransSingleTouchValue(PvrControllerKey key, int beginIndex, int[] data)
	{
		key.Touch = Convert.ToBoolean(data[beginIndex]);
		key.TouchDown = Convert.ToBoolean(data[beginIndex + 1]);
		key.TouchUp = Convert.ToBoolean(data[beginIndex + 2]);
	}
}
public class Pvr_ControllerModuleInit : MonoBehaviour
{
	public ControllerVariety Variety;

	public bool IsCustomModel;

	[SerializeField]
	private GameObject dot;

	[SerializeField]
	private GameObject rayLine;

	[SerializeField]
	private GameObject controller;

	private bool moduleState = true;

	private void Awake()
	{
		Pvr_ControllerManager.PvrServiceStartSuccessEvent += ServiceStartSuccess;
		Pvr_ControllerManager.PvrControllerStateChangedEvent += ControllerStateChanged;
		Pvr_ControllerManager.ChangeMainControllerCallBackEvent += MainControllerIDChanged;
		if (Pvr_ControllerManager.Instance.LengthAdaptiveRay)
		{
			rayLine = base.transform.GetComponentInChildren<LineRenderer>(includeInactive: true).gameObject;
			rayLine.GetComponent<LineRenderer>().startWidth = 0.003f;
			rayLine.GetComponent<LineRenderer>().endWidth = 0.0015f;
		}
	}

	private void OnDestroy()
	{
		Pvr_ControllerManager.PvrServiceStartSuccessEvent -= ServiceStartSuccess;
		Pvr_ControllerManager.PvrControllerStateChangedEvent -= ControllerStateChanged;
		Pvr_ControllerManager.ChangeMainControllerCallBackEvent -= MainControllerIDChanged;
	}

	private void ServiceStartSuccess()
	{
		RefreshRay();
	}

	private void ControllerStateChanged(string data)
	{
		if (Pvr_ControllerManager.controllerlink.controller0Connected || Pvr_ControllerManager.controllerlink.controller1Connected)
		{
			moduleState = true;
			controller.transform.localScale = Vector3.one;
		}
		RefreshRay();
	}

	private void MainControllerIDChanged(string data)
	{
		RefreshRay();
	}

	private void RefreshRay()
	{
		if (Variety == ControllerVariety.Controller0)
		{
			StartCoroutine(ShowOrHideRay(0));
		}
		if (Variety == ControllerVariety.Controller1)
		{
			StartCoroutine(ShowOrHideRay(1));
		}
	}

	private IEnumerator ShowOrHideRay(int id)
	{
		yield return null;
		yield return null;
		if (moduleState)
		{
			bool active = Controller.UPvr_GetMainHandNess() == id && Controller.UPvr_GetControllerState(id) == ControllerState.Connected;
			dot.SetActive(active);
			rayLine.SetActive(active);
		}
	}

	public void ForceHideOrShow(bool state)
	{
		dot.SetActive(state);
		rayLine.SetActive(state);
		controller.transform.localScale = (state ? Vector3.one : Vector3.zero);
		moduleState = state;
	}

	public void UpdateRay()
	{
		if (!Pvr_ControllerManager.Instance.LengthAdaptiveRay)
		{
			return;
		}
		bool flag = false;
		flag = ((Pvr_ControllerManager.controllerlink.controller0Connected || Pvr_ControllerManager.controllerlink.controller1Connected) ? true : false);
		if (flag && rayLine != null && rayLine.gameObject.activeSelf)
		{
			if (Controller.UPvr_GetDeviceType() == 1)
			{
				rayLine.GetComponent<LineRenderer>().SetPosition(0, base.transform.TransformPoint(0f, 0f, 0.058f));
			}
			else
			{
				rayLine.GetComponent<LineRenderer>().SetPosition(0, base.transform.TransformPoint(0f, 0.009f, 0.055f));
			}
			rayLine.GetComponent<LineRenderer>().SetPosition(1, dot.transform.position);
		}
	}
}
public class Pvr_ControllerPower : MonoBehaviour
{
	[SerializeField]
	private Sprite power1;

	[SerializeField]
	private Sprite power2;

	[SerializeField]
	private Sprite power3;

	[SerializeField]
	private Sprite power4;

	[SerializeField]
	private Sprite power5;

	[HideInInspector]
	public ControllerVariety variety;

	[HideInInspector]
	public ControllerDevice currentDevice;

	private Image powerImage;

	private int powerValue;

	private float power;

	private void Start()
	{
		powerImage = base.transform.GetComponent<Image>();
		powerValue = -1;
		variety = base.transform.GetComponentInParent<Pvr_ControllerModuleInit>().Variety;
		currentDevice = base.transform.GetComponentInParent<Pvr_ControllerVisual>().currentDevice;
	}

	private void Update()
	{
		RefreshPower((variety != 0) ? 1 : 0);
	}

	private void RefreshPower(int hand)
	{
		if (powerValue != Controller.UPvr_GetControllerPower(hand))
		{
			switch (Controller.UPvr_GetControllerPower(hand))
			{
			case 1:
				powerImage.sprite = power1;
				powerImage.color = Color.red;
				break;
			case 2:
				powerImage.sprite = power2;
				powerImage.color = Color.white;
				break;
			case 3:
				powerImage.sprite = power3;
				powerImage.color = Color.white;
				break;
			case 4:
				powerImage.sprite = power4;
				powerImage.color = Color.white;
				break;
			case 5:
				powerImage.sprite = power5;
				powerImage.color = Color.white;
				break;
			default:
				powerImage.sprite = power1;
				powerImage.color = Color.white;
				break;
			}
			powerValue = Controller.UPvr_GetControllerPower(hand);
		}
	}
}
public class Pvr_ControllerVisual : MonoBehaviour
{
	public ControllerDevice currentDevice;

	public Texture2D m_idle;

	public Texture2D m_app;

	public Texture2D m_home;

	public Texture2D m_touchpad;

	public Texture2D m_volUp;

	public Texture2D m_volDn;

	public Texture2D m_trigger;

	public Texture2D m_a;

	public Texture2D m_b;

	public Texture2D m_x;

	public Texture2D m_y;

	public Texture2D m_grip;

	private Renderer controllerRenderMat;

	[HideInInspector]
	public ControllerVariety variety;

	private void Awake()
	{
		controllerRenderMat = GetComponent<Renderer>();
	}

	private void Start()
	{
		variety = base.transform.GetComponentInParent<Pvr_ControllerModuleInit>().Variety;
	}

	private void Update()
	{
		ChangeKeyEffects((variety != 0) ? 1 : 0);
	}

	private void ChangeKeyEffects(int hand)
	{
		if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.TOUCHPAD))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_touchpad);
		}
		else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.APP))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_app);
		}
		else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.HOME))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_home);
		}
		else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.VOLUMEUP))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_volUp);
		}
		else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.VOLUMEDOWN))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_volDn);
		}
		else if (Controller.UPvr_GetControllerTriggerValue(hand) > 0 || Controller.UPvr_GetKey(hand, Pvr_KeyCode.TRIGGER))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_trigger);
		}
		else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.X))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_x);
		}
		else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.Y))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_y);
		}
		else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.A))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_a);
		}
		else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.B))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_b);
		}
		else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.Left) || Controller.UPvr_GetKey(hand, Pvr_KeyCode.Right))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_grip);
		}
		else if (controllerRenderMat.material.GetTexture("_MainTex") != m_idle)
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_idle);
		}
	}
}
public class Pvr_ToolTips : MonoBehaviour
{
	public enum TipBtn
	{
		app,
		touchpad,
		home,
		volup,
		voldown,
		trigger,
		grip
	}

	private ControllerDevice currentDevice;

	private float tipsAlpha;

	public static Pvr_ToolTips tooltips;

	public void ChangeTipsText(TipBtn tip, string key)
	{
		switch (tip)
		{
		case TipBtn.app:
			base.transform.Find("apptip/btn/Text").GetComponent<Text>().text = key;
			break;
		case TipBtn.touchpad:
			base.transform.Find("touchtip/btn/Text").GetComponent<Text>().text = key;
			break;
		case TipBtn.home:
			base.transform.Find("hometip/btn/Text").GetComponent<Text>().text = key;
			break;
		case TipBtn.volup:
			base.transform.Find("volup/btn/Text").GetComponent<Text>().text = key;
			break;
		case TipBtn.voldown:
			base.transform.Find("voldown/btn/Text").GetComponent<Text>().text = key;
			break;
		case TipBtn.trigger:
			base.transform.Find("triggertip/btn/Text").GetComponent<Text>().text = key;
			break;
		case TipBtn.grip:
			base.transform.Find("grip/btn/Text").GetComponent<Text>().text = key;
			break;
		}
	}

	private void Awake()
	{
		tooltips = base.transform.GetComponent<Pvr_ToolTips>();
	}

	private void Update()
	{
		switch (currentDevice)
		{
		case ControllerDevice.Goblin:
		case ControllerDevice.G2:
			tipsAlpha = (330f - base.transform.parent.parent.parent.localRotation.eulerAngles.x) / 45f;
			if (base.transform.parent.parent.parent.localRotation.eulerAngles.x >= 270f && base.transform.parent.parent.parent.localRotation.eulerAngles.x <= 330f)
			{
				tipsAlpha = Mathf.Max(0f, tipsAlpha);
				tipsAlpha = ((tipsAlpha > 1f) ? 1f : tipsAlpha);
			}
			else
			{
				tipsAlpha = 0f;
			}
			GetComponent<CanvasGroup>().alpha = tipsAlpha;
			break;
		case ControllerDevice.Neo2:
		case ControllerDevice.Neo3:
			tipsAlpha = (330f - base.transform.parent.parent.parent.localRotation.eulerAngles.x) / 45f;
			if (base.transform.parent.parent.parent.localRotation.eulerAngles.x >= 270f && base.transform.parent.parent.parent.localRotation.eulerAngles.x <= 330f)
			{
				tipsAlpha = Mathf.Max(0f, tipsAlpha);
				tipsAlpha = ((tipsAlpha > 1f) ? 1f : tipsAlpha);
			}
			else
			{
				tipsAlpha = 0f;
			}
			GetComponent<CanvasGroup>().alpha = tipsAlpha;
			break;
		case ControllerDevice.Neo:
			break;
		}
	}

	private void LoadTextFromJson()
	{
		currentDevice = base.transform.GetComponentInParent<Pvr_ControllerVisual>().currentDevice;
		base.transform.Find("apptip/btn/Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("apptip");
		base.transform.Find("touchtip/btn/Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("touchtip");
		base.transform.Find("hometip/btn/Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("hometip");
		Transform transform = base.transform.Find("volup/btn/Text");
		if (transform != null)
		{
			transform.GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("voluptip");
		}
		Transform transform2 = base.transform.Find("voldown/btn/Text");
		if (transform2 != null)
		{
			transform2.GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("voldowntip");
		}
		Transform transform3 = base.transform.Find("triggertip/btn/Text");
		if (transform3 != null)
		{
			transform3.GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("triggertip");
		}
		Transform transform4 = base.transform.Find("grip/btn/Text");
		if (transform4 != null)
		{
			transform4.GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("griptip");
		}
	}

	public static void RefreshTips()
	{
		if (tooltips != null)
		{
			tooltips.LoadTextFromJson();
		}
	}
}
public class Pvr_TouchPadScroll : MonoBehaviour
{
	private ScrollRect scrollRect;

	private bool isHoving;

	private int mainHand;

	private SwipeDirection direction;

	private Vector2 currPos;

	private Vector2 tarPos;

	private float lerpSpeed = 10f;

	private Transform tranViewport;

	private float ignoreDis = 3f;

	private Vector2 lastTouchDownPos;

	private Vector2 lastTouchUpPos;

	private bool isTouching;

	private bool isClosed = true;

	private Vector2 vecOrigin = Vector2.zero;

	private Vector2 vecOriginNeo2 = new Vector2(128f, 128f);

	private void Awake()
	{
		scrollRect = base.gameObject.GetComponent<ScrollRect>();
		tranViewport = base.transform.Find("Viewport");
	}

	private void Update()
	{
		Process();
		UpdateTargetPos();
		UpdatePos();
	}

	private bool IsControllerConnect()
	{
		mainHand = Controller.UPvr_GetMainHandNess();
		if (mainHand == 0 && Pvr_ControllerManager.controllerlink.controller0Connected)
		{
			return true;
		}
		if (mainHand == 1 && Pvr_ControllerManager.controllerlink.controller1Connected)
		{
			return true;
		}
		return false;
	}

	private void UpdateTargetPos()
	{
		if (Controller.UPvr_GetKey(0, Pvr_KeyCode.TOUCHPAD) || Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.TOUCHPAD))
		{
			ResetParameter();
		}
		else if (isHoving)
		{
			if (Pvr_ControllerManager.controllerlink.GetControllerType() == 3)
			{
				ComputeTouchPos();
			}
			else
			{
				ComputeRockerPos();
			}
			if ((currPos - tarPos).sqrMagnitude <= 10f)
			{
				isClosed = true;
			}
		}
	}

	private void ComputeTouchPos()
	{
		mainHand = Controller.UPvr_GetMainHandNess();
		currPos = scrollRect.content.localPosition;
		Vector2 vector = vecOrigin;
		if (mainHand == 0 && Pvr_ControllerManager.controllerlink.controller0Connected)
		{
			vector = Controller.UPvr_GetTouchPadPosition(mainHand);
		}
		if (mainHand == 1 && Pvr_ControllerManager.controllerlink.controller1Connected)
		{
			vector = Controller.UPvr_GetTouchPadPosition(mainHand);
		}
		if ((vector - vecOrigin).sqrMagnitude >= 1f)
		{
			if (!isTouching)
			{
				lastTouchDownPos = vector;
				isTouching = true;
			}
			lastTouchUpPos.x = vector.x;
			if (Mathf.Abs(lastTouchUpPos.x - lastTouchDownPos.x) > ignoreDis)
			{
				Vector2 vector2 = new Vector2((lastTouchUpPos.x - lastTouchDownPos.x) * 10f, 0f);
				lastTouchDownPos.x = lastTouchUpPos.x;
				if (isClosed)
				{
					tarPos = currPos + vector2;
					isClosed = false;
				}
				else
				{
					tarPos += vector2;
				}
			}
		}
		else
		{
			lastTouchDownPos = vecOrigin;
			lastTouchUpPos = vecOrigin;
			isTouching = false;
			if ((double)scrollRect.horizontalScrollbar.value >= 0.999 || (double)scrollRect.horizontalScrollbar.value <= 0.0001)
			{
				isClosed = true;
			}
		}
	}

	private void ComputeRockerPos()
	{
		mainHand = Controller.UPvr_GetMainHandNess();
		currPos = scrollRect.content.localPosition;
		Vector2 vector = vecOriginNeo2;
		if (mainHand == 0 && Pvr_ControllerManager.controllerlink.controller0Connected)
		{
			vector = Controller.UPvr_GetTouchPadPosition(mainHand);
		}
		if (mainHand == 1 && Pvr_ControllerManager.controllerlink.controller1Connected)
		{
			vector = Controller.UPvr_GetTouchPadPosition(mainHand);
		}
		if (VerifyNeo2TouchValid(vector) && (vector - vecOriginNeo2).sqrMagnitude >= 1f)
		{
			if (!isTouching)
			{
				lastTouchDownPos = vector;
				isTouching = true;
			}
			lastTouchUpPos.x = vector.x;
			if (Mathf.Abs(lastTouchUpPos.x - lastTouchDownPos.x) > ignoreDis)
			{
				Vector2 vector2 = new Vector2((lastTouchUpPos.x - lastTouchDownPos.x) * 10f, 0f);
				lastTouchDownPos.x = lastTouchUpPos.x;
				if (isClosed)
				{
					tarPos = currPos + vector2;
					isClosed = false;
				}
				else
				{
					tarPos += vector2;
				}
			}
		}
		else
		{
			lastTouchDownPos = vecOriginNeo2;
			lastTouchUpPos = vecOriginNeo2;
			isTouching = false;
			if ((double)scrollRect.horizontalScrollbar.value >= 0.999 || (double)scrollRect.horizontalScrollbar.value <= 0.0001)
			{
				isClosed = true;
			}
		}
	}

	private bool VerifyNeo2TouchValid(Vector2 nowTouchPos)
	{
		if (nowTouchPos.x > vecOriginNeo2.x && nowTouchPos.x > lastTouchDownPos.x)
		{
			return true;
		}
		if (nowTouchPos.x < vecOriginNeo2.x && nowTouchPos.x < lastTouchDownPos.x)
		{
			return true;
		}
		return false;
	}

	private void UpdatePos()
	{
		if (Controller.UPvr_GetKey(0, Pvr_KeyCode.TOUCHPAD) || Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.TOUCHPAD))
		{
			ResetParameter();
		}
		else if (!isClosed && IsControllerConnect())
		{
			if ((double)scrollRect.horizontalScrollbar.value >= 0.9999 && tarPos.x <= currPos.x)
			{
				isClosed = true;
				return;
			}
			if ((double)scrollRect.horizontalScrollbar.value <= 0.0001 && tarPos.x >= currPos.x)
			{
				isClosed = true;
				return;
			}
			currPos.x = Mathf.Lerp(currPos.x, tarPos.x, lerpSpeed * Time.deltaTime);
			currPos.y = Mathf.Lerp(currPos.y, tarPos.y, lerpSpeed * Time.deltaTime);
			scrollRect.content.localPosition = currPos;
		}
	}

	private void ResetParameter()
	{
		currPos = scrollRect.content.localPosition;
		tarPos = scrollRect.content.localPosition;
		isClosed = true;
	}

	private void Process()
	{
		for (int i = 0; i < Pvr_InputModule.pointers.Count; i++)
		{
			Pvr_UIPointer pvr_UIPointer = Pvr_InputModule.pointers[i];
			if (pvr_UIPointer.gameObject.activeInHierarchy && pvr_UIPointer.enabled)
			{
				isHoving = IsHovering(pvr_UIPointer);
			}
		}
	}

	private bool IsHovering(Pvr_UIPointer pointer)
	{
		if (!IsControllerConnect())
		{
			return false;
		}
		foreach (GameObject item in pointer.pointerEventData.hovered)
		{
			if (FindTree(item.transform))
			{
				mainHand = Controller.UPvr_GetMainHandNess();
				if (mainHand == 0 && Pvr_ControllerManager.controllerlink.controller0Connected)
				{
					return true;
				}
				if (mainHand == 1 && Pvr_ControllerManager.controllerlink.controller1Connected)
				{
					return true;
				}
			}
		}
		return false;
	}

	private bool FindTree(Transform tran)
	{
		if (tran == base.transform || tran == tranViewport)
		{
			return true;
		}
		if (tran.IsChildOf(tranViewport))
		{
			return true;
		}
		return false;
	}
}
public class Pvr_TouchVisual : MonoBehaviour
{
	[HideInInspector]
	public ControllerDevice currentDevice;

	[HideInInspector]
	public ControllerVariety variety;

	private MeshRenderer touchRenderer;

	private void Start()
	{
		variety = base.transform.GetComponentInParent<Pvr_ControllerModuleInit>().Variety;
		currentDevice = GetComponentInParent<Pvr_ControllerVisual>().currentDevice;
		touchRenderer = GetComponent<MeshRenderer>();
	}

	private void Update()
	{
		ChangeEffects((variety != 0) ? 1 : 0);
	}

	private void ChangeEffects(int hand)
	{
		if (currentDevice == ControllerDevice.G2)
		{
			if (Controller.UPvr_IsTouching(0))
			{
				touchRenderer.enabled = true;
				base.transform.localPosition = new Vector3(1.3f - Controller.UPvr_GetTouchPadPosition(hand).x * 0.01f, 1.6f, -1.7f - Controller.UPvr_GetTouchPadPosition(hand).y * 0.01f);
			}
			else
			{
				touchRenderer.enabled = false;
			}
		}
	}
}
public class DemoController : MonoBehaviour
{
	public delegate void showLoadingEventHandler();

	private Callback callback;

	private GameObject msg;

	private Pvr_UnitySDKManager picoVrManager;

	private string currentOrderID;

	public GameObject loading;

	public GameObject BG;

	public GameObject InputPanel;

	public static showLoadingEventHandler showLoading;

	private void Awake()
	{
		UnityEngine.Debug.Log(loading.name);
		UnityEngine.Debug.Log(BG.name);
		showLoading = (showLoadingEventHandler)Delegate.Combine(showLoading, new showLoadingEventHandler(StopLoading));
		InputManager.doEnter = (InputManager.doEnterEventHandler)Delegate.Combine(InputManager.doEnter, new InputManager.doEnterEventHandler(DoPayByCode));
		currentOrderID = "";
	}

	private void Start()
	{
		msg = GameObject.Find("MassageInfo");
		InitDelegate();
		callback = new Callback();
		picoVrManager = GameObject.Find("Pvr_UnitySDK").GetComponent<Pvr_UnitySDKManager>();
		InputPanel.SetActive(value: false);
	}

	private void Update()
	{
		if (picoVrManager != null && (Input.GetKeyDown(KeyCode.Y) || Input.GetKeyDown(KeyCode.Joystick1Button2)))
		{
			UnityEngine.Debug.Log("update");
			Pvr_UnitySDKSensor.Instance.ResetUnitySDKSensor();
		}
		if (Input.GetKeyDown(KeyCode.Joystick1Button1) || Input.GetKeyDown(KeyCode.Escape))
		{
			if (InputPanel.activeInHierarchy)
			{
				InputPanel.SetActive(value: false);
			}
			else
			{
				Application.Quit();
			}
		}
	}

	private void InitDelegate()
	{
		foreach (string item in new ArrayList { "Login", "GetUserAPI", "PayOne", "PayCode", "QueryOrder" })
		{
			GameObject btnObj = GameObject.Find(item);
			btnObj.GetComponent<Button>().onClick.AddListener(delegate
			{
				OnClick(btnObj);
			});
		}
	}

	private void OnClick(GameObject btnObj)
	{
		switch (btnObj.name)
		{
		case "Login":
			StartLoading();
			LoginSDK.Login();
			break;
		case "PayOne":
			CommonDic.getInstance().setParameters("subject", "game");
			CommonDic.getInstance().setParameters("body", "gamePay");
			CommonDic.getInstance().setParameters("order_id", getRamdomTestOrderID());
			CommonDic.getInstance().setParameters("total", "1");
			CommonDic.getInstance().setParameters("goods_tag", "game");
			CommonDic.getInstance().setParameters("notify_url", "www.picovr.com");
			CommonDic.getInstance().setParameters("pay_code", "");
			StartLoading();
			PicoPaymentSDK.Pay(CommonDic.getInstance().PayOrderString());
			break;
		case "PayCode":
			InputPanel.SetActive(value: true);
			break;
		case "QueryOrder":
			StartLoading();
			PicoPaymentSDK.QueryOrder(currentOrderID);
			break;
		case "GetUserAPI":
			StartLoading();
			LoginSDK.GetUserAPI();
			break;
		}
	}

	public string getRamdomTestOrderID()
	{
		currentOrderID = (UnityEngine.Random.value * 65535f).ToString();
		return currentOrderID;
	}

	private void StartLoading()
	{
		loading.SetActive(value: true);
		BG.SetActive(value: true);
	}

	public void StopLoading()
	{
		if ((bool)loading && (bool)BG)
		{
			loading.SetActive(value: false);
			BG.SetActive(value: false);
		}
		else
		{
			UnityEngine.Debug.LogError("用户自定义，非演示demo");
		}
	}

	public void DoPayByCode()
	{
		CommonDic.getInstance().setParameters("subject", "game");
		CommonDic.getInstance().setParameters("body", "gamePay");
		CommonDic.getInstance().setParameters("order_id", getRamdomTestOrderID());
		CommonDic.getInstance().setParameters("total", "0");
		CommonDic.getInstance().setParameters("goods_tag", "game");
		CommonDic.getInstance().setParameters("notify_url", "www.picovr.com");
		CommonDic.getInstance().setParameters("pay_code", GameObject.Find("CodeText").GetComponent<Text>().text);
		UnityEngine.Debug.Log("商品码支付" + GameObject.Find("CodeText").GetComponent<Text>().text);
		StartLoading();
		GameObject.Find("CodeText").GetComponent<Text>().text = "";
		InputPanel.SetActive(value: false);
		PicoPaymentSDK.Pay(CommonDic.getInstance().PayOrderString());
	}

	private bool VerifyLocalToken()
	{
		if (CommonDic.getInstance().access_token.Equals(""))
		{
			GameObject.Find("MassageInfo").GetComponent<Text>().text = "{code:exception,msg:请先登录}";
			currentOrderID = "";
			StopLoading();
			return false;
		}
		return true;
	}
}
public class LoadingRatation : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
		base.gameObject.transform.Rotate(new Vector3(0f, 0f, -4f));
	}
}
public class InputManager : MonoBehaviour
{
	public delegate void doEnterEventHandler();

	public static doEnterEventHandler doEnter;

	private StringBuilder sb = new StringBuilder();

	private ArrayList btnsName = new ArrayList();

	private GameObject enter;

	private void Awake()
	{
		InitKeyBoard();
	}

	private void Start()
	{
	}

	private void Update()
	{
	}

	private void InitKeyBoard()
	{
		btnsName.Add("1");
		btnsName.Add("2");
		btnsName.Add("3");
		btnsName.Add("4");
		btnsName.Add("5");
		btnsName.Add("6");
		btnsName.Add("7");
		btnsName.Add("8");
		btnsName.Add("9");
		btnsName.Add("0");
		btnsName.Add("Q");
		btnsName.Add("W");
		btnsName.Add("E");
		btnsName.Add("R");
		btnsName.Add("T");
		btnsName.Add("Y");
		btnsName.Add("U");
		btnsName.Add("I");
		btnsName.Add("O");
		btnsName.Add("P");
		btnsName.Add("A");
		btnsName.Add("S");
		btnsName.Add("D");
		btnsName.Add("F");
		btnsName.Add("G");
		btnsName.Add("H");
		btnsName.Add("J");
		btnsName.Add("K");
		btnsName.Add("L");
		btnsName.Add("Z");
		btnsName.Add("X");
		btnsName.Add("C");
		btnsName.Add("V");
		btnsName.Add("B");
		btnsName.Add("N");
		btnsName.Add("M");
		btnsName.Add("Clear");
		btnsName.Add("Capslock");
		btnsName.Add("Enter");
		foreach (string item in btnsName)
		{
			GameObject btnObj = GameObject.Find(item);
			btnObj.GetComponent<Button>().onClick.AddListener(delegate
			{
				OnClick(btnObj);
			});
		}
		enter = GameObject.Find("Enter");
		enter.SetActive(sb.Length > 0);
	}

	private void OnClick(GameObject btnObj)
	{
		if (btnObj.name.Equals("Capslock"))
		{
			if (GameObject.Find("Q").transform.GetChild(0).GetComponent<Text>().text.Equals("Q"))
			{
				DoCapslock(IsUpper: true);
			}
			else
			{
				DoCapslock(IsUpper: false);
			}
		}
		else if (btnObj.name.Equals("Clear"))
		{
			GameObject.Find("CodeText").GetComponent<Text>().text = "";
			ClearBuffer();
		}
		else if (btnObj.name.Equals("Enter"))
		{
			ClearBuffer();
			doEnter();
		}
		else
		{
			EnterChar(btnObj.transform.GetChild(0).GetComponent<Text>().text);
		}
	}

	private void EnterChar(string s)
	{
		sb.Append(s);
		GameObject.Find("CodeText").GetComponent<Text>().text = sb.ToString();
		enter.SetActive(sb.Length > 0);
	}

	private void DoCapslock(bool IsUpper)
	{
		if (IsUpper)
		{
			foreach (string item in btnsName)
			{
				Text component = GameObject.Find(item).transform.GetChild(0).GetComponent<Text>();
				component.text = component.text.ToLower();
			}
			return;
		}
		foreach (string item2 in btnsName)
		{
			Text component2 = GameObject.Find(item2).transform.GetChild(0).GetComponent<Text>();
			component2.text = component2.text.ToUpper();
		}
	}

	private void ClearBuffer()
	{
		sb.Remove(0, sb.Length);
		enter.SetActive(sb.Length > 0);
	}
}
public class Callback : MonoBehaviour
{
	private static string IS_SUCCESS = "isSuccess";

	private static string MSG = "msg";

	private static string CODE = "code";

	public void LoginCallback(string LoginInfo)
	{
		JsonData jsonData = JsonMapper.ToObject(LoginInfo);
		SetMassage(LoginInfo);
		DemoController.showLoading();
		if (jsonData[IS_SUCCESS] != null)
		{
			CommonDic.getInstance().isSuccess = jsonData[IS_SUCCESS].ToString();
		}
		if (jsonData[MSG] != null)
		{
			CommonDic.getInstance().loginMsg = jsonData[MSG].ToString();
		}
		UnityEngine.Debug.Log("调用login回调:" + LoginInfo);
	}

	public void QueryOrPayCallback(string queryOrPayInfo)
	{
		JsonData jsonData = JsonMapper.ToObject(queryOrPayInfo);
		if (jsonData[CODE] != null)
		{
			CommonDic.getInstance().code = jsonData["code"].ToString();
		}
		if (jsonData[MSG] != null)
		{
			CommonDic.getInstance().msg = jsonData["msg"].ToString();
		}
		if (jsonData != null)
		{
			CommonDic.getInstance().order_info = jsonData[1].ToString();
		}
		SetMassage(queryOrPayInfo);
		DemoController.showLoading();
		UnityEngine.Debug.Log("调用pay回调:" + queryOrPayInfo);
	}

	public void UserInfoCallback(string userInfo)
	{
		CommonDic.getInstance().user_info = userInfo;
		SetMassage(userInfo);
		DemoController.showLoading();
		UnityEngine.Debug.Log("调用userInfo回调:" + userInfo);
	}

	public void SetMassage(string massage)
	{
		if (!GetCurrentGameObject().Equals(null))
		{
			GetCurrentGameObject().GetComponent<Text>().text = massage;
		}
		else
		{
			UnityEngine.Debug.LogError("无接收该Message的控件");
		}
	}

	public GameObject GetCurrentGameObject()
	{
		return GameObject.Find("MassageInfo");
	}

	public void ActivityForResultCallback(string activity)
	{
		PicoPaymentSDK.jo.Call("authCallback", activity);
	}
}
public class CommonDic
{
	private static CommonDic dic;

	private static Dictionary<string, string> mydic;

	private string _app_ID;

	private string _app_Key;

	private string _user_token;

	private string _access_token = "";

	private string _open_id;

	private string _refresh_token;

	private string _expires_in;

	private string _user_info;

	private string _subject;

	private string _body;

	private string _order_id;

	private string _total;

	private string _goods_tag;

	private string _notify_url;

	private string _trade_type;

	private string _pay_code = "";

	private string _order_info;

	private string _code;

	private string _msg = "null";

	private string _merchant_ID;

	private string _payKey;

	private string _isSuucess;

	private string _loginMsg;

	public string subject
	{
		get
		{
			return _subject;
		}
		set
		{
			_subject = value;
		}
	}

	public string body
	{
		get
		{
			return _body;
		}
		set
		{
			_body = value;
		}
	}

	public string order_id
	{
		get
		{
			return _order_id;
		}
		set
		{
			_order_id = value;
		}
	}

	public string total
	{
		get
		{
			return _total;
		}
		set
		{
			_total = value;
		}
	}

	public string goods_tag
	{
		get
		{
			return _goods_tag;
		}
		set
		{
			_goods_tag = value;
		}
	}

	public string notify_url
	{
		get
		{
			return _notify_url;
		}
		set
		{
			_notify_url = value;
		}
	}

	public string pay_code
	{
		get
		{
			return _pay_code;
		}
		set
		{
			_pay_code = value;
		}
	}

	public string trade_type
	{
		get
		{
			return _trade_type;
		}
		set
		{
			_trade_type = value;
		}
	}

	public string user_token
	{
		get
		{
			return _user_token;
		}
		set
		{
			_user_token = value;
		}
	}

	public string access_token
	{
		get
		{
			return _access_token;
		}
		set
		{
			_access_token = value;
		}
	}

	public string open_id
	{
		get
		{
			return _open_id;
		}
		set
		{
			_open_id = value;
		}
	}

	public string refresh_token
	{
		get
		{
			return _refresh_token;
		}
		set
		{
			_refresh_token = value;
		}
	}

	public string expires_in
	{
		get
		{
			return _expires_in;
		}
		set
		{
			_expires_in = value;
		}
	}

	public string isSuccess
	{
		get
		{
			return _isSuucess;
		}
		set
		{
			_isSuucess = value;
		}
	}

	public string loginMsg
	{
		get
		{
			return _loginMsg;
		}
		set
		{
			_loginMsg = value;
		}
	}

	public string user_info
	{
		get
		{
			return _user_info;
		}
		set
		{
			_user_info = value;
		}
	}

	public string order_info
	{
		get
		{
			return _order_info;
		}
		set
		{
			_order_info = value;
		}
	}

	public string code
	{
		get
		{
			return _code;
		}
		set
		{
			_code = value;
		}
	}

	public string msg
	{
		get
		{
			return _msg;
		}
		set
		{
			_msg = value;
		}
	}

	public string app_ID
	{
		get
		{
			return _app_ID;
		}
		set
		{
			_app_ID = value;
		}
	}

	public string app_Key
	{
		get
		{
			return _app_Key;
		}
		set
		{
			_app_Key = value;
		}
	}

	public string merchant_ID
	{
		get
		{
			return _merchant_ID;
		}
		set
		{
			_merchant_ID = value;
		}
	}

	public string paykey
	{
		get
		{
			return _payKey;
		}
		set
		{
			_payKey = value;
		}
	}

	public static CommonDic getInstance()
	{
		if (dic == null)
		{
			dic = new CommonDic();
		}
		if (mydic == null)
		{
			mydic = new Dictionary<string, string>();
			InitDicData(mydic);
		}
		return dic;
	}

	public Dictionary<string, string> getDic()
	{
		return mydic;
	}

	public void setParameters(string name, string value)
	{
		if (name.Equals("subject"))
		{
			subject = value;
		}
		if (name.Equals("body"))
		{
			body = value;
		}
		if (name.Equals("order_id"))
		{
			order_id = value;
		}
		if (name.Equals("total"))
		{
			total = value;
		}
		if (name.Equals("goods_tag"))
		{
			goods_tag = value;
		}
		if (name.Equals("notify_url"))
		{
			notify_url = value;
		}
		if (name.Equals("trade_type"))
		{
			trade_type = value;
		}
		if (name.Equals("pay_code"))
		{
			pay_code = value;
		}
	}

	public string PayOrderString()
	{
		return JsonMapper.ToJson(getInstance());
	}

	public static void InitDicData(Dictionary<string, string> mydic)
	{
		mydic.Add("00000", "网络异常");
		mydic.Add("10000", "登录成功");
		mydic.Add("10001", "用户未登陆");
		mydic.Add("10002", "请输入正确金额");
		mydic.Add("10003", "登陆过期，请重新登陆");
		mydic.Add("11000", "商户验证成功");
		mydic.Add("11001", "商户验证失败");
		mydic.Add("11002", "用户验证参数错误或请求过期");
		mydic.Add("11003", "商户未验证");
		mydic.Add("12000", "支付成功");
		mydic.Add("12001", "支付失败");
		mydic.Add("12003", "P币不足");
		mydic.Add("12004", "余额可用");
		mydic.Add("13000", "生成订单");
		mydic.Add("13001", "获取数据失败");
		mydic.Add("13002", "生成订单失败");
		mydic.Add("14000", "查询订单成功");
		mydic.Add("14001", "订单不存在/有误");
		mydic.Add("14002", "用户取消支付操作");
		mydic.Add("15000", "未输入商品信息");
		mydic.Add("15001", "未输入预付ID");
		mydic.Add("15002", "请输入Pico支付订单号或商户订单号");
		mydic.Add("NOAUTH", "商户无此接口权限");
		mydic.Add("SYSTEMERROR", "系统错误");
		mydic.Add("APP_ID_NOT_EXIST", "APP_ID不存在");
		mydic.Add("MCHID_NOT_EXIST", "MCHID不存在");
		mydic.Add("APP_ID_MCHID_NOT_MATCH", "app_id和mch_id不匹配ID");
		mydic.Add("LACK_PARAMS", "缺少参数");
		mydic.Add("SIGNERROR", "签名错误");
		mydic.Add("NO_DATA", "没有查询到数据");
	}
}
public class LoginSDK
{
	public static void Login()
	{
		PicoPaymentSDK.Login();
	}

	public static void GetUserAPI()
	{
		PicoPaymentSDK.GetUserAPI();
	}
}
public class PicoPaymentSDK
{
	private static AndroidJavaObject _jo = new AndroidJavaObject("com.pico.loginpaysdk.UnityInterface");

	public static AndroidJavaObject jo
	{
		get
		{
			return _jo;
		}
		set
		{
			_jo = value;
		}
	}

	public static void Login()
	{
		AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
		jo.Call("init", @static);
		jo.Call("authSSO");
	}

	public static void Pay(string payOrderJson)
	{
		AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
		jo.Call("init", @static);
		jo.Call("pay", payOrderJson);
	}

	public static void QueryOrder(string orderId)
	{
		AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
		jo.Call("init", @static);
		jo.Call("queryOrder", orderId);
	}

	public static void GetUserAPI()
	{
		AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
		jo.Call("init", @static);
		jo.Call("getUserAPI");
	}
}
public class Pvr_ToBService : MonoBehaviour
{
	public Text deviceInfoText;

	private void Awake()
	{
		InitToBService();
	}

	private void Start()
	{
		BindToBService();
	}

	private void OnDestory()
	{
		UnBindToBService();
	}

	private void InitToBService()
	{
		ToBService.UPvr_InitToBService();
		ToBService.UPvr_SetUnityObjectName(base.name);
	}

	private void BindToBService()
	{
		ToBService.UPvr_BindToBService();
	}

	private void UnBindToBService()
	{
		ToBService.UPvr_UnBindToBService();
	}

	private void BoolCallback(string value)
	{
		if (ToBService.BoolCallback != null)
		{
			ToBService.BoolCallback(bool.Parse(value));
		}
		ToBService.BoolCallback = null;
	}

	private void IntCallback(string value)
	{
		if (ToBService.IntCallback != null)
		{
			ToBService.IntCallback(int.Parse(value));
		}
		ToBService.IntCallback = null;
	}

	private void LongCallback(string value)
	{
		if (ToBService.LongCallback != null)
		{
			ToBService.LongCallback(int.Parse(value));
		}
		ToBService.LongCallback = null;
	}

	public void StateGetDeviceInfo()
	{
		string text = ToBService.UPvr_StateGetDeviceInfo(PBS_SystemInfoEnum.PUI_VERSION);
		deviceInfoText.text = "PUI_VERSION:" + text;
	}

	public void ControlSetDeviceAction()
	{
		ToBService.UPvr_ControlSetDeviceAction(PBS_DeviceControlEnum.DEVICE_CONTROL_SHUTDOWN, ControlSetDeviceActionCallBack);
	}

	private void ControlSetDeviceActionCallBack(int value)
	{
		UnityEngine.Debug.Log("ControlSetDeviceActionCallBack : " + value);
	}

	public void AppManager()
	{
		ToBService.UPvr_ControlAPPManger(PBS_PackageControlEnum.PACKAGE_SILENCE_UNINSTALL, "com.pico.ipd.test", AppManagerCallBack);
	}

	private void AppManagerCallBack(int value)
	{
		UnityEngine.Debug.Log("AppManagerCallBack : " + value);
	}
}
public class PLOG : MonoBehaviour
{
	public static int logLevel;

	public static void getConfigTraceLevel()
	{
		Render.UPvr_GetIntConfig(6, ref logLevel);
	}

	public static void D(string msg)
	{
		if (logLevel > 2)
		{
			UnityEngine.Debug.Log(msg);
		}
	}

	public static void I(string msg)
	{
		if (logLevel > 1)
		{
			UnityEngine.Debug.Log(msg);
		}
	}

	public static void W(string msg)
	{
		if (logLevel > 0)
		{
			UnityEngine.Debug.LogWarning(msg);
		}
	}

	public static void E(string msg)
	{
		UnityEngine.Debug.LogError(msg);
	}
}
public class PicoDevice : MonoBehaviour
{
	public enum DeviceType
	{
		HMD,
		LeftController,
		RightController
	}

	public DeviceType deviceType;

	private Vector3 devicePos;

	private Quaternion deviceRot;

	private void Awake()
	{
		if (deviceType == DeviceType.HMD)
		{
			base.gameObject.AddComponent<Camera>();
			GameObject obj = new GameObject();
			obj.name = "LeftEye";
			obj.transform.parent = base.transform;
			obj.AddComponent<Pvr_UnitySDKEye>().eyeSide = Eye.LeftEye;
			GameObject obj2 = new GameObject();
			obj2.name = "RightEye";
			obj2.transform.parent = base.transform;
			obj2.AddComponent<Pvr_UnitySDKEye>().eyeSide = Eye.RightEye;
			GameObject obj3 = new GameObject();
			obj3.name = "BothEye";
			obj3.transform.parent = base.transform;
			obj3.AddComponent<Pvr_UnitySDKEye>().eyeSide = Eye.BothEye;
			base.gameObject.AddComponent<Pvr_UnitySDKEyeManager>();
		}
	}

	private void Update()
	{
		switch (deviceType)
		{
		case DeviceType.HMD:
			devicePos = Pvr_UnitySDKSensor.Instance.HeadPose.Position;
			deviceRot = Pvr_UnitySDKSensor.Instance.HeadPose.Orientation;
			break;
		case DeviceType.LeftController:
			devicePos = Pvr_ControllerManager.controllerlink.Controller0.Position;
			deviceRot = Pvr_ControllerManager.controllerlink.Controller0.Rotation;
			break;
		case DeviceType.RightController:
			devicePos = Pvr_ControllerManager.controllerlink.Controller1.Position;
			deviceRot = Pvr_ControllerManager.controllerlink.Controller1.Rotation;
			break;
		}
		base.transform.localPosition = devicePos;
		base.transform.localRotation = deviceRot;
	}
}
public class CPicoSDKSettingAsset : ScriptableObject
{
	public bool IgnoreSDKSetting;

	public bool DontshowBuildWaring;

	public bool AppIDChecked;
}
[Serializable]
public class Pvr_UnitySDKProjectSetting : ScriptableObject
{
	public RenderTextureAntiAliasing rtAntiAlising;

	public RenderTextureDepth rtBitDepth;

	public RenderTextureFormat rtFormat;

	public bool usedefaultRenderTexture;

	public Vector2 customRTSize;

	public bool usedefaultfps;

	public int customfps;

	public bool usesinglepass;

	public bool usecontentprotect;

	public static Pvr_UnitySDKProjectSetting GetProjectConfig()
	{
		return Resources.Load<Pvr_UnitySDKProjectSetting>("ProjectSetting");
	}
}
public sealed class Pvr_UnitySDKPlatformSetting : ScriptableObject
{
	public enum simulationType
	{
		Null,
		Invalid,
		Valid
	}

	[SerializeField]
	private bool entitlementchecksimulation;

	[SerializeField]
	private bool startTimeEntitlementCheck;

	[SerializeField]
	public string appID;

	public List<string> deviceSN = new List<string>();

	private static Pvr_UnitySDKPlatformSetting instance;

	public static bool Entitlementchecksimulation
	{
		get
		{
			return Instance.entitlementchecksimulation;
		}
		set
		{
			if (Instance.entitlementchecksimulation != value)
			{
				Instance.entitlementchecksimulation = value;
			}
		}
	}

	public static bool StartTimeEntitlementCheck
	{
		get
		{
			return Instance.startTimeEntitlementCheck;
		}
		set
		{
			if (Instance.startTimeEntitlementCheck != value)
			{
				Instance.startTimeEntitlementCheck = value;
			}
		}
	}

	public static Pvr_UnitySDKPlatformSetting Instance
	{
		get
		{
			if (instance == null)
			{
				instance = Resources.Load<Pvr_UnitySDKPlatformSetting>("PlatformSettings");
			}
			return instance;
		}
		set
		{
			instance = value;
		}
	}
}
public class Pvr_UnitySDKManager : MonoBehaviour
{
	public delegate void EntitlementCheckResult(int ReturnValue);

	public static PlatForm platform;

	private static Pvr_UnitySDKManager sdk;

	[HideInInspector]
	public float EyesAspect = 1f;

	[HideInInspector]
	public int posStatus;

	[HideInInspector]
	public bool ismirroring;

	[HideInInspector]
	public Vector3 resetBasePos;

	[HideInInspector]
	public int trackingmode = -1;

	[HideInInspector]
	public int systemprop = -1;

	[HideInInspector]
	public bool systemFPS;

	[HideInInspector]
	public float[] headData = new float[7];

	[SerializeField]
	private bool rotfoldout;

	[SerializeField]
	private bool hmdOnlyrot;

	[SerializeField]
	private bool controllerOnlyrot;

	[SerializeField]
	private TrackingOrigin trackingOrigin;

	public bool ResetTrackerOnLoad;

	[HideInInspector]
	public Vector3 leftEyeOffset;

	[HideInInspector]
	public Vector3 rightEyeOffset;

	[HideInInspector]
	public Rect leftEyeRect;

	[HideInInspector]
	public Rect rightEyeRect;

	[HideInInspector]
	public Matrix4x4 leftEyeView;

	[HideInInspector]
	public Matrix4x4 rightEyeView;

	[HideInInspector]
	public Pvr_UnitySDKEditor pvr_UnitySDKEditor;

	[SerializeField]
	private bool vrModeEnabled = true;

	[HideInInspector]
	public Material Eyematerial;

	[HideInInspector]
	public Material Middlematerial;

	[HideInInspector]
	public bool newPicovrTriggered;

	[SerializeField]
	private bool showFPS;

	[HideInInspector]
	public Vector3 neckOffset = new Vector3(0f, 0.075f, 0.0805f);

	[SerializeField]
	private bool pVRNeck = true;

	[HideInInspector]
	public bool UseCustomNeckPara;

	[HideInInspector]
	public bool onResume;

	[HideInInspector]
	public bool isEnterVRMode;

	public bool isHasController;

	public Pvr_UnitySDKConfigProfile pvr_UnitySDKConfig;

	private GameObject calltoast;

	private GameObject msgtoast;

	private GameObject lowhmdBatterytoast;

	private GameObject lowphoneBatterytoast;

	private GameObject LowPhoneHealthtoast;

	private GameObject LowcontrollerBatterytoast;

	private bool lowControllerpowerstate;

	private float controllerpowershowtime;

	private bool UseToast = true;

	private int iPhoneHMDModeEnabled;

	private GameObject G3LiteTips;

	[SerializeField]
	private bool monoscopic;

	private bool mIsAndroid7;

	public static Func<bool> eventEnterVRMode;

	[HideInInspector]
	public bool ShowVideoSeethrough;

	public int SystemDebugFFRLevel = -1;

	public int SystemFFRLevel = -1;

	public int AppCheckResult = 100;

	public Action longPressHomeKeyAction;

	public static Pvr_UnitySDKManager SDK
	{
		get
		{
			if (sdk == null)
			{
				sdk = UnityEngine.Object.FindObjectOfType<Pvr_UnitySDKManager>();
			}
			return sdk;
		}
	}

	public bool Rotfoldout
	{
		get
		{
			return rotfoldout;
		}
		set
		{
			if (value != rotfoldout)
			{
				rotfoldout = value;
			}
		}
	}

	public bool HmdOnlyrot
	{
		get
		{
			return hmdOnlyrot;
		}
		set
		{
			if (value != hmdOnlyrot)
			{
				hmdOnlyrot = value;
			}
		}
	}

	public bool ControllerOnlyrot
	{
		get
		{
			return controllerOnlyrot;
		}
		set
		{
			if (value != controllerOnlyrot)
			{
				controllerOnlyrot = value;
			}
		}
	}

	public TrackingOrigin TrackingOrigin
	{
		get
		{
			return trackingOrigin;
		}
		set
		{
			if (value != trackingOrigin)
			{
				trackingOrigin = value;
				Sensor.UPvr_SetTrackingOriginType(value);
			}
		}
	}

	[HideInInspector]
	public bool VRModeEnabled
	{
		get
		{
			return vrModeEnabled;
		}
		set
		{
			if (value != vrModeEnabled)
			{
				vrModeEnabled = value;
			}
		}
	}

	[HideInInspector]
	public bool picovrTriggered { get; set; }

	public bool ShowFPS
	{
		get
		{
			return showFPS;
		}
		set
		{
			if (value != showFPS)
			{
				showFPS = value;
			}
		}
	}

	public bool PVRNeck
	{
		get
		{
			return pVRNeck;
		}
		set
		{
			if (value != pVRNeck)
			{
				pVRNeck = value;
			}
		}
	}

	[HideInInspector]
	public bool Monoscopic
	{
		get
		{
			return monoscopic;
		}
		set
		{
			if (value != monoscopic)
			{
				monoscopic = value;
				Render.UPvr_SetMonoMode(monoscopic);
			}
		}
	}

	public static event EntitlementCheckResult EntitlementCheckResultEvent;

	public void ChangeDefaultCustomRtSize(int w, int h)
	{
		Pvr_UnitySDKProjectSetting.GetProjectConfig().customRTSize = new Vector2(w, h);
	}

	public Vector3 EyeOffset(Eye eye)
	{
		if (eye != 0)
		{
			return rightEyeOffset;
		}
		return leftEyeOffset;
	}

	public Rect EyeRect(Eye eye)
	{
		if (eye != 0)
		{
			return rightEyeRect;
		}
		return leftEyeRect;
	}

	private bool SDKManagerInit()
	{
		if (SDKManagerInitConfigProfile())
		{
			mIsAndroid7 = SystemInfo.operatingSystem.Contains("Android OS 7.");
			PLOG.I("Android 7 = " + mIsAndroid7);
			if (SDKManagerInitCoreAbility())
			{
				return true;
			}
			return false;
		}
		return false;
	}

	private bool SDKManagerInitCoreAbility()
	{
		Sensor.UPvr_SetTrackingOriginType(trackingOrigin);
		Render.UPvr_SetMonoMode(monoscopic);
		if (Pvr_UnitySDKRender.Instance == null)
		{
			PLOG.I("pvr_UnitySDKRender init failed");
		}
		if (Pvr_UnitySDKSensor.Instance == null)
		{
			PLOG.I("pvr_UnitySDKSensor init failed");
		}
		Pvr_UnitySDKAPI.System.UPvr_StartHomeKeyReceiver(base.gameObject.name);
		return true;
	}

	public void smsReceivedCallback(string msg)
	{
		PLOG.I("PvrLog MSG" + msg);
		JsonData jsonData = JsonMapper.ToObject(msg);
		string text = "";
		if (msg.Contains("messageSender"))
		{
			text = (string)jsonData["messageSender"];
		}
		string text2 = "";
		if (msg.Contains("messageAdr"))
		{
			text2 = (string)jsonData["messageAdr"];
			if (text2.Substring(0, 3) == "+82")
			{
				text2 = "0" + text2.Remove(0, 3);
				text2 = TransformNumber(text2);
			}
			else if (text2.Substring(0, 1) != "+")
			{
				text2 = TransformNumber(text2);
			}
		}
		if (UseToast)
		{
			msgtoast.transform.Find("number").GetComponent<Text>().text = text2;
			msgtoast.transform.Find("name").GetComponent<Text>().text = text;
			if (text.Length == 0)
			{
				msgtoast.transform.Find("number").transform.localPosition = new Vector3(0f, 0f, 0f);
			}
			else
			{
				msgtoast.transform.Find("number").transform.localPosition = new Vector3(60f, 0f, 0f);
			}
			StartCoroutine(ToastManager(2, state: true, 0f));
			StartCoroutine(ToastManager(2, state: false, 5f));
		}
	}

	public void phoneStateCallback(string state)
	{
		PLOG.I("PvrLog phone" + state);
		JsonData jsonData = JsonMapper.ToObject(state);
		string text = "";
		if (state.Contains("phoneNumber"))
		{
			text = (string)jsonData["phoneNumber"];
			if (text.Substring(0, 3) == "+82")
			{
				text = "0" + text.Remove(0, 3);
				text = TransformNumber(text);
			}
			else if (text.Substring(0, 1) != "+")
			{
				text = TransformNumber(text);
			}
		}
		string text2 = "";
		if (state.Contains("contactName"))
		{
			text2 = (string)jsonData["contactName"];
		}
		if (UseToast)
		{
			calltoast.transform.Find("number").GetComponent<Text>().text = text;
			calltoast.transform.Find("name").GetComponent<Text>().text = text2;
			if (text2.Length == 0)
			{
				calltoast.transform.Find("number").transform.localPosition = new Vector3(0f, 0f, 0f);
			}
			else
			{
				calltoast.transform.Find("number").transform.localPosition = new Vector3(60f, 0f, 0f);
			}
			StartCoroutine(ToastManager(1, state: true, 0f));
			StartCoroutine(ToastManager(1, state: false, 5f));
		}
	}

	public void phoneBatteryStateCallback(string state)
	{
		PLOG.I("PvrLog phoneBatteryState" + state);
		JsonData jsonData = JsonMapper.ToObject(state);
		string value = "";
		if (state.Contains("phoneBatteryLevel"))
		{
			value = (string)jsonData["phoneBatteryLevel"];
		}
		string value2 = "";
		if (state.Contains("phoneBatteryHealth"))
		{
			value2 = (string)jsonData["phoneBatteryHealth"];
		}
		if (!UseToast)
		{
			return;
		}
		if (Convert.ToInt16(value) <= 5)
		{
			if (!lowhmdBatterytoast.activeSelf)
			{
				StartCoroutine(ToastManager(4, state: true, 0f));
				StartCoroutine(ToastManager(4, state: false, 3f));
			}
			else
			{
				StartCoroutine(ToastManager(4, state: true, 5f));
				StartCoroutine(ToastManager(4, state: false, 8f));
			}
		}
		if (Convert.ToInt16(value2) == 3)
		{
			StartCoroutine(ToastManager(5, state: true, 0f));
			StartCoroutine(ToastManager(5, state: false, 5f));
		}
	}

	public void hmdLowBatteryCallback(string level)
	{
		PLOG.I("PvrLog hmdLowBatteryCallback" + level);
		if (UseToast)
		{
			if (!lowphoneBatterytoast.activeSelf)
			{
				StartCoroutine(ToastManager(3, state: true, 0f));
				StartCoroutine(ToastManager(3, state: false, 3f));
			}
			else
			{
				StartCoroutine(ToastManager(3, state: true, 5f));
				StartCoroutine(ToastManager(3, state: false, 8f));
			}
		}
	}

	private string TransformNumber(string number)
	{
		if (number.Length == 11)
		{
			string text = number.Substring(0, 3);
			string text2 = number.Substring(3, 4);
			string text3 = number.Substring(7, 4);
			number = text + "-" + text2 + "-" + text3;
		}
		else if (number.Length == 10)
		{
			if (number.Substring(1, 1) == "1")
			{
				string text4 = number.Substring(0, 3);
				string text5 = number.Substring(3, 3);
				string text6 = number.Substring(6, 4);
				number = text4 + "-" + text5 + "-" + text6;
			}
			else
			{
				string text7 = number.Substring(0, 2);
				string text8 = number.Substring(2, 4);
				string text9 = number.Substring(6, 4);
				number = text7 + "-" + text8 + "-" + text9;
			}
		}
		else if (number.Length == 9)
		{
			if (number.Substring(1, 1) == "2")
			{
				string text10 = number.Substring(0, 2);
				string text11 = number.Substring(2, 3);
				string text12 = number.Substring(5, 4);
				number = text10 + "-" + text11 + "-" + text12;
			}
			else
			{
				number = "+82" + number.Remove(0, 1);
			}
		}
		return number;
	}

	public void onHmdOrientationReseted()
	{
	}

	private IEnumerator ToastManager(int type, bool state, float time)
	{
		yield return new WaitForSeconds(time);
		switch (type)
		{
		case 1:
			calltoast.SetActive(state);
			break;
		case 2:
			msgtoast.SetActive(state);
			break;
		case 3:
			lowhmdBatterytoast.SetActive(state);
			break;
		case 4:
			lowphoneBatterytoast.SetActive(state);
			break;
		case 5:
			LowPhoneHealthtoast.SetActive(state);
			break;
		case 6:
			LowcontrollerBatterytoast.SetActive(state);
			break;
		}
	}

	private void CheckControllerStateForG2(string state)
	{
		if (iPhoneHMDModeEnabled == 1 && Convert.ToBoolean(Convert.ToInt16(state)) && Controller.UPvr_GetControllerPower(0) == 0 && Pvr_ControllerManager.controllerlink.Controller0.Rotation.eulerAngles != Vector3.zero)
		{
			StartCoroutine(ToastManager(6, state: true, 0f));
			StartCoroutine(ToastManager(6, state: false, 3f));
		}
	}

	public void notificationCallback(string data)
	{
		JsonData jsonData = JsonMapper.ToObject(data);
		if (G3LiteTips == null)
		{
			G3LiteTips = UnityEngine.Object.Instantiate(Resources.Load("Prefabs/G3LiteTips") as GameObject, base.transform.Find("Head"), worldPositionStays: false);
		}
		JsonData jsonData2 = JsonMapper.ToObject(jsonData["str"].ToString());
		switch ((int)jsonData["type"])
		{
		case 0:
			SetProperty(0, jsonData2, "Sms");
			break;
		case 1:
			SetProperty(1, jsonData2, "Call");
			break;
		case 2:
			SetProperty(2, jsonData2, "Warnning");
			break;
		case 3:
			SetProperty(3, jsonData2, "Warnning");
			break;
		case 4:
			SetProperty(4, jsonData2, "Warnning");
			break;
		case 5:
		{
			Transform transform = G3LiteTips.transform.Find("Onlyimage");
			SetBaseProperty(transform, jsonData2["General"], "");
			SetImageProperty(transform, jsonData2["General"], "");
			transform.gameObject.SetActive(value: true);
			StartCoroutine(G3TipsManager(transform.gameObject, (int)jsonData2["General"]["time"]));
			break;
		}
		case -1:
			break;
		}
	}

	private Sprite LoadSprite(Vector2 size, string filepath)
	{
		int width = (int)size.x;
		int height = (int)size.y;
		Texture2D texture2D = new Texture2D(width, height);
		texture2D.LoadImage(ReadTex(filepath));
		return Sprite.Create(texture2D, new Rect(0f, 0f, texture2D.width, texture2D.height), new Vector2(0.5f, 0.5f));
	}

	private byte[] ReadTex(string path)
	{
		if (path == "")
		{
			return new byte[0];
		}
		FileStream fileStream = new FileStream(path, FileMode.Open, FileAccess.Read);
		fileStream.Seek(0L, SeekOrigin.Begin);
		byte[] array = new byte[fileStream.Length];
		fileStream.Read(array, 0, (int)fileStream.Length);
		fileStream.Close();
		fileStream.Dispose();
		fileStream = null;
		return array;
	}

	private void SetProperty(int type, JsonData data, string value)
	{
		Transform trans = G3LiteTips.transform.Find(value);
		SetBaseProperty(trans, data, "");
		SetImageProperty(trans, data, "");
		trans.gameObject.SetActive(value: true);
		StartCoroutine(G3TipsManager(trans.gameObject, (int)data["time"]));
		Transform transform = trans.transform.Find("icon");
		SetBaseProperty(transform, data, "icon_");
		SetImageProperty(transform, data, "icon_");
		Transform transform2 = trans.transform.Find("title");
		SetBaseProperty(transform2, data, "title_");
		SetTextProperty(transform2, data, "title_");
		if (type != 1)
		{
			Transform transform3 = trans.transform.Find("details");
			SetBaseProperty(transform3, data, "details_");
			SetTextProperty(transform3, data, "details_");
			Transform transform4 = trans.transform.Find("image1");
			SetBaseProperty(transform4, data, "image1_");
			SetImageProperty(transform4, data, "image1_");
		}
		if (type == 0 || type == 1)
		{
			Transform transform5 = trans.transform.Find("explain");
			SetBaseProperty(transform5, data, "explain_");
			SetTextProperty(transform5, data, "explain_");
			Transform transform6 = trans.transform.Find("source");
			SetBaseProperty(transform6, data, "source_");
			SetTextProperty(transform6, data, "source_");
		}
		if (type == 0)
		{
			Transform transform7 = trans.transform.Find("time");
			SetBaseProperty(transform7, data, "system_time_");
			SetTextProperty(transform7, data, "system_time_");
		}
		Transform transform8 = trans.transform.Find("Button");
		SetBaseProperty(transform8, data, "button_");
		SetImageProperty(transform8, data, "button_");
		transform8.GetComponent<Button>().onClick.AddListener(delegate
		{
			StartCoroutine(G3TipsManager(trans.gameObject, 0f));
		});
		Transform transform9 = transform8.transform.Find("Text");
		SetBaseProperty(transform9, data, "button_text_");
		SetTextProperty(transform9, data, "button_text_");
	}

	private void SetBaseProperty(Transform trans, JsonData data, string value)
	{
		string prop_name = value + "pos";
		string prop_name2 = value + "angles";
		string prop_name3 = value + "size";
		string prop_name4 = value + "scale";
		trans.GetComponent<RectTransform>().anchoredPosition3D = new Vector3(JsonToFloat(data[prop_name][0]), JsonToFloat(data[prop_name][1]), JsonToFloat(data[prop_name][2]));
		trans.GetComponent<RectTransform>().eulerAngles = new Vector3(JsonToFloat(data[prop_name2][0]), JsonToFloat(data[prop_name2][1]), JsonToFloat(data[prop_name2][2]));
		trans.GetComponent<RectTransform>().sizeDelta = new Vector2(JsonToFloat(data[prop_name3][0]), JsonToFloat(data[prop_name3][1]));
		trans.GetComponent<RectTransform>().localScale = new Vector3(JsonToFloat(data[prop_name4][0]), JsonToFloat(data[prop_name4][1]), JsonToFloat(data[prop_name4][2]));
	}

	private void SetImageProperty(Transform image, JsonData data, string value)
	{
		string prop_name = value + "sprite";
		string prop_name2 = value + "color";
		string prop_name3 = value + "size";
		image.GetComponent<Image>().sprite = LoadSprite(new Vector2(JsonToFloat(data[prop_name3][0]), JsonToFloat(data[prop_name3][1])), (string)data[prop_name]);
		image.GetComponent<Image>().color = new Color(JsonToFloat(data[prop_name2][0]), JsonToFloat(data[prop_name2][1]), JsonToFloat(data[prop_name2][2]), JsonToFloat(data[prop_name2][3]));
	}

	private void SetTextProperty(Transform text, JsonData data, string value)
	{
		string prop_name = value + "color";
		string prop_name2 = value + "font_size";
		string prop_name3 = value + "font_style";
		string prop_name4 = value + "text";
		text.GetComponent<Text>().text = (string)data[prop_name4];
		text.GetComponent<Text>().color = new Color(JsonToFloat(data[prop_name][0]), JsonToFloat(data[prop_name][1]), JsonToFloat(data[prop_name][2]), JsonToFloat(data[prop_name][3]));
		text.GetComponent<Text>().fontSize = (int)data[prop_name2];
		text.GetComponent<Text>().fontStyle = (FontStyle)(int)data[prop_name3];
	}

	private IEnumerator G3TipsManager(GameObject tip, float time)
	{
		yield return new WaitForSeconds(time);
		tip.SetActive(value: false);
	}

	private float JsonToFloat(JsonData data)
	{
		return Convert.ToSingle((string)data);
	}

	private bool SDKManagerInitFPS()
	{
		Transform[] componentsInChildren = GetComponentsInChildren<Transform>(includeInactive: true);
		GameObject gameObject = null;
		Transform[] array = componentsInChildren;
		foreach (Transform transform in array)
		{
			if (transform.gameObject.name == "FPS")
			{
				gameObject = transform.gameObject;
			}
		}
		if (gameObject != null)
		{
			if (systemFPS)
			{
				gameObject.SetActive(value: true);
				return true;
			}
			int res = 0;
			Render.UPvr_GetIntConfig(10, ref res);
			if (Convert.ToBoolean(res))
			{
				gameObject.SetActive(value: true);
				return true;
			}
			if (ShowFPS)
			{
				gameObject.SetActive(value: true);
				return true;
			}
			return false;
		}
		return false;
	}

	private bool SDKManagerInitConfigProfile()
	{
		pvr_UnitySDKConfig = Pvr_UnitySDKConfigProfile.Default;
		return true;
	}

	private bool SDKManagerInitEditor()
	{
		if (pvr_UnitySDKEditor == null)
		{
			pvr_UnitySDKEditor = base.gameObject.AddComponent<Pvr_UnitySDKEditor>();
		}
		else
		{
			pvr_UnitySDKEditor = null;
			pvr_UnitySDKEditor = base.gameObject.AddComponent<Pvr_UnitySDKEditor>();
		}
		return true;
	}

	private bool SDKManagerInitPara()
	{
		return true;
	}

	public void SDKManagerLongHomeKey()
	{
		if (Pvr_UnitySDKSensor.Instance == null)
		{
			return;
		}
		if (isHasController)
		{
			if (Controller.UPvr_GetControllerState(0) == ControllerState.Connected || Controller.UPvr_GetControllerState(1) == ControllerState.Connected)
			{
				Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(0, 1);
			}
			else
			{
				Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 1);
			}
		}
		else
		{
			Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 1);
		}
	}

	private void setLongHomeKey()
	{
		if (sdk.HmdOnlyrot)
		{
			if (Pvr_UnitySDKSensor.Instance != null)
			{
				PLOG.I(Pvr_UnitySDKSensor.Instance.ResetUnitySDKSensor() ? "Long Home Key to Reset Sensor Success!" : "Long Home Key to Reset Sensor Failed!");
			}
			return;
		}
		if (trackingmode == 4 || trackingmode == 5 || trackingmode == 6)
		{
			Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 1);
		}
		else
		{
			if (trackingmode == 2 || trackingmode == 3)
			{
				if (isHasController && (Controller.UPvr_GetControllerState(0) == ControllerState.Connected || Controller.UPvr_GetControllerState(1) == ControllerState.Connected))
				{
					Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(0, 1);
				}
				else
				{
					Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 1);
				}
			}
			if (trackingmode == 0 || trackingmode == 1)
			{
				Pvr_UnitySDKSensor.Instance.ResetUnitySDKSensor();
			}
		}
		if (longPressHomeKeyAction != null)
		{
			longPressHomeKeyAction();
		}
	}

	public void verifyAPPCallback(string code)
	{
		UnityEngine.Debug.Log("PvrLog verifyAPPCallback" + code);
		AppCheckResult = Convert.ToInt32(code);
		if (Pvr_UnitySDKManager.EntitlementCheckResultEvent != null)
		{
			Pvr_UnitySDKManager.EntitlementCheckResultEvent(AppCheckResult);
		}
	}

	public void IpdRefreshCallBack(string ipd)
	{
		UnityEngine.Debug.Log("PvrLog IpdRefreshCallBack");
		Pvr_UnitySDKEye[] eyes = Pvr_UnitySDKEyeManager.Instance.Eyes;
		for (int i = 0; i < eyes.Length; i++)
		{
			eyes[i].RefreshCameraPosition(Convert.ToSingle(ipd));
		}
	}

	private void Awake()
	{
		UnityEngine.Debug.Log("DISFT Unity Version:" + Application.unityVersion);
		Vector3 vector = neckOffset;
		UnityEngine.Debug.Log("DISFT Customize NeckOffset:" + vector.ToString());
		UnityEngine.Debug.Log("DISFT MSAA :" + Pvr_UnitySDKProjectSetting.GetProjectConfig().rtAntiAlising);
		if (GraphicsSettings.renderPipelineAsset != null)
		{
			UnityEngine.Debug.Log("DISFT LWRP = Enable");
		}
		UnityEngine.Debug.Log("DISFT Content Proctect :" + Pvr_UnitySDKProjectSetting.GetProjectConfig().usecontentprotect);
		int res = 0;
		LoadIsMirroringValue();
		if (!ismirroring)
		{
			Render.UPvr_GetIntConfig(18, ref res);
			if (res == 1)
			{
				UnityEngine.Debug.Log("DISFT ScreenOrientation.Portrait = Enable");
				Screen.orientation = ScreenOrientation.Portrait;
			}
		}
		else
		{
			Render.UPvr_GetIntConfig(19, ref res);
			Screen.orientation = ((res == 0) ? ScreenOrientation.Portrait : ScreenOrientation.LandscapeLeft);
		}
		new AndroidJavaClass("com.psmart.vrlib.VrActivity");
		new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
		Pvr_ControllerManager pvr_ControllerManager = UnityEngine.Object.FindObjectOfType<Pvr_ControllerManager>();
		isHasController = pvr_ControllerManager != null;
		PLOG.getConfigTraceLevel();
		Render.UPvr_GetIntConfig(5, ref trackingmode);
		Application.targetFrameRate = 61;
		int res2 = 0;
		Render.UPvr_GetIntConfig(3, ref res2);
		if (res2 == 0)
		{
			SDK.HmdOnlyrot = true;
		}
		int res3 = -1;
		Render.UPvr_GetIntConfig(9, ref res3);
		float res4 = 0f;
		Render.UPvr_GetFloatConfig(6, ref res4);
		Application.targetFrameRate = ((res3 > 0) ? res3 : ((int)res4));
		if (!Pvr_UnitySDKProjectSetting.GetProjectConfig().usedefaultfps)
		{
			if ((float)Pvr_UnitySDKProjectSetting.GetProjectConfig().customfps <= res4)
			{
				Application.targetFrameRate = Pvr_UnitySDKProjectSetting.GetProjectConfig().customfps;
			}
			else
			{
				Application.targetFrameRate = (int)res4;
			}
		}
		UnityEngine.Debug.Log("DISFT Customize FPS :" + Application.targetFrameRate);
		if (!UseCustomNeckPara)
		{
			float res5 = 0f;
			float res6 = 0f;
			float res7 = 0f;
			int configsenum = 4;
			int configsenum2 = 5;
			Render.UPvr_GetFloatConfig(3, ref res5);
			Render.UPvr_GetFloatConfig(configsenum, ref res6);
			Render.UPvr_GetFloatConfig(configsenum2, ref res7);
			if (res5 != 0f || res6 != 0f || res7 != 0f)
			{
				neckOffset = new Vector3(res5, res6, res7);
			}
		}
		Render.UPvr_GetIntConfig(16, ref iPhoneHMDModeEnabled);
		Pvr_ControllerManager.ControllerStatusChangeEvent += CheckControllerStateForG2;
		InitUI();
		RefreshTextByLanguage();
	}

	private IEnumerator Start()
	{
		if (SDKManagerInit())
		{
			PLOG.I("SDK Init success.");
		}
		else
		{
			PLOG.E("SDK Init Failed.");
			Application.Quit();
		}
		if (Pvr_UnitySDKRender.Instance != null)
		{
			Pvr_UnitySDKRender.Instance.ReInit();
		}
		SDKManagerInitFPS();
		if (Pvr_UnitySDKPlatformSetting.StartTimeEntitlementCheck)
		{
			if (PlatformSettings.UPvr_IsCurrentDeviceValid() != Pvr_UnitySDKPlatformSetting.simulationType.Valid)
			{
				UnityEngine.Debug.Log("DISFT Entitlement Check Simulation DO NOT PASS");
				string appID = Pvr_UnitySDKPlatformSetting.Instance.appID;
				UnityEngine.Debug.Log("DISFT Start-time Entitlement Check Enable");
				PLOG.I("DISFT Start-time Entitlement Check APPID :" + appID);
				PlatformSettings.UPvr_AppEntitlementCheckExtra(appID);
			}
			else
			{
				UnityEngine.Debug.Log("DISFT Entitlement Check Simulation PASS");
			}
		}
		yield return StartCoroutine(InitRenderThreadRoutine());
	}

	private IEnumerator InitRenderThreadRoutine()
	{
		PLOG.I("InitRenderThreadRoutine begin");
		int i = 0;
		while (i < 2)
		{
			yield return null;
			int num = i + 1;
			i = num;
		}
		UnityEngine.Debug.Log("InitRenderThreadRoutine after a wait");
		if (Pvr_UnitySDKRender.Instance != null)
		{
			Pvr_UnitySDKRender.Instance.IssueRenderThread();
		}
		else
		{
			UnityEngine.Debug.Log("InitRenderThreadRoutine pvr_UnitySDKRender == null");
		}
		UnityEngine.Debug.Log("InitRenderThreadRoutine end");
	}

	private void Update()
	{
		if (isHasController && iPhoneHMDModeEnabled == 1 && Controller.UPvr_GetControllerPower(0) == 0 && Pvr_ControllerManager.controllerlink.controller0Connected && Pvr_ControllerManager.controllerlink.Controller0.Rotation.eulerAngles != Vector3.zero)
		{
			if (!lowControllerpowerstate)
			{
				StartCoroutine(ToastManager(6, state: true, 0f));
				StartCoroutine(ToastManager(6, state: false, 3f));
				lowControllerpowerstate = true;
			}
			controllerpowershowtime += Time.deltaTime;
			if (controllerpowershowtime >= 3600f)
			{
				lowControllerpowerstate = false;
				controllerpowershowtime = 0f;
			}
		}
		if (Input.touchCount == 1 && Input.touches[0].phase == TouchPhase.Began)
		{
			newPicovrTriggered = true;
		}
		if (Input.GetKeyDown(KeyCode.JoystickButton0))
		{
			newPicovrTriggered = true;
		}
		if (Pvr_UnitySDKSensor.Instance != null)
		{
			Pvr_UnitySDKSensor.Instance.SensorUpdate();
		}
		picovrTriggered = newPicovrTriggered;
		newPicovrTriggered = false;
	}

	private void OnDestroy()
	{
		if (sdk == this)
		{
			sdk = null;
		}
		RenderTexture.active = null;
		Resources.UnloadUnusedAssets();
		GC.Collect();
		Pvr_ControllerManager.ControllerStatusChangeEvent -= CheckControllerStateForG2;
	}

	private void OnEnable()
	{
		if (sdk == null)
		{
			sdk = this;
		}
		else if (sdk != this)
		{
			sdk = this;
		}
	}

	private void OnDisable()
	{
		StopAllCoroutines();
	}

	private void OnPause()
	{
		Pvr_UnitySDKAPI.System.UPvr_StopHomeKeyReceiver();
		LeaveVRMode();
		if (Pvr_UnitySDKSensor.Instance != null)
		{
			Pvr_UnitySDKSensor.Instance.StopUnitySDKSensor();
		}
	}

	private void OnApplicationPause(bool pause)
	{
		bool flag = pause;
		UnityEngine.Debug.Log("OnApplicationPause-------------------------" + (flag ? "true" : "false"));
		if (Pvr_UnitySDKAPI.System.UPvr_IsPicoActivity() && !Pvr_UnitySDKRender.Instance.isShellMode)
		{
			bool flag2 = Pvr_UnitySDKAPI.System.UPvr_GetMainActivityPauseStatus();
			UnityEngine.Debug.Log("OnApplicationPause-------------------------Activity Pause State:" + flag2);
			pause = flag2;
		}
		if (flag == pause)
		{
			if (pause)
			{
				onResume = false;
				OnPause();
			}
			else
			{
				onResume = true;
				GL.InvalidateState();
				StartCoroutine(OnResume());
			}
		}
		else if (pause)
		{
			UnityEngine.Debug.Log("OnApplicationPause-------------------------Activity pause Unity resume");
			GL.InvalidateState();
			StartCoroutine(OnResume());
			onResume = false;
			OnPause();
		}
		else
		{
			UnityEngine.Debug.Log("OnApplicationPause-------------------------Activity resume Unity pause");
			OnPause();
			onResume = true;
			GL.InvalidateState();
			StartCoroutine(OnResume());
		}
	}

	public void EnterVRMode()
	{
		Pvr_UnitySDKPluginEvent.Issue(RenderEventType.Resume);
		isEnterVRMode = true;
		if (eventEnterVRMode != null)
		{
			eventEnterVRMode();
		}
	}

	public void LeaveVRMode()
	{
		Pvr_UnitySDKPluginEvent.Issue(RenderEventType.Pause);
		isEnterVRMode = false;
	}

	public void SixDofForceQuit()
	{
		Application.Quit();
	}

	private void InitUI()
	{
		if (iPhoneHMDModeEnabled == 1)
		{
			Transform transform = UnityEngine.Object.Instantiate(Resources.Load("Prefabs/flamingo2Tips") as GameObject, base.transform.Find("Head"), worldPositionStays: false).transform;
			calltoast = transform.Find("Call").gameObject;
			msgtoast = transform.Find("Msg").gameObject;
			lowhmdBatterytoast = transform.Find("LowHmdBattery").gameObject;
			lowphoneBatterytoast = transform.Find("LowPhoneBattery").gameObject;
			LowPhoneHealthtoast = transform.Find("LowPhoneHealth").gameObject;
			LowcontrollerBatterytoast = transform.Find("LowControllerBattery").gameObject;
		}
	}

	private void RefreshTextByLanguage()
	{
		if (msgtoast != null)
		{
			msgtoast.transform.Find("Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("msgtoast0");
			msgtoast.transform.Find("string").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("msgtoast1");
			calltoast.transform.Find("Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("calltoast0");
			calltoast.transform.Find("Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("calltoast1");
			lowhmdBatterytoast.transform.Find("Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("lowhmdBatterytoast");
			lowphoneBatterytoast.transform.Find("Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("lowphoneBatterytoast");
			LowPhoneHealthtoast.transform.Find("Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("LowPhoneHealthtoast");
			LowcontrollerBatterytoast.transform.Find("Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("LowcontrollerBatterytoast");
		}
	}

	private void LoadIsMirroringValue()
	{
		AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
		AndroidJavaObject androidJavaObject = @static.Call<AndroidJavaObject>("getPackageManager", Array.Empty<object>());
		string text = @static.Call<string>("getPackageName", Array.Empty<object>());
		AndroidJavaObject androidJavaObject2 = androidJavaObject.Call<AndroidJavaObject>("getApplicationInfo", new object[2] { text, 128 }).Get<AndroidJavaObject>("metaData");
		ismirroring = Convert.ToBoolean(androidJavaObject2.Call<int>("getInt", new object[2] { "bypass_presentation", 0 }));
	}

	private IEnumerator OnResume()
	{
		int ability6dof = 0;
		Render.UPvr_GetIntConfig(3, ref ability6dof);
		RefreshTextByLanguage();
		if (Pvr_UnitySDKSensor.Instance != null)
		{
			Pvr_UnitySDKSensor.Instance.StartUnitySDKSensor();
			int res = -1;
			Render.UPvr_GetIntConfig(8, ref res);
			if (res != 1)
			{
				int res2 = -1;
				Render.UPvr_GetIntConfig(11, ref res2);
				if (res2 != 8)
				{
					Pvr_UnitySDKSensor.Instance.ResetUnitySDKSensor();
				}
			}
		}
		if (Pvr_UnitySDKAPI.System.UPvr_IsPicoActivity())
		{
			PLOG.I("onresume set monoPresentation success ?-------------" + Pvr_UnitySDKAPI.System.UPvr_SetMonoPresentation());
			PLOG.I("onresume presentation existed ?-------------" + Pvr_UnitySDKAPI.System.UPvr_IsPresentationExisted());
		}
		for (int j = 0; j < Pvr_UnitySDKEyeManager.Instance.Eyes.Length; j++)
		{
			Pvr_UnitySDKEyeManager.Instance.Eyes[j].RefreshCameraPosition(Pvr_UnitySDKAPI.System.UPvr_GetIPD());
		}
		int waitNum = 15;
		Render.UPvr_GetIntConfig(20, ref waitNum);
		int resetNum = 10;
		Render.UPvr_GetIntConfig(21, ref resetNum);
		for (int i = 0; i < waitNum; i++)
		{
			if (i == resetNum && ResetTrackerOnLoad && ability6dof == 1)
			{
				UnityEngine.Debug.Log("Reset Tracker OnLoad");
				Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 1);
			}
			yield return null;
		}
		EnterVRMode();
		Pvr_UnitySDKAPI.System.UPvr_StartHomeKeyReceiver(base.gameObject.name);
		Pvr_UnitySDKEye.setLevel = false;
		if (longPressHomeKeyAction != null)
		{
			longPressHomeKeyAction();
		}
		if (Render.UPvr_GetIntSysProc("pvrsist.foveation.level", ref SystemDebugFFRLevel))
		{
			Render.SetFoveatedRenderingLevel((EFoveationLevel)SystemDebugFFRLevel);
			UnityEngine.Debug.Log("DISFT OnResume Get System Debug ffr level is : " + SystemDebugFFRLevel);
		}
		else
		{
			UnityEngine.Debug.Log("DISFT OnResume Get System Debug ffr level Error,ffr level is : " + SystemDebugFFRLevel);
		}
		if (SystemDebugFFRLevel == -1)
		{
			Render.UPvr_GetIntConfig(22, ref SystemFFRLevel);
			if (SystemFFRLevel != -1 && SystemFFRLevel >= (int)Pvr_UnitySDKEyeManager.Instance.FoveationLevel)
			{
				Render.SetFoveatedRenderingLevel((EFoveationLevel)SystemFFRLevel);
				UnityEngine.Debug.Log("DISFT OnResume Get System ffr level is : " + SystemFFRLevel);
			}
		}
	}
}
public class QuitGame : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.Escape))
		{
			Application.Quit();
		}
	}
}
public class Pvr_UnityEyeMask : MonoBehaviour
{
	private class EyeMaskData
	{
		public Eye eyeSide;

		public Camera camera;

		public CommandBuffer cmdBuf;
	}

	private Shader eyeMaskShader;

	private Material eyeMaskMaterial;

	private Mesh eyeMaskMeshLeft;

	private Mesh eyeMaskMeshRight;

	private Mesh eyeMaskMeshBoth;

	private float zDir = -1f;

	private Color eyeMaskColor = Color.black;

	private List<EyeMaskData> cameraDataList = new List<EyeMaskData>();

	private void Awake()
	{
		UnityEngine.Debug.Log("DISFT EyeMask = Enable");
		if (SystemInfo.graphicsDeviceType == GraphicsDeviceType.OpenGLES3 || SystemInfo.graphicsDeviceType == GraphicsDeviceType.OpenGLES2)
		{
			zDir = -1f;
		}
		else if (SystemInfo.usesReversedZBuffer)
		{
			zDir = 1f;
		}
		else
		{
			zDir = 0f;
		}
	}

	private void OnEnable()
	{
		if (eyeMaskShader == null)
		{
			eyeMaskShader = Shader.Find("Pvr_UnitySDK/Pvr_EyeMask");
		}
		if (eyeMaskMaterial == null && eyeMaskShader != null)
		{
			eyeMaskMaterial = new Material(eyeMaskShader);
			eyeMaskMaterial.SetColor("_Color", eyeMaskColor);
		}
		if (eyeMaskMaterial == null)
		{
			base.enabled = false;
			UnityEngine.Debug.LogWarning("EyeMask materil is null or EyeMask shader not found!");
		}
		else
		{
			PrepareCameras();
			Camera.onPreRender = (Camera.CameraCallback)Delegate.Combine(Camera.onPreRender, new Camera.CameraCallback(OnCustomPreRender));
			CreateCommandBuffer();
		}
	}

	private void OnDisable()
	{
		Camera.onPreRender = (Camera.CameraCallback)Delegate.Remove(Camera.onPreRender, new Camera.CameraCallback(OnCustomPreRender));
		foreach (EyeMaskData cameraData in cameraDataList)
		{
			if (cameraData.camera != null && cameraData.cmdBuf != null)
			{
				RemoveCameraCommandBuffer(cameraData);
			}
		}
		CleanEyeMask();
	}

	private void CreateCommandBuffer()
	{
		if (VerifyCommadBuffer())
		{
			return;
		}
		if (eyeMaskMeshLeft == null || eyeMaskMeshRight == null)
		{
			eyeMaskMeshLeft = GetStencilMesh(Eye.LeftEye);
			eyeMaskMeshRight = GetStencilMesh(Eye.RightEye);
			if (eyeMaskMeshLeft == null || eyeMaskMeshRight == null)
			{
				UnityEngine.Debug.LogWarning("Stencil Mesh is not exist, disable EyeMask.");
				base.enabled = false;
				return;
			}
		}
		foreach (EyeMaskData cameraData in cameraDataList)
		{
			if (cameraData.eyeSide == Eye.LeftEye)
			{
				CommandBuffer commandBuffer = new CommandBuffer();
				commandBuffer.name = "EyeMaskLeft";
				commandBuffer.DrawMesh(eyeMaskMeshLeft, Matrix4x4.identity, eyeMaskMaterial, 0, 0);
				cameraData.cmdBuf = commandBuffer;
			}
			else if (cameraData.eyeSide == Eye.RightEye)
			{
				CommandBuffer commandBuffer2 = new CommandBuffer();
				commandBuffer2.name = "EyeMaskRight";
				commandBuffer2.DrawMesh(eyeMaskMeshRight, Matrix4x4.identity, eyeMaskMaterial, 0, 0);
				cameraData.cmdBuf = commandBuffer2;
			}
			else if (cameraData.eyeSide == Eye.BothEye)
			{
				if (eyeMaskMeshBoth == null)
				{
					eyeMaskMeshBoth = GetStencilMeshBoth(eyeMaskMeshLeft, eyeMaskMeshRight);
					float value = Mathf.Max(Mathf.Abs(eyeMaskMeshLeft.bounds.max.x), Mathf.Abs(eyeMaskMeshRight.bounds.min.x));
					eyeMaskMaterial.SetFloat("_MeshOffsetX", value);
				}
				CommandBuffer commandBuffer3 = new CommandBuffer();
				commandBuffer3.name = "EyeMaskBoth";
				commandBuffer3.DrawMesh(eyeMaskMeshBoth, Matrix4x4.identity, eyeMaskMaterial, 0, 1);
				cameraData.cmdBuf = commandBuffer3;
			}
		}
	}

	private void OnCustomPreRender(Camera cam)
	{
		if (!VerifyCommadBuffer())
		{
			UnityEngine.Debug.LogWarning("Verify CommandBuffer failed!");
			return;
		}
		foreach (EyeMaskData cameraData in cameraDataList)
		{
			if (!(cameraData.camera != cam))
			{
				RemoveCameraCommandBuffer(cameraData);
				AddCameraCommandBuffer(cameraData);
			}
		}
	}

	private Mesh GetStencilMesh(Eye eyeSide)
	{
		int vertexCount = 0;
		int triangleCount = 0;
		IntPtr vertexDataPtr = IntPtr.Zero;
		IntPtr indexDataPtr = IntPtr.Zero;
		Render.UPvr_GetStencilMesh((int)eyeSide, ref vertexCount, ref triangleCount, ref vertexDataPtr, ref indexDataPtr);
		if (vertexCount <= 0 || triangleCount <= 0 || vertexDataPtr == IntPtr.Zero || indexDataPtr == IntPtr.Zero)
		{
			return null;
		}
		Vector3[] array = new Vector3[vertexCount];
		int[] array2 = new int[triangleCount * 3];
		float[] array3 = new float[vertexCount * 3];
		int[] array4 = new int[triangleCount * 3];
		Marshal.Copy(vertexDataPtr, array3, 0, vertexCount * 3);
		Marshal.Copy(indexDataPtr, array4, 0, triangleCount * 3);
		for (int i = 0; i < vertexCount; i++)
		{
			array[i] = new Vector3(array3[3 * i], array3[3 * i + 1], zDir);
		}
		for (int j = 0; j < triangleCount; j++)
		{
			array2[3 * j] = array4[3 * j + 2];
			array2[3 * j + 1] = array4[3 * j + 1];
			array2[3 * j + 2] = array4[3 * j];
		}
		Mesh mesh = new Mesh();
		mesh.name = "EyeMaskMesh";
		mesh.vertices = array;
		mesh.SetIndices(array2, MeshTopology.Triangles, 0);
		return mesh;
	}

	private Mesh GetStencilMeshBoth(Mesh leftMesh, Mesh rightMesh)
	{
		float num = Mathf.Max(Mathf.Abs(leftMesh.bounds.max.x), Mathf.Abs(rightMesh.bounds.min.x));
		Mesh mesh = new Mesh();
		mesh.name = "EyeMaskBoth";
		CombineInstance combineInstance = default(CombineInstance);
		combineInstance.mesh = leftMesh;
		Matrix4x4 identity = Matrix4x4.identity;
		identity.SetTRS(Vector3.left * num, Quaternion.identity, Vector3.one);
		combineInstance.transform = identity;
		CombineInstance combineInstance2 = default(CombineInstance);
		combineInstance2.mesh = rightMesh;
		Matrix4x4 identity2 = Matrix4x4.identity;
		identity2.SetTRS(Vector3.right * num, Quaternion.identity, Vector3.one);
		combineInstance2.transform = identity2;
		CombineInstance[] combine = new CombineInstance[2] { combineInstance, combineInstance2 };
		mesh.CombineMeshes(combine);
		return mesh;
	}

	private bool VerifyCommadBuffer()
	{
		if (cameraDataList == null || cameraDataList.Count <= 0)
		{
			return false;
		}
		foreach (EyeMaskData cameraData in cameraDataList)
		{
			if (cameraData == null || cameraData.cmdBuf == null)
			{
				return false;
			}
		}
		return true;
	}

	private void PrepareCameras()
	{
		cameraDataList.Clear();
		if (Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.SinglePass)
		{
			if (Pvr_UnitySDKEyeManager.Instance.BothEyeCamera == null)
			{
				UnityEngine.Debug.LogWarning("BothEye Camera is null!");
				return;
			}
			EyeMaskData eyeMaskData = new EyeMaskData();
			eyeMaskData.eyeSide = Eye.BothEye;
			eyeMaskData.camera = Pvr_UnitySDKEyeManager.Instance.BothEyeCamera;
			cameraDataList.Add(eyeMaskData);
		}
		else if (Pvr_UnitySDKEyeManager.Instance.LeftEyeCamera == null || Pvr_UnitySDKEyeManager.Instance.RightEyeCamera == null)
		{
			UnityEngine.Debug.LogWarning("LeftEye or RightEye Camera is null!");
		}
		else
		{
			EyeMaskData eyeMaskData2 = new EyeMaskData();
			eyeMaskData2.eyeSide = Eye.LeftEye;
			eyeMaskData2.camera = Pvr_UnitySDKEyeManager.Instance.LeftEyeCamera;
			eyeMaskData2.cmdBuf = null;
			cameraDataList.Add(eyeMaskData2);
			EyeMaskData eyeMaskData3 = new EyeMaskData();
			eyeMaskData3.eyeSide = Eye.RightEye;
			eyeMaskData3.camera = Pvr_UnitySDKEyeManager.Instance.RightEyeCamera;
			eyeMaskData3.cmdBuf = null;
			cameraDataList.Add(eyeMaskData3);
		}
	}

	private void AddCameraCommandBuffer(EyeMaskData data)
	{
		data.camera.AddCommandBuffer(CameraEvent.BeforeForwardOpaque, data.cmdBuf);
	}

	private void RemoveCameraCommandBuffer(EyeMaskData data)
	{
		data.camera.RemoveCommandBuffer(CameraEvent.BeforeForwardOpaque, data.cmdBuf);
	}

	private void CleanEyeMask()
	{
		cameraDataList.Clear();
		eyeMaskMeshLeft = null;
		eyeMaskMeshRight = null;
		eyeMaskMeshBoth = null;
		eyeMaskShader = null;
		eyeMaskMaterial = null;
	}
}
[RequireComponent(typeof(Camera))]
public class Pvr_UnitySDKEye : MonoBehaviour
{
	public static List<Pvr_UnitySDKEye> Instances = new List<Pvr_UnitySDKEye>();

	public Eye eyeSide;

	private int eyeCameraOriginCullingMask;

	private CameraClearFlags eyeCameraOriginClearFlag;

	private Color eyeCameraOriginBackgroundColor;

	private int lastBoundaryState;

	private Matrix4x4 realProj = Matrix4x4.identity;

	private const int bufferSize = 3;

	private int IDIndex;

	private RenderEventType eventType;

	private int previousId;

	public static bool setLevel = false;

	private Material mat_Vignette;

	public Camera eyecamera { get; private set; }

	private void Awake()
	{
		Instances.Add(this);
		eyecamera = GetComponent<Camera>();
	}

	private void Start()
	{
		Setup(eyeSide);
		SetupUpdate();
		if (eyecamera != null)
		{
			eyeCameraOriginCullingMask = eyecamera.cullingMask;
			eyeCameraOriginClearFlag = eyecamera.clearFlags;
			eyeCameraOriginBackgroundColor = eyecamera.backgroundColor;
		}
	}

	private void Update()
	{
		if (!(eyecamera != null) || !eyecamera.enabled)
		{
			return;
		}
		int num = BoundarySystem.UPvr_GetSeeThroughState();
		if (num == lastBoundaryState)
		{
			return;
		}
		switch (num)
		{
		case 2:
			eyeCameraOriginCullingMask = eyecamera.cullingMask;
			eyeCameraOriginClearFlag = eyecamera.clearFlags;
			eyeCameraOriginBackgroundColor = eyecamera.backgroundColor;
			eyecamera.cullingMask = 0;
			eyecamera.clearFlags = CameraClearFlags.Color;
			eyecamera.backgroundColor = Color.black;
			break;
		case 1:
			if (lastBoundaryState == 2)
			{
				if (eyecamera.cullingMask == 0)
				{
					eyecamera.cullingMask = eyeCameraOriginCullingMask;
				}
				if (eyecamera.clearFlags == CameraClearFlags.Color)
				{
					eyecamera.clearFlags = eyeCameraOriginClearFlag;
				}
				if (eyecamera.backgroundColor == Color.black)
				{
					eyecamera.backgroundColor = eyeCameraOriginBackgroundColor;
				}
			}
			break;
		default:
			if (lastBoundaryState == 2 || lastBoundaryState == 1)
			{
				if (eyecamera.cullingMask == 0)
				{
					eyecamera.cullingMask = eyeCameraOriginCullingMask;
				}
				if (eyecamera.clearFlags == CameraClearFlags.Color)
				{
					eyecamera.clearFlags = eyeCameraOriginClearFlag;
				}
				if (eyecamera.backgroundColor == Color.black)
				{
					eyecamera.backgroundColor = eyeCameraOriginBackgroundColor;
				}
			}
			break;
		}
		lastBoundaryState = num;
	}

	private void OnEnable()
	{
		if (GraphicsSettings.renderPipelineAsset != null)
		{
			RenderPipelineManager.beginCameraRendering += MyPreRender;
			RenderPipelineManager.endCameraRendering += MyPostRender;
		}
	}

	private void OnDisable()
	{
		if (GraphicsSettings.renderPipelineAsset != null)
		{
			RenderPipelineManager.beginCameraRendering -= MyPreRender;
			RenderPipelineManager.endCameraRendering -= MyPostRender;
		}
	}

	private void OnDestroy()
	{
		Instances.Remove(this);
	}

	public void MyPreRender(Camera camera)
	{
		if (!(camera.gameObject != base.gameObject))
		{
			OnPreRender();
		}
	}

	public void MyPreRender(ScriptableRenderContext context, Camera camera)
	{
		if (!(camera.gameObject != base.gameObject))
		{
			OnPreRender();
		}
	}

	public void MyPostRender(ScriptableRenderContext context, Camera camera)
	{
		if (!(camera.gameObject != base.gameObject))
		{
			OnPostRender();
		}
	}

	private void OnPreRender()
	{
		if (!eyecamera.enabled)
		{
			return;
		}
		if (Pvr_UnitySDKRender.Instance.StereoRendering != null)
		{
			if (Pvr_UnitySDKRender.Instance.isSwitchSDK)
			{
				return;
			}
			Pvr_UnitySDKRender.Instance.StereoRendering.OnSDKPreRender();
		}
		SetFFRParameter();
		Pvr_UnitySDKPluginEvent.Issue(RenderEventType.BeginEye);
	}

	private void OnPostRender()
	{
		if (!eyecamera.enabled)
		{
			return;
		}
		Pvr_UnitySDKAPI.System.UPvr_UnityEventData(Pvr_UnitySDKAPI.System.UPvr_GetEyeBufferData(Pvr_UnitySDKRender.Instance.eyeTextureIds[IDIndex]));
		Pvr_UnitySDKPluginEvent.Issue(eventType);
		if (Pvr_UnitySDKRender.Instance.StereoRendering != null)
		{
			if (Pvr_UnitySDKRender.Instance.isSwitchSDK)
			{
				return;
			}
			Pvr_UnitySDKRender.Instance.StereoRendering.OnSDKPostRender();
		}
		Pvr_UnitySDKPluginEvent.Issue(RenderEventType.EndEye);
	}

	public void EyeRender()
	{
		SetupUpdate();
		if (Pvr_UnitySDKRender.Instance.eyeTextures[IDIndex] != null)
		{
			Pvr_UnitySDKRender.Instance.eyeTextures[IDIndex].DiscardContents();
			eyecamera.targetTexture = Pvr_UnitySDKRender.Instance.eyeTextures[IDIndex];
		}
	}

	private void Setup(Eye eyeSide)
	{
		eyecamera = GetComponent<Camera>();
		switch (eyeSide)
		{
		case Eye.LeftEye:
		case Eye.RightEye:
			base.transform.localPosition = Pvr_UnitySDKManager.SDK.EyeOffset(eyeSide);
			break;
		case Eye.BothEye:
			base.transform.localPosition = Vector3.zero;
			break;
		}
		eyecamera.aspect = Pvr_UnitySDKManager.SDK.EyesAspect;
		eyecamera.rect = new Rect(0f, 0f, 1f, 1f);
		if (Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.MultiPass)
		{
			eventType = ((eyeSide == Eye.LeftEye) ? RenderEventType.LeftEyeEndFrame : RenderEventType.RightEyeEndFrame);
		}
		else
		{
			eventType = RenderEventType.BothEyeEndFrame;
		}
	}

	private void SetupUpdate()
	{
		if (eyeSide == Eye.LeftEye || eyeSide == Eye.RightEye)
		{
			eyecamera.enabled = !Pvr_UnitySDKManager.SDK.Monoscopic && Pvr_UnitySDKRender.Instance.StereoRenderPath != StereoRenderingPathPico.SinglePass;
		}
		else if (eyeSide == Eye.BothEye)
		{
			eyecamera.enabled = Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.SinglePass;
		}
		eyecamera.fieldOfView = Pvr_UnitySDKRender.Instance.EyeVFoV;
		eyecamera.aspect = Pvr_UnitySDKManager.SDK.EyesAspect;
		if (eyeSide == Eye.LeftEye || eyeSide == Eye.RightEye)
		{
			IDIndex = Pvr_UnitySDKRender.Instance.currEyeTextureIdx + (int)eyeSide * 3;
		}
		else if (eyeSide == Eye.BothEye)
		{
			IDIndex = Pvr_UnitySDKRender.Instance.currEyeTextureIdx;
			Pvr_UnitySDKRender.Instance.isSwitchSDK = Pvr_UnitySDKRender.Instance.lastEyeTextureIdx == Pvr_UnitySDKRender.Instance.currEyeTextureIdx;
			Pvr_UnitySDKRender.Instance.lastEyeTextureIdx = Pvr_UnitySDKRender.Instance.currEyeTextureIdx;
		}
	}

	public void RefreshCameraPosition(float ipd)
	{
		Pvr_UnitySDKManager.SDK.leftEyeOffset = new Vector3((0f - ipd) / 2f, 0f, 0f);
		Pvr_UnitySDKManager.SDK.rightEyeOffset = new Vector3(ipd / 2f, 0f, 0f);
		if (eyeSide == Eye.LeftEye || eyeSide == Eye.RightEye)
		{
			base.transform.localPosition = Pvr_UnitySDKManager.SDK.EyeOffset(eyeSide);
		}
		else if (eyeSide == Eye.BothEye)
		{
			eyecamera.stereoSeparation = ipd;
		}
	}

	private void DrawVignetteLine()
	{
		if (null == mat_Vignette)
		{
			mat_Vignette = new Material(Shader.Find("Diffuse"));
			if (null == mat_Vignette)
			{
				return;
			}
		}
		GL.PushMatrix();
		mat_Vignette.SetPass(0);
		GL.LoadOrtho();
		vignette();
		GL.PopMatrix();
	}

	private void vignette()
	{
		GL.Begin(7);
		GL.Color(Color.black);
		GL.Vertex3(0f, 1f, 0f);
		GL.Vertex3(1f, 1f, 0f);
		GL.Vertex3(1f, 0.995f, 0f);
		GL.Vertex3(0f, 0.995f, 0f);
		GL.Vertex3(0f, 0f, 0f);
		GL.Vertex3(0f, 0.005f, 0f);
		GL.Vertex3(1f, 0.005f, 0f);
		GL.Vertex3(1f, 0f, 0f);
		GL.Vertex(new Vector3(0f, 1f, 0f));
		GL.Vertex(new Vector3(0.005f, 1f, 0f));
		GL.Vertex(new Vector3(0.005f, 0f, 0f));
		GL.Vertex(new Vector3(0f, 0f, 0f));
		GL.Vertex(new Vector3(0.995f, 1f, 0f));
		GL.Vertex(new Vector3(1f, 1f, 0f));
		GL.Vertex(new Vector3(1f, 0f, 0f));
		GL.Vertex(new Vector3(0.995f, 0f, 0f));
		GL.End();
	}

	private void SetFFRParameter()
	{
		Vector3 vector = Vector3.zero;
		if (Pvr_UnitySDKManager.SDK.isEnterVRMode && Pvr_UnitySDKEyeManager.supportEyeTracking && Pvr_UnitySDKEyeManager.Instance.EyeTracking)
		{
			vector = Pvr_UnitySDKAPI.System.UPvr_getEyeTrackingPos();
		}
		int textureId = Pvr_UnitySDKRender.Instance.eyeTextureIds[IDIndex];
		Render.UPvr_SetFoveationResource(textureId, previousId, vector.x, vector.y);
		previousId = textureId;
	}
}
public class Pvr_UnitySDKEyeManager : MonoBehaviour
{
	private static Pvr_UnitySDKEyeManager instance;

	private Pvr_UnitySDKEye[] eyes;

	[HideInInspector]
	public Camera LeftEyeCamera;

	[HideInInspector]
	public Camera RightEyeCamera;

	[HideInInspector]
	public Camera MonoEyeCamera;

	[HideInInspector]
	public Camera BothEyeCamera;

	private int MonoEyeTextureID;

	private readonly int WaitSplashScreenFrames = 3;

	private int frameNum;

	[SerializeField]
	[HideInInspector]
	private bool foveatedRendering;

	[SerializeField]
	[HideInInspector]
	private EFoveationLevel foveationLevel;

	private int eyeTextureId;

	private RenderEventType eventType = RenderEventType.LeftEyeEndFrame;

	private Pvr_UnitySDKEyeOverlay compositeLayer;

	private int overlayLayerDepth = 1;

	private int underlayLayerDepth;

	private bool isHeadLocked;

	private int layerFlags;

	[HideInInspector]
	public bool EyeTracking;

	[HideInInspector]
	public Vector3 eyePoint;

	private EyeTrackingData eyePoseData;

	[HideInInspector]
	public static bool supportEyeTracking;

	[Tooltip("If true, specific color gradient when switching scenes.")]
	public bool screenFade;

	[Tooltip("Define the duration of screen fade.")]
	public float fadeTime = 5f;

	[Tooltip("Define the color of screen fade.")]
	public Color fadeColor = new Color(0f, 0f, 0f, 1f);

	public int renderQueue = 5000;

	private MeshRenderer fadeMeshRenderer;

	private MeshFilter fadeMeshFilter;

	private Material fadeMaterial;

	private float elapsedTime;

	private bool isFading;

	private float currentAlpha;

	private float nowFadeAlpha;

	public static Pvr_UnitySDKEyeManager Instance
	{
		get
		{
			if (instance == null)
			{
				PLOG.E("Pvr_UnitySDKEyeManager instance is not init yet...");
			}
			return instance;
		}
	}

	public Pvr_UnitySDKEye[] Eyes
	{
		get
		{
			if (eyes == null)
			{
				eyes = Pvr_UnitySDKEye.Instances.ToArray();
			}
			return eyes;
		}
	}

	[HideInInspector]
	public bool FoveatedRendering
	{
		get
		{
			return foveatedRendering;
		}
		set
		{
			if (value == foveatedRendering)
			{
				return;
			}
			foveatedRendering = value;
			if (Application.isPlaying)
			{
				Render.UPvr_EnableFoveation(enable: true);
				if (!foveatedRendering)
				{
					Render.SetFoveatedRenderingLevel((EFoveationLevel)(-1));
				}
			}
		}
	}

	[HideInInspector]
	public EFoveationLevel FoveationLevel
	{
		get
		{
			return foveationLevel;
		}
		set
		{
			if (value != foveationLevel)
			{
				foveationLevel = value;
			}
		}
	}

	private void SetCameraEnableEditor()
	{
		MonoEyeCamera.enabled = !Pvr_UnitySDKManager.SDK.VRModeEnabled || Pvr_UnitySDKManager.SDK.Monoscopic;
		for (int i = 0; i < Eyes.Length; i++)
		{
			if (Eyes[i].eyeSide == Eye.LeftEye || Eyes[i].eyeSide == Eye.RightEye)
			{
				Eyes[i].eyecamera.enabled = Pvr_UnitySDKManager.SDK.VRModeEnabled;
			}
			else if (Eyes[i].eyeSide == Eye.BothEye)
			{
				Eyes[i].eyecamera.enabled = false;
			}
		}
	}

	private void SetCamerasEnableByStereoRendering()
	{
		MonoEyeCamera.enabled = Pvr_UnitySDKManager.SDK.Monoscopic && Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.MultiPass;
	}

	private void SetupMonoCamera()
	{
		base.transform.localPosition = Vector3.zero;
		MonoEyeCamera.aspect = Pvr_UnitySDKManager.SDK.EyesAspect;
		MonoEyeCamera.rect = new Rect(0f, 0f, 1f, 1f);
	}

	private void SetupUpdate()
	{
		MonoEyeCamera.fieldOfView = Pvr_UnitySDKRender.Instance.EyeVFoV;
		MonoEyeCamera.aspect = Pvr_UnitySDKManager.SDK.EyesAspect;
		MonoEyeTextureID = Pvr_UnitySDKRender.Instance.currEyeTextureIdx;
	}

	private void MonoEyeRender()
	{
		SetupUpdate();
		if (Pvr_UnitySDKRender.Instance.eyeTextures[MonoEyeTextureID] != null)
		{
			Pvr_UnitySDKRender.Instance.eyeTextures[MonoEyeTextureID].DiscardContents();
			MonoEyeCamera.targetTexture = Pvr_UnitySDKRender.Instance.eyeTextures[MonoEyeTextureID];
		}
	}

	private void Awake()
	{
		if (MonoEyeCamera == null)
		{
			MonoEyeCamera = GetComponent<Camera>();
		}
		if (LeftEyeCamera == null)
		{
			LeftEyeCamera = base.gameObject.transform.Find("LeftEye").GetComponent<Camera>();
		}
		if (RightEyeCamera == null)
		{
			RightEyeCamera = base.gameObject.transform.Find("RightEye").GetComponent<Camera>();
		}
		if (BothEyeCamera == null)
		{
			BothEyeCamera = base.gameObject.transform.Find("BothEye").GetComponent<Camera>();
		}
		if (BothEyeCamera != null)
		{
			BothEyeCamera.transform.GetComponent<Pvr_UnitySDKEye>().eyeSide = Eye.BothEye;
		}
		CreateFadeMesh();
		SetCurrentAlpha(0f);
		Render.UPvr_EnableFoveation(enable: true);
		if (foveatedRendering)
		{
			Render.SetFoveatedRenderingLevel(foveationLevel);
		}
		else
		{
			Render.SetFoveatedRenderingLevel((EFoveationLevel)(-1));
		}
		Pvr_UnitySDKManager.eventEnterVRMode = (Func<bool>)Delegate.Combine(Pvr_UnitySDKManager.eventEnterVRMode, new Func<bool>(SetEyeTrackingMode));
	}

	private void OnEnable()
	{
		if (instance == null)
		{
			instance = this;
		}
		else if (instance != this)
		{
			instance = this;
		}
		if (Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.SinglePass)
		{
			Pvr_UnitySDKRender.Instance.StereoRendering.InitEye(BothEyeCamera);
		}
		foreach (Pvr_UnitySDKEyeOverlay instance in Pvr_UnitySDKEyeOverlay.Instances)
		{
			instance.RefreshCamera();
			if (instance.overlayType == Pvr_UnitySDKEyeOverlay.OverlayType.Overlay)
			{
				if (instance.overlayShape == Pvr_UnitySDKEyeOverlay.OverlayShape.Cylinder)
				{
					UnityEngine.Debug.Log("DISFT Cylinder OverLay = Enable");
				}
				if (instance.overlayShape == Pvr_UnitySDKEyeOverlay.OverlayShape.Equirect)
				{
					UnityEngine.Debug.Log("DISFT 360 OverLay= Enable");
				}
				if (instance.overlayShape == Pvr_UnitySDKEyeOverlay.OverlayShape.Quad)
				{
					UnityEngine.Debug.Log("DISFT 2D OverLay= Enable");
				}
			}
			if (instance.overlayType == Pvr_UnitySDKEyeOverlay.OverlayType.Underlay)
			{
				UnityEngine.Debug.Log("DISFT UnderLay= Enable");
			}
		}
		GfxDeviceAdvanceFrameGLES();
		StartCoroutine("EndOfFrame");
		if (screenFade)
		{
			StartCoroutine(ScreenFade(1f, 0f));
		}
		if (GraphicsSettings.renderPipelineAsset != null)
		{
			RenderPipelineManager.endCameraRendering += MyPostRender;
		}
	}

	private void Start()
	{
		SetCamerasEnableByStereoRendering();
		SetupMonoCamera();
	}

	private void Update()
	{
		if (Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.SinglePass)
		{
			for (int i = 0; i < Eyes.Length; i++)
			{
				if (Eyes[i].isActiveAndEnabled && Eyes[i].eyeSide == Eye.BothEye)
				{
					Eyes[i].EyeRender();
				}
			}
		}
		if (Pvr_UnitySDKRender.Instance.StereoRenderPath != 0)
		{
			return;
		}
		if (!Pvr_UnitySDKManager.SDK.Monoscopic)
		{
			for (int j = 0; j < Eyes.Length; j++)
			{
				if (Eyes[j].isActiveAndEnabled && Eyes[j].eyeSide != Eye.BothEye)
				{
					Eyes[j].EyeRender();
				}
			}
		}
		else
		{
			MonoEyeRender();
		}
	}

	private void OnPause()
	{
		Pvr_UnitySDKManager.eventEnterVRMode = (Func<bool>)Delegate.Remove(Pvr_UnitySDKManager.eventEnterVRMode, new Func<bool>(SetEyeTrackingMode));
	}

	public void MyPostRender(ScriptableRenderContext context, Camera camera)
	{
		if (!(camera.gameObject != base.gameObject))
		{
			OnPostRender();
		}
	}

	private void OnDisable()
	{
		StopAllCoroutines();
		if (GraphicsSettings.renderPipelineAsset != null)
		{
			RenderPipelineManager.endCameraRendering -= MyPostRender;
		}
	}

	private void OnDestroy()
	{
		DestoryFadeMesh();
	}

	private void OnPostRender()
	{
		long data = Pvr_UnitySDKAPI.System.UPvr_GetEyeBufferData(Pvr_UnitySDKRender.Instance.eyeTextureIds[Pvr_UnitySDKRender.Instance.currEyeTextureIdx]);
		Pvr_UnitySDKAPI.System.UPvr_UnityEventData(data);
		Pvr_UnitySDKPluginEvent.Issue(RenderEventType.LeftEyeEndFrame);
		Pvr_UnitySDKAPI.System.UPvr_UnityEventData(data);
		Pvr_UnitySDKPluginEvent.Issue(RenderEventType.RightEyeEndFrame);
	}

	private IEnumerator EndOfFrame()
	{
		while (true)
		{
			yield return new WaitForEndOfFrame();
			if (!Pvr_UnitySDKManager.SDK.isEnterVRMode)
			{
				GL.Clear(clearDepth: false, clearColor: true, Color.black);
			}
			if (Pvr_UnitySDKRender.Instance.isFirstStartup && frameNum == WaitSplashScreenFrames)
			{
				Pvr_UnitySDKAPI.System.UPvr_RemovePlatformLogo();
				if (Pvr_UnitySDKManager.SDK.ResetTrackerOnLoad)
				{
					UnityEngine.Debug.Log("Reset Tracker OnLoad");
					Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 1);
				}
				Pvr_UnitySDKAPI.System.UPvr_StartVRModel();
				Pvr_UnitySDKRender.Instance.isFirstStartup = false;
			}
			else if (Pvr_UnitySDKRender.Instance.isFirstStartup && frameNum < WaitSplashScreenFrames)
			{
				PLOG.I("frameNum:" + frameNum);
				frameNum++;
			}
			int num = BoundarySystem.UPvr_GetSeeThroughState();
			if (Pvr_UnitySDKEyeOverlay.Instances.Count > 0 && num != 2)
			{
				overlayLayerDepth = 1;
				underlayLayerDepth = 0;
				Pvr_UnitySDKEyeOverlay.Instances.Sort();
				for (int i = 0; i < Pvr_UnitySDKEyeOverlay.Instances.Count; i++)
				{
					compositeLayer = Pvr_UnitySDKEyeOverlay.Instances[i];
					if (!compositeLayer.isActiveAndEnabled || (compositeLayer.layerTextures[0] == null && compositeLayer.layerTextures[1] == null && !compositeLayer.isExternalAndroidSurface) || (compositeLayer.layerTransform != null && !compositeLayer.layerTransform.gameObject.activeSelf))
					{
						continue;
					}
					layerFlags = 0;
					if (compositeLayer.overlayShape == Pvr_UnitySDKEyeOverlay.OverlayShape.Quad || compositeLayer.overlayShape == Pvr_UnitySDKEyeOverlay.OverlayShape.Cylinder)
					{
						if (compositeLayer.overlayType == Pvr_UnitySDKEyeOverlay.OverlayType.Overlay)
						{
							isHeadLocked = false;
							if (compositeLayer.layerTransform != null && compositeLayer.layerTransform.parent == base.transform)
							{
								isHeadLocked = true;
							}
							if (compositeLayer.isExternalAndroidSurface)
							{
								layerFlags |= 1;
								CreateExternalSurface(compositeLayer, overlayLayerDepth);
							}
							Render.UPvr_SetOverlayModelViewMatrix((int)compositeLayer.overlayType, (int)compositeLayer.overlayShape, compositeLayer.layerTextureIds[0], 0, overlayLayerDepth, isHeadLocked, layerFlags, compositeLayer.MVMatrixs[0], compositeLayer.ModelScales[0], compositeLayer.ModelRotations[0], compositeLayer.ModelTranslations[0], compositeLayer.CameraRotations[0], compositeLayer.CameraTranslations[0], compositeLayer.GetLayerColorScale(), compositeLayer.GetLayerColorOffset());
							Render.UPvr_SetOverlayModelViewMatrix((int)compositeLayer.overlayType, (int)compositeLayer.overlayShape, compositeLayer.layerTextureIds[1], 1, overlayLayerDepth, isHeadLocked, layerFlags, compositeLayer.MVMatrixs[1], compositeLayer.ModelScales[1], compositeLayer.ModelRotations[1], compositeLayer.ModelTranslations[1], compositeLayer.CameraRotations[1], compositeLayer.CameraTranslations[1], compositeLayer.GetLayerColorScale(), compositeLayer.GetLayerColorOffset());
							overlayLayerDepth++;
						}
						else if (compositeLayer.overlayType == Pvr_UnitySDKEyeOverlay.OverlayType.Underlay)
						{
							if (compositeLayer.isExternalAndroidSurface)
							{
								layerFlags |= 1;
								CreateExternalSurface(compositeLayer, underlayLayerDepth);
							}
							Render.UPvr_SetOverlayModelViewMatrix((int)compositeLayer.overlayType, (int)compositeLayer.overlayShape, compositeLayer.layerTextureIds[0], 0, underlayLayerDepth, isHeadLocked: false, layerFlags, compositeLayer.MVMatrixs[0], compositeLayer.ModelScales[0], compositeLayer.ModelRotations[0], compositeLayer.ModelTranslations[0], compositeLayer.CameraRotations[0], compositeLayer.CameraTranslations[0], compositeLayer.GetLayerColorScale(), compositeLayer.GetLayerColorOffset());
							Render.UPvr_SetOverlayModelViewMatrix((int)compositeLayer.overlayType, (int)compositeLayer.overlayShape, compositeLayer.layerTextureIds[1], 1, underlayLayerDepth, isHeadLocked: false, layerFlags, compositeLayer.MVMatrixs[1], compositeLayer.ModelScales[1], compositeLayer.ModelRotations[1], compositeLayer.ModelTranslations[1], compositeLayer.CameraRotations[1], compositeLayer.CameraTranslations[1], compositeLayer.GetLayerColorScale(), compositeLayer.GetLayerColorOffset());
							underlayLayerDepth++;
						}
					}
					else if (compositeLayer.overlayShape == Pvr_UnitySDKEyeOverlay.OverlayShape.Equirect)
					{
						if (compositeLayer.isExternalAndroidSurface)
						{
							layerFlags |= 1;
							CreateExternalSurface(compositeLayer, 0);
						}
						Render.UPvr_SetupLayerData(0, 0, compositeLayer.layerTextureIds[0], (int)compositeLayer.overlayShape, layerFlags, compositeLayer.GetLayerColorScale(), compositeLayer.GetLayerColorOffset());
						Render.UPvr_SetupLayerData(0, 1, compositeLayer.layerTextureIds[1], (int)compositeLayer.overlayShape, layerFlags, compositeLayer.GetLayerColorScale(), compositeLayer.GetLayerColorOffset());
					}
				}
			}
			Pvr_UnitySDKAPI.System.UPvr_UnityEventData(Pvr_UnitySDKAPI.System.UPvr_GetEyeBufferData(0));
			Pvr_UnitySDKPluginEvent.Issue(RenderEventType.TimeWarp);
			Pvr_UnitySDKRender.Instance.currEyeTextureIdx = Pvr_UnitySDKRender.Instance.nextEyeTextureIdx;
			Pvr_UnitySDKRender.Instance.nextEyeTextureIdx = (Pvr_UnitySDKRender.Instance.nextEyeTextureIdx + 1) % 3;
		}
	}

	private void CreateExternalSurface(Pvr_UnitySDKEyeOverlay overlayInstance, int layerDepth)
	{
		if (overlayInstance.externalAndroidSurfaceObject == IntPtr.Zero)
		{
			overlayInstance.externalAndroidSurfaceObject = Render.UPvr_CreateLayerAndroidSurface((int)overlayInstance.overlayType, layerDepth);
			UnityEngine.Debug.LogFormat("CreateExternalSurface: Overlay Type:{0}, LayerDepth:{1}, SurfaceObject:{2}", overlayInstance.overlayType, layerDepth, overlayInstance.externalAndroidSurfaceObject);
			if (overlayInstance.externalAndroidSurfaceObject != IntPtr.Zero && overlayInstance.externalAndroidSurfaceObjectCreated != null)
			{
				overlayInstance.externalAndroidSurfaceObjectCreated();
			}
		}
	}

	public bool SetEyeTrackingMode()
	{
		supportEyeTracking = (Pvr_UnitySDKAPI.System.UPvr_GetTrackingMode() & 4) != 0;
		bool result = false;
		if (EyeTracking && supportEyeTracking)
		{
			result = Pvr_UnitySDKAPI.System.UPvr_setTrackingMode(6);
		}
		UnityEngine.Debug.Log("SetEyeTrackingMode EyeTracking " + EyeTracking + " supportEyeTracking " + supportEyeTracking + " result " + result);
		return result;
	}

	public Vector3 GetEyeTrackingPos()
	{
		if (!Instance.EyeTracking)
		{
			return Vector3.zero;
		}
		bool flag = Pvr_UnitySDKAPI.System.UPvr_getEyeTrackingData(ref eyePoseData);
		if (!flag)
		{
			PLOG.E("UPvr_getEyeTrackingData failed " + flag);
			return Vector3.zero;
		}
		EyeDeviceInfo deviceInfo = GetDeviceInfo();
		Vector3 zero = Vector3.zero;
		zero.x = 0.5f * (deviceInfo.targetFrustumLeft.right - deviceInfo.targetFrustumLeft.left);
		zero.y = 0.5f * (deviceInfo.targetFrustumLeft.top - deviceInfo.targetFrustumLeft.bottom);
		zero.z = deviceInfo.targetFrustumLeft.near;
		Vector3 foveatedGazeDirection = eyePoseData.foveatedGazeDirection;
		float num = Vector3.Dot(foveatedGazeDirection, Vector3.forward);
		if (num > float.Epsilon)
		{
			eyePoint = foveatedGazeDirection * (zero.z / num);
			eyePoint.x /= zero.x;
			eyePoint.y /= zero.y;
		}
		return eyePoint;
	}

	private EyeDeviceInfo GetDeviceInfo()
	{
		float num = Mathf.Tan(Pvr_UnitySDKRender.Instance.EyeVFoV / 2f * ((float)Math.PI / 180f));
		float num2 = Mathf.Tan(Pvr_UnitySDKRender.Instance.EyeHFoV / 2f * ((float)Math.PI / 180f));
		EyeDeviceInfo result = default(EyeDeviceInfo);
		result.targetFrustumLeft.left = 0f - LeftEyeCamera.nearClipPlane * num2;
		result.targetFrustumLeft.right = LeftEyeCamera.nearClipPlane * num2;
		result.targetFrustumLeft.top = LeftEyeCamera.nearClipPlane * num;
		result.targetFrustumLeft.bottom = 0f - LeftEyeCamera.nearClipPlane * num;
		result.targetFrustumLeft.near = LeftEyeCamera.nearClipPlane;
		result.targetFrustumLeft.far = LeftEyeCamera.farClipPlane;
		result.targetFrustumRight.left = 0f - RightEyeCamera.nearClipPlane * num2;
		result.targetFrustumRight.right = RightEyeCamera.nearClipPlane * num2;
		result.targetFrustumRight.top = RightEyeCamera.nearClipPlane * num;
		result.targetFrustumRight.bottom = 0f - RightEyeCamera.nearClipPlane * num;
		result.targetFrustumRight.near = RightEyeCamera.nearClipPlane;
		result.targetFrustumRight.far = RightEyeCamera.farClipPlane;
		return result;
	}

	private void CreateFadeMesh()
	{
		fadeMaterial = new Material(Shader.Find("Pvr_UnitySDK/Fade"));
		fadeMeshFilter = base.gameObject.AddComponent<MeshFilter>();
		fadeMeshRenderer = base.gameObject.AddComponent<MeshRenderer>();
		Mesh mesh = new Mesh();
		fadeMeshFilter.mesh = mesh;
		Vector3[] array = new Vector3[4];
		float num = 2f;
		float num2 = 2f;
		float z = 1f;
		array[0] = new Vector3(0f - num, 0f - num2, z);
		array[1] = new Vector3(num, 0f - num2, z);
		array[2] = new Vector3(0f - num, num2, z);
		array[3] = new Vector3(num, num2, z);
		mesh.vertices = array;
		mesh.triangles = new int[6] { 0, 2, 1, 2, 3, 1 };
		mesh.normals = new Vector3[4]
		{
			-Vector3.forward,
			-Vector3.forward,
			-Vector3.forward,
			-Vector3.forward
		};
		mesh.uv = new Vector2[4]
		{
			new Vector2(0f, 0f),
			new Vector2(1f, 0f),
			new Vector2(0f, 1f),
			new Vector2(1f, 1f)
		};
	}

	private void DestoryFadeMesh()
	{
		if (fadeMeshRenderer != null)
		{
			UnityEngine.Object.Destroy(fadeMeshRenderer);
		}
		if (fadeMaterial != null)
		{
			UnityEngine.Object.Destroy(fadeMaterial);
		}
		if (fadeMeshFilter != null)
		{
			UnityEngine.Object.Destroy(fadeMeshFilter);
		}
	}

	public void SetCurrentAlpha(float alpha)
	{
		currentAlpha = alpha;
		SetMaterialAlpha();
	}

	private IEnumerator ScreenFade(float startAlpha, float endAlpha)
	{
		float elapsedTime = 0f;
		while (elapsedTime < fadeTime)
		{
			elapsedTime += Time.deltaTime;
			nowFadeAlpha = Mathf.Lerp(startAlpha, endAlpha, Mathf.Clamp01(elapsedTime / fadeTime));
			SetMaterialAlpha();
			yield return new WaitForEndOfFrame();
		}
	}

	private void SetMaterialAlpha()
	{
		Color color = fadeColor;
		color.a = Mathf.Max(currentAlpha, nowFadeAlpha);
		isFading = color.a > 0f;
		if (fadeMaterial != null)
		{
			fadeMaterial.color = color;
			fadeMaterial.renderQueue = renderQueue;
			fadeMeshRenderer.material = fadeMaterial;
			fadeMeshRenderer.enabled = isFading;
		}
	}

	public bool GfxDeviceAdvanceFrameGLES()
	{
		MethodInfo[] methods = typeof(AndroidDevice).GetMethods();
		foreach (MethodInfo methodInfo in methods)
		{
			if (methodInfo.Name == "VRDeviceUseOwnSurface")
			{
				PLOG.I("Use VRDeviceUseOwnSurface");
				methodInfo.Invoke(null, null);
				return true;
			}
		}
		return false;
	}
}
public class Pvr_UnitySDKEyeOverlay : MonoBehaviour, IComparable<Pvr_UnitySDKEyeOverlay>
{
	public delegate void ExternalAndroidSurfaceObjectCreated();

	public enum OverlayShape
	{
		Quad,
		Cylinder,
		Equirect
	}

	public enum OverlayType
	{
		Overlay,
		Underlay
	}

	public enum OverlayTexFilterMode
	{
		NotCare,
		Nearest,
		Linear,
		Nearest_Mipmap_Nearest,
		Linear_Mipmap_Nearest,
		Nearest_Mipmap_Linear,
		Linear_Mipmap_Linear
	}

	public static List<Pvr_UnitySDKEyeOverlay> Instances = new List<Pvr_UnitySDKEyeOverlay>();

	public int layerIndex;

	public OverlayType overlayType;

	public OverlayShape overlayShape;

	public Transform layerTransform;

	public Texture[] layerTextures = new Texture[2];

	public int[] layerTextureIds = new int[2];

	public Matrix4x4[] MVMatrixs = new Matrix4x4[2];

	public Vector3[] ModelScales = new Vector3[2];

	public Quaternion[] ModelRotations = new Quaternion[2];

	public Vector3[] ModelTranslations = new Vector3[2];

	public Quaternion[] CameraRotations = new Quaternion[2];

	public Vector3[] CameraTranslations = new Vector3[2];

	public Camera[] layerEyeCamera = new Camera[2];

	public bool overrideColorScaleAndOffset;

	public Vector4 colorScale = Vector4.one;

	public Vector4 colorOffset = Vector4.zero;

	private Vector4 overlayLayerColorScaleDefault = Vector4.one;

	private Vector4 overlayLayerColorOffsetDefault = Vector4.zero;

	public bool isExternalAndroidSurface;

	public IntPtr externalAndroidSurfaceObject = IntPtr.Zero;

	public ExternalAndroidSurfaceObjectCreated externalAndroidSurfaceObjectCreated;

	public int CompareTo(Pvr_UnitySDKEyeOverlay other)
	{
		return layerIndex.CompareTo(other.layerIndex);
	}

	private void Awake()
	{
		Instances.Add(this);
		if (Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.SinglePass)
		{
			layerEyeCamera[0] = Pvr_UnitySDKEyeManager.Instance.BothEyeCamera;
			layerEyeCamera[1] = Pvr_UnitySDKEyeManager.Instance.BothEyeCamera;
		}
		else if (Pvr_UnitySDKManager.SDK.Monoscopic)
		{
			layerEyeCamera[0] = Pvr_UnitySDKEyeManager.Instance.MonoEyeCamera;
			layerEyeCamera[1] = Pvr_UnitySDKEyeManager.Instance.MonoEyeCamera;
		}
		else
		{
			layerEyeCamera[0] = Pvr_UnitySDKEyeManager.Instance.LeftEyeCamera;
			layerEyeCamera[1] = Pvr_UnitySDKEyeManager.Instance.RightEyeCamera;
		}
		layerTransform = GetComponent<Transform>();
		if (layerTransform != null)
		{
			MeshRenderer component = layerTransform.GetComponent<MeshRenderer>();
			if (component != null)
			{
				component.enabled = false;
			}
		}
		InitializeBuffer();
	}

	private void LateUpdate()
	{
		UpdateCoords();
	}

	private void OnDestroy()
	{
		Instances.Remove(this);
	}

	public void RefreshCamera()
	{
		if (Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.SinglePass)
		{
			layerEyeCamera[0] = Pvr_UnitySDKEyeManager.Instance.BothEyeCamera;
			layerEyeCamera[1] = Pvr_UnitySDKEyeManager.Instance.BothEyeCamera;
		}
		else if (Pvr_UnitySDKManager.SDK.Monoscopic)
		{
			layerEyeCamera[0] = Pvr_UnitySDKEyeManager.Instance.MonoEyeCamera;
			layerEyeCamera[1] = Pvr_UnitySDKEyeManager.Instance.MonoEyeCamera;
		}
		else
		{
			layerEyeCamera[0] = Pvr_UnitySDKEyeManager.Instance.LeftEyeCamera;
			layerEyeCamera[1] = Pvr_UnitySDKEyeManager.Instance.RightEyeCamera;
		}
	}

	private void InitializeBuffer()
	{
		OverlayShape overlayShape = this.overlayShape;
		if ((uint)overlayShape > 2u)
		{
			return;
		}
		for (int i = 0; i < layerTextureIds.Length; i++)
		{
			if (layerTextures[i] != null)
			{
				layerTextureIds[i] = layerTextures[i].GetNativeTexturePtr().ToInt32();
			}
			else
			{
				UnityEngine.Debug.LogWarning($"{(Eye)i} Texture is null!");
			}
		}
	}

	private void UpdateCoords()
	{
		if (layerTransform == null || !layerTransform.gameObject.activeSelf || layerEyeCamera[0] == null || layerEyeCamera[1] == null)
		{
			return;
		}
		for (int i = 0; i < MVMatrixs.Length; i++)
		{
			if (Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.SinglePass)
			{
				Matrix4x4[] stereoWorldToCameraMat = Pvr_UnitySDKSinglePass.GetStereoWorldToCameraMat();
				MVMatrixs[i] = stereoWorldToCameraMat[i] * layerTransform.localToWorldMatrix;
			}
			else
			{
				MVMatrixs[i] = layerEyeCamera[i].worldToCameraMatrix * layerTransform.localToWorldMatrix;
			}
			ModelScales[i] = layerTransform.localScale;
			ModelRotations[i] = layerTransform.rotation;
			ModelTranslations[i] = layerTransform.position;
			CameraRotations[i] = layerEyeCamera[i].transform.rotation;
			CameraTranslations[i] = layerEyeCamera[i].transform.position;
		}
	}

	public void SetTexture(Texture texture)
	{
		for (int i = 0; i < layerTextures.Length; i++)
		{
			layerTextures[i] = texture;
		}
		InitializeBuffer();
	}

	public void SetLayerColorScaleAndOffset(Vector4 scale, Vector4 offset)
	{
		colorScale = scale;
		colorOffset = offset;
	}

	public Vector4 GetLayerColorScale()
	{
		if (!overrideColorScaleAndOffset)
		{
			return overlayLayerColorScaleDefault;
		}
		return colorScale;
	}

	public Vector4 GetLayerColorOffset()
	{
		if (!overrideColorScaleAndOffset)
		{
			return overlayLayerColorOffsetDefault;
		}
		return colorOffset;
	}
}
public class Pvr_UnitySDKRender
{
	private static Pvr_UnitySDKRender instance;

	public AndroidJavaObject activity;

	public static AndroidJavaClass javaVrActivityClass;

	public static AndroidJavaClass javaSysActivityClass;

	public static AndroidJavaClass javaserviceClass;

	public static AndroidJavaClass javaVrActivityLongReceiver;

	public static AndroidJavaClass javaVrActivityClientClass;

	private bool canConnecttoActivity;

	private bool isInitrenderThread = true;

	private string model;

	private Vector2 prefinger1 = new Vector2(0f, 0f);

	private Vector2 prefinger2 = new Vector2(0f, 0f);

	public int eyeTextureCount = 6;

	public RenderTexture[] eyeTextures;

	public int[] eyeTextureIds;

	public int currEyeTextureIdx;

	public int nextEyeTextureIdx = 1;

	public int lastEyeTextureIdx;

	public bool isSwitchSDK;

	public int RenderviewNumber;

	public bool isFirstStartup = true;

	public bool isShellMode;

	private StereoRenderingPathPico stereoRenderPath;

	private float rtScaleFactor = 1f;

	private float eyeVFov = 90f;

	private float eyeHFov = 90f;

	public static Pvr_UnitySDKRender Instance
	{
		get
		{
			if (instance == null)
			{
				instance = new Pvr_UnitySDKRender();
			}
			return instance;
		}
		set
		{
			instance = value;
		}
	}

	public StereoRenderingPathPico StereoRenderPath => stereoRenderPath;

	public SDKStereoRendering StereoRendering { get; private set; }

	public float RtScaleFactor
	{
		get
		{
			return rtScaleFactor;
		}
		set
		{
			if (value != rtScaleFactor)
			{
				rtScaleFactor = value;
				ReCreateEyeBuffer();
			}
		}
	}

	public float EyeVFoV
	{
		get
		{
			return eyeVFov;
		}
		set
		{
			if (value != eyeVFov)
			{
				eyeVFov = value;
			}
		}
	}

	public float EyeHFoV
	{
		get
		{
			return eyeHFov;
		}
		set
		{
			if (value != eyeHFov)
			{
				eyeHFov = value;
			}
		}
	}

	public Pvr_UnitySDKRender()
	{
		if (!canConnecttoActivity)
		{
			ConnectToAndriod();
			PLOG.I("PvrLog Init Render Ability Success!");
			isInitrenderThread = false;
		}
		Init();
	}

	public void ConnectToAndriod()
	{
		try
		{
			UnityEngine.Debug.Log("PvrLog SDK Version :  " + Pvr_UnitySDKAPI.System.UPvr_GetSDKVersion().ToString() + "  Unity Script Version :" + Pvr_UnitySDKAPI.System.UPvr_GetUnitySDKVersion().ToString());
			AndroidJavaClass androidJavaClass = new AndroidJavaClass("com.unity3d.player.UnityPlayer");
			activity = androidJavaClass.GetStatic<AndroidJavaObject>("currentActivity");
			javaVrActivityClass = new AndroidJavaClass("com.psmart.vrlib.VrActivity");
			javaserviceClass = new AndroidJavaClass("com.picovr.picovrlib.hummingbirdclient.UnityClient");
			javaVrActivityLongReceiver = new AndroidJavaClass("com.psmart.vrlib.HomeKeyReceiver");
			javaSysActivityClass = new AndroidJavaClass("com.psmart.aosoperation.SysActivity");
			javaVrActivityClientClass = new AndroidJavaClass("com.psmart.vrlib.PvrClient");
			Pvr_UnitySDKAPI.System.Pvr_SetInitActivity(activity.GetRawObject(), javaVrActivityClass.GetRawClass());
			model = javaVrActivityClass.CallStatic<string>("Pvr_GetBuildModel", Array.Empty<object>());
			double[] result = new double[5];
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaVrActivityClass, "getDPIParameters", activity);
			int res = -1;
			Render.UPvr_GetIntConfig(4, ref res);
			string result2 = "";
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result2, javaserviceClass, "getSysproc", "persist.pvr.debug.appfps");
			if (result2 != "")
			{
				Pvr_UnitySDKManager.SDK.systemFPS = Convert.ToBoolean(Convert.ToInt16(result2));
			}
			if (res == 0)
			{
				Render.UPvr_ChangeScreenParameters(model, (int)result[0], (int)result[1], result[2], result[3], result[4]);
				Screen.sleepTimeout = -1;
			}
			if (Pvr_UnitySDKAPI.System.UPvr_IsPicoActivity())
			{
				UnityEngine.Debug.Log("ConnectToAndriod set monoPresentation success ?-------------" + Pvr_UnitySDKAPI.System.UPvr_SetMonoPresentation());
				UnityEngine.Debug.Log("ConnectToAndriod presentation existed ?-------------" + Pvr_UnitySDKAPI.System.UPvr_IsPresentationExisted());
			}
			isShellMode = GetIsShellMode();
			UnityEngine.Debug.Log("ConnectToAndriod isShellMode ?-------------" + isShellMode);
		}
		catch (AndroidJavaException ex)
		{
			PLOG.E("ConnectToAndriod--catch" + ex.Message);
		}
		canConnecttoActivity = true;
	}

	public void Init()
	{
		if (InitRenderAbility())
		{
			UnityEngine.Debug.Log("PvrLog Init Render Ability Success!");
			isInitrenderThread = false;
		}
		else
		{
			UnityEngine.Debug.Log("PvrLog Init Render Ability Failed!");
		}
	}

	private bool InitRenderAbility()
	{
		if (UpdateRenderParaFrame() && CreateEyeBuffer())
		{
			float num = Pvr_UnitySDKAPI.System.UPvr_GetIPD();
			Pvr_UnitySDKManager.SDK.leftEyeOffset = new Vector3((0f - num) / 2f, 0f, 0f);
			Pvr_UnitySDKManager.SDK.rightEyeOffset = new Vector3(num / 2f, 0f, 0f);
			return true;
		}
		return false;
	}

	private bool UpdateRenderParaFrame()
	{
		EyeVFoV = GetEyeVFOV();
		EyeHFoV = GetEyeHFOV();
		Pvr_UnitySDKManager.SDK.EyesAspect = EyeHFoV / EyeVFoV;
		return true;
	}

	private bool CreateEyeBuffer()
	{
		Vector2 eyeBufferResolution = GetEyeBufferResolution();
		if (isFirstStartup)
		{
			InitSinglePass();
			Pvr_UnitySDKAPI.System.UPvr_SetSinglePassDepthBufferWidthHeight((int)eyeBufferResolution.x, (int)eyeBufferResolution.y);
		}
		eyeTextures = new RenderTexture[eyeTextureCount];
		eyeTextureIds = new int[eyeTextureCount];
		for (int i = 0; i < eyeTextureCount; i++)
		{
			if (null == eyeTextures[i])
			{
				try
				{
					ConfigureEyeBuffer(i, eyeBufferResolution);
				}
				catch (Exception ex)
				{
					PLOG.E("ConfigureEyeBuffer ERROR " + ex.Message);
					throw;
				}
			}
			if (!eyeTextures[i].IsCreated())
			{
				eyeTextures[i].Create();
				eyeTextureIds[i] = eyeTextures[i].GetNativeTexturePtr().ToInt32();
			}
			eyeTextureIds[i] = eyeTextures[i].GetNativeTexturePtr().ToInt32();
		}
		return true;
	}

	private void InitSinglePass()
	{
		bool flag = true;
		if (GraphicsSettings.renderPipelineAsset != null)
		{
			flag = false;
			if (!BoundarySystem.UPvr_EnableLWRP(enable: true))
			{
				UnityEngine.Debug.Log("UPvr_EnableLWRP return false");
			}
			Vector2 eyeBufferResolution = GetEyeBufferResolution();
			if (!BoundarySystem.UPvr_SetViewportSize((int)eyeBufferResolution.x, (int)eyeBufferResolution.y))
			{
				UnityEngine.Debug.Log("UPvr_SetViewportSize return false");
			}
		}
		if (Pvr_UnitySDKProjectSetting.GetProjectConfig().usesinglepass)
		{
			bool flag2 = false;
			if (flag)
			{
				flag2 = Pvr_UnitySDKAPI.System.UPvr_EnableSinglePass(enable: true);
			}
			if (flag2)
			{
				StereoRendering = new Pvr_UnitySDKSinglePass();
				stereoRenderPath = StereoRenderingPathPico.SinglePass;
				eyeTextureCount = 3;
			}
			UnityEngine.Debug.Log("EnableSinglePass supportSinglePass " + flag + " result " + flag2);
		}
	}

	public float GetEyeVFOV()
	{
		float res = 102f;
		try
		{
			Render.UPvr_GetFloatConfig(1, ref res);
			if (res <= 0f)
			{
				res = 102f;
			}
		}
		catch (Exception ex)
		{
			PLOG.E("GetEyeVFOV ERROR! " + ex.Message);
			throw;
		}
		return res;
	}

	public float GetEyeHFOV()
	{
		float res = 102f;
		try
		{
			Render.UPvr_GetFloatConfig(2, ref res);
			if (res <= 0f)
			{
				res = 102f;
			}
		}
		catch (Exception ex)
		{
			PLOG.E("GetEyeHFOV ERROR! " + ex.Message);
			throw;
		}
		return res;
	}

	private void ConfigureEyeBuffer(int eyeTextureIndex, Vector2 resolution)
	{
		int width = (int)resolution.x;
		int height = (int)resolution.y;
		eyeTextures[eyeTextureIndex] = new RenderTexture(width, height, (int)Pvr_UnitySDKProjectSetting.GetProjectConfig().rtBitDepth, Pvr_UnitySDKProjectSetting.GetProjectConfig().rtFormat);
		if (StereoRenderPath == StereoRenderingPathPico.MultiPass)
		{
			eyeTextures[eyeTextureIndex].anisoLevel = 0;
			eyeTextures[eyeTextureIndex].antiAliasing = Mathf.Max(QualitySettings.antiAliasing, (int)Pvr_UnitySDKProjectSetting.GetProjectConfig().rtAntiAlising);
			UnityEngine.Debug.Log("MultiPass ConfigureEyeBuffer eyeTextureIndex " + eyeTextureIndex);
		}
		else if (StereoRenderPath == StereoRenderingPathPico.SinglePass)
		{
			eyeTextures[eyeTextureIndex].useMipMap = false;
			eyeTextures[eyeTextureIndex].wrapMode = TextureWrapMode.Clamp;
			eyeTextures[eyeTextureIndex].filterMode = FilterMode.Bilinear;
			eyeTextures[eyeTextureIndex].anisoLevel = 1;
			eyeTextures[eyeTextureIndex].dimension = TextureDimension.Tex2DArray;
			eyeTextures[eyeTextureIndex].volumeDepth = 2;
			UnityEngine.Debug.Log("SinglePass ConfigureEyeBuffer eyeTextureIndex " + eyeTextureIndex);
		}
		eyeTextures[eyeTextureIndex].Create();
		if (eyeTextures[eyeTextureIndex].IsCreated())
		{
			eyeTextureIds[eyeTextureIndex] = eyeTextures[eyeTextureIndex].GetNativeTexturePtr().ToInt32();
			UnityEngine.Debug.Log("eyeTextureIndex : " + eyeTextureIndex);
		}
	}

	public bool ReCreateEyeBuffer()
	{
		if (!Pvr_UnitySDKProjectSetting.GetProjectConfig().usedefaultRenderTexture)
		{
			for (int i = 0; i < eyeTextureCount; i++)
			{
				if (eyeTextures[i] != null)
				{
					eyeTextures[i].Release();
				}
			}
			Array.Clear(eyeTextures, 0, eyeTextures.Length);
			return CreateEyeBuffer();
		}
		return false;
	}

	public void ReInit()
	{
		if (canConnecttoActivity && isInitrenderThread)
		{
			Init();
		}
	}

	public void IssueRenderThread()
	{
		if (canConnecttoActivity && !isInitrenderThread)
		{
			switch (QualitySettings.activeColorSpace)
			{
			case ColorSpace.Gamma:
				Render.UPvr_SetColorspaceType(0);
				break;
			case ColorSpace.Linear:
				Render.UPvr_SetColorspaceType(1);
				break;
			}
			Pvr_UnitySDKPluginEvent.Issue(RenderEventType.InitRenderThread);
			isInitrenderThread = true;
			if (StereoRendering != null)
			{
				StereoRendering.OnSDKRenderInited();
			}
			UnityEngine.Debug.Log("PvrLog IssueRenderThread end");
		}
		else
		{
			PLOG.I("PvrLog IssueRenderThread  canConnecttoActivity = " + canConnecttoActivity);
		}
	}

	private void AutoAdpatForPico1s()
	{
		Vector2 position = Input.touches[0].position;
		Vector2 position2 = Input.touches[1].position;
		if (Vector2.Distance(prefinger1, position) > 2f && Vector2.Distance(prefinger2, position2) > 2f)
		{
			float midH = (Input.touches[0].position.x + Input.touches[1].position.x) / (float)Screen.width - 1f;
			float midV = (Input.touches[0].position.y + Input.touches[1].position.y) / (float)Screen.height - 1f;
			Render.UPvr_SetRatio(midH, midV);
		}
		prefinger1 = position;
		prefinger2 = position2;
	}

	public Vector2 GetEyeBufferResolution()
	{
		int res = 1024;
		int res2 = 1024;
		if (Pvr_UnitySDKProjectSetting.GetProjectConfig().usedefaultRenderTexture)
		{
			try
			{
				Render.UPvr_GetIntConfig(0, ref res);
				Render.UPvr_GetIntConfig(1, ref res2);
			}
			catch (Exception ex)
			{
				PLOG.E("GetEyeBufferResolution ERROR! " + ex.Message);
				throw;
			}
		}
		else
		{
			res = (int)(Pvr_UnitySDKProjectSetting.GetProjectConfig().customRTSize.x * RtScaleFactor);
			res2 = (int)(Pvr_UnitySDKProjectSetting.GetProjectConfig().customRTSize.y * RtScaleFactor);
		}
		Vector2 vector = new Vector2(res, res2);
		Vector2 vector2 = vector;
		UnityEngine.Debug.Log("DISFT Customize RenderTexture:" + vector2.ToString() + ", scaleFactor: " + RtScaleFactor);
		return vector;
	}

	public bool GetUsePredictedMatrix()
	{
		return true;
	}

	public bool GetIsShellMode()
	{
		if (activity == null)
		{
			return false;
		}
		using (AndroidJavaObject androidJavaObject = activity.Call<AndroidJavaObject>("getPackageManager", Array.Empty<object>()).Call<AndroidJavaObject>("getApplicationInfo", new object[2]
		{
			activity.Call<string>("getPackageName", Array.Empty<object>()),
			128
		}))
		{
			AndroidJavaObject androidJavaObject2 = androidJavaObject.Get<AndroidJavaObject>("metaData");
			if (androidJavaObject2 != null)
			{
				if (androidJavaObject2.Call<int>("getInt", new object[1] { "shell_mode" }) == 1)
				{
					return true;
				}
				return false;
			}
		}
		return false;
	}
}
public class Pvr_UnitySDKSinglePass : SDKStereoRendering
{
	private static Camera bothCamera;

	private Matrix4x4[] unity_StereoMatrixP = new Matrix4x4[2];

	private Matrix4x4[] unity_StereoMatrixInvP = new Matrix4x4[2];

	private static Matrix4x4[] unity_StereoWorldToCamera = new Matrix4x4[2];

	private Matrix4x4[] unity_StereoCameraToWorld = new Matrix4x4[2];

	private Matrix4x4[] unity_StereoMatrixVP = new Matrix4x4[2];

	private Vector3[] eyesOffset = new Vector3[2];

	private static Matrix4x4[] eyesOffsetMatrix = new Matrix4x4[2];

	private CommandBuffer commandBufferBeforeForwardOpaque;

	private CommandBuffer commandBufferBeforeSkybox;

	private CommandBuffer commandBufferAfterSkybox;

	public override void InitEye(Camera eye)
	{
		bothCamera = eye;
		bothCamera.stereoSeparation = 0.0625f;
		bothCamera.stereoConvergence = 0f;
		bothCamera.allowHDR = false;
		bothCamera.allowDynamicResolution = false;
		SetEyesPosition();
		SetEyeProjection();
		Pvr_UnitySDKSensor.EyeFovChanged = (Action)Delegate.Combine(Pvr_UnitySDKSensor.EyeFovChanged, new Action(SetEyeProjection));
		UnityEngine.Debug.Log("SinglePass Init success! CameraName = " + eye.transform.name + " eye.eyeSide " + eye.GetComponent<Pvr_UnitySDKEye>().eyeSide);
	}

	public override void OnSDKRenderInited()
	{
		OnSDKRenderInited_SinglePass();
	}

	public override void OnSDKPreRender()
	{
		SinglePassPreRender();
	}

	public override void OnSDKPostRender()
	{
		SwitchKeywordAndDeviceView(enable: false);
	}

	public void OnSDKRenderInited_SinglePass()
	{
		Shader.SetGlobalVectorArray("unity_StereoScaleOffset", new Vector4[2]
		{
			new Vector4(1f, 1f, 0f, 0f),
			new Vector4(1f, 1f, 0.5f, 0f)
		});
		SetAntiAliasing();
		UnityEngine.Debug.Log("OnSDKRenderInited_SinglePass");
	}

	private void SetAntiAliasing()
	{
		int antiAliasing = Mathf.Max(QualitySettings.antiAliasing, (int)Pvr_UnitySDKProjectSetting.GetProjectConfig().rtAntiAlising);
		Pvr_UnitySDKAPI.System.UPvr_SetAntiAliasing(antiAliasing);
		UnityEngine.Debug.Log("SetAntiAliasing  antiAliasing = " + antiAliasing);
	}

	public void SetEyesPosition()
	{
		float res = 0.0625f;
		int configsenum = 0;
		if (Render.UPvr_GetFloatConfig(configsenum, ref res) != 0)
		{
			PLOG.E("Cannot get ipd");
			res = 0.0625f;
		}
		bothCamera.stereoSeparation = res;
		Vector3 vector = new Vector3((0f - res) / 2f, 0f, 0f);
		Vector3 vector2 = new Vector3(res / 2f, 0f, 0f);
		Vector3 vector3 = (vector + vector2) / 2f;
		bothCamera.transform.localPosition = vector3;
		bothCamera.transform.localRotation = Quaternion.identity;
		Vector3 vector4 = vector - vector3;
		Vector3 vector5 = vector2 - vector3;
		eyesOffset[0] = vector4;
		eyesOffset[1] = vector5;
		eyesOffsetMatrix[0] = Matrix4x4.TRS(vector4, Quaternion.identity, Vector3.one);
		eyesOffsetMatrix[1] = Matrix4x4.TRS(vector5, Quaternion.identity, Vector3.one);
	}

	public void SetEyeProjection()
	{
		Matrix4x4 projection = GetProjection(bothCamera.nearClipPlane, bothCamera.farClipPlane);
		Matrix4x4 projection2 = GetProjection(bothCamera.nearClipPlane, bothCamera.farClipPlane);
		SetStereoProjectionMatrix(projection, projection2);
	}

	private static Matrix4x4 GetProjection(float near, float far)
	{
		if (near < 0.01f)
		{
			near = 0.01f;
		}
		if (far < 0.02f)
		{
			far = 0.02f;
		}
		_ = Matrix4x4.identity;
		return MakeProjection(near, far);
	}

	public static Matrix4x4 MakeProjection(float n, float f)
	{
		Vector2 eyeBufferResolution = Pvr_UnitySDKRender.Instance.GetEyeBufferResolution();
		float num = Mathf.Tan(Pvr_UnitySDKRender.Instance.EyeVFoV / 2f * ((float)Math.PI / 180f));
		float num2 = 1f / num;
		Matrix4x4 zero = Matrix4x4.zero;
		zero[0, 0] = num2 / (eyeBufferResolution.x / eyeBufferResolution.y);
		zero[1, 1] = num2;
		zero[2, 2] = (0f - (f + n)) / (f - n);
		zero[2, 3] = -2f * f * n / (f - n);
		zero[3, 2] = -1f;
		return zero;
	}

	public void SetStereoProjectionMatrix(Matrix4x4 left, Matrix4x4 right)
	{
		unity_StereoMatrixP[0] = left;
		unity_StereoMatrixInvP[0] = left.inverse;
		unity_StereoMatrixP[1] = right;
		unity_StereoMatrixInvP[1] = right.inverse;
	}

	private void SwitchKeywordAndDeviceView(bool enable)
	{
		if (enable)
		{
			Shader.EnableKeyword("STEREO_MULTIVIEW_ON");
			Shader.EnableKeyword("UNITY_SINGLE_PASS_STEREO");
			XRSettings.showDeviceView = false;
		}
		else
		{
			XRSettings.showDeviceView = true;
			Shader.DisableKeyword("UNITY_SINGLE_PASS_STEREO");
			Shader.DisableKeyword("STEREO_MULTIVIEW_ON");
		}
	}

	public static Matrix4x4[] GetStereoWorldToCameraMat()
	{
		Matrix4x4 worldToCameraMatrix = bothCamera.worldToCameraMatrix;
		unity_StereoWorldToCamera[0] = eyesOffsetMatrix[0].inverse * worldToCameraMatrix;
		unity_StereoWorldToCamera[1] = eyesOffsetMatrix[1].inverse * worldToCameraMatrix;
		return unity_StereoWorldToCamera;
	}

	public void SinglePassPreRender()
	{
		SwitchKeywordAndDeviceView(enable: true);
		Shader.SetGlobalMatrixArray("unity_StereoCameraProjection", unity_StereoMatrixP);
		Shader.SetGlobalMatrixArray("unity_StereoCameraInvProjection", unity_StereoMatrixInvP);
		Shader.SetGlobalMatrixArray("unity_StereoMatrixP", unity_StereoMatrixP);
		Matrix4x4 worldToCameraMatrix = bothCamera.worldToCameraMatrix;
		Matrix4x4 cameraToWorldMatrix = bothCamera.cameraToWorldMatrix;
		unity_StereoCameraToWorld[0] = cameraToWorldMatrix * eyesOffsetMatrix[0];
		unity_StereoCameraToWorld[1] = cameraToWorldMatrix * eyesOffsetMatrix[1];
		Shader.SetGlobalMatrixArray("unity_StereoCameraToWorld", unity_StereoCameraToWorld);
		unity_StereoWorldToCamera[0] = eyesOffsetMatrix[0].inverse * worldToCameraMatrix;
		unity_StereoWorldToCamera[1] = eyesOffsetMatrix[1].inverse * worldToCameraMatrix;
		Shader.SetGlobalMatrixArray("unity_StereoWorldToCamera", unity_StereoWorldToCamera);
		Vector4[] values = new Vector4[2]
		{
			bothCamera.transform.position + eyesOffset[0],
			bothCamera.transform.position + eyesOffset[1]
		};
		Shader.SetGlobalVectorArray("unity_StereoWorldSpaceCameraPos", values);
		Shader.SetGlobalMatrixArray("unity_StereoMatrixV", unity_StereoWorldToCamera);
		Shader.SetGlobalMatrixArray("unity_StereoMatrixInvV", unity_StereoCameraToWorld);
		unity_StereoMatrixVP[0] = unity_StereoMatrixP[0] * unity_StereoWorldToCamera[0];
		unity_StereoMatrixVP[1] = unity_StereoMatrixP[1] * unity_StereoWorldToCamera[1];
		Shader.SetGlobalMatrixArray("unity_StereoMatrixVP", unity_StereoMatrixVP);
		SetRenderTextureWithDepth();
		SetCommandBuffers();
	}

	private void SetCommandBuffers()
	{
		if (commandBufferBeforeForwardOpaque == null)
		{
			commandBufferBeforeForwardOpaque = new CommandBuffer();
			Pvr_UnitySDKPluginEvent.SetSinglePassBeforeForwardOpaque(commandBufferBeforeForwardOpaque);
			commandBufferBeforeForwardOpaque.ClearRenderTarget(clearDepth: true, clearColor: true, bothCamera.backgroundColor);
			commandBufferBeforeForwardOpaque.name = "SinglePassPrepare";
		}
		bothCamera.RemoveCommandBuffer(CameraEvent.BeforeForwardOpaque, commandBufferBeforeForwardOpaque);
		bothCamera.AddCommandBuffer(CameraEvent.BeforeForwardOpaque, commandBufferBeforeForwardOpaque);
		if (commandBufferAfterSkybox == null)
		{
			commandBufferAfterSkybox = new CommandBuffer();
		}
		bothCamera.RemoveCommandBuffer(CameraEvent.AfterSkybox, commandBufferAfterSkybox);
		commandBufferAfterSkybox.Clear();
		commandBufferAfterSkybox.SetGlobalMatrixArray("unity_StereoMatrixVP", unity_StereoMatrixVP);
		commandBufferAfterSkybox.name = "SinglePassAfterSkyBox";
		bothCamera.AddCommandBuffer(CameraEvent.AfterSkybox, commandBufferAfterSkybox);
		if (commandBufferBeforeSkybox == null)
		{
			commandBufferBeforeSkybox = new CommandBuffer();
		}
		Matrix4x4 transpose = (Matrix4x4.LookAt(Vector3.zero, bothCamera.transform.forward, bothCamera.transform.up) * Matrix4x4.Scale(new Vector3(1f, 1f, -1f))).transpose;
		Matrix4x4 matrix4x = unity_StereoMatrixP[0];
		Matrix4x4 matrix4x2 = unity_StereoMatrixP[1];
		matrix4x.m22 = -1f;
		matrix4x2.m22 = -1f;
		Matrix4x4[] values = new Matrix4x4[2]
		{
			matrix4x * transpose,
			matrix4x2 * transpose
		};
		bothCamera.RemoveCommandBuffer(CameraEvent.BeforeSkybox, commandBufferBeforeSkybox);
		commandBufferBeforeSkybox.Clear();
		commandBufferBeforeSkybox.SetGlobalMatrixArray("unity_StereoMatrixVP", values);
		commandBufferBeforeSkybox.name = "SinglePassAfterSkybox";
		bothCamera.AddCommandBuffer(CameraEvent.BeforeSkybox, commandBufferBeforeSkybox);
	}

	private void SetRenderTextureWithDepth()
	{
		Pvr_UnitySDKAPI.System.UPvr_SetCurrentRenderTexture((uint)Pvr_UnitySDKRender.Instance.eyeTextureIds[Pvr_UnitySDKRender.Instance.currEyeTextureIdx]);
	}
}
public abstract class SDKStereoRendering
{
	public abstract void InitEye(Camera eye);

	public abstract void OnSDKRenderInited();

	public abstract void OnSDKPreRender();

	public abstract void OnSDKPostRender();
}
public class HighlightAtGaze : MonoBehaviour
{
	public Color HighlightColor = Color.red;

	public float AnimationTime = 0.1f;

	private Renderer myRenderer;

	private Color originalColor;

	private Color targetColor;

	private EyeTrackingGazeRay gazeRay;

	private void Start()
	{
		myRenderer = GetComponent<Renderer>();
		originalColor = myRenderer.material.color;
		targetColor = originalColor;
	}

	private void Update()
	{
		Pvr_UnitySDKAPI.System.UPvr_getEyeTrackingGazeRay(ref gazeRay);
		if (Physics.Raycast(new Ray(gazeRay.Origin, gazeRay.Direction), out var hitInfo))
		{
			if (hitInfo.transform.name == base.transform.name)
			{
				if (targetColor != HighlightColor)
				{
					targetColor = HighlightColor;
				}
			}
			else if (targetColor != originalColor)
			{
				targetColor = originalColor;
			}
		}
		else if (targetColor != originalColor)
		{
			targetColor = originalColor;
		}
		myRenderer.material.color = Color.Lerp(myRenderer.material.color, targetColor, Time.deltaTime * (1f / AnimationTime));
	}
}
public class RayVisualizer : MonoBehaviour
{
	private LineRenderer _line;

	private EyeTrackingGazeRay gazeRay;

	private void Start()
	{
		_line = base.gameObject.GetComponent<LineRenderer>();
		_line.startWidth = 0.002f;
		_line.endWidth = 0.002f;
	}

	private void Update()
	{
		Matrix4x4 matrix = Pvr_UnitySDKSensor.Instance.HeadPose.Matrix;
		Pvr_UnitySDKAPI.System.UPvr_getEyeTrackingGazeRay(ref gazeRay);
		_line.SetPosition(0, matrix.MultiplyPoint(new Vector3(0f, -0.05f, 0.2f)));
		_line.SetPosition(1, gazeRay.Origin + gazeRay.Direction * 20f);
	}
}
public class GetSeeThroughImage : MonoBehaviour
{
	public RawImage viewImage_left;

	public RawImage viewImage_right;

	private int width;

	private int height;

	private RenderTexture cameraTex_left;

	private RenderTexture cameraTex_right;

	private bool cameraPreview;

	private void Start()
	{
		CreateTexture();
	}

	private void Update()
	{
		if (Input.GetKey(KeyCode.JoystickButton0))
		{
			DrawTexture();
		}
	}

	private void OnDestory()
	{
		if (cameraPreview)
		{
			cameraPreview = false;
			BoundarySystem.UPvr_StopCameraFrame();
		}
	}

	private void CreateTexture()
	{
		width = 600;
		height = 600;
		BoundarySystem.UPvr_BoundarySetCameraImageRect(width, height);
		cameraTex_left = new RenderTexture(width, height, 24, RenderTextureFormat.Default);
		cameraTex_right = new RenderTexture(width, height, 24, RenderTextureFormat.Default);
		cameraTex_left.Create();
		cameraTex_right.Create();
		viewImage_left.texture = cameraTex_left;
		viewImage_right.texture = cameraTex_right;
	}

	private void DrawTexture()
	{
		if (!cameraPreview)
		{
			cameraPreview = true;
			BoundarySystem.UPvr_StartCameraFrame();
		}
		BoundarySystem.UPvr_BoundaryGetSeeThroughData(0, cameraTex_left);
		BoundarySystem.UPvr_BoundaryGetSeeThroughData(1, cameraTex_right);
	}
}
public class OverlayExternalSurfaceDemo : MonoBehaviour
{
	public string movieName;

	public Pvr_UnitySDKEyeOverlay.OverlayType overlayType;

	public Pvr_UnitySDKEyeOverlay.OverlayShape overlayShape;

	private Pvr_UnitySDKEyeOverlay overlay;

	private const string TAG = "[ExternalSurface]>>>>>>";

	private void Awake()
	{
		overlay = GetComponent<Pvr_UnitySDKEyeOverlay>();
		if (overlay == null)
		{
			UnityEngine.Debug.LogError("[ExternalSurface]>>>>>>Overlay is null!");
			overlay = base.gameObject.AddComponent<Pvr_UnitySDKEyeOverlay>();
		}
		overlay.overlayType = overlayType;
		overlay.overlayShape = overlayShape;
		overlay.isExternalAndroidSurface = true;
	}

	private void Start()
	{
		if (!string.IsNullOrEmpty(movieName))
		{
			StartPlay(Application.streamingAssetsPath + "/" + movieName, null);
		}
	}

	private void StartPlay(string moviePath, string licenceUrl)
	{
		if (moviePath != string.Empty)
		{
			if (overlay.isExternalAndroidSurface)
			{
				Pvr_UnitySDKEyeOverlay.ExternalAndroidSurfaceObjectCreated externalAndroidSurfaceObjectCreated = delegate
				{
					UnityEngine.Debug.Log("[ExternalSurface]>>>>>>SurfaceObject created callback is Invoke().");
				};
				if (overlay.externalAndroidSurfaceObject == IntPtr.Zero)
				{
					UnityEngine.Debug.Log("[ExternalSurface]>>>>>>Register surfaceObject crreated callback");
					overlay.externalAndroidSurfaceObjectCreated = externalAndroidSurfaceObjectCreated;
				}
				else
				{
					UnityEngine.Debug.Log("[ExternalSurface]>>>>>>SurfaceObject is already created! Invoke callback");
					externalAndroidSurfaceObjectCreated();
				}
			}
		}
		else
		{
			UnityEngine.Debug.LogError("[ExternalSurface]>>>>>>Movie path is null!");
		}
	}
}
public class MoveCylinder : MonoBehaviour
{
	private Vector3 startingPosition;

	private Quaternion startingRotation;

	private void Start()
	{
		startingPosition = base.transform.localPosition;
		startingRotation = base.transform.rotation;
	}

	public void Reset()
	{
		base.transform.localPosition = startingPosition;
		base.transform.rotation = startingRotation;
	}
}
[RequireComponent(typeof(Collider))]
public class MoveSphere : MonoBehaviour
{
	private Vector3 startingPosition;

	private void Start()
	{
		startingPosition = base.transform.localPosition;
		SetGazedAt(gazedAt: false);
		base.gameObject.GetComponent<Rigidbody>().AddForce(Vector3.right * 120f);
	}

	private void OnTriggerEnter(Collider other)
	{
	}

	public void SetGazedAt(bool gazedAt)
	{
		GetComponent<Renderer>().material.color = (gazedAt ? Color.yellow : Color.blue);
	}

	public void Reset()
	{
		base.transform.localPosition = startingPosition;
		SetGazedAt(gazedAt: false);
		base.gameObject.GetComponent<Rigidbody>().Sleep();
		base.gameObject.GetComponent<Rigidbody>().AddForce(Vector3.right * 120f);
	}

	public void TeleportRandomly()
	{
		Vector3 onUnitSphere = UnityEngine.Random.onUnitSphere;
		onUnitSphere.y = Mathf.Clamp(onUnitSphere.y, 0.5f, 1f);
		float num = 2f * UnityEngine.Random.value + 1.5f;
		base.transform.localPosition = onUnitSphere * num;
	}
}
public class Resetbutton : MonoBehaviour
{
	public void DemoResetTracking()
	{
		if (Pvr_UnitySDKSensor.Instance != null)
		{
			Pvr_UnitySDKSensor.Instance.ResetUnitySDKSensor();
		}
	}
}
public class UserEntitlementCheck : MonoBehaviour
{
	private void OnEnable()
	{
		Pvr_UnitySDKManager.EntitlementCheckResultEvent += HandelEntitlementCheckResult;
	}

	private void OnDisable()
	{
		Pvr_UnitySDKManager.EntitlementCheckResultEvent -= HandelEntitlementCheckResult;
	}

	private void HandelEntitlementCheckResult(int resultCode)
	{
		UnityEngine.Debug.Log("The User Entitlement Check Result is :" + resultCode);
		switch (resultCode)
		{
		case 0:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: success");
			break;
		case -1:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: invalid params");
			break;
		case -2:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: service not exist");
			break;
		case -3:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: bind failed");
			break;
		case -4:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: exception");
			break;
		case -5:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: timeout");
			break;
		case 10:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: missing package name");
			break;
		case 11:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: missing appid");
			break;
		case 13:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: appid and package name not match");
			break;
		case 20:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: not login");
			break;
		case 21:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: not pay");
			break;
		case 31:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: invalid sn");
			break;
		default:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: unknown");
			break;
		}
	}
}
public class Pvr_SQPLoader : MonoBehaviour
{
	private struct SceneInfo
	{
		public List<string> scenes;

		public long version;

		public SceneInfo(List<string> sceneList, long currentSceneEpochVersion)
		{
			scenes = sceneList;
			version = currentSceneEpochVersion;
		}
	}

	public const string RESOURCE_BUNDLE_NAME = "asset_resources";

	public const string EXTERNAL_STORAGE_PATH = "/sdcard/Android/data";

	public const string SCENE_LOAD_DATA_NAME = "SceneLoadData.txt";

	private const string SQP_INDEX_NAME = "PvrSQPIndex";

	private const string CACHE_SCENES_PATH = "cache/scenes";

	private UnityEngine.AsyncOperation loadSceneOperation;

	private string scenePath = "";

	private string sceneLoadDataPath = "";

	private List<AssetBundle> loadedAssetBundles = new List<AssetBundle>();

	private SceneInfo currentSceneInfo;

	private void Awake()
	{
		UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
	}

	private void Start()
	{
		string path = Path.Combine("/sdcard/Android/data", Application.identifier);
		scenePath = Path.Combine(path, "cache/scenes");
		sceneLoadDataPath = Path.Combine(scenePath, "SceneLoadData.txt");
		currentSceneInfo = GetSceneInfo();
		if (currentSceneInfo.version != 0L && !string.IsNullOrEmpty(currentSceneInfo.scenes[0]))
		{
			LoadScene(currentSceneInfo);
		}
	}

	public void Update()
	{
	}

	private SceneInfo GetSceneInfo()
	{
		SceneInfo result = default(SceneInfo);
		try
		{
			StreamReader streamReader = new StreamReader(sceneLoadDataPath);
			result.version = Convert.ToInt64(streamReader.ReadLine());
			List<string> list = new List<string>();
			while (!streamReader.EndOfStream)
			{
				list.Add(streamReader.ReadLine());
			}
			result.scenes = list;
		}
		catch
		{
		}
		return result;
	}

	private void LoadScene(SceneInfo sceneInfo)
	{
		AssetBundle assetBundle = null;
		string[] files = Directory.GetFiles(scenePath, "*_*");
		string text = "scene_" + sceneInfo.scenes[0].ToLower();
		try
		{
			string[] array = files;
			for (int i = 0; i < array.Length; i++)
			{
				AssetBundle assetBundle2 = AssetBundle.LoadFromFile(array[i]);
				if (assetBundle2 != null)
				{
					UnityEngine.Debug.Log(("[PVRSceneLoader] Loading file bundle: " + assetBundle2.name == null) ? "null" : assetBundle2.name);
					loadedAssetBundles.Add(assetBundle2);
				}
				else
				{
					UnityEngine.Debug.LogError("[PVRSceneLoader] Loading file bundle failed");
				}
				if (assetBundle2.name == text)
				{
					assetBundle = assetBundle2;
				}
				_ = assetBundle2.name == "asset_resources";
			}
		}
		catch (Exception)
		{
			return;
		}
		if (assetBundle != null)
		{
			string fileNameWithoutExtension = Path.GetFileNameWithoutExtension(assetBundle.GetAllScenePaths()[0]);
			loadSceneOperation = SceneManager.LoadSceneAsync(fileNameWithoutExtension);
			loadSceneOperation.completed += LoadSceneOperation_completed;
		}
	}

	private void LoadSceneOperation_completed(UnityEngine.AsyncOperation obj)
	{
		StartCoroutine(onCheckNewSceneCoroutine());
	}

	private IEnumerator onCheckNewSceneCoroutine()
	{
		while (GetSceneInfo().version == currentSceneInfo.version)
		{
			yield return new WaitForSeconds(0f);
		}
		UnityEngine.Debug.Log("Scene change detected.");
		foreach (AssetBundle loadedAssetBundle in loadedAssetBundles)
		{
			if (loadedAssetBundle != null)
			{
				loadedAssetBundle.Unload(unloadAllLoadedObjects: true);
			}
		}
		loadedAssetBundles.Clear();
		int sceneCount = SceneManager.sceneCount;
		for (int i = 0; i < sceneCount; i++)
		{
			SceneManager.UnloadSceneAsync(SceneManager.GetSceneAt(i));
		}
		GameObject[] array = Resources.FindObjectsOfTypeAll(typeof(GameObject)) as GameObject[];
		for (int j = 0; j < array.Length; j++)
		{
			UnityEngine.Object.Destroy(array[j]);
		}
		SceneManager.LoadSceneAsync("PvrSQPIndex");
	}
}
public class Pvr_UnitySDKHeadTrack : MonoBehaviour
{
	[Tooltip("If true, head tracking will affect the rotation of each Pvr_UnitySDK's cameras.")]
	public bool trackRotation = true;

	[Tooltip("If true, head tracking will affect the position of each Pvr_UnitySDK's cameras.")]
	public bool trackPosition = true;

	public Transform target;

	private bool updated;

	private bool dataClock;

	public Ray Gaze
	{
		get
		{
			UpdateHead();
			return new Ray(base.transform.position, base.transform.forward);
		}
	}

	private void Update()
	{
		updated = false;
		UpdateHead();
	}

	private void UpdateHead()
	{
		if (updated)
		{
			return;
		}
		updated = true;
		if (Pvr_UnitySDKManager.SDK == null)
		{
			return;
		}
		if (trackRotation)
		{
			Quaternion orientation = Pvr_UnitySDKSensor.Instance.HeadPose.Orientation;
			if (target == null)
			{
				base.transform.localRotation = orientation;
			}
			else
			{
				base.transform.rotation = orientation * target.rotation;
			}
		}
		else
		{
			Quaternion orientation2 = Pvr_UnitySDKSensor.Instance.HeadPose.Orientation;
			if (target == null)
			{
				base.transform.localRotation = Quaternion.identity;
			}
			else
			{
				base.transform.rotation = orientation2 * target.rotation;
			}
		}
		if (trackPosition)
		{
			Vector3 position = Pvr_UnitySDKSensor.Instance.HeadPose.Position;
			if (target == null)
			{
				base.transform.localPosition = position;
			}
			else
			{
				base.transform.position = target.position + target.rotation * position;
			}
		}
	}
}
public class Pvr_UnitySDKPose
{
	protected static readonly Matrix4x4 flipZ = Matrix4x4.Scale(new Vector3(1f, 1f, -1f));

	public Matrix4x4 RightHandedMatrix => flipZ * Matrix * flipZ;

	public Vector3 Position { get; protected set; }

	public Quaternion Orientation { get; protected set; }

	public Matrix4x4 Matrix { get; protected set; }

	public Pvr_UnitySDKPose(Matrix4x4 matrix)
	{
		Set(matrix);
	}

	public Pvr_UnitySDKPose(Vector3 position, Quaternion orientation)
	{
		Set(position, orientation);
	}

	public void Set(Vector3 position, Quaternion orientation)
	{
		Position = position;
		Orientation = orientation;
		Matrix = Matrix4x4.TRS(position, orientation, Vector3.one);
	}

	protected void Set(Matrix4x4 matrix)
	{
		Matrix = matrix;
		Position = matrix.GetColumn(3);
		Orientation = Quaternion.LookRotation(matrix.GetColumn(2), matrix.GetColumn(1));
	}

	private Quaternion NormalizeQuaternion(ref Quaternion q)
	{
		float num = 0f;
		for (int i = 0; i < 4; i++)
		{
			num += q[i] * q[i];
		}
		float num2 = 1f / Mathf.Sqrt(num);
		for (int j = 0; j < 4; j++)
		{
			q[j] *= num2;
		}
		return q;
	}
}
public class Pvr_UnitySDKSensor
{
	public delegate void Enter3DofModel();

	public delegate void Exit3DofModel();

	private static Pvr_UnitySDKSensor instance;

	private bool SensorStart;

	private bool SensorInit;

	private Quaternion UnityQuaternion = Quaternion.identity;

	private Vector3 UnityPosition = Vector3.zero;

	private Sensorindex sensorIndex;

	private bool dofClock;

	public static Action EyeFovChanged;

	public Pvr_UnitySDKPose HeadPose;

	private float vfov = 102f;

	private float hfov = 102f;

	private float w;

	private float x;

	private float y;

	private float z;

	private float px;

	private float py;

	private float pz;

	public static Pvr_UnitySDKSensor Instance
	{
		get
		{
			if (instance == null)
			{
				instance = new Pvr_UnitySDKSensor();
			}
			return instance;
		}
		set
		{
			instance = value;
		}
	}

	public static event Enter3DofModel Enter3DofModelEvent;

	public static event Exit3DofModel Exit3DofModelEvent;

	public Pvr_UnitySDKSensor()
	{
		Init();
	}

	public void Init()
	{
		InitUnitySDK6DofSensor();
		SensorInit = InitUnitySDKSensor();
		SensorStart = StartUnitySDKSensor();
		HeadPose = new Pvr_UnitySDKPose(Vector3.zero, Quaternion.identity);
	}

	public void SensorUpdate()
	{
		if (GetUnitySDKSensorState())
		{
			HeadPose.Set(UnityPosition, UnityQuaternion);
		}
	}

	public bool InitUnitySDKSensor()
	{
		bool result = false;
		try
		{
			if (Sensor.UPvr_Init((int)sensorIndex) == 0)
			{
				result = true;
			}
		}
		catch (Exception ex)
		{
			PLOG.E("InitUnitySDKSensor ERROR! " + ex.Message);
			throw;
		}
		return result;
	}

	public bool InitUnitySDK6DofSensor()
	{
		bool result = false;
		try
		{
			int res = 0;
			Render.UPvr_GetIntConfig(3, ref res);
			if (res == 1)
			{
				if (Sensor.UPvr_Enable6DofModule(!Pvr_UnitySDKManager.SDK.HmdOnlyrot) == 0 && !Pvr_UnitySDKManager.SDK.HmdOnlyrot)
				{
					result = true;
					Pvr_UnitySDKManager.SDK.PVRNeck = false;
				}
			}
			else
			{
				UnityEngine.Debug.LogWarning("This platform does not support 6 Dof !");
			}
		}
		catch (Exception ex)
		{
			PLOG.E("InitUnity6DofSDKSensor ERROR! " + ex.Message);
			throw;
		}
		return result;
	}

	public bool StartUnitySDKSensor()
	{
		bool result = false;
		try
		{
			if (Sensor.UPvr_StartSensor((int)sensorIndex) == 0)
			{
				result = true;
			}
		}
		catch (Exception ex)
		{
			PLOG.E("StartUnitySDKSensor ERROR! " + ex.Message);
			throw;
		}
		return result;
	}

	public bool StopUnitySDKSensor()
	{
		bool result = false;
		try
		{
			if (Sensor.UPvr_StopSensor((int)sensorIndex) == 0)
			{
				result = true;
			}
		}
		catch (Exception ex)
		{
			PLOG.E("StopUnitySDKSensor ERROR! " + ex.Message);
			throw;
		}
		return result;
	}

	public bool ResetUnitySDKSensor()
	{
		bool result = false;
		try
		{
			if (Sensor.UPvr_ResetSensor((int)sensorIndex) == 0)
			{
				result = true;
				PLOG.E("ResetUnitySDKSensor OK! ");
			}
		}
		catch (Exception ex)
		{
			PLOG.E("ResetUnitySDKSensor ERROR! " + ex.Message);
			throw;
		}
		return result;
	}

	public bool OptionalResetUnitySDKSensor(int resetRot, int resetPos)
	{
		bool result = false;
		try
		{
			if (Sensor.UPvr_OptionalResetSensor((int)sensorIndex, resetRot, resetPos) == 0)
			{
				result = true;
				UnityEngine.Debug.Log("PvrLog OptionalResetUnitySDKSensor OK!" + resetRot + resetPos);
			}
		}
		catch (Exception ex)
		{
			UnityEngine.Debug.LogError("OptionalResetUnitySDKSensor ERROR! " + ex.Message);
			throw;
		}
		return result;
	}

	public bool GetUnitySDKSensorState()
	{
		bool result = false;
		if (SensorInit && SensorStart)
		{
			try
			{
				int num = -1;
				if (Pvr_UnitySDKManager.SDK.ShowVideoSeethrough)
				{
					Pvr_BoundarySystem.Instance.CameraFramePtr = Pvr_BoundaryAPI.UPvr_GetCameraData_Ext();
					num = Pvr_BoundaryAPI.UPvr_GetMainSensorStateExt(ref x, ref y, ref z, ref w, ref px, ref py, ref pz, ref vfov, ref hfov, ref Pvr_UnitySDKRender.Instance.RenderviewNumber);
				}
				else
				{
					num = Sensor.UPvr_GetMainSensorState(ref x, ref y, ref z, ref w, ref px, ref py, ref pz, ref vfov, ref hfov, ref Pvr_UnitySDKRender.Instance.RenderviewNumber);
				}
				Pvr_UnitySDKManager.SDK.posStatus = Sensor.UPvr_Get6DofSensorQualityStatus();
				if (num == 0)
				{
					if (!Convert.ToBoolean(Pvr_UnitySDKManager.SDK.posStatus & 2))
					{
						if (!dofClock)
						{
							if (Pvr_UnitySDKSensor.Enter3DofModelEvent != null)
							{
								Pvr_UnitySDKSensor.Enter3DofModelEvent();
							}
							dofClock = true;
						}
					}
					else if (dofClock)
					{
						if (Pvr_UnitySDKSensor.Exit3DofModelEvent != null)
						{
							Pvr_UnitySDKSensor.Exit3DofModelEvent();
						}
						dofClock = false;
					}
					RefreshHeadData(x, y, z, w, px, py, pz);
					UnityQuaternion.Set(x, y, 0f - z, 0f - w);
					if (Pvr_UnitySDKRender.Instance.EyeVFoV != vfov)
					{
						Pvr_UnitySDKRender.Instance.EyeVFoV = vfov;
						if (EyeFovChanged != null)
						{
							EyeFovChanged();
						}
					}
					Pvr_UnitySDKRender.Instance.EyeHFoV = hfov;
					Pvr_UnitySDKManager.SDK.EyesAspect = hfov / vfov;
					result = true;
					if (Pvr_UnitySDKManager.SDK.HmdOnlyrot)
					{
						if (Pvr_UnitySDKManager.SDK.PVRNeck)
						{
							if (Pvr_UnitySDKManager.SDK.TrackingOrigin == TrackingOrigin.FloorLevel)
							{
								UnityPosition.Set(0f, py, 0f);
								UnityPosition += UnityQuaternion * Pvr_UnitySDKManager.SDK.neckOffset - Pvr_UnitySDKManager.SDK.neckOffset.y * Vector3.up;
							}
							else
							{
								UnityPosition = UnityQuaternion * Pvr_UnitySDKManager.SDK.neckOffset - Pvr_UnitySDKManager.SDK.neckOffset.y * Vector3.up;
							}
						}
					}
					else
					{
						UnityPosition.Set(px, py, 0f - pz);
					}
					if (PLOG.logLevel > 2)
					{
						PLOG.D("posStatus=" + Pvr_UnitySDKManager.SDK.posStatus);
						PLOG.D("PvrLog 6DoFHeadRotation:" + x + "," + y + "," + (0f - z) + "," + (0f - w) + ",Position:" + px + "," + py + "," + (0f - pz) + ",eulerAngles:" + UnityQuaternion.eulerAngles.ToString());
					}
				}
				if (num == -1)
				{
					PLOG.I("PvrLog Sensor update --- GetUnitySDKSensorState  -1 ");
				}
			}
			catch (Exception ex)
			{
				PLOG.E("GetUnitySDKSensorState ERROR! " + ex.Message);
				throw;
			}
		}
		return result;
	}

	public bool GetUnitySDKPSensorState()
	{
		bool result = false;
		try
		{
			if (Sensor.UPvr_ResetSensor((int)sensorIndex) == 0)
			{
				result = true;
			}
		}
		catch (Exception ex)
		{
			PLOG.E("GetUnitySDKPSensorState ERROR! " + ex.Message);
			throw;
		}
		return result;
	}

	private void RefreshHeadData(float x, float y, float z, float w, float px, float py, float pz)
	{
		Pvr_UnitySDKManager.SDK.headData[0] = x;
		Pvr_UnitySDKManager.SDK.headData[1] = y;
		Pvr_UnitySDKManager.SDK.headData[2] = z;
		Pvr_UnitySDKManager.SDK.headData[3] = w;
		Pvr_UnitySDKManager.SDK.headData[4] = px;
		Pvr_UnitySDKManager.SDK.headData[5] = py;
		Pvr_UnitySDKManager.SDK.headData[6] = pz;
	}
}
public class CLoadingAsset : ScriptableObject
{
	public int SplashScreenType;

	public List<Texture2D> splashImage = new List<Texture2D>();

	public Texture2D Inside_background;

	public bool UseSplashText;

	public string DefaultText;

	public string ChineseText;

	public string EnglishText;

	public string JapaneseText;

	public string KoreanText;

	public string FontSize;

	public Color FontColor;

	public string TextHeight;

	public bool UseCarousel;

	public int SplashTextAlignment;
}
[Serializable]
public class Pvr_UnitySDKConfigProfile
{
	public struct Lenses
	{
		public float separation;

		public float offset;

		public float distance;

		public int alignment;

		public const int AlignTop = -1;

		public const int AlignCenter = 0;

		public const int AlignBottom = 1;
	}

	public struct MaxFOV
	{
		public float upper;

		public float lower;

		public float inner;

		public float outer;
	}

	public struct Distortion
	{
		public float k1;

		public float k2;

		public float k3;

		public float k4;

		public float k5;

		public float k6;

		public float distort(float r)
		{
			return 0f;
		}

		public float distort(float r, float dist)
		{
			float num = r * dist * 1000f;
			return (k1 * Mathf.Pow(num, 5f) + k2 * Mathf.Pow(num, 4f) + k3 * Mathf.Pow(num, 3f) + k4 * Mathf.Pow(num, 2f) + k5 * num + k6) / 1000f / dist;
		}

		public float diatortInv(float radious)
		{
			return 0f;
		}
	}

	public struct Device
	{
		public Lenses devLenses;

		public MaxFOV devMaxFov;

		public Distortion devDistortion;

		public Distortion devDistortionInv;
	}

	public static readonly Device SimulateDevice = new Device
	{
		devLenses = 
		{
			separation = 0.062f,
			offset = 0f,
			distance = 0.0403196f,
			alignment = 0
		},
		devMaxFov = 
		{
			upper = 40f,
			lower = 40f,
			inner = 40f,
			outer = 40f
		},
		devDistortion = 
		{
			k1 = 2.333E-06f,
			k2 = -0.000126f,
			k3 = 0.002978f,
			k4 = -0.02615f,
			k5 = 1.089f,
			k6 = -0.0337f
		},
		devDistortionInv = 
		{
			k1 = 1.342E-08f,
			k2 = 1.665E-06f,
			k3 = -0.0002797f,
			k4 = 0.001166f,
			k5 = 0.9945f,
			k6 = 0.004805f
		}
	};

	public Device device;

	public static readonly Pvr_UnitySDKConfigProfile Default = new Pvr_UnitySDKConfigProfile
	{
		device = SimulateDevice
	};

	public Pvr_UnitySDKConfigProfile Clone()
	{
		return new Pvr_UnitySDKConfigProfile
		{
			device = device
		};
	}

	public static Pvr_UnitySDKConfigProfile GetPicoProfile()
	{
		return new Pvr_UnitySDKConfigProfile
		{
			device = SimulateDevice
		};
	}

	public float[] GetLeftEyeVisibleTanAngles(float width, float height)
	{
		float val = (float)Math.Tan((double)(0f - device.devMaxFov.outer) * Math.PI / 180.0);
		float val2 = (float)Math.Tan((double)device.devMaxFov.upper * Math.PI / 180.0);
		float val3 = (float)Math.Tan((double)device.devMaxFov.inner * Math.PI / 180.0);
		float val4 = (float)Math.Tan((double)(0f - device.devMaxFov.lower) * Math.PI / 180.0);
		float num = width / 4f;
		float num2 = height / 2f;
		float num3 = device.devLenses.separation / 2f - num;
		float num4 = 0f;
		float distance = device.devLenses.distance;
		float val5 = device.devDistortion.distort((num3 - num) / distance, device.devLenses.distance);
		float val6 = device.devDistortion.distort((num4 + num2) / distance, device.devLenses.distance);
		float val7 = device.devDistortion.distort((num3 + num) / distance, device.devLenses.distance);
		float val8 = device.devDistortion.distort((num4 - num) / distance, device.devLenses.distance);
		float num5 = Math.Max(val, val5);
		float num6 = Math.Min(val2, val6);
		float num7 = Math.Min(val3, val7);
		float num8 = Math.Max(val4, val8);
		return new float[4] { num5, num6, num7, num8 };
	}

	public float[] GetLeftEyeNoLensTanAngles(float width, float height)
	{
		float val = device.devDistortionInv.distort((float)Math.Tan((double)(0f - device.devMaxFov.outer) * Math.PI / 180.0), device.devLenses.distance);
		float val2 = device.devDistortionInv.distort((float)Math.Tan((double)device.devMaxFov.upper * Math.PI / 180.0), device.devLenses.distance);
		float val3 = device.devDistortionInv.distort((float)Math.Tan((double)device.devMaxFov.inner * Math.PI / 180.0), device.devLenses.distance);
		float val4 = device.devDistortionInv.distort((float)Math.Tan((double)(0f - device.devMaxFov.lower) * Math.PI / 180.0), device.devLenses.distance);
		float num = width / 4f;
		float num2 = height / 2f;
		float num3 = device.devLenses.separation / 2f - num;
		float num4 = 0f;
		float distance = device.devLenses.distance;
		float val5 = (num3 - num) / distance;
		float val6 = (num4 + num2) / distance;
		float val7 = (num3 + num) / distance;
		float val8 = (num4 - num) / distance;
		float num5 = Math.Min(val, val5);
		float num6 = Math.Min(val2, val6);
		float num7 = Math.Min(val3, val7);
		float num8 = Math.Max(val4, val8);
		return new float[4] { num5, num6, num7, num8 };
	}

	public Rect GetLeftEyeVisibleScreenRect(float[] undistortedFrustum, float width, float height)
	{
		float distance = device.devLenses.distance;
		float num = (width - device.devLenses.separation) / 2f;
		float num2 = height / 2f;
		float num3 = (undistortedFrustum[0] * distance + num) / width;
		float num4 = (undistortedFrustum[1] * distance + num2) / height;
		float num5 = (undistortedFrustum[2] * distance + num) / width;
		float num6 = (undistortedFrustum[3] * distance + num2) / height;
		return new Rect(num3, num6, num5 - num3, num4 - num6);
	}
}
[RequireComponent(typeof(Text))]
public class Pvr_UnitySDKFPS : MonoBehaviour
{
	public Text fpsText;

	private float updateInterval = 0.5f;

	private float accum;

	private int frames;

	private float timeLeft;

	private string strFps;

	private void Update()
	{
		if (fpsText != null)
		{
			ShowFps();
		}
	}

	private void ShowFps()
	{
		timeLeft -= Time.unscaledDeltaTime;
		accum += Time.unscaledDeltaTime;
		frames++;
		if ((double)timeLeft <= 0.0)
		{
			float num = (float)frames / accum;
			strFps = $"FPS: {num:f0}";
			fpsText.text = strFps;
			timeLeft += updateInterval;
			accum = 0f;
			frames = 0;
		}
	}
}
public class Pvr_GazeFuse : MonoBehaviour
{
	public GameObject gazeGameObject;

	private Image image;

	private void Start()
	{
		image = GetComponent<Image>();
	}

	private void Update()
	{
		if (gazeGameObject == null || Pvr_GazeInputModule.gazeGameObject == gazeGameObject)
		{
			FuseAmountChanged(Pvr_GazeInputModule.gazeFraction);
		}
	}

	private void FuseAmountChanged(float fuseAmount)
	{
		if (image != null)
		{
			image.fillAmount = fuseAmount;
		}
	}
}
public class Pvr_GazeInputModule : PointerInputModule
{
	public enum Mode
	{
		Click,
		Gaze
	}

	public Mode mode;

	[Header("Click Settings")]
	public string ClickInputName = "Submit";

	[Header("Gaze Settings")]
	public float GazeTimeInSeconds = 2f;

	public RaycastResult CurrentRaycast;

	private PointerEventData pointerEventData;

	private GameObject currentLookAtHandler;

	private float currentLookAtHandlerClickTime;

	public static float gazeFraction { get; private set; }

	public static GameObject gazeGameObject { get; private set; }

	public override void Process()
	{
		HandleLook();
		HandleSelection();
	}

	private void HandleLook()
	{
		if (pointerEventData == null)
		{
			pointerEventData = new PointerEventData(base.eventSystem);
		}
		pointerEventData.position = new Vector2(Screen.width / 2, Screen.height / 2);
		pointerEventData.delta = Vector2.zero;
		List<RaycastResult> list = new List<RaycastResult>();
		base.eventSystem.RaycastAll(pointerEventData, list);
		RaycastResult currentRaycast = (pointerEventData.pointerCurrentRaycast = BaseInputModule.FindFirstRaycast(list));
		CurrentRaycast = currentRaycast;
		ProcessMove(pointerEventData);
	}

	private void HandleSelection()
	{
		gazeFraction = 0f;
		if (pointerEventData.pointerEnter != null)
		{
			GameObject eventHandler = ExecuteEvents.GetEventHandler<IPointerClickHandler>(pointerEventData.pointerEnter);
			if (currentLookAtHandler != eventHandler)
			{
				gazeGameObject = (currentLookAtHandler = eventHandler);
				currentLookAtHandlerClickTime = Time.realtimeSinceStartup + GazeTimeInSeconds;
			}
			if (mode == Mode.Gaze && currentLookAtHandler != null)
			{
				gazeFraction = Mathf.Clamp01(1f - (currentLookAtHandlerClickTime - Time.realtimeSinceStartup) / GazeTimeInSeconds);
			}
			if ((currentLookAtHandler != null && mode == Mode.Gaze && Time.realtimeSinceStartup > currentLookAtHandlerClickTime) || (mode == Mode.Click && Input.GetButtonDown(ClickInputName)))
			{
				_ = EventSystem.current.currentSelectedGameObject != null;
				EventSystem.current.SetSelectedGameObject(currentLookAtHandler);
				gazeFraction = 0f;
				ExecuteEvents.ExecuteHierarchy(currentLookAtHandler, pointerEventData, ExecuteEvents.pointerClickHandler);
				currentLookAtHandlerClickTime = float.MaxValue;
				ExecuteEvents.ExecuteHierarchy(EventSystem.current.currentSelectedGameObject, pointerEventData, ExecuteEvents.deselectHandler);
			}
		}
		else
		{
			gazeGameObject = (currentLookAtHandler = null);
		}
	}
}
[RequireComponent(typeof(Pvr_GazeInputModule))]
public class Pvr_GazeInputModuleCrosshair : MonoBehaviour
{
	public static bool DisplayCrosshair = true;

	[Tooltip("Crosshair GameObject attached to your VR Camera")]
	public Transform Crosshair;

	private Pvr_GazeInputModule gazeInputModule;

	private Vector3 CrosshairOriginalScale;

	private float CrosshairOriginalDistance;

	private void Awake()
	{
		gazeInputModule = GetComponent<Pvr_GazeInputModule>();
	}

	private void Start()
	{
		CrosshairOriginalScale = Crosshair.localScale;
		CrosshairOriginalDistance = Crosshair.localPosition.z;
		Crosshair.gameObject.SetActive(value: false);
	}

	private void Update()
	{
		Crosshair.gameObject.SetActive(DisplayCrosshair);
		if (DisplayCrosshair)
		{
			float crossHairAtDistance = CrosshairOriginalDistance;
			if (gazeInputModule.CurrentRaycast.isValid)
			{
				crossHairAtDistance = gazeInputModule.CurrentRaycast.distance * 0.8f - 0.5f;
			}
			SetCrossHairAtDistance(crossHairAtDistance);
		}
	}

	private void SetCrossHairAtDistance(float dist)
	{
		Vector3 localPosition = Crosshair.localPosition;
		Crosshair.localPosition = new Vector3(localPosition.x, localPosition.y, dist);
		Crosshair.localScale = CrosshairOriginalScale * dist;
	}
}
public enum RenderEventType
{
	InitRenderThread = 1024,
	Pause,
	Resume,
	LeftEyeEndFrame,
	RightEyeEndFrame,
	TimeWarp,
	ResetVrModeParms,
	ShutdownRenderThread,
	BeginEye,
	EndEye,
	BoundaryRenderLeft,
	BoundaryRenderRight,
	BothEyeEndFrame,
	CameraFrameLeft,
	CameraFrameRight,
	StartCameraFrame,
	StopCameraFrame
}
public static class Pvr_UnitySDKPluginEvent
{
	private delegate void RenderEventDelegate(int eventId);

	private const uint IS_DATA_FLAG = 2147483648u;

	private const uint DATA_POS_MASK = 1073741824u;

	private const int DATA_POS_SHIFT = 30;

	private const uint EVENT_TYPE_MASK = 1056899072u;

	private const int EVENT_TYPE_SHIFT = 17;

	private const uint PAYLOAD_MASK = 65535u;

	private const int PAYLOAD_SHIFT = 16;

	private static RenderEventDelegate SetSinglePassBeforeForwardOpaqueHandle = SetSinglePassBeforeForwardOpaque;

	private static IntPtr SetSinglePassBeforeForwardOpaquePtr = Marshal.GetFunctionPointerForDelegate(SetSinglePassBeforeForwardOpaqueHandle);

	public static void Issue(RenderEventType eventType)
	{
		GL.IssuePluginEvent(Pvr_UnitySDKAPI.System.GetRenderEventFunc(), (int)eventType);
	}

	private static int EncodeType(int eventType)
	{
		return eventType & 0x7FFFFFFF;
	}

	private static int EncodeData(int eventId, int eventData, int pos)
	{
		return int.MinValue | ((pos << 30) & 0x40000000) | ((eventId << 17) & 0x3EFF0000) | ((eventData >>> pos * 16) & 0xFFFF);
	}

	private static int DecodeData(int eventData)
	{
		uint num = (uint)(eventData & 0x40000000) >> 30;
		return (eventData & 0xFFFF) << (int)(16 * num);
	}

	[MonoPInvokeCallback(typeof(RenderEventDelegate))]
	private static void SetSinglePassBeforeForwardOpaque(int eventId)
	{
		Pvr_UnitySDKAPI.System.UPvr_SinglePassBeforeForwardOpaque();
	}

	public static void SetSinglePassBeforeForwardOpaque(CommandBuffer cmd)
	{
		cmd.IssuePluginEvent(SetSinglePassBeforeForwardOpaquePtr, 0);
	}
}
public class Pvr_UnitySDKSightInputModule : BaseInputModule
{
	[Tooltip("Optional object to place at raycast intersections as a 3D cursor. Be sure it is on a layer that raycasts will ignore.")]
	public GameObject cursor;

	public int trigger;

	[HideInInspector]
	public float clickTime = 0.1f;

	[HideInInspector]
	public Vector2 hotspot = new Vector2(0.5f, 0.5f);

	private PointerEventData pointerData;

	public override bool ShouldActivateModule()
	{
		if (!base.ShouldActivateModule())
		{
			return false;
		}
		return Pvr_UnitySDKManager.SDK.VRModeEnabled;
	}

	public override void DeactivateModule()
	{
		base.DeactivateModule();
		if (pointerData != null)
		{
			HandlePendingClick();
			HandlePointerExitAndEnter(pointerData, null);
			pointerData = null;
		}
		base.eventSystem.SetSelectedGameObject(null, GetBaseEventData());
		if (cursor != null)
		{
			cursor.SetActive(value: false);
		}
	}

	public override bool IsPointerOverGameObject(int pointerId)
	{
		if (pointerData != null)
		{
			return pointerData.pointerEnter != null;
		}
		return false;
	}

	public override void Process()
	{
		CastRayFromGaze();
		UpdateCurrentObject();
		PlaceCursor();
		HandlePendingClick();
		HandleTrigger();
	}

	private void CastRayFromGaze()
	{
		if (pointerData == null)
		{
			pointerData = new PointerEventData(base.eventSystem);
		}
		pointerData.Reset();
		pointerData.position = new Vector2(hotspot.x * (float)Screen.width, hotspot.y * (float)Screen.height);
		base.eventSystem.RaycastAll(pointerData, m_RaycastResultCache);
		pointerData.pointerCurrentRaycast = BaseInputModule.FindFirstRaycast(m_RaycastResultCache);
		m_RaycastResultCache.Clear();
	}

	private void UpdateCurrentObject()
	{
		GameObject gameObject = pointerData.pointerCurrentRaycast.gameObject;
		HandlePointerExitAndEnter(pointerData, gameObject);
		if (ExecuteEvents.GetEventHandler<ISelectHandler>(gameObject) == base.eventSystem.currentSelectedGameObject)
		{
			ExecuteEvents.Execute(base.eventSystem.currentSelectedGameObject, GetBaseEventData(), ExecuteEvents.updateSelectedHandler);
		}
		else
		{
			base.eventSystem.SetSelectedGameObject(null, pointerData);
		}
	}

	private void PlaceCursor()
	{
		if (!(cursor == null))
		{
			GameObject gameObject = pointerData.pointerCurrentRaycast.gameObject;
			cursor.SetActive(gameObject != null);
			if (cursor.activeInHierarchy)
			{
				Camera enterEventCamera = pointerData.enterEventCamera;
				float num = pointerData.pointerCurrentRaycast.distance + enterEventCamera.nearClipPlane - 0.1f;
				cursor.transform.position = enterEventCamera.transform.position + enterEventCamera.transform.forward * num;
			}
		}
	}

	private void HandlePendingClick()
	{
		if (pointerData.eligibleForClick && (Pvr_UnitySDKManager.SDK.picovrTriggered || !(Time.unscaledTime - pointerData.clickTime < clickTime)))
		{
			ExecuteEvents.Execute(pointerData.pointerPress, pointerData, ExecuteEvents.pointerUpHandler);
			ExecuteEvents.Execute(pointerData.pointerPress, pointerData, ExecuteEvents.pointerClickHandler);
			pointerData.pointerPress = null;
			pointerData.rawPointerPress = null;
			pointerData.eligibleForClick = false;
			pointerData.clickCount = 0;
		}
	}

	private void HandleTrigger()
	{
		if (Pvr_UnitySDKManager.SDK.picovrTriggered)
		{
			GameObject gameObject = pointerData.pointerCurrentRaycast.gameObject;
			if (!(gameObject == null) && !(ExecuteEvents.GetEventHandler<IPointerClickHandler>(gameObject) == null))
			{
				pointerData.pointerPress = ExecuteEvents.GetEventHandler<IPointerClickHandler>(gameObject);
				pointerData.pressPosition = pointerData.position;
				pointerData.pointerPressRaycast = pointerData.pointerCurrentRaycast;
				pointerData.pointerPress = ExecuteEvents.ExecuteHierarchy(gameObject, pointerData, ExecuteEvents.pointerDownHandler) ?? ExecuteEvents.GetEventHandler<IPointerClickHandler>(gameObject);
				pointerData.rawPointerPress = gameObject;
				pointerData.eligibleForClick = true;
				pointerData.clickCount = 1;
				pointerData.clickTime = Time.unscaledTime;
			}
		}
	}
}
public class Pvr_ObjImporter
{
	private static Pvr_ObjImporter _instance;

	private List<int> triangles;

	private List<Vector3> vertices;

	private List<Vector2> uv;

	private List<Vector3> normals;

	private List<PvrVector3Int> faceData;

	private List<int> intArray;

	private const int MIN_POW_10 = -16;

	private const int MAX_POW_10 = 16;

	private const int NUM_POWS_10 = 33;

	private static readonly float[] pow10 = GenerateLookupTable();

	public static Pvr_ObjImporter Instance => _instance ?? (_instance = new Pvr_ObjImporter());

	public Mesh ImportFile(string filePath)
	{
		triangles = new List<int>();
		vertices = new List<Vector3>();
		uv = new List<Vector2>();
		normals = new List<Vector3>();
		faceData = new List<PvrVector3Int>();
		intArray = new List<int>();
		LoadMeshData(filePath);
		Vector3[] array = new Vector3[faceData.Count];
		Vector2[] array2 = new Vector2[faceData.Count];
		Vector3[] array3 = new Vector3[faceData.Count];
		for (int i = 0; i < faceData.Count; i++)
		{
			array[i] = vertices[faceData[i].x - 1];
			if (faceData[i].y >= 1)
			{
				array2[i] = uv[faceData[i].y - 1];
			}
			if (faceData[i].z >= 1)
			{
				array3[i] = normals[faceData[i].z - 1];
			}
		}
		Mesh mesh = new Mesh();
		mesh.vertices = array;
		mesh.uv = array2;
		mesh.normals = array3;
		mesh.triangles = triangles.ToArray();
		mesh.RecalculateBounds();
		return mesh;
	}

	private void LoadMeshData(string fileName)
	{
		StringBuilder stringBuilder = new StringBuilder();
		string text = File.ReadAllText(fileName);
		int num = 0;
		string text2 = null;
		int num2 = 0;
		StringBuilder sbInt = new StringBuilder();
		for (int i = 0; i < text.Length; i++)
		{
			if (text[i] != '\n')
			{
				continue;
			}
			stringBuilder.Remove(0, stringBuilder.Length);
			stringBuilder.Append(text, num + 1, i - num);
			num = i;
			if (stringBuilder[0] == 'o' && stringBuilder[1] == ' ')
			{
				sbInt.Remove(0, sbInt.Length);
				for (int j = 2; j < stringBuilder.Length; j++)
				{
					text2 += stringBuilder[j];
				}
			}
			else if (stringBuilder[0] == 'v' && stringBuilder[1] == ' ')
			{
				int start = 2;
				vertices.Add(new Vector3(GetFloat(stringBuilder, ref start, ref sbInt), GetFloat(stringBuilder, ref start, ref sbInt), GetFloat(stringBuilder, ref start, ref sbInt)));
			}
			else if (stringBuilder[0] == 'v' && stringBuilder[1] == 't' && stringBuilder[2] == ' ')
			{
				int start2 = 3;
				uv.Add(new Vector2(GetFloat(stringBuilder, ref start2, ref sbInt), GetFloat(stringBuilder, ref start2, ref sbInt)));
			}
			else if (stringBuilder[0] == 'v' && stringBuilder[1] == 'n' && stringBuilder[2] == ' ')
			{
				int start3 = 3;
				normals.Add(new Vector3(GetFloat(stringBuilder, ref start3, ref sbInt), GetFloat(stringBuilder, ref start3, ref sbInt), GetFloat(stringBuilder, ref start3, ref sbInt)));
			}
			else if (stringBuilder[0] == 'f' && stringBuilder[1] == ' ')
			{
				int start4 = 2;
				int num3 = 1;
				intArray.Clear();
				int num4 = 0;
				while (start4 < stringBuilder.Length && char.IsDigit(stringBuilder[start4]))
				{
					faceData.Add(new PvrVector3Int(GetInt(stringBuilder, ref start4, ref sbInt), GetInt(stringBuilder, ref start4, ref sbInt), GetInt(stringBuilder, ref start4, ref sbInt)));
					num3++;
					intArray.Add(num2);
					num2++;
				}
				num4 += num3;
				for (num3 = 1; num3 + 2 < num4; num3++)
				{
					triangles.Add(intArray[0]);
					triangles.Add(intArray[num3]);
					triangles.Add(intArray[num3 + 1]);
				}
			}
		}
	}

	private float GetFloat(StringBuilder sb, ref int start, ref StringBuilder sbFloat)
	{
		sbFloat.Remove(0, sbFloat.Length);
		while (start < sb.Length && (char.IsDigit(sb[start]) || sb[start] == '-' || sb[start] == '.'))
		{
			sbFloat.Append(sb[start]);
			start++;
		}
		start++;
		return ParseFloat(sbFloat);
	}

	private int GetInt(StringBuilder sb, ref int start, ref StringBuilder sbInt)
	{
		sbInt.Remove(0, sbInt.Length);
		while (start < sb.Length && char.IsDigit(sb[start]))
		{
			sbInt.Append(sb[start]);
			start++;
		}
		start++;
		return IntParseFast(sbInt);
	}

	private static float[] GenerateLookupTable()
	{
		float[] array = new float[320];
		for (int i = 0; i < array.Length; i++)
		{
			array[i] = (float)(i / 33) * Mathf.Pow(10f, i % 33 + -16);
		}
		return array;
	}

	private float ParseFloat(StringBuilder value)
	{
		float num = 0f;
		bool flag = false;
		int length = value.Length;
		int num2 = value.Length;
		for (int num3 = length - 1; num3 >= 0; num3--)
		{
			if (value[num3] == '.')
			{
				num2 = num3;
				break;
			}
		}
		int num4 = 16 + num2;
		for (int i = 0; i < num2; i++)
		{
			if (i != num2 && value[i] != '-')
			{
				num += pow10[(value[i] - 48) * 33 + num4 - i - 1];
			}
			else if (value[i] == '-')
			{
				flag = true;
			}
		}
		for (int j = num2 + 1; j < length; j++)
		{
			if (j != num2)
			{
				num += pow10[(value[j] - 48) * 33 + num4 - j];
			}
		}
		if (flag)
		{
			num = 0f - num;
		}
		return num;
	}

	private int IntParseFast(StringBuilder value)
	{
		int num = 0;
		for (int i = 0; i < value.Length; i++)
		{
			num = 10 * num + (value[i] - 48);
		}
		return num;
	}
}
public sealed class PvrVector3Int
{
	public int x { get; set; }

	public int y { get; set; }

	public int z { get; set; }

	public PvrVector3Int()
	{
	}

	public PvrVector3Int(int x, int y, int z)
	{
		this.x = x;
		this.y = y;
		this.z = z;
	}
}
public class Pvr_EnumFlags : PropertyAttribute
{
}
public enum ConfirmBtn
{
	App = 1,
	TouchPad = 2,
	Trigger = 4
}
public class Pvr_InputModule : PointerInputModule
{
	public static List<Pvr_UIPointer> pointers = new List<Pvr_UIPointer>();

	[Pvr_EnumFlags]
	public ConfirmBtn confirmBtn = ConfirmBtn.TouchPad;

	private List<RaycastResult> rayCasts = new List<RaycastResult>();

	private RaycastResult rayCastResult;

	public virtual void Initialise()
	{
		pointers.Clear();
	}

	public static void AddPoint(Pvr_UIPointer point)
	{
		if (!pointers.Contains(point))
		{
			pointers.Add(point);
		}
	}

	public static void RemovePoint(Pvr_UIPointer point)
	{
		if (pointers.Contains(point))
		{
			pointers.Remove(point);
		}
	}

	public override void Process()
	{
		if (Pvr_UnitySDKManager.SDK.isHasController)
		{
			if ((confirmBtn & ConfirmBtn.App) == ConfirmBtn.App)
			{
				Pvr_UIPointer.AppBtnValue = Controller.UPvr_GetKey(Pvr_ControllerManager.controllerlink.mainHandID, Pvr_KeyCode.APP);
			}
			if ((confirmBtn & ConfirmBtn.TouchPad) == ConfirmBtn.TouchPad)
			{
				Pvr_UIPointer.TouchBtnValue = Controller.UPvr_GetKey(Pvr_ControllerManager.controllerlink.mainHandID, Pvr_KeyCode.TOUCHPAD);
			}
			if ((confirmBtn & ConfirmBtn.Trigger) == ConfirmBtn.Trigger)
			{
				Pvr_UIPointer.TriggerBtnValue = Controller.UPvr_GetKey(Pvr_ControllerManager.controllerlink.mainHandID, Pvr_KeyCode.TRIGGER);
			}
		}
		for (int i = 0; i < pointers.Count; i++)
		{
			Pvr_UIPointer pvr_UIPointer = pointers[i];
			if (pvr_UIPointer.gameObject.activeInHierarchy && pvr_UIPointer.enabled)
			{
				List<RaycastResult> results = new List<RaycastResult>();
				if (pvr_UIPointer.PointerActive())
				{
					results = CheckRaycasts(pvr_UIPointer);
				}
				Hover(pvr_UIPointer, results);
				Click(pvr_UIPointer, results);
				Drag(pvr_UIPointer, results);
			}
		}
	}

	protected virtual List<RaycastResult> CheckRaycasts(Pvr_UIPointer pointer)
	{
		rayCastResult.worldPosition = pointer.GetOriginPosition();
		rayCastResult.worldNormal = pointer.GetOriginForward();
		pointer.pointerEventData.pointerCurrentRaycast = rayCastResult;
		base.eventSystem.RaycastAll(pointer.pointerEventData, rayCasts);
		return rayCasts;
	}

	protected virtual bool CheckTransformTree(Transform target, Transform source)
	{
		if (target == null)
		{
			return false;
		}
		if (target.Equals(source))
		{
			return true;
		}
		return CheckTransformTree(target.transform.parent, source);
	}

	protected virtual bool NoValidCollision(Pvr_UIPointer pointer, List<RaycastResult> results)
	{
		if (results.Count != 0)
		{
			return !CheckTransformTree(results[0].gameObject.transform, pointer.pointerEventData.pointerEnter.transform);
		}
		return true;
	}

	protected virtual bool IsHovering(Pvr_UIPointer pointer)
	{
		foreach (GameObject item in pointer.pointerEventData.hovered)
		{
			if ((bool)pointer.pointerEventData.pointerEnter && (bool)item && CheckTransformTree(item.transform, pointer.pointerEventData.pointerEnter.transform))
			{
				return true;
			}
		}
		return false;
	}

	protected virtual bool ValidElement(GameObject obj)
	{
		Pvr_UICanvas componentInParent = obj.GetComponentInParent<Pvr_UICanvas>();
		if (!componentInParent || !componentInParent.enabled)
		{
			return false;
		}
		return true;
	}

	protected virtual void CheckPointerHoverClick(Pvr_UIPointer pointer, List<RaycastResult> results)
	{
		if (pointer.hoverDurationTimer > 0f)
		{
			pointer.hoverDurationTimer -= Time.deltaTime;
		}
		if (pointer.canClickOnHover && pointer.hoverDurationTimer <= 0f)
		{
			pointer.canClickOnHover = false;
			ClickOnDown(pointer, results, forceClick: true);
		}
	}

	protected virtual void Hover(Pvr_UIPointer pointer, List<RaycastResult> results)
	{
		if ((bool)pointer.pointerEventData.pointerEnter)
		{
			CheckPointerHoverClick(pointer, results);
			if (!ValidElement(pointer.pointerEventData.pointerEnter))
			{
				pointer.pointerEventData.pointerEnter = null;
				return;
			}
			if (NoValidCollision(pointer, results))
			{
				ExecuteEvents.ExecuteHierarchy(pointer.pointerEventData.pointerEnter, pointer.pointerEventData, ExecuteEvents.pointerExitHandler);
				pointer.pointerEventData.hovered.Remove(pointer.pointerEventData.pointerEnter);
				pointer.pointerEventData.pointerEnter = null;
			}
			if (results.Count <= 0 || !(pointer.pointerEventData.pointerEnter != results[0].gameObject))
			{
				return;
			}
			{
				foreach (RaycastResult result in results)
				{
					if (!ValidElement(result.gameObject))
					{
						continue;
					}
					GameObject gameObject = ExecuteEvents.ExecuteHierarchy(result.gameObject, pointer.pointerEventData, ExecuteEvents.pointerEnterHandler);
					if (gameObject != null)
					{
						Selectable component = gameObject.GetComponent<Selectable>();
						if ((bool)component)
						{
							Navigation navigation = default(Navigation);
							navigation.mode = Navigation.Mode.None;
							component.navigation = navigation;
						}
						pointer.pointerEventData.hovered.Remove(pointer.pointerEventData.pointerEnter);
						pointer.OnUIPointerElementEnter(pointer.SetUIPointerEvent(result, gameObject, pointer.hoveringElement));
						pointer.hoveringElement = gameObject;
						pointer.pointerEventData.pointerCurrentRaycast = result;
						pointer.pointerEventData.pointerEnter = gameObject;
						pointer.pointerEventData.hovered.Add(pointer.pointerEventData.pointerEnter);
						break;
					}
					if (result.gameObject != pointer.hoveringElement)
					{
						pointer.OnUIPointerElementEnter(pointer.SetUIPointerEvent(result, result.gameObject, pointer.hoveringElement));
					}
					pointer.hoveringElement = result.gameObject;
				}
				return;
			}
		}
		foreach (RaycastResult result2 in results)
		{
			if (!ValidElement(result2.gameObject))
			{
				continue;
			}
			GameObject gameObject2 = ExecuteEvents.ExecuteHierarchy(result2.gameObject, pointer.pointerEventData, ExecuteEvents.pointerEnterHandler);
			if (gameObject2 != null)
			{
				Selectable component2 = gameObject2.GetComponent<Selectable>();
				if ((bool)component2)
				{
					Navigation navigation2 = default(Navigation);
					navigation2.mode = Navigation.Mode.None;
					component2.navigation = navigation2;
				}
				pointer.OnUIPointerElementEnter(pointer.SetUIPointerEvent(result2, gameObject2, pointer.hoveringElement));
				pointer.hoveringElement = gameObject2;
				pointer.pointerEventData.pointerCurrentRaycast = result2;
				pointer.pointerEventData.pointerEnter = gameObject2;
				pointer.pointerEventData.hovered.Add(pointer.pointerEventData.pointerEnter);
				break;
			}
			if (result2.gameObject != pointer.hoveringElement)
			{
				pointer.OnUIPointerElementEnter(pointer.SetUIPointerEvent(result2, result2.gameObject, pointer.hoveringElement));
			}
			pointer.hoveringElement = result2.gameObject;
		}
		if ((bool)pointer.hoveringElement && results.Count == 0)
		{
			pointer.OnUIPointerElementExit(pointer.SetUIPointerEvent(default(RaycastResult), null, pointer.hoveringElement));
			pointer.hoveringElement = null;
		}
	}

	protected virtual void Click(Pvr_UIPointer pointer, List<RaycastResult> results)
	{
		switch (pointer.clickMethod)
		{
		case Pvr_UIPointer.ClickMethods.ClickOnButtonUp:
			ClickOnUp(pointer, results);
			break;
		case Pvr_UIPointer.ClickMethods.ClickOnButtonDown:
			ClickOnDown(pointer, results);
			break;
		}
	}

	protected virtual void ClickOnUp(Pvr_UIPointer pointer, List<RaycastResult> results)
	{
		pointer.pointerEventData.eligibleForClick = pointer.ValidClick(checkLastClick: false);
		if (!AttemptClick(pointer))
		{
			IsEligibleClick(pointer, results);
		}
	}

	protected virtual void ClickOnDown(Pvr_UIPointer pointer, List<RaycastResult> results, bool forceClick = false)
	{
		pointer.pointerEventData.eligibleForClick = forceClick || pointer.ValidClick(checkLastClick: true);
		if (IsEligibleClick(pointer, results))
		{
			pointer.pointerEventData.eligibleForClick = false;
			AttemptClick(pointer);
		}
	}

	protected virtual bool IsEligibleClick(Pvr_UIPointer pointer, List<RaycastResult> results)
	{
		if (pointer.pointerEventData.eligibleForClick)
		{
			foreach (RaycastResult result in results)
			{
				if (ValidElement(result.gameObject))
				{
					GameObject gameObject = ExecuteEvents.ExecuteHierarchy(result.gameObject, pointer.pointerEventData, ExecuteEvents.pointerDownHandler);
					if (gameObject != null)
					{
						pointer.pointerEventData.pressPosition = pointer.pointerEventData.position;
						pointer.pointerEventData.pointerPressRaycast = result;
						pointer.pointerEventData.pointerPress = gameObject;
						return true;
					}
				}
			}
		}
		return false;
	}

	protected virtual bool AttemptClick(Pvr_UIPointer pointer)
	{
		if ((bool)pointer.pointerEventData.pointerPress)
		{
			if (!ValidElement(pointer.pointerEventData.pointerPress))
			{
				pointer.pointerEventData.pointerPress = null;
				return true;
			}
			if (pointer.pointerEventData.eligibleForClick)
			{
				if (!IsHovering(pointer))
				{
					ExecuteEvents.ExecuteHierarchy(pointer.pointerEventData.pointerPress, pointer.pointerEventData, ExecuteEvents.pointerUpHandler);
					pointer.pointerEventData.pointerPress = null;
				}
			}
			else
			{
				pointer.OnUIPointerElementClick(pointer.SetUIPointerEvent(pointer.pointerEventData.pointerPressRaycast, pointer.pointerEventData.pointerPress));
				ExecuteEvents.ExecuteHierarchy(pointer.pointerEventData.pointerPress, pointer.pointerEventData, ExecuteEvents.pointerClickHandler);
				ExecuteEvents.ExecuteHierarchy(pointer.pointerEventData.pointerPress, pointer.pointerEventData, ExecuteEvents.pointerUpHandler);
				pointer.pointerEventData.pointerPress = null;
			}
			return true;
		}
		return false;
	}

	protected virtual void Drag(Pvr_UIPointer pointer, List<RaycastResult> results)
	{
		pointer.pointerEventData.dragging = pointer.IsSelectionButtonPressed() && pointer.pointerEventData.delta != Vector2.zero;
		if ((bool)pointer.pointerEventData.pointerDrag)
		{
			if (!ValidElement(pointer.pointerEventData.pointerDrag))
			{
				pointer.pointerEventData.pointerDrag = null;
				return;
			}
			if (pointer.pointerEventData.dragging)
			{
				if (IsHovering(pointer))
				{
					ExecuteEvents.ExecuteHierarchy(pointer.pointerEventData.pointerDrag, pointer.pointerEventData, ExecuteEvents.dragHandler);
				}
				return;
			}
			ExecuteEvents.ExecuteHierarchy(pointer.pointerEventData.pointerDrag, pointer.pointerEventData, ExecuteEvents.dragHandler);
			ExecuteEvents.ExecuteHierarchy(pointer.pointerEventData.pointerDrag, pointer.pointerEventData, ExecuteEvents.endDragHandler);
			foreach (RaycastResult result in results)
			{
				ExecuteEvents.ExecuteHierarchy(result.gameObject, pointer.pointerEventData, ExecuteEvents.dropHandler);
			}
			pointer.pointerEventData.pointerDrag = null;
		}
		else
		{
			if (!pointer.pointerEventData.dragging)
			{
				return;
			}
			foreach (RaycastResult result2 in results)
			{
				if (ValidElement(result2.gameObject))
				{
					ExecuteEvents.ExecuteHierarchy(result2.gameObject, pointer.pointerEventData, ExecuteEvents.initializePotentialDrag);
					ExecuteEvents.ExecuteHierarchy(result2.gameObject, pointer.pointerEventData, ExecuteEvents.beginDragHandler);
					GameObject gameObject = ExecuteEvents.ExecuteHierarchy(result2.gameObject, pointer.pointerEventData, ExecuteEvents.dragHandler);
					if (gameObject != null)
					{
						pointer.pointerEventData.pointerDrag = gameObject;
						break;
					}
				}
			}
		}
	}
}
public class Pvr_UICanvas : MonoBehaviour
{
	public bool clickOnPointerCollision;

	public float autoActivateWithinDistance;

	protected BoxCollider canvasBoxCollider;

	protected Rigidbody canvasRigidBody;

	protected Coroutine draggablePanelCreation;

	protected const string CANVAS_DRAGGABLE_PANEL = "UICANVAS_DRAGGABLE_PANEL";

	protected virtual void OnEnable()
	{
		SetupCanvas();
	}

	protected virtual void OnDisable()
	{
		RemoveCanvas();
	}

	protected virtual void OnDestroy()
	{
		RemoveCanvas();
	}

	protected virtual void SetupCanvas()
	{
		Canvas component = GetComponent<Canvas>();
		if ((bool)component && component.renderMode == RenderMode.WorldSpace)
		{
			RectTransform component2 = component.GetComponent<RectTransform>();
			Vector2 sizeDelta = component2.sizeDelta;
			GraphicRaycaster component3 = component.gameObject.GetComponent<GraphicRaycaster>();
			Pvr_UIGraphicRaycaster pvr_UIGraphicRaycaster = component.gameObject.GetComponent<Pvr_UIGraphicRaycaster>();
			if (!pvr_UIGraphicRaycaster)
			{
				pvr_UIGraphicRaycaster = component.gameObject.AddComponent<Pvr_UIGraphicRaycaster>();
			}
			if ((bool)component3 && component3.enabled)
			{
				pvr_UIGraphicRaycaster.ignoreReversedGraphics = component3.ignoreReversedGraphics;
				pvr_UIGraphicRaycaster.blockingObjects = component3.blockingObjects;
				component3.enabled = false;
			}
			if (!component.gameObject.GetComponent<BoxCollider>())
			{
				float z = 0.1f / component2.localScale.z;
				canvasBoxCollider = component.gameObject.AddComponent<BoxCollider>();
				canvasBoxCollider.size = new Vector3(sizeDelta.x, sizeDelta.y, z);
				canvasBoxCollider.isTrigger = true;
			}
			if (!component.gameObject.GetComponent<Rigidbody>())
			{
				canvasRigidBody = component.gameObject.AddComponent<Rigidbody>();
				canvasRigidBody.isKinematic = true;
			}
			draggablePanelCreation = StartCoroutine(CreateDraggablePanel(component, sizeDelta));
		}
	}

	protected virtual IEnumerator CreateDraggablePanel(Canvas canvas, Vector2 canvasSize)
	{
		if ((bool)canvas && !canvas.transform.Find("UICANVAS_DRAGGABLE_PANEL"))
		{
			yield return null;
			GameObject obj = new GameObject("UICANVAS_DRAGGABLE_PANEL", typeof(RectTransform));
			obj.AddComponent<LayoutElement>().ignoreLayout = true;
			obj.AddComponent<Image>().color = Color.clear;
			obj.AddComponent<EventTrigger>();
			obj.transform.SetParent(canvas.transform);
			obj.GetComponent<RectTransform>().sizeDelta = canvasSize;
			obj.transform.localPosition = Vector3.zero;
			obj.transform.localRotation = Quaternion.identity;
			obj.transform.localScale = Vector3.one;
			obj.transform.SetAsFirstSibling();
		}
	}

	protected virtual void RemoveCanvas()
	{
		Canvas component = GetComponent<Canvas>();
		if ((bool)component)
		{
			GraphicRaycaster component2 = component.gameObject.GetComponent<GraphicRaycaster>();
			Pvr_UIGraphicRaycaster component3 = component.gameObject.GetComponent<Pvr_UIGraphicRaycaster>();
			if ((bool)component3)
			{
				UnityEngine.Object.Destroy(component3);
			}
			if ((bool)component2 && !component2.enabled)
			{
				component2.enabled = true;
			}
			if ((bool)canvasBoxCollider)
			{
				UnityEngine.Object.Destroy(canvasBoxCollider);
			}
			if ((bool)canvasRigidBody)
			{
				UnityEngine.Object.Destroy(canvasRigidBody);
			}
			StopCoroutine(draggablePanelCreation);
			Transform transform = component.transform.Find("UICANVAS_DRAGGABLE_PANEL");
			if ((bool)transform)
			{
				UnityEngine.Object.Destroy(transform.gameObject);
			}
		}
	}
}
public struct UIDraggableItemEventArgs
{
	public GameObject target;
}
public delegate void UIDraggableItemEventHandler(object sender, UIDraggableItemEventArgs e);
public class Pvr_UIDraggableItem : MonoBehaviour, IBeginDragHandler, IEventSystemHandler, IDragHandler, IEndDragHandler
{
	public bool restrictToDropZone;

	public bool restrictToOriginalCanvas;

	public float moveOffset = 0.1f;

	[HideInInspector]
	public GameObject validDropZone;

	protected RectTransform dragTransform;

	protected Vector3 startPosition;

	protected Quaternion startRotation;

	protected GameObject startDropZone;

	protected Transform startParent;

	protected Canvas startCanvas;

	protected CanvasGroup canvasGroup;

	protected Pvr_InputModule currentInputmodule;

	public event UIDraggableItemEventHandler DraggableItemDropped;

	public event UIDraggableItemEventHandler DraggableItemReset;

	public virtual void OnDraggableItemDropped(UIDraggableItemEventArgs e)
	{
		if (this.DraggableItemDropped != null)
		{
			this.DraggableItemDropped(this, e);
		}
	}

	public virtual void OnDraggableItemReset(UIDraggableItemEventArgs e)
	{
		if (this.DraggableItemReset != null)
		{
			this.DraggableItemReset(this, e);
		}
	}

	public void OnBeginDrag(PointerEventData eventData)
	{
		startPosition = base.transform.position;
		startRotation = base.transform.rotation;
		startParent = base.transform.parent;
		startCanvas = GetComponentInParent<Canvas>();
		canvasGroup.blocksRaycasts = false;
		if (restrictToDropZone)
		{
			startDropZone = GetComponentInParent<Pvr_UIDropZone>().gameObject;
			validDropZone = startDropZone;
		}
		SetDragPosition(eventData);
		Pvr_UIPointer pointer = GetPointer();
		if (pointer != null)
		{
			pointer.OnUIPointerElementDragStart(pointer.SetUIPointerEvent(pointer.pointerEventData.pointerPressRaycast, base.gameObject));
		}
	}

	public void OnDrag(PointerEventData eventData)
	{
		SetDragPosition(eventData);
	}

	public void OnEndDrag(PointerEventData eventData)
	{
		canvasGroup.blocksRaycasts = true;
		dragTransform = null;
		base.transform.position += base.transform.forward * moveOffset;
		bool flag = true;
		if (restrictToDropZone)
		{
			if (validDropZone != null && validDropZone != startDropZone)
			{
				base.transform.SetParent(validDropZone.transform);
			}
			else
			{
				ResetElement();
				flag = false;
			}
		}
		Canvas canvas = ((eventData.pointerEnter != null) ? eventData.pointerEnter.GetComponentInParent<Canvas>() : null);
		if (restrictToOriginalCanvas && canvas != null && canvas != startCanvas)
		{
			ResetElement();
			flag = false;
		}
		if (canvas == null)
		{
			ResetElement();
			flag = false;
		}
		if (flag)
		{
			Pvr_UIPointer pointer = GetPointer();
			if (pointer != null)
			{
				pointer.OnUIPointerElementDragEnd(pointer.SetUIPointerEvent(pointer.pointerEventData.pointerPressRaycast, base.gameObject));
			}
			OnDraggableItemDropped(SetEventPayload(validDropZone));
		}
		validDropZone = null;
		startParent = null;
		startCanvas = null;
	}

	protected virtual void OnEnable()
	{
		canvasGroup = GetComponent<CanvasGroup>();
		if (restrictToDropZone && GetComponentInParent<Pvr_UIDropZone>() == null)
		{
			base.enabled = false;
		}
		currentInputmodule = UnityEngine.Object.FindObjectOfType<Pvr_InputModule>();
	}

	protected virtual Pvr_UIPointer GetPointer()
	{
		foreach (Pvr_UIPointer pointer in Pvr_InputModule.pointers)
		{
			if (pointer.gameObject.activeInHierarchy && (bool)pointer)
			{
				return pointer;
			}
		}
		return null;
	}

	protected virtual void SetDragPosition(PointerEventData eventData)
	{
		if (eventData.pointerEnter != null && eventData.pointerEnter.transform as RectTransform != null)
		{
			dragTransform = eventData.pointerEnter.transform as RectTransform;
		}
		if (dragTransform != null && RectTransformUtility.ScreenPointToWorldPointInRectangle(dragTransform, eventData.position, eventData.pressEventCamera, out var worldPoint))
		{
			base.transform.position = worldPoint - base.transform.forward * moveOffset;
			base.transform.rotation = dragTransform.rotation;
		}
	}

	protected virtual void ResetElement()
	{
		base.transform.position = startPosition;
		base.transform.rotation = startRotation;
		base.transform.SetParent(startParent);
		OnDraggableItemReset(SetEventPayload(startParent.gameObject));
	}

	protected virtual UIDraggableItemEventArgs SetEventPayload(GameObject target)
	{
		UIDraggableItemEventArgs result = default(UIDraggableItemEventArgs);
		result.target = target;
		return result;
	}
}
public class Pvr_UIDropZone : MonoBehaviour, IPointerEnterHandler, IEventSystemHandler, IPointerExitHandler
{
	protected Pvr_UIDraggableItem droppableItem;

	public void OnPointerEnter(PointerEventData eventData)
	{
		if ((bool)eventData.pointerDrag)
		{
			Pvr_UIDraggableItem component = eventData.pointerDrag.GetComponent<Pvr_UIDraggableItem>();
			if ((bool)component && component.restrictToDropZone)
			{
				component.validDropZone = base.gameObject;
				droppableItem = component;
			}
		}
	}

	public void OnPointerExit(PointerEventData eventData)
	{
		if ((bool)droppableItem)
		{
			droppableItem.validDropZone = null;
		}
		droppableItem = null;
	}
}
public class Pvr_UIGraphicRaycaster : GraphicRaycaster
{
	protected Canvas currentCanvas;

	protected Vector2 lastKnownPosition;

	protected const float UI_CONTROL_OFFSET = 1E-05f;

	[NonSerialized]
	private static List<RaycastResult> s_RaycastResults = new List<RaycastResult>();

	protected virtual Canvas canvas
	{
		get
		{
			if (currentCanvas != null)
			{
				return currentCanvas;
			}
			currentCanvas = base.gameObject.GetComponent<Canvas>();
			return currentCanvas;
		}
	}

	public override void Raycast(PointerEventData eventData, List<RaycastResult> resultAppendList)
	{
		if (!(canvas == null))
		{
			Raycast(ray: new Ray(eventData.pointerCurrentRaycast.worldPosition, eventData.pointerCurrentRaycast.worldNormal), canvas: canvas, eventCamera: eventCamera, results: ref s_RaycastResults);
			SetNearestRaycast(ref eventData, ref resultAppendList, ref s_RaycastResults);
			s_RaycastResults.Clear();
		}
	}

	protected virtual void SetNearestRaycast(ref PointerEventData eventData, ref List<RaycastResult> resultAppendList, ref List<RaycastResult> raycastResults)
	{
		RaycastResult? raycastResult = null;
		for (int i = 0; i < raycastResults.Count; i++)
		{
			RaycastResult raycastResult2 = raycastResults[i];
			raycastResult2.index = resultAppendList.Count;
			if (!raycastResult.HasValue || raycastResult2.distance < raycastResult.Value.distance)
			{
				raycastResult = raycastResult2;
			}
			resultAppendList.Add(raycastResult2);
		}
		if (raycastResult.HasValue)
		{
			eventData.position = raycastResult.Value.screenPosition;
			eventData.delta = eventData.position - lastKnownPosition;
			lastKnownPosition = eventData.position;
			eventData.pointerCurrentRaycast = raycastResult.Value;
		}
	}

	protected virtual float GetHitDistance(Ray ray)
	{
		float result = float.MaxValue;
		if (canvas.renderMode != 0 && base.blockingObjects != 0)
		{
			float num = Vector3.Distance(ray.origin, canvas.transform.position);
			if (base.blockingObjects == BlockingObjects.ThreeD || base.blockingObjects == BlockingObjects.All)
			{
				Physics.Raycast(ray, out var hitInfo, num);
				if ((bool)hitInfo.collider)
				{
					result = hitInfo.distance;
				}
			}
			if (base.blockingObjects == BlockingObjects.TwoD || base.blockingObjects == BlockingObjects.All)
			{
				RaycastHit2D raycastHit2D = Physics2D.Raycast(ray.origin, ray.direction, num);
				if (raycastHit2D.collider != null)
				{
					result = raycastHit2D.fraction * num;
				}
			}
		}
		return result;
	}

	protected virtual void Raycast(Canvas canvas, Camera eventCamera, Ray ray, ref List<RaycastResult> results)
	{
		float hitDistance = GetHitDistance(ray);
		IList<Graphic> graphicsForCanvas = GraphicRegistry.GetGraphicsForCanvas(canvas);
		for (int i = 0; i < graphicsForCanvas.Count; i++)
		{
			Graphic graphic = graphicsForCanvas[i];
			if (graphic.depth == -1 || !graphic.raycastTarget)
			{
				continue;
			}
			Transform transform = graphic.transform;
			Vector3 forward = transform.forward;
			float num = Vector3.Dot(forward, transform.position - ray.origin) / Vector3.Dot(forward, ray.direction);
			if (!(num < 0f) && !(num - 1E-05f > hitDistance))
			{
				Vector3 point = ray.GetPoint(num);
				Vector2 vector = eventCamera.WorldToScreenPoint(point);
				if (RectTransformUtility.RectangleContainsScreenPoint(graphic.rectTransform, vector, eventCamera) && graphic.Raycast(vector, eventCamera))
				{
					RaycastResult raycastResult = default(RaycastResult);
					raycastResult.gameObject = graphic.gameObject;
					raycastResult.module = this;
					raycastResult.distance = num;
					raycastResult.screenPosition = vector;
					raycastResult.worldPosition = point;
					raycastResult.depth = graphic.depth;
					raycastResult.sortingLayer = canvas.sortingLayerID;
					raycastResult.sortingOrder = canvas.sortingOrder;
					RaycastResult item = raycastResult;
					results.Add(item);
				}
			}
		}
		results.Sort((RaycastResult g1, RaycastResult g2) => g2.depth.CompareTo(g1.depth));
	}
}
public struct UIPointerEventArgs
{
	public bool isActive;

	public GameObject currentTarget;

	public GameObject previousTarget;

	public RaycastResult raycastResult;
}
public delegate void UIPointerEventHandler(object sender, UIPointerEventArgs e);
public class Pvr_UIPointer : MonoBehaviour
{
	public enum ClickMethods
	{
		ClickOnButtonUp,
		ClickOnButtonDown
	}

	public ClickMethods clickMethod;

	[HideInInspector]
	public bool collisionClick;

	[HideInInspector]
	public bool pressToDrag;

	[HideInInspector]
	public GameObject autoActivatingCanvas;

	[HideInInspector]
	public PointerEventData pointerEventData;

	[HideInInspector]
	public GameObject hoveringElement;

	[HideInInspector]
	public float hoverDurationTimer;

	[HideInInspector]
	public bool canClickOnHover;

	public Transform pointerOriginTransform;

	protected bool pointerClicked;

	protected bool beamEnabledState;

	protected bool lastPointerPressState;

	protected bool lastPointerClickState;

	protected GameObject currentTarget;

	protected EventSystem cachedEventSystem;

	protected Pvr_InputModule cachedVRInputModule;

	protected Transform originalPointerOriginTransform;

	public static bool TouchBtnValue;

	public static bool AppBtnValue;

	public static bool TriggerBtnValue;

	public event UIPointerEventHandler UIPointerElementEnter;

	public event UIPointerEventHandler UIPointerElementExit;

	public event UIPointerEventHandler UIPointerElementClick;

	public event UIPointerEventHandler UIPointerElementDragStart;

	public event UIPointerEventHandler UIPointerElementDragEnd;

	public virtual bool PointerActive()
	{
		return true;
	}

	public virtual bool IsSelectionButtonPressed()
	{
		if (!Input.GetMouseButton(0) && !Input.GetKey(KeyCode.JoystickButton0) && !TouchBtnValue && !AppBtnValue)
		{
			return TriggerBtnValue;
		}
		return true;
	}

	public virtual Vector3 GetOriginPosition()
	{
		if (!pointerOriginTransform)
		{
			return base.transform.position;
		}
		return pointerOriginTransform.position;
	}

	public virtual Vector3 GetOriginForward()
	{
		if (!pointerOriginTransform)
		{
			return base.transform.forward;
		}
		return pointerOriginTransform.forward;
	}

	public virtual bool ValidClick(bool checkLastClick, bool lastClickState = false)
	{
		bool result = (collisionClick ? collisionClick : IsSelectionButtonPressed());
		if (!checkLastClick)
		{
			return result;
		}
		return result;
	}

	protected virtual void ResetHoverTimer()
	{
		hoverDurationTimer = 0f;
		canClickOnHover = false;
	}

	public virtual void OnUIPointerElementEnter(UIPointerEventArgs e)
	{
		if (e.currentTarget != currentTarget)
		{
			ResetHoverTimer();
		}
		currentTarget = e.currentTarget;
		if (this.UIPointerElementEnter != null)
		{
			this.UIPointerElementEnter(this, e);
		}
	}

	public virtual void OnUIPointerElementExit(UIPointerEventArgs e)
	{
		if (e.previousTarget == currentTarget)
		{
			ResetHoverTimer();
		}
		if (this.UIPointerElementExit != null)
		{
			this.UIPointerElementExit(this, e);
		}
	}

	public virtual void OnUIPointerElementClick(UIPointerEventArgs e)
	{
		if (e.currentTarget == currentTarget)
		{
			ResetHoverTimer();
		}
		if (this.UIPointerElementClick != null)
		{
			this.UIPointerElementClick(this, e);
		}
	}

	public virtual void OnUIPointerElementDragStart(UIPointerEventArgs e)
	{
		if (this.UIPointerElementDragStart != null)
		{
			this.UIPointerElementDragStart(this, e);
		}
	}

	public virtual void OnUIPointerElementDragEnd(UIPointerEventArgs e)
	{
		if (this.UIPointerElementDragEnd != null)
		{
			this.UIPointerElementDragEnd(this, e);
		}
	}

	public virtual UIPointerEventArgs SetUIPointerEvent(RaycastResult currentRaycastResult, GameObject currentTarget, GameObject lastTarget = null)
	{
		UIPointerEventArgs result = default(UIPointerEventArgs);
		result.isActive = PointerActive();
		result.currentTarget = currentTarget;
		result.previousTarget = lastTarget;
		result.raycastResult = currentRaycastResult;
		return result;
	}

	protected virtual void Awake()
	{
		originalPointerOriginTransform = pointerOriginTransform;
	}

	protected virtual void OnEnable()
	{
		pointerOriginTransform = originalPointerOriginTransform;
		ConfigureEventSystem();
		pointerClicked = false;
		lastPointerPressState = false;
		lastPointerClickState = false;
		beamEnabledState = false;
	}

	protected virtual void OnDisable()
	{
		Pvr_InputModule.RemovePoint(this);
	}

	protected virtual void ConfigureEventSystem()
	{
		if (!cachedEventSystem)
		{
			cachedEventSystem = UnityEngine.Object.FindObjectOfType<EventSystem>();
		}
		if (!cachedVRInputModule)
		{
			cachedVRInputModule = cachedEventSystem.GetComponent<Pvr_InputModule>();
		}
		if ((bool)cachedEventSystem && (bool)cachedVRInputModule && pointerEventData == null)
		{
			pointerEventData = new PointerEventData(cachedEventSystem);
		}
		Pvr_InputModule.AddPoint(this);
	}
}
[ExecuteInEditMode]
public class Pvr_UnitySDKEditor : MonoBehaviour
{
	private bool vrModeEnabled = true;

	private float mouseX;

	private float mouseY;

	private float mouseZ;

	private float neckModelScale;

	private bool autoUntiltHead;

	private static readonly Vector3 neckOffset = new Vector3(0f, 0.075f, 0.0805f);

	[HideInInspector]
	public Matrix4x4 headView;

	[HideInInspector]
	public Matrix4x4 leftEyeUndistortedProj;

	[HideInInspector]
	public Matrix4x4 rightEyeUndistortedProj;

	[HideInInspector]
	public Matrix4x4 leftEyeProj;

	[HideInInspector]
	public Matrix4x4 rightEyeProj;

	private const float TOUCH_TIME_LIMIT = 0.2f;

	private float touchStartTime;

	public Matrix4x4 UndistortedProjection(Eye eye)
	{
		if (eye != 0)
		{
			return rightEyeUndistortedProj;
		}
		return leftEyeUndistortedProj;
	}

	public Matrix4x4 Projection(Eye eye)
	{
		if (eye != 0)
		{
			return rightEyeProj;
		}
		return leftEyeProj;
	}

	private void Awake()
	{
		InitEyePara();
		InitEditorSensorPara();
	}

	private void Update()
	{
		SimulateInput();
		Pvr_UnitySDKManager.SDK.picovrTriggered = Pvr_UnitySDKManager.SDK.newPicovrTriggered;
		Pvr_UnitySDKManager.SDK.newPicovrTriggered = false;
	}

	public void InitEyePara()
	{
		ComputeEyesFromProfile();
		InitForEye(ref Pvr_UnitySDKManager.SDK.Eyematerial, ref Pvr_UnitySDKManager.SDK.Middlematerial);
		if (Pvr_UnitySDKRender.Instance == null)
		{
			PLOG.I("pvr_UnitySDKRender init failed");
		}
		if (Pvr_UnitySDKSensor.Instance == null)
		{
			PLOG.I("pvr_UnitySDKSensor init failed");
		}
		FovAdjust();
	}

	private void InitEditorSensorPara()
	{
		Pvr_UnitySDKManager.SDK.picovrTriggered = Pvr_UnitySDKManager.SDK.newPicovrTriggered;
		Pvr_UnitySDKManager.SDK.newPicovrTriggered = false;
	}

	public static Matrix4x4 MakeProjection(float l, float t, float r, float b, float n, float f)
	{
		Matrix4x4 zero = Matrix4x4.zero;
		zero[0, 0] = 2f * n / (r - l);
		zero[1, 1] = 2f * n / (t - b);
		zero[0, 2] = (r + l) / (r - l);
		zero[1, 2] = (t + b) / (t - b);
		zero[2, 2] = (n + f) / (n - f);
		zero[2, 3] = 2f * n * f / (n - f);
		zero[3, 2] = -1f;
		return zero;
	}

	public bool UpdateStatesensor()
	{
		UpdateSimulatedSensor();
		return true;
	}

	public void ComputeEyesFromProfile()
	{
		Vector2 vector = new Vector2(0.11f, 0.062f);
		Pvr_UnitySDKManager.SDK.leftEyeView = Matrix4x4.identity;
		Pvr_UnitySDKManager.SDK.leftEyeView[0, 3] = (0f - Pvr_UnitySDKManager.SDK.pvr_UnitySDKConfig.device.devLenses.separation) / 2f;
		float[] leftEyeVisibleTanAngles = Pvr_UnitySDKManager.SDK.pvr_UnitySDKConfig.GetLeftEyeVisibleTanAngles(vector.x, vector.y);
		leftEyeProj = MakeProjection(leftEyeVisibleTanAngles[0], leftEyeVisibleTanAngles[1], leftEyeVisibleTanAngles[2], leftEyeVisibleTanAngles[3], 1f, 1000f);
		leftEyeVisibleTanAngles = Pvr_UnitySDKManager.SDK.pvr_UnitySDKConfig.GetLeftEyeNoLensTanAngles(vector.x, vector.y);
		leftEyeUndistortedProj = MakeProjection(leftEyeVisibleTanAngles[0], leftEyeVisibleTanAngles[1], leftEyeVisibleTanAngles[2], leftEyeVisibleTanAngles[3], 1f, 1000f);
		Pvr_UnitySDKManager.SDK.leftEyeRect = Pvr_UnitySDKManager.SDK.pvr_UnitySDKConfig.GetLeftEyeVisibleScreenRect(leftEyeVisibleTanAngles, vector.x, vector.y);
		Pvr_UnitySDKManager.SDK.rightEyeView = Pvr_UnitySDKManager.SDK.leftEyeView;
		Pvr_UnitySDKManager.SDK.rightEyeView[0, 3] *= -1f;
		rightEyeProj = leftEyeProj;
		rightEyeProj[0, 2] *= -1f;
		rightEyeUndistortedProj = leftEyeUndistortedProj;
		rightEyeUndistortedProj[0, 2] *= -1f;
		Rect leftEyeRect = new Rect(0f, 0f, 0.5f, 1f);
		Rect rightEyeRect = new Rect(0.5f, 0f, 0.5f, 1f);
		Pvr_UnitySDKManager.SDK.leftEyeRect = leftEyeRect;
		Pvr_UnitySDKManager.SDK.rightEyeRect = rightEyeRect;
		Pvr_UnitySDKManager.SDK.leftEyeOffset = new Vector3((0f - Pvr_UnitySDKManager.SDK.pvr_UnitySDKConfig.device.devLenses.separation) / 2f, 0f, 0f);
		Pvr_UnitySDKManager.SDK.rightEyeOffset = new Vector3(Pvr_UnitySDKManager.SDK.pvr_UnitySDKConfig.device.devLenses.separation / 2f, 0f, 0f);
	}

	public bool ResetUnitySDKSensor()
	{
		mouseX = (mouseY = (mouseZ = 0f));
		return true;
	}

	private void SimulateInput()
	{
		if (Input.GetMouseButtonDown(0) && (Input.GetKey(KeyCode.LeftAlt) || Input.GetKey(KeyCode.RightAlt)))
		{
			EnableVEmodel();
		}
		if (Input.GetMouseButtonDown(0))
		{
			touchStartTime = Time.time;
		}
		else if (Input.GetMouseButtonUp(0))
		{
			if (Time.time - touchStartTime <= 0.2f)
			{
				Pvr_UnitySDKManager.SDK.newPicovrTriggered = true;
			}
			touchStartTime = 0f;
		}
		UpdateSimulatedSensor();
	}

	private void FovAdjust()
	{
		Pvr_UnitySDKRender.Instance.EyeVFoV = 2f * Pvr_UnitySDKManager.SDK.pvr_UnitySDKConfig.device.devMaxFov.upper;
	}

	private Rect RectAdjust(Rect eyeRect)
	{
		Rect result = new Rect(0f, 0f, 0.5f, 1f);
		result.width *= 2f * eyeRect.width;
		result.x = eyeRect.x + 2f * result.x * eyeRect.width;
		result.height *= eyeRect.height;
		result.y = eyeRect.y + result.y * eyeRect.height;
		return result;
	}

	private void UpdateSimulatedSensor()
	{
		bool flag = false;
		if (Input.GetKey(KeyCode.LeftAlt) || Input.GetKey(KeyCode.RightAlt))
		{
			mouseX += Input.GetAxis("Mouse X") * 5f;
			if (mouseX <= -180f)
			{
				mouseX += 360f;
			}
			else if (mouseX > 180f)
			{
				mouseX -= 360f;
			}
			mouseY -= Input.GetAxis("Mouse Y") * 2.4f;
			mouseY = Mathf.Clamp(mouseY, -91f, 91f);
		}
		else if (Input.GetKey(KeyCode.LeftControl) || Input.GetKey(KeyCode.RightControl))
		{
			flag = true;
			mouseZ += Input.GetAxis("Mouse X") * 5f;
			mouseZ = Mathf.Clamp(mouseZ, -91f, 91f);
		}
		if (!flag && autoUntiltHead)
		{
			mouseZ = Mathf.Lerp(mouseZ, 0f, Time.deltaTime / (Time.deltaTime + 0.1f));
		}
		Quaternion quaternion = Quaternion.Euler(mouseY, mouseX, mouseZ);
		Matrix4x4 matrix = Matrix4x4.TRS((quaternion * neckOffset - neckOffset.y * Vector3.up) * neckModelScale, quaternion, Vector3.one);
		Pvr_UnitySDKSensor.Instance.HeadPose = new Pvr_UnitySDKPose(matrix);
	}

	private void InitForEye(ref Material mat, ref Material mat1)
	{
		Shader shader = Shader.Find("Pvr_UnitySDK/Undistortion");
		Shader shader2 = Shader.Find("Pvr_UnitySDK/FillColor");
		if (shader == null || shader2 == null)
		{
			PLOG.E("Ths Shader Missing ！");
			return;
		}
		mat = new Material(shader);
		mat1 = new Material(shader2);
	}

	private void EnableVEmodel()
	{
		vrModeEnabled = !vrModeEnabled;
		Pvr_UnitySDKManager.SDK.VRModeEnabled = vrModeEnabled;
	}
}
public class Pvr_VolumePowerBrightness : MonoBehaviour
{
	private bool VolEnable;

	private bool BattEnable;

	public Text showResult;

	public Text setVolumnum;

	public Text setBrightnum;

	public string MusicPath;

	private void Awake()
	{
		InitBatteryVolClass();
		string startreceivre = base.gameObject.name;
		StartBatteryReceiver(startreceivre);
		StartAudioReceiver(startreceivre);
	}

	private void OnDisable()
	{
		if (VolEnable)
		{
			StopAudioReceiver();
		}
		if (BattEnable)
		{
			StopBatteryReceiver();
		}
	}

	public void GetMaxVolumeNumber()
	{
		int num = 0;
		num = VolumePowerBrightness.UPvr_GetMaxVolumeNumber();
		showResult.text = "Maximum volume: " + num;
	}

	public void GetCurrentVolumeNumber()
	{
		int num = 0;
		num = VolumePowerBrightness.UPvr_GetCurrentVolumeNumber();
		showResult.text = "Current volume：" + num;
	}

	public void VolumeUp()
	{
		if (!VolumePowerBrightness.UPvr_VolumeUp())
		{
			PLOG.E("VolumeUp Error");
		}
	}

	public void VolumeDown()
	{
		if (!VolumePowerBrightness.UPvr_VolumeDown())
		{
			PLOG.E("VolumeDown Error");
		}
	}

	public void SetVolumeNum()
	{
		int volume = new System.Random().Next(0, 15);
		setVolumnum.text = "Random number：" + volume;
		if (!VolumePowerBrightness.UPvr_SetVolumeNum(volume))
		{
			PLOG.E("SetVolumeNum Error");
		}
	}

	public void SetBrightness()
	{
		int brightness = new System.Random().Next(0, 255);
		setBrightnum.text = "Random number：" + brightness;
		if (!VolumePowerBrightness.UPvr_SetCommonBrightness(brightness))
		{
			PLOG.E("SetBrightness Error");
		}
	}

	public void GetCurrentBrightness()
	{
		int num = 0;
		num = VolumePowerBrightness.UPvr_GetCommonBrightness();
		showResult.text = "Current brightness：" + num;
	}

	public bool setAudio(string s)
	{
		PLOG.I(s.ToString());
		return true;
	}

	public bool setBattery(string s)
	{
		PLOG.I(s.ToString());
		return true;
	}

	private bool InitBatteryVolClass()
	{
		return VolumePowerBrightness.UPvr_InitBatteryVolClass();
	}

	private bool StartBatteryReceiver(string startreceivre)
	{
		BattEnable = VolumePowerBrightness.UPvr_StartBatteryReceiver(startreceivre);
		return BattEnable;
	}

	private bool StopBatteryReceiver()
	{
		return VolumePowerBrightness.UPvr_StopBatteryReceiver();
	}

	private bool StartAudioReceiver(string startreceivre)
	{
		VolEnable = VolumePowerBrightness.UPvr_StartAudioReceiver(startreceivre);
		return VolEnable;
	}

	private bool StopAudioReceiver()
	{
		return VolumePowerBrightness.UPvr_StopAudioReceiver();
	}
}
public class PlantPosition : MonoBehaviour
{
	public GameObject[] potPrefabs;

	public MinMax scale;

	public float positionVariance;

	private void Start()
	{
		base.transform.position += Quaternion.Euler(0f, UnityEngine.Random.value * 360f, 0f) * Vector3.forward * positionVariance * UnityEngine.Random.value;
		base.transform.rotation = Quaternion.Euler(0f, UnityEngine.Random.value * 360f, 0f);
		base.transform.localScale = scale.random() * Vector3.one;
	}

	private void Update()
	{
	}
}
public class PlayerPositionOffset : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
	}
}
public class PortraitCameraController : MonoBehaviour
{
	private Transform following;

	public Vector3 posOffset;

	public Vector3 lookOffset;

	public int size = 256;

	private Camera cam;

	public string charName;

	public float takePicTime = 1f;

	private int picNum;

	private Quaternion offsetRot;

	public AudioClip photoSound;

	private AudioSource audioSource;

	private void Start()
	{
		offsetRot = Quaternion.identity;
		cam = GetComponent<Camera>();
		audioSource = base.gameObject.AddComponent<AudioSource>();
		base.gameObject.SetActive(value: false);
	}

	public void setToFollow(CharacterData character, Transform t)
	{
		if (audioSource == null)
		{
			cam = GetComponent<Camera>();
			audioSource = base.gameObject.AddComponent<AudioSource>();
		}
		offsetRot = Quaternion.identity;
		cam.backgroundColor = Color.white;
		following = t;
		charName = character.name;
		picNum = 0;
		takePicTime = 1f;
		base.gameObject.SetActive(value: true);
	}

	private void Update()
	{
		if (!(following == null))
		{
			base.transform.position = following.transform.position + following.rotation * offsetRot * posOffset;
			base.transform.LookAt(following.transform.position + lookOffset);
			takePicTime -= Time.deltaTime;
			if (takePicTime <= 0f)
			{
				takePic();
				takePicTime += UnityEngine.Random.Range(3, 10);
			}
		}
	}

	private void takePic()
	{
		RenderTexture active = RenderTexture.active;
		RenderTexture renderTexture = new RenderTexture(size, size, 24, RenderTextureFormat.ARGB32);
		cam.targetTexture = renderTexture;
		cam.Render();
		DumpRenderTexture(renderTexture, Application.dataPath + "/Resources/portraits/" + charName + "_" + picNum + ".png");
		cam.targetTexture = active;
		offsetRot = Quaternion.Euler(UnityEngine.Random.value * 45f, UnityEngine.Random.value * 45f, UnityEngine.Random.value * 45f);
		audioSource.PlayOneShot(photoSound);
		picNum++;
		if (picNum >= 10)
		{
			base.gameObject.SetActive(value: false);
		}
	}

	public void DumpRenderTexture(RenderTexture rt, string pngOutPath)
	{
		RenderTexture active = RenderTexture.active;
		Texture2D texture2D = new Texture2D(rt.width, rt.height);
		RenderTexture.active = rt;
		texture2D.ReadPixels(new Rect(0f, 0f, rt.width, rt.height), 0, 0);
		texture2D.Apply();
		File.WriteAllBytes(pngOutPath, texture2D.EncodeToPNG());
		RenderTexture.active = active;
	}
}
public class PoseDisplay : MonoBehaviour
{
	public static PoseDisplay instance;

	public GameObject headPos;

	public GameObject leftHandStartPos;

	public GameObject rightHandStartPos;

	public SpecialMoveInstructionController instruction;

	public SkinnedMeshRenderer skinMesh;

	public VRIK ik;

	public float showTimer;

	private bool rCorrect;

	private bool lCorrect;

	public float maxDist = 0.1f;

	public float maxAngle = 15f;

	private Color showColour;

	public bool alwaysOn;

	public Color onColour;

	public Color offColour;

	public Color failColour;

	public GameCharacter character;

	public Transform ghostContainer;

	public GameObject ghostRig;

	[Header("Hand Skeleton Stuff")]
	public Transform rightHand;

	public Transform leftHand;

	public Transform[] r_bones;

	public Transform[] l_bones;

	public Material ghostMaterial;

	public float forwardOffset;

	private void Start()
	{
		instance = this;
	}

	public Transform findHand(string handName)
	{
		Transform[] componentsInChildren = ghostRig.GetComponentsInChildren<Transform>();
		foreach (Transform transform in componentsInChildren)
		{
			if (transform.name == handName)
			{
				return transform;
			}
		}
		return null;
	}

	private Transform[] getBones(Transform hand)
	{
		Transform[] componentsInChildren = hand.GetComponentsInChildren<Transform>();
		List<Transform> list = new List<Transform>();
		Transform[] array = componentsInChildren;
		foreach (Transform transform in array)
		{
			if (!(transform.GetComponent<Canvas>() != null) && !(transform.parent.GetComponent<TextMeshProUGUI>() != null) && !(transform.GetComponent<TextMeshProUGUI>() != null) && !(transform.GetComponent<Image>() != null) && !(transform.GetComponent<HandMeterController>() != null) && !(transform.GetComponent<EffectCirclesController>() != null) && !transform.name.Contains("Prop M") && !transform.name.Contains("Additional"))
			{
				list.Add(transform);
			}
		}
		return list.ToArray();
	}

	private void showHandPoses()
	{
		HandPosition[] handPositions = character.hands.handPositions;
		SpecialMove specialMove = character.specialMove.move();
		if (l_bones.Length == 0 || l_bones[0] == null)
		{
			return;
		}
		Vector3 rotation = specialMove.pose.l_hand[0].rotation;
		Vector3 rotation2 = specialMove.pose.r_hand[0].rotation;
		float squeeze = specialMove.pose.l_hand[0].squeeze;
		float squeeze2 = specialMove.pose.r_hand[0].squeeze;
		for (int i = 0; i < 2; i++)
		{
			Transform[] array = ((i == 0) ? l_bones : r_bones);
			for (int j = 0; j < array.Length; j++)
			{
				int num = 0;
				int num2 = 1;
				Quaternion a;
				Quaternion b;
				float t;
				if (i == 0)
				{
					if (0f - rotation.y > 30f && 0f - rotation.y < 90f)
					{
						num = 2;
					}
					if (num >= handPositions.Length || num < 0)
					{
						UnityEngine.Debug.LogError("L: " + num);
					}
					a = Quaternion.Euler(handPositions[num].l_rotations[j]);
					b = Quaternion.Euler(handPositions[num2].l_rotations[j]);
					t = squeeze;
				}
				else
				{
					if (rotation2.y > 30f && rotation2.y < 90f)
					{
						num = 2;
					}
					if (num >= handPositions.Length || num < 0)
					{
						UnityEngine.Debug.LogError("R: " + num);
					}
					if (array.Length != handPositions[num].r_rotations.Length)
					{
						UnityEngine.Debug.LogError(array.Length + "!=" + handPositions[num].r_rotations.Length + " " + handPositions[num].l_rotations.Length);
					}
					a = Quaternion.Euler(handPositions[num].r_rotations[j]);
					b = Quaternion.Euler(handPositions[num2].r_rotations[j]);
					t = squeeze2;
				}
				Quaternion localRotation = Quaternion.Lerp(a, b, t);
				array[j].localRotation = localRotation;
			}
		}
	}

	public bool showPose(GameCharacter character, RecordAction pose)
	{
		this.character = character;
		if (GameController.instance.fightState != 0 && GameController.instance.fightState != GameController.FightState.Over && character.rigidBodies.specialPerc < 1f)
		{
			if (character.isPlayer())
			{
				CanvasController.addText(localise: true, "Not Ready", character.rigidBodies.rightHand.transform.position, Color.red, 1f);
				GameController.instance.gameData.ShowVRTip(4);
			}
			return false;
		}
		if (character.doingSpecial > 0f)
		{
			return false;
		}
		updatePosition(setup: true);
		float num = character.trackers.transforms[0].localPosition.y / pose.head[0].position.y;
		leftHandStartPos.transform.localPosition = pose.l_hand[0].position * num;
		rightHandStartPos.transform.localPosition = pose.r_hand[0].position * num;
		if (character.isPlayer())
		{
			leftHandStartPos.transform.localPosition += forwardOffset * Vector3.forward;
			rightHandStartPos.transform.localPosition += forwardOffset * Vector3.forward;
		}
		leftHandStartPos.transform.localRotation = Quaternion.Euler(pose.l_hand[0].rotation);
		rightHandStartPos.transform.localRotation = Quaternion.Euler(pose.r_hand[0].rotation);
		showHandPoses();
		float magnitude = (leftHandStartPos.transform.position - character.trackers.transforms[1].position).magnitude;
		float magnitude2 = (rightHandStartPos.transform.position - character.trackers.transforms[2].position).magnitude;
		float num2 = Quaternion.Angle(leftHandStartPos.transform.rotation, character.trackers.transforms[1].rotation);
		float num3 = Quaternion.Angle(rightHandStartPos.transform.rotation, character.trackers.transforms[2].rotation);
		bool flag = true;
		bool flag2 = true;
		bool flag3 = true;
		bool flag4 = true;
		if (character.isPlayer())
		{
			flag3 = (double)pose.l_hand[0].squeeze > 0.5;
			flag4 = (double)pose.r_hand[0].squeeze > 0.5;
			bool flag5 = (double)character.rigidBodies.leftHand.getSqueeze() > 0.5;
			bool flag6 = (double)character.rigidBodies.rightHand.getSqueeze() > 0.5;
			flag = flag3 == flag5;
			flag2 = flag4 == flag6;
		}
		rCorrect = magnitude2 < maxDist;
		lCorrect = magnitude < maxDist;
		if (rCorrect)
		{
			if (!flag2)
			{
				CanvasController.addText(localise: true, flag4 ? "Fist" : "Palm", character.rigidBodies.rightHand.transform.position, Color.red, 1f);
				rCorrect = false;
			}
			else if (num3 > maxAngle)
			{
				if (num3 > 110f)
				{
					CanvasController.addText(localise: true, "Other Way", character.rigidBodies.rightHand.transform.position, Color.red, 1f);
				}
				rCorrect = false;
			}
		}
		if (lCorrect)
		{
			if (!flag)
			{
				CanvasController.addText(localise: true, flag3 ? "Fist" : "Palm", character.rigidBodies.leftHand.transform.position, Color.red, 1f);
				lCorrect = false;
			}
			else if (num2 > maxAngle)
			{
				if (num2 > 110f)
				{
					CanvasController.addText(localise: true, "Other Way", character.rigidBodies.leftHand.transform.position, Color.red, 1f);
				}
				lCorrect = false;
			}
		}
		if (character.data.weaknessName == "Left Armed")
		{
			rCorrect = true;
		}
		if (character.data.weaknessName == "Right Armed")
		{
			lCorrect = true;
		}
		leftHandStartPos.gameObject.SetActive(!lCorrect && character.isPlayer());
		rightHandStartPos.gameObject.SetActive(!rCorrect && character.isPlayer());
		if (lCorrect && rCorrect)
		{
			return true;
		}
		if (!character.isPlayer())
		{
			return false;
		}
		showTimer = 1f;
		showColour = failColour;
		skinMesh.material.SetColor("_Color", showColour);
		return false;
	}

	private void updatePosition(bool setup)
	{
		if (character == null)
		{
			return;
		}
		if (setup)
		{
			UnityEngine.Object.Destroy(ghostRig);
			if (character.rigidBodies.wholebodyMeshRenderer != null && !character.rigidBodies.hideWholeBody)
			{
				character.rigidBodies.wholebodyMeshRenderer.gameObject.SetActive(value: true);
			}
			ghostRig = UnityEngine.Object.Instantiate(character.rigidBodies.ik.references.root.gameObject, ghostContainer);
			ghostRig.transform.localPosition = Vector3.zero;
			ghostRig.transform.localRotation = Quaternion.identity;
			if (character.rigidBodies.wholebodyMeshRenderer != null && !character.rigidBodies.hideWholeBody)
			{
				character.rigidBodies.wholebodyMeshRenderer.gameObject.SetActive(value: false);
			}
			UnityEngine.Object.Destroy(ghostRig.GetComponentInChildren<FaceController>());
			SkinnedMeshRenderer[] componentsInChildren = ghostRig.GetComponentsInChildren<SkinnedMeshRenderer>(includeInactive: true);
			skinMesh = null;
			SkinnedMeshRenderer[] array = componentsInChildren;
			foreach (SkinnedMeshRenderer skinnedMeshRenderer in array)
			{
				if (skinnedMeshRenderer.name == character.rigidBodies.wholebodyMeshRenderer.name)
				{
					skinMesh = skinnedMeshRenderer;
					skinMesh.enabled = true;
					skinMesh.gameObject.SetActive(value: true);
				}
				else
				{
					UnityEngine.Object.Destroy(skinnedMeshRenderer.gameObject);
				}
			}
			if (skinMesh == null)
			{
				UnityEngine.Debug.LogError("Skin Mesh not found");
			}
			skinMesh.sharedMaterial = ghostMaterial;
			skinMesh.shadowCastingMode = ShadowCastingMode.Off;
			ik = ghostRig.GetComponent<VRIK>();
			ik.solver.spine.headTarget = headPos.transform;
			ik.solver.leftArm.target = leftHandStartPos.transform;
			ik.solver.rightArm.target = rightHandStartPos.transform;
			leftHand = findHand(character.rigidBodies.hands.leftHand.name);
			rightHand = findHand(character.rigidBodies.hands.rightHand.name);
			r_bones = getBones(rightHand);
			l_bones = getBones(leftHand);
		}
		base.transform.position = character.standPosition;
		headPos.transform.position = character.trackers.transforms[0].position;
		headPos.transform.rotation = character.trackers.transforms[0].rotation;
		Vector3 forward = character.trackers.transforms[0].forward;
		forward.y = 0f;
		base.transform.rotation = Quaternion.LookRotation(forward);
	}

	private void Update()
	{
		if (!(skinMesh == null))
		{
			if (alwaysOn && character == null && GameController.instance.player != null)
			{
				showPose(GameController.instance.player, GameController.instance.player.specialMove.move().pose);
				showColour = Color.black;
				showTimer = 1f;
			}
			showTimer = Mathf.MoveTowards(showTimer, 0f, Time.deltaTime);
			if (showTimer > 0f)
			{
				updatePosition(setup: false);
			}
			Color a = (alwaysOn ? onColour : offColour);
			if (character != null && character.doingSpecial > 0f)
			{
				showColour = Color.black;
				showTimer = 1f;
			}
			skinMesh.material.SetColor("_Color", Color.Lerp(a, showColour, showTimer));
		}
	}
}
public class PositionDebugger : MonoBehaviour
{
	public Color colour = Color.red;

	private MeshRenderer sphere;

	private LineRenderer line;

	private void Start()
	{
		line = base.gameObject.AddComponent<LineRenderer>();
		line.material = new Material(Shader.Find("Sprites/Default"));
		line.widthMultiplier = 0.05f;
		line.useWorldSpace = false;
		line.SetPosition(0, Vector3.zero);
		line.SetPosition(1, Vector3.up * 3f * base.transform.lossyScale.y);
		LineRenderer lineRenderer = line;
		Color startColor = (line.endColor = colour);
		lineRenderer.startColor = startColor;
		line.enabled = Settings.instance != null && Settings.instance.positionLines;
		sphere = UnityEngine.Object.Instantiate(GameController.instance.debugSphere, base.transform.position, Quaternion.identity, base.transform).GetComponent<MeshRenderer>();
		sphere.material.SetColor("_Color", colour);
		sphere.gameObject.SetActive(line.enabled);
	}

	private void Update()
	{
		line.enabled = Settings.instance != null && Settings.instance.positionLines;
		sphere.gameObject.SetActive(line.enabled);
	}
}
public class PotSwingerController : MonoBehaviour
{
	public Rigidbody[] pots;

	public bool active;

	public float minInterval = 1f;

	public float maxInterval = 1f;

	public float timer = 3f;

	public int onPot;

	public AudioClip releaseSound;

	public StandPositionIndicator standPos;

	private Breakable current;

	private ChamberController chamber;

	private void Start()
	{
		standPos.onPress = startGame;
		chamber = GetComponentInParent<ChamberController>();
		List<Rigidbody> list = new List<Rigidbody>();
		Rigidbody[] array = pots;
		foreach (Rigidbody rigidbody in array)
		{
			rigidbody.GetComponent<Breakable>().onHurt = onHurt;
			list.Add(rigidbody);
		}
		chamber.isComplete = false;
		onPot = 0;
		while (list.Count > 0)
		{
			int index = UnityEngine.Random.Range(0, list.Count);
			pots[onPot] = list[index];
			list.RemoveAt(index);
			onPot++;
		}
		onPot = 0;
	}

	private void onHurt()
	{
		FaceCanvasController.addText("Failed");
		active = false;
	}

	private void startGame(StandPositionIndicator standPos)
	{
		active = true;
		standPos.gameObject.SetActive(value: false);
	}

	private void Update()
	{
		if (!active)
		{
			return;
		}
		bool flag = true;
		Rigidbody[] array = pots;
		foreach (Rigidbody rigidbody in array)
		{
			if (rigidbody != null && !rigidbody.GetComponent<Breakable>().broken)
			{
				flag = false;
			}
		}
		if (flag)
		{
			chamber.isComplete = true;
			active = false;
		}
		if (onPot < pots.Length)
		{
			timer -= Time.deltaTime;
			if (timer < 0f && (current == null || current.broken))
			{
				pots[onPot].isKinematic = false;
				current = pots[onPot].GetComponent<Breakable>();
				current.GetComponent<AudioSource>().PlayOneShot(releaseSound);
				onPot++;
				timer += UnityEngine.Random.Range(minInterval, maxInterval);
			}
		}
	}
}
public class PracticeMoveController : StandButtonsController
{
	public static PracticeMoveController instance;

	public Transform headingContainer;

	public TextMeshProUGUI heading;

	public TextMeshProUGUI desc;

	private bool setup;

	public string[] practiceModes;

	public int practiceMode;

	public int onPressurePoint;

	public GameCharacter practiceCharacter;

	public StandPositionIndicator nextCharButton;

	public StandPositionIndicator practiceButton;

	private float tipTimer = 0.5f;

	public static bool isActive(int mode)
	{
		if (instance != null)
		{
			if (mode != -1)
			{
				return instance.practiceMode == mode;
			}
			return true;
		}
		return false;
	}

	private void Start()
	{
		instance = this;
		practiceMode = 0;
		if (spawnPoints.Length == 0)
		{
			spawnPoints = GetComponentsInChildren<SpawnPointController>();
		}
		GameController.instance.standButtons = this;
		if (editCam != null)
		{
			editCam.gameObject.SetActive(value: false);
		}
		practiceButton.heading.text = (practiceButton.headingText = LocalisationController.getText("Practice Mode", "Practice Mode"));
		practiceButton.buttonLabel = LocalisationController.getText("Practice Mode", practiceModes[1]);
		practiceButton.button.label.text = practiceButton.buttonLabel;
		practiceButton.extra.text = LocalisationController.getText("General", "Current:") + " " + LocalisationController.getText("Practice Mode", practiceModes[practiceMode]);
		WebLogging.log("Practice Special Move", GameController.instance.selectedCharacter().name, 0f);
		CharacterData characterData = GameData.instance.characters[GameController.instance.getNextCharacterID()];
		nextCharButton.heading.text = (nextCharButton.headingText = LocalisationController.getText("General", "Next Character"));
		StandPositionIndicator standPositionIndicator = nextCharButton;
		string buttonLabel = (nextCharButton.button.label.text = LocalisationController.getText("General", "Next"));
		standPositionIndicator.buttonLabel = buttonLabel;
		nextCharButton.extra.text = LocalisationController.getText("Character: " + characterData.name, characterData.name);
	}

	public void nextPracticeMode()
	{
		practiceMode++;
		if (practiceMode >= practiceModes.Length)
		{
			practiceMode = 0;
		}
		int num = practiceMode + 1;
		if (num >= practiceModes.Length)
		{
			num = 0;
		}
		practiceButton.buttonLabel = LocalisationController.getText("Practice Mode", practiceModes[num]);
		practiceButton.button.label.text = practiceButton.buttonLabel;
		practiceButton.extra.text = LocalisationController.getText("General", "Current:") + " " + LocalisationController.getText("Practice Mode", practiceModes[practiceMode]);
		tipTimer = 0.5f;
		WebLogging.log("Practice " + practiceModes[practiceMode], GameController.instance.selectedCharacter().name, 0f);
	}

	private void Update()
	{
		noticeBoard.SetActive(OptionData.getOption("Noticeboard").value == 0);
		if (GameController.instance == null || GameController.instance.player == null)
		{
			return;
		}
		if (tipTimer > 0f && isActive(0) && GameController.instance.player.targetEnemy != null)
		{
			tipTimer -= Time.deltaTime;
			if (tipTimer < 0f && practiceMode == 0)
			{
				PoseDisplay.instance.instruction.showFinished(GameController.instance.player, "Press the special move button to view pose", 4f);
				GameController.instance.player.playerController.controllerTips.tip(GameController.instance.player.playerController.vrActions.spectateAction_pico, left: false, "Special Move");
			}
		}
		Vector3 forward = headingContainer.transform.position - GameController.instance.player.standPosition;
		forward.y = 0f;
		headingContainer.transform.rotation = Quaternion.LookRotation(forward);
		if (setup)
		{
			switch (practiceMode)
			{
			case 2:
				heading.text = LocalisationController.getText("Practice", "Free Practice");
				desc.text = "";
				FloatingPointerController.instance.pointingAt = null;
				break;
			case 1:
				if (onPressurePoint >= practiceCharacter.rigidBodies.pressurePoints.Length)
				{
					heading.text = LocalisationController.getText("Practice", "Pressure Point Practice");
					desc.text = LocalisationController.getText("Practice", "Try hitting any pressure points you want");
					FloatingPointerController.instance.pointingAt = null;
					break;
				}
				heading.text = LocalisationController.getText("Practice", "Pressure Point:") + " " + LocalisationController.getText("Pressure Point", practiceCharacter.pressurePoints[onPressurePoint].name);
				desc.text = LocalisationController.getText("Pressure Point", practiceCharacter.pressurePoints[onPressurePoint].instruction);
				FloatingPointerController.instance.pointingAt = practiceCharacter.rigidBodies.pressurePoints[onPressurePoint].transform;
				FloatingPointerController.instance.displayText = LocalisationController.getText("Pressure Point", practiceCharacter.pressurePoints[onPressurePoint].name) + "\n" + LocalisationController.getText("Pressure Point Instruction", practiceCharacter.pressurePoints[onPressurePoint].instruction);
				if (!practiceCharacter.rigidBodies.pressurePoints[onPressurePoint].allowTime())
				{
					onPressurePoint++;
				}
				break;
			default:
				FloatingPointerController.instance.pointingAt = null;
				heading.text = LocalisationController.getText("Special Move", GameController.instance.player.specialMove.name);
				if (GameController.instance.player.doingSpecial <= 0f)
				{
					desc.text = LocalisationController.getText("Special Move Description", GameController.instance.player.specialMove.desc);
				}
				else
				{
					desc.text = LocalisationController.getText("Special Move Instruction", GameController.instance.player.specialMove.instruction);
				}
				break;
			}
			if (practiceCharacter != null)
			{
				for (int i = 0; i < practiceCharacter.rigidBodies.pressurePoints.Length; i++)
				{
					PressurePoint pressurePoint = practiceCharacter.rigidBodies.pressurePoints[i];
					pressurePoint.display.SetActive(pressurePoint.allowTime() && practiceMode == 1 && (i == onPressurePoint || onPressurePoint >= practiceCharacter.rigidBodies.pressurePoints.Length));
				}
			}
		}
		else if (GameController.instance.player != null)
		{
			setup = true;
			int characterIndex = Settings.instance.practiceFighterID;
			if (GameController.instance.specialMode.name == "Ninja Challenge")
			{
				characterIndex = 32;
			}
			practiceCharacter = GameController.instance.addFighter(2, characterIndex, 1, base.transform.position, base.transform.rotation.eulerAngles.y, 1f, aboveGround: false);
			practiceCharacter.lives = 1;
			GameController.instance.hud.setup();
		}
	}
}
public class PressurePoint : MonoBehaviour
{
	public PressurePointData data;

	private float lastHit;

	public GameObject display;

	public void setup(PressurePointData data)
	{
		this.data = data;
		base.name = "Pressure Point: " + data.name;
		display.gameObject.SetActive(value: false);
		display.transform.localScale = data.radius * 10f * Vector3.one;
	}

	public bool hit(Hittable.HandHitType handHit, bool showFailReason)
	{
		if (Array.IndexOf(data.hitType, handHit) == -1)
		{
			if (showFailReason)
			{
				CanvasController.addText(localise: true, data.failedText, base.transform.position, Color.red, 3f, base.transform);
			}
			return false;
		}
		lastHit = Time.time;
		return true;
	}

	public bool allowTime()
	{
		return Time.time > lastHit + 15f;
	}
}
[Serializable]
public class PressurePointData : Exportable
{
	[Header("Info")]
	public string instruction;

	public string failedText;

	[Header("Puppet Settings")]
	public string boneName;

	public string altBoneName;

	public Vector3 position;

	[Header("Hit Settings")]
	public float radius = 0.1f;

	public bool maleOnly;

	public Hittable.HandHitType[] hitType;

	public float damageMod = 1f;

	public float slideMod = 1f;

	public CharacterEffect.Effect addEffect;

	public string effectName;

	public float effectTime = 3f;

	public AudioClip[] soundOverrides;

	public bool hitInRound;

	public void localise()
	{
		LocalisationController.getText("Pressure Point", name);
		LocalisationController.getText("Pressure Point Instruction", instruction);
		LocalisationController.getText("Pressure Point Failed", failedText);
		if (effectName == "")
		{
			effectName = addEffect.ToString();
		}
		UnityEngine.Debug.LogError(name + ": " + LocalisationController.getChinese(name) + " (" + LocalisationController.getChinese(effectName) + ")");
	}

	public string summary()
	{
		if (effectName == "")
		{
			effectName = addEffect.ToString();
		}
		return LocalisationController.getText("Pressure Point", name) + " (" + LocalisationController.getText("Pressure Point", effectName) + ")";
	}
}
public class PressurePointDummy : MonoBehaviour
{
	public AudioClip hitSound;

	public AudioClip hitLiteSound;

	public float minHitTime = 0.5f;

	public float minHitPower = 1f;

	private float hitTime;

	public ChamberController chamber;

	public Transform boneContainer;

	public Transform colliderContainer;

	public Collider[] allColliders;

	public PressurePointData[] pressurePoints;

	public PressurePoint[] pressurePointDisplays;

	private int onPressurePoint;

	private void Start()
	{
		Transform[] componentsInChildren = boneContainer.GetComponentsInChildren<Transform>();
		allColliders = colliderContainer.GetComponentsInChildren<Collider>();
		chamber = base.transform.parent.GetComponentInParent<ChamberController>();
		Dictionary<string, Transform> dictionary = new Dictionary<string, Transform>();
		Transform[] array = componentsInChildren;
		foreach (Transform transform in array)
		{
			if (!dictionary.ContainsKey(transform.name))
			{
				dictionary.Add(transform.name, transform);
			}
		}
		List<PressurePoint> list = new List<PressurePoint>();
		PressurePointData[] array2 = pressurePoints;
		foreach (PressurePointData pressurePointData in array2)
		{
			Transform transform2 = null;
			if (dictionary.ContainsKey(pressurePointData.boneName))
			{
				transform2 = dictionary[pressurePointData.boneName];
			}
			else if (dictionary.ContainsKey(pressurePointData.altBoneName))
			{
				transform2 = dictionary[pressurePointData.altBoneName];
			}
			if (transform2 == null)
			{
				UnityEngine.Debug.LogError("Couldnt find: " + pressurePointData.name + " (" + pressurePointData.boneName + "/" + pressurePointData.altBoneName + ")");
				continue;
			}
			PressurePoint pressurePoint = UnityEngine.Object.Instantiate(Settings.instance.pressurePointPrefab, transform2);
			pressurePoint.transform.localPosition = pressurePointData.position;
			float num = float.PositiveInfinity;
			Vector3 position = Vector3.zero;
			Collider[] array3 = allColliders;
			for (int j = 0; j < array3.Length; j++)
			{
				Vector3 vector = array3[j].ClosestPoint(pressurePoint.transform.position);
				float magnitude = (pressurePoint.transform.position - vector).magnitude;
				if (magnitude < num)
				{
					num = magnitude;
					position = vector;
				}
			}
			pressurePoint.transform.position = position;
			pressurePoint.setup(pressurePointData);
			list.Add(pressurePoint);
		}
		pressurePointDisplays = list.ToArray();
	}

	private void Update()
	{
		if (!(GameController.instance.player == null) && onPressurePoint < pressurePoints.Length)
		{
			for (int i = 0; i < pressurePoints.Length; i++)
			{
				pressurePointDisplays[i].display.SetActive(onPressurePoint == i);
			}
			FloatingPointerController.instance.pointingAt = pressurePointDisplays[onPressurePoint].transform;
			FloatingPointerController.instance.displayText = LocalisationController.getText("Pressure Point", pressurePoints[onPressurePoint].name) + "\n" + LocalisationController.getText("Pressure Point Instruction", pressurePoints[onPressurePoint].instruction);
		}
	}

	private void OnCollisionEnter(Collision collision)
	{
		if (onPressurePoint >= pressurePoints.Length)
		{
			return;
		}
		Hittable component = collision.collider.GetComponent<Hittable>();
		if (component == null || hitTime > Time.time)
		{
			return;
		}
		float num = Mathf.Clamp01(collision.relativeVelocity.magnitude);
		if (!(component != null))
		{
			return;
		}
		bool flag = false;
		string text = "Blocked";
		if (component.isHand)
		{
			flag = true;
		}
		if (flag)
		{
			hitTime = Time.time + minHitTime;
		}
		if (component.audioSource != null)
		{
			component.audioSource.PlayOneShot(flag ? hitSound : hitLiteSound);
		}
		component.rb.buzz(collision.relativeVelocity.magnitude, component.bodyPart.source);
		HitEffects.addHitEffect(flag, num / 10f, collision.contacts[0].point, collision.contacts[0].normal, showPerc: false);
		if (flag)
		{
			Hittable.HandHitType handHit = component.handHitType(collision);
			PressurePoint pressurePoint = pressurePointDisplays[onPressurePoint];
			if ((pressurePoint.transform.position - collision.contacts[0].point).magnitude <= pressurePoint.data.radius)
			{
				if (pressurePoint.hit(handHit, showFailReason: true))
				{
					onPressurePoint++;
					if (onPressurePoint >= pressurePoints.Length)
					{
						chamber.isComplete = true;
						FloatingPointerController.instance.pointingAt = null;
						FloatingPointerController.instance.displayText = "Done";
						pressurePoint.gameObject.SetActive(value: false);
					}
				}
			}
			else
			{
				CanvasController.addText(localise: true, "Missed", collision.GetContact(0).point, Color.red, 0.5f);
			}
		}
		else
		{
			CanvasController.addText(localise: true, text, collision.GetContact(0).point, flag ? Color.green : Color.red, flag ? 2f : 0.5f);
		}
	}
}
public class ProjectileController : MonoBehaviour
{
	public enum HitCheck
	{
		None,
		Angle,
		Ray
	}

	public enum MovementType
	{
		Default,
		Straighten,
		Spin
	}

	public enum HitType
	{
		None,
		StickIn,
		Explode
	}

	public GameObject hitEffectPrefab;

	public float speed = 1f;

	public float speedMult = 1f;

	public float speedMin = 5f;

	public bool gravity = true;

	public float revertTimer = 1.5f;

	protected Rigidbody rb;

	protected Vector3 velocity;

	protected float startTime;

	public bool hasHit;

	public bool fromGrab;

	public AudioClip hitSound;

	public AudioClip hitFloorSound;

	public AudioSource continualAudio;

	protected AudioSource audioSource;

	public Collider collider;

	public float deleteTimer;

	public bool provokesVoice = true;

	public string givesAchievement = "";

	public HitCheck hitCheckType;

	public GameCharacter firer;

	public float damage = 0.5f;

	public Transform inner;

	public MovementType movementType;

	public HitType hitType;

	private SpecialMoveData specialMoveData;

	public SpecialMoveController following;

	public bool useRBVelocity;

	public bool unblockable;

	public GameObject hitPersonEffect;

	public bool inMotion = true;

	public LayerMask layerMask;

	public float minTime = 0.03f;

	public bool doRayCast;

	public void setup(GameCharacter firer, Vector3 position, Quaternion rotation, Vector3 direction, bool fromGrab, float speed = -1f)
	{
		if (base.gameObject.layer != 9)
		{
			UnityEngine.Debug.LogError("Wrong layer? " + base.name);
		}
		this.fromGrab = fromGrab;
		audioSource = GetComponent<AudioSource>();
		specialMoveData = firer.doingSpecialData;
		this.firer = firer;
		base.transform.position = position + direction.normalized * 0.2f;
		base.transform.rotation = rotation;
		if (speed > 0f)
		{
			this.speed = speed * speedMult;
		}
		if (this.speed < speedMin)
		{
			this.speed = speedMin;
		}
		rb = GetComponent<Rigidbody>();
		rb.useGravity = false;
		velocity = direction.normalized * this.speed;
		startTime = Time.time;
		deleteTimer = 5f + UnityEngine.Random.value * 5f;
		GameController.instance.projectiles.Add(this);
	}

	protected void explode(bool isPerson)
	{
		if (hitType == HitType.Explode)
		{
			GameObject gameObject = ((isPerson && hitPersonEffect != null) ? hitPersonEffect : hitEffectPrefab);
			if (gameObject != null)
			{
				GameObject obj = UnityEngine.Object.Instantiate(gameObject, GameController.instance.transform);
				obj.transform.position = base.transform.position;
				obj.transform.rotation = base.transform.rotation;
				UnityEngine.Object.Destroy(obj, 8f);
			}
			inMotion = false;
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}

	public void collideWith(Collider collider, Vector3 point, Vector3 normal)
	{
		Hittable component = collider.GetComponent<Hittable>();
		if (component != null && component.rb.character == firer)
		{
			return;
		}
		inMotion = false;
		bool flag = false;
		if (component == null)
		{
			Breakable breakable = collider.attachedRigidbody?.GetComponent<Breakable>();
			if (breakable != null)
			{
				breakable.hit(breakable.minHitPower * 2f, special: true, velocity, point, "", firer != null && firer.isPlayer());
				flag = false;
				bounce(normal);
			}
			else
			{
				Rigidbody component2 = collider.GetComponent<Rigidbody>();
				if (component2 != null && !component2.isKinematic)
				{
					component2.AddForce(velocity * 2f, ForceMode.Impulse);
				}
				else
				{
					HitSurface component3 = collider.GetComponent<HitSurface>();
					if (component3 == null)
					{
						flag = true;
					}
					else
					{
						flag = true;
						if (component3.bouncesProjectiles())
						{
							component3.PlaySound(audioSource);
							bounce(normal);
							flag = false;
						}
						else
						{
							component3.ProjectileHit(this, point, normal);
						}
					}
				}
			}
			explode(isPerson: false);
		}
		else if (component.bodyPart.weaponForce == 0f || unblockable)
		{
			switch (hitCheckType)
			{
			case HitCheck.Angle:
			{
				Quaternion a = Quaternion.LookRotation(base.transform.forward);
				Quaternion b = Quaternion.LookRotation(-normal);
				flag = Quaternion.Angle(a, b) < 85f;
				break;
			}
			case HitCheck.Ray:
			{
				if (Physics.Raycast(new Ray(base.transform.position, base.transform.forward), out var _, 0.3f))
				{
					flag = true;
				}
				break;
			}
			case HitCheck.None:
				flag = true;
				break;
			}
		}
		if (flag)
		{
			OnHit(component, collider, point, normal);
		}
		else if (!rb.isKinematic)
		{
			if (!hasHit && hitType == HitType.Explode)
			{
				explode(isPerson: true);
			}
			else
			{
				audioSource.PlayOneShot(hitFloorSound);
			}
		}
	}

	public virtual void OnCollisionEnter(Collision collision)
	{
		if (!(Time.time < startTime + minTime))
		{
			collideWith(collision.collider, collision.contacts[0].point, collision.contacts[0].normal);
		}
	}

	public virtual void OnHit(Hittable hittable, Collision collision)
	{
		OnHit(hittable, collision.collider, collision.contacts[0].point, collision.contacts[0].normal);
	}

	public virtual void OnHit(Hittable hittable, Collider collider, Vector3 point, Vector3 normal)
	{
		HitObject(hittable, collider, point, normal);
	}

	public void HitObject(Hittable hittable, Collider collider, Vector3 point, Vector3 normal)
	{
		if (hasHit)
		{
			return;
		}
		audioSource.Stop();
		if (hittable != null)
		{
			if (firer == hittable.rb.character)
			{
				return;
			}
			float num = specialMoveData.damageMod * hittable.bodyPart.knockDownPerc;
			if (unblockable)
			{
				num = num / 2f + 0.5f;
			}
			hittable.rb.Hit(useRBVelocity ? rb.velocity : velocity, hittable, firer, specialMoveData.slideMod, num, point, Hittable.HandHitType.General, skipPressurePoints: false, specialMoveData.name);
			hittable.rb.setLastHit(RigidBodies.LastHit.Projectile, point);
			hasHit = true;
			if (hittable.rb != null)
			{
				if (hitType == HitType.Explode)
				{
					explode(isPerson: true);
				}
				else
				{
					if (hitPersonEffect != null)
					{
						UnityEngine.Object.Instantiate(hitPersonEffect, point, Quaternion.LookRotation(normal), null);
					}
					if (provokesVoice)
					{
						hittable.rb.character.ProjectileHitVoice();
					}
					if (hittable.bodyPart.knockDownPerc > 0f)
					{
						if (hittable.bodyPart.isHead && givesAchievement != "" && firer.isPlayer())
						{
							AchievementsController.achievement(givesAchievement);
						}
						stick(hittable.muscle.target, normal, hittable.rb);
					}
					else
					{
						bounce(normal);
					}
				}
			}
		}
		else
		{
			hasHit = true;
			if (hitType == HitType.Explode)
			{
				explode(isPerson: false);
			}
			else
			{
				stick(collider.transform, normal, null);
				UnityEngine.Object.Destroy(base.gameObject, 5f);
			}
		}
		if (!hasHit && hitType == HitType.Explode)
		{
			explode(isPerson: false);
		}
		velocity = Vector3.zero;
	}

	public void stick(Transform into, Vector3 normal, RigidBodies person)
	{
		audioSource.PlayOneShot(hitSound);
		rb.isKinematic = true;
		rb.useGravity = false;
		collider.enabled = false;
		base.transform.SetParent(into, worldPositionStays: true);
		if (person != null)
		{
			base.transform.position += normal * -0.1f;
		}
		else
		{
			base.transform.position += base.transform.forward * 0.1f;
		}
		if (continualAudio != null)
		{
			continualAudio.Stop();
		}
		if ((bool)person)
		{
			person.stuckProjectiles.Add(this);
		}
	}

	public void bounce(Vector3 normal)
	{
		hasHit = true;
		rb.useGravity = true;
		rb.isKinematic = false;
		if (continualAudio != null)
		{
			continualAudio.Stop();
		}
		rb.velocity = Vector3.Reflect(rb.velocity, normal);
	}

	public void unstick()
	{
		rb.isKinematic = false;
		rb.useGravity = true;
		collider.enabled = true;
		base.transform.SetParent(GameController.instance.transform, worldPositionStays: true);
		base.transform.position -= base.transform.forward * 0.1f;
	}

	public virtual void flyingMovement()
	{
		switch (movementType)
		{
		case MovementType.Straighten:
			base.transform.rotation = Quaternion.RotateTowards(base.transform.rotation, Quaternion.LookRotation(velocity), 1000f * Time.deltaTime);
			base.transform.position += velocity * Time.deltaTime;
			break;
		case MovementType.Spin:
			base.transform.rotation *= Quaternion.Euler(1000f * Time.deltaTime, 0f, 0f);
			base.transform.position += velocity * Time.deltaTime;
			break;
		default:
		{
			if (doRayCast && Physics.Raycast(new Ray(base.transform.position, velocity), out var hitInfo, velocity.magnitude * Time.deltaTime * 1.1f, layerMask))
			{
				base.transform.position = hitInfo.point;
				Hittable component = hitInfo.collider.GetComponent<Hittable>();
				HitObject(component, hitInfo.collider, hitInfo.point, hitInfo.normal);
				Breakable breakable = hitInfo.collider.attachedRigidbody?.GetComponent<Breakable>();
				if (breakable != null)
				{
					breakable.hit(breakable.minHitPower * 2f, special: true, velocity, hitInfo.point, "", firer != null && firer.isPlayer());
				}
			}
			else
			{
				base.transform.position += velocity * Time.deltaTime;
			}
			break;
		}
		}
		if (gravity)
		{
			velocity += Vector3.down * Time.deltaTime;
		}
	}

	private void Update()
	{
		if (!hasHit)
		{
			flyingMovement();
			revertTimer -= Time.deltaTime;
			if (revertTimer < 0f)
			{
				if (continualAudio != null)
				{
					continualAudio.Stop();
				}
				if (rb == null)
				{
					rb = GetComponent<Rigidbody>();
					UnityEngine.Debug.LogError("Rigidbody null on: " + base.name + " try again: " + rb);
					return;
				}
				rb.isKinematic = false;
				collider.enabled = true;
				rb.useGravity = true;
				rb.constraints = RigidbodyConstraints.None;
				rb.velocity = velocity;
				velocity = Vector3.zero;
				hasHit = true;
			}
			return;
		}
		if (continualAudio != null)
		{
			continualAudio.Stop();
		}
		if (rb == null || !rb.isKinematic)
		{
			deleteTimer -= Time.deltaTime;
			if (deleteTimer < 0f)
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}
	}
}
public class PropGrab : MonoBehaviour
{
	public PuppetMasterProp prop;

	public void grab(PropMuscle muscle)
	{
		if (!prop.isPickedUp)
		{
			muscle.currentProp = prop;
		}
	}
}
public class PuppetTrackerHandOffset : MonoBehaviour
{
	public float speed;

	[Range(0f, 1f)]
	public float massPerc;

	public GameCharacter gameCharacter;

	public bool isLeft;

	public Transform offsetDisplay;

	public Hittable hand;

	public Transform target;

	public Vector3 offsetSpeed;

	public Vector3 offset;

	public float offsetPerc;

	public float maxOffsetAchieved;

	public Quaternion rotationOffset;

	public bool doRotation;

	private LineRenderer line;

	public float recoverPause;

	public float recoverTime = 1f;

	public float pause;

	private float perc;

	private float startTime;

	private float maxOffset = 0.3f;

	public float minMass;

	public float maxMass = 4f;

	private Vector3 lastPos;

	public bool showLine = true;

	public bool isOffset;

	private void Start()
	{
		line = GetComponent<LineRenderer>();
		startTime = Time.time + 0f;
	}

	public static Quaternion ClampRotation(Quaternion q, Vector3 bounds)
	{
		q.x /= q.w;
		q.y /= q.w;
		q.z /= q.w;
		q.w = 1f;
		float value = 114.59156f * Mathf.Atan(q.x);
		value = Mathf.Clamp(value, 0f - bounds.x, bounds.x);
		q.x = Mathf.Tan((float)Math.PI / 360f * value);
		float value2 = 114.59156f * Mathf.Atan(q.y);
		value2 = Mathf.Clamp(value2, 0f - bounds.y, bounds.y);
		q.y = Mathf.Tan((float)Math.PI / 360f * value2);
		float value3 = 114.59156f * Mathf.Atan(q.z);
		value3 = Mathf.Clamp(value3, 0f - bounds.z, bounds.z);
		q.z = Mathf.Tan((float)Math.PI / 360f * value3);
		return q.normalized;
	}

	private void Update()
	{
		lastPos = base.transform.localPosition;
		if (hand == null)
		{
			if (isLeft)
			{
				hand = gameCharacter.rigidBodies.leftHand;
			}
			else
			{
				hand = gameCharacter.rigidBodies.rightHand;
			}
			return;
		}
		if (minMass == 0f)
		{
			minMass = hand.rigidBody.mass;
		}
		speed = hand.rigidBody.velocity.magnitude;
		massPerc = Mathf.Clamp01((speed - 1f) / 10f);
		if (gameCharacter.isPlayer())
		{
			recoverPause = 0f;
			recoverTime = Settings.instance.playerHandOffsetRecoveryTime;
			maxMass = 1f * Settings.instance.maxMassMultiply;
		}
		else
		{
			recoverPause = GameController.instance.difficultyLevel.handOffsetPauseTime.lerp(gameCharacter.difficulty);
			recoverTime = GameController.instance.difficultyLevel.handOffsetRecoveryTime.lerp(gameCharacter.difficulty);
			maxMass = GameController.instance.difficultyLevel.massMultiplyBySpeed.lerp(gameCharacter.difficulty) * Settings.instance.maxMassMultiply;
		}
		if (gameCharacter.hasEffect(CharacterEffect.Effect.Strength))
		{
			massPerc = 1f;
		}
		bool flag = gameCharacter.rigidBodies.notTouching(isLeft);
		bool flag2 = gameCharacter.rigidBodies.grabbed[(!isLeft) ? 1u : 0u];
		if (Settings.instance.massMultiplyEnabled)
		{
			hand.rigidBody.mass = Mathf.Lerp(minMass, maxMass, massPerc);
		}
		else
		{
			hand.rigidBody.mass = minMass;
		}
		Vector3 vector = target.transform.position - base.transform.position;
		bool flag3 = hand.rb.touchTime > Time.time - 1f;
		float num = 0.02f / (Time.deltaTime / (1f / 60f));
		float num2 = ((gameCharacter.targetEnemy == null) ? 1f : Mathf.Clamp01(((gameCharacter.targetEnemy.standPosition - gameCharacter.standPosition).magnitude - 1.5f) / 1.5f)) * 4f + 1f;
		if (Time.time > startTime && vector.magnitude > num && vector.magnitude > offset.magnitude && !flag2)
		{
			if (flag3 && !flag)
			{
				bool flag4 = false;
				bool flag5 = true;
				if (offset.magnitude > 0.02f && vector.magnitude < offset.magnitude && flag5)
				{
					Quaternion a = Quaternion.LookRotation(vector);
					Quaternion b = Quaternion.LookRotation(offset);
					if (Quaternion.Angle(a, b) > 90f)
					{
						flag4 = true;
					}
				}
				if (!flag4)
				{
					offsetSpeed = vector * (1f - offsetPerc);
					if (Settings.instance.offsetRotation)
					{
						rotationOffset = Quaternion.Inverse(base.transform.rotation) * target.transform.rotation;
						if (flag5)
						{
							rotationOffset = ClampRotation(rotationOffset, Vector3.one * 45f);
						}
					}
					perc = 0f;
					pause = recoverPause;
				}
			}
		}
		else if (pause > 0f)
		{
			if (flag)
			{
				pause -= Time.deltaTime * num2;
			}
		}
		else if (flag)
		{
			perc = Mathf.MoveTowards(perc, 1f, Time.deltaTime);
			offset = Vector3.MoveTowards(offset, Vector3.zero, perc * perc * (Time.deltaTime / recoverTime) * num2);
			if (Settings.instance.offsetRotation)
			{
				rotationOffset = Quaternion.RotateTowards(rotationOffset, Quaternion.identity, 45f * (Time.deltaTime / recoverTime * 2f));
			}
		}
		offset += offsetSpeed;
		float num3 = Mathf.Clamp01(offsetSpeed.magnitude / 0.3f);
		if (num3 > offsetPerc)
		{
			offsetPerc = num3;
		}
		else
		{
			offsetPerc = Mathf.MoveTowards(offsetPerc, Mathf.Clamp01(offsetSpeed.magnitude / 0.3f), Time.deltaTime);
		}
		if (offset.magnitude > maxOffsetAchieved)
		{
			maxOffsetAchieved = offset.magnitude;
		}
		if (true)
		{
			offsetSpeed = Vector3.MoveTowards(offsetSpeed, Vector3.zero, Time.deltaTime * 3f);
		}
		else
		{
			offsetSpeed = Vector3.zero;
		}
		offset = Vector3.ClampMagnitude(offset, maxOffset);
		if (offset.magnitude > 0.05f && !gameCharacter.rigidBodies.isDown(allTheWay: true))
		{
			isOffset = true;
			if (showLine)
			{
				line.enabled = true;
				line.SetPosition(0, base.transform.position);
				line.SetPosition(1, base.transform.position - offset);
			}
		}
		else
		{
			line.enabled = false;
			isOffset = false;
		}
		offsetDisplay.transform.position = base.transform.position - offset;
		if (Settings.instance.offsetRotation)
		{
			offsetDisplay.transform.rotation = base.transform.rotation * Quaternion.Inverse(rotationOffset);
		}
	}
}
public class RainDrops : MonoBehaviour
{
	private MeshRenderer renderer;

	public string mainTexture = "_MainTex";

	public string detailTexture = "_DetailNormalMap";

	public Vector2 mainOffset;

	public Vector2 detailOffset;

	private float timer1;

	private float timer2;

	public float interval = 0.025f;

	public float interval2 = 0.05f;

	private void Start()
	{
		renderer = GetComponent<MeshRenderer>();
	}

	private void Update()
	{
		timer1 -= Time.deltaTime;
		if (timer1 <= 0f)
		{
			mainOffset.x = UnityEngine.Random.value;
			mainOffset.y = UnityEngine.Random.value;
			renderer.material.SetTextureOffset(mainTexture, mainOffset);
			timer1 += interval;
		}
		timer2 -= Time.deltaTime;
		if (timer2 <= 0f)
		{
			detailOffset.x = UnityEngine.Random.value;
			detailOffset.y = UnityEngine.Random.value;
			renderer.material.SetTextureOffset(detailTexture, detailOffset);
			timer2 += interval2;
		}
	}
}
public class RandomScale : MonoBehaviour
{
	public MinMax scale;

	public MinMax heightVariance;

	private void Start()
	{
		float num = scale.random();
		base.transform.localScale = new Vector3(num, num, num * heightVariance.random());
	}

	private void Update()
	{
	}
}
public class RandomSound : MonoBehaviour
{
	public AudioClip[] sounds;

	public AudioSource audioSource;

	private void Start()
	{
		audioSource = base.gameObject.AddComponent<AudioSource>();
		audioSource.spatialBlend = 1f;
		audioSource.playOnAwake = false;
		GameController.instance.setAudioMixerGroup(audioSource);
		audioSource.PlayOneShot(sounds[UnityEngine.Random.Range(0, sounds.Length)]);
	}

	private void Update()
	{
	}
}
[Serializable]
public class RecordAction
{
	public enum TrackerType
	{
		Head,
		L_Hand,
		R_Hand
	}

	public string name;

	public RecordStep[] head;

	public RecordStep[] l_hand;

	public RecordStep[] r_hand;

	[NonSerialized]
	public float l_squeezeAmount;

	[NonSerialized]
	public float r_squeezeAmount;

	public float totalTime;

	[NonSerialized]
	public Vector3 centraliseOffset;

	public bool isSetup;

	public bool singleFrame;

	public float attackRange;

	public float attackHeight;

	public float attackTime;

	public string attackDebug = "";

	public RecordAction(string name, bool singleFrame = false)
	{
		this.name = name;
		this.singleFrame = singleFrame;
	}

	public bool isEmpty()
	{
		if (head != null)
		{
			return head.Length == 0;
		}
		return true;
	}

	public void play(TrackerType type, float e, float speedMultiply, bool loop, out Vector3 localPosition, out Quaternion localRotation, float heightPerc = 1f)
	{
		RecordStep[] array = null;
		if (type == TrackerType.Head)
		{
			array = head;
		}
		if (type == TrackerType.L_Hand)
		{
			array = l_hand;
		}
		if (type == TrackerType.R_Hand)
		{
			array = r_hand;
		}
		if (singleFrame)
		{
			if (array == null || array.Length == 0)
			{
				MoveRecorder.instance.actions.defaultAction.play(type, e, speedMultiply, loop, out localPosition, out localRotation, heightPerc);
				return;
			}
			RecordStep recordStep = array[0];
			localPosition = recordStep.position;
			localRotation = Quaternion.Euler(recordStep.rotation);
			if (type == TrackerType.L_Hand)
			{
				l_squeezeAmount = recordStep.squeeze;
			}
			if (type == TrackerType.R_Hand)
			{
				r_squeezeAmount = recordStep.squeeze;
			}
			return;
		}
		if (array == null || array.Length < 2)
		{
			MoveRecorder.instance.actions.defaultAction.play(type, e, speedMultiply, loop, out localPosition, out localRotation, heightPerc);
			return;
		}
		if (totalTime == 0f)
		{
			totalTime = array[^1].time + 0.5f;
		}
		float num = 0f;
		num = ((loop || MoveRecorder.alwaysLoop) ? Mathf.Repeat(e * speedMultiply, totalTime) : Mathf.Clamp(e * speedMultiply, 0f, totalTime));
		for (int i = 0; i < array.Length; i++)
		{
			if (!(num >= array[i].time) || !(num < array[i].endTime))
			{
				continue;
			}
			int num2 = i;
			int num3 = num2 + 1;
			if (!loop)
			{
				if (num3 == array.Length)
				{
					num3 = num2;
				}
			}
			else if (num3 == array.Length)
			{
				num3 = 0;
			}
			RecordStep recordStep2 = array[num2];
			RecordStep recordStep3 = array[num3];
			float t = (num - recordStep2.time) / recordStep2.duration;
			localPosition = Vector3.Lerp(recordStep2.position, recordStep3.position, t);
			localPosition.y *= heightPerc;
			localRotation = Quaternion.Lerp(Quaternion.Euler(recordStep2.rotation), Quaternion.Euler(recordStep3.rotation), t);
			if (type == TrackerType.L_Hand)
			{
				l_squeezeAmount = Mathf.Lerp(recordStep2.squeeze, recordStep3.squeeze, t);
			}
			if (type == TrackerType.R_Hand)
			{
				r_squeezeAmount = Mathf.Lerp(recordStep2.squeeze, recordStep3.squeeze, t);
			}
			return;
		}
		RecordStep recordStep4 = array[^1];
		localPosition = recordStep4.position;
		localRotation = Quaternion.Euler(recordStep4.rotation);
		if (type == TrackerType.L_Hand)
		{
			l_squeezeAmount = recordStep4.squeeze;
		}
		if (type == TrackerType.R_Hand)
		{
			r_squeezeAmount = recordStep4.squeeze;
		}
	}

	public void setup(bool clean, string defaultName)
	{
		isSetup = true;
		if (defaultName != "")
		{
			name = defaultName;
		}
		if (clean)
		{
			head = cleanUp(head);
			l_hand = cleanUp(l_hand);
			r_hand = cleanUp(r_hand);
		}
		if (head.Length != 0)
		{
			centraliseOffset = new Vector3(head[0].position.x, 0f, head[0].position.z);
		}
		setupSteps(head);
		setupSteps(l_hand);
		setupSteps(r_hand);
		attackRange = 0f;
		RecordStep[] array = l_hand;
		foreach (RecordStep recordStep in array)
		{
			Vector3 vector = recordStep.position - head[0].position;
			vector.y = 0f;
			if (vector.magnitude > attackRange)
			{
				attackRange = vector.magnitude;
				attackTime = recordStep.time;
				attackHeight = recordStep.position.y;
				attackDebug = "L Hand";
			}
		}
		array = r_hand;
		foreach (RecordStep recordStep2 in array)
		{
			Vector3 vector2 = recordStep2.position - head[0].position;
			vector2.y = 0f;
			if (vector2.magnitude > attackRange)
			{
				attackRange = vector2.magnitude;
				attackTime = recordStep2.time;
				attackHeight = recordStep2.position.y;
				attackDebug = "R Hand";
			}
		}
	}

	public float getRange(float speed, float timeElapsed = 0f)
	{
		float num = (attackTime - timeElapsed) * speed;
		if (num < 0f)
		{
			num = 0f;
		}
		return num + attackRange;
	}

	public bool isBetween(Vector3 between, Vector3 start, Vector3 end, float cullThreshold = 0.02f)
	{
		Vector3 vector = end - start;
		_ = between - start;
		return (start + vector / 2f - between).magnitude <= cullThreshold;
	}

	public bool isBetweenRotation(Quaternion between, Quaternion start, Quaternion end)
	{
		float num = Quaternion.Angle(end, start);
		return Quaternion.Angle(between, start) < num;
	}

	private RecordStep[] cleanUp(RecordStep[] data)
	{
		if (data == null)
		{
			data = new RecordStep[0];
		}
		RecordStep[] array = data;
		foreach (RecordStep recordStep in array)
		{
			recordStep.pos = new VectorSavable(recordStep.position.x, recordStep.position.y, recordStep.position.z);
			recordStep.rot = new VectorSavable(recordStep.rotation.x, recordStep.rotation.y, recordStep.rotation.z);
		}
		bool flag = false;
		for (int j = 0; j < data.Length - 3; j += 2)
		{
			Vector3 position = data[j + 1].position;
			Vector3 position2 = data[j].position;
			Vector3 position3 = data[j + 2].position;
			Quaternion between = Quaternion.Euler(data[j + 1].rotation);
			Quaternion start = Quaternion.Euler(data[j].rotation);
			Quaternion end = Quaternion.Euler(data[j + 2].rotation);
			if (isBetween(position, position2, position3) && isBetweenRotation(between, start, end))
			{
				data[j + 1].toRemove = true;
				flag = true;
			}
		}
		if (flag)
		{
			List<RecordStep> list = new List<RecordStep>();
			for (int k = 0; k < data.Length; k++)
			{
				if (!data[k].toRemove)
				{
					list.Add(data[k]);
				}
			}
			return cleanUp(list.ToArray());
		}
		return data;
	}

	public void setupSteps(RecordStep[] data)
	{
		for (int i = 0; i < data.Length; i++)
		{
			data[i].position -= centraliseOffset;
			if (i < data.Length - 1)
			{
				data[i].endTime = data[i + 1].time;
			}
			else
			{
				data[i].endTime = data[i].time + 0.5f;
			}
			data[i].duration = data[i].endTime - data[i].time;
		}
	}
}
[Serializable]
public class RecordStep
{
	public float time;

	public VectorSavable pos;

	public VectorSavable rot;

	public float squeeze;

	[NonSerialized]
	public float endTime;

	[NonSerialized]
	public float duration;

	public bool toRemove;

	public Vector3 position
	{
		get
		{
			return pos.getVector();
		}
		set
		{
			if (pos == null)
			{
				pos = new VectorSavable();
			}
			pos.setVector(value);
		}
	}

	public Vector3 rotation
	{
		get
		{
			return rot.getVector();
		}
		set
		{
			if (rot == null)
			{
				rot = new VectorSavable();
			}
			rot.setVector(value);
		}
	}
}
public class RecordTracker : MonoBehaviour
{
	public List<RecordStep> recordData;

	public float nextInterval;

	public LineRenderer line;

	public void record(float elapsed, float interval, Transform following)
	{
		if (Time.time > nextInterval)
		{
			nextInterval = Time.time + interval;
			base.transform.position = following.transform.position;
			base.transform.rotation = following.transform.rotation;
			RecordStep recordStep = new RecordStep();
			recordStep.time = elapsed;
			recordStep.position = base.transform.localPosition;
			recordStep.rotation = base.transform.localRotation.eulerAngles;
			recordData.Add(recordStep);
			int num = Mathf.Min(recordData.Count, 40);
			Vector3[] array = new Vector3[num];
			for (int i = 0; i < num; i++)
			{
				array[i] = recordData[recordData.Count - i - 1].position + base.transform.parent.position;
			}
			line.positionCount = num;
			line.SetPositions(array);
		}
	}

	public void setPosition(Transform following)
	{
		base.transform.position = following.transform.position;
		base.transform.rotation = following.transform.rotation;
	}

	public void clear()
	{
		recordData.Clear();
	}

	public RecordStep[] getSteps()
	{
		return recordData.ToArray();
	}
}
public class RecordedActions : MonoBehaviour
{
	public RecordAction defaultAction;

	public List<FightingStyle> fightingStyles;

	public List<SpecialMove> specialMoves;

	private void Start()
	{
		setup();
	}

	public void setup()
	{
		defaultAction.setup(clean: true, "Default Stance");
		if (fightingStyles.Count == 0)
		{
			UnityEngine.Debug.LogError("No fighting styles");
		}
		foreach (FightingStyle fightingStyle in fightingStyles)
		{
			fightingStyle.setup(clean: true);
		}
		foreach (SpecialMove specialMove in specialMoves)
		{
			specialMove.setup(clean: true);
			getSpecialMoveByName(specialMove.name);
		}
	}

	public SpecialMove getSpecialMoveByName(string name)
	{
		foreach (SpecialMove specialMove in specialMoves)
		{
			if (specialMove.name == name)
			{
				return specialMove;
			}
		}
		UnityEngine.Debug.LogError("Couldnt find move for: " + name);
		return null;
	}
}
public class RigidBodies : MonoBehaviour
{
	public enum LastHit
	{
		None,
		FlyingKick,
		FlyingPunch,
		SpecialMove,
		Projectile,
		Crockery
	}

	public int id;

	public float aiSpeed = 1f;

	[NonSerialized]
	public GameCharacter character;

	[NonSerialized]
	public Rigidbody rb;

	public BodyPartData[] bodyParts;

	[NonSerialized]
	public Transform head;

	[NonSerialized]
	public Transform chest;

	public Hittable generalHitPoint;

	public Hittable headHittable;

	public Hittable rightHand;

	public Hittable leftHand;

	public Hittable rightFoot;

	public Hittable leftFoot;

	[NonSerialized]
	public HandPositions hands;

	public float leftWeaponDamageTime;

	public float rightWeaponDamageTime;

	public float leftWeaponHitTime;

	public float rightWeaponHitTime;

	public float touchTime;

	[NonSerialized]
	public VRIK ik;

	[NonSerialized]
	public PuppetMaster pm;

	public FaceController face;

	public SkinnedMeshRenderer characterHat;

	public Material ironFistSkin;

	public MeshRenderer vrHat;

	public float maxHealth = 1f;

	public float standUpPerc = 1f;

	public float standUpPercMax = 1f;

	public float specialPerc;

	public float specialChargeSpeed;

	[Range(0f, 1f)]
	public float jumpPerc;

	public float hitRecovery;

	public float heightStandOffset;

	public SwooshIfFast[] swooshes;

	public FootstepController[] footSoundSources;

	public bool hitsDisabled;

	public LastHit lastHit;

	public Vector3 slide;

	public Vector3 specialSlide;

	public Vector3 r_forward = new Vector3(-80f, 110f, -50f);

	public Vector3 l_forward = new Vector3(-80f, -90f, 25f);

	private SkinnedMeshRenderer[] meshes;

	public float downTimer;

	public AudioSource audioSource;

	public bool hasHitGround;

	[NonSerialized]
	public Material defaultSkinMaterial;

	public SkinnedMeshRenderer wholebodyMeshRenderer;

	public bool hideWholeBody;

	public SkinMesh[] skinMeshes;

	public List<ProjectileController> stuckProjectiles;

	public HandMeterController rightHandMeter;

	public HandMeterController leftHandMeter;

	public PressurePoint[] pressurePoints;

	public int[] armCollisions;

	public float[] armTouchTime;

	public float[] armHitTime;

	public bool[] grabbed;

	public bool[] grabbing;

	public FallAndGetUp fall;

	public float showPressurePoints;

	public float stanceAngle;

	public AltCostume[] altCostumes;

	public bool forPlinth;

	[NonSerialized]
	public string wasPressurePoint = "";

	[NonSerialized]
	public AudioClip overrideSound;

	public float firstStrikeTime;

	public int recoveries;

	public float landSpeed;

	public float landOffset;

	public Muscle spine;

	public Muscle hips;

	public float createTime;

	private void setup(HandPositions hands)
	{
		audioSource = base.gameObject.AddComponent<AudioSource>();
		audioSource.spatialBlend = 1f;
		armCollisions = new int[2];
		armTouchTime = new float[2];
		armHitTime = new float[2];
		grabbed = new bool[2];
		grabbing = new bool[2];
		GetComponentInChildren<Animator>().runtimeAnimatorController = character.animatorController;
		meshes = GetComponentsInChildren<SkinnedMeshRenderer>();
		SkinnedMeshRenderer[] array = meshes;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].enabled = false;
		}
		this.hands = hands;
		if (hands == null)
		{
			UnityEngine.Debug.LogError("No Hands: " + base.name);
		}
		face = GetComponentInChildren<FaceController>();
		face.Setup();
		createTime = Time.time;
		pm = GetComponentInChildren<PuppetMaster>();
		pm.mode = PuppetMaster.Mode.Kinematic;
		Muscle[] muscles;
		if (bodyParts.Length == 0)
		{
			Rigidbody[] componentsInChildren = GetComponentsInChildren<Rigidbody>();
			List<BodyPartData> list = new List<BodyPartData>();
			Rigidbody[] array2 = componentsInChildren;
			foreach (Rigidbody rigidbody in array2)
			{
				if (!rigidbody.GetComponent<TigerClawController>())
				{
					BodyPartData bodyPartData = new BodyPartData();
					bodyPartData.name = rigidbody.name;
					bodyPartData.rb = rigidbody;
					bodyPartData.setDefaults();
					list.Add(bodyPartData);
				}
			}
			muscles = pm.muscles;
			foreach (Muscle muscle in muscles)
			{
				if (muscle.props.group == Muscle.Group.Spine)
				{
					spine = muscle;
				}
				if (muscle.props.group == Muscle.Group.Hips)
				{
					hips = muscle;
				}
			}
			bodyParts = list.ToArray();
		}
		BodyPartData[] array3 = bodyParts;
		foreach (BodyPartData bodyPartData2 in array3)
		{
			Hittable hittable = bodyPartData2.rb.gameObject.AddComponent<Hittable>();
			hittable.bodyPart = bodyPartData2;
			hittable.rb = this;
			bodyPartData2.hittable = hittable;
			if (bodyPartData2.isLeftHand)
			{
				leftHand = hittable;
			}
			if (bodyPartData2.isRightHand)
			{
				rightHand = hittable;
			}
			if (bodyPartData2.isChest)
			{
				generalHitPoint = hittable;
			}
			if (bodyPartData2.isFoot && bodyPartData2.source == BodyPartData.Source.LeftHand)
			{
				leftFoot = bodyPartData2.hittable;
			}
			if (bodyPartData2.isFoot && bodyPartData2.source == BodyPartData.Source.RightHand)
			{
				rightFoot = bodyPartData2.hittable;
			}
			if (bodyPartData2.weaponForce > 0f || bodyPartData2.isHead)
			{
				hittable.audioSource = hittable.gameObject.AddComponent<AudioSource>();
				hittable.audioSource.playOnAwake = false;
				hittable.audioSource.spatialBlend = 1f;
				GameController.instance.setAudioMixerGroup(hittable.audioSource);
			}
		}
		muscles = pm.muscles;
		foreach (Muscle muscle2 in muscles)
		{
			Hittable component = muscle2.joint.GetComponent<Hittable>();
			if (component != null)
			{
				component.muscle = muscle2;
			}
			muscle2.props.mapPosition = muscle2.props.group == Muscle.Group.Hips;
		}
		swooshes = new SwooshIfFast[2];
		footSoundSources = new FootstepController[2];
		muscles = pm.muscles;
		foreach (Muscle muscle3 in muscles)
		{
			if (muscle3.name == "head" || muscle3.name == "head 1")
			{
				head = muscle3.target;
				headHittable = muscle3.joint.GetComponent<Hittable>();
			}
			if (muscle3.name == "chest" || muscle3.name == "spine_02")
			{
				chest = muscle3.target;
			}
			if (muscle3.name == "hand.L" || muscle3.name == "hand_l")
			{
				setupHand(muscle3, right: false);
			}
			if (muscle3.name == "hand.R" || muscle3.name == "hand_r")
			{
				setupHand(muscle3, right: true);
			}
			if (muscle3.name == "foot.L" || muscle3.name == "foot_l")
			{
				setupFoot(muscle3, right: false);
			}
			if (muscle3.name == "foot.R" || muscle3.name == "foot_r")
			{
				setupFoot(muscle3, right: true);
			}
		}
		if (head == null)
		{
			UnityEngine.Debug.LogError("Null head: " + character.data.name);
		}
		if (chest == null)
		{
			UnityEngine.Debug.LogError("Null chest: " + character.data.name);
		}
		if (wholebodyMeshRenderer == null)
		{
			array = GetComponentsInChildren<SkinnedMeshRenderer>();
			foreach (SkinnedMeshRenderer skinnedMeshRenderer in array)
			{
				if (skinnedMeshRenderer.material.name.Contains("SSS"))
				{
					wholebodyMeshRenderer = skinnedMeshRenderer;
					break;
				}
			}
		}
		hideWholeBody = !wholebodyMeshRenderer.enabled;
		defaultSkinMaterial = wholebodyMeshRenderer.material;
		if (defaultSkinMaterial == null)
		{
			UnityEngine.Debug.LogError(character.data.name + " has no default skin material");
		}
		skinMeshes = ik.GetComponentsInChildren<SkinMesh>();
		Transform[] componentsInChildren2 = pm.targetRoot.GetComponentsInChildren<Transform>();
		Dictionary<string, Transform> dictionary = new Dictionary<string, Transform>();
		Transform[] array4 = componentsInChildren2;
		foreach (Transform transform in array4)
		{
			if (!dictionary.ContainsKey(transform.name))
			{
				dictionary.Add(transform.name, transform);
			}
		}
		List<PressurePoint> list2 = new List<PressurePoint>();
		PressurePointData[] array5 = character.pressurePoints;
		foreach (PressurePointData pressurePointData in array5)
		{
			if (pressurePointData.maleOnly && character.data.female)
			{
				continue;
			}
			Transform transform2 = null;
			if (dictionary.ContainsKey(pressurePointData.boneName))
			{
				transform2 = dictionary[pressurePointData.boneName];
			}
			else if (dictionary.ContainsKey(pressurePointData.altBoneName))
			{
				transform2 = dictionary[pressurePointData.altBoneName];
			}
			if (transform2 == null)
			{
				UnityEngine.Debug.LogError("Couldnt find: " + pressurePointData.name + " (" + pressurePointData.boneName + "/" + pressurePointData.altBoneName + ")");
				continue;
			}
			PressurePoint pressurePoint = UnityEngine.Object.Instantiate(Settings.instance.pressurePointPrefab, transform2);
			pressurePoint.transform.localPosition = pressurePointData.position;
			float num = float.PositiveInfinity;
			Vector3 position = Vector3.zero;
			muscles = pm.muscles;
			for (int j = 0; j < muscles.Length; j++)
			{
				Vector3 vector = muscles[j].colliders[0].ClosestPoint(pressurePoint.transform.position);
				float magnitude = (pressurePoint.transform.position - vector).magnitude;
				if (magnitude < num)
				{
					num = magnitude;
					position = vector;
				}
			}
			pressurePoint.transform.position = position;
			pressurePoint.setup(pressurePointData);
			list2.Add(pressurePoint);
		}
		pressurePoints = list2.ToArray();
		swooshes[0].right = false;
		swooshes[1].right = true;
		swooshes[0].rb = this;
		swooshes[1].rb = this;
		Invoke("show", 0.1f);
		array3 = bodyParts;
		foreach (BodyPartData bodyPartData3 in array3)
		{
			LocalisationController.getText("Body Part", bodyPartData3.friendlyName);
		}
	}

	public bool hasAlt()
	{
		return altCostumes.Length != 0;
	}

	public bool notTouching(bool left)
	{
		int num = ((!left) ? 1 : 0);
		if (grabbed[num])
		{
			return false;
		}
		if (armCollisions[num] == 0)
		{
			return armTouchTime[num] < Time.time - 0.2f;
		}
		return false;
	}

	public int altCostume()
	{
		if (GameController.instance == null)
		{
			return 0;
		}
		if (GameController.instance.gameMode == GameController.GameMode.Chambers)
		{
			return 0;
		}
		if (GameController.instance.player == null)
		{
			if (character == null)
			{
				return 0;
			}
			if (GameController.instance.players.Count > 0 && character.team == 1 && GameController.instance.players[0].data.id == character.data.id)
			{
				return 1;
			}
			return 0;
		}
		int num = 0;
		if (character == null || character.isPlayer() || GameController.instance.standButtons.type == StandButtonsController.Type.Final)
		{
			num = GameController.instance.costume;
		}
		else
		{
			if (character.data.id == GameController.instance.player.data.id)
			{
				num = GameController.instance.costume + 1;
			}
			if (GameController.instance.specialMode.name == "Ninja Challenge" && character.data.isNinja())
			{
				num++;
			}
		}
		return num % 2;
	}

	public void setLastHit(LastHit newlastHit, Vector3 pos)
	{
		if (lastHit != newlastHit)
		{
			lastHit = newlastHit;
		}
	}

	public void switchCostume()
	{
		AltCostume[] array = altCostumes;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].refresh();
		}
	}

	public float say(AudioClip clip, bool halfSpacial, string sayText)
	{
		return face.say(clip, halfSpacial, sayText, onlyInterupt: false);
	}

	public float say(VoiceData voice)
	{
		if (!OptionData.getBool("Voices"))
		{
			return 0f;
		}
		if (voice == null)
		{
			return 0f;
		}
		if (GameController.instance.player == null)
		{
			return 0f;
		}
		if (character.isPlayer())
		{
			return 0f;
		}
		if (!character.isPlayer())
		{
			character.aiControl.headLookPerc = UnityEngine.Random.value / 2f + 0.5f;
		}
		voice.useCount++;
		voice.nextUseTime = Time.time + 300f;
		return face.say(voice);
	}

	public float staminaPerc(bool inverse = false)
	{
		float num = 1f;
		if (!isDown(allTheWay: false))
		{
			num = Mathf.Clamp01(standUpPerc / standUpPercMax);
		}
		if (inverse)
		{
			num = 1f - num;
		}
		return num;
	}

	public void hitGroundSound()
	{
		if (!hasHitGround && !(downTimer < 0.25f))
		{
			HitSoundsController.playSound(audioSource, Hittable.HitType.FallToGround, 1f);
			hasHitGround = true;
		}
	}

	private void show()
	{
		SkinnedMeshRenderer[] array = meshes;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].enabled = true;
		}
		downSettings(up: true);
		pm.mode = PuppetMaster.Mode.Active;
	}

	private void setupFoot(Muscle foot, bool right)
	{
		footSoundSources[right ? 1 : 0] = UnityEngine.Object.Instantiate(GameController.instance.footstepPrefab, foot.target);
		footSoundSources[right ? 1 : 0].mover = character.mover;
		if (character.kickController.legs.Length == 0)
		{
			character.kickController.legs = new KickLegController[2];
		}
		character.kickController.legs[right ? 1 : 0].foot = foot;
		foot.DisableColliders();
	}

	private void setupHand(Muscle hand, bool right)
	{
		GameObject gameObject = UnityEngine.Object.Instantiate(character.handForwardPrefab);
		gameObject.transform.parent = hand.joint.transform;
		gameObject.transform.localPosition = Vector3.zero;
		gameObject.transform.localRotation = Quaternion.Euler(right ? r_forward : l_forward);
		if (right)
		{
			rightHandMeter = UnityEngine.Object.Instantiate(character.rightHandMeterPrefab, hand.target.transform);
			rightHandMeter.setup(this, isHealth: false);
			if (character.data.weakness.name == "Left Armed")
			{
				rightHandMeter.transform.SetParent(character.trackers.transforms[2], worldPositionStays: true);
				rightHandMeter.reposition();
			}
		}
		else
		{
			leftHandMeter = UnityEngine.Object.Instantiate(character.leftHandMeterPrefab, hand.target.transform);
			leftHandMeter.setup(this, isHealth: true);
			if (character.data.weakness.name == "Right Armed")
			{
				leftHandMeter.transform.SetParent(character.trackers.transforms[1], worldPositionStays: true);
				leftHandMeter.reposition();
			}
		}
		swooshes[right ? 1 : 0] = UnityEngine.Object.Instantiate(GameController.instance.swooshPrefab, hand.transform);
		swooshes[right ? 1 : 0].transform.localPosition = Vector3.zero;
		Hittable component = hand.joint.GetComponent<Hittable>();
		hand.joint.gameObject.AddComponent<ScaleColliderWithSqueeze>().hittable = component;
		component.forwardAngle = gameObject.transform;
		component.isHand = true;
	}

	public void land(float ySpeed)
	{
		if (ySpeed < -4f)
		{
			ySpeed = -4f;
		}
		landSpeed = ySpeed;
	}

	public void downSettings(bool up)
	{
		SwooshIfFast[] array = swooshes;
		foreach (SwooshIfFast swooshIfFast in array)
		{
			if (swooshIfFast != null)
			{
				swooshIfFast.nextPlay = Time.time + 1f;
				swooshIfFast.enabled = up;
			}
		}
	}

	public Transform getMuscleTransformByName(string muscleName)
	{
		Muscle[] muscles = pm.muscles;
		foreach (Muscle muscle in muscles)
		{
			if (muscle.name == muscleName)
			{
				return muscle.target;
			}
		}
		return null;
	}

	public Muscle getMuscleByName(string muscleName)
	{
		Muscle[] muscles = pm.muscles;
		foreach (Muscle muscle in muscles)
		{
			if (muscle.name == muscleName)
			{
				return muscle;
			}
		}
		return null;
	}

	private void OnDestroy()
	{
		if (vrHat != null)
		{
			UnityEngine.Object.Destroy(vrHat.gameObject);
		}
	}

	public void setupLayers(bool povView)
	{
		if (characterHat != null)
		{
			if (character != null && character.playerController != null)
			{
				vrHat.transform.SetParent(VRMainRigController.instance.headTrack.transform);
				vrHat.transform.localScale = Vector3.one;
			}
			vrHat.shadowCastingMode = ShadowCastingMode.Off;
			vrHat.gameObject.SetActive(povView && OptionData.getBool("VR Hats"));
			GlassesController component = vrHat.GetComponent<GlassesController>();
			if (component != null)
			{
				component.show(povView && OptionData.getBool("VR Hats"));
			}
			AltCostume component2 = vrHat.GetComponent<AltCostume>();
			if (component2 != null)
			{
				component2.rb = this;
			}
			characterHat.shadowCastingMode = ((!povView) ? ShadowCastingMode.On : ShadowCastingMode.ShadowsOnly);
			component = characterHat.GetComponent<GlassesController>();
			if (component != null)
			{
				component.show(!povView);
			}
		}
		SkinnedMeshRenderer[] componentsInChildren = ik.gameObject.GetComponentsInChildren<SkinnedMeshRenderer>();
		foreach (SkinnedMeshRenderer skinnedMeshRenderer in componentsInChildren)
		{
			if (skinnedMeshRenderer.gameObject.layer == 15 && !povView)
			{
				skinnedMeshRenderer.gameObject.layer = 18;
				skinnedMeshRenderer.shadowCastingMode = ShadowCastingMode.On;
			}
			else if (skinnedMeshRenderer.gameObject.layer == 18 && povView)
			{
				skinnedMeshRenderer.gameObject.layer = 15;
				skinnedMeshRenderer.shadowCastingMode = ShadowCastingMode.ShadowsOnly;
			}
		}
		SkinMesh[] array = skinMeshes;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].Set(povView);
		}
	}

	private void updateStance()
	{
		if (character == null || character.trackers == null)
		{
			return;
		}
		if (landSpeed < 0f)
		{
			landOffset += landSpeed;
			landSpeed = Mathf.MoveTowards(landSpeed, 0f, Time.deltaTime * 15f);
		}
		else if (landOffset < 0f)
		{
			landOffset += landSpeed;
			landSpeed = Mathf.MoveTowards(landSpeed, 1f, Time.deltaTime * 1f);
			if (landOffset > 0f)
			{
				landOffset = 0f;
				landSpeed = 0f;
			}
		}
		character.aiControl.landOffset = landOffset / 100f;
		if (character.aiControl.landOffset < -0.5f)
		{
			character.aiControl.landOffset = -0.5f;
		}
		float num = 0f;
		Transform transform = character.trackers.transforms[0];
		Transform transform2 = character.trackers.transforms[1];
		Transform transform3 = character.trackers.transforms[2];
		if (!character.isPlayer())
		{
			num = ((GameController.instance.fightState != GameController.FightState.During && GameController.instance.fightState != GameController.FightState.Ready && !(GameController.instance.player == null)) ? 0f : character.aiControl.currentStance().stanceAngle);
		}
		else
		{
			float magnitude = GameController.flatVector(transform.position - transform2.position).magnitude;
			Vector3 forward = ((!(GameController.flatVector(transform.position - transform3.position).magnitude < magnitude)) ? GameController.flatVector(transform3.localPosition - transform2.localPosition) : GameController.flatVector(transform2.localPosition - transform3.localPosition));
			num = Quaternion.LookRotation(forward).eulerAngles.y - Quaternion.LookRotation(GameController.flatVector(transform.forward)).eulerAngles.y + character.transform.rotation.eulerAngles.y;
			if (num < -180f)
			{
				num += 360f;
			}
			if (num > 180f)
			{
				num -= 360f;
			}
			num = ((!(num > 0f)) ? (Mathf.Round(Mathf.Clamp(num, -90f, 90f)) + 90f) : (Mathf.Round(Mathf.Clamp(num, -90f, 90f)) - 90f));
		}
		float num2 = Mathf.Clamp01(Mathf.Abs(num) / 90f);
		float num3 = Mathf.Clamp01((transform.transform.localPosition.y - 1.4f) / 0.30000007f);
		num3 = 1f - num3;
		float target = Mathf.Lerp(0.2f, 0.4f, num3 * num2);
		ik.solver.locomotion.footDistance = Mathf.MoveTowards(ik.solver.locomotion.footDistance, target, Time.deltaTime);
		stanceAngle = num;
		ik.solver.spine.rootHeadingOffset = (Settings.instance.stanceAngles ? Mathf.MoveTowards(ik.solver.spine.rootHeadingOffset, num, Time.deltaTime * 45f) : 0f);
	}

	public void setIK(HandPositions hands, Transform[] trackers, bool forPlinth = false)
	{
		ik = GetComponentInChildren<VRIK>();
		if (ik == null)
		{
			UnityEngine.Debug.LogError("No VRIK: " + base.name);
			return;
		}
		ik.solver.spine.headTarget = trackers[0];
		ik.solver.spine.rootHeadingOffset = 45f;
		ik.solver.leftArm.target = trackers[1];
		ik.solver.rightArm.target = trackers[2];
		if (trackers.Length > 3)
		{
			ik.solver.leftLeg.target = trackers[3];
			ik.solver.rightLeg.target = trackers[4];
		}
		ik.solver.spine.minHeadHeight = 0f;
		altCostumes = GetComponentsInChildren<AltCostume>();
		if (forPlinth)
		{
			this.forPlinth = forPlinth;
			ik.solver.spine.minHeadHeight = 0f;
			ik.solver.locomotion.weight = 0f;
			pm = GetComponentInChildren<PuppetMaster>();
			pm.mode = PuppetMaster.Mode.Kinematic;
			this.hands = hands;
			face = GetComponentInChildren<FaceController>();
			face.Setup();
			skinMeshes = ik.GetComponentsInChildren<SkinMesh>();
			setupLayers(povView: false);
		}
		else
		{
			setup(hands);
			character.playerController.scaledTrackers[1].GetComponentInChildren<PuppetTrackerHandOffset>().target = hands.leftHand;
			character.playerController.scaledTrackers[2].GetComponentInChildren<PuppetTrackerHandOffset>().target = hands.rightHand;
			hands.l_offset = character.playerController.scaledTrackers[1].GetComponentInChildren<PuppetTrackerHandOffset>();
			hands.r_offset = character.playerController.scaledTrackers[2].GetComponentInChildren<PuppetTrackerHandOffset>();
			ik.solver.locomotion.onLeftFootstep.AddListener(delegate
			{
				footSoundSources[0].footstepSound(character.isPlayer());
			});
			ik.solver.locomotion.onRightFootstep.AddListener(delegate
			{
				footSoundSources[1].footstepSound(character.isPlayer());
			});
			pm.pinPow = 0f;
		}
		fall = base.gameObject.AddComponent<FallAndGetUp>();
		fall.Setup(character, pm, ik);
	}

	public void buzz(float perc, BodyPartData.Source source)
	{
		perc = Mathf.Clamp01(perc);
		if (character.isPlayer() && OptionData.getBool("Haptic Feedback"))
		{
			Controller.UPvr_VibrateNeo2Controller(Mathf.Clamp01(perc * 2f), 100 + Mathf.RoundToInt(perc * 400f), (source != BodyPartData.Source.LeftHand) ? 1 : 0);
		}
	}

	public void setSkin(Material skinMaterial)
	{
		SkinMesh[] array = skinMeshes;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetMaterial(skinMaterial);
		}
	}

	public void Hit(Vector3 hitDir, float hitPerc, float damagePerc, GameCharacter hittingCharacter, string customDamage)
	{
		Hit(hitDir, generalHitPoint, hittingCharacter, hitPerc, damagePerc, generalHitPoint.transform.position, Hittable.HandHitType.General, skipPressurePoints: true, customDamage);
	}

	public void Hit(Vector3 hitDir, Hittable beingHit, GameCharacter hittingCharacter, float hitPerc, float damagePerc, Vector3 hitLocation, Hittable.HandHitType handHit, bool skipPressurePoints, string customDamage)
	{
		if (!character.isPlayer())
		{
			character.aiControl.onHit();
		}
		if (damagePerc > 0.1f && (handHit == Hittable.HandHitType.Punch || handHit == Hittable.HandHitType.Palm) && stuckProjectiles.Count > 0)
		{
			stuckProjectiles[0].unstick();
			stuckProjectiles.RemoveAt(0);
		}
		float num = 1f;
		if (hittingCharacter != null && hittingCharacter.hasEffect(CharacterEffect.Effect.SpeedHands))
		{
			num *= 3f;
			hitPerc *= 0.1f;
			damagePerc *= 0.3f;
		}
		if (hittingCharacter != null && hittingCharacter.hasEffect(CharacterEffect.Effect.Weakness))
		{
			num *= 0.85f;
		}
		face.closeTime += damagePerc;
		if (beingHit != null && beingHit.bodyPart != null && !beingHit.rb.isDown(allTheWay: false))
		{
			if (!skipPressurePoints)
			{
				PressurePoint pressurePoint = null;
				float num2 = 0.1f;
				int num3 = 0;
				PressurePoint[] array = pressurePoints;
				foreach (PressurePoint pressurePoint2 in array)
				{
					if (pressurePoint2.allowTime() && (PracticeMoveController.instance == null || !PracticeMoveController.isActive(1) || PracticeMoveController.instance.onPressurePoint == num3 || PracticeMoveController.instance.onPressurePoint >= pressurePoints.Length))
					{
						Vector3 vector = pressurePoint2.transform.position - hitLocation;
						if (vector.magnitude <= num2 && vector.magnitude < pressurePoint2.data.radius)
						{
							pressurePoint = pressurePoint2;
							num2 = vector.magnitude;
						}
					}
					num3++;
				}
				if (pressurePoint != null)
				{
					float num4 = 1f;
					if (character.hasEffect(CharacterEffect.Effect.ViperLeavesCave))
					{
						handHit = pressurePoint.data.hitType[0];
						num4 = 2f;
					}
					if ((pressurePoint.data.name == "Left Eye" || pressurePoint.data.name == "Right Eye") && vrHat != null && characterHat != null)
					{
						GlassesController[] array2 = new GlassesController[2]
						{
							vrHat.GetComponent<GlassesController>(),
							characterHat.GetComponent<GlassesController>()
						};
						if (array2[1] != null)
						{
							if (pressurePoint.data.name == "Left Eye")
							{
								GlassesController[] array3 = array2;
								foreach (GlassesController glassesController in array3)
								{
									if ((bool)glassesController)
									{
										glassesController.smash(left: true);
									}
								}
							}
							else
							{
								GlassesController[] array3 = array2;
								foreach (GlassesController glassesController2 in array3)
								{
									if ((bool)glassesController2)
									{
										glassesController2.smash(left: false);
									}
								}
							}
						}
					}
					wasPressurePoint = "";
					overrideSound = null;
					if (pressurePoint.hit(handHit, PracticeMoveController.isActive(1)))
					{
						if (face == null)
						{
							UnityEngine.Debug.LogError("Face is null " + base.name);
						}
						face.hurt(character.data.female);
						num4 *= character.data.perkMod("Thick Skin", hitLocation);
						if (pressurePoint.data.name == "Sternum" || pressurePoint.data.name == "Solar Plexus")
						{
							num4 *= hittingCharacter.data.perkMod("Centre Line", hitLocation);
						}
						if (pressurePoint.data.name.Contains("Eye"))
						{
							num4 *= hittingCharacter.data.perkMod("Blinder", hitLocation);
						}
						if (pressurePoint.data.name.Contains("Rib"))
						{
							num4 *= hittingCharacter.data.perkMod("Rib Tickler", hitLocation);
						}
						num4 *= hittingCharacter.data.perkMod("Pressure Fighter", hitLocation);
						num4 *= character.data.perkMod("Thin Skin", hitLocation);
						if (pressurePoint.data.name == "Sternum")
						{
							num4 *= character.data.perkMod("Weak Sternum", hitLocation);
						}
						if (pressurePoint.data.name == "Solar Plexus")
						{
							num4 *= character.data.perkMod("Weak Solar Plexus", hitLocation);
						}
						if (pressurePoint.data.name == "Throat")
						{
							num4 *= character.data.perkMod("Weak Throat", hitLocation);
						}
						if (pressurePoint.data.name.Contains("Eye"))
						{
							num4 *= character.data.perkMod("Weak Eyes", hitLocation);
						}
						if (pressurePoint.data.name.Contains("Rib"))
						{
							num4 *= character.data.perkMod("Weak Ribs", hitLocation);
						}
						if (pressurePoint.data.name.Contains("Knee"))
						{
							num4 *= character.data.perkMod("Weak Knees", hitLocation);
						}
						character.addEffect(hitLocation, pressurePoint.data.addEffect, pressurePoint.data.effectTime * num4, preventSpecialRecharge: false, isTest: false);
						wasPressurePoint = pressurePoint.data.summary();
						if (pressurePoint.data.soundOverrides.Length != 0)
						{
							overrideSound = pressurePoint.data.soundOverrides[UnityEngine.Random.Range(0, pressurePoint.data.soundOverrides.Length)];
						}
						if (GameController.instance.fightState == GameController.FightState.During)
						{
							pressurePoint.data.hitInRound = true;
							int num5 = 0;
							PressurePointData[] array4 = GameData.instance.pressurePoints;
							for (int i = 0; i < array4.Length; i++)
							{
								if (array4[i].hitInRound)
								{
									num5++;
								}
							}
							if (num5 >= 10)
							{
								AchievementsController.achievement("Pressure Fighter");
							}
						}
						if (handHit != Hittable.HandHitType.Foot)
						{
							num *= pressurePoint.data.slideMod;
						}
						hitPerc *= pressurePoint.data.damageMod * num4;
					}
				}
			}
			if (beingHit.bodyPart.isHead)
			{
				if (!character.isPlayer())
				{
					character.headRecoil.hit(hitDir, damagePerc);
				}
				else
				{
					VRMainRigController.instance.faceHit.hit(hitPerc, damagePerc, hitLocation, beingHit != null && beingHit.bodyPart != null && beingHit.bodyPart.isHead);
				}
				if (handHit == Hittable.HandHitType.Punch)
				{
					num *= 0.9f;
				}
				if (handHit == Hittable.HandHitType.FingerJab)
				{
					num *= 0.75f;
				}
			}
			else if (beingHit.bodyPart.isChest)
			{
				if (handHit == Hittable.HandHitType.Punch)
				{
					num *= 0.9f;
				}
				if (handHit == Hittable.HandHitType.FingerJab)
				{
					num *= 0.5f;
				}
			}
		}
		if (handHit == Hittable.HandHitType.Foot)
		{
			num *= 2f;
		}
		if (staminaPerc() > 0f)
		{
			num /= Mathf.Clamp01(staminaPerc() / 0.75f);
		}
		slide += hitDir.normalized * hitPerc * num;
		if (hittingCharacter != null && beingHit.bodyPart.isHead && !hittingCharacter.hasEffect(CharacterEffect.Effect.SpeedHands) && !hittingCharacter.hasEffect(CharacterEffect.Effect.SpeedKick))
		{
			float num6 = Mathf.Clamp01(character.mover.velocity.magnitude / 2.5f * num * num);
			if (slide.magnitude < num6)
			{
				slide = slide.normalized * num6;
			}
		}
		if (character.hasEffect(CharacterEffect.Effect.HighImpact))
		{
			slide += hitDir * (slide.magnitude / (Settings.instance.slideClamp / 1.5f));
		}
		slide = Vector3.ClampMagnitude(slide, Settings.instance.slideClamp);
		face.blinking = true;
		float num7 = ((GameController.instance.specialMode.name == "Stamina") ? 0.2f : 1f);
		float num8 = damagePerc * GameController.instance.healthDamage * num7;
		if (num8 > 0f || wasPressurePoint != "")
		{
			character.aiControl.impatientTimer = 10f;
			if (character.targetEnemy != null)
			{
				character.targetEnemy.aiControl.impatientTimer = 10f;
			}
			if (OptionData.getBool("Show Hit Percentages") || PracticeMoveController.isActive(2))
			{
				Color color = ((character.team == 0) ? Color.red : Color.green);
				if (customDamage != "")
				{
					CanvasController.addText(localise: false, LocalisationController.getText("Body Part", customDamage) + ">" + LocalisationController.getText("Body Part", beingHit.bodyPart.friendlyName) + "\n" + Mathf.Round(num8 * 100f) + "%", hitLocation, color, 1f);
				}
				else
				{
					string text = handHit.ToString();
					if (handHit == Hittable.HandHitType.FingerJab)
					{
						text = "Finger Jab";
					}
					if (handHit == Hittable.HandHitType.Palm)
					{
						text = "Palm Strike";
					}
					if (handHit == Hittable.HandHitType.Foot)
					{
						text = "Kick";
					}
					if (handHit == Hittable.HandHitType.General)
					{
						text = "Forearm";
					}
					if (wasPressurePoint != "")
					{
						CanvasController.addText(localise: false, LocalisationController.getText("General", text) + ">" + wasPressurePoint + "\n" + Mathf.Round(num8 * 100f) + "%", hitLocation, Color.cyan, 1f);
					}
					else
					{
						CanvasController.addText(localise: false, LocalisationController.getText("General", text) + ">" + LocalisationController.getText("Body Part", beingHit.bodyPart.friendlyName) + "\n" + Mathf.Round(num8 * 100f) + "%", hitLocation, color, 1f);
					}
				}
			}
		}
		standUpPerc -= num8 * (float)((!Settings.instance.quickKnockout) ? 1 : 15);
		if (character.hasEffect(CharacterEffect.Effect.Stunned))
		{
			character.getEffect(CharacterEffect.Effect.Stunned).amount -= num8 * 5f;
		}
		if (staminaPerc() < 0.5f && character.isPlayer() && standUpPerc > 0.25f)
		{
			GameController.instance.gameData.ShowVRTip(3);
		}
		if (!PracticeMoveController.isActive(-1))
		{
			standUpPercMax -= num8 / 2f;
		}
		if (character.isPlayer())
		{
			AchievementsController.instance.perfect = false;
		}
		LastHit newlastHit = LastHit.None;
		if (hittingCharacter != null && beingHit != null && beingHit.rb.character != null && (wasPressurePoint != "" || num8 > 0f) && (hittingCharacter.isPlayer() || character.isPlayer()) && (GameController.instance.fightState == GameController.FightState.During || PracticeMoveController.isActive(2)) && !isDown(allTheWay: true))
		{
			hittingCharacter.addToCombo(num8, hitLocation);
			if (GameController.instance.fightState == GameController.FightState.During)
			{
				string text2 = ((handHit == Hittable.HandHitType.Foot) ? "Kicks" : "Hits");
				string text3 = (hittingCharacter.isPlayer() ? "Landed" : "Received");
				Saving.instance.incrementStat(text2 + " " + text3, onlyInFight: true);
				if (hittingCharacter.isPlayer())
				{
					if (handHit == Hittable.HandHitType.Foot && beingHit.bodyPart.isHead)
					{
						Saving.instance.incrementStat("Head Kicks Landed", onlyInFight: true);
					}
					if (hittingCharacter.vrCharacterController.heightOffGround > 0.3f)
					{
						switch (handHit)
						{
						case Hittable.HandHitType.Foot:
							Saving.instance.incrementStat("Flying Kicks Landed", onlyInFight: true);
							newlastHit = LastHit.FlyingKick;
							break;
						case Hittable.HandHitType.Punch:
							Saving.instance.incrementStat("Flying Punches Landed", onlyInFight: true);
							newlastHit = LastHit.FlyingPunch;
							break;
						}
					}
					if (wasPressurePoint != "")
					{
						Saving.instance.incrementStat("Pressure Points Hit", onlyInFight: true);
						GameController.instance.pressurePointCount++;
						Saving.instance.maxStat("Pressure Points in Round", GameController.instance.pressurePointCount, onlyInFight: true, isInt: true);
					}
				}
			}
		}
		hitRecovery += damagePerc;
		if (damagePerc > 0f)
		{
			setLastHit(newlastHit, hitLocation);
		}
		if (standUpPerc <= 0f && !PracticeMoveController.isActive(-1) && num8 > 0f)
		{
			if ((bool)beingHit && Settings.instance.knockdownMultiply > 0f)
			{
				beingHit.bodyPart.rb.AddForce(hitDir * Settings.instance.knockdownMultiply * hitPerc, ForceMode.Impulse);
			}
			fall.Fall();
			downSettings(up: false);
		}
	}

	public bool dazed()
	{
		if (!fall.willRecover() || !(standUpPerc < 0f) || !fall.falling)
		{
			return character.hasEffect(CharacterEffect.Effect.Stunned);
		}
		return true;
	}

	public bool isDown(bool allTheWay)
	{
		if (fall == null)
		{
			return false;
		}
		if (allTheWay)
		{
			return fall.fallen;
		}
		if (character != null && character.hasEffect(CharacterEffect.Effect.Stunned))
		{
			return true;
		}
		if (fall.falling)
		{
			return true;
		}
		return false;
	}

	public Vector3 diffToTarget()
	{
		if (character.targetEnemy == null)
		{
			return Vector3.zero;
		}
		return character.standPosition - character.targetEnemy.standPosition;
	}

	private void Update()
	{
		if (pm == null)
		{
			return;
		}
		if (spine != null && spine.rigidbody != null)
		{
			float num = 500f;
			spine.rigidbody.angularDrag = Mathf.MoveTowards(spine.rigidbody.angularDrag, (isDown(allTheWay: false) || !fall.gotUp) ? 0f : num, Time.deltaTime * num * 10f);
			spine.rigidbody.drag = spine.rigidbody.angularDrag;
			hips.rigidbody.angularDrag = spine.rigidbody.angularDrag;
			hips.rigidbody.drag = spine.rigidbody.angularDrag;
		}
		if (isDown(allTheWay: true))
		{
			downTimer += Time.deltaTime;
			if (character.lives <= 0)
			{
				return;
			}
			if ((diffToTarget().magnitude > 2.5f || (character.isPlayer() && downTimer > 4f)) && GameController.instance.canGetUp)
			{
				standUpPercMax = Mathf.MoveTowards(standUpPercMax, 1f, Time.deltaTime);
				standUpPerc += Time.deltaTime * character.data.perkMod("Fighting Fit", character.name) * character.data.perkMod("Unfit", character.name);
			}
			else if (GameController.instance.canGetUp && character.targetEnemy != null && character.targetEnemy.isPlayer() && downTimer > 5f)
			{
				GameController.instance.winLose.show(LocalisationController.getText("Win/Lose", "Move Away"), head, halfWay: true, fadeOut: true, -1);
			}
			if (standUpPerc > 0f)
			{
				hitsDisabled = true;
			}
			if (standUpPerc >= 1f)
			{
				downTimer = 0f;
				hitsDisabled = false;
				downSettings(up: true);
				character.isPlayer();
				armCollisions[0] = 0;
				armCollisions[1] = 0;
				standUpPerc = 1f;
				fall.GetUp();
				hasHitGround = false;
			}
			slide = Vector3.zero;
		}
		else if (standUpPerc < 1f && !(hitRecovery > 0f))
		{
			float num2 = (PracticeMoveController.isActive(-1) ? 1f : GameController.instance.healthRecharge);
			if (character.hasEffect(CharacterEffect.Effect.Sickness))
			{
				num2 /= 3f;
				if (standUpPercMax > 0.01f)
				{
					standUpPercMax -= Time.deltaTime / 20f * standUpPercMax;
				}
				if (character.isPlayer())
				{
					AchievementsController.instance.perfect = false;
				}
			}
			if (character.hasEffect(CharacterEffect.Effect.Drunk))
			{
				num2 *= 2f;
				standUpPercMax += Time.deltaTime / 30f;
				if (standUpPercMax > 1f)
				{
					standUpPercMax = 1f;
				}
			}
			if (character.hasEffect(CharacterEffect.Effect.Winded))
			{
				num2 /= 2f;
			}
			standUpPerc += Time.deltaTime * num2;
			if (standUpPerc > standUpPercMax)
			{
				standUpPerc = standUpPercMax;
			}
		}
		if (hitRecovery > 0f)
		{
			hitRecovery -= Time.deltaTime;
			if (hitRecovery < 0f)
			{
				hitRecovery = 0f;
			}
		}
		if (!forPlinth)
		{
			ik.solver.locomotion.weight = Mathf.MoveTowards(ik.solver.locomotion.weight, 1f, Time.deltaTime);
		}
		updateStance();
		rightHand?.updateGrab();
		leftHand?.updateGrab();
		if (!PracticeMoveController.isActive(1))
		{
			bool flag = showPressurePoints > Time.time;
			for (int i = 0; i < pressurePoints.Length; i++)
			{
				PressurePoint pressurePoint = pressurePoints[i];
				pressurePoint.display.SetActive(flag && pressurePoint.allowTime());
			}
		}
		slide.y = 0f;
		if (standUpPercMax > maxHealth)
		{
			standUpPercMax = maxHealth;
		}
		if (character != null && character.effects.Count == 0)
		{
			if (diffToTarget().magnitude > 1.25f)
			{
				if (armCollisions[0] > 0)
				{
					armCollisions[0] = 0;
				}
				if (armCollisions[1] > 0)
				{
					armCollisions[1] = 0;
				}
			}
			if (!(character.targetEnemy != null) || !character.targetEnemy.rigidBodies.isDown(allTheWay: true))
			{
				float num3 = 0f;
				if (character.targetEnemy != null)
				{
					num3 = (character.standPosition - character.targetEnemy.standPosition).magnitude;
				}
				if (Settings.instance.quickSpecials)
				{
					specialPerc = Mathf.MoveTowards(specialPerc, 1f, Time.deltaTime);
				}
				else if (num3 != 0f && specialChargeSpeed > 0f)
				{
					specialPerc = Mathf.MoveTowards(specialPerc, 1f, Time.deltaTime * specialChargeSpeed / Settings.instance.specialChargeTime);
					specialChargeSpeed = Mathf.MoveTowards(specialChargeSpeed, 0f, Time.deltaTime * 3f);
				}
			}
		}
		specialPerc = Mathf.Clamp01(specialPerc);
		if (Settings.instance != null)
		{
			if (isDown(allTheWay: false))
			{
				slide = Vector3.MoveTowards(slide, Vector3.zero, Time.deltaTime * Settings.instance.recoverySpeed * 2f);
				specialSlide = Vector3.MoveTowards(specialSlide, Vector3.zero, Time.deltaTime * 50f);
			}
			else
			{
				float num4 = 1f;
				if (character != null)
				{
					if (character.hasEffect(CharacterEffect.Effect.Strength))
					{
						num4 *= 2f;
					}
					num4 *= character.data.perkMod("Massive", character.data.name);
				}
				slide = Vector3.MoveTowards(slide, Vector3.zero, Time.deltaTime * Settings.instance.recoverySpeed * num4);
				specialSlide = Vector3.MoveTowards(specialSlide, Vector3.zero, Time.deltaTime * 15f);
			}
		}
		if (character != null)
		{
			if (float.IsNaN(slide.x))
			{
				slide = Vector3.zero;
			}
			character.mover.slide = (slide + specialSlide) * Settings.instance.slideMult;
		}
	}
}
[Serializable]
public class SaveGame
{
	public int difficultyLevel;

	public string specialMode;

	public int lowestDifficulty = -1;

	public int character;

	public int costume;

	public int[] characterOrder;

	public int[] characterStars;

	public int[] characterFights;

	public int[] usedCharacters;

	public GameStats stats = new GameStats();

	public void clear()
	{
		difficultyLevel = 0;
		lowestDifficulty = -1;
		character = 0;
		costume = 0;
		characterOrder = new int[0];
		characterStars = new int[0];
		characterFights = new int[0];
		usedCharacters = new int[0];
	}

	public bool exists()
	{
		if (characterOrder.Length != 0)
		{
			return characterOrder.Length == characterStars.Length;
		}
		return false;
	}

	public string summary()
	{
		if (!exists())
		{
			return "";
		}
		string text = LocalisationController.getText("Game Mode", specialMode) + " - ";
		text = text + LocalisationController.getText("Character: " + GameData.instance.characters[character].name, GameData.instance.characters[character].name) + ", ";
		text += LocalisationController.getText("Difficulty Level", Settings.instance.difficultyLevels[difficultyLevel].name);
		if (stats.getStat("Stars").value > 0f)
		{
			text = text + ", " + stats.getStat("Stars").display();
		}
		return text;
	}
}
[Serializable]
public class SavedCompletedGame
{
	public string name;

	public int characterId;

	public string specialMode;

	public int difficultyLevel;

	public bool singleCharacter;

	public DateTime lastSaved;

	public void SetToCurrent()
	{
		name = GameController.instance.selectedCharacter().name;
		characterId = GameController.instance.characterID;
		specialMode = GameController.instance.specialMode.name;
		difficultyLevel = Saving.instance.saveGameData.lowestDifficulty;
		singleCharacter = Saving.instance.saveGameData.usedCharacters.Length <= 1;
		lastSaved = DateTime.Now;
	}

	public bool matchesCurrent()
	{
		if (Saving.instance.saveGameData.lowestDifficulty != difficultyLevel)
		{
			return false;
		}
		if (characterId != GameController.instance.characterID)
		{
			return false;
		}
		if (specialMode != GameController.instance.specialMode.name)
		{
			return false;
		}
		if (singleCharacter != Saving.instance.saveGameData.usedCharacters.Length <= 1)
		{
			return false;
		}
		return true;
	}
}
[Serializable]
public class SavedFightingStyles
{
	public FightingStyle[] fightingStyles;

	public SpecialMove[] specialMoves;
}
[Serializable]
public class SavedProgress
{
	public SavedCompletedGame[] completedGames;

	public int[] characterFights;

	public int[] unlockedLocations;

	public string[] unlockedModes;

	public string[] customUnlocks;

	public GameStats stats;

	public void CompleteGame()
	{
		List<SavedCompletedGame> list = new List<SavedCompletedGame>();
		if (completedGames != null)
		{
			list.AddRange(completedGames);
		}
		SavedCompletedGame savedCompletedGame = null;
		foreach (SavedCompletedGame item in list)
		{
			if (item.matchesCurrent())
			{
				savedCompletedGame = item;
				break;
			}
		}
		if (savedCompletedGame == null)
		{
			savedCompletedGame = new SavedCompletedGame();
			list.Add(savedCompletedGame);
		}
		savedCompletedGame.SetToCurrent();
		completedGames = list.ToArray();
	}

	public bool hasCustomUnlock(string name)
	{
		if (customUnlocks == null)
		{
			return false;
		}
		return Array.IndexOf(customUnlocks, name) > -1;
	}

	public void customUnlock(string unlockName)
	{
		List<string> list = new List<string>();
		if (customUnlocks != null)
		{
			list.AddRange(customUnlocks);
		}
		if (!list.Contains(unlockName))
		{
			list.Add(unlockName);
			customUnlocks = list.ToArray();
			Saving.saveProgress();
		}
	}

	public void updateUnlocked()
	{
		List<int> list = new List<int>();
		LocationData[] locations = GameData.instance.locations;
		foreach (LocationData locationData in locations)
		{
			if (locationData.charactersUnlocked)
			{
				list.Add(locationData.id);
			}
		}
		unlockedLocations = list.ToArray();
	}
}
[Serializable]
public class SavedSettings
{
	public float calibrateScale = 1f;

	public float headY = 1.1f;

	public float calibrateRotation;

	public OptionCategory[] options;

	public OptionCategory customGameOptions;

	public int[] seenControllerTips;

	public void saveControllerTips()
	{
		seenControllerTips = new int[GameData.instance.vrControlTips.Length];
		for (int i = 0; i < GameData.instance.vrControlTips.Length; i++)
		{
			seenControllerTips[i] = GameData.instance.vrControlTips[i].seen;
		}
		Saving.saveSettings();
	}

	public void loadControllerTips()
	{
		if (seenControllerTips != null)
		{
			for (int i = 0; i < seenControllerTips.Length; i++)
			{
				GameData.instance.vrControlTips[i].seen = seenControllerTips[i];
			}
		}
	}
}
public class Saving : MonoBehaviour
{
	public static Saving instance;

	public SavedFightingStyles styles;

	public SavedSettings gameSettings;

	public SaveGame saveGameData;

	public SaveGame[] saveSlots;

	public int selectedSlot;

	public SavedProgress savedProgress;

	public MoveRecorder recorder;

	public string folder;

	public string backupName;

	public bool saveNow;

	public bool commit;

	public bool rollback;

	public string[] fileNames;

	private void Start()
	{
		instance = this;
		folder = Application.persistentDataPath;
		saveGameData.clear();
		getGame();
		Backup();
	}

	public void clearData()
	{
		string[] array = fileNames;
		foreach (string text in array)
		{
			string path = Application.persistentDataPath + "/" + text + ".dat";
			if (File.Exists(path))
			{
				File.Delete(path);
			}
		}
	}

	public void Backup()
	{
		string[] array = fileNames;
		foreach (string text in array)
		{
			string text2 = Application.persistentDataPath + "/" + text + ".dat";
			if (File.Exists(text2))
			{
				File.Copy(text2, text2.Replace(".dat", ".bkp"), overwrite: true);
			}
		}
	}

	private void Update()
	{
		if (saveGameData.stats.saveTimer > 0f)
		{
			saveGameData.stats.saveTimer -= Time.deltaTime;
			if (saveGameData.stats.saveTimer <= 0f)
			{
				saveGame();
			}
		}
		if (savedProgress.stats.saveTimer > 0f)
		{
			savedProgress.stats.saveTimer -= Time.deltaTime;
			if (savedProgress.stats.saveTimer <= 0f)
			{
				saveProgress();
			}
		}
		if (saveNow)
		{
			saveNow = false;
			saveSettings();
			saveFightingStyles();
		}
		if (commit)
		{
			commit = false;
			string text = Application.persistentDataPath + "\\fightingStyles.dat";
			File.Copy(text, text.Replace("fightingStyles", "fightingStyles_commit"), overwrite: true);
		}
	}

	public void incrementStat(string name, bool onlyInFight)
	{
		if (!onlyInFight || GameController.instance.fightState == GameController.FightState.During)
		{
			if (saveGameData.stats == null)
			{
				saveGameData.stats = new GameStats();
			}
			if (savedProgress.stats == null)
			{
				saveGameData.stats = new GameStats();
			}
			saveGameData.stats.incrementStat(name, checkAchievement: false);
			savedProgress.stats.incrementStat(name, checkAchievement: true);
		}
	}

	public void maxStat(string name, float value, bool onlyInFight, bool isInt)
	{
		if (!onlyInFight || GameController.instance.fightState == GameController.FightState.During)
		{
			if (saveGameData.stats == null)
			{
				saveGameData.stats = new GameStats();
			}
			if (savedProgress.stats == null)
			{
				saveGameData.stats = new GameStats();
			}
			saveGameData.stats.maxStat(name, value, checkAchievement: false, isInt);
			savedProgress.stats.maxStat(name, value, checkAchievement: true, isInt);
		}
	}

	public void minStat(string name, float value, bool onlyInFight, bool isInt)
	{
		if (!onlyInFight || GameController.instance.fightState == GameController.FightState.During)
		{
			if (saveGameData.stats == null)
			{
				saveGameData.stats = new GameStats();
			}
			if (savedProgress.stats == null)
			{
				saveGameData.stats = new GameStats();
			}
			saveGameData.stats.minStat(name, value, checkAchievement: false, isInt);
			savedProgress.stats.minStat(name, value, checkAchievement: true, isInt);
		}
	}

	public static SavedProgress loadProgress()
	{
		string path = Application.persistentDataPath + "\\progress.dat";
		if (File.Exists(path))
		{
			BinaryFormatter binaryFormatter = new BinaryFormatter();
			FileStream fileStream = File.Open(path, FileMode.Open);
			instance.savedProgress = (SavedProgress)binaryFormatter.Deserialize(fileStream);
			for (int i = 0; i < GameData.instance.specialModes.Length; i++)
			{
				if (GameData.instance.specialModes[i].singleRound)
				{
					if (instance.savedProgress.stats == null)
					{
						instance.savedProgress.stats = new GameStats();
					}
					GameData.instance.specialModes[i].best = Mathf.RoundToInt(instance.savedProgress.stats.getStat(GameData.instance.specialModes[i].name).value);
				}
			}
			string[] unlockedModes = instance.savedProgress.unlockedModes;
			foreach (string text in unlockedModes)
			{
				GameModeData specialModeByName = GameData.instance.getSpecialModeByName(text);
				if (specialModeByName != null)
				{
					specialModeByName.unlocked = true;
				}
			}
			int[] unlockedLocations = instance.savedProgress.unlockedLocations;
			foreach (int num in unlockedLocations)
			{
				GameData.instance.locations[num].charactersUnlocked = true;
			}
			fileStream.Close();
		}
		return instance.savedProgress;
	}

	public static SavedFightingStyles loadSettings()
	{
		string path = Application.persistentDataPath + "\\settings.dat";
		if (File.Exists(path))
		{
			BinaryFormatter binaryFormatter = new BinaryFormatter();
			FileStream fileStream = File.Open(path, FileMode.Open);
			instance.gameSettings = (SavedSettings)binaryFormatter.Deserialize(fileStream);
			instance.gameSettings.loadControllerTips();
			if (instance.gameSettings.options != null)
			{
				GameController.instance.gameData.calibrateScale = instance.gameSettings.calibrateScale;
				GameController.instance.noPlayer.headY = instance.gameSettings.headY;
				if (GameController.instance.gameData.calibrateScale == 0f)
				{
					GameController.instance.gameData.calibrateScale = 1f;
				}
				OptionCategory[] options = instance.gameSettings.options;
				for (int i = 0; i < options.Length; i++)
				{
					OptionData[] options2 = options[i].options;
					foreach (OptionData optionData in options2)
					{
						if (OptionData.getOption(optionData.name) != null)
						{
							OptionData.getOption(optionData.name).value = optionData.value;
						}
					}
				}
			}
			fileStream.Close();
		}
		return instance.styles;
	}

	public static bool gameExists()
	{
		return instance.saveGameData.exists();
	}

	public static void getGame()
	{
		List<SaveGame> list = new List<SaveGame>();
		bool flag = false;
		for (int i = -1; i < Settings.instance.maxSaveSlots; i++)
		{
			string text = Application.persistentDataPath + "\\";
			text += ((i == -1) ? "currentGame.dat" : ("saveSlot" + i + ".dat"));
			if (File.Exists(text))
			{
				BinaryFormatter binaryFormatter = new BinaryFormatter();
				FileStream fileStream = File.Open(text, FileMode.Open);
				if (i == -1)
				{
					instance.saveGameData = (SaveGame)binaryFormatter.Deserialize(fileStream);
					flag = true;
				}
				else
				{
					list.Add((SaveGame)binaryFormatter.Deserialize(fileStream));
				}
				fileStream.Close();
			}
		}
		instance.saveSlots = list.ToArray();
		if (instance.saveSlots.Length == 0 && flag)
		{
			instance.saveSlots = new SaveGame[1];
			instance.saveSlots[0] = instance.saveGameData;
		}
	}

	public void clearEmptySlots()
	{
		List<SaveGame> list = new List<SaveGame>();
		SaveGame[] array = saveSlots;
		foreach (SaveGame saveGame in array)
		{
			if (saveGame.exists())
			{
				list.Add(saveGame);
			}
		}
		saveSlots = list.ToArray();
	}

	public static void loadGame(int slot)
	{
		instance.saveGameData = instance.saveSlots[slot];
		GameController.instance.gameData.characterID = instance.saveGameData.character;
		GameController.instance.costume = instance.saveGameData.costume;
		GameController.instance.gameData.chooseDifficulty = false;
		if (GameController.instance.gameData.characterID == -1)
		{
			GameController.instance.gameData.characterID = 0;
		}
		GameController.instance.difficultyLevel = Settings.instance.difficultyLevels[instance.saveGameData.difficultyLevel];
		GameController.instance.lowestDifficultyLevel = instance.saveGameData.lowestDifficulty;
		GameController.instance.specialMode = GameData.instance.getSpecialModeByName(instance.saveGameData.specialMode);
		List<CharacterData> list = new List<CharacterData>();
		for (int i = 0; i < instance.saveGameData.characterOrder.Length; i++)
		{
			CharacterData characterData = GameController.instance.gameData.characters[instance.saveGameData.characterOrder[i]];
			characterData.hasStars = instance.saveGameData.characterStars[i];
			characterData.fightsFinished = ((instance.saveGameData.characterFights != null) ? instance.saveGameData.characterFights[i] : 0);
			characterData.playedAs = Array.IndexOf(instance.saveGameData.usedCharacters, i) > -1;
			list.Add(characterData);
		}
		GameController.instance.gameData.characterOrder = list.ToArray();
		GameController.instance.gameData.setupUnlocks();
		GameController.instance.characterID = GameController.instance.gameData.characterID;
	}

	public static void saveProgress()
	{
		instance.savedProgress.updateUnlocked();
		string path = Application.persistentDataPath + "\\progress.dat";
		BinaryFormatter binaryFormatter = new BinaryFormatter();
		FileStream fileStream = File.Create(path);
		instance.savedProgress.stats.saveTimer = 0f;
		binaryFormatter.Serialize(fileStream, instance.savedProgress);
		fileStream.Close();
	}

	public static void saveGame()
	{
		if (GameController.instance.specialMode.name == "")
		{
			GameController.instance.specialMode = GameData.instance.getSpecialModeByName("Normal");
		}
		if (!GameController.instance.specialMode.saves || GameController.instance.gameMode != GameController.GameMode.Normal || GameController.instance.gameData.characterID == -1 || GameController.instance.gameData.chooseDifficulty)
		{
			return;
		}
		for (int i = -1; i < instance.saveSlots.Length; i++)
		{
			SaveGame saveGame = ((i == -1) ? instance.saveGameData : instance.saveSlots[i]);
			if (i == -1)
			{
				saveGame.stats.saveTimer = 0f;
				saveGame.character = GameController.instance.gameData.characterID;
				saveGame.costume = GameController.instance.costume;
				saveGame.difficultyLevel = GameController.instance.difficultyLevel.id;
				saveGame.lowestDifficulty = GameController.instance.lowestDifficultyLevel;
				saveGame.specialMode = GameController.instance.specialMode.name;
				saveGame.characterOrder = new int[GameController.instance.gameData.characterOrder.Length];
				saveGame.characterStars = new int[GameController.instance.gameData.characterOrder.Length];
				saveGame.characterFights = new int[GameController.instance.gameData.characterOrder.Length];
				List<int> list = new List<int>();
				for (int j = 0; j < saveGame.characterOrder.Length; j++)
				{
					saveGame.characterOrder[j] = GameController.instance.gameData.characterOrder[j].id;
					saveGame.characterStars[j] = GameController.instance.gameData.characterOrder[j].hasStars;
					saveGame.characterFights[j] = GameController.instance.gameData.characterOrder[j].fightsFinished;
					if (GameController.instance.gameData.characterOrder[j].playedAs)
					{
						list.Add(GameController.instance.gameData.characterOrder[j].id);
					}
				}
				saveGame.usedCharacters = list.ToArray();
			}
			string path = string.Concat(Application.persistentDataPath + "\\", (i == -1) ? "currentGame.dat" : ("saveSlot" + i + ".dat"));
			BinaryFormatter binaryFormatter = new BinaryFormatter();
			FileStream fileStream = File.Create(path);
			binaryFormatter.Serialize(fileStream, saveGame);
			fileStream.Close();
		}
	}

	public static void saveSettings()
	{
		string path = Application.persistentDataPath + "\\settings.dat";
		BinaryFormatter binaryFormatter = new BinaryFormatter();
		FileStream fileStream = File.Create(path);
		instance.gameSettings.options = GameController.instance.gameData.options;
		instance.gameSettings.calibrateScale = GameController.instance.gameData.calibrateScale;
		instance.gameSettings.headY = GameController.instance.noPlayer.headY;
		binaryFormatter.Serialize(fileStream, instance.gameSettings);
		fileStream.Close();
	}

	public static void saveFightingStyles()
	{
		instance.styles.fightingStyles = instance.recorder.actions.fightingStyles.ToArray();
		instance.styles.specialMoves = instance.recorder.actions.specialMoves.ToArray();
		string text = Application.persistentDataPath + "\\fightingStyles.dat";
		if (File.Exists(text))
		{
			if (instance.backupName == "")
			{
				UnityEngine.Debug.Log("Do backup....");
				for (int i = 0; i < 100; i++)
				{
					string text2 = text.Replace("fightingStyles", "fightingStyles_backup_" + i);
					if (!File.Exists(text2))
					{
						instance.backupName = text2;
						UnityEngine.Debug.Log("File backup: " + text2);
						break;
					}
				}
			}
			File.Copy(text, instance.backupName, overwrite: true);
		}
		BinaryFormatter binaryFormatter = new BinaryFormatter();
		FileStream fileStream = File.Create(text);
		binaryFormatter.Serialize(fileStream, instance.styles);
		fileStream.Close();
		FaceCanvasController.addText("Saved Styles");
	}

	public static SavedFightingStyles loadFightingStyles()
	{
		string path = Application.persistentDataPath + "\\fightingStyles.dat";
		if (File.Exists(path))
		{
			BinaryFormatter binaryFormatter = new BinaryFormatter();
			FileStream fileStream = File.Open(path, FileMode.Open);
			instance.styles = (SavedFightingStyles)binaryFormatter.Deserialize(fileStream);
			instance.recorder.actions.fightingStyles.Clear();
			instance.recorder.actions.specialMoves.Clear();
			if (instance.styles != null)
			{
				if (instance.styles.fightingStyles != null)
				{
					instance.recorder.actions.fightingStyles.AddRange(instance.styles.fightingStyles);
				}
				if (instance.styles.specialMoves != null)
				{
					instance.recorder.actions.specialMoves.AddRange(instance.styles.specialMoves);
				}
				instance.recorder.actions.setup();
			}
			fileStream.Close();
		}
		return instance.styles;
	}
}
public class ScaleColliderWithSqueeze : MonoBehaviour
{
	private CapsuleCollider collider;

	public Vector3 maxCentre;

	public float maxHeight;

	public Vector3 minCentre;

	public float minHeight;

	public float squeeze;

	private float mod = 0.6f;

	public Hittable hittable;

	private void Start()
	{
		collider = GetComponent<CapsuleCollider>();
		maxCentre = collider.center;
		maxHeight = collider.height;
		minCentre = new Vector3(maxCentre.x, maxCentre.y * mod, maxCentre.z);
		minHeight = maxHeight * mod;
	}

	private void Update()
	{
		squeeze = hittable.getSqueeze();
		collider.center = Vector3.Lerp(maxCentre, minCentre, squeeze);
		collider.height = Mathf.Lerp(maxHeight, minHeight, squeeze);
	}
}
public class ScatterObjects : MonoBehaviour
{
	public GameObject prefab;

	public float radius;

	public float clearRadius;

	public int amount;

	public bool reset;

	public bool varyHeight = true;

	public float minWidth = 0.5f;

	public float maxWidth = 1.2f;

	public float lean = 2f;

	public float fallOff = 1f;

	public bool rayCast;

	private void Start()
	{
		if (base.transform.childCount == 0)
		{
			reset = true;
		}
	}

	private void Update()
	{
		if (!reset)
		{
			return;
		}
		foreach (Transform item in base.transform)
		{
			UnityEngine.Object.Destroy(item.gameObject);
		}
		reset = false;
		UnityEngine.Debug.LogError("add bamboo");
		List<GameObject> list = new List<GameObject>();
		for (int i = 0; i < amount; i++)
		{
			GameObject gameObject = UnityEngine.Object.Instantiate(prefab, base.transform);
			list.Add(gameObject);
			float num = 1f - fallOff * UnityEngine.Random.value;
			Vector3 origin = Quaternion.Euler(90f, 0f, 0f) * UnityEngine.Random.insideUnitCircle.normalized * num;
			float num2 = UnityEngine.Random.Range(clearRadius, radius);
			origin *= num2;
			if (Physics.Raycast(new Ray(origin, Vector3.down), out var hitInfo, 2f))
			{
				origin = hitInfo.point;
				if (origin.magnitude < clearRadius)
				{
					origin = origin.normalized * clearRadius;
				}
				gameObject.transform.position = origin;
				gameObject.transform.rotation = Quaternion.Euler(-90f, 0f, UnityEngine.Random.value * 360f) * Quaternion.Euler(UnityEngine.Random.Range(0f - lean, lean), UnityEngine.Random.Range(0f - lean, lean), 0f);
				if (varyHeight)
				{
					gameObject.transform.localScale = Vector3.one * UnityEngine.Random.Range(minWidth, maxWidth);
					continue;
				}
				float num3 = UnityEngine.Random.Range(0.9f, 1.3f);
				float num4 = UnityEngine.Random.Range(minWidth, maxWidth) * num3;
				gameObject.transform.localScale = new Vector3(num4, num4, num3);
			}
		}
	}
}
public class SceneController : MonoBehaviour
{
	public enum QuickAction
	{
		None,
		Portrait,
		SkipLevels
	}

	public int generalChamberScene;

	public int generalChamber;

	public int finalStoryScene;

	public int firstLevelScene;

	public GameController game;

	public int sceneID;

	public bool showMenuOnLoad;

	public bool addPlayerOnLoad;

	public bool fadeInOnLoad;

	public bool loading;

	public float fadeTime = 2f;

	public QuickAction quickAction;

	private void Start()
	{
		showMenuOnLoad = true;
		SceneManager.sceneLoaded += OnSceneLoaded;
	}

	private void OnSceneLoaded(Scene scene, LoadSceneMode mode)
	{
		loading = false;
		if (showMenuOnLoad)
		{
			game.menu.mainMenu = true;
			game.menu.showMenu("");
		}
		else
		{
			game.menu.mainMenu = false;
		}
		if (addPlayerOnLoad)
		{
			Invoke("addPlayer", 0.1f);
		}
		else
		{
			Fader.fade(fadeOut: false, 1f);
		}
	}

	private void addPlayer()
	{
		game.addPlayer();
		Fader.fade(fadeOut: false, 1f);
	}

	public void randomLevel()
	{
		loadLevel(UnityEngine.Random.Range(0, 13));
	}

	public void loadLevel(int level)
	{
		loadScene(GameData.instance.locations[level].name, level + firstLevelScene);
	}

	private void loadScene(string logName, int sceneID, bool showMenuOnLoad = false, bool addPlayerOnLoad = true)
	{
		if (!loading)
		{
			WebLogging.log("Load Scene", logName, sceneID);
			if (GameController.instance.player != null)
			{
				GameController.instance.clearFighters();
				GameController.instance.noPlayer.gameObject.SetActive(value: true);
				VRMainRigController.instance.faceHit.blinkPerc = 1f;
				Fader.fade(fadeOut: false, 0.25f);
			}
			loading = true;
			this.sceneID = sceneID;
			this.showMenuOnLoad = showMenuOnLoad;
			this.addPlayerOnLoad = addPlayerOnLoad;
			fadeInOnLoad = !addPlayerOnLoad;
			Invoke("loadSceneFade", 0.5f);
		}
	}

	private void loadSceneFade()
	{
		AmbientSoundController.fade(fadeOut: true, fadeTime);
		Fader.fade(fadeOut: true, fadeTime);
		Invoke("loadSceneNext", fadeTime + 0.1f);
	}

	public void endOfLevel()
	{
		if ((GameController.instance.gameMode != GameController.GameMode.Normal && GameController.instance.gameMode != GameController.GameMode.No_Fight) || GameController.instance.standButtons.isLevelPicker || GameController.instance.specialMode.singleRound)
		{
			mainMenu();
		}
		else
		{
			pickLevel();
		}
	}

	public void chooseDifficulty()
	{
		generalChamber = 3;
		loadScene("Choose Difficulty", generalChamberScene);
	}

	public void practiceMove()
	{
		generalChamber = 2;
		loadScene("Practice", generalChamberScene);
	}

	public void finalStory()
	{
		loadScene("Final Story", finalStoryScene);
	}

	public void pickLevel()
	{
		if (GameController.instance.characterID < 0)
		{
			GameController.instance.scenes.pickCharacter();
			return;
		}
		if (GameController.instance.gameData.chooseDifficulty && GameController.instance.specialMode.hasDifficultyLevels)
		{
			chooseDifficulty();
			return;
		}
		generalChamber = 1;
		loadScene("Choose Level", generalChamberScene);
	}

	public void pickCharacter()
	{
		generalChamber = 0;
		loadScene("Choose Character", generalChamberScene);
	}

	public void credits()
	{
		generalChamber = 4;
		loadScene("Credits", generalChamberScene);
	}

	public void mainMenu()
	{
		loadScene("Main Menu", firstLevelScene, showMenuOnLoad: true, addPlayerOnLoad: false);
		GameController.instance.menu.mainMenuPosition();
	}

	public bool levelExists(int id)
	{
		return id + firstLevelScene < SceneManager.sceneCountInBuildSettings;
	}

	private void loadSceneNext()
	{
		SceneManager.LoadSceneAsync(sceneID);
	}

	public void skipLevels(bool back)
	{
		int num = 0;
		for (int i = 0; i < GameData.instance.characterOrder.Length; i++)
		{
			CharacterData characterData = GameData.instance.characterOrder[i];
			if (!back)
			{
				if (characterData.unlocked && characterData.hasStars < 3 && characterData.playable(allowUnlockedBosses: false, blockLevelLocked: false))
				{
					characterData.hasStars += UnityEngine.Random.Range(1, 4);
					if (characterData.hasStars > 3)
					{
						characterData.hasStars = 3;
					}
					num++;
					if (num >= 10)
					{
						break;
					}
				}
			}
			else if (characterData.unlocked && characterData.hasStars > 0 && characterData.playable(allowUnlockedBosses: false, blockLevelLocked: false))
			{
				characterData.hasStars--;
				num++;
				if (num >= 5)
				{
					break;
				}
			}
		}
		pickLevel();
	}

	private void Update()
	{
		if (quickAction == QuickAction.SkipLevels)
		{
			skipLevels(back: false);
		}
		if (quickAction != 0)
		{
			quickAction = QuickAction.None;
		}
	}
}
public class SceneryBreakable : HitSurface
{
	public float breakForce = 0.5f;

	public GameObject intactPieceContainer;

	public GameObject smashedPieceContainer;

	public AudioClip breakSound;

	public ParticleSystem[] particles;

	private void Start()
	{
		intactPieceContainer.gameObject.SetActive(value: true);
		smashedPieceContainer.gameObject.SetActive(value: false);
		bounce = 0f;
	}

	public override void OnHit(Hittable hitBy, Hittable.HandHitType hitType, float force, Vector3 point, Vector3 normal)
	{
		if (force > breakForce)
		{
			intactPieceContainer.SetActive(value: false);
			smashedPieceContainer.SetActive(value: true);
			foreach (Transform item in smashedPieceContainer.transform)
			{
				Rigidbody rigidbody = item.gameObject.AddComponent<Rigidbody>();
				rigidbody.mass = 2f;
				rigidbody.AddForceAtPosition((item.position - point).normalized * force * Settings.instance.scenerySmashForce, point, ForceMode.Impulse);
			}
			ParticleSystem[] array = particles;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].Play();
			}
			hitBy.audioSource.PlayOneShot(breakSound);
			if (TableSmashAchievementCheck.instance != null)
			{
				TableSmashAchievementCheck.instance.Remove(this);
			}
		}
		else
		{
			base.OnHit(hitBy, hitType, force, point, normal);
		}
	}

	private void Update()
	{
	}
}
[DisallowMultipleComponent]
public class SteamManager : MonoBehaviour
{
	public static bool Initialized => false;
}
public class SelfieCamera : MonoBehaviour
{
	public static SelfieCamera instance;

	public Vector3 offset;

	public Vector3 lookOffset;

	private void Start()
	{
		instance = this;
	}

	public static void LookAt(Vector3 position)
	{
		instance.transform.position = position + instance.offset;
		instance.transform.LookAt(position + instance.lookOffset);
	}
}
public class Settings : MonoBehaviour
{
	public enum TestButtonFunction
	{
		None,
		OutOfBody,
		AddEffect,
		Screenshot,
		Fall,
		ToggleIndicators,
		Teleport
	}

	public static Settings instance;

	[Header("AI Settings")]
	public DifficultyLevel[] difficultyLevels;

	public DifficultyLevel generalDifficultyLevel;

	public MinMax aiStanceOffsetAngle;

	public MinMax aiStanceOffsetDistance;

	public MinMax aiStanceOffsetDistance_vsAI;

	public MinMax aiStanceSwitchFrequency;

	public MinMax aiSizeupTime;

	public MinMax aiSpeedVariance;

	public MinMax aiCounterMiddleRange;

	public MinMax aiCounterOuterRange;

	public float baseKickFreqency = 0.25f;

	[Header("Fighter General & Puppet Settings")]
	public bool mainMenuFighters = true;

	public float playerHandOffsetRecoveryTime = 0.03f;

	public float playerMuscleWeight = 0.9f;

	public float pinWeight = 0.9f;

	public float maxMagnitude = 10f;

	public float slideMult = 3f;

	public float recoverySpeed = 0.5f;

	public float slideClamp = 3f;

	public float minHitPerc = 0.05f;

	public bool massMultiplyEnabled = true;

	public bool outOfBodyCam_start = true;

	public float controllerDeadZone = 0.2f;

	public float controllerSensitivity = 2f;

	public bool stopGlancingBlows;

	public bool offsetRotation;

	public bool swooshesEnabled;

	public bool fingerTrackingEnabled;

	public float minFriendlyDistance = 1f;

	public float minDistance = 0.4f;

	public float knockdownMultiply = 10f;

	public MinMax restartDistance;

	public MinMax snapTurnAmount;

	public float snapTurnSpeed = 360f;

	public float smoothTurnSpeed = 30f;

	public float uberHitTimerMax;

	[Header("General")]
	public Color colour_qi;

	public Color colour_qi_empty;

	public Color colour_sickness;

	public Color[] beltColours;

	public AudioClip[] breaths;

	public float femaleBreathPitch = 1.3f;

	public float maxBreathVolume = 0.5f;

	public float specialChargeTime = 5f;

	public float specialHitCharge = 0.1f;

	public float handHeadOffsetAmount = 0.5f;

	public float comboTimer = 0.5f;

	public int practiceFighterID = 2;

	public bool moveVoices;

	public bool stanceAngles;

	public bool allowSpecialModes;

	public bool allowSaveSlots;

	public int maxSaveSlots = 5;

	public float maxMassMultiply = 2f;

	public float maxMoveSpeed = 45f;

	public float maxRotateSpeed = 1800f;

	public int masterStarRequirement = 70;

	public Vector3 getUpOffsetProne;

	public Vector3 getUpOffsetSupine;

	public float scenerySmashForce = 2f;

	[Header("Debugging")]
	public bool positionLines;

	public bool quickKnockout;

	public bool infiniteLives;

	public bool quickSpecials;

	public bool startWithSpecials;

	public bool testCounters;

	public bool timeSlowOnMenu = true;

	public TestButtonFunction testButtonFunction;

	public CharacterEffect.Effect testParticularEffect;

	[Header("Prefabs")]
	public PressurePoint pressurePointPrefab;

	public GameObject dazedEffect;

	private void Start()
	{
		instance = this;
		for (int i = 0; i < difficultyLevels.Length; i++)
		{
			difficultyLevels[i].id = i;
			if (i > 0)
			{
				string text = difficultyLevels[i - 1].moreDifficultThan(difficultyLevels[i]);
				if (text != "")
				{
					UnityEngine.Debug.LogError(difficultyLevels[i - 1].name + " more difficult than " + difficultyLevels[i].name + "? Yes: " + text);
				}
			}
		}
	}

	public void setToDefault()
	{
		if (!GameData.instance.devModeEnabled)
		{
			testButtonFunction = TestButtonFunction.None;
			positionLines = false;
			quickKnockout = false;
			infiniteLives = false;
			quickSpecials = false;
			startWithSpecials = false;
			timeSlowOnMenu = true;
		}
	}
}
public class ShadowBoxingCollider : MonoBehaviour
{
	public ShadowBoxingEffect shadowBoxing;

	private float nextHit;

	private Vector3 lastPos;

	private Vector3 velocity;

	private AudioSource audioSource;

	private void Start()
	{
		audioSource = base.gameObject.AddComponent<AudioSource>();
		audioSource.playOnAwake = false;
		audioSource.spatialBlend = 1f;
		GameController.instance.setAudioMixerGroup(audioSource);
	}

	private void OnTriggerEnter(Collider other)
	{
		Hittable component = other.GetComponent<Hittable>();
		if (component != null)
		{
			if (component.rb.character.team == shadowBoxing.character.team || Time.time < nextHit)
			{
				return;
			}
			float num = component.bodyPart.knockDownPerc * Mathf.Clamp01(velocity.magnitude / 5f);
			component.rb.Hit(velocity, component, null, num, num, component.collider.ClosestPoint(base.transform.position), Hittable.HandHitType.General, skipPressurePoints: false, "Shadow Hand");
			HitSoundsController.playSound(audioSource, component.bodyPart.hitType, num);
			HitEffects.addHitEffect(component.bodyPart.knockDownPerc > 0f, num, num, base.transform.position, -velocity, component.bodyPart.friendlyName, component.rb.character, component.bodyPart.knockDownPerc > 0f);
		}
		Breakable breakable = other.attachedRigidbody?.GetComponent<Breakable>();
		if (breakable != null)
		{
			breakable.hit(breakable.minHitPower * 2f, special: true, velocity, base.transform.position, "", shadowBoxing.character);
		}
	}

	private void FixedUpdate()
	{
		velocity = (base.transform.position - lastPos) / Time.fixedDeltaTime;
		lastPos = base.transform.position;
	}
}
public class ShadowBoxingEffect : SpecialMoveAttachedEffect
{
	public VRIK vrik;

	public ParticleSystem[] skinnedParticles;

	public SkinnedMeshRenderer meshRenderer;

	public override void setup(GameCharacter character)
	{
		if (character.isPlayer())
		{
			vrik.solver.spine.headTarget = character.playerController.activeRig.trackers[0];
			vrik.solver.leftArm.target = character.playerController.activeRig.trackers[1];
			vrik.solver.rightArm.target = character.playerController.activeRig.trackers[2];
		}
		else
		{
			vrik.solver.spine.headTarget = character.aiControl.aiTrackers[0];
			vrik.solver.leftArm.target = character.aiControl.aiTrackers[1];
			vrik.solver.rightArm.target = character.aiControl.aiTrackers[2];
		}
		IKSolver iKSolver = vrik.GetIKSolver();
		iKSolver.OnPostUpdate = (IKSolver.UpdateDelegate)Delegate.Combine(iKSolver.OnPostUpdate, new IKSolver.UpdateDelegate(OnPostUpdate));
		base.setup(character);
		meshRenderer.material.SetColor("_Color", Color.clear);
	}

	private void OnDestroy()
	{
		IKSolver iKSolver = vrik.GetIKSolver();
		iKSolver.OnPostUpdate = (IKSolver.UpdateDelegate)Delegate.Remove(iKSolver.OnPostUpdate, new IKSolver.UpdateDelegate(OnPostUpdate));
	}

	public override void end()
	{
		UnityEngine.Object.Destroy(base.gameObject);
	}

	private void Update()
	{
		if (!(character.rigidBodies.ik == null))
		{
			base.transform.position = character.rigidBodies.ik.transform.position;
			base.transform.rotation = character.rigidBodies.ik.transform.rotation;
		}
	}

	private void OnPostUpdate()
	{
		if (base.enabled)
		{
			float t = character.getEffect(CharacterEffect.Effect.ShadowBoxing).edgePerc(1f);
			meshRenderer.material.SetColor("_Color", Color.Lerp(Color.clear, Color.black, t));
			ParticleSystem[] array = skinnedParticles;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].Simulate(Time.deltaTime, withChildren: true, restart: false);
			}
		}
	}
}
public class ShowIfHasEffect : MonoBehaviour
{
	public RigidBodies rigidBodies;

	public CharacterEffect.Effect effect;

	private SkinnedMeshRenderer mesh;

	private void Start()
	{
		mesh = GetComponent<SkinnedMeshRenderer>();
		mesh.enabled = false;
	}

	private void Update()
	{
		mesh.enabled = rigidBodies.character != null && rigidBodies.character.hasEffect(effect);
	}
}
public class SimpleControls : MonoBehaviour
{
	public CharacterController characterController;

	private void Start()
	{
		characterController = GetComponent<CharacterController>();
	}

	private void FixedUpdate()
	{
		Vector3 vector = Vector3.zero;
		if (Input.GetKey(KeyCode.W))
		{
			vector += base.transform.forward;
		}
		if (Input.GetKey(KeyCode.S))
		{
			vector -= base.transform.forward;
		}
		if (Input.GetKey(KeyCode.D))
		{
			vector += base.transform.right;
		}
		if (Input.GetKey(KeyCode.A))
		{
			vector -= base.transform.right;
		}
		if (vector != Vector3.zero)
		{
			vector = vector.normalized;
		}
		if (Input.GetKey(KeyCode.LeftShift))
		{
			vector *= 2f;
		}
		characterController.Move(vector * Time.deltaTime);
	}
}
public class SkinMesh : MonoBehaviour
{
	public enum Show
	{
		Show,
		ShowNoShadows,
		ShadowsOnly,
		Hide
	}

	public Show inBody;

	public Show outOfBody;

	private SkinnedMeshRenderer mesh;

	private void Start()
	{
		if (mesh == null)
		{
			mesh = GetComponent<SkinnedMeshRenderer>();
		}
	}

	public void SetMaterial(Material material)
	{
		if (mesh == null)
		{
			mesh = GetComponent<SkinnedMeshRenderer>();
		}
		mesh.material = material;
	}

	public void Set(bool povView)
	{
		if (mesh == null)
		{
			mesh = GetComponent<SkinnedMeshRenderer>();
		}
		Show show = (povView ? inBody : outOfBody);
		int layer = 18;
		int layer2 = 15;
		switch (show)
		{
		case Show.Show:
			base.gameObject.layer = layer;
			mesh.shadowCastingMode = ShadowCastingMode.On;
			break;
		case Show.ShowNoShadows:
			base.gameObject.layer = layer;
			mesh.shadowCastingMode = ShadowCastingMode.Off;
			break;
		case Show.ShadowsOnly:
			base.gameObject.layer = layer2;
			mesh.shadowCastingMode = ShadowCastingMode.ShadowsOnly;
			break;
		case Show.Hide:
			base.gameObject.layer = layer2;
			mesh.shadowCastingMode = ShadowCastingMode.Off;
			break;
		}
	}

	private void Update()
	{
	}
}
public class SkinParticles : SpecialMoveAttachedEffect
{
	public IK ik;

	public ParticleSystem[] skinnedParticles;

	public SkinnedMeshRenderer[] skins;

	public bool hideSkin;

	private bool done;

	public override void setup(GameCharacter character)
	{
		if (character.rigidBodies.wholebodyMeshRenderer == null)
		{
			UnityEngine.Debug.LogError(character.data.name + " needs a whole body mesh to do effect");
		}
		setupSkin(character.rigidBodies.ik, character.rigidBodies.wholebodyMeshRenderer);
	}

	public void setupSkin(IK ik, SkinnedMeshRenderer skinnedMesh)
	{
		this.ik = ik;
		IKSolver iKSolver = ik.GetIKSolver();
		iKSolver.OnPostUpdate = (IKSolver.UpdateDelegate)Delegate.Combine(iKSolver.OnPostUpdate, new IKSolver.UpdateDelegate(OnPostUpdate));
		ParticleSystem[] array = skinnedParticles;
		for (int i = 0; i < array.Length; i++)
		{
			ParticleSystem.ShapeModule shape = array[i].shape;
			shape.skinnedMeshRenderer = skinnedMesh;
		}
		if (hideSkin)
		{
			skins = ik.GetComponentsInChildren<SkinnedMeshRenderer>();
			SkinnedMeshRenderer[] array2 = skins;
			for (int i = 0; i < array2.Length; i++)
			{
				array2[i].enabled = false;
			}
		}
	}

	private void OnDestroy()
	{
		IKSolver iKSolver = ik.GetIKSolver();
		iKSolver.OnPostUpdate = (IKSolver.UpdateDelegate)Delegate.Remove(iKSolver.OnPostUpdate, new IKSolver.UpdateDelegate(OnPostUpdate));
	}

	public override void end()
	{
		if (done)
		{
			return;
		}
		done = true;
		if (hideSkin)
		{
			SkinnedMeshRenderer[] array = skins;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].enabled = true;
			}
		}
		UnityEngine.Object.Destroy(base.gameObject);
	}

	private void Update()
	{
		if (ik == null)
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}

	private void OnPostUpdate()
	{
		if (!done && base.enabled)
		{
			ParticleSystem[] array = skinnedParticles;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].Simulate(Time.deltaTime, withChildren: true, restart: false);
			}
		}
	}
}
[Serializable]
public class SlowMo
{
	public float timeScale = 1f;

	public float timeSlowTarget;

	public float changeSpeed = 1f;

	public SlowMo(float target, float changeSpeed, bool instantOn)
	{
		timeSlowTarget = target;
		this.changeSpeed = changeSpeed;
		if (instantOn)
		{
			timeScale = target;
		}
	}

	public bool finished()
	{
		if (timeScale == 1f)
		{
			return timeSlowTarget == 1f;
		}
		return false;
	}

	public void update(float deltaTime)
	{
		timeScale = Mathf.MoveTowards(timeScale, timeSlowTarget, deltaTime * 25f * changeSpeed);
		timeSlowTarget = Mathf.Clamp01(Mathf.MoveTowards(timeSlowTarget, 1f, Time.deltaTime * changeSpeed));
	}

	public void reduceBy(float amount)
	{
		timeSlowTarget = Mathf.MoveTowards(timeSlowTarget, 1f, amount * 25f);
		timeScale = Mathf.MoveTowards(timeScale, timeSlowTarget, amount * 25f);
	}
}
public class SpawnPointController : MonoBehaviour
{
	private void Start()
	{
		if (GameController.instance == null)
		{
			return;
		}
		foreach (Transform item in base.transform)
		{
			item.gameObject.SetActive(value: false);
		}
	}

	private void Update()
	{
	}
}
[Serializable]
public class SpecialMove
{
	public string name;

	public RecordAction pose;

	public List<RecordAction> ai_attacks;

	public SpecialMove(string name)
	{
		this.name = name;
		pose = new RecordAction(name + " pose", singleFrame: true);
		ai_attacks = new List<RecordAction>();
	}

	public void setup(bool clean)
	{
		pose.setup(clean: true, "Pose");
		int num = 1;
		foreach (RecordAction ai_attack in ai_attacks)
		{
			ai_attack.setup(clean, "Special Attack " + num);
			num++;
		}
	}
}
public class SpecialMoveAttachedEffect : MonoBehaviour
{
	public GameCharacter character;

	public GameObject onHitEffect;

	public virtual void setup(GameCharacter character)
	{
		this.character = character;
	}

	public virtual void end()
	{
	}
}
public class SpecialMoveController : MonoBehaviour
{
	public enum ActivateMode
	{
		None,
		Instant,
		Impact,
		AirHit,
		Release,
		DownStrike,
		Chop,
		Trigger
	}

	public enum SlideActivate
	{
		None,
		Punch,
		Kick
	}

	public ProjectileController projectilePrefab;

	public SpecialMoveEffect effectPrefab;

	public Transform toGrip;

	public SpecialMoveController other;

	public SpecialMoveData data;

	public bool disableSounds;

	public GameObject preEffect;

	public GameObject effect;

	[NonSerialized]
	public Hittable following;

	public Transform followingTransform;

	[NonSerialized]
	private bool armed;

	[NonSerialized]
	public float activated;

	[NonSerialized]
	public bool finished;

	[NonSerialized]
	public bool launched;

	public bool fromGrab;

	public bool activateOnce = true;

	public Transform[] projectileStartPoint;

	public ActivateMode activateMode;

	public SlideActivate slideActivate;

	public float timer = 2f;

	private Vector3 lastPos;

	public bool slideOnActivate;

	public bool requiresSlide;

	public bool maxHitPower = true;

	public GameCharacter character;

	public bool angledProjectileSpawns = true;

	public float removeDelay = 3f;

	public bool success;

	public bool isFinished;

	private ProjectileController projectile;

	private Vector3 startPos;

	private Vector3 endPos;

	private void Start()
	{
		if (preEffect != null)
		{
			preEffect.SetActive(value: true);
		}
		if (effect != null)
		{
			effect.SetActive(value: false);
		}
	}

	public void onHitActivate(BodyPartData bodyPart)
	{
		if (activateMode != ActivateMode.Impact)
		{
			return;
		}
		if (character.doingSpecialData.removeOnHit)
		{
			finish(removeOther: true);
		}
		if (character.doingSpecialData.name == "Unstoppable Punch")
		{
			success = true;
		}
		else
		{
			if ((character.doingSpecialData.hitLocation == SpecialMoveData.HitLocation.Torso && !bodyPart.isChest) || (character.doingSpecialData.hitLocation == SpecialMoveData.HitLocation.Head && !bodyPart.isHead) || (character.doingSpecialData.hitLocation == SpecialMoveData.HitLocation.Leg && bodyPart.hitType != Hittable.HitType.Leg))
			{
				return;
			}
			success = bodyPart.knockDownPerc > 0f;
			if (character.doingSpecialData.hitLocation == SpecialMoveData.HitLocation.Arm)
			{
				success = bodyPart.isArm;
			}
		}
		onHit(success, bodyPart);
		bodyPart.hittable.rb.setLastHit(RigidBodies.LastHit.SpecialMove, base.transform.position);
	}

	public void onHit(bool success, BodyPartData bodyPart)
	{
		if (isFinished)
		{
			return;
		}
		if (effect != null)
		{
			if (preEffect != null)
			{
				preEffect.SetActive(value: false);
			}
			effect.SetActive(success);
		}
		if (character.doingSpecialData.timeSlowMode == SpecialMoveData.TimeSlowMode.OnHit)
		{
			character.doingSpecialData.timeSlow.doIt();
		}
		if (!success && character.doingSpecialData.removeOnHit)
		{
			if (character.isPlayer())
			{
				GeneralSounds.playSound(character.specialMoveFailHitSound);
			}
			PoseDisplay.instance.instruction.showFinished(character, "Blocked");
			bodyPart.hittable.rb.slide += (bodyPart.hittable.rb.character.standPosition - character.standPosition.normalized).normalized / 2f;
		}
		else if (bodyPart != null)
		{
			if (character.doingSpecialData.name == "Buddha Fist")
			{
				if (bodyPart.source == BodyPartData.Source.LeftHand)
				{
					bodyPart.hittable.rb.character.addEffect(bodyPart.hittable.transform.position, CharacterEffect.Effect.L_ArmDisabled, 10f, preventSpecialRecharge: false, isTest: false);
				}
				else
				{
					bodyPart.hittable.rb.character.addEffect(bodyPart.hittable.transform.position, CharacterEffect.Effect.R_ArmDisabled, 10f, preventSpecialRecharge: false, isTest: false);
				}
			}
			else if (character.doingSpecialData.addEffect != 0 && !character.doingSpecialData.addEffectToSelf)
			{
				bodyPart.hittable.rb.character.addEffect(bodyPart.hittable.transform.position, character.doingSpecialData.addEffect, character.doingSpecialData.effectDuration, preventSpecialRecharge: true, isTest: false);
			}
			activateMove();
			PoseDisplay.instance.instruction.showFinished(character, "Success");
		}
		if (character.doingSpecialData.removeOnHit)
		{
			isFinished = true;
		}
	}

	public void activateMove()
	{
		if ((activateOnce && activated != 0f) || activated > Time.time)
		{
			return;
		}
		activated = Time.time + 0.5f;
		if (character.doingSpecialData.activateSound != null && !disableSounds)
		{
			GeneralSounds.audioSource.PlayOneShot(character.doingSpecialData.activateSound);
		}
		if (effectPrefab != null)
		{
			SpecialMoveEffect specialMoveEffect = UnityEngine.Object.Instantiate(effectPrefab, character.standPosition, Quaternion.identity, GameController.instance.transform);
			if (specialMoveEffect.attachTo == SpecialMoveEffect.AttachTo.Hand)
			{
				specialMoveEffect.transform.position = base.transform.position;
				specialMoveEffect.transform.rotation = base.transform.rotation;
			}
			success = true;
			specialMoveEffect.setup(character);
			if (character.doingSpecialData.removeOnHit)
			{
				finish(removeOther: true);
			}
		}
		else if (character.doingSpecialData.addEffect != 0 && character.doingSpecialData.addEffectToSelf)
		{
			character.addEffect(character.rigidBodies.head.position + character.rigidBodies.head.forward * 0.5f, character.doingSpecialData, preventSpecialCharge: false, isTest: false);
			PoseDisplay.instance.instruction.hide();
			finish(removeOther: true);
		}
		if (!(projectilePrefab != null))
		{
			return;
		}
		if (character.doingSpecialData.timeSlowMode == SpecialMoveData.TimeSlowMode.OnThrow)
		{
			character.doingSpecialData.timeSlow.doIt();
		}
		if (activateMode == ActivateMode.Chop)
		{
			UnityEngine.Object.Instantiate(projectilePrefab, GameController.instance.transform).setup(position: Vector3.Lerp(startPos, endPos, 0.5f) + character.trackers.transforms[0].forward * 0.25f, rotation: Quaternion.LookRotation(character.trackers.transforms[0].forward, startPos - endPos), firer: character, direction: character.trackers.transforms[0].forward, fromGrab: fromGrab, speed: 1f);
		}
		else
		{
			float speed = (lastPos - base.transform.position).magnitude / Time.deltaTime;
			following.specialMove = null;
			Vector3 vector = base.transform.position - lastPos;
			for (int i = 0; i < projectileStartPoint.Length; i++)
			{
				ProjectileController projectileController = UnityEngine.Object.Instantiate(projectilePrefab, GameController.instance.transform);
				if (angledProjectileSpawns)
				{
					projectileController.setup(character, projectileStartPoint[i].position, projectileStartPoint[i].rotation, projectileStartPoint[i].localRotation * vector, fromGrab, speed);
				}
				else
				{
					projectileController.setup(character, projectileStartPoint[i].position, projectileStartPoint[i].rotation, vector, fromGrab, speed);
				}
				projectileController.following = this;
			}
		}
		finish(removeOther: true);
		PoseDisplay.instance.instruction.hide();
	}

	public void drop()
	{
		float speed = (lastPos - base.transform.position).magnitude / Time.deltaTime;
		following.specialMove = null;
		for (int i = 0; i < projectileStartPoint.Length; i++)
		{
			ProjectileController projectileController = UnityEngine.Object.Instantiate(projectilePrefab, GameController.instance.transform);
			if (angledProjectileSpawns)
			{
				projectileController.setup(character, projectileStartPoint[i].position, projectileStartPoint[i].rotation, projectileStartPoint[i].localRotation * (base.transform.position - lastPos), fromGrab, speed);
			}
			else
			{
				projectileController.setup(character, projectileStartPoint[i].position, projectileStartPoint[i].rotation, base.transform.position - lastPos, fromGrab, speed);
			}
			projectileController.following = this;
		}
		finish(removeOther: true);
	}

	private void finish(bool removeOther)
	{
		if (!finished)
		{
			if (removeOther && other != null)
			{
				other.finish(removeOther: false);
			}
			finished = true;
			following.rb.character.doingSpecial = 0f;
			if (preEffect != null)
			{
				preEffect.SetActive(value: false);
			}
			UnityEngine.Object.Destroy(base.gameObject, removeDelay);
		}
	}

	private void pause()
	{
	}

	private void Update()
	{
		if (following == null || finished)
		{
			return;
		}
		if (activated > 0f && requiresSlide && following.rb.specialSlide.magnitude == 0f)
		{
			PoseDisplay.instance.instruction.showFinished(character, "Missed");
			finish(removeOther: false);
			return;
		}
		if (activateMode == ActivateMode.Instant)
		{
			activateMove();
		}
		if (timer >= 0f)
		{
			timer -= Time.deltaTime;
			if (timer < 0f)
			{
				if (!success && !isFinished && !disableSounds)
				{
					if (character.isPlayer())
					{
						if (character.isPlayer())
						{
							GeneralSounds.playSound(character.specialMoveFailHitSound);
						}
						PoseDisplay.instance.instruction.showFinished(character, "Too Slow");
					}
				}
				else
				{
					PoseDisplay.instance.instruction.hide();
				}
				isFinished = true;
				finish(removeOther: true);
				return;
			}
		}
		base.transform.position = followingTransform.position;
		base.transform.rotation = followingTransform.rotation;
		float num = ((activateMode != ActivateMode.DownStrike) ? ((lastPos - base.transform.position).magnitude / Time.deltaTime) : ((lastPos.y - base.transform.position.y) / Time.deltaTime));
		if (lastPos != Vector3.zero)
		{
			if (activateMode == ActivateMode.Release)
			{
				if (following.getSqueeze() < 0.5f)
				{
					if (armed)
					{
						activateMove();
					}
				}
				else
				{
					armed = true;
				}
			}
			else if (activateMode == ActivateMode.AirHit || activateMode == ActivateMode.DownStrike)
			{
				if (num > 5f)
				{
					armed = true;
				}
				else if (armed)
				{
					activateMove();
				}
			}
			else if (activateMode == ActivateMode.Chop)
			{
				if (num > 5f)
				{
					startPos = base.transform.position;
					armed = true;
				}
				else if (armed)
				{
					endPos = base.transform.position;
					activateMove();
				}
			}
			if (!launched)
			{
				if (slideActivate == SlideActivate.Punch)
				{
					if (num > 5f)
					{
						character.rigidBodies.specialSlide = GameController.flatVector(character.trackers.transforms[0].forward, normalize: true) * character.doingSpecialData.forwardSlide;
						launched = true;
						activateMove();
						Invoke("pause", 0.1f);
					}
				}
				else if (slideActivate == SlideActivate.Kick && (character.kickController.legs[0].onStage >= 2 || character.kickController.legs[1].onStage >= 2))
				{
					character.rigidBodies.specialSlide = GameController.flatVector(character.trackers.transforms[0].forward, normalize: true) * character.doingSpecialData.forwardSlide;
					launched = true;
					activateMove();
				}
			}
		}
		lastPos = base.transform.position;
	}
}
[Serializable]
public class SpecialMoveData : Exportable
{
	public enum AIDoWhen
	{
		WithinMovingRange,
		WithinStillRange,
		GreaterThanCustom,
		LessThanCustom,
		AroundCustom,
		AnyTime
	}

	public enum HitLocation
	{
		Any,
		Head,
		Torso,
		Arm,
		Leg
	}

	public enum TimeSlowMode
	{
		None,
		OnActivate,
		OnHit,
		OnThrow
	}

	public enum Type
	{
		RightHand,
		LeftHand,
		BothHands,
		NoHands,
		BothFeet,
		Mouth
	}

	public enum HandMovementType
	{
		None,
		Forward,
		Downward,
		StrikeHeadOrBody,
		StrikeHead,
		StrikeBody,
		StrikeArm,
		StrikeLeg,
		StrikeAnywhere
	}

	[TextArea(5, 5)]
	public string desc;

	[TextArea(5, 5)]
	public string instruction;

	[Header("For Instruction")]
	public string shortInstruction;

	public HandMovementType leftHand;

	public HandMovementType rightHand;

	[Header("Time Slow")]
	public TimeSlowMode timeSlowMode;

	public TimeSlow timeSlow;

	[Header("AI Settings")]
	public AIDoWhen aiDoWhen;

	public float customRange;

	public float qiUsage = 1f;

	public bool kickMove;

	public bool allowPressurePoints;

	public bool stayStillDuring;

	public bool dontTurnDuring;

	[Header("Move Settings")]
	public AudioClip voice;

	public string voiceText;

	public AudioClip sound;

	public AudioClip activateSound;

	public bool skipHitSound;

	public SpecialMoveController prefab;

	public HandPosition.Position l_handPosition;

	public HandPosition.Position r_handPosition;

	public string customPosition;

	public bool ignoreSpeed = true;

	public float damageMod = 1f;

	public float slideMod = 1f;

	public float forwardSlide;

	public float moveDelayMod = 1f;

	public bool addEffectToSelf;

	public CharacterEffect.Effect addEffect;

	public float effectDuration = 10f;

	public Type moveType;

	public HitLocation hitLocation;

	public bool removeOnHit;

	public void localise()
	{
		LocalisationController.getText("Special Move", name);
		LocalisationController.getText("Special Move Description", desc);
		LocalisationController.getText("Special Move Instruction", instruction);
		LocalisationController.getText("Special Move Short Instruction", shortInstruction);
	}

	public SpecialMoveController addToHand(GameCharacter character, Transform attachTo, Hittable hittable, bool fromGrab = false)
	{
		SpecialMoveController specialMoveController = UnityEngine.Object.Instantiate(prefab, character.transform);
		specialMoveController.data = this;
		specialMoveController.fromGrab = fromGrab;
		specialMoveController.followingTransform = attachTo;
		specialMoveController.following = hittable;
		specialMoveController.following.specialMove = specialMoveController;
		specialMoveController.character = character;
		character.doingSpecialData = this;
		return specialMoveController;
	}

	public SpecialMove move()
	{
		return GameController.instance.gameData.moveRecorder.actions.getSpecialMoveByName(name);
	}
}
public class SpecialMoveEffect : MonoBehaviour
{
	public enum AttachTo
	{
		Hand,
		Floor
	}

	public float life = 10f;

	public string moveName;

	public ProjectileController projectilePrefab;

	public AttachTo attachTo;

	public void setup(GameCharacter firer)
	{
		UnityEngine.Object.Destroy(base.gameObject, life);
		moveName = firer.specialMove.name;
		bool flag = false;
		float num = 2f;
		switch (moveName)
		{
		case "Shockwave":
			num = 3f;
			foreach (GameCharacter player in GameController.instance.players)
			{
				if (player.team != firer.team)
				{
					Vector3 hitDir = player.standPosition - base.transform.position;
					if (hitDir.magnitude < num)
					{
						player.rigidBodies.Hit(hitDir, firer.specialMove.slideMod, firer.specialMove.damageMod, firer, moveName);
						player.rigidBodies.setLastHit(RigidBodies.LastHit.SpecialMove, base.transform.position);
						player.addEffect(player.rigidBodies.head.position, firer.specialMove, preventSpecialCharge: false, isTest: false);
						flag = true;
					}
				}
			}
			break;
		case "Air Pull":
			num = 4f;
			foreach (GameCharacter player2 in GameController.instance.players)
			{
				if (player2.team != firer.team)
				{
					Vector3 vector = player2.standPosition - base.transform.position;
					if (vector.magnitude < num)
					{
						player2.rigidBodies.slide -= vector.normalized;
						player2.addEffect(player2.rigidBodies.head.transform.position, CharacterEffect.Effect.HighImpact, 1.5f, preventSpecialRecharge: false, isTest: false);
						flag = true;
					}
				}
			}
			break;
		case "Orbital Sphere":
		{
			for (int i = 0; i < 3; i++)
			{
				ProjectileController projectileController = UnityEngine.Object.Instantiate(projectilePrefab, GameController.instance.transform);
				projectileController.setup(firer, firer.trackers.transforms[0].position, Quaternion.identity, firer.standPosition, fromGrab: false, 1f);
				OrbitalSphereController component = projectileController.GetComponent<OrbitalSphereController>();
				component.angle = 120 * i;
				component.height = 0.3f * ((float)i + 1f);
				component.speed = 0f;
				component.life = 15 + i;
			}
			break;
		}
		}
		PoseDisplay.instance.instruction.showFinished(firer, flag ? "Success" : "Too Far");
	}

	private void Update()
	{
	}
}
public class SpecialMoveInstructionController : MonoBehaviour
{
	public TextMeshProUGUI tip;

	public GameObject[] arrows;

	public GameObject[] crosshairs;

	public LineRenderer[] lines;

	public SpecialMoveData.HandMovementType[] handsMovements;

	public float moveAmount = 0.5f;

	public float perc;

	private bool arrowsOn = true;

	public float speed = 5f;

	public float heightOffset = -0.2f;

	public float angleThreshold = 10f;

	private Quaternion targetRotation;

	private Vector3[] defaultPositions;

	public BodyPartData[] bodyParts;

	public List<Collider> strikeTargets;

	public Collider closestCollider;

	public bool finished;

	public float hideTimer;

	private void Start()
	{
		base.gameObject.SetActive(value: false);
		defaultPositions = new Vector3[2];
		handsMovements = new SpecialMoveData.HandMovementType[2];
		defaultPositions[0] = arrows[0].transform.localPosition;
		defaultPositions[1] = arrows[1].transform.localPosition;
	}

	private void aimArrow(int i)
	{
		GameCharacter player = GameController.instance.player;
		Transform parent = arrows[i].transform.parent;
		SpecialMoveData.HandMovementType handMovementType = handsMovements[i];
		strikeTargets.Clear();
		bodyParts = ((player.targetEnemy == null) ? new BodyPartData[0] : player.targetEnemy.rigidBodies.bodyParts);
		switch (handMovementType)
		{
		case SpecialMoveData.HandMovementType.Forward:
			if (player.targetEnemy != null)
			{
				Vector3 forward = player.targetEnemy.trackers.transforms[0].position - parent.position;
				forward.y = 0f;
				parent.rotation = Quaternion.LookRotation(forward);
			}
			else
			{
				parent.localRotation = Quaternion.identity;
			}
			crosshairs[i].gameObject.SetActive(value: false);
			arrows[i].gameObject.SetActive(arrowsOn);
			break;
		case SpecialMoveData.HandMovementType.Downward:
			parent.localRotation = Quaternion.identity;
			crosshairs[i].gameObject.SetActive(value: false);
			arrows[i].gameObject.SetActive(arrowsOn);
			break;
		case SpecialMoveData.HandMovementType.None:
			crosshairs[i].gameObject.SetActive(value: false);
			arrows[i].gameObject.SetActive(value: false);
			break;
		case SpecialMoveData.HandMovementType.StrikeHead:
		{
			if (player.targetEnemy == null)
			{
				break;
			}
			BodyPartData[] array = bodyParts;
			foreach (BodyPartData bodyPartData3 in array)
			{
				if (bodyPartData3.hitType == Hittable.HitType.Head)
				{
					strikeTargets.Add(bodyPartData3.hittable.collider);
				}
			}
			break;
		}
		case SpecialMoveData.HandMovementType.StrikeBody:
		{
			if (player.targetEnemy == null)
			{
				break;
			}
			BodyPartData[] array = bodyParts;
			foreach (BodyPartData bodyPartData5 in array)
			{
				if (bodyPartData5.hitType == Hittable.HitType.Body)
				{
					strikeTargets.Add(bodyPartData5.hittable.collider);
				}
			}
			break;
		}
		case SpecialMoveData.HandMovementType.StrikeHeadOrBody:
		{
			if (player.targetEnemy == null)
			{
				break;
			}
			BodyPartData[] array = bodyParts;
			foreach (BodyPartData bodyPartData2 in array)
			{
				if (bodyPartData2.hitType == Hittable.HitType.Body || bodyPartData2.hitType == Hittable.HitType.Head)
				{
					strikeTargets.Add(bodyPartData2.hittable.collider);
				}
			}
			break;
		}
		case SpecialMoveData.HandMovementType.StrikeArm:
		{
			if (player.targetEnemy == null)
			{
				break;
			}
			BodyPartData[] array = bodyParts;
			foreach (BodyPartData bodyPartData6 in array)
			{
				if (bodyPartData6.hitType == Hittable.HitType.Arm && bodyPartData6.isArm)
				{
					strikeTargets.Add(bodyPartData6.hittable.collider);
				}
			}
			break;
		}
		case SpecialMoveData.HandMovementType.StrikeLeg:
		{
			if (player.targetEnemy == null)
			{
				break;
			}
			BodyPartData[] array = bodyParts;
			foreach (BodyPartData bodyPartData4 in array)
			{
				if (bodyPartData4.hitType == Hittable.HitType.Leg)
				{
					strikeTargets.Add(bodyPartData4.hittable.collider);
				}
			}
			break;
		}
		case SpecialMoveData.HandMovementType.StrikeAnywhere:
			if (!(player.targetEnemy == null))
			{
				BodyPartData[] array = bodyParts;
				foreach (BodyPartData bodyPartData in array)
				{
					strikeTargets.Add(bodyPartData.hittable.collider);
				}
			}
			break;
		default:
			UnityEngine.Debug.LogError("Unknown Movement type");
			break;
		}
		closestCollider = null;
		lines[i].enabled = strikeTargets.Count > 0;
		if (strikeTargets.Count > 0)
		{
			Transform transform = ((i == 0) ? player.rigidBodies.leftHand.transform : player.rigidBodies.rightHand.transform);
			float num = float.PositiveInfinity;
			Vector3 position = Vector3.zero;
			foreach (Collider strikeTarget in strikeTargets)
			{
				float magnitude = (strikeTarget.ClosestPoint(transform.position) - transform.position).magnitude;
				if (magnitude < num && strikeTarget.enabled)
				{
					num = magnitude;
					position = strikeTarget.ClosestPoint(transform.position);
					closestCollider = strikeTarget;
				}
			}
			lines[i].SetPosition(0, transform.position);
			lines[i].SetPosition(1, position);
			crosshairs[i].gameObject.SetActive(value: true);
			crosshairs[i].transform.position = position;
			crosshairs[i].transform.LookAt(transform);
		}
		else
		{
			crosshairs[i].gameObject.SetActive(value: false);
		}
	}

	private void updatePosition(bool resetAngle)
	{
		GameCharacter player = GameController.instance.player;
		base.transform.position = player.standPosition;
		Vector3 forward = player.trackers.transforms[0].forward;
		forward.y = 0f;
		base.transform.position = player.trackers.transforms[0].position + heightOffset * Vector3.up;
		lines[0].enabled = false;
		lines[1].enabled = false;
		if (finished)
		{
			return;
		}
		aimArrow(0);
		aimArrow(1);
		Quaternion quaternion = Quaternion.LookRotation(forward);
		if (!resetAngle)
		{
			_ = targetRotation;
			if (Quaternion.Angle(quaternion, base.transform.rotation) > angleThreshold)
			{
				targetRotation = quaternion;
			}
		}
		else
		{
			base.transform.rotation = quaternion;
		}
		base.transform.rotation = Quaternion.RotateTowards(base.transform.rotation, targetRotation, Time.deltaTime * 180f);
	}

	public void hide()
	{
		base.gameObject.SetActive(value: false);
	}

	public void showFinished(GameCharacter character, string message, float showTime = 2f)
	{
		if (character.isPlayer() && !(character.targetEnemy == null) && PracticeMoveController.isActive(0))
		{
			tip.text = LocalisationController.getText("Special Move Display", message);
			for (int i = 0; i < arrows.Length; i++)
			{
				arrows[i].gameObject.SetActive(value: false);
				crosshairs[i].gameObject.SetActive(value: false);
				handsMovements[i] = SpecialMoveData.HandMovementType.None;
			}
			hideTimer = showTime;
			finished = true;
			updatePosition(resetAngle: true);
			base.gameObject.SetActive(value: true);
		}
	}

	public void show(GameCharacter character)
	{
		if (character.isPlayer() && !(character.targetEnemy == null) && PracticeMoveController.isActive(0))
		{
			SpecialMoveData specialMoveData = character.data.specialMoveData(isPlayer: true);
			tip.text = LocalisationController.getText("Special Move Instruction", (specialMoveData.shortInstruction == "") ? "???" : specialMoveData.shortInstruction);
			handsMovements = new SpecialMoveData.HandMovementType[2];
			handsMovements[0] = specialMoveData.leftHand;
			handsMovements[1] = specialMoveData.rightHand;
			arrowsOn = false;
			perc = 0f;
			GameObject[] array = arrows;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].gameObject.SetActive(arrowsOn);
			}
			updatePosition(resetAngle: true);
			base.gameObject.SetActive(value: true);
			finished = false;
		}
	}

	private void Update()
	{
		if (GameController.instance.player == null)
		{
			base.gameObject.SetActive(value: false);
			return;
		}
		updatePosition(resetAngle: false);
		if (finished)
		{
			hideTimer -= Time.deltaTime;
			if (hideTimer < 0f)
			{
				base.gameObject.SetActive(value: false);
			}
			return;
		}
		if (perc == 1f)
		{
			arrowsOn = !arrowsOn;
			perc = 0f;
			return;
		}
		perc = Mathf.MoveTowards(perc, 1f, Time.deltaTime * speed);
		for (int i = 0; i < arrows.Length; i++)
		{
			if (handsMovements[i] == SpecialMoveData.HandMovementType.Forward)
			{
				arrows[i].transform.localPosition = new Vector3(defaultPositions[i].x, defaultPositions[i].y, Mathf.Lerp(defaultPositions[i].z, defaultPositions[i].z + moveAmount, perc));
				arrows[i].transform.localRotation = Quaternion.Euler(90f, 180f, 0f);
			}
			else if (handsMovements[i] == SpecialMoveData.HandMovementType.Downward)
			{
				arrows[i].transform.localPosition = new Vector3(defaultPositions[i].x, Mathf.Lerp(defaultPositions[i].y + moveAmount / 2f, defaultPositions[i].y - moveAmount / 2f, perc), defaultPositions[i].z);
				arrows[i].transform.localRotation = Quaternion.Euler(0f, 180f, 0f);
			}
		}
	}
}
public class SpectateCanvasController : MonoBehaviour
{
	public GameObject nonVRMenu;

	public Canvas canvas;

	private void Start()
	{
		canvas = GetComponent<Canvas>();
		nonVRMenu.SetActive(!XRSettings.enabled);
	}

	private void Update()
	{
		canvas.enabled = false;
	}
}
public class SpectatorCam : MonoBehaviour
{
	public Vector3 targetPos;

	public Vector3 offset;

	public float rotation;

	public float orbitSpeed = 10f;

	public float closestDist = 3f;

	public float furthestDist = 30f;

	public float changeInterval = 8f;

	private bool init;

	private float changeTime;

	public GameCharacter following;

	public GameCharacter followingEnemy;

	private void Start()
	{
		change();
	}

	private void change()
	{
		if (following == null)
		{
			following = GameController.instance.getToFollow(prioritizePlayer: true);
		}
		if (following != null)
		{
			followingEnemy = GameController.instance.getClosestEnemy(following);
		}
		orbitSpeed = UnityEngine.Random.Range(-3, 3);
		offset = new Vector3(0f, -0.5f + UnityEngine.Random.value * 5f, -5f);
		rotation = UnityEngine.Random.value * 360f;
		changeTime = changeInterval;
	}

	private void Update()
	{
		Vector3 vector = Vector3.zero;
		if (following == null)
		{
			return;
		}
		if (GameController.instance.players.Count == 0)
		{
			targetPos = Vector3.zero;
			targetPos.y = 1f;
		}
		else
		{
			if ((bool)followingEnemy && GameController.instance.players.Count < 2)
			{
				followingEnemy = null;
			}
			if (followingEnemy == null)
			{
				targetPos = GameController.instance.players[0].rigidBodies.head.transform.position + GameController.instance.players[0].rigidBodies.head.transform.forward;
				targetPos.y = 1f;
			}
			else
			{
				vector = GameController.instance.players[1].rigidBodies.head.transform.position - GameController.instance.players[0].rigidBodies.head.transform.position;
				targetPos = GameController.instance.players[0].rigidBodies.head.transform.position + vector / 2f;
				targetPos.y = 1f;
			}
		}
		changeTime -= Time.deltaTime;
		if (changeTime < 0f)
		{
			change();
		}
		Vector3 position = targetPos + Quaternion.Euler(0f, rotation, 0f) * offset.normalized * Mathf.Clamp(vector.magnitude, closestDist, furthestDist);
		base.transform.position = position;
		base.transform.rotation = Quaternion.LookRotation(targetPos - base.transform.position);
		rotation += Time.deltaTime * orbitSpeed;
		rotation = Mathf.Repeat(rotation, 360f);
	}
}
public class SpectatorSideCam : MonoBehaviour
{
	public Vector3 lookOffset;

	public Vector3 middlePos;

	public Vector3 camPos;

	public float magnitude;

	public float minMagnitude;

	public float changeInterval = 2f;

	private float changeTime;

	public GameCharacter following;

	public GameCharacter followingEnemy;

	public Vector3 centrePos;

	public float angle;

	public float dist;

	public float camSpeed = 5f;

	public float rotateSpeed = 25f;

	public float moveSpeed = 5f;

	private void Start()
	{
		change();
	}

	private void Update()
	{
		if (!(following == null))
		{
			Vector3 vector;
			if (followingEnemy == null)
			{
				middlePos = following.standPosition;
				vector = following.transform.right * minMagnitude;
			}
			else
			{
				middlePos = (following.standPosition + followingEnemy.standPosition) / 2f;
				vector = Quaternion.Euler(0f, 90f, 0f) * (followingEnemy.standPosition - following.standPosition);
			}
			if (vector.magnitude < minMagnitude)
			{
				vector = vector.normalized * minMagnitude;
			}
			dist = Mathf.MoveTowards(dist, vector.magnitude, Time.deltaTime);
			float y = Quaternion.LookRotation(middlePos + lookOffset - (middlePos + vector + camPos)).eulerAngles.y;
			angle = Mathf.MoveTowards(angle, y, rotateSpeed * Time.deltaTime);
			base.transform.position = centrePos + (Quaternion.Euler(0f, angle, 0f) * -Vector3.forward * dist + camPos);
			base.transform.rotation = Quaternion.Euler(0f, angle, 0f);
			centrePos = Vector3.MoveTowards(centrePos, middlePos, Time.deltaTime * moveSpeed);
			changeTime -= Time.deltaTime;
			if (changeTime < 0f)
			{
				change();
			}
		}
	}

	private void change()
	{
		if (following == null)
		{
			following = GameController.instance.getToFollow(prioritizePlayer: true);
		}
		if (following != null)
		{
			followingEnemy = GameController.instance.getClosestEnemy(following);
		}
		changeTime = changeInterval;
	}
}
public class SpikeController : MonoBehaviour
{
	public Vector3 center;

	public AudioClip stabSound;

	public GameObject hitEffectPrefab;

	public bool dirFromBox;

	private float nextHit;

	private GameCharacter lastHit;

	private void Start()
	{
	}

	private void Update()
	{
	}

	private void OnCollisionEnter(Collision collision)
	{
		Hittable component = collision.collider.GetComponent<Hittable>();
		if (!(component == null))
		{
			bool flag = false;
			if (Time.time < nextHit && lastHit == component.rb.character)
			{
				flag = true;
			}
			nextHit = Time.time + 1f;
			lastHit = component.rb.character;
			if (component.rb.character.name == "Feng Xiu" && !component.rb.character.isPlayer())
			{
				AchievementsController.achievement("Prickles");
			}
			float knockDownPerc = component.bodyPart.knockDownPerc;
			Vector3 hitDir = collision.contacts[0].point - center;
			hitDir.y = 0f;
			if (dirFromBox)
			{
				hitDir = Quaternion.Euler(0f, Mathf.Round(Quaternion.LookRotation(collision.contacts[0].point).eulerAngles.y / 90f) * 90f, 0f) * -Vector3.forward;
			}
			if (!flag)
			{
				GameObject obj = UnityEngine.Object.Instantiate(hitEffectPrefab, GameController.instance.transform);
				obj.transform.position = collision.contacts[0].point;
				obj.transform.rotation = Quaternion.LookRotation(collision.contacts[0].normal);
				UnityEngine.Object.Destroy(obj, 8f);
				component.rb.audioSource.PlayOneShot(stabSound);
			}
			if (knockDownPerc > 0f)
			{
				component.rb.Hit(hitDir, component, null, knockDownPerc / 2f, flag ? 0f : knockDownPerc, collision.contacts[0].point, Hittable.HandHitType.General, skipPressurePoints: false, "Spikes");
			}
		}
	}
}
public class Spinner : MonoBehaviour
{
	public Vector3 spinDirection;

	private void Start()
	{
	}

	private void Update()
	{
		base.transform.localRotation *= Quaternion.Euler(spinDirection * Time.deltaTime);
	}
}
public class StandButtonsController : MonoBehaviour
{
	public enum Type
	{
		Normal,
		LevelPick,
		CharPick,
		Practice,
		Difficulty,
		Final
	}

	public enum BoundsType
	{
		None,
		Circle,
		Square,
		Rect
	}

	public SpawnPointController[] spawnPoints;

	public StandPositionIndicator[] positions;

	public Type type;

	public Camera editCam;

	public GameObject noticeBoard;

	public Transform menuPosition;

	public FootstepController.Surface defaultSurface;

	public BoundsType boundsType;

	public float boundsSize;

	public Vector3 bounds;

	public bool isLevelPicker;

	public VolumetricFogProfile fogProfile;

	public float fightRadius = 20f;

	public Vector2 fightArea;

	public bool ai_Jumping;

	public bool ai_avoidObstructions = true;

	public AudioClip ambienceSound;

	public AudioClip roundStartSound;

	public int fighterSet = -1;

	public Transform[] cameraPoints;

	public float minimumHeight = -5f;

	private void Start()
	{
		if (spawnPoints.Length == 0)
		{
			spawnPoints = GetComponentsInChildren<SpawnPointController>();
		}
		if (GameController.instance != null)
		{
			SpawnPointController[] array = spawnPoints;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].gameObject.SetActive(value: false);
			}
		}
		AmbientSoundController.fadeIn(1f, ambienceSound);
		if (FloatingPointerController.instance != null)
		{
			FloatingPointerController.instance.pointingAt = null;
		}
		if (noticeBoard == null)
		{
			UnityEngine.Debug.LogError("Null notice board...");
		}
		if ((bool)GameController.instance)
		{
			GameController.instance.noPlayer.delayedActivate();
		}
		Invoke("delayedFade", 0.5f);
		if (GameController.instance != null)
		{
			Invoke("showTip", 1.5f);
		}
		StandPositionIndicator[] array2 = positions;
		for (int i = 0; i < array2.Length; i++)
		{
			array2[i].localise = true;
		}
	}

	public void startSound()
	{
		if (roundStartSound != null)
		{
			GeneralSounds.playSound(roundStartSound);
		}
	}

	private void delayedFade()
	{
		if (Fader.paused && GameController.instance != null)
		{
			GameController.instance.menu.fadeIn();
		}
	}

	private void showTip()
	{
		GameController.instance.gameData.ShowVRTip();
	}

	public void onKnockout()
	{
		CrowdController.applause();
	}

	public bool inFightArea(Vector3 targetPos)
	{
		Vector3 vector = targetPos;
		if (GameController.instance.standButtons.fightRadius > 0f && targetPos.magnitude > GameController.instance.standButtons.fightRadius)
		{
			return false;
		}
		if (GameController.instance.standButtons.fightArea.x != 0f && Mathf.Abs(vector.x) > GameController.instance.standButtons.fightArea.x)
		{
			return false;
		}
		if (GameController.instance.standButtons.fightArea.y != 0f && Mathf.Abs(vector.z) > GameController.instance.standButtons.fightArea.y)
		{
			return false;
		}
		return true;
	}

	public Vector3 clampPos(Vector3 targetPos)
	{
		Vector3 vector = targetPos;
		if (GameController.instance.standButtons.fightRadius > 0f)
		{
			vector = Vector3.ClampMagnitude(vector, GameController.instance.standButtons.fightRadius);
		}
		if (GameController.instance.standButtons.fightArea.x != 0f)
		{
			vector.x = Mathf.Clamp(vector.x, 0f - GameController.instance.standButtons.fightArea.x, GameController.instance.standButtons.fightArea.x);
		}
		if (GameController.instance.standButtons.fightArea.y != 0f)
		{
			vector.z = Mathf.Clamp(vector.z, 0f - GameController.instance.standButtons.fightArea.y, GameController.instance.standButtons.fightArea.y);
		}
		return vector;
	}

	private void Update()
	{
		if (spawnPoints.Length == 0)
		{
			spawnPoints = GetComponentsInChildren<SpawnPointController>();
		}
		if (GameController.instance == null)
		{
			return;
		}
		noticeBoard.SetActive(OptionData.getOption("Noticeboard").value == 0);
		if (GameController.instance != null)
		{
			for (int i = 0; i < positions.Length; i++)
			{
				if (GameController.instance.specialMode.singleRound && i == 0)
				{
					positions[i].setToSingleRound();
					if (GameController.instance.specialMode.centralSpawn)
					{
						positions[i].transform.position = new Vector3(0f, positions[i].transform.position.y, 0f);
						positions[i].transform.rotation = Quaternion.Euler(-90f, 0f, 0f);
					}
					continue;
				}
				if (i >= GameController.instance.levelCharacters.Length || GameController.instance.specialMode.singleRound)
				{
					positions[i].gameObject.SetActive(value: false);
					continue;
				}
				if (GameController.instance.gameMode == GameController.GameMode.Normal)
				{
					bool disabled = !GameController.instance.levelCharacters[i].unlocked;
					if (GameController.instance.difficultyLevel.name == "Master" && GameController.instance.levelCharacters[i].fightsFinished > 0)
					{
						disabled = true;
					}
					positions[i].disabled = disabled;
					positions[i].starDisplay.setTo(GameController.instance.levelCharacters[i]);
					positions[i].setToCharacter(GameController.instance.levelCharacters[i]);
				}
				else if (GameController.instance.gameMode == GameController.GameMode.Quick)
				{
					positions[i].disabled = false;
					positions[i].setToCharacter(GameController.instance.levelCharacters[i]);
				}
				positions[i].id = i;
			}
			GameController.instance.standButtons = this;
			if (editCam != null)
			{
				editCam.gameObject.SetActive(value: false);
			}
		}
		else if (editCam != null)
		{
			editCam.gameObject.SetActive(value: true);
		}
	}
}
public class StandPositionIndicator : MonoBehaviour
{
	public delegate void OnPress(StandPositionIndicator standPos);

	public string headingText;

	public string buttonLabel;

	public string buttonAction;

	public string standAction;

	public RawImage thumbnail;

	public LevelStarDisplay starDisplay;

	public int id;

	public TextMeshProUGUI heading;

	public TextMeshProUGUI extra;

	public TextMeshProUGUI tip;

	public MenuButtonContoller button;

	private float targetHeight;

	public bool standingOn;

	public bool disabled;

	public float dist;

	public Transform enemySpawnPoint;

	public OnPress onPress;

	public OnPress onSmash;

	public bool manual;

	public Material buttonDisabledMaterial;

	public Material circleDisabledMaterial;

	public Material circleEnabledMaterial;

	public AudioClip disabledHitSound;

	public Color disabledHeadingColour;

	public Material buttonStandardMaterial;

	public Material circleStandardMaterial;

	public AudioClip standardHitSound;

	public GameObject groundStars;

	public bool localise;

	private bool isDisabled;

	private bool fadeInLight;

	public bool on;

	public float minTime;

	private string tipText = "";

	private Material[] mats;

	private void Start()
	{
		button.gameObject.SetActive(value: false);
		starDisplay.gameObject.SetActive(value: false);
		if ((bool)groundStars)
		{
			groundStars.SetActive(value: false);
		}
		minTime = Time.time + 1f;
		if (localise)
		{
			LocalisationController.getText("Stand Position", heading);
			LocalisationController.getText("Stand Position", extra);
			LocalisationController.getText("Stand Position", tip);
		}
	}

	public Vector3 projected(float sideOffset)
	{
		return enemySpawnPoint.position - base.transform.right * sideOffset;
	}

	private void Update()
	{
		if (GameController.instance == null || GameController.instance.player == null)
		{
			return;
		}
		if (isDisabled != disabled)
		{
			isDisabled = disabled;
			button.unbreakable = disabled;
			if (disabled)
			{
				button.background.GetComponent<MeshRenderer>().material = buttonDisabledMaterial;
				mats = GetComponent<MeshRenderer>().materials;
				mats[1] = circleDisabledMaterial;
				GetComponent<MeshRenderer>().materials = mats;
				heading.color = disabledHeadingColour;
				button.hitSound = disabledHitSound;
			}
			else
			{
				button.background.GetComponent<MeshRenderer>().material = buttonStandardMaterial;
				mats = GetComponent<MeshRenderer>().materials;
				mats[1] = circleStandardMaterial;
				GetComponent<MeshRenderer>().materials = mats;
				heading.color = Color.white;
				button.hitSound = standardHitSound;
			}
		}
		dist = (GameController.instance.player.standPosition - base.transform.position).magnitude;
		float num = GameController.instance.player.rigidBodies.head.transform.position.y - 0.25f;
		num = base.transform.position.y + 1.4f;
		if ((double)Mathf.Abs(targetHeight - num) > 0.05)
		{
			targetHeight = num;
		}
		if (!manual)
		{
			on = dist < 0.4f && Time.time > minTime;
		}
		if (on)
		{
			if (!standingOn || button.onSmash == null)
			{
				heading.text = headingText;
				if (localise)
				{
					LocalisationController.getText("General", heading);
				}
				standingOn = true;
				button.setup(localise, buttonLabel, buttonLabel, buttonAction, press);
				button.onSmash = smash;
				button.gameObject.SetActive(value: true);
				GameController.instance.standAction(this, on: true);
			}
			Vector3 vector = new Vector3(0f, -0.75f, targetHeight - base.transform.position.y);
			button.transform.localPosition = Vector3.MoveTowards(button.transform.localPosition, vector, Time.deltaTime * 8f);
			if (starDisplay.set)
			{
				starDisplay.gameObject.SetActive((button.transform.localPosition - vector).magnitude == 0f);
			}
		}
		else
		{
			if (standingOn && !button.disabled)
			{
				GameController.instance.standAction(this, on: false);
				standingOn = false;
			}
			button.transform.localPosition = Vector3.MoveTowards(button.transform.localPosition, new Vector3(0f, -0.75f, -0.3f), Time.deltaTime * 4f);
			starDisplay.gameObject.SetActive(value: false);
		}
		GetComponent<MeshRenderer>().enabled = !manual;
		if (fadeInLight)
		{
			float t = Mathf.Clamp01((dist - 1f) / 3f);
			if (standingOn)
			{
				t = 0f;
			}
			mats[2].SetColor("_EmissionColor", Color.Lerp(Color.white, Color.black, t));
			GetComponent<MeshRenderer>().materials = mats;
		}
	}

	public void setToSingleRound()
	{
		groundStars.SetActive(value: false);
		mats = GetComponent<MeshRenderer>().materials;
		mats[2].SetTexture("_MainTex", GameController.instance.specialMode.thumbnail);
		mats[2].SetTexture("_EmissionMap", GameController.instance.specialMode.thumbnail);
		mats[2].SetColor("_EmissionColor", Color.black);
		GetComponent<MeshRenderer>().materials = mats;
		fadeInLight = true;
		extra.text = LocalisationController.getText("General", "Best:") + " " + GameController.instance.specialMode.best;
		if (tip != null && tipText == "" && GameController.instance.specialMode.tips.Length != 0)
		{
			tipText = GameController.instance.specialMode.tips[UnityEngine.Random.Range(0, GameController.instance.specialMode.tips.Length)];
		}
	}

	public void setToCharacter(CharacterData character)
	{
		mats = GetComponent<MeshRenderer>().materials;
		mats[2].SetTexture("_MainTex", character.thumbnail);
		mats[2].EnableKeyword("_EMISSION");
		mats[2].SetTexture("_EmissionMap", character.thumbnail);
		mats[2].SetColor("_EmissionColor", Color.black);
		GetComponent<MeshRenderer>().materials = mats;
		fadeInLight = true;
		if (!character.unlocked)
		{
			return;
		}
		groundStars.SetActive(value: true);
		for (int i = 0; i < groundStars.transform.childCount; i++)
		{
			groundStars.transform.GetChild(i).gameObject.SetActive(character.unlocked);
			MeshRenderer component = groundStars.transform.GetChild(i).GetComponent<MeshRenderer>();
			Material[] materials = component.materials;
			materials[1] = ((character.hasStars > i) ? circleEnabledMaterial : circleDisabledMaterial);
			component.materials = materials;
		}
		if (tip != null)
		{
			if (tipText == "")
			{
				tipText = GameController.instance.gameData.getTip();
			}
			tip.text = LocalisationController.getText("Tip", "Tip:") + " " + tipText;
		}
	}

	private void smash()
	{
		GameController.instance.smashAction(this);
	}

	private void press(MenuButtonContoller button)
	{
		if (onPress == null)
		{
			GameController.instance.buttonAction(this);
		}
		else
		{
			onPress(this);
		}
	}
}
public class StandingController : MonoBehaviour
{
	public GameCharacter character;

	public bool onGround;

	private void Start()
	{
	}

	private void FixedUpdate()
	{
		base.transform.position = character.rigidBodies.head.position;
		base.transform.localPosition = new Vector3(base.transform.localPosition.x, 0f, base.transform.localPosition.z);
		character.rigidBodies.transform.position = new Vector3(character.rigidBodies.transform.position.x, base.transform.position.y, character.rigidBodies.transform.position.z);
		onGround = Physics.Raycast(base.transform.position + Vector3.up * 0.3f, Vector3.down, 0.35f);
	}
}
public class StarPortraitController : MonoBehaviour
{
	public RawImage portrait;

	public Image border;

	public TextMeshProUGUI unlockText;

	public Image[] stars;

	public Sprite onSprite;

	public Sprite offSprite;

	public Sprite disabledSprite;

	private void Start()
	{
	}

	public void setTo(CharacterData character)
	{
		portrait.texture = character.thumbnail;
		if (character.unlocked)
		{
			if (GameController.instance.difficultyLevel.isMaster())
			{
				if (character.fightsFinished == 0)
				{
					border.color = Color.red;
				}
			}
			else if (character.hasStars == 0)
			{
				border.color = Color.red;
			}
			for (int i = 0; i < 3; i++)
			{
				stars[i].sprite = ((character.hasStars > i) ? onSprite : offSprite);
				if (GameController.instance.difficultyLevel.isMaster() && character.fightsFinished > 0 && character.hasStars <= i)
				{
					stars[i].gameObject.SetActive(value: false);
				}
			}
			unlockText.gameObject.SetActive(value: false);
		}
		else
		{
			portrait.color = Color.gray;
			for (int j = 0; j < 3; j++)
			{
				stars[j].sprite = disabledSprite;
			}
			unlockText.text = LocalisationController.replaceText("Location Requirement", "[x] to unlock", (character.getUnlockStars() - GameController.instance.gameData.stars).ToString());
		}
	}

	private void Update()
	{
	}
}
[Serializable]
public class StatScreenColumn
{
	public string[] statNames;
}
public class StatsScreenController : MonoBehaviour
{
	public bool currentGame;

	public TextMeshProUGUI head;

	public Transform container;

	public GameObject statPrefab;

	public Vector2 spacing;

	public float columnLimit = 650f;

	public StatScreenColumn[] columns;

	private void Start()
	{
		head.text = LocalisationController.getText("Heading", "Statistics");
		if (currentGame)
		{
			head.text += LocalisationController.getText("Heading", " (Current Game)");
		}
		GameStats gameStats = (currentGame ? Saving.instance.saveGameData.stats : Saving.instance.savedProgress.stats);
		Vector2 vector = default(Vector2);
		if (currentGame && GameController.instance.specialMode.singleRound)
		{
			base.transform.parent.gameObject.SetActive(value: false);
			return;
		}
		StatScreenColumn[] array = columns;
		for (int i = 0; i < array.Length; i++)
		{
			string[] statNames = array[i].statNames;
			foreach (string text in statNames)
			{
				GameStat stat = gameStats.getStat(text);
				GameObject obj = UnityEngine.Object.Instantiate(statPrefab, container);
				obj.transform.localPosition = vector;
				TextMeshProUGUI[] componentsInChildren = obj.GetComponentsInChildren<TextMeshProUGUI>();
				componentsInChildren[0].text = LocalisationController.getText("Gameplay Statistic", stat.name);
				componentsInChildren[1].text = stat.display();
				vector.y -= spacing.y;
			}
			vector.y = 0f;
			vector.x += spacing.x;
		}
	}
}
public class StoryController : MonoBehaviour
{
	public MenuButtonContoller menuButton;

	public MenuButtonContoller practiceButton;

	public MenuButtonContoller cancelButton;

	public MenuButtonContoller altCostume;

	public MenuButtonContoller nextCharacter;

	public TextMeshProUGUI heading;

	public TextMeshProUGUI text;

	public TextMeshProUGUI specialMove;

	public TextMeshProUGUI perks;

	public GameCharacterForPlinthController miniPuppet;

	public Light spotlight;

	public float targetHeight = -2f;

	public bool pressed;

	private void Start()
	{
		menuButton.setup(localise: true, "Continue", "Continue", "", nextScreen);
		practiceButton.setup(localise: true, "Practice Special Move", "Practice Special Move", "practice", nextScreen);
		altCostume.setup(localise: true, "Alt Costume", "Alt Costume", "altCostume", altCostumePress);
		nextCharacter.setup(localise: true, "Next Character", "Next Character", "nextChar", nextScreen);
		base.transform.position = Vector3.up * targetHeight;
	}

	private void altCostumePress(MenuButtonContoller b)
	{
		GameController.instance.costume++;
		GameController.instance.costume %= 2;
		miniPuppet.rigidBodies.switchCostume();
	}

	private void nextScreen(MenuButtonContoller b)
	{
		if (pressed)
		{
			return;
		}
		pressed = true;
		if (b.action == "nextChar")
		{
			int num = GameController.instance.characterID + 1;
			if (num >= GameController.instance.gameData.characters.Length)
			{
				num = 0;
			}
			while (!GameController.instance.gameData.characters[num].playable(allowUnlockedBosses: true, blockLevelLocked: true))
			{
				num++;
				if (num >= GameController.instance.gameData.characters.Length)
				{
					num = 0;
				}
			}
			GameController.instance.characterID = num;
			GameController.instance.costume = 0;
			show(GameController.instance.gameData.characters[GameController.instance.characterID]);
		}
		else if (b.action == "practice")
		{
			GameController.instance.scenes.practiceMove();
		}
		else if (GameController.instance.gameMode == GameController.GameMode.Quick)
		{
			GameController.instance.scenes.loadLevel(GameController.instance.selectedLevel);
		}
		else if (GameController.instance.gameData.chooseDifficulty && GameController.instance.specialMode.hasDifficultyLevels)
		{
			GameController.instance.scenes.chooseDifficulty();
		}
		else if (GameController.instance.specialMode.fixedLevel == -2)
		{
			GameController.instance.scenes.randomLevel();
		}
		else if (GameController.instance.specialMode.fixedLevel > -1)
		{
			GameController.instance.scenes.loadLevel(GameController.instance.specialMode.fixedLevel);
		}
		else
		{
			GameController.instance.scenes.pickLevel();
		}
	}

	public void hide()
	{
		targetHeight = -2f;
	}

	public void show(CharacterData characterData)
	{
		pressed = false;
		heading.text = LocalisationController.getText("Character: " + base.name, characterData.name);
		text.text = LocalisationController.getText("Character: " + base.name, characterData.bio);
		miniPuppet.setup(characterData);
		if (text.text == "")
		{
			text.text = LocalisationController.getText("General", "No Information Available");
		}
		specialMove.text = LocalisationController.getText("General", "Special Move: ") + LocalisationController.getText("Special Move", characterData.specialMoveData(isPlayer: true).name);
		perks.text = LocalisationController.getText("General", "Perk: ") + LocalisationController.getText("Perk Description", characterData.perk.getDescription(withName: true));
		TextMeshProUGUI textMeshProUGUI = perks;
		textMeshProUGUI.text = textMeshProUGUI.text + "\n" + LocalisationController.getText("General", "Weakness: ") + LocalisationController.getText("Weakness Description", characterData.weakness.getDescription(withName: true));
		Vector3 forward = GameController.instance.player.trackers.transforms[0].forward;
		forward.y = 0f;
		if (targetHeight != 0f)
		{
			base.transform.rotation = Quaternion.LookRotation(-forward);
			targetHeight = 0f;
		}
		altCostume.gameObject.SetActive(miniPuppet.rigidBodies.hasAlt());
		nextCharacter.gameObject.SetActive(OptionData.getBool("Next Char Button"));
	}

	private void Update()
	{
		base.transform.position = Vector3.MoveTowards(base.transform.position, Vector3.up * targetHeight, Time.deltaTime * 2f);
		spotlight.intensity = Mathf.MoveTowards(spotlight.intensity, (base.transform.position.y == 0f) ? 2 : 0, Time.deltaTime * 5f);
	}
}
public class SubtitlesController : MonoBehaviour
{
	public FaceController following;

	public Vector3 followPosition;

	public TextMeshProUGUI text;

	public static SubtitlesController instance;

	public float showTime;

	public float hideTime;

	public Color onColour;

	public Color offColour;

	private void Start()
	{
		instance = this;
		text.gameObject.SetActive(value: false);
	}

	public void cutOff(float perc, string with)
	{
		if (text.text.Length == 0)
		{
			text.text = with;
		}
		int num = Mathf.CeilToInt((float)text.text.Length * perc);
		if (num < 3)
		{
			num = 3;
		}
		if (num > text.text.Length)
		{
			num = text.text.Length;
		}
		text.text = text.text.Substring(0, num) + "..." + with;
	}

	public void say(Vector3 fromPos, string sayText, float forTime)
	{
		say(null, sayText, forTime, fromPos);
	}

	public void say(FaceController following, string sayText, float forTime, Vector3 fromPos)
	{
		if (!(sayText == "") && OptionData.getBool("Subtitles"))
		{
			this.following = following;
			text.text = sayText;
			showTime = forTime;
			hideTime = 2f;
			text.gameObject.SetActive(value: true);
			if (following == null)
			{
				base.transform.position = (followPosition = fromPos);
			}
			else
			{
				base.transform.position = following.transform.position;
			}
		}
	}

	private void Update()
	{
		if (GameController.instance.player == null || Camera.main == null || GameController.instance.paused)
		{
			return;
		}
		if (showTime <= 0f)
		{
			if (hideTime <= 0f)
			{
				text.gameObject.SetActive(value: false);
				return;
			}
			hideTime -= Time.deltaTime;
			text.color = Color.Lerp(offColour, onColour, hideTime / 2f);
			return;
		}
		text.color = onColour;
		showTime -= Time.deltaTime;
		Vector3 forward = Camera.main.transform.position - base.transform.position;
		forward.y = 0f;
		base.transform.rotation = Quaternion.LookRotation(forward);
		Vector3 vector = ((following == null) ? followPosition : following.transform.position);
		Vector3 vector2 = vector + (Camera.main.transform.position - vector) / 2f;
		Vector3 vector3 = Camera.main.transform.position + (vector - Camera.main.transform.position).normalized * 2.5f;
		float num = (vector2 - Camera.main.transform.position).magnitude / 3f;
		if (num > 0.35f)
		{
			num = 0.35f;
		}
		Vector3 vector4 = ((!((vector2 - Camera.main.transform.position).magnitude < (vector3 - Camera.main.transform.position).magnitude)) ? (vector3 + Vector3.down * num) : (vector2 + Vector3.down * num));
		base.transform.position = Vector3.MoveTowards(base.transform.position, vector4, (vector4 - base.transform.position).magnitude * Time.deltaTime);
		float num2 = Mathf.Clamp(((base.transform.position - Camera.main.transform.position).magnitude + 1f) / 4f, 0.5f, 1f);
		base.transform.localScale = Vector3.one * num2;
		if (!OptionData.getBool("Subtitles"))
		{
			showTime = 0f;
		}
	}
}
public class SwitchLayer : MonoBehaviour
{
	public int toLayer;

	public float time = 1f;

	private void Start()
	{
		if (time == 0f)
		{
			switchLayer();
		}
		else
		{
			Invoke("switchLayer", time);
		}
	}

	private void switchLayer()
	{
		base.gameObject.layer = toLayer;
	}
}
public class SwooshIfFast : MonoBehaviour
{
	public AudioClip outClip;

	public AudioClip roundClip;

	public float minSpeed;

	public bool doPitch;

	public bool ignoreSpeedForVolume;

	public float speed;

	public float swipeSpeed;

	public float pitch;

	private AudioSource audioSource;

	private Vector3 lastPos;

	private Vector3 startPos;

	private float lastHeadDist;

	[NonSerialized]
	public float nextPlay;

	private bool doneSwoosh;

	public bool right;

	public RigidBodies rb;

	private int frameCount;

	private void Start()
	{
		audioSource = GetComponent<AudioSource>();
		audioSource.spatialBlend = 1f;
		audioSource.playOnAwake = false;
		audioSource.Stop();
		lastPos = base.transform.position;
		nextPlay = Time.time + 0.1f;
		audioSource.loop = false;
	}

	public void sleep()
	{
		nextPlay = Time.time + 0.1f;
	}

	private void Update()
	{
		if (!Settings.instance.swooshesEnabled)
		{
			return;
		}
		if (Time.time > nextPlay && !audioSource.isPlaying)
		{
			speed = (base.transform.position - lastPos).magnitude / Time.deltaTime;
			float num = ((rb == null) ? 0f : GameController.flatVector(rb.head.position - base.transform.position).magnitude);
			float num2 = (num - lastHeadDist) * 2f / Time.deltaTime;
			lastHeadDist = num;
			if (speed + num2 > minSpeed && (rb == null || !rb.isDown(allTheWay: false)))
			{
				if (!doneSwoosh)
				{
					float num3 = ((!(rb != null)) ? (startPos - base.transform.position).magnitude : (startPos - (base.transform.position - rb.head.position)).magnitude);
					if (frameCount < 3 || num3 < 0.1f)
					{
						if (frameCount == 0)
						{
							startPos = ((rb == null) ? base.transform.position : (base.transform.position - rb.head.position));
						}
						frameCount++;
					}
					else
					{
						swipeSpeed = speed;
						if (!ignoreSpeedForVolume)
						{
							audioSource.volume = Mathf.Clamp01((speed - minSpeed) / minSpeed);
						}
						if (doPitch)
						{
							float num5 = (audioSource.pitch = Mathf.Clamp((speed - 3f) / 10f, 0.5f, 1.5f));
							pitch = num5;
						}
						if (rb != null && rb.character.overrideSwipeSound != null)
						{
							audioSource.clip = rb.character.overrideSwipeSound;
						}
						else if (outClip != null && roundClip != null)
						{
							float num6 = (right ? rb.hands.r_squeezeAmount : rb.hands.l_squeezeAmount);
							audioSource.clip = ((num6 > 0.5f) ? outClip : roundClip);
						}
						audioSource.Play();
						nextPlay = Time.time + 0.2f;
						doneSwoosh = true;
					}
				}
			}
			else
			{
				doneSwoosh = false;
				frameCount = 0;
			}
		}
		else if (audioSource.isPlaying)
		{
			speed = (base.transform.position - lastPos).magnitude / Time.deltaTime;
			float num7 = Mathf.Clamp((speed - 3f) / 10f, 0.5f, 1.5f);
			float num8 = Mathf.Clamp01((speed - 5f) / 5f);
			if (doPitch && num8 > audioSource.pitch)
			{
				audioSource.pitch = num7;
			}
		}
		lastPos = base.transform.position;
	}
}
public class SwordSpawner : MonoBehaviour
{
	public PuppetMasterPropMelee swordPrefab;

	public static PropGrab[] all;

	public int spawnCount = 5;

	private void Start()
	{
		for (int i = 0; i < spawnCount; i++)
		{
			UnityEngine.Object.Instantiate(swordPrefab, base.transform.position + Vector3.up * i, Quaternion.Euler(UnityEngine.Random.insideUnitSphere), base.transform);
		}
		all = GetComponentsInChildren<PropGrab>();
	}

	private void Update()
	{
	}
}
public class TableSmashAchievementCheck : MonoBehaviour
{
	public static TableSmashAchievementCheck instance;

	public List<SceneryBreakable> breakables;

	private void Awake()
	{
		instance = this;
	}

	public void Remove(SceneryBreakable breakable)
	{
		breakables.Remove(breakable);
		if (breakables.Count == 0)
		{
			AchievementsController.achievement("Vandal");
		}
	}

	private void Update()
	{
	}
}
public class TakePhoto : MonoBehaviour
{
	public enum Format
	{
		Jpg,
		Png
	}

	public bool takePhoto;

	public int width = 256;

	public int height;

	private Camera cam;

	public string photoFolder;

	public string fileName;

	public AudioClip photoSound;

	private AudioSource audioSource;

	public bool disableOnLoad;

	public bool alignToSceneView;

	public Format format;

	private void Start()
	{
		if (height == 0)
		{
			height = width;
		}
		cam = GetComponent<Camera>();
		audioSource = base.gameObject.AddComponent<AudioSource>();
		if (audioSource == null)
		{
			audioSource = base.gameObject.AddComponent<AudioSource>();
		}
		if (disableOnLoad)
		{
			base.gameObject.SetActive(value: false);
		}
	}

	private void Update()
	{
		if (takePhoto)
		{
			takePhoto = false;
			_ = alignToSceneView;
			takePic();
		}
	}

	private void takePic()
	{
		takePhoto = false;
		if (fileName == "")
		{
			UnityEngine.Debug.LogError("No file to take photo: " + base.name);
			return;
		}
		RenderTexture active = RenderTexture.active;
		RenderTexture renderTexture = new RenderTexture(width, height, 24, RenderTextureFormat.ARGB32);
		cam.targetTexture = renderTexture;
		cam.Render();
		DumpRenderTexture(renderTexture, photoFolder + "/" + fileName);
		cam.targetTexture = active;
		audioSource.PlayOneShot(photoSound);
	}

	public void DumpRenderTexture(RenderTexture rt, string outPath)
	{
		RenderTexture active = RenderTexture.active;
		Texture2D texture2D = new Texture2D(rt.width, rt.height);
		RenderTexture.active = rt;
		texture2D.ReadPixels(new Rect(0f, 0f, rt.width, rt.height), 0, 0);
		texture2D.Apply();
		if (format == Format.Jpg)
		{
			File.WriteAllBytes(outPath, texture2D.EncodeToJPG());
		}
		else
		{
			File.WriteAllBytes(outPath, texture2D.EncodeToPNG());
		}
		RenderTexture.active = active;
	}
}
public class TargetController : HitSurface
{
	public float ringRadiusStep = 0.2f;

	public int scoreMod = 1;

	public DaggerGameController daggerGame;

	private void Start()
	{
	}

	public override void ProjectileHit(ProjectileController projectile, Vector3 point, Vector3 normal)
	{
		float num = Mathf.Round((point - base.transform.position).magnitude * 100f) / 100f;
		int num2 = ((num < 0.16f) ? 20 : ((num < 0.36f) ? 10 : ((num < 0.56f) ? 5 : ((!(num < 0.76f)) ? 1 : 2))));
		num2 *= scoreMod;
		if (projectile.fromGrab)
		{
			daggerGame.score += num2;
			string text = LocalisationController.replaceText("General", "Score: +[x]", num2.ToString());
			CanvasController.addText(localise: false, text, point, Color.cyan, 2f, base.transform);
		}
		else
		{
			CanvasController.addText(localise: false, num2.ToString(), point, Color.white, 2f, base.transform);
		}
	}

	private void Update()
	{
	}
}
public class TextureScroller : MonoBehaviour
{
	private MeshRenderer renderer;

	public string mainTexture = "_MainTex";

	private Vector2 mainOffset;

	public float multiply = 1f;

	public Vector2 mainSpeed;

	private void Start()
	{
		renderer = GetComponent<MeshRenderer>();
	}

	private void Update()
	{
		mainOffset += mainSpeed * Time.deltaTime * multiply;
		mainOffset.x = Mathf.Repeat(mainOffset.x, 1f);
		mainOffset.y = Mathf.Repeat(mainOffset.y, 1f);
		renderer.material.SetTextureOffset(mainTexture, mainOffset);
	}
}
public class TigerClawController : MonoBehaviour
{
	public RigidBodies rigidBodies;

	public GameObject hitPersonEffect;

	public AudioClip hitSound;

	public AudioClip hitOtherSound;

	public BoxCollider boxCollider;

	public GameObject trails;

	public TransformData leftHandData;

	public TransformData rightHandData;

	private AudioSource audioSource;

	private Rigidbody rb;

	private float hitTime;

	private int hitCount;

	private int collisions;

	private Hittable lastHitObject;

	private FixedJoint joint;

	private float allowHitNonDamage;

	private void Start()
	{
		audioSource = GetComponent<AudioSource>();
		rb = GetComponent<Rigidbody>();
	}

	public bool timeCheck(int max, Hittable hit)
	{
		if (lastHitObject != hit)
		{
			lastHitObject = hit;
			hitTime = Time.time;
			return true;
		}
		bool result = hitTime + 0.5f * Time.timeScale < Time.time;
		hitTime = Time.time;
		return result;
	}

	private void OnCollisionEnter(Collision collision)
	{
		if (rb.velocity.magnitude < 2f)
		{
			return;
		}
		Hittable component = collision.collider.GetComponent<Hittable>();
		if (component == null)
		{
			audioSource.PlayOneShot(hitOtherSound);
		}
		else
		{
			if (!timeCheck(1, component))
			{
				return;
			}
			if (component.bodyPart == null)
			{
				audioSource.PlayOneShot(hitOtherSound);
				return;
			}
			if (component.bodyPart.knockDownPerc < 0.8f)
			{
				if (Time.time < allowHitNonDamage)
				{
					return;
				}
				allowHitNonDamage = Time.time + 1f;
			}
			if (component.rb.character.team != rigidBodies.character.team)
			{
				float num = Mathf.Clamp01(rb.velocity.magnitude / 10f) * component.bodyPart.knockDownPerc;
				if (hitPersonEffect != null)
				{
					UnityEngine.Object.Instantiate(hitPersonEffect, collision.contacts[0].point, Quaternion.LookRotation(collision.contacts[0].normal), null);
				}
				component.rb.Hit(rb.velocity, component, rigidBodies.character, num * 0.25f, num * 0.5f, collision.contacts[0].point, Hittable.HandHitType.General, skipPressurePoints: true, "Tiger Claw");
				component.rb.setLastHit(RigidBodies.LastHit.SpecialMove, collision.contacts[0].point);
				component.rb.character.ProjectileHitVoice();
				audioSource.PlayOneShot(hitSound);
			}
		}
	}
}
public class TigerClawEffect : SpecialMoveAttachedEffect
{
	public TigerClawController clawPrefab;

	public TigerClawController l_claw;

	public TigerClawController r_claw;

	public override void setup(GameCharacter character)
	{
		Transform transform = character.rigidBodies.leftHand.muscle.transform;
		Transform transform2 = character.rigidBodies.rightHand.muscle.transform;
		l_claw = UnityEngine.Object.Instantiate(clawPrefab, transform);
		l_claw.leftHandData.setToLocal(l_claw.transform);
		l_claw.rigidBodies = character.rigidBodies;
		l_claw.gameObject.AddComponent<FixedJoint>().connectedBody = transform.GetComponent<Rigidbody>();
		r_claw = UnityEngine.Object.Instantiate(clawPrefab, transform2);
		r_claw.rightHandData.setToLocal(r_claw.transform);
		r_claw.rigidBodies = character.rigidBodies;
		r_claw.gameObject.AddComponent<FixedJoint>().connectedBody = transform2.GetComponent<Rigidbody>();
	}

	public override void end()
	{
		UnityEngine.Object.Destroy(r_claw.gameObject);
		UnityEngine.Object.Destroy(l_claw.gameObject);
	}
}
[Serializable]
public class TimeSlow
{
	public enum Type
	{
		None,
		Change,
		InstantOn
	}

	public Type type;

	public float amount = 0.95f;

	public float changeTime = 2f;

	public SlowMo doIt()
	{
		if (type == Type.None)
		{
			return null;
		}
		if (amount == 0f)
		{
			amount = 0.95f;
		}
		if (changeTime == 0f)
		{
			changeTime = 2f;
		}
		return HitEffects.timeSlow(amount, changeTime, type == Type.InstantOn);
	}
}
public class TipCanvasController : MonoBehaviour
{
	public float alpha;

	public TextMeshProUGUI text;

	public string origText;

	private float alphaTarget;

	private void Start()
	{
		if ((double)(text.transform.position - base.transform.position).magnitude > 0.1)
		{
			UnityEngine.Debug.LogError("Move the whole tip: " + text.text);
			text.transform.position = base.transform.position;
		}
		origText = text.text;
	}

	public void refresh()
	{
		text.text = LocalisationController.getText("Tutorial", origText);
	}

	private string replace(string txt)
	{
		string[] array = new string[3] { "[Dash]", "[Special]", "[Squeeze]" };
		string[] array2 = new string[3];
		array2 = new string[3]
		{
			GameController.instance.gameData.vrProfile.dash,
			GameController.instance.gameData.vrProfile.special,
			GameController.instance.gameData.vrProfile.makeFist
		};
		for (int i = 0; i < array.Length; i++)
		{
			txt = txt.Replace(array[i], LocalisationController.getText("General", array2[i]));
		}
		return txt;
	}

	private void Update()
	{
		if (LocalisationController.instance.refresh)
		{
			UnityEngine.Debug.LogError("Refrehs this");
		}
		if (GameController.instance == null)
		{
			return;
		}
		if (GameController.instance.player != null)
		{
			Vector3 forward = GameController.instance.player.standPosition - base.transform.position;
			forward.y = 0f;
			if (forward.magnitude < 2f)
			{
				alphaTarget = 1f;
			}
			else
			{
				alphaTarget = Mathf.Clamp01(1f - (forward.magnitude - 2f) / 2.5f);
			}
			Quaternion b = Quaternion.LookRotation(-base.transform.forward);
			if (Quaternion.Angle(Quaternion.LookRotation(forward), b) > 90f)
			{
				alphaTarget = 0f;
			}
			else if (forward.magnitude < 0.3f)
			{
				alphaTarget = 0f;
			}
		}
		else
		{
			alphaTarget = 0f;
		}
		alpha = Mathf.MoveTowards(alpha, alphaTarget, Time.deltaTime);
		if (alpha > 0f)
		{
			text.text = replace(text.text);
		}
		text.color = Color.white * alpha;
	}
}
public class Tools
{
	public static Vector3 RoundVector3(Vector3 vec, int decimalPoints = 0)
	{
		vec *= Mathf.Pow(10f, decimalPoints);
		vec.x = Mathf.Round(vec.x);
		vec.y = Mathf.Round(vec.y);
		vec.z = Mathf.Round(vec.z);
		vec /= Mathf.Pow(10f, decimalPoints);
		return vec;
	}

	public static Vector3 FlatVector3(Vector3 vec)
	{
		vec.y = 0f;
		return vec;
	}

	public static Vector3 deadZone(Vector3 vec, float deadZoneSize = 0.4f)
	{
		if (vec.magnitude < deadZoneSize)
		{
			return Vector3.zero;
		}
		return (vec - vec.normalized * deadZoneSize) / (1f - deadZoneSize);
	}

	public static float deadZone(float num, float deadZoneSize = 0.4f)
	{
		if (Mathf.Abs(num) < deadZoneSize)
		{
			return 0f;
		}
		if (num > 0f)
		{
			return (num - deadZoneSize) / (1f - deadZoneSize);
		}
		return (0f - (0f - num - deadZoneSize)) / (1f - deadZoneSize);
	}
}
public class TrailIfOverSpeed : MonoBehaviour
{
	public float minSpeed = 1f;

	private Vector3 lastPos;

	private TrailRenderer trail;

	private void Start()
	{
		trail = GetComponent<TrailRenderer>();
	}

	private void Update()
	{
		float num = (base.transform.position - lastPos).magnitude / Time.deltaTime;
		lastPos = base.transform.position;
		trail.emitting = num >= minSpeed;
	}
}
[Serializable]
public class TransformData
{
	public Vector3 position = new Vector3(0f, 0f, 0f);

	public Vector3 rotation = new Vector3(0f, 0f, 0f);

	public Vector3 scale = new Vector3(1f, 1f, 1f);

	public void setToLocal(Transform t)
	{
		t.localPosition = position;
		t.localRotation = Quaternion.Euler(rotation);
		t.localScale = scale;
	}
}
public class TurnWithKeys : MonoBehaviour
{
	public KeyCode turnLeft;

	public KeyCode turnRight;

	public KeyCode turnUp;

	public KeyCode turnDown;

	public KeyCode moveForward;

	public KeyCode moveBack;

	public float turnSpeed = 30f;

	public float moveSpeed = 1f;

	private void Start()
	{
	}

	private void Update()
	{
		if (Input.GetKey(turnLeft))
		{
			base.transform.localRotation *= Quaternion.Euler(0f, (0f - turnSpeed) * Time.deltaTime, 0f);
		}
		if (Input.GetKey(turnRight))
		{
			base.transform.localRotation *= Quaternion.Euler(0f, turnSpeed * Time.deltaTime, 0f);
		}
		if (Input.GetKey(turnUp))
		{
			base.transform.localRotation *= Quaternion.Euler((0f - turnSpeed) * Time.deltaTime, 0f, 0f);
		}
		if (Input.GetKey(turnDown))
		{
			base.transform.localRotation *= Quaternion.Euler(turnSpeed * Time.deltaTime, 0f, 0f);
		}
		if (Input.GetKey(moveForward))
		{
			base.transform.localPosition += base.transform.forward * moveSpeed * Time.deltaTime;
		}
		if (Input.GetKey(moveBack))
		{
			base.transform.localPosition -= base.transform.forward * moveSpeed * Time.deltaTime;
		}
	}
}
public class VRCharacterActions : MonoBehaviour
{
	public VRRig picoRig;

	[Header("Pico Actions")]
	public Pvr_KeyCode dashAction_pico;

	public Pvr_KeyCode specialMoveAction_pico;

	public Pvr_KeyCode spectateAction_pico;

	public Pvr_KeyCode testAction_pico;

	public Pvr_KeyCode pauseAction_pico;

	public Pvr_KeyCode squeeze_pico;

	public Pvr_KeyCode squeezeSecondary_pico_l;

	public Pvr_KeyCode squeezeSecondary_pico_r;

	public Pvr_KeyCode grab_pico;

	public Pvr_KeyCode nextAIModeAction_pico;

	public Pvr_KeyCode showMenuAction_pico;

	[Header("Keybaord Actions")]
	public KeyCode pause_key;

	public KeyCode spectate_key;

	public KeyCode pauseUnity_key;

	public KeyCode test_key;

	private int rightThumbDirection;

	private int rightThumbDirection_was;

	private bool rightThumbDirectionChange;

	private void Update()
	{
		Vector2 vector = Controller.UPvr_GetAxis2D(1);
		if (Application.isEditor)
		{
			if (Input.GetKey(KeyCode.RightArrow))
			{
				vector.x += 1f;
			}
			if (Input.GetKey(KeyCode.LeftArrow))
			{
				vector.x -= 1f;
			}
			if (Input.GetKey(KeyCode.UpArrow))
			{
				vector.y += 1f;
			}
			if (Input.GetKey(KeyCode.DownArrow))
			{
				vector.y -= 1f;
			}
		}
		if (vector.magnitude > 0.75f)
		{
			if (Mathf.Abs(vector.x) > Mathf.Abs(vector.y))
			{
				rightThumbDirection = ((vector.x > 0f) ? 2 : 4);
			}
			else
			{
				rightThumbDirection = ((vector.y > 0f) ? 1 : 3);
			}
		}
		else if (vector.magnitude < 0.5f)
		{
			rightThumbDirection = 0;
		}
		rightThumbDirectionChange = rightThumbDirection != rightThumbDirection_was;
		rightThumbDirection_was = rightThumbDirection;
	}

	public bool rightThumbDown(int direction)
	{
		if (!rightThumbDirectionChange)
		{
			return false;
		}
		return rightThumbDirection == direction;
	}

	public VRRig activeRig()
	{
		return picoRig;
	}

	public void Activate()
	{
		picoRig.gameObject.SetActive(value: true);
	}

	public bool nextAIMode()
	{
		return false;
	}

	public bool pauseUnity()
	{
		return Input.GetKey(pauseUnity_key);
	}

	public bool showMenu()
	{
		return false;
	}

	public Vector2 move()
	{
		if (Application.isEditor)
		{
			Vector2 result = default(Vector3);
			if (Input.GetKey(KeyCode.D))
			{
				result.x += 1f;
			}
			if (Input.GetKey(KeyCode.A))
			{
				result.x -= 1f;
			}
			if (Input.GetKey(KeyCode.W))
			{
				result.y += 1f;
			}
			if (Input.GetKey(KeyCode.S))
			{
				result.y -= 1f;
			}
			return result;
		}
		return Controller.UPvr_GetAxis2D(0);
	}

	public bool dash()
	{
		return Controller.UPvr_GetKeyDown(1, dashAction_pico);
	}

	public bool jump()
	{
		return rightThumbDown(1);
	}

	public bool kick()
	{
		return rightThumbDown(3);
	}

	public bool specialMove()
	{
		return Controller.UPvr_GetKeyDown(1, specialMoveAction_pico);
	}

	public bool spectate()
	{
		if (!Controller.UPvr_GetKey(0, spectateAction_pico))
		{
			return Input.GetKey(spectate_key);
		}
		return true;
	}

	public bool test()
	{
		if (!Controller.UPvr_GetKeyDown(0, testAction_pico))
		{
			return Input.GetKeyDown(test_key);
		}
		return true;
	}

	public bool pause()
	{
		if (!Controller.UPvr_GetKeyDown(0, pauseAction_pico))
		{
			return Input.GetKeyDown(pause_key);
		}
		return true;
	}

	public float turn()
	{
		return Controller.UPvr_GetAxis2D(1).x;
	}

	public float squeezeSecondary(bool right)
	{
		return Controller.UPvr_GetAxis1D(right ? 1 : 0, right ? squeezeSecondary_pico_r : squeezeSecondary_pico_l);
	}

	public float squeeze(bool right)
	{
		return Controller.UPvr_GetAxis1D(right ? 1 : 0, squeeze_pico);
	}
}
public class VRCharacterController : MonoBehaviour
{
	public GameCharacter gameCharacter;

	public VRIK ik;

	public Vector3 standPos;

	public CapsuleCollider footCollider;

	public CapsuleCollider headCollider;

	private Vector3 lastHeadPosition;

	public float footHeightOffset;

	public float colliderRadius = 0.3f;

	private List<Collision> collisions = new List<Collision>();

	public float ySpeed;

	public LayerMask scenery;

	public bool onGround;

	public float heightOffGround;

	public float jumpPower = 4.5f;

	private void Start()
	{
		Physics.IgnoreCollision(footCollider, headCollider);
	}

	public void jump()
	{
		if (!(gameCharacter.rigidBodies.jumpPerc > 0f) && GameController.instance.movingAllowed && (onGround || !(gameCharacter.vrCharacterController.heightOffGround > 0.2f)) && !(gameCharacter.vrCharacterController.ySpeed > 0.1f))
		{
			float num = Mathf.Clamp01(gameCharacter.walkSpeedMod());
			ySpeed = num * jumpPower;
			gameCharacter.rigidBodies.footSoundSources[0].playJumpSound(start: true);
		}
	}

	public void gravity()
	{
		float num = 0.5f;
		float num2 = 0.3f;
		if (Physics.SphereCast(footCollider.transform.position + Vector3.up * num, num2, Vector3.down, out var hitInfo, 10f, scenery, QueryTriggerInteraction.Ignore))
		{
			heightOffGround = hitInfo.distance - num + num2 - 0.1f;
			bool flag = !onGround;
			if (heightOffGround <= 0f)
			{
				if (!onGround)
				{
					onGround = true;
				}
				if (onGround && flag)
				{
					gameCharacter.rigidBodies.land(ySpeed);
				}
				base.transform.parent.position += (0f - heightOffGround) * Vector3.up;
				if (ySpeed < 0f)
				{
					ySpeed = 0f;
				}
			}
			else
			{
				onGround = heightOffGround <= 0.1f && ySpeed <= 0f;
				if (onGround && flag)
				{
					gameCharacter.rigidBodies.land(ySpeed);
				}
				if (onGround)
				{
					base.transform.parent.position += (0f - heightOffGround) * Vector3.up;
				}
			}
		}
		else
		{
			heightOffGround = 10f;
		}
		if (ySpeed >= 0f || !onGround)
		{
			base.transform.parent.position += Vector3.up * ySpeed * Time.deltaTime;
			ySpeed -= 10f * Time.deltaTime;
		}
		else
		{
			ySpeed = 0f;
		}
	}

	private void Update()
	{
		if (!GameController.instance.paused && !gameCharacter.rigidBodies.isDown(allTheWay: true) && !(ik == null) && !(ik.references.leftFoot == null))
		{
			moveBackByRB();
			gravity();
			headCollider.transform.position = Vector3.MoveTowards(headCollider.transform.position, ik.solver.spine.headTarget.position, Time.deltaTime);
			headCollider.height = (headCollider.transform.position - (footCollider.transform.position + Vector3.up)).magnitude + headCollider.radius * 2f;
			if (headCollider.height > 1f)
			{
				headCollider.transform.position -= headCollider.transform.forward * (headCollider.height - 1f);
				headCollider.height = 1f;
			}
			headCollider.center = Vector3.forward * (0f - headCollider.height / 2f + headCollider.radius);
			headCollider.transform.rotation = Quaternion.RotateTowards(headCollider.transform.rotation, Quaternion.LookRotation(headCollider.transform.position - (footCollider.transform.position + Vector3.up)), Time.deltaTime * 360f);
			standPos = Vector3.Lerp(ik.references.leftFoot.position, ik.references.rightFoot.position, 0.5f);
			Vector3 vector = GameController.flatVector(standPos - headCollider.transform.position);
			float num = vector.magnitude - 0.35f;
			if (num > 0f)
			{
				standPos -= vector.normalized * num;
			}
			footCollider.transform.position = Vector3.MoveTowards(footCollider.transform.position, standPos, Time.deltaTime);
			footCollider.transform.localPosition = GameController.flatVector(footCollider.transform.localPosition) + Vector3.up * footHeightOffset;
			footCollider.radius = colliderRadius;
			float num2 = GameController.instance.standButtons.minimumHeight - 0.1f;
			if (base.transform.parent.position.y < num2)
			{
				base.transform.parent.position = GameController.flatVector(base.transform.parent.position) + Vector3.up * num2;
			}
			keepInBounds();
		}
	}

	private void moveBackByRB()
	{
		if (gameCharacter.rigidBodies.isDown(allTheWay: true))
		{
			return;
		}
		Vector3 vector = base.transform.position - base.transform.parent.position;
		base.transform.parent.position += vector;
		base.transform.position -= vector;
		if (vector.magnitude > 0.01f && ySpeed > 0f && Physics.Raycast(new Ray(gameCharacter.rigidBodies.headHittable.transform.position, Vector3.up), out var hitInfo, 0.5f, scenery))
		{
			HitSurface component = hitInfo.collider.GetComponent<HitSurface>();
			if (component != null)
			{
				ySpeed = 0f;
				component.OnHit(gameCharacter.rigidBodies.headHittable, Hittable.HandHitType.General, 1f, hitInfo.point, hitInfo.normal);
				gameCharacter.rigidBodies.Hit(Vector3.down, gameCharacter.rigidBodies.headHittable, gameCharacter, 1f, 0f, gameCharacter.rigidBodies.headHittable.transform.position, Hittable.HandHitType.General, skipPressurePoints: true, "Ceiling");
			}
		}
		Vector3 vector2 = GameController.flatVector(vector);
		if ((double)vector2.magnitude > 0.01 && vector2.magnitude > gameCharacter.rigidBodies.slide.magnitude)
		{
			gameCharacter.rigidBodies.slide = Vector3.zero;
		}
	}

	public void Move(Vector3 amount)
	{
		if (!(amount.magnitude < Time.deltaTime * 0.5f))
		{
			float num = 0.2f;
			float num2 = 0f;
			if (Physics.Raycast(ik.solver.spine.headTarget.position, amount.normalized, out var hitInfo, num, scenery))
			{
				num2 = num - hitInfo.distance;
			}
			if (Physics.Raycast(standPos + Vector3.up * 0.5f, amount.normalized, out var hitInfo2, num, scenery))
			{
				num2 = Mathf.Max(num2, num - hitInfo2.distance);
			}
			if (num2 > 0f)
			{
				amount -= amount.normalized * num2;
			}
			base.transform.parent.position += amount;
			keepInBounds();
		}
	}

	private void keepInBounds()
	{
		Transform transform = gameCharacter.vrCharacterController.footCollider.transform;
		switch (GameController.instance.standButtons.boundsType)
		{
		case StandButtonsController.BoundsType.Circle:
			if (GameController.flatVector(transform.position).magnitude > GameController.instance.standButtons.boundsSize)
			{
				Vector3 vector2 = GameController.flatVector(transform.position);
				float num = vector2.magnitude - GameController.instance.standButtons.boundsSize;
				base.transform.parent.position -= num * vector2.normalized;
			}
			break;
		case StandButtonsController.BoundsType.Square:
			if (Mathf.Abs(transform.position.x) > GameController.instance.standButtons.boundsSize || Mathf.Abs(transform.position.z) > GameController.instance.standButtons.boundsSize)
			{
				Vector3 vector3 = GameController.flatVector(transform.position);
				Vector3 zero2 = Vector3.zero;
				if (vector3.x > GameController.instance.standButtons.boundsSize)
				{
					zero2.x = vector3.x - GameController.instance.standButtons.boundsSize;
				}
				if (vector3.z > GameController.instance.standButtons.boundsSize)
				{
					zero2.z = vector3.z - GameController.instance.standButtons.boundsSize;
				}
				if (0f - vector3.x > GameController.instance.standButtons.boundsSize)
				{
					zero2.x = 0f - (0f - vector3.x - GameController.instance.standButtons.boundsSize);
				}
				if (0f - vector3.z > GameController.instance.standButtons.boundsSize)
				{
					zero2.z = 0f - (0f - vector3.z - GameController.instance.standButtons.boundsSize);
				}
				base.transform.parent.position -= zero2;
			}
			break;
		case StandButtonsController.BoundsType.Rect:
			if (Mathf.Abs(transform.position.x) > GameController.instance.standButtons.bounds.x || Mathf.Abs(transform.position.z) > GameController.instance.standButtons.bounds.z)
			{
				Vector3 vector = GameController.flatVector(transform.position);
				Vector3 zero = Vector3.zero;
				if (vector.x > GameController.instance.standButtons.bounds.x)
				{
					zero.x = vector.x - GameController.instance.standButtons.bounds.x;
				}
				if (vector.z > GameController.instance.standButtons.bounds.z)
				{
					zero.z = vector.z - GameController.instance.standButtons.bounds.z;
				}
				if (0f - vector.x > GameController.instance.standButtons.bounds.x)
				{
					zero.x = 0f - (0f - vector.x - GameController.instance.standButtons.bounds.x);
				}
				if (0f - vector.z > GameController.instance.standButtons.bounds.z)
				{
					zero.z = 0f - (0f - vector.z - GameController.instance.standButtons.bounds.z);
				}
				base.transform.parent.position -= zero;
			}
			break;
		}
	}

	private void FixedUpdate()
	{
	}

	private void OnCollisionEnter(Collision collision)
	{
		collisions.Add(collision);
	}

	private void OnCollisionExit(Collision collision)
	{
		collisions.Remove(collision);
	}
}
[Serializable]
public class VRControlTip
{
	public enum Type
	{
		LevelStart,
		OnMenu,
		AdHoc
	}

	public string tip;

	public bool leftArrows;

	public bool rightArrows;

	public bool arrow_up;

	public bool arrow_down;

	public bool arrow_left;

	public bool arrow_right;

	public int maxSeen = 3;

	public int seen;

	[NonSerialized]
	public float nextSeeTime;

	public Type type;

	public Pvr_KeyCode[] leftButtons;

	public Pvr_KeyCode[] rightButtons;

	public void localise()
	{
		LocalisationController.getText("Control Tip", tip);
	}
}
public class VRHatController : MonoBehaviour
{
	public Vector3 offset;

	public Vector3 rotationOffset;

	public GlassesController glasses;

	private MeshRenderer meshRenderer;

	private void Start()
	{
		glasses = GetComponent<GlassesController>();
		meshRenderer = GetComponent<MeshRenderer>();
	}

	private void Update()
	{
		base.transform.localPosition = offset;
		base.transform.localRotation = Quaternion.Euler(rotationOffset);
		meshRenderer.enabled = GameController.instance.player != null && GameController.instance.player.playerController.inBody;
	}
}
public class VRMainRigController : MonoBehaviour
{
	public static VRMainRigController instance;

	private VRRig rig;

	public Transform following;

	public VRRig controlling;

	public Transform pointer;

	public FaceHitEffect faceHit;

	public Pvr_UnitySDKHeadTrack headTrack;

	public Pvr_UnitySDKManager manager;

	public static ControllerTipController controllerTips;

	private void Start()
	{
		instance = this;
		rig = GetComponent<VRRig>();
		controllerTips = GetComponent<ControllerTipController>();
		manager = GetComponent<Pvr_UnitySDKManager>();
		if (Application.isEditor)
		{
			headTrack.enabled = false;
			rig.trackers[0].parent.localPosition = Vector3.up * 1.6f;
			rig.trackers[1].parent.localPosition = new Vector3(-0.3f, 1.25f, 0.5f);
			rig.trackers[2].parent.localPosition = new Vector3(0.3f, 1.25f, 0.5f);
		}
	}

	public void refreshFollowing()
	{
		if (GameController.instance.player != null && GameController.instance.player.playerController.inBody)
		{
			following = GameController.instance.player.playerController.activeRig.transform;
			controlling = GameController.instance.player.playerController.activeRig;
		}
		else if ((bool)GameController.instance.noPlayer)
		{
			following = GameController.instance.noPlayer.transform;
			controlling = GameController.instance.noPlayer.activeRig;
		}
		else
		{
			following = null;
			controlling = null;
		}
		controllerTips.refresh();
		if (!(following == null))
		{
			base.transform.position = following.position;
			base.transform.rotation = following.rotation;
			base.transform.localScale = following.localScale;
		}
	}

	private void Update()
	{
		manager.ShowFPS = OptionData.getBool("FPS Display");
		refreshFollowing();
		if (!(controlling == null))
		{
			for (int i = 0; i < 3; i++)
			{
				controlling.trackers[i].localPosition = rig.transform.InverseTransformPoint(rig.trackers[i].position);
				controlling.trackers[i].localRotation = rig.trackers[i].parent.localRotation * rig.trackers[i].localRotation;
			}
		}
	}
}
public class VRMenuActions : MonoBehaviour
{
	public int hand;

	public Pvr_KeyCode key;

	public KeyCode keyboardKey;

	public bool press()
	{
		if (!Controller.UPvr_GetKeyDown(hand, key))
		{
			return Input.GetKeyDown(keyboardKey);
		}
		return true;
	}

	public bool noPlayer()
	{
		if (!Controller.UPvr_GetKeyDown(hand, key))
		{
			return Input.GetKeyDown(keyboardKey);
		}
		return true;
	}

	private void Update()
	{
	}
}
public class VRNonPlayerCamActions : MonoBehaviour
{
	public VRRig rig;

	public Pvr_KeyCode pauseAction_pico;

	public int pauseHand;

	public KeyCode pause_key;

	public void Start()
	{
		rig.gameObject.SetActive(value: true);
	}

	private void Update()
	{
	}

	public VRRig activeRig()
	{
		return rig;
	}

	public void Activate()
	{
	}

	public void Deactivate()
	{
	}

	public float turn()
	{
		return Controller.UPvr_GetAxis2D(1).x;
	}

	public bool pause()
	{
		if (!Controller.UPvr_GetKeyDown(pauseHand, pauseAction_pico))
		{
			return Input.GetKeyDown(pause_key);
		}
		return true;
	}
}
[Serializable]
public class VRProfile
{
	public string name;

	public string modelSearch;

	[Header("Instructions")]
	public string dash;

	public string special;

	public string makeFist;

	[Header("Settings")]
	public bool allowFingerTracking;

	public float moveSensitivity = 1f;
}
public class VRRig : MonoBehaviour
{
	public Transform[] trackers;
}
public class VRRunController : MonoBehaviour
{
	public VRIK ik;

	public float runThreshold = 0.5f;

	public float runSpeed = 2f;

	public float acceleration = 7.5f;

	public float decelleration = 3f;

	private Vector3 leftLastPos;

	private Vector3 rightLastPos;

	public Vector3 moveDirection;

	public Vector3 runMove;

	private void Start()
	{
		if (ik == null)
		{
			ik = GetComponent<VRIK>();
		}
	}

	private void Update()
	{
		if (!(ik == null))
		{
			Quaternion quaternion = Quaternion.Euler(0f, ik.solver.spine.headTarget.localRotation.eulerAngles.y, 0f);
			Vector3 vector = Vector3Int.RoundToInt(quaternion * (ik.solver.leftArm.target.localPosition - leftLastPos) / Time.deltaTime);
			vector.x = 0f;
			Vector3 vector2 = Vector3Int.RoundToInt(quaternion * (ik.solver.rightArm.target.localPosition - rightLastPos) / Time.deltaTime);
			vector2.x = 0f;
			if (vector.magnitude >= runThreshold && vector2.magnitude >= runThreshold)
			{
				float num = acceleration * (Mathf.Clamp01(vector2.magnitude) + Mathf.Clamp01(vector.magnitude)) / 2f;
				runMove = Vector3.MoveTowards(runMove, Vector3.ClampMagnitude(moveDirection, 1f) * runSpeed, Time.deltaTime * num);
			}
			else
			{
				runMove = Vector3.MoveTowards(runMove, Vector3.zero, Time.deltaTime * decelleration);
			}
			leftLastPos = ik.solver.leftArm.target.localPosition;
			rightLastPos = ik.solver.rightArm.target.localPosition;
		}
	}
}
public class VRTrackerContainer : MonoBehaviour
{
	public bool debug;

	public GameCharacter gameCharacter;

	public GameObject[] shapes;

	public Transform[] transforms;

	public Transform lOffset;

	public Transform rOffset;

	public Vector3 rightHandMoved;

	public Vector3 leftHandMoved;

	[Range(0f, 1f)]
	public float rightHandMovedPerc;

	[Range(0f, 1f)]
	public float leftHandMovedPerc;

	public float rightHandSpeed;

	public float leftHandSpeed;

	public float rightTopSpeed;

	public float leftTopSpeed;

	public Vector3 rhPos;

	public Vector3 lhPos;

	private Vector3 lastRPos = Vector3.zero;

	private Vector3 lastLPos = Vector3.zero;

	private float resetSpeed = 15f;

	private float recordTime = 1f;

	private float min = 0.5f;

	private float max = 20f;

	private float hitPercMin = 1f;

	private float turnPause;

	private void Start()
	{
	}

	public void turn()
	{
		turnPause = 0.25f;
	}

	private void Update()
	{
		GameObject[] array = shapes;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetActive(debug);
		}
		leftHandSpeed = Mathf.MoveTowards(leftHandSpeed, 0f, Time.deltaTime * resetSpeed);
		rightHandSpeed = Mathf.MoveTowards(rightHandSpeed, 0f, Time.deltaTime * resetSpeed);
		if (turnPause > 0f)
		{
			turnPause -= Time.deltaTime;
			return;
		}
		if (recordTime > 0f)
		{
			recordTime -= Time.deltaTime;
			return;
		}
		Vector3 localPosition = transforms[1].localPosition;
		Vector3 localPosition2 = transforms[2].localPosition;
		if (lOffset != null)
		{
			localPosition = lOffset.localPosition;
			localPosition2 = rOffset.localPosition;
		}
		if (lastLPos != Vector3.zero)
		{
			leftHandMoved = Vector3.MoveTowards(leftHandMoved, Vector3.zero, Time.deltaTime * 1f);
			rightHandMoved = Vector3.MoveTowards(rightHandMoved, Vector3.zero, Time.deltaTime * 1f);
			leftHandMoved += localPosition - lastLPos;
			rightHandMoved += localPosition2 - lastRPos;
			rightHandMovedPerc = Mathf.Clamp01(rightHandMoved.magnitude);
			leftHandMovedPerc = Mathf.Clamp01(leftHandMoved.magnitude);
		}
		lastLPos = localPosition;
		lastRPos = localPosition2;
		if (rhPos != Vector3.zero)
		{
			float num = (localPosition2 - rhPos).magnitude / Time.deltaTime;
			if (num > min && num < max && num > rightHandSpeed)
			{
				rightTopSpeed = (rightHandSpeed = num);
			}
		}
		rhPos = localPosition2;
		if (lhPos != Vector3.zero)
		{
			float num2 = (localPosition - lhPos).magnitude / Time.deltaTime;
			if (num2 > min && num2 < max && num2 > leftHandSpeed)
			{
				leftTopSpeed = (leftHandSpeed = num2);
			}
		}
		lhPos = localPosition;
		leftHandSpeed = Mathf.MoveTowards(leftHandSpeed, 0f, Time.deltaTime * resetSpeed);
		rightHandSpeed = Mathf.MoveTowards(rightHandSpeed, 0f, Time.deltaTime * resetSpeed);
		hitPercMin = Mathf.MoveTowards(hitPercMin, 0.5f, Time.deltaTime / 2f);
	}

	public float speedPerc(bool right)
	{
		return Mathf.Clamp01((right ? rightHandMoved.magnitude : leftHandMoved.magnitude) / 0.3f);
	}

	public bool speedCheck(bool right, bool isPlayer)
	{
		bool flag = (double)leftHandMoved.magnitude > 0.04;
		bool flag2 = (double)rightHandMoved.magnitude > 0.04;
		if (turnPause > 0f)
		{
			return false;
		}
		if (!isPlayer)
		{
			hitPercMin = 1.5f * Time.timeScale;
		}
		if ((right && rightHandSpeed >= hitPercMin && flag2) || (!right && leftHandSpeed >= hitPercMin && flag))
		{
			hitPercMin = 1.5f;
			return true;
		}
		return false;
	}
}
[Serializable]
public class VectorSavable
{
	public float x;

	public float y;

	public float z;

	public VectorSavable(float x = 0f, float y = 0f, float z = 0f)
	{
		this.x = x;
		this.y = y;
		this.z = z;
	}

	public Vector3 getVector()
	{
		return new Vector3(x, y, z);
	}

	public void setVector(Vector3 vector)
	{
		x = vector.x;
		y = vector.y;
		z = vector.z;
	}
}
[Serializable]
public class Version
{
	public string prefix;

	public int primary;

	public int major;

	public int minor;

	public string status;

	public bool allowed;

	public override string ToString()
	{
		if (prefix != "")
		{
			return prefix + " " + primary + "." + major + "." + minor;
		}
		return primary + "." + major + "." + minor;
	}
}
[Serializable]
public class VoiceData
{
	public enum Type
	{
		Intro,
		IntroOnReturn,
		OnRestart,
		OnWin,
		AfterWeaponHit,
		AfterDelay,
		AfterSpecialHit,
		OnWinFinal,
		Hurt
	}

	public enum Restriction
	{
		Any,
		SpecificCharacter,
		SameFaction,
		NotSameFaction,
		YoungOnly,
		ContainsWordInName,
		SpecificFaction,
		ChineseOnly,
		AsianOnly
	}

	public string words;

	public Type type;

	public AudioClip clip;

	public Restriction restriction;

	public string extraParameter;

	[NonSerialized]
	public int useCount;

	[NonSerialized]
	public float orderNum;

	public float nextUseTime;

	public bool restrictionAllow(CharacterData thisCharacter, CharacterData otherCharacter, float randomAmount)
	{
		if (Time.time < nextUseTime)
		{
			return false;
		}
		if (UnityEngine.Random.value > randomAmount)
		{
			return false;
		}
		switch (restriction)
		{
		case Restriction.SpecificCharacter:
			if (extraParameter.Contains("|"))
			{
				string[] array = extraParameter.Split('|');
				foreach (string text in array)
				{
					if (otherCharacter.name == text)
					{
						return true;
					}
				}
			}
			return otherCharacter.name == extraParameter;
		case Restriction.ChineseOnly:
			return otherCharacter.race == CharacterData.Race.Chinese;
		case Restriction.AsianOnly:
			if (otherCharacter.race != 0)
			{
				return thisCharacter.race == CharacterData.Race.Japanese;
			}
			return true;
		case Restriction.SameFaction:
			return thisCharacter.home == otherCharacter.home;
		case Restriction.NotSameFaction:
			return thisCharacter.home != otherCharacter.home;
		case Restriction.ContainsWordInName:
			return otherCharacter.name.Contains(extraParameter);
		case Restriction.SpecificFaction:
			return otherCharacter.home == (LocationData.HomeLocation)int.Parse(extraParameter);
		case Restriction.YoungOnly:
			return otherCharacter.young;
		default:
			return true;
		}
	}
}
public class test : MonoBehaviour
{
	public GameObject pivot;

	private void Start()
	{
		Camera main = Camera.main;
		for (int i = 1; i < 6; i++)
		{
			GameObject obj = UnityEngine.Object.Instantiate(main.gameObject);
			obj.transform.SetParent(pivot.transform, worldPositionStays: false);
			obj.transform.rotation = Quaternion.Euler(0f, i * 60, 0f);
			obj.GetComponent<Camera>().rect = new Rect(0.16f * (float)i, 0f, 0.16f, 1f);
			UnityEngine.Object.Destroy(obj.GetComponent<AudioListener>());
		}
	}

	private void Update()
	{
	}
}
public class Vomitter : MonoBehaviour
{
	private float floatHitTestSpawnTimer;

	public float hitTestInterval;

	public float speedPerc;

	public float spawnDuration = 3f;

	public float spawnPerc;

	public Transform spawnPoint;

	public WineBottleHitTest hitTestPrefab;

	private SpecialMoveController move;

	private void Start()
	{
		spawnPerc = 1f;
		move = GetComponent<SpecialMoveController>();
	}

	private void Update()
	{
		if (!(spawnPerc <= 0f))
		{
			floatHitTestSpawnTimer -= Time.deltaTime * spawnPerc;
			spawnPerc -= Time.deltaTime / spawnDuration;
			if (floatHitTestSpawnTimer < 0f)
			{
				floatHitTestSpawnTimer += hitTestInterval;
				WineBottleHitTest wineBottleHitTest = UnityEngine.Object.Instantiate(hitTestPrefab, spawnPoint.position, spawnPoint.rotation, null);
				wineBottleHitTest.velocity = base.transform.forward * speedPerc;
				wineBottleHitTest.firer = move.character;
			}
		}
	}
}
public class WalkTest : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
		Vector3 vector = Camera.main.transform.position + Camera.main.transform.forward;
		if ((vector - base.transform.position).magnitude < 1f)
		{
			vector = Camera.main.transform.position;
		}
		Quaternion quaternion = Quaternion.LookRotation(vector - base.transform.position);
		if (Quaternion.Angle(base.transform.rotation, quaternion) < 10f && (vector - base.transform.position).magnitude > 1f)
		{
			base.transform.position += base.transform.forward * Time.deltaTime;
		}
		base.transform.rotation = Quaternion.RotateTowards(base.transform.rotation, quaternion, 180f * Time.deltaTime);
	}
}
public class WatcherFace : MonoBehaviour
{
	public Transform[] eyes;

	public Vector3 rotationOffset;

	private float changeLooktimer = 1f;

	public Transform jaw;

	public float jawClosedX;

	private void Start()
	{
		jawClosedX = 0f - (jaw.localRotation.eulerAngles.x - 180f);
	}

	private void updateJaw()
	{
		jaw.localRotation = Quaternion.Euler(jawClosedX, 0f, 0f);
	}

	private void LateUpdate()
	{
		updateJaw();
		if (!(GameController.instance == null) && !(GameController.instance.player == null))
		{
			Transform head = GameController.instance.player.rigidBodies.head;
			Quaternion b = Quaternion.LookRotation(head.position - base.transform.position);
			Quaternion quaternion = Quaternion.LookRotation(base.transform.parent.forward);
			if (Quaternion.Angle(quaternion, b) > 50f)
			{
				base.transform.rotation = Quaternion.RotateTowards(base.transform.rotation, quaternion, 45f * Time.deltaTime);
			}
			else
			{
				base.transform.rotation = Quaternion.Lerp(quaternion, b, 0.7f);
			}
			Transform[] array = eyes;
			foreach (Transform transform in array)
			{
				Quaternion rotation = Quaternion.LookRotation(head.position + head.up * 0.07f - transform.position) * Quaternion.Euler(rotationOffset);
				transform.transform.rotation = rotation;
			}
		}
	}
}
public class WaterScroller : MonoBehaviour
{
	private MeshRenderer renderer;

	public string mainTexture = "_MainTex";

	public string detailTexture = "_DetailNormalMap";

	private Vector2 mainOffset;

	private Vector2 detailOffset;

	public float multiply = 1f;

	public Vector2 mainSpeed;

	public Vector2 detailSpeed;

	public GameObject splashPrefab;

	private Collider collider;

	private float lastSplash;

	public float minTime = 1f;

	private void Start()
	{
		renderer = GetComponent<MeshRenderer>();
	}

	private void OnTriggerEnter(Collider other)
	{
		if (!(lastSplash + minTime > Time.time))
		{
			if (collider == null)
			{
				collider = GetComponent<Collider>();
			}
			GameObject obj = UnityEngine.Object.Instantiate(splashPrefab, null);
			obj.transform.position = collider.ClosestPoint(other.transform.position);
			UnityEngine.Object.Destroy(obj, 5f);
			lastSplash = Time.time;
		}
	}

	private void Update()
	{
		mainOffset += mainSpeed * Time.deltaTime * multiply;
		detailOffset += detailSpeed * Time.deltaTime * multiply;
		mainOffset.x = Mathf.Repeat(mainOffset.x, 1f);
		mainOffset.y = Mathf.Repeat(mainOffset.y, 1f);
		detailOffset.x = Mathf.Repeat(detailOffset.x, 1f);
		detailOffset.y = Mathf.Repeat(detailOffset.y, 1f);
		renderer.material.SetTextureOffset(mainTexture, mainOffset);
		renderer.material.SetTextureOffset(detailTexture, detailOffset);
	}
}
public class WeaponContoller : MonoBehaviour
{
	public AudioClip hitSound;

	private AudioSource audioSource;

	public PuppetMasterProp prop;

	public Rigidbody rb;

	private void Start()
	{
		prop = GetComponent<PuppetMasterProp>();
		rb = prop.GetRigidbody();
	}

	private void OnCollisionEnter(Collision collision)
	{
		audioSource = base.gameObject.AddComponent<AudioSource>();
		audioSource.spatialBlend = 1f;
		audioSource.PlayOneShot(hitSound);
	}

	private void Update()
	{
	}
}
public class WebLogging : MonoBehaviour
{
	public delegate void OnDone();

	public delegate void OnFail(bool allowPlay);

	public static WebLogging instance;

	public string gameName;

	public string sessionID;

	public string version;

	public string url;

	[TextArea(5, 5)]
	public string response;

	public bool logEditorSessions;

	private void Awake()
	{
		UnityEngine.Debug.Log("Webserver init");
		url = "Initialised";
		instance = this;
		sessionID = AnalyticsSessionInfo.sessionId.ToString();
		response = "Ready...";
	}

	public static void log(string logType, string dataLabel, float numberValue)
	{
		string text = "";
		text += "username=PicoUser&";
		text = text + "game=" + instance.gameName + "&";
		text = text + "session=" + instance.sessionID + "&";
		text = text + "logType=" + logType + "&";
		text = text + "dataLabel=" + dataLabel + "&";
		text = text + "numberValue=" + numberValue + "&";
		text = text + "gameVersion=" + instance.version + "&";
		if (Application.isEditor && !instance.logEditorSessions)
		{
			instance.response = "Ignored logging, cos editor: " + text;
		}
		else
		{
			instance.doSend(text);
		}
	}

	private void doSend(string data)
	{
		StartCoroutine(sendData(data));
	}

	private IEnumerator sendData(string data)
	{
		url = "https://www.benoldinggames.co.uk/logging/log.asp?" + data;
		UnityEngine.Debug.Log("Send: " + url);
		UnityWebRequest www = UnityWebRequest.Get(url);
		yield return www.SendWebRequest();
		string text = www.downloadHandler.text;
		response = text;
	}
}
public class WinLoseDisplay : MonoBehaviour
{
	public TextMeshProUGUI messageText;

	public TextMeshProUGUI extraMessageText;

	public Transform following;

	public bool halfWay;

	public bool fadeOut;

	public GameObject starContainer;

	public Image[] stars;

	public Sprite onSprite;

	public Sprite offSprite;

	private int existingStars;

	private int newStars;

	private float colourPerc;

	public Color extraColourFlash;

	private void Start()
	{
		base.gameObject.SetActive(value: false);
	}

	public void showWin(int existingStars, int newStars, string extra)
	{
		show(LocalisationController.getText("Win/Lose", "Winner"), null, halfWay: false, fadeOut: false, 1, extra);
		this.existingStars = existingStars;
		this.newStars = newStars;
		for (int i = 0; i < stars.Length; i++)
		{
			if (i < existingStars || i < newStars)
			{
				stars[i].sprite = onSprite;
			}
			else
			{
				stars[i].sprite = offSprite;
			}
		}
		starContainer.SetActive(value: true);
		Invoke("winChecks", 0.5f);
	}

	private void winChecks()
	{
		AchievementsController.instance.onWinChecks();
	}

	public void show(string message, Transform follow, bool halfWay, bool fadeOut, int soundID, string extra = "")
	{
		extraMessageText.text = "";
		messageText.text = message;
		messageText.alpha = 1f;
		following = follow;
		if (extra != "")
		{
			extraMessageText.text = extra;
			extraMessageText.transform.localPosition = new Vector3(0f, -70f, -20f);
		}
		this.halfWay = halfWay;
		this.fadeOut = fadeOut;
		if (soundID > -1)
		{
			GeneralSounds.playSound(soundID, 0.7f);
		}
		starContainer.SetActive(value: false);
		base.gameObject.SetActive(value: true);
	}

	private void Update()
	{
		if (GameController.instance.player == null)
		{
			base.gameObject.SetActive(value: false);
			return;
		}
		if (starContainer.activeInHierarchy)
		{
			for (int i = 0; i < stars.Length; i++)
			{
				if (i < existingStars || i >= newStars)
				{
					stars[i].color = Color.white;
				}
				else
				{
					stars[i].color = Color.Lerp(Color.white, Color.gray, colourPerc);
				}
			}
		}
		extraMessageText.transform.localPosition = Vector3.MoveTowards(extraMessageText.transform.localPosition, new Vector3(0f, 190f, -10f), Time.deltaTime * 100f);
		if (colourPerc == 1f)
		{
			colourPerc = 0f;
		}
		else
		{
			colourPerc = Mathf.MoveTowards(colourPerc, 1f, Time.deltaTime);
		}
		extraMessageText.color = Color.Lerp(Color.white, extraColourFlash, colourPerc);
		if (Camera.main != null)
		{
			Vector3 forward = Camera.main.transform.position - base.transform.position;
			forward.y = 0f;
			base.transform.rotation = Quaternion.LookRotation(forward);
		}
		if (following == null)
		{
			base.transform.position = GameController.instance.player.rigidBodies.head.transform.position;
		}
		else if (halfWay)
		{
			base.transform.position = following.position + (Camera.main.transform.position - following.position) / 2f;
		}
		else
		{
			base.transform.position = following.position;
		}
		if (fadeOut)
		{
			messageText.alpha -= Time.deltaTime / 2f;
			if (messageText.alpha <= 0f)
			{
				base.gameObject.SetActive(value: false);
			}
		}
	}
}
public class WineBottleController : MonoBehaviour
{
	public ParticleSystem[] particles;

	public Transform spout;

	public WineBottleHitTest hitTestPrefab;

	private bool playing;

	public float angle;

	[Range(0f, 1f)]
	public float speedPerc;

	public float hitTestInterval;

	private float floatHitTestSpawnTimer;

	public float left = 4f;

	private AudioSource audioSource;

	private SpecialMoveController move;

	private void Start()
	{
		move = GetComponentInParent<SpecialMoveController>();
		particles = GetComponentsInChildren<ParticleSystem>();
		audioSource = GetComponent<AudioSource>();
		audioSource.volume = 0f;
		ParticleSystem[] array = particles;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].Stop();
		}
		angle = Vector3.Angle(-base.transform.up, Vector3.down);
	}

	private void Update()
	{
		angle = Mathf.MoveTowards(angle, Vector3.Angle(-base.transform.up, Vector3.down), Time.deltaTime * 180f);
		if (angle < 90f && left > 0f)
		{
			ParticleSystem[] array;
			if (!playing)
			{
				array = particles;
				for (int i = 0; i < array.Length; i++)
				{
					array[i].Play();
				}
				playing = true;
			}
			float num = 25f;
			if (angle > 90f - num)
			{
				speedPerc = (0f - (angle - 90f)) / num;
			}
			else
			{
				speedPerc = angle / 90f;
			}
			array = particles;
			for (int i = 0; i < array.Length; i++)
			{
				ParticleSystem.MainModule main = array[i].main;
				main.startSpeed = speedPerc;
			}
			floatHitTestSpawnTimer -= Time.deltaTime;
			if (floatHitTestSpawnTimer < 0f)
			{
				floatHitTestSpawnTimer += hitTestInterval;
				WineBottleHitTest wineBottleHitTest = UnityEngine.Object.Instantiate(hitTestPrefab, null);
				wineBottleHitTest.transform.position = spout.transform.position;
				wineBottleHitTest.velocity = spout.forward * speedPerc;
				wineBottleHitTest.firer = move.character;
			}
		}
		else if (playing)
		{
			ParticleSystem[] array = particles;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].Stop();
			}
			playing = false;
		}
		if (playing)
		{
			left = Mathf.MoveTowards(left, 0f, Time.deltaTime);
		}
		audioSource.volume = Mathf.MoveTowards(audioSource.volume, playing ? 1 : 0, Time.deltaTime * 5f);
		Vector3[] array2 = new Vector3[30];
		Vector3 vector = spout.forward * speedPerc;
		Vector3 position = spout.position;
		float num2 = 0.05f;
		for (int j = 0; j < array2.Length; j++)
		{
			array2[j] = position;
			vector -= Vector3.up * num2;
			position += vector * num2;
		}
	}
}
public class WineBottleHitTest : MonoBehaviour
{
	public Vector3 velocity;

	public LayerMask layers;

	public float gravity = 1f;

	public float effectAmount = 0.25f;

	public CharacterEffect.Effect addEffect;

	public GameObject hitEffectPrefab;

	public GameCharacter firer;

	public bool ignoreFirer;

	private void Start()
	{
		UnityEngine.Object.Destroy(base.gameObject, 2f);
	}

	private void Update()
	{
		for (int i = 0; i < 2; i++)
		{
			base.transform.position += velocity * Time.deltaTime;
			if (gravity != 0f)
			{
				velocity -= Vector3.up * Time.deltaTime * gravity;
			}
			if (!Physics.Raycast(base.transform.position, velocity, out var hitInfo, velocity.magnitude * Time.deltaTime * 2f, layers))
			{
				continue;
			}
			bool flag = true;
			Hittable component = hitInfo.collider.GetComponent<Hittable>();
			if (component != null && component.rb != null)
			{
				if (ignoreFirer && component.rb.character == firer)
				{
					flag = false;
				}
				else
				{
					component.rb.character.addEffect(hitInfo.point, addEffect, effectAmount, preventSpecialRecharge: false, isTest: false);
				}
			}
			if (flag)
			{
				if (hitEffectPrefab != null)
				{
					UnityEngine.Object.Destroy(UnityEngine.Object.Instantiate(hitEffectPrefab, hitInfo.point, Quaternion.LookRotation(hitInfo.normal), GameController.instance.transform), 5f);
				}
				UnityEngine.Object.Destroy(base.gameObject);
				break;
			}
		}
	}
}
public class WingChunDummyController : MonoBehaviour
{
	public Transform hitPointContainer;

	public WingChunDummyHitPoint[] hitPoints;

	public HitSurface[] hitParts;

	public WingChunDummyStep[] sequence;

	public int onStep;

	public float resetTimer;

	private float startTime;

	public float best;

	public bool started;

	private int laps = 3;

	private void Start()
	{
		hitParts = GetComponentsInChildren<HitSurface>();
		best = Saving.instance.savedProgress.stats.getStat("Wooden Dummy Score", 1000f).value;
		HitSurface[] array = hitParts;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].onSuccessHit = hitDummy;
		}
		hitPoints = new WingChunDummyHitPoint[hitPointContainer.childCount];
		for (int j = 0; j < hitPointContainer.childCount; j++)
		{
			hitPoints[j] = hitPointContainer.GetChild(j).GetComponent<WingChunDummyHitPoint>();
			hitPoints[j].gameObject.SetActive(value: false);
		}
		showStep();
	}

	private void showStep()
	{
		if (onStep >= sequence.Length)
		{
			if (laps <= 0)
			{
				float num = Mathf.Round((Time.time - startTime) * 100f) / 100f;
				GeneralSounds.playSound(2);
				WebLogging.log("Wooden Dummy", "Finish", num);
				if (num < 30f)
				{
					AchievementsController.achievement("Dummy");
				}
				string text;
				if (best == 0f)
				{
					text = LocalisationController.replaceText("General", "Time: [x] seconds", num.ToString());
					best = num;
				}
				else if (num < best)
				{
					best = num;
					text = "New Best: " + num + " seconds";
					text = LocalisationController.replaceText("General", "New Best: [x] seconds", num.ToString());
				}
				else
				{
					text = num + " seconds (Best: " + best + ")";
					text = LocalisationController.replaceText("General", "[x] seconds", num.ToString()) + LocalisationController.replaceText("General", " (Best: [x])", best.ToString());
				}
				Saving.instance.minStat("Wooden Dummy Score", best, onlyInFight: false, isInt: false);
				CanvasController.addText(localise: false, text, hitPoints[0].transform.position, Color.white, 3f);
				resetTimer = 3f;
				return;
			}
			laps--;
			onStep = 0;
		}
		WingChunDummyHitPoint[] array = sequence[onStep].hitPoints;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].gameObject.SetActive(value: true);
		}
	}

	private void hitDummy(Vector3 point, Hittable.HandHitType hitType)
	{
		if (GameController.instance.fightState != 0 || onStep >= sequence.Length)
		{
			return;
		}
		WingChunDummyHitPoint[] array = sequence[onStep].hitPoints;
		bool flag = false;
		WingChunDummyHitPoint[] array2 = array;
		foreach (WingChunDummyHitPoint wingChunDummyHitPoint in array2)
		{
			if (!wingChunDummyHitPoint.gameObject.activeInHierarchy)
			{
				continue;
			}
			if ((wingChunDummyHitPoint.transform.position - point).magnitude <= wingChunDummyHitPoint.transform.localScale.x)
			{
				if (Array.IndexOf(wingChunDummyHitPoint.hitTypes, hitType) == -1)
				{
					CanvasController.addText(localise: true, wingChunDummyHitPoint.instruct(), point, Color.red, 1f);
					flag = true;
				}
				else
				{
					wingChunDummyHitPoint.gameObject.SetActive(value: false);
				}
				if (!started)
				{
					startTime = Time.time;
					started = true;
					WebLogging.log("Wooden Dummy", "Start", best);
					GeneralSounds.playSound(5);
				}
			}
			else
			{
				flag = true;
			}
		}
		if (!flag)
		{
			onStep++;
			showStep();
		}
	}

	private void Update()
	{
		bool flag = GameController.instance.fightState == GameController.FightState.Pre && GameController.instance.player != null;
		if (flag)
		{
			flag = (hitPointContainer.transform.position - GameController.instance.player.standPosition).magnitude < 3f;
		}
		hitPointContainer.gameObject.SetActive(flag);
		if (started)
		{
			HitEffects.instance.slowMos.Clear();
			if (!flag)
			{
				onStep = 0;
				WingChunDummyHitPoint[] array = hitPoints;
				for (int i = 0; i < array.Length; i++)
				{
					array[i].gameObject.SetActive(value: false);
				}
				started = false;
				laps = 3;
				showStep();
			}
		}
		if (resetTimer > 0f)
		{
			resetTimer -= Time.deltaTime;
			if (resetTimer < 0f)
			{
				onStep = 0;
				started = false;
				laps = 3;
				showStep();
			}
		}
	}
}
public class WingChunDummyHitPoint : MonoBehaviour
{
	public Hittable.HandHitType[] hitTypes;

	public string instruct()
	{
		if (hitTypes[0] == Hittable.HandHitType.Foot)
		{
			return "Use Kick";
		}
		if (hitTypes[0] == Hittable.HandHitType.Punch)
		{
			return "Use Punch";
		}
		return "Use Palm";
	}
}
[Serializable]
public class WingChunDummyStep
{
	public WingChunDummyHitPoint[] hitPoints;
}
public class BenOldingGamesLogoController : MonoBehaviour
{
	public Transform holder;

	public float mainMoveMin = 0.5f;

	public float mainMoveSpeed = 1f;

	public float mainRotateSpeed = 1f;

	public float distance = 1f;

	public Transform arrows;

	public Material glow;

	public Light light;

	private Vector3 targetPos;

	private Quaternion targetRotation;

	private Vector3 currentVelocity;

	public float delay = 1f;

	public float arrowPerc;

	public float emmisionPerc;

	public float nextSceneTimer = 4f;

	public bool doFadeOut;

	private bool fadeOut;

	private bool done;

	public ParticleSystem particles;

	public AudioSource audioSource;

	private bool windupSound;

	public Beautify beautify;

	public GameObject loadingDisplay;

	private void Awake()
	{
		StartCoroutine(SetEmptyXRDevice());
		loadingDisplay.gameObject.SetActive(value: false);
		holder.rotation *= Quaternion.Euler(0f, UnityEngine.Random.value * 360f, 0f);
		base.transform.position = UnityEngine.Random.insideUnitSphere * 3f;
		base.transform.rotation = Quaternion.Euler(UnityEngine.Random.value * 360f, UnityEngine.Random.value * 360f, UnityEngine.Random.value * 360f);
	}

	private IEnumerator SetEmptyXRDevice()
	{
		XRSettings.LoadDeviceByName("");
		yield return new WaitForEndOfFrame();
	}

	private void Update()
	{
		if (done)
		{
			return;
		}
		if (fadeOut)
		{
			done = true;
			SceneManager.LoadSceneAsync(1);
			return;
		}
		_ = targetPos - base.transform.position;
		Vector3 vector = Camera.main.transform.position + Camera.main.transform.forward * distance;
		vector.y = Camera.main.transform.position.y;
		if (Vector3.Distance(vector, targetPos) > mainMoveMin)
		{
			targetPos = vector;
			Vector3 forward = vector - Camera.main.transform.position;
			forward.y = 0f;
			targetRotation = Quaternion.LookRotation(forward);
		}
		base.transform.position = Vector3.SmoothDamp(base.transform.position, targetPos, ref currentVelocity, mainMoveSpeed);
		base.transform.rotation = Quaternion.RotateTowards(base.transform.rotation, targetRotation, Time.deltaTime * mainRotateSpeed);
		if (delay > 0f)
		{
			delay -= Time.deltaTime;
			if (delay < 0f)
			{
				delay = 0f;
			}
			arrowPerc = 1f;
			emmisionPerc = 0f;
		}
		arrows.localScale = Vector3.one * (1f - arrowPerc);
		light.intensity = Mathf.Clamp01(1f - delay);
		arrows.transform.localPosition = Vector3.forward * 5f * arrowPerc;
		arrows.transform.localRotation = Quaternion.Euler(arrowPerc * arrowPerc * 360f * 5f, 90f + arrowPerc * 90f, -90f);
		arrowPerc = Mathf.MoveTowards(arrowPerc, 0f, Time.deltaTime / 2f);
		if (!windupSound && arrowPerc < 0.85f && delay == 0f)
		{
			windupSound = true;
			arrows.GetComponent<AudioSource>().Play();
		}
		if (arrowPerc <= 0f)
		{
			if (emmisionPerc >= 1f)
			{
				nextSceneTimer -= Time.deltaTime;
				if (nextSceneTimer < 0f)
				{
					fadeOut = true;
				}
				else if (nextSceneTimer < 1f)
				{
					loadingDisplay.gameObject.SetActive(value: true);
					loadingDisplay.transform.localScale = Mathf.Clamp01(1f - nextSceneTimer) * 0.003f * Vector3.one;
					if (doFadeOut && beautify != null)
					{
						beautify.vignettingBlink = 1f - nextSceneTimer;
					}
				}
			}
			else
			{
				emmisionPerc = 1f;
				particles.Play();
				audioSource.Play();
			}
		}
		glow.EnableKeyword("_EMISSION");
		glow.SetColor("_EmissionColor", Color.Lerp(Color.black, Color.white, emmisionPerc));
	}
}
namespace DynamicFogAndMist
{
	[ExecuteInEditMode]
	[RequireComponent(typeof(Camera))]
	[HelpURL("https://kronnect.com/support")]
	[ImageEffectAllowedInSceneView]
	public class DynamicFog : DynamicFogBase
	{
		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (fogMat == null || _alpha == 0f || currentCamera == null)
			{
				Graphics.Blit(source, destination);
				return;
			}
			if (shouldUpdateMaterialProperties)
			{
				shouldUpdateMaterialProperties = false;
				UpdateMaterialPropertiesNow();
			}
			if (currentCamera.orthographic)
			{
				if (!matOrtho)
				{
					ResetMaterial();
				}
				fogMat.SetVector("_ClipDir", currentCamera.transform.forward);
			}
			else if (matOrtho)
			{
				ResetMaterial();
			}
			if (_useSinglePassStereoRenderingMatrix && VRCheck.IsVrRunning())
			{
				fogMat.SetMatrix("_ClipToWorld", currentCamera.cameraToWorldMatrix);
			}
			else
			{
				fogMat.SetMatrix("_ClipToWorld", currentCamera.cameraToWorldMatrix * currentCamera.projectionMatrix.inverse);
			}
			Graphics.Blit(source, destination, fogMat);
		}
	}
	public enum FOG_TYPE
	{
		DesktopFogWithSkyHaze,
		MobileFogWithSkyHaze,
		MobileFogOnlyGround,
		DesktopFogPlusWithSkyHaze,
		MobileFogSimple,
		MobileFogBasic,
		MobileFogOrthogonal,
		DesktopFogPlusOrthogonal
	}
	internal static class FOG_TYPE_Ext
	{
		public static bool isPlus(this FOG_TYPE fogType)
		{
			if (fogType != FOG_TYPE.DesktopFogPlusWithSkyHaze && fogType != FOG_TYPE.MobileFogSimple && fogType != FOG_TYPE.MobileFogBasic && fogType != FOG_TYPE.MobileFogOrthogonal)
			{
				return fogType == FOG_TYPE.DesktopFogPlusOrthogonal;
			}
			return true;
		}
	}
	public enum FOG_PRESET
	{
		Clear,
		Mist,
		WindyMist,
		GroundFog,
		Fog,
		HeavyFog,
		SandStorm,
		Custom
	}
	[AddComponentMenu("")]
	public class DynamicFogBase : MonoBehaviour
	{
		[SerializeField]
		private FOG_TYPE _effectType = FOG_TYPE.DesktopFogPlusWithSkyHaze;

		[SerializeField]
		private FOG_PRESET _preset = FOG_PRESET.Mist;

		[SerializeField]
		private DynamicFogProfile _profile;

		[SerializeField]
		private bool _profileSync;

		[SerializeField]
		private bool _useFogVolumes;

		[SerializeField]
		private bool _enableDithering;

		[SerializeField]
		[Range(0f, 0.3f)]
		private float _ditherStrength = 0.03f;

		[SerializeField]
		[Range(0f, 1f)]
		protected float _alpha = 1f;

		[SerializeField]
		[Range(0f, 1f)]
		private float _noiseStrength = 0.5f;

		[SerializeField]
		[Range(0.01f, 1f)]
		private float _noiseScale = 0.1f;

		[SerializeField]
		[Range(0f, 0.999f)]
		private float _distance = 0.1f;

		[SerializeField]
		[Range(0.0001f, 5f)]
		private float _distanceFallOff = 0.01f;

		[SerializeField]
		[Range(0f, 1.2f)]
		private float _maxDistance = 0.999f;

		[SerializeField]
		[Range(0.0001f, 0.5f)]
		private float _maxDistanceFallOff;

		[SerializeField]
		[Range(0f, 500f)]
		private float _height = 1f;

		[SerializeField]
		[Range(0f, 500f)]
		private float _maxHeight = 100f;

		[SerializeField]
		[Range(0.0001f, 1f)]
		private float _heightFallOff = 0.1f;

		[SerializeField]
		private float _baselineHeight;

		[SerializeField]
		private bool _clipUnderBaseline;

		[SerializeField]
		[Range(0f, 15f)]
		private float _turbulence = 0.1f;

		[SerializeField]
		[Range(0f, 5f)]
		private float _speed = 0.1f;

		[SerializeField]
		private Vector3 _windDirection = new Vector3(1f, 0f, 1f);

		[SerializeField]
		private Color _color = Color.white;

		[SerializeField]
		private Color _color2 = Color.gray;

		[SerializeField]
		[Range(0f, 500f)]
		private float _skyHaze = 50f;

		[SerializeField]
		[Range(0f, 1f)]
		private float _skySpeed = 0.3f;

		[SerializeField]
		[Range(0f, 1f)]
		private float _skyNoiseStrength = 0.1f;

		[SerializeField]
		[Range(0f, 1f)]
		private float _skyAlpha = 1f;

		[SerializeField]
		private GameObject _sun;

		[SerializeField]
		private bool _fogOfWarEnabled;

		[SerializeField]
		private Vector3 _fogOfWarCenter;

		[SerializeField]
		private Vector3 _fogOfWarSize = new Vector3(1024f, 0f, 1024f);

		[SerializeField]
		private int _fogOfWarTextureSize = 256;

		[SerializeField]
		protected bool _useSinglePassStereoRenderingMatrix;

		[SerializeField]
		private bool _useXZDistance;

		[SerializeField]
		[Range(0f, 1f)]
		private float _scattering = 0.7f;

		[SerializeField]
		private Color _scatteringColor = new Color(1f, 1f, 0.8f);

		private Material fogMatAdv;

		private Material fogMatFogSky;

		private Material fogMatOnlyFog;

		private Material fogMatVol;

		private Material fogMatSimple;

		private Material fogMatBasic;

		private Material fogMatOrthogonal;

		private Material fogMatDesktopPlusOrthogonal;

		[SerializeField]
		protected Material fogMat;

		private float initialFogAlpha;

		private float targetFogAlpha;

		private float initialSkyHazeAlpha;

		private float targetSkyHazeAlpha;

		private bool targetFogColors;

		private Color initialFogColor1;

		private Color targetFogColor1;

		private Color initialFogColor2;

		private Color targetFogColor2;

		private float transitionDuration;

		private float transitionStartTime;

		private float currentFogAlpha;

		private float currentSkyHazeAlpha;

		private bool transitionAlpha;

		private bool transitionColor;

		private bool transitionProfile;

		private DynamicFogProfile initialProfile;

		private DynamicFogProfile targetProfile;

		private Color currentFogColor1;

		private Color currentFogColor2;

		protected Camera currentCamera;

		private Texture2D fogOfWarTexture;

		private Color32[] fogOfWarColorBuffer;

		private Light sunLight;

		private Vector3 sunDirection = Vector3.zero;

		private Color sunColor = Color.white;

		private float sunIntensity = 1f;

		private static DynamicFog _fog;

		private List<string> shaderKeywords;

		protected bool matOrtho;

		protected bool shouldUpdateMaterialProperties;

		public FOG_TYPE effectType
		{
			get
			{
				return _effectType;
			}
			set
			{
				if (value != _effectType)
				{
					_effectType = value;
					_preset = FOG_PRESET.Custom;
					UpdateMaterialProperties();
				}
			}
		}

		public FOG_PRESET preset
		{
			get
			{
				return _preset;
			}
			set
			{
				if (value != _preset)
				{
					_preset = value;
					UpdateMaterialPropertiesNow();
				}
			}
		}

		public DynamicFogProfile profile
		{
			get
			{
				return _profile;
			}
			set
			{
				if (value != _profile)
				{
					_profile = value;
					if (_profile != null)
					{
						_profile.Load(this);
						_preset = FOG_PRESET.Custom;
						UpdateMaterialProperties();
					}
				}
			}
		}

		public bool profileSync
		{
			get
			{
				return _profileSync;
			}
			set
			{
				if (value != _profileSync)
				{
					_profileSync = value;
				}
			}
		}

		public bool useFogVolumes
		{
			get
			{
				return _useFogVolumes;
			}
			set
			{
				if (value != _useFogVolumes)
				{
					_useFogVolumes = value;
				}
			}
		}

		public bool enableDithering
		{
			get
			{
				return _enableDithering;
			}
			set
			{
				if (value != _enableDithering)
				{
					_enableDithering = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float ditherStrength
		{
			get
			{
				return _ditherStrength;
			}
			set
			{
				if (value != _ditherStrength)
				{
					_ditherStrength = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float alpha
		{
			get
			{
				return _alpha;
			}
			set
			{
				if (value != _alpha)
				{
					_alpha = value;
					_preset = FOG_PRESET.Custom;
					UpdateMaterialProperties();
				}
			}
		}

		public float noiseStrength
		{
			get
			{
				return _noiseStrength;
			}
			set
			{
				if (value != _noiseStrength)
				{
					_noiseStrength = value;
					_preset = FOG_PRESET.Custom;
					UpdateMaterialProperties();
				}
			}
		}

		public float noiseScale
		{
			get
			{
				return _noiseScale;
			}
			set
			{
				if (value != _noiseScale)
				{
					_noiseScale = value;
					_preset = FOG_PRESET.Custom;
					UpdateMaterialProperties();
				}
			}
		}

		public float distance
		{
			get
			{
				return _distance;
			}
			set
			{
				if (value != _distance)
				{
					_distance = value;
					_preset = FOG_PRESET.Custom;
					UpdateMaterialProperties();
				}
			}
		}

		public float distanceFallOff
		{
			get
			{
				return _distanceFallOff;
			}
			set
			{
				if (value != _distanceFallOff)
				{
					_distanceFallOff = value;
					_preset = FOG_PRESET.Custom;
					UpdateMaterialProperties();
				}
			}
		}

		public float maxDistance
		{
			get
			{
				return _maxDistance;
			}
			set
			{
				if (value != _maxDistance)
				{
					_maxDistance = value;
					_preset = FOG_PRESET.Custom;
					UpdateMaterialProperties();
				}
			}
		}

		public float maxDistanceFallOff
		{
			get
			{
				return _maxDistanceFallOff;
			}
			set
			{
				if (value != _maxDistanceFallOff)
				{
					_maxDistanceFallOff = value;
					_preset = FOG_PRESET.Custom;
					UpdateMaterialProperties();
				}
			}
		}

		public float height
		{
			get
			{
				return _height;
			}
			set
			{
				if (value != _height)
				{
					_height = value;
					_preset = FOG_PRESET.Custom;
					UpdateMaterialProperties();
				}
			}
		}

		public float maxHeight
		{
			get
			{
				return _maxHeight;
			}
			set
			{
				if (value != _maxHeight)
				{
					_maxHeight = value;
					_preset = FOG_PRESET.Custom;
					UpdateMaterialProperties();
				}
			}
		}

		public float heightFallOff
		{
			get
			{
				return _heightFallOff;
			}
			set
			{
				if (value != _heightFallOff)
				{
					_heightFallOff = value;
					_preset = FOG_PRESET.Custom;
					UpdateMaterialProperties();
				}
			}
		}

		public float baselineHeight
		{
			get
			{
				return _baselineHeight;
			}
			set
			{
				if (value != _baselineHeight)
				{
					_baselineHeight = value;
					UpdateMaterialProperties();
				}
			}
		}

		public bool clipUnderBaseline
		{
			get
			{
				return _clipUnderBaseline;
			}
			set
			{
				if (value != _clipUnderBaseline)
				{
					_clipUnderBaseline = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float turbulence
		{
			get
			{
				return _turbulence;
			}
			set
			{
				if (value != _turbulence)
				{
					_turbulence = value;
					_preset = FOG_PRESET.Custom;
					UpdateMaterialProperties();
				}
			}
		}

		public float speed
		{
			get
			{
				return _speed;
			}
			set
			{
				if (value != _speed)
				{
					_speed = value;
					_preset = FOG_PRESET.Custom;
					UpdateMaterialProperties();
				}
			}
		}

		public Vector3 windDirection
		{
			get
			{
				return _windDirection;
			}
			set
			{
				if (value != _windDirection)
				{
					_windDirection = value;
					UpdateMaterialProperties();
				}
			}
		}

		public Color color
		{
			get
			{
				return _color;
			}
			set
			{
				if (value != _color)
				{
					_color = value;
					_preset = FOG_PRESET.Custom;
					UpdateMaterialProperties();
				}
			}
		}

		public Color color2
		{
			get
			{
				return _color2;
			}
			set
			{
				if (value != _color2)
				{
					_color2 = value;
					_preset = FOG_PRESET.Custom;
					UpdateMaterialProperties();
				}
			}
		}

		public float skyHaze
		{
			get
			{
				return _skyHaze;
			}
			set
			{
				if (value != _skyHaze)
				{
					_skyHaze = value;
					_preset = FOG_PRESET.Custom;
					UpdateMaterialProperties();
				}
			}
		}

		public float skySpeed
		{
			get
			{
				return _skySpeed;
			}
			set
			{
				if (value != _skySpeed)
				{
					_skySpeed = value;
					_preset = FOG_PRESET.Custom;
					UpdateMaterialProperties();
				}
			}
		}

		public float skyNoiseStrength
		{
			get
			{
				return _skyNoiseStrength;
			}
			set
			{
				if (value != _skyNoiseStrength)
				{
					_skyNoiseStrength = value;
					_preset = FOG_PRESET.Custom;
					UpdateMaterialProperties();
				}
			}
		}

		public float skyAlpha
		{
			get
			{
				return _skyAlpha;
			}
			set
			{
				if (value != _skyAlpha)
				{
					_skyAlpha = value;
					_preset = FOG_PRESET.Custom;
					UpdateMaterialProperties();
				}
			}
		}

		public GameObject sun
		{
			get
			{
				return _sun;
			}
			set
			{
				if (value != _sun)
				{
					_sun = value;
					UpdateMaterialProperties();
				}
			}
		}

		public bool fogOfWarEnabled
		{
			get
			{
				return _fogOfWarEnabled;
			}
			set
			{
				if (value != _fogOfWarEnabled)
				{
					_fogOfWarEnabled = value;
					UpdateMaterialProperties();
				}
			}
		}

		public Vector3 fogOfWarCenter
		{
			get
			{
				return _fogOfWarCenter;
			}
			set
			{
				if (value != _fogOfWarCenter)
				{
					_fogOfWarCenter = value;
					UpdateMaterialProperties();
				}
			}
		}

		public Vector3 fogOfWarSize
		{
			get
			{
				return _fogOfWarSize;
			}
			set
			{
				if (value != _fogOfWarSize)
				{
					_fogOfWarSize = value;
					UpdateMaterialProperties();
				}
			}
		}

		public int fogOfWarTextureSize
		{
			get
			{
				return _fogOfWarTextureSize;
			}
			set
			{
				if (value != _fogOfWarTextureSize)
				{
					_fogOfWarTextureSize = value;
					UpdateMaterialProperties();
				}
			}
		}

		public bool useSinglePassStereoRenderingMatrix
		{
			get
			{
				return _useSinglePassStereoRenderingMatrix;
			}
			set
			{
				if (value != _useSinglePassStereoRenderingMatrix)
				{
					_useSinglePassStereoRenderingMatrix = value;
					UpdateMaterialProperties();
				}
			}
		}

		public bool useXZDistance
		{
			get
			{
				return _useXZDistance;
			}
			set
			{
				if (value != _useXZDistance)
				{
					_useXZDistance = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float scattering
		{
			get
			{
				return _scattering;
			}
			set
			{
				if (value != _scattering)
				{
					_scattering = value;
					UpdateMaterialProperties();
				}
			}
		}

		public Color scatteringColor
		{
			get
			{
				return _scatteringColor;
			}
			set
			{
				if (value != _scatteringColor)
				{
					_scatteringColor = value;
					UpdateMaterialProperties();
				}
			}
		}

		public static DynamicFog instance
		{
			get
			{
				if (_fog == null)
				{
					Camera[] allCameras = Camera.allCameras;
					for (int i = 0; i < allCameras.Length; i++)
					{
						_fog = allCameras[i].GetComponent<DynamicFog>();
						if (_fog != null)
						{
							break;
						}
					}
				}
				return _fog;
			}
		}

		public Camera fogCamera => currentCamera;

		public string GetCurrentPresetName()
		{
			return Enum.GetName(typeof(FOG_PRESET), preset);
		}

		private void OnEnable()
		{
			Init();
			UpdateMaterialPropertiesNow();
		}

		private void Reset()
		{
			UpdateMaterialPropertiesNow();
		}

		private void OnDestroy()
		{
			fogMat = null;
			if (fogMatVol != null)
			{
				UnityEngine.Object.DestroyImmediate(fogMatVol);
				fogMatVol = null;
				if (fogMatDesktopPlusOrthogonal != null)
				{
					UnityEngine.Object.DestroyImmediate(fogMatDesktopPlusOrthogonal);
					fogMatDesktopPlusOrthogonal = null;
				}
			}
			if (fogMatAdv != null)
			{
				UnityEngine.Object.DestroyImmediate(fogMatAdv);
				fogMatAdv = null;
			}
			if (fogMatFogSky != null)
			{
				UnityEngine.Object.DestroyImmediate(fogMatFogSky);
				fogMatFogSky = null;
			}
			if (fogMatOnlyFog != null)
			{
				UnityEngine.Object.DestroyImmediate(fogMatOnlyFog);
				fogMatOnlyFog = null;
			}
			if (fogMatSimple != null)
			{
				UnityEngine.Object.DestroyImmediate(fogMatSimple);
				fogMatSimple = null;
			}
			if (fogMatBasic != null)
			{
				UnityEngine.Object.DestroyImmediate(fogMatBasic);
				fogMatBasic = null;
			}
			if (fogMatOrthogonal != null)
			{
				UnityEngine.Object.DestroyImmediate(fogMatOrthogonal);
				fogMatOrthogonal = null;
			}
			if (fogMatDesktopPlusOrthogonal != null)
			{
				UnityEngine.Object.DestroyImmediate(fogMatDesktopPlusOrthogonal);
				fogMatOrthogonal = null;
			}
			if (fogOfWarTexture != null)
			{
				UnityEngine.Object.DestroyImmediate(fogOfWarTexture);
				fogOfWarTexture = null;
			}
		}

		private void Init()
		{
			targetFogAlpha = -1f;
			targetSkyHazeAlpha = -1f;
			currentCamera = GetComponent<Camera>();
			UpdateFogOfWarTexture();
			if (_profileSync && _profile != null)
			{
				_profile.Load(this);
			}
		}

		private void Update()
		{
			if (fogMat == null)
			{
				return;
			}
			if (transitionProfile)
			{
				float num = (Time.time - transitionStartTime) / transitionDuration;
				if (num > 1f)
				{
					num = 1f;
				}
				DynamicFogProfile.Lerp(initialProfile, targetProfile, num, this);
				if (num >= 1f)
				{
					transitionProfile = false;
				}
			}
			if (transitionAlpha)
			{
				if (targetFogAlpha >= 0f)
				{
					if (targetFogAlpha != currentFogAlpha || targetSkyHazeAlpha != currentSkyHazeAlpha)
					{
						if (transitionDuration > 0f)
						{
							currentFogAlpha = Mathf.Lerp(initialFogAlpha, targetFogAlpha, (Time.time - transitionStartTime) / transitionDuration);
							currentSkyHazeAlpha = Mathf.Lerp(initialSkyHazeAlpha, targetSkyHazeAlpha, (Time.time - transitionStartTime) / transitionDuration);
						}
						else
						{
							currentFogAlpha = targetFogAlpha;
							currentSkyHazeAlpha = targetSkyHazeAlpha;
							transitionAlpha = false;
						}
						fogMat.SetFloat("_FogAlpha", currentFogAlpha);
						SetSkyData();
					}
				}
				else if (currentFogAlpha != alpha || targetSkyHazeAlpha != currentSkyHazeAlpha)
				{
					if (transitionDuration > 0f)
					{
						currentFogAlpha = Mathf.Lerp(initialFogAlpha, alpha, (Time.time - transitionStartTime) / transitionDuration);
						currentSkyHazeAlpha = Mathf.Lerp(initialSkyHazeAlpha, alpha, (Time.time - transitionStartTime) / transitionDuration);
					}
					else
					{
						currentFogAlpha = alpha;
						currentSkyHazeAlpha = skyAlpha;
						transitionAlpha = false;
					}
					fogMat.SetFloat("_FogAlpha", currentFogAlpha);
					SetSkyData();
				}
			}
			if (transitionColor)
			{
				if (targetFogColors)
				{
					if (targetFogColor1 != currentFogColor1 || targetFogColor2 != currentFogColor2)
					{
						if (transitionDuration > 0f)
						{
							currentFogColor1 = Color.Lerp(initialFogColor1, targetFogColor1, (Time.time - transitionStartTime) / transitionDuration);
							currentFogColor2 = Color.Lerp(initialFogColor2, targetFogColor2, (Time.time - transitionStartTime) / transitionDuration);
						}
						else
						{
							currentFogColor1 = targetFogColor1;
							currentFogColor2 = targetFogColor2;
							transitionColor = false;
						}
						fogMat.SetColor("_FogColor", currentFogColor1);
						fogMat.SetColor("_FogColor2", currentFogColor2);
					}
				}
				else if (currentFogColor1 != color || currentFogColor2 != color2)
				{
					if (transitionDuration > 0f)
					{
						currentFogColor1 = Color.Lerp(initialFogColor1, color, (Time.time - transitionStartTime) / transitionDuration);
						currentFogColor2 = Color.Lerp(initialFogColor2, color2, (Time.time - transitionStartTime) / transitionDuration);
					}
					else
					{
						currentFogColor1 = color;
						currentFogColor2 = color2;
						transitionColor = false;
					}
					fogMat.SetColor("_FogColor", currentFogColor1);
					fogMat.SetColor("_FogColor2", currentFogColor2);
				}
			}
			if (sun != null)
			{
				bool flag = false;
				if (sun.transform.forward != sunDirection)
				{
					flag = true;
				}
				if (sunLight != null && (sunLight.color != sunColor || sunLight.intensity != sunIntensity))
				{
					flag = true;
				}
				if (flag)
				{
					UpdateFogColor();
				}
			}
		}

		private void OnDidApplyAnimationProperties()
		{
			shouldUpdateMaterialProperties = true;
		}

		public void CheckPreset()
		{
			if (_preset != FOG_PRESET.Custom)
			{
				_effectType = FOG_TYPE.DesktopFogWithSkyHaze;
			}
			switch (preset)
			{
			case FOG_PRESET.Clear:
				alpha = 0f;
				break;
			case FOG_PRESET.Mist:
				alpha = 0.75f;
				skySpeed = 0.11f;
				skyHaze = 15f;
				skyNoiseStrength = 1f;
				skyAlpha = 0.33f;
				distance = 0f;
				distanceFallOff = 0.07f;
				height = 4.4f;
				heightFallOff = 1f;
				turbulence = 0f;
				noiseStrength = 0.6f;
				speed = 0.01f;
				color = new Color(0.89f, 0.89f, 0.89f, 1f);
				color2 = color;
				maxDistance = 0.999f;
				maxDistanceFallOff = 0f;
				break;
			case FOG_PRESET.WindyMist:
				alpha = 0.75f;
				skySpeed = 0.3f;
				skyHaze = 35f;
				skyNoiseStrength = 0.32f;
				skyAlpha = 0.33f;
				distance = 0f;
				distanceFallOff = 0.07f;
				height = 2f;
				heightFallOff = 1f;
				turbulence = 2f;
				noiseStrength = 0.6f;
				speed = 0.06f;
				color = new Color(0.89f, 0.89f, 0.89f, 1f);
				color2 = color;
				maxDistance = 0.999f;
				maxDistanceFallOff = 0f;
				break;
			case FOG_PRESET.GroundFog:
				alpha = 1f;
				skySpeed = 0.3f;
				skyHaze = 35f;
				skyNoiseStrength = 0.32f;
				skyAlpha = 0.33f;
				distance = 0f;
				distanceFallOff = 0f;
				height = 1f;
				heightFallOff = 1f;
				turbulence = 0.4f;
				noiseStrength = 0.7f;
				speed = 0.005f;
				color = new Color(0.89f, 0.89f, 0.89f, 1f);
				color2 = color;
				maxDistance = 0.999f;
				maxDistanceFallOff = 0f;
				break;
			case FOG_PRESET.Fog:
				alpha = 0.96f;
				skySpeed = 0.3f;
				skyHaze = 155f;
				skyNoiseStrength = 0.6f;
				skyAlpha = 0.93f;
				distance = (effectType.isPlus() ? 0.2f : 0.01f);
				distanceFallOff = 0.04f;
				height = 20f;
				heightFallOff = 1f;
				turbulence = 0.4f;
				noiseStrength = 0.4f;
				speed = 0.005f;
				color = new Color(0.89f, 0.89f, 0.89f, 1f);
				color2 = color;
				maxDistance = 0.999f;
				maxDistanceFallOff = 0f;
				break;
			case FOG_PRESET.HeavyFog:
				alpha = 1f;
				skySpeed = 0.05f;
				skyHaze = 350f;
				skyNoiseStrength = 0.8f;
				skyAlpha = 0.97f;
				distance = (effectType.isPlus() ? 0.1f : 0f);
				distanceFallOff = 0.045f;
				height = 35f;
				heightFallOff = 0.88f;
				turbulence = 0.4f;
				noiseStrength = 0.24f;
				speed = 0.003f;
				color = new Color(0.86f, 0.847f, 0.847f, 1f);
				color2 = color;
				maxDistance = 0.999f;
				maxDistanceFallOff = 0f;
				break;
			case FOG_PRESET.SandStorm:
				alpha = 1f;
				skySpeed = 0.49f;
				skyHaze = 333f;
				skyNoiseStrength = 0.72f;
				skyAlpha = 0.97f;
				distance = (effectType.isPlus() ? 0.15f : 0f);
				distanceFallOff = 0.028f;
				height = 83f;
				heightFallOff = 0f;
				turbulence = 15f;
				noiseStrength = 0.45f;
				speed = 0.2f;
				color = new Color(0.364f, 0.36f, 0.36f, 1f);
				color2 = color;
				maxDistance = 0.999f;
				maxDistanceFallOff = 0f;
				break;
			}
		}

		private void OnPreCull()
		{
			if (currentCamera != null)
			{
				currentCamera.depthTextureMode |= DepthTextureMode.Depth;
			}
		}

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (fogMat == null || _alpha == 0f || currentCamera == null)
			{
				Graphics.Blit(source, destination);
				return;
			}
			if (shouldUpdateMaterialProperties)
			{
				shouldUpdateMaterialProperties = false;
				UpdateMaterialPropertiesNow();
			}
			if (currentCamera.orthographic)
			{
				if (!matOrtho)
				{
					ResetMaterial();
				}
				fogMat.SetVector("_ClipDir", currentCamera.transform.forward);
			}
			else if (matOrtho)
			{
				ResetMaterial();
			}
			if (_useSinglePassStereoRenderingMatrix && VRCheck.IsVrRunning())
			{
				fogMat.SetMatrix("_ClipToWorld", currentCamera.cameraToWorldMatrix);
			}
			else
			{
				fogMat.SetMatrix("_ClipToWorld", currentCamera.cameraToWorldMatrix * currentCamera.projectionMatrix.inverse);
			}
			Graphics.Blit(source, destination, fogMat);
		}

		protected void ResetMaterial()
		{
			fogMat = null;
			fogMatAdv = null;
			fogMatFogSky = null;
			fogMatOnlyFog = null;
			fogMatSimple = null;
			fogMatBasic = null;
			fogMatVol = null;
			fogMatDesktopPlusOrthogonal = null;
			fogMatOrthogonal = null;
			UpdateMaterialProperties();
		}

		public void UpdateMaterialProperties()
		{
			if (Application.isPlaying)
			{
				shouldUpdateMaterialProperties = true;
			}
			else
			{
				UpdateMaterialPropertiesNow();
			}
		}

		protected void UpdateMaterialPropertiesNow()
		{
			CheckPreset();
			CopyTransitionValues();
			if (currentCamera == null)
			{
				currentCamera = GetComponent<Camera>();
			}
			switch (effectType)
			{
			case FOG_TYPE.MobileFogOnlyGround:
				if (fogMatOnlyFog == null)
				{
					string path;
					if (currentCamera.orthographic)
					{
						matOrtho = true;
						path = "Materials/DFOOnlyFog";
					}
					else
					{
						matOrtho = false;
						path = "Materials/DFGOnlyFog";
					}
					fogMatOnlyFog = UnityEngine.Object.Instantiate(Resources.Load<Material>(path));
					fogMatOnlyFog.hideFlags = HideFlags.DontSave;
				}
				fogMat = fogMatOnlyFog;
				break;
			case FOG_TYPE.MobileFogWithSkyHaze:
				if (fogMatFogSky == null)
				{
					string path;
					if (currentCamera.orthographic)
					{
						matOrtho = true;
						path = "Materials/DFOWithSky";
					}
					else
					{
						matOrtho = false;
						path = "Materials/DFGWithSky";
					}
					fogMatFogSky = UnityEngine.Object.Instantiate(Resources.Load<Material>(path));
					fogMatFogSky.hideFlags = HideFlags.DontSave;
				}
				fogMat = fogMatFogSky;
				break;
			case FOG_TYPE.DesktopFogPlusWithSkyHaze:
				if (fogMatVol == null)
				{
					string path;
					if (currentCamera.orthographic)
					{
						matOrtho = true;
						path = "Materials/DFODesktopPlus";
					}
					else
					{
						matOrtho = false;
						path = "Materials/DFGDesktopPlus";
					}
					fogMatVol = Resources.Load<Material>(path);
					if (fogMatVol == null)
					{
						return;
					}
					fogMatVol = UnityEngine.Object.Instantiate(fogMatVol);
					fogMatVol.hideFlags = HideFlags.DontSave;
				}
				fogMat = fogMatVol;
				break;
			case FOG_TYPE.MobileFogSimple:
				if (fogMatSimple == null)
				{
					string path;
					if (currentCamera.orthographic)
					{
						matOrtho = true;
						path = "Materials/DFOSimple";
					}
					else
					{
						matOrtho = false;
						path = "Materials/DFGSimple";
					}
					fogMatSimple = UnityEngine.Object.Instantiate(Resources.Load<Material>(path));
					fogMatSimple.hideFlags = HideFlags.DontSave;
				}
				fogMat = fogMatSimple;
				break;
			case FOG_TYPE.MobileFogBasic:
				if (fogMatBasic == null)
				{
					string path;
					if (currentCamera.orthographic)
					{
						matOrtho = true;
						path = "Materials/DFOBasic";
					}
					else
					{
						matOrtho = false;
						path = "Materials/DFGBasic";
					}
					fogMatBasic = UnityEngine.Object.Instantiate(Resources.Load<Material>(path));
					fogMatBasic.hideFlags = HideFlags.DontSave;
				}
				fogMat = fogMatBasic;
				break;
			case FOG_TYPE.MobileFogOrthogonal:
				if (fogMatOrthogonal == null)
				{
					string path;
					if (currentCamera.orthographic)
					{
						matOrtho = true;
						path = "Materials/DFOOrthogonal";
					}
					else
					{
						matOrtho = false;
						path = "Materials/DFGOrthogonal";
					}
					fogMatOrthogonal = UnityEngine.Object.Instantiate(Resources.Load<Material>(path));
					fogMatOrthogonal.hideFlags = HideFlags.DontSave;
				}
				fogMat = fogMatOrthogonal;
				break;
			case FOG_TYPE.DesktopFogPlusOrthogonal:
				if (fogMatDesktopPlusOrthogonal == null)
				{
					string path;
					if (currentCamera.orthographic)
					{
						matOrtho = true;
						path = "Materials/DFODesktopPlusOrthogonal";
					}
					else
					{
						matOrtho = false;
						path = "Materials/DFGDesktopPlusOrthogonal";
					}
					fogMatDesktopPlusOrthogonal = UnityEngine.Object.Instantiate(Resources.Load<Material>(path));
					fogMatDesktopPlusOrthogonal.hideFlags = HideFlags.DontSave;
				}
				fogMat = fogMatDesktopPlusOrthogonal;
				break;
			default:
				if (fogMatAdv == null)
				{
					string path;
					if (currentCamera.orthographic)
					{
						matOrtho = true;
						path = "Materials/DFODesktop";
					}
					else
					{
						matOrtho = false;
						path = "Materials/DFGDesktop";
					}
					fogMatAdv = UnityEngine.Object.Instantiate(Resources.Load<Material>(path));
					fogMatAdv.hideFlags = HideFlags.DontSave;
				}
				fogMat = fogMatAdv;
				break;
			}
			if (fogMat == null)
			{
				return;
			}
			float num = ((effectType == FOG_TYPE.DesktopFogPlusWithSkyHaze) ? (_speed * 5f) : _speed);
			fogMat.SetVector("_FogSpeed", -_windDirection.normalized * num);
			Vector4 value = new Vector4(_noiseStrength, _turbulence, currentCamera.farClipPlane * 15f / 1000f, _noiseScale);
			fogMat.SetVector("_FogNoiseData", value);
			Vector4 value2 = new Vector4(_height + 0.001f, _baselineHeight, _clipUnderBaseline ? (-0.01f) : (-10000f), _heightFallOff);
			if (_effectType == FOG_TYPE.MobileFogOrthogonal || _effectType == FOG_TYPE.DesktopFogPlusOrthogonal)
			{
				value2.z = maxHeight;
			}
			fogMat.SetVector("_FogHeightData", value2);
			fogMat.SetFloat("_FogAlpha", currentFogAlpha);
			Vector4 value3 = new Vector4(_distance, _distanceFallOff, _maxDistance, _maxDistanceFallOff);
			if (effectType.isPlus())
			{
				value3.x = currentCamera.farClipPlane * _distance;
				value3.y = distanceFallOff * value3.x + 0.0001f;
				value3.z *= currentCamera.farClipPlane;
			}
			fogMat.SetVector("_FogDistance", value3);
			UpdateFogColor();
			SetSkyData();
			if (shaderKeywords == null)
			{
				shaderKeywords = new List<string>();
			}
			else
			{
				shaderKeywords.Clear();
			}
			if (fogOfWarEnabled)
			{
				if (fogOfWarTexture == null)
				{
					UpdateFogOfWarTexture();
				}
				fogMat.SetTexture("_FogOfWar", fogOfWarTexture);
				fogMat.SetVector("_FogOfWarCenter", _fogOfWarCenter);
				fogMat.SetVector("_FogOfWarSize", _fogOfWarSize);
				Vector3 vector = fogOfWarCenter - 0.5f * _fogOfWarSize;
				fogMat.SetVector("_FogOfWarCenterAdjusted", new Vector3(vector.x / _fogOfWarSize.x, 1f, vector.z / _fogOfWarSize.z));
				shaderKeywords.Add("FOG_OF_WAR_ON");
			}
			if (_enableDithering)
			{
				fogMat.SetFloat("_FogDither", _ditherStrength * 0.1f);
				shaderKeywords.Add("DITHER_ON");
			}
			fogMat.shaderKeywords = shaderKeywords.ToArray();
		}

		private void CopyTransitionValues()
		{
			currentFogAlpha = _alpha;
			currentSkyHazeAlpha = _skyAlpha;
			currentFogColor1 = _color;
			currentFogColor2 = _color2;
		}

		private void SetSkyData()
		{
			Vector4 value = new Vector4(_skyHaze, _skySpeed, _skyNoiseStrength, currentSkyHazeAlpha);
			fogMat.SetVector("_FogSkyData", value);
		}

		private void UpdateFogColor()
		{
			if (fogMat == null)
			{
				return;
			}
			if (_sun != null)
			{
				if (sunLight == null)
				{
					sunLight = _sun.GetComponent<Light>();
				}
				if (sunLight != null && sunLight.transform != _sun.transform)
				{
					sunLight = _sun.GetComponent<Light>();
				}
				sunDirection = _sun.transform.forward;
				if (sunLight != null)
				{
					sunColor = sunLight.color;
					sunIntensity = sunLight.intensity;
				}
			}
			float num = sunIntensity * Mathf.Clamp01(1f - sunDirection.y);
			fogMat.SetColor("_FogColor", num * currentFogColor1 * sunColor);
			fogMat.SetColor("_FogColor2", num * currentFogColor2 * sunColor);
			Color color = num * scatteringColor;
			fogMat.SetColor("_SunColor", new Vector4(color.r, color.g, color.b, scattering));
			fogMat.SetVector("_SunDir", -sunDirection);
		}

		public void SetTargetProfile(DynamicFogProfile targetProfile, float duration)
		{
			if (_useFogVolumes)
			{
				preset = FOG_PRESET.Custom;
				initialProfile = ScriptableObject.CreateInstance<DynamicFogProfile>();
				initialProfile.Save(this);
				this.targetProfile = targetProfile;
				transitionDuration = duration;
				transitionStartTime = Time.time;
				transitionProfile = true;
			}
		}

		public void ClearTargetProfile(float duration)
		{
			SetTargetProfile(initialProfile, duration);
		}

		public void SetTargetAlpha(float newFogAlpha, float newSkyHazeAlpha, float duration)
		{
			if (useFogVolumes)
			{
				preset = FOG_PRESET.Custom;
				initialFogAlpha = currentFogAlpha;
				initialSkyHazeAlpha = currentSkyHazeAlpha;
				targetFogAlpha = newFogAlpha;
				targetSkyHazeAlpha = newSkyHazeAlpha;
				transitionDuration = duration;
				transitionStartTime = Time.time;
				transitionAlpha = true;
			}
		}

		public void ClearTargetAlpha(float duration)
		{
			SetTargetAlpha(-1f, -1f, duration);
		}

		public void SetTargetColors(Color color1, Color color2, float duration)
		{
			if (useFogVolumes)
			{
				preset = FOG_PRESET.Custom;
				initialFogColor1 = currentFogColor1;
				initialFogColor2 = currentFogColor2;
				targetFogColor1 = color1;
				targetFogColor2 = color2;
				transitionDuration = duration;
				transitionStartTime = Time.time;
				targetFogColors = true;
				transitionColor = true;
			}
		}

		public void ClearTargetColors(float duration)
		{
			targetFogColors = false;
			SetTargetColors(color, color2, duration);
		}

		public float GetFogOfWarAlpha(Vector3 worldPosition)
		{
			if (fogOfWarTexture == null)
			{
				return 1f;
			}
			float num = (worldPosition.x - fogOfWarCenter.x) / fogOfWarSize.x + 0.5f;
			if (num < 0f || num > 1f)
			{
				return 1f;
			}
			float num2 = (worldPosition.z - fogOfWarCenter.z) / fogOfWarSize.z + 0.5f;
			if (num2 < 0f || num2 > 1f)
			{
				return 1f;
			}
			int width = fogOfWarTexture.width;
			int num3 = fogOfWarTexture.height;
			int num4 = (int)(num * (float)width);
			int num5 = (int)(num2 * (float)num3) * width + num4;
			return (float)(int)fogOfWarColorBuffer[num5].a / 255f;
		}

		private void UpdateFogOfWarTexture()
		{
			if (fogOfWarEnabled)
			{
				int scaledSize = GetScaledSize(fogOfWarTextureSize, 1f);
				fogOfWarTexture = new Texture2D(scaledSize, scaledSize, TextureFormat.ARGB32, mipChain: false);
				fogOfWarTexture.hideFlags = HideFlags.DontSave;
				fogOfWarTexture.filterMode = FilterMode.Bilinear;
				fogOfWarTexture.wrapMode = TextureWrapMode.Clamp;
				ResetFogOfWar();
			}
		}

		public void SetFogOfWarAlpha(Vector3 worldPosition, float radius, float fogNewAlpha)
		{
			if (fogOfWarTexture == null)
			{
				return;
			}
			float num = (worldPosition.x - fogOfWarCenter.x) / fogOfWarSize.x + 0.5f;
			if (num < 0f || num > 1f)
			{
				return;
			}
			float num2 = (worldPosition.z - fogOfWarCenter.z) / fogOfWarSize.z + 0.5f;
			if (num2 < 0f || num2 > 1f)
			{
				return;
			}
			int width = fogOfWarTexture.width;
			int num3 = fogOfWarTexture.height;
			int num4 = (int)(num * (float)width);
			int num5 = (int)(num2 * (float)num3);
			int num6 = num5 * width + num4;
			byte b = (byte)(fogNewAlpha * 255f);
			Color32 color = fogOfWarColorBuffer[num6];
			if (b == color.a)
			{
				return;
			}
			float num7 = radius / fogOfWarSize.z;
			int num8 = Mathf.FloorToInt((float)num3 * num7);
			for (int i = num5 - num8; i <= num5 + num8; i++)
			{
				if (i <= 0 || i >= num3 - 1)
				{
					continue;
				}
				for (int j = num4 - num8; j <= num4 + num8; j++)
				{
					if (j > 0 && j < width - 1)
					{
						int num9 = Mathf.FloorToInt(Mathf.Sqrt((num5 - i) * (num5 - i) + (num4 - j) * (num4 - j)));
						if (num9 <= num8)
						{
							num6 = i * width + j;
							Color32 color2 = fogOfWarColorBuffer[num6];
							color2.a = (byte)Mathf.Lerp((int)b, (int)color2.a, (float)num9 / (float)num8);
							fogOfWarColorBuffer[num6] = color2;
							fogOfWarTexture.SetPixel(j, i, color2);
						}
					}
				}
			}
			fogOfWarTexture.Apply();
		}

		public void ResetFogOfWarAlpha(Vector3 worldPosition, float radius)
		{
			if (fogOfWarTexture == null)
			{
				return;
			}
			float num = (worldPosition.x - fogOfWarCenter.x) / fogOfWarSize.x + 0.5f;
			if (num < 0f || num > 1f)
			{
				return;
			}
			float num2 = (worldPosition.z - fogOfWarCenter.z) / fogOfWarSize.z + 0.5f;
			if (num2 < 0f || num2 > 1f)
			{
				return;
			}
			int width = fogOfWarTexture.width;
			int num3 = fogOfWarTexture.height;
			int num4 = (int)(num * (float)width);
			int num5 = (int)(num2 * (float)num3);
			int num6 = num5 * width + num4;
			float num7 = radius / fogOfWarSize.z;
			int num8 = Mathf.FloorToInt((float)num3 * num7);
			for (int i = num5 - num8; i <= num5 + num8; i++)
			{
				if (i > 0 && i < num3 - 1)
				{
					for (int j = num4 - num8; j <= num4 + num8; j++)
					{
						if (j > 0 && j < width - 1 && Mathf.FloorToInt(Mathf.Sqrt((num5 - i) * (num5 - i) + (num4 - j) * (num4 - j))) <= num8)
						{
							num6 = i * width + j;
							Color32 color = fogOfWarColorBuffer[num6];
							color.a = byte.MaxValue;
							fogOfWarColorBuffer[num6] = color;
							fogOfWarTexture.SetPixel(j, i, color);
						}
					}
				}
				fogOfWarTexture.Apply();
			}
		}

		public void ResetFogOfWar()
		{
			if (!(fogOfWarTexture == null))
			{
				int num = fogOfWarTexture.height;
				int width = fogOfWarTexture.width;
				int num2 = num * width;
				if (fogOfWarColorBuffer == null || fogOfWarColorBuffer.Length != num2)
				{
					fogOfWarColorBuffer = new Color32[num2];
				}
				Color32 color = new Color32(byte.MaxValue, byte.MaxValue, byte.MaxValue, byte.MaxValue);
				for (int i = 0; i < num2; i++)
				{
					fogOfWarColorBuffer[i] = color;
				}
				fogOfWarTexture.SetPixels32(fogOfWarColorBuffer);
				fogOfWarTexture.Apply();
			}
		}

		private int GetScaledSize(int size, float factor)
		{
			size = (int)((float)size / factor);
			size /= 4;
			if (size < 1)
			{
				size = 1;
			}
			return size * 4;
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(Camera))]
	[HelpURL("https://kronnect.com/support")]
	[ImageEffectAllowedInSceneView]
	public class DynamicFogExclusive : DynamicFogBase
	{
		private RenderTexture rt;

		[Range(0.1f, 2f)]
		public float renderScale = 1f;

		private void OnPreRender()
		{
			if (!(fogMat == null) && _alpha != 0f && !(currentCamera == null))
			{
				if (VRCheck.IsVrRunning())
				{
					RenderTextureDescriptor eyeTextureDesc = XRSettings.eyeTextureDesc;
					eyeTextureDesc.width = (int)((float)eyeTextureDesc.width * renderScale);
					eyeTextureDesc.height = (int)((float)eyeTextureDesc.height * renderScale);
					rt = RenderTexture.GetTemporary(eyeTextureDesc);
				}
				else
				{
					int width = (int)((float)currentCamera.pixelWidth * renderScale);
					int num = (int)((float)currentCamera.pixelHeight * renderScale);
					rt = RenderTexture.GetTemporary(width, num, 24, RenderTextureFormat.ARGB32);
					rt.antiAliasing = 1;
				}
				rt.wrapMode = TextureWrapMode.Clamp;
				currentCamera.targetTexture = rt;
			}
		}

		private void OnPostRender()
		{
			if (fogMat == null || _alpha == 0f || currentCamera == null)
			{
				return;
			}
			if (shouldUpdateMaterialProperties)
			{
				shouldUpdateMaterialProperties = false;
				UpdateMaterialPropertiesNow();
			}
			if (currentCamera.orthographic)
			{
				if (!matOrtho)
				{
					ResetMaterial();
				}
				fogMat.SetVector("_ClipDir", currentCamera.transform.forward);
			}
			else if (matOrtho)
			{
				ResetMaterial();
			}
			if (_useSinglePassStereoRenderingMatrix && VRCheck.IsVrRunning())
			{
				fogMat.SetMatrix("_ClipToWorld", currentCamera.cameraToWorldMatrix);
			}
			else
			{
				fogMat.SetMatrix("_ClipToWorld", currentCamera.cameraToWorldMatrix * currentCamera.projectionMatrix.inverse);
			}
			currentCamera.targetTexture = null;
			Graphics.Blit(rt, null, fogMat);
			RenderTexture.ReleaseTemporary(rt);
		}
	}
	[ExecuteInEditMode]
	[HelpURL("https://kronnect.com/support")]
	public class DynamicFogManager : MonoBehaviour
	{
		[Range(0f, 1f)]
		public float alpha = 1f;

		[Range(0f, 1f)]
		public float noiseStrength = 0.5f;

		[Range(0f, 0.999f)]
		public float distance = 0.2f;

		[Range(0f, 2f)]
		public float distanceFallOff = 1f;

		[Range(0f, 500f)]
		public float height = 1f;

		[Range(0f, 1f)]
		public float heightFallOff = 1f;

		public float baselineHeight;

		public Color color = new Color(0.89f, 0.89f, 0.89f, 1f);

		public GameObject sun;

		private Light sunLight;

		private Vector3 sunDirection = Vector3.zero;

		private Color sunColor = Color.white;

		private float sunIntensity = 1f;

		private void OnEnable()
		{
			UpdateMaterialProperties();
		}

		private void Reset()
		{
			UpdateMaterialProperties();
		}

		private void Update()
		{
			if (sun != null)
			{
				bool flag = false;
				if (sun.transform.forward != sunDirection)
				{
					flag = true;
				}
				if (sunLight != null && (sunLight.color != sunColor || sunLight.intensity != sunIntensity))
				{
					flag = true;
				}
				if (flag)
				{
					UpdateFogColor();
				}
			}
			UpdateFogData();
		}

		public void UpdateMaterialProperties()
		{
			UpdateFogData();
			UpdateFogColor();
		}

		private void UpdateFogData()
		{
			Vector4 value = new Vector4(height + 0.001f, baselineHeight, Camera.main.farClipPlane * distance, heightFallOff);
			Shader.SetGlobalVector("_FogData", value);
			Shader.SetGlobalFloat("_FogData2", distanceFallOff * value.z + 0.0001f);
		}

		private void UpdateFogColor()
		{
			if (sun != null)
			{
				if (sunLight == null)
				{
					sunLight = sun.GetComponent<Light>();
				}
				if (sunLight != null && sunLight.transform != sun.transform)
				{
					sunLight = sun.GetComponent<Light>();
				}
				sunDirection = sun.transform.forward;
				if (sunLight != null)
				{
					sunColor = sunLight.color;
					sunIntensity = sunLight.intensity;
				}
			}
			float num = sunIntensity * Mathf.Clamp01(1f - sunDirection.y);
			Color value = color * sunColor * num;
			value.a = alpha;
			Shader.SetGlobalColor("_FogColor", value);
		}
	}
	[ExecuteInEditMode]
	public class DynamicFogOfWar : MonoBehaviour
	{
		public int fogOfWarTextureSize = 512;

		private Material fogMat;

		private static DynamicFogOfWar _instance;

		private Texture2D fogOfWarTexture;

		private Color32[] fogOfWarColorBuffer;

		public static DynamicFogOfWar instance
		{
			get
			{
				if (_instance == null)
				{
					_instance = UnityEngine.Object.FindObjectOfType<DynamicFogOfWar>();
				}
				return _instance;
			}
		}

		private void OnEnable()
		{
			fogMat = GetComponent<MeshRenderer>().sharedMaterial;
			UpdateFogOfWarTexture();
		}

		private void OnDisable()
		{
			if (fogOfWarTexture != null)
			{
				UnityEngine.Object.DestroyImmediate(fogOfWarTexture);
				fogOfWarTexture = null;
			}
		}

		private void Update()
		{
			fogMat.SetVector("_FogOfWarData", new Vector4(base.transform.position.x, base.transform.position.z, base.transform.localScale.x, base.transform.localScale.y));
		}

		private void UpdateFogOfWarTexture()
		{
			int scaledSize = GetScaledSize(fogOfWarTextureSize, 1f);
			fogOfWarTexture = new Texture2D(scaledSize, scaledSize, TextureFormat.ARGB32, mipChain: false);
			fogOfWarTexture.hideFlags = HideFlags.DontSave;
			fogOfWarTexture.filterMode = FilterMode.Bilinear;
			fogOfWarTexture.wrapMode = TextureWrapMode.Clamp;
			fogMat.mainTexture = fogOfWarTexture;
			ResetFogOfWar();
		}

		private int GetScaledSize(int size, float factor)
		{
			size = (int)((float)size / factor);
			size /= 4;
			if (size < 1)
			{
				size = 1;
			}
			return size * 4;
		}

		public float GetFogOfWarAlpha(Vector3 worldPosition)
		{
			if (fogOfWarTexture == null)
			{
				return 1f;
			}
			float num = (worldPosition.x - base.transform.position.x) / base.transform.localScale.x + 0.5f;
			if (num < 0f || num > 1f)
			{
				return 1f;
			}
			float num2 = (worldPosition.z - base.transform.position.z) / base.transform.localScale.y + 0.5f;
			if (num2 < 0f || num2 > 1f)
			{
				return 1f;
			}
			int width = fogOfWarTexture.width;
			int height = fogOfWarTexture.height;
			int num3 = (int)(num * (float)width);
			int num4 = (int)(num2 * (float)height) * width + num3;
			return (float)(int)fogOfWarColorBuffer[num4].a / 255f;
		}

		public void SetFogOfWarAlpha(Vector3 worldPosition, float radius, float fogNewAlpha)
		{
			if (fogOfWarTexture == null)
			{
				return;
			}
			float num = (worldPosition.x - base.transform.position.x) / base.transform.localScale.x + 0.5f;
			if (num < 0f || num > 1f)
			{
				return;
			}
			float num2 = (worldPosition.z - base.transform.position.z) / base.transform.localScale.y + 0.5f;
			if (num2 < 0f || num2 > 1f)
			{
				return;
			}
			int width = fogOfWarTexture.width;
			int height = fogOfWarTexture.height;
			int num3 = (int)(num * (float)width);
			int num4 = (int)(num2 * (float)height);
			int num5 = num4 * width + num3;
			byte b = (byte)(fogNewAlpha * 255f);
			Color32 color = fogOfWarColorBuffer[num5];
			if (b == color.a)
			{
				return;
			}
			float num6 = radius / base.transform.localScale.y;
			int num7 = Mathf.FloorToInt((float)height * num6);
			for (int i = num4 - num7; i <= num4 + num7; i++)
			{
				if (i < 0 || i >= height)
				{
					continue;
				}
				for (int j = num3 - num7; j <= num3 + num7; j++)
				{
					if (j >= 0 && j < width)
					{
						int num8 = (int)Mathf.Sqrt((num4 - i) * (num4 - i) + (num3 - j) * (num3 - j));
						if (num8 <= num7)
						{
							num5 = i * width + j;
							Color32 color2 = fogOfWarColorBuffer[num5];
							color2.a = (byte)Mathf.Lerp((int)b, (int)color2.a, (float)num8 / (float)num7);
							fogOfWarColorBuffer[num5] = color2;
							fogOfWarTexture.SetPixel(j, i, color2);
						}
					}
				}
			}
			fogOfWarTexture.Apply();
		}

		public void ResetFogOfWar()
		{
			if (!(fogOfWarTexture == null))
			{
				int height = fogOfWarTexture.height;
				int width = fogOfWarTexture.width;
				int num = height * width;
				if (fogOfWarColorBuffer == null || fogOfWarColorBuffer.Length != num)
				{
					fogOfWarColorBuffer = new Color32[num];
				}
				Color32 color = new Color32(byte.MaxValue, byte.MaxValue, byte.MaxValue, byte.MaxValue);
				for (int i = 0; i < num; i++)
				{
					fogOfWarColorBuffer[i] = color;
				}
				fogOfWarTexture.SetPixels32(fogOfWarColorBuffer);
				fogOfWarTexture.Apply();
			}
		}

		public void SetFogOfWarTerrainBoundary(Terrain terrain, float borderWidth)
		{
			TerrainData terrainData = terrain.terrainData;
			int heightmapResolution = terrainData.heightmapResolution;
			int heightmapResolution2 = terrainData.heightmapResolution;
			float y = terrainData.size.y;
			float[,] heights = terrainData.GetHeights(0, 0, heightmapResolution, heightmapResolution2);
			float num = base.transform.position.y - 1f;
			float num2 = base.transform.position.y + 10f;
			Vector3 position = terrain.GetPosition();
			for (int i = 0; i < heightmapResolution2; i++)
			{
				for (int j = 0; j < heightmapResolution; j++)
				{
					float num3 = heights[i, j] * y + terrain.transform.position.y;
					if (num3 > num && num3 < num2)
					{
						Vector3 worldPosition = position + new Vector3(terrainData.size.x * ((float)j + 0.5f) / (float)heightmapResolution, 0f, terrainData.size.z * ((float)i + 0.5f) / (float)heightmapResolution2);
						SetFogOfWarAlpha(worldPosition, borderWidth, 0f);
					}
				}
			}
		}
	}
	[CreateAssetMenu(fileName = "DynamicFogProfile", menuName = "Dynamic Fog Profile", order = 100)]
	public class DynamicFogProfile : ScriptableObject
	{
		public FOG_TYPE effectType = FOG_TYPE.DesktopFogPlusWithSkyHaze;

		public bool enableDithering;

		[Range(0f, 0.2f)]
		public float ditherStrength = 0.03f;

		[Range(0f, 1f)]
		public float alpha = 1f;

		[Range(0f, 1f)]
		public float noiseStrength = 0.5f;

		[Range(0.01f, 1f)]
		public float noiseScale = 0.1f;

		[Range(0f, 0.999f)]
		public float distance = 0.1f;

		[Range(0.0001f, 2f)]
		public float distanceFallOff = 0.01f;

		[Range(0f, 1.2f)]
		public float maxDistance = 0.999f;

		[Range(0.0001f, 0.5f)]
		public float maxDistanceFallOff;

		[Range(0f, 500f)]
		public float height = 1f;

		[Range(0f, 500f)]
		public float maxHeight = 100f;

		[Range(0.0001f, 1f)]
		public float heightFallOff = 0.1f;

		public float baselineHeight;

		public bool clipUnderBaseline;

		[Range(0f, 15f)]
		public float turbulence = 0.1f;

		[Range(0f, 5f)]
		public float speed = 0.1f;

		public Vector3 windDirection = new Vector3(1f, 0f, 1f);

		public Color color = Color.white;

		public Color color2 = Color.gray;

		[Range(0f, 500f)]
		public float skyHaze = 50f;

		[Range(0f, 1f)]
		public float skySpeed = 0.3f;

		[Range(0f, 1f)]
		public float skyNoiseStrength = 0.1f;

		[Range(0f, 1f)]
		public float skyAlpha = 1f;

		public bool useXZDistance;

		[Range(0f, 1f)]
		public float scattering = 0.7f;

		public Color scatteringColor = new Color(1f, 1f, 0.8f);

		public void Load(DynamicFogBase fog)
		{
			fog.preset = FOG_PRESET.Custom;
			fog.effectType = effectType;
			fog.enableDithering = enableDithering;
			fog.ditherStrength = ditherStrength;
			fog.alpha = alpha;
			fog.noiseStrength = noiseStrength;
			fog.noiseScale = noiseScale;
			fog.distance = distance;
			fog.distanceFallOff = distanceFallOff;
			fog.maxDistance = maxDistance;
			fog.maxDistanceFallOff = maxDistanceFallOff;
			fog.height = height;
			fog.maxHeight = maxHeight;
			fog.heightFallOff = heightFallOff;
			fog.baselineHeight = baselineHeight;
			fog.clipUnderBaseline = clipUnderBaseline;
			fog.turbulence = turbulence;
			fog.speed = speed;
			fog.windDirection = windDirection;
			fog.color = color;
			fog.color2 = color2;
			fog.skyHaze = skyHaze;
			fog.skySpeed = skySpeed;
			fog.skyNoiseStrength = skyNoiseStrength;
			fog.skyAlpha = skyAlpha;
			fog.useXZDistance = useXZDistance;
			fog.scattering = scattering;
			fog.scatteringColor = scatteringColor;
		}

		public void Save(DynamicFogBase fog)
		{
			effectType = fog.effectType;
			enableDithering = fog.enableDithering;
			ditherStrength = fog.ditherStrength;
			alpha = fog.alpha;
			noiseStrength = fog.noiseStrength;
			noiseScale = fog.noiseScale;
			distance = fog.distance;
			distanceFallOff = fog.distanceFallOff;
			maxDistance = fog.maxDistance;
			maxDistanceFallOff = fog.maxDistanceFallOff;
			height = fog.height;
			maxHeight = fog.maxHeight;
			heightFallOff = fog.heightFallOff;
			baselineHeight = fog.baselineHeight;
			clipUnderBaseline = fog.clipUnderBaseline;
			turbulence = fog.turbulence;
			speed = fog.speed;
			windDirection = fog.windDirection;
			color = fog.color;
			color2 = fog.color2;
			skyHaze = fog.skyHaze;
			skySpeed = fog.skySpeed;
			skyNoiseStrength = fog.skyNoiseStrength;
			skyAlpha = fog.skyAlpha;
			useXZDistance = fog.useXZDistance;
			scattering = fog.scattering;
			scatteringColor = fog.scatteringColor;
		}

		public static void Lerp(DynamicFogProfile profile1, DynamicFogProfile profile2, float t, DynamicFogBase fog)
		{
			if (t < 0f)
			{
				t = 0f;
			}
			else if (t > 1f)
			{
				t = 1f;
			}
			fog.enableDithering = ((t < 0.5f) ? profile1.enableDithering : profile2.enableDithering);
			fog.ditherStrength = profile1.ditherStrength * (1f - t) + profile2.ditherStrength * t;
			fog.alpha = profile1.alpha * (1f - t) + profile2.alpha * t;
			fog.noiseStrength = profile1.noiseStrength * (1f - t) + profile2.noiseStrength * t;
			fog.noiseScale = profile1.noiseScale * (1f - t) + profile2.noiseScale * t;
			fog.distance = profile1.distance * (1f - t) + profile2.distance * t;
			fog.distanceFallOff = profile1.distanceFallOff * (1f - t) + profile2.distanceFallOff * t;
			fog.maxDistance = profile1.maxDistance * (1f - t) + profile2.maxDistance * t;
			fog.maxDistanceFallOff = profile1.maxDistanceFallOff * (1f - t) + profile2.maxDistanceFallOff * t;
			fog.height = profile1.height * (1f - t) + profile2.height * t;
			fog.maxHeight = profile1.maxHeight * (1f - t) + profile2.maxHeight * t;
			fog.heightFallOff = profile1.heightFallOff * (1f - t) + profile2.heightFallOff * t;
			fog.baselineHeight = profile1.baselineHeight * (1f - t) + profile2.baselineHeight * t;
			fog.clipUnderBaseline = ((t < 0.5f) ? profile1.clipUnderBaseline : profile2.clipUnderBaseline);
			fog.turbulence = profile1.turbulence * (1f - t) + profile2.turbulence * t;
			fog.speed = profile1.speed * (1f - t) + profile2.speed * t;
			fog.windDirection = profile1.windDirection * (1f - t) + profile2.windDirection * t;
			fog.color = profile1.color * (1f - t) + profile2.color * t;
			fog.color2 = profile1.color2 * (1f - t) + profile2.color * t;
			fog.skyHaze = profile1.skyHaze * (1f - t) + profile2.skyHaze * t;
			fog.skySpeed = profile1.skySpeed * (1f - t) + profile2.skySpeed * t;
			fog.skyNoiseStrength = profile1.skyNoiseStrength * (1f - t) + profile2.skyNoiseStrength * t;
			fog.skyAlpha = profile1.skyAlpha * (1f - t) + profile2.skyAlpha * t;
			fog.useXZDistance = ((t < 0.5f) ? profile1.useXZDistance : profile2.useXZDistance);
			fog.scattering = profile1.scattering * (1f - t) + profile2.scattering * t;
			fog.scatteringColor = profile1.scatteringColor * (1f - t) + profile2.scatteringColor * t;
		}
	}
	public class FogVolume : MonoBehaviour
	{
		private const float GRAY = 0.8901961f;

		[Tooltip("Enables transition to a given profile.")]
		public bool enableProfileTransition;

		[Tooltip("Assign the transition profile.")]
		public DynamicFogProfile targetProfile;

		[Tooltip("Enables alpha transition.")]
		public bool enableAlphaTransition;

		[Tooltip("Target alpha for fog when camera enters this fog volume")]
		[Range(0f, 1f)]
		public float targetFogAlpha = 0.5f;

		[Tooltip("Target alpha for sky haze when camera enters this fog volume")]
		[Range(0f, 1f)]
		public float targetSkyHazeAlpha = 0.5f;

		[Tooltip("Enables fog color transition.")]
		public bool enableFogColorTransition;

		[Tooltip("Target fog color 1 when gamera enters this fog folume")]
		public Color targetFogColor1 = new Color(0.8901961f, 0.8901961f, 0.8901961f);

		[Tooltip("Target fog color 2 when gamera enters this fog folume")]
		public Color targetFogColor2 = new Color(0.8901961f, 0.8901961f, 0.8901961f);

		[Tooltip("Set this to zero for changing fog alpha immediately upon enter/exit fog volume.")]
		public float transitionDuration = 3f;

		[Tooltip("Set collider that will trigger this fog volume. If not set, this fog volume will react to any collider which has the main camera. If you use a third person controller, assign the character collider here.")]
		public Collider targetCollider;

		[Tooltip("When enabled, a console message will be printed whenever this fog volume is entered or exited.")]
		public bool debugMode;

		[Tooltip("Assign target Dynamic Fog component that will be affected by this volume.")]
		public DynamicFog targetFog;

		private bool cameraInside;

		private void Start()
		{
			if (targetFog == null)
			{
				targetFog = DynamicFogBase.instance;
			}
			if (targetFog != null)
			{
				targetFog.useFogVolumes = true;
			}
		}

		private void OnTriggerEnter(Collider other)
		{
			if (!cameraInside && !(targetFog == null) && (other == targetCollider || other.gameObject.transform.GetComponentInChildren<Camera>() == targetFog.fogCamera))
			{
				cameraInside = true;
				if (enableProfileTransition && targetProfile != null)
				{
					targetFog.SetTargetProfile(targetProfile, transitionDuration);
				}
				if (enableAlphaTransition)
				{
					targetFog.SetTargetAlpha(targetFogAlpha, targetSkyHazeAlpha, transitionDuration);
				}
				if (enableFogColorTransition)
				{
					targetFog.SetTargetColors(targetFogColor1, targetFogColor2, transitionDuration);
				}
				if (debugMode)
				{
					UnityEngine.Debug.Log("Fog Volume entered by " + other.name);
				}
			}
		}

		private void OnTriggerExit(Collider other)
		{
			if (cameraInside && !(targetFog == null) && (other == targetCollider || other.gameObject.transform.GetComponentInChildren<Camera>() == targetFog.fogCamera))
			{
				cameraInside = false;
				if (enableProfileTransition && targetProfile != null)
				{
					targetFog.ClearTargetProfile(transitionDuration);
				}
				if (enableAlphaTransition)
				{
					targetFog.ClearTargetAlpha(transitionDuration);
				}
				if (enableFogColorTransition)
				{
					targetFog.ClearTargetColors(transitionDuration);
				}
				if (debugMode)
				{
					UnityEngine.Debug.Log("Fog Volume exited by " + other.name);
				}
			}
		}
	}
	public static class VRCheck
	{
		private static List<XRDisplaySubsystemDescriptor> displaysDescs = new List<XRDisplaySubsystemDescriptor>();

		private static List<XRDisplaySubsystem> displays = new List<XRDisplaySubsystem>();

		public static bool IsActive()
		{
			displaysDescs.Clear();
			SubsystemManager.GetSubsystemDescriptors(displaysDescs);
			return displaysDescs.Count > 0;
		}

		public static bool IsVrRunning()
		{
			bool result = false;
			displays.Clear();
			SubsystemManager.GetInstances(displays);
			foreach (XRDisplaySubsystem display in displays)
			{
				if (display.running)
				{
					result = true;
					break;
				}
			}
			return result;
		}
	}
}
namespace VolumetricFogAndMist
{
	public class DemoMultipleFogAreas : MonoBehaviour
	{
		private void Update()
		{
			if (Input.GetKeyDown(KeyCode.C))
			{
				CreateCloud();
			}
			else if (Input.GetKeyDown(KeyCode.B))
			{
				CreateBoxFog();
			}
			else if (Input.GetKeyDown(KeyCode.X))
			{
				VolumetricFog.RemoveAllFogAreas();
			}
		}

		private void CreateCloud()
		{
			Vector3 position = Camera.main.transform.position + Camera.main.transform.forward * 100f + UnityEngine.Random.insideUnitSphere * 50f;
			if (position.y < 10f)
			{
				position.y = 10f;
			}
			float radius = UnityEngine.Random.value * 50f + 85f;
			VolumetricFog.CreateFogArea(position, radius).color = new Color(0.6f, 0.57f, 0.5f, 1f);
		}

		private void CreateBoxFog()
		{
			Vector3 position = Camera.main.transform.position + Camera.main.transform.forward * 100f + UnityEngine.Random.insideUnitSphere * 50f;
			if (position.y < 10f)
			{
				position.y = 10f;
			}
			VolumetricFog obj = VolumetricFog.CreateFogArea(boxSize: new Vector3(UnityEngine.Random.value * 50f + 35f, UnityEngine.Random.value * 10f + 15f, UnityEngine.Random.value * 50f + 35f), position: position);
			obj.color = new Color(0.6f, 0.57f, 0.5f, 1f);
			obj.noiseScale = 2f;
		}
	}
	public class DemoDepthBlur : MonoBehaviour
	{
		private void Start()
		{
			GameObject.Find("Elephant").GetComponent<Renderer>().shadowCastingMode = ShadowCastingMode.On;
		}

		private void Update()
		{
			VolumetricFog instance = VolumetricFog.instance;
			if (Input.GetKeyDown(KeyCode.T))
			{
				instance.fogBlur = !instance.fogBlur;
			}
		}
	}
	public class DemoXYLights : MonoBehaviour
	{
		public Vector3 attractionPos = new Vector3(0f, 0f, -1f);

		private Vector3[] fairyDirections = new Vector3[6];

		private void Update()
		{
			for (int i = 0; i < 6; i++)
			{
				Light pointLight = VolumetricFog.instance.GetPointLight(i);
				if (pointLight != null)
				{
					pointLight.transform.position += fairyDirections[i];
					Vector3 position = pointLight.transform.position;
					if (position.x > attractionPos.x)
					{
						fairyDirections[i].x -= 0.01f;
					}
					else
					{
						fairyDirections[i].x += 0.01f;
					}
					if (position.y > attractionPos.y)
					{
						fairyDirections[i].y -= 0.01f;
					}
					else
					{
						fairyDirections[i].y += 0.01f;
					}
					if (position.z > attractionPos.z - 1f)
					{
						fairyDirections[i].z -= 0.0001f;
					}
					else
					{
						fairyDirections[i].z += 0.0001f;
					}
				}
			}
		}
	}
	public class CameraMove : MonoBehaviour
	{
		private void Update()
		{
			float angle = Time.deltaTime * 10f;
			Camera.main.transform.RotateAround(Vector3.zero, Vector3.up, angle);
			Camera.main.transform.LookAt(new Vector3(0f, 0f, 0f));
			Camera.main.transform.rotation *= Quaternion.Euler(Mathf.Sin(Time.time * 0.05f) * 60f - 45f, 0f, 0f);
		}
	}
	public class DemoWalk : MonoBehaviour
	{
		private Text status;

		private void Start()
		{
			GameObject gameObject = GameObject.Find("Elephant");
			if (gameObject != null)
			{
				gameObject.GetComponent<Renderer>().shadowCastingMode = ShadowCastingMode.On;
			}
			status = GameObject.Find("Status").GetComponent<Text>();
		}

		private void Update()
		{
			VolumetricFog instance = VolumetricFog.instance;
			if (Input.GetKeyDown(KeyCode.F))
			{
				instance.baselineHeight = 0f;
				switch (instance.preset)
				{
				case FOG_PRESET.Clear:
				case FOG_PRESET.Custom:
					instance.preset = FOG_PRESET.Mist;
					break;
				case FOG_PRESET.Mist:
					instance.preset = FOG_PRESET.WindyMist;
					break;
				case FOG_PRESET.WindyMist:
					instance.preset = FOG_PRESET.GroundFog;
					break;
				case FOG_PRESET.GroundFog:
					instance.preset = FOG_PRESET.FrostedGround;
					break;
				case FOG_PRESET.FrostedGround:
					instance.preset = FOG_PRESET.FoggyLake;
					break;
				case FOG_PRESET.FoggyLake:
					instance.preset = FOG_PRESET.Fog;
					break;
				case FOG_PRESET.Fog:
					instance.preset = FOG_PRESET.HeavyFog;
					break;
				case FOG_PRESET.HeavyFog:
					instance.preset = FOG_PRESET.LowClouds;
					break;
				case FOG_PRESET.LowClouds:
					instance.preset = FOG_PRESET.SeaClouds;
					break;
				case FOG_PRESET.SeaClouds:
					instance.preset = FOG_PRESET.Smoke;
					break;
				case FOG_PRESET.Smoke:
					instance.preset = FOG_PRESET.ToxicSwamp;
					break;
				case FOG_PRESET.ToxicSwamp:
					instance.preset = FOG_PRESET.SandStorm1;
					break;
				case FOG_PRESET.SandStorm1:
					instance.preset = FOG_PRESET.SandStorm2;
					break;
				case FOG_PRESET.SandStorm2:
					instance.preset = FOG_PRESET.Mist;
					break;
				}
			}
			else if (Input.GetKeyDown(KeyCode.T))
			{
				instance.enabled = !instance.enabled;
			}
			status.text = "Current fog preset: " + VolumetricFog.instance.GetCurrentPresetName();
		}
	}
	public class DemoFogOfWar : MonoBehaviour
	{
		private bool fogCuttingOn = true;

		private VolumetricFog fog;

		private Text status;

		private void Start()
		{
			fog = VolumetricFog.instance;
			fog.fogOfWarEnabled = fogCuttingOn;
			fog.ResetFogOfWar();
			status = GameObject.Find("Status").GetComponent<Text>();
		}

		private void Update()
		{
			if (Input.GetKeyDown(KeyCode.F))
			{
				switch (fog.preset)
				{
				case FOG_PRESET.Clear:
				case FOG_PRESET.Custom:
					fog.preset = FOG_PRESET.Mist;
					break;
				case FOG_PRESET.Mist:
					fog.preset = FOG_PRESET.WindyMist;
					break;
				case FOG_PRESET.WindyMist:
					fog.preset = FOG_PRESET.GroundFog;
					break;
				case FOG_PRESET.GroundFog:
					fog.preset = FOG_PRESET.FrostedGround;
					break;
				case FOG_PRESET.FrostedGround:
					fog.preset = FOG_PRESET.FoggyLake;
					break;
				case FOG_PRESET.FoggyLake:
					fog.preset = FOG_PRESET.Fog;
					break;
				case FOG_PRESET.Fog:
					fog.preset = FOG_PRESET.HeavyFog;
					break;
				case FOG_PRESET.HeavyFog:
					fog.preset = FOG_PRESET.LowClouds;
					break;
				case FOG_PRESET.LowClouds:
					fog.preset = FOG_PRESET.SeaClouds;
					break;
				case FOG_PRESET.SeaClouds:
					fog.preset = FOG_PRESET.Smoke;
					break;
				case FOG_PRESET.Smoke:
					fog.preset = FOG_PRESET.ToxicSwamp;
					break;
				case FOG_PRESET.ToxicSwamp:
					fog.preset = FOG_PRESET.SandStorm1;
					break;
				case FOG_PRESET.SandStorm1:
					fog.preset = FOG_PRESET.SandStorm2;
					break;
				case FOG_PRESET.SandStorm2:
					fog.preset = FOG_PRESET.Mist;
					break;
				}
			}
			else if (Input.GetKeyDown(KeyCode.T))
			{
				fog.enabled = !fog.enabled;
			}
			else if (Input.GetKeyDown(KeyCode.C))
			{
				fogCuttingOn = !fogCuttingOn;
				fog.fogOfWarEnabled = fogCuttingOn;
				fog.ResetFogOfWar();
			}
			else if (Input.GetKeyDown(KeyCode.R))
			{
				fog.ResetFogOfWar();
			}
			if (fogCuttingOn)
			{
				fog.SetFogOfWarAlpha(Camera.main.transform.position, 16f, 0f);
			}
			string text = VolumetricFog.instance.GetCurrentPresetName();
			if (fogCuttingOn)
			{
				text += "  *** FOG CUTTING ON ***";
			}
			status.text = text;
		}

		private void AssignCustomTexture()
		{
			VolumetricFog instance = VolumetricFog.instance;
			Color32[] pixels = Resources.Load<Texture2D>("Textures/alphaDemo").GetPixels32();
			instance.fogOfWarTextureSize = 64;
			instance.fogOfWarTextureData = pixels;
		}
	}
	public class DemoPointLight : MonoBehaviour
	{
		public Vector3 attractionPos = new Vector3(-58f, 3f, -19f);

		private Vector3[] fairyDirections;

		private void Start()
		{
			fairyDirections = new Vector3[6];
			for (int i = 0; i < fairyDirections.Length; i++)
			{
				Light pointLight = VolumetricFog.instance.GetPointLight(i);
				if (pointLight != null)
				{
					pointLight.color = new Color(UnityEngine.Random.value, UnityEngine.Random.value, UnityEngine.Random.value);
				}
			}
		}

		private void Update()
		{
			for (int i = 0; i < fairyDirections.Length; i++)
			{
				Light pointLight = VolumetricFog.instance.GetPointLight(i);
				if (pointLight != null)
				{
					pointLight.transform.position += fairyDirections[i];
					Vector3 position = pointLight.transform.position;
					if (position.x > attractionPos.x)
					{
						fairyDirections[i].x -= 0.01f;
					}
					else
					{
						fairyDirections[i].x += 0.01f;
					}
					if (position.y > attractionPos.y + 1f)
					{
						fairyDirections[i].y -= 0.001f;
					}
					else
					{
						fairyDirections[i].y += 0.001f;
					}
					if (position.z > attractionPos.z)
					{
						fairyDirections[i].z -= 0.01f;
					}
					else
					{
						fairyDirections[i].z += 0.01f;
					}
				}
			}
		}
	}
	public class DemoShafts : MonoBehaviour
	{
		private VolumetricFog fog;

		private void Start()
		{
			fog = VolumetricFog.instance;
		}

		private void Update()
		{
			if (Input.GetKeyDown(KeyCode.F))
			{
				switch (fog.preset)
				{
				case FOG_PRESET.Clear:
					fog.preset = FOG_PRESET.Mist;
					break;
				case FOG_PRESET.Mist:
					fog.preset = FOG_PRESET.WindyMist;
					break;
				case FOG_PRESET.WindyMist:
					fog.preset = FOG_PRESET.GroundFog;
					break;
				case FOG_PRESET.GroundFog:
					fog.preset = FOG_PRESET.FrostedGround;
					break;
				case FOG_PRESET.FrostedGround:
					fog.preset = FOG_PRESET.FoggyLake;
					break;
				case FOG_PRESET.FoggyLake:
					fog.preset = FOG_PRESET.Fog;
					break;
				case FOG_PRESET.Fog:
					fog.preset = FOG_PRESET.HeavyFog;
					break;
				case FOG_PRESET.HeavyFog:
					fog.preset = FOG_PRESET.LowClouds;
					break;
				case FOG_PRESET.LowClouds:
					fog.preset = FOG_PRESET.SeaClouds;
					break;
				case FOG_PRESET.SeaClouds:
					fog.preset = FOG_PRESET.Smoke;
					break;
				case FOG_PRESET.Smoke:
					fog.preset = FOG_PRESET.ToxicSwamp;
					break;
				case FOG_PRESET.ToxicSwamp:
					fog.preset = FOG_PRESET.SandStorm1;
					break;
				case FOG_PRESET.SandStorm1:
					fog.preset = FOG_PRESET.SandStorm2;
					break;
				case FOG_PRESET.SandStorm2:
					fog.preset = FOG_PRESET.Mist;
					break;
				}
			}
			else if (Input.GetKeyDown(KeyCode.T))
			{
				fog.enabled = !fog.enabled;
			}
			fog.sun.transform.Rotate(Vector3.left, Time.deltaTime);
		}

		private void OnGUI()
		{
			GUI.Label(new Rect(10f, 10f, Screen.width - 20, 30f), "Move around with WASD or cursor keys, space to jump, T to toggle fog on/off.");
			GUI.Label(new Rect(10f, 30f, Screen.width - 20, 30f), "Current fog preset: " + VolumetricFog.instance.GetCurrentPresetName());
		}
	}
	public class FreeCameraMove : MonoBehaviour
	{
		public float cameraSensitivity = 150f;

		public float climbSpeed = 20f;

		public float normalMoveSpeed = 20f;

		public float slowMoveFactor = 0.25f;

		public float fastMoveFactor = 3f;

		private float rotationX;

		private float rotationY;

		private void Update()
		{
			Vector2 vector = Input.mousePosition;
			if (!(vector.x < 0f) && !(vector.x > (float)Screen.width) && !(vector.y < 0f) && !(vector.y > (float)Screen.height))
			{
				rotationX += Input.GetAxis("Mouse X") * cameraSensitivity * Time.deltaTime;
				rotationY += Input.GetAxis("Mouse Y") * cameraSensitivity * Time.deltaTime;
				rotationY = Mathf.Clamp(rotationY, -90f, 90f);
				base.transform.localRotation = Quaternion.AngleAxis(rotationX, Vector3.up);
				base.transform.localRotation *= Quaternion.AngleAxis(rotationY, Vector3.left);
				if (Input.GetKey(KeyCode.LeftShift) || Input.GetKey(KeyCode.RightShift))
				{
					base.transform.position += base.transform.forward * (normalMoveSpeed * fastMoveFactor) * Input.GetAxis("Vertical") * Time.deltaTime;
					base.transform.position += base.transform.right * (normalMoveSpeed * fastMoveFactor) * Input.GetAxis("Horizontal") * Time.deltaTime;
				}
				else if (Input.GetKey(KeyCode.LeftControl) || Input.GetKey(KeyCode.RightControl))
				{
					base.transform.position += base.transform.forward * (normalMoveSpeed * slowMoveFactor) * Input.GetAxis("Vertical") * Time.deltaTime;
					base.transform.position += base.transform.right * (normalMoveSpeed * slowMoveFactor) * Input.GetAxis("Horizontal") * Time.deltaTime;
				}
				else
				{
					base.transform.position += base.transform.forward * normalMoveSpeed * Input.GetAxis("Vertical") * Time.deltaTime;
					base.transform.position += base.transform.right * normalMoveSpeed * Input.GetAxis("Horizontal") * Time.deltaTime;
				}
				if (Input.GetKey(KeyCode.Q))
				{
					base.transform.position -= base.transform.up * climbSpeed * Time.deltaTime;
				}
				if (Input.GetKey(KeyCode.E))
				{
					base.transform.position += base.transform.up * climbSpeed * Time.deltaTime;
				}
			}
		}
	}
	public class DemoBoxedArea : MonoBehaviour
	{
		private void Update()
		{
			VolumetricFog instance = VolumetricFog.instance;
			if (Input.GetKeyDown(KeyCode.T))
			{
				instance.enabled = !instance.enabled;
			}
		}
	}
	public class DemoSurroundingFog : MonoBehaviour
	{
		private FreeLookCam cam;

		private void Start()
		{
			cam = GetComponent<FreeLookCam>();
		}

		private void Update()
		{
			if (Input.GetKeyDown(KeyCode.C))
			{
				cam.enabled = !cam.enabled;
			}
		}
	}
	[AddComponentMenu("")]
	public class FogAreaCullingManager : MonoBehaviour
	{
		public VolumetricFog fog;

		private void OnEnable()
		{
			if (fog == null)
			{
				fog = GetComponent<VolumetricFog>();
				if (fog == null)
				{
					fog = base.gameObject.AddComponent<VolumetricFog>();
				}
			}
		}

		private void OnBecameVisible()
		{
			if (fog != null)
			{
				fog.enabled = true;
			}
		}

		private void OnBecameInvisible()
		{
			if (fog != null)
			{
				fog.enabled = false;
			}
		}
	}
	[ExecuteInEditMode]
	public class FogOfWarHole : MonoBehaviour
	{
		public enum HoleShape
		{
			Disc,
			Box
		}

		public HoleShape shape;

		[Range(0f, 1f)]
		[Tooltip("The transparency of the fog")]
		public float alpha;

		[Range(0f, 1f)]
		[Tooltip("The smoothness/harshness of the hole's border")]
		public float smoothness = 0.85f;

		private HoleShape lastShape;

		private Vector3 lastPosition = Vector3.zero;

		private Vector3 lastScale;

		private void Start()
		{
			StampHole(base.transform.position, shape, base.transform.localScale.x, base.transform.localScale.z);
		}

		private void RestoreHole(Vector3 position, HoleShape shape, float sizeX, float sizeZ)
		{
			VolumetricFog instance = VolumetricFog.instance;
			if (!(instance == null))
			{
				instance.fogOfWarEnabled = true;
				switch (shape)
				{
				case HoleShape.Box:
					instance.ResetFogOfWarAlpha(position, sizeX * 0.5f, sizeZ * 0.5f);
					break;
				case HoleShape.Disc:
					instance.ResetFogOfWarAlpha(position, Mathf.Max(sizeX, sizeZ) * 0.5f);
					break;
				}
			}
		}

		private void StampHole(Vector3 position, HoleShape shape, float sizeX, float sizeZ)
		{
			VolumetricFog instance = VolumetricFog.instance;
			if (!(instance == null))
			{
				instance.fogOfWarEnabled = true;
				switch (shape)
				{
				case HoleShape.Box:
					instance.SetFogOfWarAlpha(new Bounds(position, new Vector3(sizeX, 0f, sizeZ)), alpha, blendAlpha: false, 0f, smoothness, 0f, 0f);
					break;
				case HoleShape.Disc:
					instance.SetFogOfWarAlpha(position, Mathf.Max(sizeX, sizeZ) * 0.5f, alpha, blendAlpha: false, 0f, smoothness, 0f, 0f);
					break;
				}
				lastPosition = position;
				lastShape = shape;
				lastScale = base.transform.localScale;
			}
		}

		public void Refresh()
		{
			RestoreHole(lastPosition, lastShape, lastScale.x, lastScale.z);
			StampHole(base.transform.position, shape, base.transform.localScale.x, base.transform.localScale.z);
		}
	}
	[AddComponentMenu("")]
	public class FogVolume : MonoBehaviour
	{
		private const float GRAY = 0.8901961f;

		[Tooltip("Enables transition to a given profile.")]
		public bool enableProfileTransition;

		[Tooltip("Assign the transition profile.")]
		public VolumetricFogProfile targetProfile;

		[Tooltip("Enables alpha transition.")]
		public bool enableAlphaTransition;

		[Tooltip("Target alpha for fog when camera enters this fog volume")]
		[Range(0f, 1f)]
		public float targetFogAlpha = 0.5f;

		[Tooltip("Target alpha for sky haze when camera enters this fog volume")]
		[Range(0f, 1f)]
		public float targetSkyHazeAlpha = 0.5f;

		[Tooltip("Enables fog color transition.")]
		public bool enableFogColorTransition;

		[Tooltip("Target fog color 1 when gamera enters this fog folume")]
		public Color targetFogColor = new Color(0.8901961f, 0.8901961f, 0.8901961f);

		[Tooltip("Enables fog specular color transition.")]
		public bool enableFogSpecularColorTransition;

		[Tooltip("Target fog color 2 when gamera enters this fog folume")]
		public Color targetFogSpecularColor = new Color(0.8901961f, 0.8901961f, 0.8901961f);

		[Tooltip("Enables light color transition.")]
		public bool enableLightColorTransition;

		[Tooltip("Target light color when gamera enters this fog folume")]
		public Color targetLightColor = Color.white;

		[Tooltip("Set this to zero for changing fog alpha immediately upon enter/exit fog volume.")]
		public float transitionDuration = 3f;

		[Tooltip("Set collider that will trigger this fog volume. If not set, this fog volume will react to any collider which has the main camera. If you use a third person controller, assign the character collider here.")]
		public Collider targetCollider;

		[Tooltip("When enabled, a console message will be printed whenever this fog volume is entered or exited.")]
		public bool debugMode;

		[Tooltip("Assign target Volumetric Fog component that will be affected by this volume.")]
		public VolumetricFog targetFog;

		private bool cameraInside;

		private void Start()
		{
			if (targetFog == null)
			{
				targetFog = VolumetricFog.instance;
			}
			if (targetFog != null)
			{
				targetFog.useFogVolumes = true;
			}
		}

		private void OnTriggerEnter(Collider other)
		{
			if (!cameraInside && !(targetFog == null) && (other == targetCollider || other.gameObject.transform.GetComponentInChildren<Camera>() == targetFog.fogCamera))
			{
				cameraInside = true;
				if (enableProfileTransition && targetProfile != null)
				{
					targetFog.SetTargetProfile(targetProfile, transitionDuration);
				}
				if (enableAlphaTransition)
				{
					targetFog.SetTargetAlpha(targetFogAlpha, targetSkyHazeAlpha, transitionDuration);
				}
				if (enableFogColorTransition)
				{
					targetFog.SetTargetColor(targetFogColor, transitionDuration);
				}
				if (enableFogSpecularColorTransition)
				{
					targetFog.SetTargetSpecularColor(targetFogSpecularColor, transitionDuration);
				}
				if (enableLightColorTransition)
				{
					targetFog.SetTargetLightColor(targetLightColor, transitionDuration);
				}
				if (debugMode)
				{
					UnityEngine.Debug.Log("Fog Volume entered by " + other.name);
				}
			}
		}

		private void OnTriggerExit(Collider other)
		{
			if (cameraInside && !(targetFog == null) && (other == targetCollider || other.gameObject.transform.GetComponentInChildren<Camera>() == targetFog.fogCamera))
			{
				cameraInside = false;
				if (enableProfileTransition && targetProfile != null)
				{
					targetFog.ClearTargetProfile(transitionDuration);
				}
				if (enableAlphaTransition)
				{
					targetFog.ClearTargetAlpha(transitionDuration);
				}
				if (enableFogColorTransition)
				{
					targetFog.ClearTargetColor(transitionDuration);
				}
				if (enableFogSpecularColorTransition)
				{
					targetFog.ClearTargetSpecularColor(transitionDuration);
				}
				if (enableLightColorTransition)
				{
					targetFog.ClearTargetLightColor(transitionDuration);
				}
				if (debugMode)
				{
					UnityEngine.Debug.Log("Fog Volume exited by " + other.name);
				}
			}
		}
	}
	internal interface IVolumetricFogRenderComponent
	{
		VolumetricFog fog { get; set; }

		void DestroySelf();
	}
	[ExecuteInEditMode]
	public class ShadowMapCopy : MonoBehaviour
	{
		private Light m_Light;

		private CommandBuffer cb;

		private void OnEnable()
		{
			m_Light = GetComponent<Light>();
			if (m_Light == null)
			{
				UnityEngine.Debug.LogError("Light component not found on this gameobject. Make sure you have assigned a valid directional light to the Sun property of Volumetric Fog & Mist.");
				return;
			}
			cb = new CommandBuffer();
			cb.name = "Volumetric Fog ShadowMap Copy";
			cb.SetGlobalTexture("_VolumetricFogShadowMapCopy", new RenderTargetIdentifier(BuiltinRenderTextureType.CurrentActive));
			m_Light.AddCommandBuffer(LightEvent.AfterShadowMap, cb);
		}

		private void OnDisable()
		{
			if (m_Light != null)
			{
				m_Light.RemoveCommandBuffer(LightEvent.AfterShadowMap, cb);
			}
		}
	}
	public static class VRCheck
	{
		private static List<XRDisplaySubsystemDescriptor> displaysDescs = new List<XRDisplaySubsystemDescriptor>();

		private static List<XRDisplaySubsystem> displays = new List<XRDisplaySubsystem>();

		public static bool IsActive()
		{
			displaysDescs.Clear();
			SubsystemManager.GetSubsystemDescriptors(displaysDescs);
			return displaysDescs.Count > 0;
		}

		public static bool IsVrRunning()
		{
			bool result = false;
			displays.Clear();
			SubsystemManager.GetInstances(displays);
			foreach (XRDisplaySubsystem display in displays)
			{
				if (display.running)
				{
					result = true;
					break;
				}
			}
			return result;
		}
	}
	public enum FOG_PRESET
	{
		Clear = 0,
		Mist = 10,
		WindyMist = 11,
		LowClouds = 20,
		SeaClouds = 21,
		GroundFog = 30,
		FrostedGround = 31,
		FoggyLake = 32,
		Fog = 41,
		HeavyFog = 42,
		SandStorm1 = 50,
		Smoke = 51,
		ToxicSwamp = 52,
		SandStorm2 = 53,
		WorldEdge = 200,
		Custom = 1000
	}
	public enum SPSR_BEHAVIOUR
	{
		AutoDetect,
		ForcedOn,
		ForcedOff
	}
	public enum TRANSPARENT_MODE
	{
		None,
		Blend
	}
	public enum COMPUTE_DEPTH_SCOPE
	{
		OnlyTreeBillboards,
		EverythingInLayer,
		TreeBillboardsAndTransparentObjects
	}
	public enum LIGHTING_MODEL
	{
		Classic,
		Natural,
		SingleLight
	}
	public enum SUN_SHADOWS_BAKE_MODE
	{
		Realtime,
		Discrete
	}
	public enum FOG_VOID_TOPOLOGY
	{
		Sphere,
		Box
	}
	public enum FOG_AREA_TOPOLOGY
	{
		Sphere = 1,
		Box
	}
	public enum FOG_AREA_SORTING_MODE
	{
		DistanceToCamera,
		Altitude,
		Fixed
	}
	public enum FOG_AREA_FOLLOW_MODE
	{
		FullXYZ,
		RestrictToXZPlane
	}
	public enum FOG_VISIBILITY_SCOPE
	{
		Global,
		Volume
	}
	public struct FOG_TEMPORARY_PROPERTIES
	{
		public Color color;

		public float density;
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Image Effects/Rendering/Volumetric Fog & Mist")]
	[HelpURL("https://kronnect.com/support")]
	public class VolumetricFog : MonoBehaviour
	{
		[Serializable]
		public struct PointLightParams
		{
			public Light light;

			[HideInInspector]
			public VolumetricFogLightParams lightParams;

			public float range;

			public float rangeMultiplier;

			public float intensity;

			public float intensityMultiplier;

			public Vector3 position;

			public Color color;
		}

		private struct FogOfWarTransition
		{
			public bool enabled;

			public int x;

			public int y;

			public float startTime;

			public float startDelay;

			public float duration;

			public int initialAlpha;

			public int targetAlpha;
		}

		private static class ShaderParams
		{
			public static int FogWindDir = Shader.PropertyToID("_FogWindDir");

			public static int FogSkyData = Shader.PropertyToID("_FogSkyData");

			public static int LightMatrix = Shader.PropertyToID("_VolumetricFogLightMatrix");

			public static int CookieSize = Shader.PropertyToID("_VolumetricFogCookieSize");

			public static int CookieTex = Shader.PropertyToID("_VolumetricFogLightCookie");

			public static int FlickerFreeCamPos = Shader.PropertyToID("_FlickerFreeCamPos");

			public static int ClipDir = Shader.PropertyToID("_ClipDir");

			public static int ClipToWorld = Shader.PropertyToID("_ClipToWorld");

			public static int ShaftTex = Shader.PropertyToID("_ShaftTex");

			public static int DownsampledDepth = Shader.PropertyToID("_DownsampledDepth");

			public static int MainTex = Shader.PropertyToID("_MainTex");

			public static int FogDownsampled = Shader.PropertyToID("_FogDownsampled");

			public static int FogPointLightColor = Shader.PropertyToID("_FogPointLightColor");

			public static int FogPointLightPosition = Shader.PropertyToID("_FogPointLightPosition");

			public static int ScreenMaskTexture = Shader.PropertyToID("_VolumetricFogScreenMaskTexture");

			public static int SunPosition = Shader.PropertyToID("_SunPosition");

			public static int SunPositionRightEye = Shader.PropertyToID("_SunPositionRightEye");

			public static int FogScatteringData = Shader.PropertyToID("_FogScatteringData");

			public static int FogScatteringData2 = Shader.PropertyToID("_FogScatteringData2");

			public static int SunDir = Shader.PropertyToID("_SunDir");

			public static int SunColor = Shader.PropertyToID("_SunColor");

			public static int FogSkyColor = Shader.PropertyToID("_FogSkyColor");

			public static int FogSkyNoiseScale = Shader.PropertyToID("_FogSkyNoiseScale");

			public static int NoiseTex = Shader.PropertyToID("_NoiseTex");

			public static int FogData = Shader.PropertyToID("_FogData");

			public static int FogSkyHaze = Shader.PropertyToID("_FogSkyHaze");

			public static int FogVoidPosition = Shader.PropertyToID("_FogVoidPosition");

			public static int FogAreaPosition = Shader.PropertyToID("_FogAreaPosition");

			public static int DeepObscurance = Shader.PropertyToID("_DeepObscurance");

			public static int Jitter = Shader.PropertyToID("_Jitter");

			public static int FogStepping = Shader.PropertyToID("_FogStepping");

			public static int FogAlpha = Shader.PropertyToID("_FogAlpha");

			public static int FogDistance = Shader.PropertyToID("_FogDistance");

			public static int FogVoidData = Shader.PropertyToID("_FogVoidData");

			public static int FogAreaData = Shader.PropertyToID("_FogAreaData");

			public static int FogOfWar = Shader.PropertyToID("_FogOfWar");

			public static int FogOfWarCenter = Shader.PropertyToID("_FogOfWarCenter");

			public static int FogOfWarSize = Shader.PropertyToID("_FogOfWarSize");

			public static int FogOfWarCenterAdjusted = Shader.PropertyToID("_FogOfWarCenterAdjusted");

			public static int PointLightsInsideAtten = Shader.PropertyToID("_PointLightInsideAtten");

			public static int FogBlurDepth = Shader.PropertyToID("_FogBlurDepth");

			public static int VFM_CutOff = Shader.PropertyToID("_VFM_CutOff");

			public static int FogColor = Shader.PropertyToID("_FogColor");

			public static int BlurDepth = Shader.PropertyToID("_BlurDepth");

			public static int BlurTex = Shader.PropertyToID("_BlurTex");

			public static int Amount = Shader.PropertyToID("_Amount");

			public static int GlobalDepthTexture = Shader.PropertyToID("_VolumetricFogDepthTexture");

			public static int GlobalShadowBias = Shader.PropertyToID("_VF_ShadowBias");

			public static int GlobalSunProjection = Shader.PropertyToID("_VolumetricFogSunProj");

			public static int GlobalSunDepthTexture = Shader.PropertyToID("_VolumetricFogSunDepthTexture");

			public static int GlobalSunWorldPos = Shader.PropertyToID("_VolumetricFogSunWorldPos");

			public static int GlobalSunShadowsData = Shader.PropertyToID("_VolumetricFogSunShadowsData");
		}

		public const string SKW_FOG_DISTANCE_ON = "FOG_DISTANCE_ON";

		public const string SKW_LIGHT_SCATTERING = "FOG_SCATTERING_ON";

		public const string SKW_FOG_AREA_BOX = "FOG_AREA_BOX";

		public const string SKW_FOG_AREA_SPHERE = "FOG_AREA_SPHERE";

		public const string SKW_FOG_VOID_BOX = "FOG_VOID_BOX";

		public const string SKW_FOG_VOID_SPHERE = "FOG_VOID_SPHERE";

		public const string SKW_FOG_HAZE_ON = "FOG_HAZE_ON";

		public const string SKW_FOG_OF_WAR_ON = "FOG_OF_WAR_ON";

		public const string SKW_FOG_BLUR = "FOG_BLUR_ON";

		public const string SKW_SUN_SHADOWS = "FOG_SUN_SHADOWS_ON";

		public const string SKW_FOG_USE_XY_PLANE = "FOG_USE_XY_PLANE";

		public const string SKW_FOG_COMPUTE_DEPTH = "FOG_COMPUTE_DEPTH";

		public const string SKW_POINT_LIGHTS = "FOG_POINT_LIGHTS";

		private const string DEPTH_CAM_NAME = "VFMDepthCamera";

		private const string DEPTH_SUN_CAM_NAME = "VFMDepthSunCamera";

		private const string VFM_BUILD_FIRST_INSTALL = "VFMFirstInstall";

		private const string VFM_BUILD_HINT = "VFMBuildHint1083RC1";

		private static VolumetricFog _fog;

		[HideInInspector]
		public bool isDirty;

		[SerializeField]
		private FOG_PRESET _preset = FOG_PRESET.Mist;

		[SerializeField]
		private VolumetricFogProfile _profile;

		[SerializeField]
		private bool _profileSync;

		[SerializeField]
		private bool _useFogVolumes;

		[SerializeField]
		private bool _debugPass;

		[SerializeField]
		private bool _showInSceneView = true;

		[SerializeField]
		private TRANSPARENT_MODE _transparencyBlendMode;

		[SerializeField]
		[Range(0f, 1f)]
		private float _transparencyBlendPower = 1f;

		[SerializeField]
		private LayerMask _transparencyLayerMask = -1;

		[SerializeField]
		private FOG_VISIBILITY_SCOPE _visibilityScope;

		[SerializeField]
		private Bounds _visibilityVolume = new Bounds(Vector3.zero, new Vector3(1000f, 1000f, 1000f));

		[SerializeField]
		private LIGHTING_MODEL _lightingModel;

		[SerializeField]
		private bool _enableMultipleCameras;

		[SerializeField]
		private bool _computeDepth;

		[SerializeField]
		private COMPUTE_DEPTH_SCOPE _computeDepthScope;

		[SerializeField]
		private float _transparencyCutOff = 0.1f;

		[SerializeField]
		private bool _renderBeforeTransparent;

		[SerializeField]
		private GameObject _sun;

		[SerializeField]
		[Range(0f, 0.5f)]
		private float _timeBetweenTextureUpdates = 0.2f;

		[SerializeField]
		private bool _sunCopyColor = true;

		[SerializeField]
		[Range(0f, 1.25f)]
		private float _density = 1f;

		[SerializeField]
		[Range(0f, 1f)]
		private float _noiseStrength = 0.8f;

		[SerializeField]
		[Range(1f, 2f)]
		private float _noiseFinalMultiplier = 1f;

		[SerializeField]
		[Range(-0.3f, 2f)]
		private float _noiseSparse;

		[SerializeField]
		[Range(0f, 1000f)]
		private float _distance;

		[SerializeField]
		private float _maxFogLength = 1000f;

		[SerializeField]
		[Range(0f, 1f)]
		private float _maxFogLengthFallOff;

		[SerializeField]
		[Range(0f, 5f)]
		private float _distanceFallOff;

		[SerializeField]
		[Range(0.0001f, 500f)]
		private float _height = 4f;

		[SerializeField]
		[Range(0f, 1f)]
		private float _heightFallOff = 0.6f;

		[SerializeField]
		private float _deepObscurance = 1f;

		[SerializeField]
		private float _baselineHeight;

		[SerializeField]
		private bool _baselineRelativeToCamera;

		[SerializeField]
		[Range(0f, 1f)]
		private float _baselineRelativeToCameraDelay;

		[SerializeField]
		private float _noiseScale = 1f;

		[SerializeField]
		[Range(0f, 1.05f)]
		private float _alpha = 1f;

		[SerializeField]
		private Color _color = new Color(0.89f, 0.89f, 0.89f, 1f);

		[SerializeField]
		private Color _specularColor = new Color(1f, 1f, 0.8f, 1f);

		[SerializeField]
		[Range(0f, 1f)]
		private float _specularThreshold = 0.6f;

		[SerializeField]
		[Range(0f, 1f)]
		private float _specularIntensity = 0.2f;

		[SerializeField]
		private Vector3 _lightDirection = new Vector3(1f, 0f, -1f);

		[SerializeField]
		private float _lightIntensity = 0.2f;

		[SerializeField]
		private Color _lightColor = Color.white;

		[SerializeField]
		[Range(1f, 5f)]
		private int _updateTextureSpread = 1;

		[SerializeField]
		[Range(0f, 1f)]
		private float _speed = 0.01f;

		[SerializeField]
		private Vector3 _windDirection = new Vector3(-1f, 0f, 0f);

		[SerializeField]
		private bool _useRealTime;

		[SerializeField]
		private Color _skyColor = new Color(0.89f, 0.89f, 0.89f, 1f);

		[SerializeField]
		private float _skyHaze = 50f;

		[SerializeField]
		private float _skyNoiseScale = 1.5f;

		[SerializeField]
		[Range(0f, 1f)]
		private float _skySpeed = 0.3f;

		[SerializeField]
		[Range(0f, 1f)]
		private float _skyNoiseStrength = 0.1f;

		[SerializeField]
		[Range(0f, 1f)]
		private float _skyAlpha = 1f;

		[SerializeField]
		[Range(0f, 0.999f)]
		private float _skyDepth = 0.999f;

		[SerializeField]
		private GameObject _character;

		[SerializeField]
		private FOG_VOID_TOPOLOGY _fogVoidTopology;

		[SerializeField]
		[Range(0f, 10f)]
		private float _fogVoidFallOff = 1f;

		[SerializeField]
		private float _fogVoidRadius;

		[SerializeField]
		private Vector3 _fogVoidPosition;

		[SerializeField]
		private float _fogVoidDepth;

		[SerializeField]
		private float _fogVoidHeight;

		[SerializeField]
		private bool _fogVoidInverted;

		[SerializeField]
		private bool _fogVoidShowGizmos;

		[SerializeField]
		private bool _fogAreaShowGizmos = true;

		[SerializeField]
		private GameObject _fogAreaCenter;

		[SerializeField]
		[Range(0.001f, 10f)]
		private float _fogAreaFallOff = 1f;

		[SerializeField]
		private FOG_AREA_FOLLOW_MODE _fogAreaFollowMode;

		[SerializeField]
		private FOG_AREA_TOPOLOGY _fogAreaTopology = FOG_AREA_TOPOLOGY.Sphere;

		[SerializeField]
		private float _fogAreaRadius;

		[SerializeField]
		private Vector3 _fogAreaPosition = Vector3.zero;

		[SerializeField]
		private float _fogAreaDepth;

		[SerializeField]
		private float _fogAreaHeight;

		[SerializeField]
		private FOG_AREA_SORTING_MODE _fogAreaSortingMode;

		[SerializeField]
		private int _fogAreaRenderOrder = 1;

		public PointLightParams[] pointLightParams;

		[SerializeField]
		private bool pointLightDataMigrated;

		private Vector4[] pointLightColorBuffer;

		private Vector4[] pointLightPositionBuffer;

		[SerializeField]
		private GameObject[] _pointLights = new GameObject[6];

		[SerializeField]
		private float[] _pointLightRanges = new float[6];

		[SerializeField]
		private float[] _pointLightIntensities = new float[6] { 1f, 1f, 1f, 1f, 1f, 1f };

		[SerializeField]
		private float[] _pointLightIntensitiesMultiplier = new float[6] { 1f, 1f, 1f, 1f, 1f, 1f };

		[SerializeField]
		private Vector3[] _pointLightPositions = new Vector3[6];

		[SerializeField]
		private Color[] _pointLightColors = new Color[6]
		{
			new Color(1f, 1f, 0f, 1f),
			new Color(1f, 1f, 0f, 1f),
			new Color(1f, 1f, 0f, 1f),
			new Color(1f, 1f, 0f, 1f),
			new Color(1f, 1f, 0f, 1f),
			new Color(1f, 1f, 0f, 1f)
		};

		[SerializeField]
		private bool _pointLightTrackingAuto;

		[SerializeField]
		private Transform _pointLightTrackingPivot;

		[SerializeField]
		private int _pointLightTrackingCount;

		[SerializeField]
		[Range(0f, 5f)]
		private float _pointLightTrackingCheckInterval = 1f;

		[SerializeField]
		private float _pointLightTrackingNewLightsCheckInterval = 3f;

		[SerializeField]
		private float _pointLightInscattering = 1f;

		[SerializeField]
		private float _pointLightIntensity = 1f;

		[SerializeField]
		private float _pointLightInsideAtten;

		[SerializeField]
		[Range(1f, 8f)]
		private int _downsampling = 1;

		[SerializeField]
		private bool _forceComposition;

		[SerializeField]
		private bool _edgeImprove;

		[SerializeField]
		[Range(1E-05f, 0.005f)]
		private float _edgeThreshold = 0.0005f;

		[SerializeField]
		[Range(1f, 20f)]
		private float _stepping = 12f;

		[SerializeField]
		[Range(0f, 50f)]
		private float _steppingNear = 1f;

		[SerializeField]
		private bool _dithering;

		[SerializeField]
		[Range(0.1f, 5f)]
		private float _ditherStrength = 0.75f;

		[SerializeField]
		[Range(0f, 2f)]
		private float _jitterStrength = 0.5f;

		[SerializeField]
		private bool _lightScatteringEnabled;

		[SerializeField]
		[Range(0f, 1f)]
		private float _lightScatteringDiffusion = 0.7f;

		[SerializeField]
		[Range(0f, 1f)]
		private float _lightScatteringSpread = 0.686f;

		[SerializeField]
		[Range(4f, 64f)]
		private int _lightScatteringSamples = 16;

		[SerializeField]
		[Range(0f, 50f)]
		private float _lightScatteringWeight = 1.9f;

		[SerializeField]
		[Range(0f, 50f)]
		private float _lightScatteringIllumination = 18f;

		[SerializeField]
		[Range(0.9f, 1.1f)]
		private float _lightScatteringDecay = 0.986f;

		[SerializeField]
		[Range(0f, 0.2f)]
		private float _lightScatteringExposure;

		[SerializeField]
		[Range(0f, 1f)]
		private float _lightScatteringJittering = 0.5f;

		[SerializeField]
		[Range(1f, 4f)]
		private int _lightScatteringBlurDownscale = 1;

		[SerializeField]
		private bool _fogBlur;

		[SerializeField]
		[Range(0f, 1f)]
		private float _fogBlurDepth = 0.05f;

		[SerializeField]
		private bool _sunShadows;

		[SerializeField]
		private LayerMask _sunShadowsLayerMask = -1;

		[SerializeField]
		[Range(0f, 1f)]
		private float _sunShadowsStrength = 0.5f;

		[SerializeField]
		private float _sunShadowsBias = 0.1f;

		[SerializeField]
		[Range(0f, 0.5f)]
		private float _sunShadowsJitterStrength = 0.1f;

		[SerializeField]
		[Range(0f, 4f)]
		private int _sunShadowsResolution = 2;

		[SerializeField]
		[Range(50f, 2000f)]
		private float _sunShadowsMaxDistance = 200f;

		[SerializeField]
		private SUN_SHADOWS_BAKE_MODE _sunShadowsBakeMode = SUN_SHADOWS_BAKE_MODE.Discrete;

		[SerializeField]
		private float _sunShadowsRefreshInterval;

		[SerializeField]
		[Range(0f, 1f)]
		private float _sunShadowsCancellation;

		[SerializeField]
		[Range(0f, 10f)]
		private float _turbulenceStrength;

		[SerializeField]
		private bool _useXYPlane;

		[SerializeField]
		private bool _useSinglePassStereoRenderingMatrix;

		[SerializeField]
		private SPSR_BEHAVIOUR _spsrBehaviour;

		[SerializeField]
		private bool _reduceFlickerBigWorlds;

		[SerializeField]
		private bool _enableMask;

		[SerializeField]
		private LayerMask _maskLayer = 8388608;

		[SerializeField]
		[Range(1f, 4f)]
		private int _maskDownsampling = 1;

		public bool isRendering;

		[NonSerialized]
		public float distanceToCameraMin;

		[NonSerialized]
		public float distanceToCameraMax;

		[NonSerialized]
		public float distanceToCamera;

		[NonSerialized]
		public float distanceToCameraYAxis;

		[NonSerialized]
		public FOG_TEMPORARY_PROPERTIES temporaryProperties;

		public VolumetricFog fogRenderer;

		private VolumetricFog[] allFogRenderers;

		private bool isPartOfScene;

		private int noiseTextureSize;

		private float initialFogAlpha;

		private float targetFogAlpha;

		private float initialSkyHazeAlpha;

		private float targetSkyHazeAlpha;

		private bool transitionAlpha;

		private bool transitionColor;

		private bool transitionSpecularColor;

		private bool transitionLightColor;

		private bool transitionProfile;

		private bool targetColorActive;

		private bool targetSpecularColorActive;

		private bool targetLightColorActive;

		private Color initialFogColor;

		private Color targetFogColor;

		private Color initialFogSpecularColor;

		private Color targetFogSpecularColor;

		private Color initialLightColor;

		private Color targetLightColor;

		private float transitionDuration;

		private float transitionStartTime;

		private float currentFogAlpha;

		private float currentSkyHazeAlpha;

		private Color currentFogColor;

		private Color currentFogSpecularColor;

		private Color currentLightColor;

		private VolumetricFogProfile initialProfile;

		private VolumetricFogProfile targetProfile;

		private float oldBaselineRelativeCameraY;

		private float currentFogAltitude;

		private float skyHazeSpeedAcum;

		private Color skyHazeLightColor;

		private bool _hasCamera;

		private bool _hasCameraChecked;

		private Camera mainCamera;

		private List<string> shaderKeywords;

		private Material blurMat;

		private RenderBuffer[] mrt;

		private int _renderingInstancesCount;

		private bool shouldUpdateMaterialProperties;

		private int lastFrameCount;

		private RenderTextureFormat rtDownsampledFormat;

		[NonSerialized]
		public Material fogMat;

		private RenderTexture depthTexture;

		private RenderTexture depthSunTexture;

		private RenderTexture reducedDestination;

		private Light[] lastFoundLights;

		private Light[] lightBuffer;

		private Light[] currentLights;

		private float trackPointAutoLastTime;

		private float trackPointCheckNewLightsLastTime;

		private Vector4 black = new Vector4(0f, 0f, 0f, 1f);

		private Shader depthShader;

		private Shader depthShaderAndTrans;

		private GameObject depthCamObj;

		private Camera depthCam;

		private float lastTextureUpdate;

		private Vector3 windSpeedAcum;

		private Texture2D adjustedTexture;

		private Color[] noiseColors;

		private Color[] adjustedColors;

		private float sunLightIntensity = 1f;

		private bool needUpdateTexture;

		private bool hasChangeAdjustedColorsAlpha;

		private int updatingTextureSlice;

		private Color updatingTextureLightColor;

		private Color lastRenderSettingsAmbientLight;

		private float lastRenderSettingsAmbientIntensity;

		private int lastFrameAppliedChaos;

		private int lastFrameAppliedWind;

		private Light sunLight;

		private Vector2 oldSunPos;

		private float sunFade = 1f;

		private Vector3 lastLightDirection;

		private GameObject depthSunCamObj;

		private Camera depthSunCam;

		private Shader depthSunShader;

		[NonSerialized]
		public bool needUpdateDepthSunTexture;

		private float lastShadowUpdateFrame;

		private bool sunShadowsActive;

		private int currentDepthSunTextureRes;

		private Matrix4x4 lightMatrix;

		private Texture2D adjustedChaosTexture;

		private Material chaosLerpMat;

		private float turbAcum;

		private float deltaTime;

		private float timeOfLastRender;

		private RenderTexture rtAdjusted;

		private List<VolumetricFog> fogInstances = new List<VolumetricFog>();

		private List<VolumetricFog> fogRenderInstances = new List<VolumetricFog>();

		private MeshRenderer mr;

		private float lastTimeSortInstances;

		private const float FOG_INSTANCES_SORT_INTERVAL = 2f;

		private Vector3 lastCamPos;

		private bool needResort;

		private CommandBuffer maskCommandBuffer;

		private RenderTextureDescriptor rtMaskDesc;

		private Material maskMaterial;

		private const int MAX_SIMULTANEOUS_TRANSITIONS = 10000;

		[SerializeField]
		private bool _fogOfWarEnabled;

		[SerializeField]
		private Vector3 _fogOfWarCenter;

		[SerializeField]
		private Vector3 _fogOfWarSize = new Vector3(1024f, 0f, 1024f);

		[SerializeField]
		[Range(32f, 2048f)]
		private int _fogOfWarTextureSize = 256;

		[SerializeField]
		[Range(0f, 100f)]
		private float _fogOfWarRestoreDelay;

		[SerializeField]
		[Range(0f, 25f)]
		private float _fogOfWarRestoreDuration = 2f;

		[SerializeField]
		[Range(0f, 1f)]
		private float _fogOfWarSmoothness = 1f;

		[SerializeField]
		private bool _fogOfWarBlur;

		[SerializeField]
		private bool _maskEditorEnabled;

		[SerializeField]
		private MASK_TEXTURE_BRUSH_MODE _maskBrushMode = MASK_TEXTURE_BRUSH_MODE.RemoveFog;

		[SerializeField]
		[Range(1f, 128f)]
		private int _maskBrushWidth = 20;

		[SerializeField]
		[Range(0f, 1f)]
		private float _maskBrushFuzziness = 0.5f;

		[SerializeField]
		[Range(0f, 1f)]
		private float _maskBrushOpacity = 0.15f;

		private bool canDestroyFOWTexture;

		[SerializeField]
		private Texture2D _fogOfWarTexture;

		private Color32[] fogOfWarColorBuffer;

		private FogOfWarTransition[] fowTransitionList;

		private int lastTransitionPos;

		private Dictionary<int, int> fowTransitionIndices;

		private bool requiresTextureUpload;

		private Material fowBlur;

		private RenderTexture fowBlur1;

		private RenderTexture fowBlur2;

		public const int MAX_POINT_LIGHTS = 6;

		public const bool LIGHT_SCATTERING_BLUR_ENABLED = false;

		public const bool USE_UNITY_SHADOW_MAP = true;

		public const bool USE_DIRECTIONAL_LIGHT_COOKIE = false;

		public const bool LIGHT_DIFFUSION_ENABLED = true;

		public static VolumetricFog instance
		{
			get
			{
				if (_fog == null)
				{
					if (Camera.main != null)
					{
						_fog = Camera.main.GetComponent<VolumetricFog>();
					}
					if (_fog == null)
					{
						Camera[] allCameras = Camera.allCameras;
						for (int i = 0; i < allCameras.Length; i++)
						{
							_fog = allCameras[i].GetComponent<VolumetricFog>();
							if (_fog != null)
							{
								break;
							}
						}
					}
				}
				return _fog;
			}
		}

		public FOG_PRESET preset
		{
			get
			{
				return _preset;
			}
			set
			{
				if (value != _preset)
				{
					_preset = value;
					UpdatePreset();
					isDirty = true;
				}
			}
		}

		public VolumetricFogProfile profile
		{
			get
			{
				return _profile;
			}
			set
			{
				if (value != _profile)
				{
					_profile = value;
					if (_profile != null)
					{
						_profile.Load(this);
						_preset = FOG_PRESET.Custom;
					}
					isDirty = true;
				}
			}
		}

		public bool profileSync
		{
			get
			{
				return _profileSync;
			}
			set
			{
				if (value != _profileSync)
				{
					_profileSync = value;
					isDirty = true;
				}
			}
		}

		public bool useFogVolumes
		{
			get
			{
				return _useFogVolumes;
			}
			set
			{
				if (value != _useFogVolumes)
				{
					_useFogVolumes = value;
					isDirty = true;
				}
			}
		}

		public bool debugDepthPass
		{
			get
			{
				return _debugPass;
			}
			set
			{
				if (value != _debugPass)
				{
					_debugPass = value;
					isDirty = true;
				}
			}
		}

		public bool showInSceneView
		{
			get
			{
				return _showInSceneView;
			}
			set
			{
				if (value != _showInSceneView)
				{
					_showInSceneView = value;
					isDirty = true;
				}
			}
		}

		public TRANSPARENT_MODE transparencyBlendMode
		{
			get
			{
				return _transparencyBlendMode;
			}
			set
			{
				if (value != _transparencyBlendMode)
				{
					_transparencyBlendMode = value;
					UpdateRenderComponents();
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float transparencyBlendPower
		{
			get
			{
				return _transparencyBlendPower;
			}
			set
			{
				if (value != _transparencyBlendPower)
				{
					_transparencyBlendPower = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public LayerMask transparencyLayerMask
		{
			get
			{
				return _transparencyLayerMask;
			}
			set
			{
				if ((int)_transparencyLayerMask != (int)value)
				{
					_transparencyLayerMask = value;
					isDirty = true;
				}
			}
		}

		public FOG_VISIBILITY_SCOPE visibilityScope
		{
			get
			{
				return _visibilityScope;
			}
			set
			{
				if (_visibilityScope != value)
				{
					_visibilityScope = value;
					isDirty = true;
				}
			}
		}

		public Bounds visibilityVolume
		{
			get
			{
				return _visibilityVolume;
			}
			set
			{
				if (_visibilityVolume != value)
				{
					_visibilityVolume = value;
					isDirty = true;
				}
			}
		}

		public LIGHTING_MODEL lightingModel
		{
			get
			{
				return _lightingModel;
			}
			set
			{
				if (value != _lightingModel)
				{
					_lightingModel = value;
					UpdateMaterialProperties();
					UpdateTexture();
					isDirty = true;
				}
			}
		}

		public bool enableMultipleCameras
		{
			get
			{
				return _enableMultipleCameras;
			}
			set
			{
				if (value != _enableMultipleCameras)
				{
					_enableMultipleCameras = value;
					UpdateMultiCameraSetup();
					isDirty = true;
				}
			}
		}

		public bool computeDepth
		{
			get
			{
				return _computeDepth;
			}
			set
			{
				if (value != _computeDepth)
				{
					_computeDepth = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public COMPUTE_DEPTH_SCOPE computeDepthScope
		{
			get
			{
				return _computeDepthScope;
			}
			set
			{
				if (value != _computeDepthScope)
				{
					_computeDepthScope = value;
					if (_computeDepthScope == COMPUTE_DEPTH_SCOPE.TreeBillboardsAndTransparentObjects)
					{
						_transparencyBlendMode = TRANSPARENT_MODE.None;
					}
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float transparencyCutOff
		{
			get
			{
				return _transparencyCutOff;
			}
			set
			{
				if (value != _transparencyCutOff)
				{
					_transparencyCutOff = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public bool renderBeforeTransparent
		{
			get
			{
				return _renderBeforeTransparent;
			}
			set
			{
				if (value != _renderBeforeTransparent)
				{
					_renderBeforeTransparent = value;
					if (_renderBeforeTransparent)
					{
						_transparencyBlendMode = TRANSPARENT_MODE.None;
					}
					UpdateRenderComponents();
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public GameObject sun
		{
			get
			{
				return _sun;
			}
			set
			{
				if (value != _sun)
				{
					_sun = value;
					UpdateSun();
					isDirty = true;
				}
			}
		}

		public float timeBetweenTextureUpdates
		{
			get
			{
				return _timeBetweenTextureUpdates;
			}
			set
			{
				if (value != _timeBetweenTextureUpdates)
				{
					_timeBetweenTextureUpdates = value;
					isDirty = true;
				}
			}
		}

		public bool sunCopyColor
		{
			get
			{
				return _sunCopyColor;
			}
			set
			{
				if (value != _sunCopyColor)
				{
					_sunCopyColor = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float density
		{
			get
			{
				return _density;
			}
			set
			{
				if (value != _density)
				{
					_preset = FOG_PRESET.Custom;
					_density = value;
					UpdateMaterialProperties();
					UpdateTextureAlpha();
					UpdateTexture();
					isDirty = true;
				}
			}
		}

		public float noiseStrength
		{
			get
			{
				return _noiseStrength;
			}
			set
			{
				if (value != _noiseStrength)
				{
					_preset = FOG_PRESET.Custom;
					_noiseStrength = value;
					UpdateMaterialProperties();
					UpdateTextureAlpha();
					UpdateTexture();
					isDirty = true;
				}
			}
		}

		public float noiseFinalMultiplier
		{
			get
			{
				return _noiseFinalMultiplier;
			}
			set
			{
				if (value != _noiseFinalMultiplier)
				{
					_preset = FOG_PRESET.Custom;
					_noiseFinalMultiplier = value;
					UpdateMaterialProperties();
					UpdateTextureAlpha();
					UpdateTexture();
					isDirty = true;
				}
			}
		}

		public float noiseSparse
		{
			get
			{
				return _noiseSparse;
			}
			set
			{
				if (value != _noiseSparse)
				{
					_preset = FOG_PRESET.Custom;
					_noiseSparse = value;
					UpdateMaterialProperties();
					UpdateTextureAlpha();
					UpdateTexture();
					isDirty = true;
				}
			}
		}

		public float distance
		{
			get
			{
				return _distance;
			}
			set
			{
				if (value != _distance)
				{
					_preset = FOG_PRESET.Custom;
					_distance = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float maxFogLength
		{
			get
			{
				return _maxFogLength;
			}
			set
			{
				if (value != _maxFogLength)
				{
					_maxFogLength = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float maxFogLengthFallOff
		{
			get
			{
				return _maxFogLengthFallOff;
			}
			set
			{
				if (value != _maxFogLengthFallOff)
				{
					_maxFogLengthFallOff = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float distanceFallOff
		{
			get
			{
				return _distanceFallOff;
			}
			set
			{
				if (value != _distanceFallOff)
				{
					_preset = FOG_PRESET.Custom;
					_distanceFallOff = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float height
		{
			get
			{
				return _height;
			}
			set
			{
				if (value != _height)
				{
					_preset = FOG_PRESET.Custom;
					_height = Mathf.Max(value, 0.0001f);
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float heightFallOff
		{
			get
			{
				return _heightFallOff;
			}
			set
			{
				if (value != _heightFallOff)
				{
					_preset = FOG_PRESET.Custom;
					_heightFallOff = Mathf.Clamp01(value);
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float deepObscurance
		{
			get
			{
				return _deepObscurance;
			}
			set
			{
				if (value != _deepObscurance && value >= 0f)
				{
					_preset = FOG_PRESET.Custom;
					_deepObscurance = Mathf.Clamp01(value);
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float baselineHeight
		{
			get
			{
				return _baselineHeight;
			}
			set
			{
				if (value != _baselineHeight)
				{
					_preset = FOG_PRESET.Custom;
					_baselineHeight = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public bool baselineRelativeToCamera
		{
			get
			{
				return _baselineRelativeToCamera;
			}
			set
			{
				if (value != _baselineRelativeToCamera)
				{
					_preset = FOG_PRESET.Custom;
					_baselineRelativeToCamera = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float baselineRelativeToCameraDelay
		{
			get
			{
				return _baselineRelativeToCameraDelay;
			}
			set
			{
				if (value != _baselineRelativeToCameraDelay)
				{
					_baselineRelativeToCameraDelay = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float noiseScale
		{
			get
			{
				return _noiseScale;
			}
			set
			{
				if (value != _noiseScale && value >= 0.2f)
				{
					_preset = FOG_PRESET.Custom;
					_noiseScale = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float alpha
		{
			get
			{
				return _alpha;
			}
			set
			{
				if (value != _alpha)
				{
					_preset = FOG_PRESET.Custom;
					_alpha = value;
					currentFogAlpha = _alpha;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public Color color
		{
			get
			{
				return _color;
			}
			set
			{
				if (value != _color)
				{
					_preset = FOG_PRESET.Custom;
					_color = value;
					currentFogColor = _color;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public Color specularColor
		{
			get
			{
				return _specularColor;
			}
			set
			{
				if (value != _specularColor)
				{
					_preset = FOG_PRESET.Custom;
					_specularColor = value;
					currentFogSpecularColor = _specularColor;
					UpdateTexture();
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float specularThreshold
		{
			get
			{
				return _specularThreshold;
			}
			set
			{
				if (value != _specularThreshold)
				{
					_preset = FOG_PRESET.Custom;
					_specularThreshold = value;
					UpdateTexture();
					isDirty = true;
				}
			}
		}

		public float specularIntensity
		{
			get
			{
				return _specularIntensity;
			}
			set
			{
				if (value != _specularIntensity)
				{
					_preset = FOG_PRESET.Custom;
					_specularIntensity = value;
					UpdateMaterialProperties();
					UpdateTexture();
					isDirty = true;
				}
			}
		}

		public Vector3 lightDirection
		{
			get
			{
				return _lightDirection;
			}
			set
			{
				if (value != _lightDirection)
				{
					_preset = FOG_PRESET.Custom;
					_lightDirection = value;
					UpdateMaterialProperties();
					UpdateTexture();
					isDirty = true;
				}
			}
		}

		public float lightIntensity
		{
			get
			{
				return _lightIntensity;
			}
			set
			{
				if (value != _lightIntensity)
				{
					_preset = FOG_PRESET.Custom;
					_lightIntensity = value;
					UpdateMaterialProperties();
					UpdateTexture();
					isDirty = true;
				}
			}
		}

		public Color lightColor
		{
			get
			{
				return _lightColor;
			}
			set
			{
				if (value != _lightColor)
				{
					_preset = FOG_PRESET.Custom;
					_lightColor = value;
					currentLightColor = _lightColor;
					UpdateMaterialProperties();
					UpdateTexture();
					isDirty = true;
				}
			}
		}

		public int updateTextureSpread
		{
			get
			{
				return _updateTextureSpread;
			}
			set
			{
				if (value != _updateTextureSpread)
				{
					_updateTextureSpread = value;
					isDirty = true;
				}
			}
		}

		public float speed
		{
			get
			{
				return _speed;
			}
			set
			{
				if (value != _speed)
				{
					_preset = FOG_PRESET.Custom;
					_speed = value;
					if (!Application.isPlaying)
					{
						UpdateWindSpeedQuick();
					}
					isDirty = true;
				}
			}
		}

		public Vector3 windDirection
		{
			get
			{
				return _windDirection;
			}
			set
			{
				if (value != _windDirection)
				{
					_preset = FOG_PRESET.Custom;
					_windDirection = value.normalized;
					if (!Application.isPlaying)
					{
						UpdateWindSpeedQuick();
					}
					isDirty = true;
				}
			}
		}

		public bool useRealTime
		{
			get
			{
				return _useRealTime;
			}
			set
			{
				if (value != _useRealTime)
				{
					_useRealTime = value;
					isDirty = true;
				}
			}
		}

		public Color skyColor
		{
			get
			{
				return _skyColor;
			}
			set
			{
				if (value != _skyColor)
				{
					_preset = FOG_PRESET.Custom;
					_skyColor = value;
					ComputeLightColor();
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float skyHaze
		{
			get
			{
				return _skyHaze;
			}
			set
			{
				if (value != _skyHaze)
				{
					_preset = FOG_PRESET.Custom;
					_skyHaze = value;
					if (!Application.isPlaying)
					{
						UpdateWindSpeedQuick();
					}
					isDirty = true;
				}
			}
		}

		public float skyNoiseScale
		{
			get
			{
				return _skyNoiseScale;
			}
			set
			{
				if (value != _skyNoiseScale)
				{
					_skyNoiseScale = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float skySpeed
		{
			get
			{
				return _skySpeed;
			}
			set
			{
				if (value != _skySpeed)
				{
					_preset = FOG_PRESET.Custom;
					_skySpeed = value;
					isDirty = true;
				}
			}
		}

		public float skyNoiseStrength
		{
			get
			{
				return _skyNoiseStrength;
			}
			set
			{
				if (value != _skyNoiseStrength)
				{
					_preset = FOG_PRESET.Custom;
					_skyNoiseStrength = value;
					if (!Application.isPlaying)
					{
						UpdateWindSpeedQuick();
					}
					isDirty = true;
				}
			}
		}

		public float skyAlpha
		{
			get
			{
				return _skyAlpha;
			}
			set
			{
				if (value != _skyAlpha)
				{
					_preset = FOG_PRESET.Custom;
					_skyAlpha = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float skyDepth
		{
			get
			{
				return _skyDepth;
			}
			set
			{
				if (value != _skyDepth)
				{
					_skyDepth = value;
					if (!Application.isPlaying)
					{
						UpdateWindSpeedQuick();
					}
					isDirty = true;
				}
			}
		}

		public GameObject character
		{
			get
			{
				return _character;
			}
			set
			{
				if (value != _character)
				{
					_character = value;
					isDirty = true;
				}
			}
		}

		public FOG_VOID_TOPOLOGY fogVoidTopology
		{
			get
			{
				return _fogVoidTopology;
			}
			set
			{
				if (value != _fogVoidTopology)
				{
					_fogVoidTopology = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float fogVoidFallOff
		{
			get
			{
				return _fogVoidFallOff;
			}
			set
			{
				if (value != _fogVoidFallOff)
				{
					_preset = FOG_PRESET.Custom;
					_fogVoidFallOff = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float fogVoidRadius
		{
			get
			{
				return _fogVoidRadius;
			}
			set
			{
				if (value != _fogVoidRadius)
				{
					_preset = FOG_PRESET.Custom;
					_fogVoidRadius = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public Vector3 fogVoidPosition
		{
			get
			{
				return _fogVoidPosition;
			}
			set
			{
				if (value != _fogVoidPosition)
				{
					_preset = FOG_PRESET.Custom;
					_fogVoidPosition = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float fogVoidDepth
		{
			get
			{
				return _fogVoidDepth;
			}
			set
			{
				if (value != _fogVoidDepth)
				{
					_preset = FOG_PRESET.Custom;
					_fogVoidDepth = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float fogVoidHeight
		{
			get
			{
				return _fogVoidHeight;
			}
			set
			{
				if (value != _fogVoidHeight)
				{
					_preset = FOG_PRESET.Custom;
					_fogVoidHeight = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		[Obsolete("Fog Void inverted is now deprecated. Use Fog Area settings.")]
		public bool fogVoidInverted
		{
			get
			{
				return _fogVoidInverted;
			}
			set
			{
				_fogVoidInverted = value;
			}
		}

		public bool fogVoidShowGizmos
		{
			get
			{
				return _fogVoidShowGizmos;
			}
			set
			{
				_fogVoidShowGizmos = value;
			}
		}

		public bool fogAreaShowGizmos
		{
			get
			{
				return _fogAreaShowGizmos;
			}
			set
			{
				if (value != _fogAreaShowGizmos)
				{
					_fogAreaShowGizmos = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public GameObject fogAreaCenter
		{
			get
			{
				return _fogAreaCenter;
			}
			set
			{
				if (value != _fogAreaCenter)
				{
					_fogAreaCenter = value;
					isDirty = true;
				}
			}
		}

		public float fogAreaFallOff
		{
			get
			{
				return _fogAreaFallOff;
			}
			set
			{
				if (value != _fogAreaFallOff)
				{
					_fogAreaFallOff = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public FOG_AREA_FOLLOW_MODE fogAreaFollowMode
		{
			get
			{
				return _fogAreaFollowMode;
			}
			set
			{
				if (value != _fogAreaFollowMode)
				{
					_fogAreaFollowMode = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public FOG_AREA_TOPOLOGY fogAreaTopology
		{
			get
			{
				return _fogAreaTopology;
			}
			set
			{
				if (value != _fogAreaTopology)
				{
					_fogAreaTopology = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float fogAreaRadius
		{
			get
			{
				return _fogAreaRadius;
			}
			set
			{
				if (value != _fogAreaRadius)
				{
					_fogAreaRadius = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public Vector3 fogAreaPosition
		{
			get
			{
				return _fogAreaPosition;
			}
			set
			{
				if (value != _fogAreaPosition)
				{
					_fogAreaPosition = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float fogAreaDepth
		{
			get
			{
				return _fogAreaDepth;
			}
			set
			{
				if (value != _fogAreaDepth)
				{
					_fogAreaDepth = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float fogAreaHeight
		{
			get
			{
				return _fogAreaHeight;
			}
			set
			{
				if (value != _fogAreaHeight)
				{
					_fogAreaHeight = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public FOG_AREA_SORTING_MODE fogAreaSortingMode
		{
			get
			{
				return _fogAreaSortingMode;
			}
			set
			{
				if (value != _fogAreaSortingMode)
				{
					_fogAreaSortingMode = value;
					lastTimeSortInstances = 0f;
					isDirty = true;
				}
			}
		}

		public int fogAreaRenderOrder
		{
			get
			{
				return _fogAreaRenderOrder;
			}
			set
			{
				if (value != _fogAreaRenderOrder)
				{
					_fogAreaRenderOrder = value;
					lastTimeSortInstances = 0f;
					isDirty = true;
				}
			}
		}

		public bool pointLightTrackAuto
		{
			get
			{
				return _pointLightTrackingAuto;
			}
			set
			{
				if (value != _pointLightTrackingAuto)
				{
					_pointLightTrackingAuto = value;
					TrackPointLights();
					isDirty = true;
				}
			}
		}

		public Transform pointLightTrackingPivot
		{
			get
			{
				return _pointLightTrackingPivot;
			}
			set
			{
				if (value != _pointLightTrackingPivot)
				{
					_pointLightTrackingPivot = value;
					TrackPointLights();
					isDirty = true;
				}
			}
		}

		public int pointLightTrackingCount
		{
			get
			{
				return _pointLightTrackingCount;
			}
			set
			{
				if (value != _pointLightTrackingCount)
				{
					_pointLightTrackingCount = Mathf.Clamp(value, 0, 6);
					CheckPointLightData();
					TrackPointLights();
					isDirty = true;
				}
			}
		}

		public float pointLightTrackingCheckInterval
		{
			get
			{
				return _pointLightTrackingCheckInterval;
			}
			set
			{
				if (value != _pointLightTrackingCheckInterval)
				{
					_pointLightTrackingCheckInterval = value;
					TrackPointLights();
					isDirty = true;
				}
			}
		}

		public float pointLightTrackingNewLightsCheckInterval
		{
			get
			{
				return _pointLightTrackingNewLightsCheckInterval;
			}
			set
			{
				if (value != _pointLightTrackingNewLightsCheckInterval)
				{
					_pointLightTrackingNewLightsCheckInterval = value;
					TrackPointLights();
					isDirty = true;
				}
			}
		}

		public float pointLightInscattering
		{
			get
			{
				return _pointLightInscattering;
			}
			set
			{
				if (value != _pointLightInscattering)
				{
					_pointLightInscattering = value;
					isDirty = true;
				}
			}
		}

		public float pointLightIntensity
		{
			get
			{
				return _pointLightIntensity;
			}
			set
			{
				if (value != _pointLightIntensity)
				{
					_pointLightIntensity = value;
					isDirty = true;
				}
			}
		}

		public float pointLightInsideAtten
		{
			get
			{
				return _pointLightInsideAtten;
			}
			set
			{
				if (value != _pointLightInsideAtten)
				{
					_pointLightInsideAtten = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public int downsampling
		{
			get
			{
				return _downsampling;
			}
			set
			{
				if (value != _downsampling)
				{
					_preset = FOG_PRESET.Custom;
					_downsampling = value;
					isDirty = true;
				}
			}
		}

		public bool forceComposition
		{
			get
			{
				return _forceComposition;
			}
			set
			{
				if (value != _forceComposition)
				{
					_preset = FOG_PRESET.Custom;
					_forceComposition = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public bool edgeImprove
		{
			get
			{
				return _edgeImprove;
			}
			set
			{
				if (value != _edgeImprove)
				{
					_preset = FOG_PRESET.Custom;
					_edgeImprove = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float edgeThreshold
		{
			get
			{
				return _edgeThreshold;
			}
			set
			{
				if (value != _edgeThreshold)
				{
					_preset = FOG_PRESET.Custom;
					_edgeThreshold = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float stepping
		{
			get
			{
				return _stepping;
			}
			set
			{
				if (value != _stepping)
				{
					_preset = FOG_PRESET.Custom;
					_stepping = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float steppingNear
		{
			get
			{
				return _steppingNear;
			}
			set
			{
				if (value != _steppingNear)
				{
					_preset = FOG_PRESET.Custom;
					_steppingNear = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public bool dithering
		{
			get
			{
				return _dithering;
			}
			set
			{
				if (value != _dithering)
				{
					_dithering = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float ditherStrength
		{
			get
			{
				return _ditherStrength;
			}
			set
			{
				if (value != _ditherStrength)
				{
					_ditherStrength = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float jitterStrength
		{
			get
			{
				return _jitterStrength;
			}
			set
			{
				if (value != _jitterStrength)
				{
					_jitterStrength = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public bool lightScatteringEnabled
		{
			get
			{
				return _lightScatteringEnabled;
			}
			set
			{
				if (value != _lightScatteringEnabled)
				{
					_lightScatteringEnabled = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float lightScatteringDiffusion
		{
			get
			{
				return _lightScatteringDiffusion;
			}
			set
			{
				if (value != _lightScatteringDiffusion)
				{
					_lightScatteringDiffusion = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float lightScatteringSpread
		{
			get
			{
				return _lightScatteringSpread;
			}
			set
			{
				if (value != _lightScatteringSpread)
				{
					_lightScatteringSpread = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public int lightScatteringSamples
		{
			get
			{
				return _lightScatteringSamples;
			}
			set
			{
				if (value != _lightScatteringSamples)
				{
					_lightScatteringSamples = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float lightScatteringWeight
		{
			get
			{
				return _lightScatteringWeight;
			}
			set
			{
				if (value != _lightScatteringWeight)
				{
					_lightScatteringWeight = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float lightScatteringIllumination
		{
			get
			{
				return _lightScatteringIllumination;
			}
			set
			{
				if (value != _lightScatteringIllumination)
				{
					_lightScatteringIllumination = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float lightScatteringDecay
		{
			get
			{
				return _lightScatteringDecay;
			}
			set
			{
				if (value != _lightScatteringDecay)
				{
					_lightScatteringDecay = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float lightScatteringExposure
		{
			get
			{
				return _lightScatteringExposure;
			}
			set
			{
				if (value != _lightScatteringExposure)
				{
					_lightScatteringExposure = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float lightScatteringJittering
		{
			get
			{
				return _lightScatteringJittering;
			}
			set
			{
				if (value != _lightScatteringJittering)
				{
					_lightScatteringJittering = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public int lightScatteringBlurDownscale
		{
			get
			{
				return _lightScatteringBlurDownscale;
			}
			set
			{
				if (value != _lightScatteringBlurDownscale)
				{
					_lightScatteringBlurDownscale = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public bool fogBlur
		{
			get
			{
				return _fogBlur;
			}
			set
			{
				if (value != _fogBlur)
				{
					_fogBlur = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float fogBlurDepth
		{
			get
			{
				return _fogBlurDepth;
			}
			set
			{
				if (value != _fogBlurDepth)
				{
					_fogBlurDepth = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public bool sunShadows
		{
			get
			{
				return _sunShadows;
			}
			set
			{
				if (value != _sunShadows)
				{
					_sunShadows = value;
					CleanUpTextureDepthSun();
					if (_sunShadows)
					{
						needUpdateDepthSunTexture = true;
					}
					else
					{
						DestroySunShadowsDependencies();
					}
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public LayerMask sunShadowsLayerMask
		{
			get
			{
				return _sunShadowsLayerMask;
			}
			set
			{
				if ((int)_sunShadowsLayerMask != (int)value)
				{
					_sunShadowsLayerMask = value;
					isDirty = true;
				}
			}
		}

		public float sunShadowsStrength
		{
			get
			{
				return _sunShadowsStrength;
			}
			set
			{
				if (value != _sunShadowsStrength)
				{
					_sunShadowsStrength = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float sunShadowsBias
		{
			get
			{
				return _sunShadowsBias;
			}
			set
			{
				if (value != _sunShadowsBias)
				{
					_sunShadowsBias = value;
					needUpdateDepthSunTexture = true;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float sunShadowsJitterStrength
		{
			get
			{
				return _sunShadowsJitterStrength;
			}
			set
			{
				if (value != _sunShadowsJitterStrength)
				{
					_sunShadowsJitterStrength = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public int sunShadowsResolution
		{
			get
			{
				return _sunShadowsResolution;
			}
			set
			{
				if (value != _sunShadowsResolution)
				{
					_sunShadowsResolution = value;
					needUpdateDepthSunTexture = true;
					CleanUpTextureDepthSun();
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float sunShadowsMaxDistance
		{
			get
			{
				return _sunShadowsMaxDistance;
			}
			set
			{
				if (value != _sunShadowsMaxDistance)
				{
					_sunShadowsMaxDistance = value;
					needUpdateDepthSunTexture = true;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public SUN_SHADOWS_BAKE_MODE sunShadowsBakeMode
		{
			get
			{
				return _sunShadowsBakeMode;
			}
			set
			{
				if (value != _sunShadowsBakeMode)
				{
					_sunShadowsBakeMode = value;
					needUpdateDepthSunTexture = true;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float sunShadowsRefreshInterval
		{
			get
			{
				return _sunShadowsRefreshInterval;
			}
			set
			{
				if (value != _sunShadowsRefreshInterval)
				{
					_sunShadowsRefreshInterval = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float sunShadowsCancellation
		{
			get
			{
				return _sunShadowsCancellation;
			}
			set
			{
				if (value != _sunShadowsCancellation)
				{
					_sunShadowsCancellation = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float turbulenceStrength
		{
			get
			{
				return _turbulenceStrength;
			}
			set
			{
				if (value != _turbulenceStrength)
				{
					_turbulenceStrength = value;
					if (_turbulenceStrength <= 0f)
					{
						UpdateTexture();
					}
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public bool useXYPlane
		{
			get
			{
				return _useXYPlane;
			}
			set
			{
				if (value != _useXYPlane)
				{
					_useXYPlane = value;
					if (_sunShadows)
					{
						needUpdateDepthSunTexture = true;
					}
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public bool useSinglePassStereoRenderingMatrix
		{
			get
			{
				return _useSinglePassStereoRenderingMatrix;
			}
			set
			{
				if (value != _useSinglePassStereoRenderingMatrix)
				{
					_useSinglePassStereoRenderingMatrix = value;
					isDirty = true;
				}
			}
		}

		public SPSR_BEHAVIOUR spsrBehaviour
		{
			get
			{
				return _spsrBehaviour;
			}
			set
			{
				if (value != _spsrBehaviour)
				{
					_spsrBehaviour = value;
					isDirty = true;
				}
			}
		}

		public bool reduceFlickerBigWorlds
		{
			get
			{
				return _reduceFlickerBigWorlds;
			}
			set
			{
				if (value != _reduceFlickerBigWorlds)
				{
					_reduceFlickerBigWorlds = value;
					isDirty = true;
				}
			}
		}

		public bool enableMask
		{
			get
			{
				return _enableMask;
			}
			set
			{
				if (value != _enableMask)
				{
					_enableMask = value;
					UpdateVolumeMask();
					isDirty = true;
				}
			}
		}

		public LayerMask maskLayer
		{
			get
			{
				return _maskLayer;
			}
			set
			{
				if ((int)value != (int)_maskLayer)
				{
					_maskLayer = value;
					UpdateVolumeMask();
					isDirty = true;
				}
			}
		}

		public int maskDownsampling
		{
			get
			{
				return _maskDownsampling;
			}
			set
			{
				if (value != _maskDownsampling)
				{
					_maskDownsampling = value;
					UpdateVolumeMask();
					isDirty = true;
				}
			}
		}

		public Camera fogCamera => mainCamera;

		public int renderingInstancesCount => _renderingInstancesCount;

		public List<VolumetricFog> renderingInstances => fogRenderInstances;

		public List<VolumetricFog> instances => fogInstances;

		public bool hasCamera
		{
			get
			{
				if (!_hasCameraChecked)
				{
					_hasCamera = GetComponent<Camera>() != null;
					_hasCameraChecked = true;
				}
				return _hasCamera;
			}
		}

		public bool fogOfWarEnabled
		{
			get
			{
				return _fogOfWarEnabled;
			}
			set
			{
				if (value != _fogOfWarEnabled)
				{
					_fogOfWarEnabled = value;
					FogOfWarInit();
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public Vector3 fogOfWarCenter
		{
			get
			{
				return _fogOfWarCenter;
			}
			set
			{
				if (value != _fogOfWarCenter)
				{
					_fogOfWarCenter = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public Vector3 fogOfWarSize
		{
			get
			{
				return _fogOfWarSize;
			}
			set
			{
				if (value != _fogOfWarSize && value.x > 0f && value.z > 0f)
				{
					_fogOfWarSize = value;
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public int fogOfWarTextureSize
		{
			get
			{
				return _fogOfWarTextureSize;
			}
			set
			{
				if (value != _fogOfWarTextureSize && value > 16)
				{
					_fogOfWarTextureSize = value;
					FogOfWarUpdateTexture();
					UpdateMaterialProperties();
					isDirty = true;
				}
			}
		}

		public float fogOfWarRestoreDelay
		{
			get
			{
				return _fogOfWarRestoreDelay;
			}
			set
			{
				if (value != _fogOfWarRestoreDelay)
				{
					_fogOfWarRestoreDelay = value;
					isDirty = true;
				}
			}
		}

		public float fogOfWarRestoreDuration
		{
			get
			{
				return _fogOfWarRestoreDuration;
			}
			set
			{
				if (value != _fogOfWarRestoreDuration)
				{
					_fogOfWarRestoreDuration = value;
					isDirty = true;
				}
			}
		}

		public float fogOfWarSmoothness
		{
			get
			{
				return _fogOfWarSmoothness;
			}
			set
			{
				if (value != _fogOfWarSmoothness)
				{
					_fogOfWarSmoothness = value;
					isDirty = true;
				}
			}
		}

		public bool fogOfWarBlur
		{
			get
			{
				return _fogOfWarBlur;
			}
			set
			{
				if (value != _fogOfWarBlur)
				{
					_fogOfWarBlur = value;
					isDirty = true;
				}
			}
		}

		public bool maskEditorEnabled
		{
			get
			{
				return _maskEditorEnabled;
			}
			set
			{
				if (value != _maskEditorEnabled)
				{
					_maskEditorEnabled = value;
				}
			}
		}

		public MASK_TEXTURE_BRUSH_MODE maskBrushMode
		{
			get
			{
				return _maskBrushMode;
			}
			set
			{
				if (value != _maskBrushMode)
				{
					_maskBrushMode = value;
				}
			}
		}

		public int maskBrushWidth
		{
			get
			{
				return _maskBrushWidth;
			}
			set
			{
				if (value != _maskBrushWidth)
				{
					_maskBrushWidth = value;
				}
			}
		}

		public float maskBrushFuzziness
		{
			get
			{
				return _maskBrushFuzziness;
			}
			set
			{
				if (value != _maskBrushFuzziness)
				{
					_maskBrushFuzziness = value;
				}
			}
		}

		public float maskBrushOpacity
		{
			get
			{
				return _maskBrushOpacity;
			}
			set
			{
				if (value != _maskBrushOpacity)
				{
					_maskBrushOpacity = value;
				}
			}
		}

		public Texture2D fogOfWarTexture
		{
			get
			{
				return _fogOfWarTexture;
			}
			set
			{
				if (_fogOfWarTexture != value && value != null)
				{
					if (value.width != value.height)
					{
						UnityEngine.Debug.LogError("Fog of war texture must be square.");
						return;
					}
					_fogOfWarTexture = value;
					canDestroyFOWTexture = false;
					ReloadFogOfWarTexture();
				}
			}
		}

		public Color32[] fogOfWarTextureData
		{
			get
			{
				return fogOfWarColorBuffer;
			}
			set
			{
				fogOfWarEnabled = true;
				fogOfWarColorBuffer = value;
				if (value != null && !(_fogOfWarTexture == null) && value.Length == _fogOfWarTexture.width * _fogOfWarTexture.height)
				{
					_fogOfWarTexture.SetPixels32(fogOfWarColorBuffer);
					_fogOfWarTexture.Apply();
				}
			}
		}

		private void OnEnable()
		{
			isPartOfScene = isPartOfScene || IsPartOfScene();
			if (!isPartOfScene)
			{
				return;
			}
			temporaryProperties.color = Color.white;
			temporaryProperties.density = 1f;
			if (_fogVoidInverted)
			{
				_fogVoidInverted = false;
				_fogAreaCenter = _character;
				_fogAreaDepth = _fogVoidDepth;
				_fogAreaFallOff = _fogVoidFallOff;
				_fogAreaHeight = _fogVoidHeight;
				_fogAreaPosition = _fogVoidPosition;
				_fogAreaRadius = _fogVoidRadius;
				_fogVoidRadius = 0f;
				_character = null;
			}
			if (mrt == null || mrt.Length != 2)
			{
				mrt = new RenderBuffer[2];
			}
			rtDownsampledFormat = (SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.RFloat) ? RenderTextureFormat.RFloat : RenderTextureFormat.ARGBFloat);
			mainCamera = base.gameObject.GetComponent<Camera>();
			_hasCamera = mainCamera != null;
			_hasCameraChecked = true;
			if (_hasCamera)
			{
				fogRenderer = this;
				if (mainCamera.depthTextureMode == DepthTextureMode.None)
				{
					mainCamera.depthTextureMode = DepthTextureMode.Depth;
				}
				UpdateVolumeMask();
			}
			else if (fogRenderer == null)
			{
				FindMainCamera();
				if (mainCamera == null)
				{
					UnityEngine.Debug.LogError("Volumetric Fog: no camera found!");
					return;
				}
				fogRenderer = mainCamera.GetComponent<VolumetricFog>();
				if (fogRenderer == null)
				{
					fogRenderer = mainCamera.gameObject.AddComponent<VolumetricFog>();
					fogRenderer.density = 0f;
				}
			}
			else
			{
				mainCamera = fogRenderer.mainCamera;
				if (mainCamera == null)
				{
					mainCamera = fogRenderer.GetComponent<Camera>();
				}
			}
			if (fogMat == null)
			{
				InitFogMaterial();
				if (_profile != null && _profileSync)
				{
					_profile.Load(this);
				}
			}
			else
			{
				UpdateMaterialPropertiesNow();
			}
			RegisterWithRenderers();
			needResort = true;
		}

		private void OnDisable()
		{
			RemoveMaskCommandBuffer();
			RemoveDirectionalLightCommandBuffer();
		}

		private void OnDestroy()
		{
			if (!_hasCamera)
			{
				UnregisterWithRenderers();
			}
			else
			{
				RemoveMaskCommandBuffer();
				UnregisterFogArea(this);
			}
			if (depthCamObj != null)
			{
				UnityEngine.Object.DestroyImmediate(depthCamObj);
				depthCamObj = null;
			}
			if (adjustedTexture != null)
			{
				UnityEngine.Object.DestroyImmediate(adjustedTexture);
				adjustedTexture = null;
			}
			if (chaosLerpMat != null)
			{
				UnityEngine.Object.DestroyImmediate(chaosLerpMat);
				chaosLerpMat = null;
			}
			if (adjustedChaosTexture != null)
			{
				UnityEngine.Object.DestroyImmediate(adjustedChaosTexture);
				adjustedChaosTexture = null;
			}
			if (blurMat != null)
			{
				UnityEngine.Object.DestroyImmediate(blurMat);
				blurMat = null;
			}
			if (fogMat != null)
			{
				UnityEngine.Object.DestroyImmediate(fogMat);
				fogMat = null;
			}
			FogOfWarDestroy();
			CleanUpDepthTexture();
			DestroySunShadowsDependencies();
		}

		public void DestroySelf()
		{
			DestroyRenderComponent<VolumetricFogPreT>();
			DestroyRenderComponent<VolumetricFogPosT>();
			UnityEngine.Object.DestroyImmediate(this);
		}

		private void Start()
		{
			currentFogAlpha = _alpha;
			currentSkyHazeAlpha = _skyAlpha;
			lastTextureUpdate = Time.time + _timeBetweenTextureUpdates;
			RegisterWithRenderers();
			Update();
		}

		private void Update()
		{
			if (!isPartOfScene || fogRenderer == null)
			{
				return;
			}
			float time = Time.time;
			if (fogRenderer.sun != null)
			{
				_lightDirection = fogRenderer.sun.transform.forward;
				if (!Application.isPlaying || (updatingTextureSlice < 0 && time - lastTextureUpdate >= _timeBetweenTextureUpdates))
				{
					if (lastLightDirection != _lightDirection)
					{
						lastLightDirection = _lightDirection;
						needUpdateTexture = true;
						needUpdateDepthSunTexture = true;
					}
					if (sunLight != null)
					{
						if (_sunCopyColor && sunLight.color != _lightColor)
						{
							_lightColor = sunLight.color;
							currentLightColor = _lightColor;
							needUpdateTexture = true;
						}
						if (sunLightIntensity != sunLight.intensity)
						{
							sunLightIntensity = sunLight.intensity;
							needUpdateTexture = true;
						}
					}
				}
			}
			if (!needUpdateTexture)
			{
				if (_lightingModel == LIGHTING_MODEL.Classic)
				{
					if (lastRenderSettingsAmbientIntensity != RenderSettings.ambientIntensity)
					{
						needUpdateTexture = true;
					}
					else if (lastRenderSettingsAmbientLight != RenderSettings.ambientLight)
					{
						needUpdateTexture = true;
					}
				}
				else if (_lightingModel == LIGHTING_MODEL.Natural && lastRenderSettingsAmbientLight != RenderSettings.ambientLight)
				{
					needUpdateTexture = true;
				}
			}
			if (transitionProfile)
			{
				float num = (time - transitionStartTime) / transitionDuration;
				if (num > 1f)
				{
					num = 1f;
				}
				VolumetricFogProfile.Lerp(initialProfile, targetProfile, num, this);
				if (num >= 1f)
				{
					transitionProfile = false;
				}
			}
			if (transitionAlpha)
			{
				if (targetFogAlpha >= 0f || targetSkyHazeAlpha >= 0f)
				{
					if (targetFogAlpha != currentFogAlpha || targetSkyHazeAlpha != currentSkyHazeAlpha)
					{
						if (transitionDuration > 0f)
						{
							currentFogAlpha = Mathf.Lerp(initialFogAlpha, targetFogAlpha, (time - transitionStartTime) / transitionDuration);
							currentSkyHazeAlpha = Mathf.Lerp(initialSkyHazeAlpha, targetSkyHazeAlpha, (time - transitionStartTime) / transitionDuration);
						}
						else
						{
							currentFogAlpha = targetFogAlpha;
							currentSkyHazeAlpha = targetSkyHazeAlpha;
							transitionAlpha = false;
						}
						fogMat.SetFloat(ShaderParams.FogAlpha, currentFogAlpha);
						UpdateSkyColor(currentSkyHazeAlpha);
					}
				}
				else if (currentFogAlpha != _alpha || currentSkyHazeAlpha != _skyAlpha)
				{
					if (transitionDuration > 0f)
					{
						currentFogAlpha = Mathf.Lerp(initialFogAlpha, _alpha, (time - transitionStartTime) / transitionDuration);
						currentSkyHazeAlpha = Mathf.Lerp(initialSkyHazeAlpha, alpha, (time - transitionStartTime) / transitionDuration);
					}
					else
					{
						currentFogAlpha = _alpha;
						currentSkyHazeAlpha = _skyAlpha;
						transitionAlpha = false;
					}
					fogMat.SetFloat(ShaderParams.FogAlpha, currentFogAlpha);
					UpdateSkyColor(currentSkyHazeAlpha);
				}
			}
			if (transitionColor)
			{
				if (targetColorActive)
				{
					if (targetFogColor != currentFogColor)
					{
						if (transitionDuration > 0f)
						{
							currentFogColor = Color.Lerp(initialFogColor, targetFogColor, (time - transitionStartTime) / transitionDuration);
						}
						else
						{
							currentFogColor = targetFogColor;
							transitionColor = false;
						}
					}
				}
				else if (currentFogColor != _color)
				{
					if (transitionDuration > 0f)
					{
						currentFogColor = Color.Lerp(initialFogColor, _color, (time - transitionStartTime) / transitionDuration);
					}
					else
					{
						currentFogColor = _color;
						transitionColor = false;
					}
				}
				UpdateMaterialFogColor();
			}
			if (transitionSpecularColor)
			{
				if (targetSpecularColorActive)
				{
					if (targetFogSpecularColor != currentFogSpecularColor)
					{
						if (transitionDuration > 0f)
						{
							currentFogSpecularColor = Color.Lerp(initialFogSpecularColor, targetFogSpecularColor, (time - transitionStartTime) / transitionDuration);
						}
						else
						{
							currentFogSpecularColor = targetFogSpecularColor;
							transitionSpecularColor = false;
						}
						needUpdateTexture = true;
					}
				}
				else if (currentFogSpecularColor != _specularColor)
				{
					if (transitionDuration > 0f)
					{
						currentFogSpecularColor = Color.Lerp(initialFogSpecularColor, _specularColor, (time - transitionStartTime) / transitionDuration);
					}
					else
					{
						currentFogSpecularColor = _specularColor;
						transitionSpecularColor = false;
					}
					needUpdateTexture = true;
				}
			}
			if (transitionLightColor)
			{
				if (targetLightColorActive)
				{
					if (targetLightColor != currentLightColor)
					{
						if (transitionDuration > 0f)
						{
							currentLightColor = Color.Lerp(initialLightColor, targetLightColor, (time - transitionStartTime) / transitionDuration);
						}
						else
						{
							currentLightColor = targetLightColor;
							transitionLightColor = false;
						}
						needUpdateTexture = true;
					}
				}
				else if (currentLightColor != _lightColor)
				{
					if (transitionDuration > 0f)
					{
						currentLightColor = Color.Lerp(initialLightColor, _lightColor, (time - transitionStartTime) / transitionDuration);
					}
					else
					{
						currentLightColor = _lightColor;
						transitionLightColor = false;
					}
					needUpdateTexture = true;
				}
			}
			if (_baselineRelativeToCamera)
			{
				UpdateMaterialHeights(mainCamera);
			}
			else if (_character != null)
			{
				_fogVoidPosition = _character.transform.position;
				UpdateMaterialHeights(mainCamera);
			}
			if (_fogAreaCenter != null)
			{
				if (_fogAreaFollowMode == FOG_AREA_FOLLOW_MODE.FullXYZ)
				{
					_fogAreaPosition = _fogAreaCenter.transform.position;
				}
				else
				{
					_fogAreaPosition.x = _fogAreaCenter.transform.position.x;
					_fogAreaPosition.z = _fogAreaCenter.transform.position.z;
				}
				UpdateMaterialHeights(mainCamera);
			}
			if (_pointLightTrackingAuto && (!Application.isPlaying || time - trackPointAutoLastTime > _pointLightTrackingCheckInterval))
			{
				trackPointAutoLastTime = time;
				TrackPointLights();
			}
			if (updatingTextureSlice >= 0)
			{
				UpdateTextureColors(adjustedColors, forceUpdateEntireTexture: false);
			}
			else if (needUpdateTexture)
			{
				UpdateTexture();
			}
			if (!_hasCamera)
			{
				return;
			}
			if (_fogOfWarEnabled)
			{
				UpdateFogOfWar();
			}
			if (sunShadowsActive)
			{
				CastSunShadows();
			}
			int count = fogInstances.Count;
			if (count <= 1)
			{
				return;
			}
			Vector3 position = mainCamera.transform.position;
			if (!Application.isPlaying || time - lastTimeSortInstances >= 2f)
			{
				needResort = true;
			}
			if (!needResort && (position.x - lastCamPos.x) * (position.x - lastCamPos.x) + (position.y - lastCamPos.y) * (position.y - lastCamPos.y) + (position.z - lastCamPos.z) * (position.z - lastCamPos.z) > 625f)
			{
				lastCamPos = position;
				needResort = true;
			}
			if (!needResort)
			{
				return;
			}
			needResort = false;
			lastTimeSortInstances = time;
			float x2 = position.x;
			float y2 = position.y;
			float z = position.z;
			for (int i = 0; i < count; i++)
			{
				VolumetricFog volumetricFog = fogInstances[i];
				if (volumetricFog != null)
				{
					Vector3 position2 = volumetricFog.transform.position;
					position2.y = volumetricFog.currentFogAltitude;
					float num2 = x2 - position2.x;
					float num3 = y2 - position2.y;
					float num4 = num3 * num3;
					float num5 = y2 - (position2.y + volumetricFog.height);
					float num6 = num5 * num5;
					volumetricFog.distanceToCameraYAxis = ((num4 < num6) ? num4 : num6);
					float num7 = z - position2.z;
					float num8 = num2 * num2 + num3 * num3 + num7 * num7;
					volumetricFog.distanceToCamera = num8;
					Vector3 position3 = position2 - volumetricFog.transform.localScale * 0.5f;
					Vector3 position4 = position2 + volumetricFog.transform.localScale * 0.5f;
					volumetricFog.distanceToCameraMin = mainCamera.WorldToScreenPoint(position3).z;
					volumetricFog.distanceToCameraMax = mainCamera.WorldToScreenPoint(position4).z;
				}
			}
			fogInstances.Sort(delegate(VolumetricFog x, VolumetricFog y)
			{
				if (!x || !y)
				{
					return 0;
				}
				if (x._fogAreaSortingMode == FOG_AREA_SORTING_MODE.Fixed || y._fogAreaSortingMode == FOG_AREA_SORTING_MODE.Fixed)
				{
					if (x._fogAreaRenderOrder < y._fogAreaRenderOrder)
					{
						return -1;
					}
					if (x._fogAreaRenderOrder > y._fogAreaRenderOrder)
					{
						return 1;
					}
					return 0;
				}
				if ((x.distanceToCameraMin < y.distanceToCameraMin && x.distanceToCameraMax > y.distanceToCameraMax) || (y.distanceToCameraMin < x.distanceToCameraMin && y.distanceToCameraMax > x.distanceToCameraMax) || x._fogAreaSortingMode == FOG_AREA_SORTING_MODE.Altitude || y._fogAreaSortingMode == FOG_AREA_SORTING_MODE.Altitude)
				{
					if (x.distanceToCameraYAxis < y.distanceToCameraYAxis)
					{
						return 1;
					}
					if (x.distanceToCameraYAxis > y.distanceToCameraYAxis)
					{
						return -1;
					}
					return 0;
				}
				if (x.distanceToCamera < y.distanceToCamera)
				{
					return 1;
				}
				return (x.distanceToCamera > y.distanceToCamera) ? (-1) : 0;
			});
		}

		public void OnPreCull()
		{
			if (!base.enabled || !base.gameObject.activeSelf || fogMat == null || !_hasCamera || mainCamera == null)
			{
				return;
			}
			if (mainCamera.depthTextureMode == DepthTextureMode.None)
			{
				mainCamera.depthTextureMode = DepthTextureMode.Depth;
			}
			if (_computeDepth)
			{
				GetTransparentDepth();
			}
			if (!_hasCamera || !Application.isPlaying)
			{
				return;
			}
			int count = fogRenderInstances.Count;
			for (int i = 0; i < count; i++)
			{
				if (fogRenderInstances[i] != null && fogRenderInstances[i].turbulenceStrength > 0f)
				{
					fogRenderInstances[i].ApplyChaos();
				}
			}
		}

		private void OnPostRender()
		{
			if (!_hasCamera || !Application.isPlaying)
			{
				return;
			}
			int count = fogRenderInstances.Count;
			for (int i = 0; i < count; i++)
			{
				if (fogRenderInstances[i] != null)
				{
					fogRenderInstances[i].DoOnPostRender();
				}
			}
		}

		private void DoOnPostRender()
		{
			if (rtAdjusted != null)
			{
				RenderTexture.ReleaseTemporary(rtAdjusted);
			}
		}

		private void OnDidApplyAnimationProperties()
		{
			shouldUpdateMaterialProperties = true;
		}

		private void FindMainCamera()
		{
			mainCamera = Camera.main;
			if (!(mainCamera == null))
			{
				return;
			}
			Camera[] array = UnityEngine.Object.FindObjectsOfType<Camera>();
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i].isActiveAndEnabled)
				{
					mainCamera = array[i];
					break;
				}
			}
		}

		private bool IsPartOfScene()
		{
			VolumetricFog[] array = UnityEngine.Object.FindObjectsOfType<VolumetricFog>();
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i] == this)
				{
					return true;
				}
			}
			return false;
		}

		private void InitFogMaterial()
		{
			targetFogAlpha = -1f;
			targetSkyHazeAlpha = -1f;
			_skyColor.a = _skyAlpha;
			updatingTextureSlice = -1;
			fogMat = new Material(Shader.Find("VolumetricFogAndMist/VolumetricFog"));
			fogMat.hideFlags = HideFlags.DontSave;
			fogMat.name = "FogMat " + base.name;
			Texture2D texture2D = Resources.Load<Texture2D>("Textures/Noise3");
			noiseTextureSize = texture2D.width;
			noiseColors = texture2D.GetPixels();
			adjustedColors = new Color[noiseColors.Length];
			adjustedTexture = new Texture2D(texture2D.width, texture2D.height, TextureFormat.RGBA32, mipChain: false);
			adjustedTexture.hideFlags = HideFlags.DontSave;
			timeOfLastRender = Time.time;
			chaosLerpMat = new Material(Shader.Find("VolumetricFogAndMist/Chaos Lerp"));
			chaosLerpMat.hideFlags = HideFlags.DontSave;
			CheckPointLightData();
			if (_pointLightTrackingAuto)
			{
				TrackPointLights();
			}
			FogOfWarInit();
			CopyTransitionValues();
			UpdatePreset();
			oldBaselineRelativeCameraY = mainCamera.transform.position.y;
			if (_sunShadows)
			{
				needUpdateDepthSunTexture = true;
			}
		}

		private void UpdateRenderComponents()
		{
			if (_hasCamera)
			{
				if (_renderBeforeTransparent)
				{
					AssignRenderComponent<VolumetricFogPreT>();
					DestroyRenderComponent<VolumetricFogPosT>();
				}
				else if (_transparencyBlendMode == TRANSPARENT_MODE.Blend)
				{
					AssignRenderComponent<VolumetricFogPreT>();
					AssignRenderComponent<VolumetricFogPosT>();
				}
				else
				{
					AssignRenderComponent<VolumetricFogPosT>();
					DestroyRenderComponent<VolumetricFogPreT>();
				}
			}
		}

		private void DestroyRenderComponent<T>() where T : IVolumetricFogRenderComponent
		{
			T[] componentsInChildren = GetComponentsInChildren<T>(includeInactive: true);
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				if (componentsInChildren[i].fog == this || componentsInChildren[i].fog == null)
				{
					componentsInChildren[i].DestroySelf();
				}
			}
		}

		private void AssignRenderComponent<T>() where T : UnityEngine.Component, IVolumetricFogRenderComponent
		{
			T[] componentsInChildren = GetComponentsInChildren<T>(includeInactive: true);
			int num = -1;
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				if (componentsInChildren[i].fog == this)
				{
					return;
				}
				if (componentsInChildren[i].fog == null)
				{
					num = i;
				}
			}
			if (num < 0)
			{
				base.gameObject.AddComponent<T>().fog = this;
			}
			else
			{
				componentsInChildren[num].fog = this;
			}
		}

		private void RegisterFogArea(VolumetricFog fog)
		{
			if (!fogInstances.Contains(fog))
			{
				fogInstances.Add(fog);
			}
		}

		private void UnregisterFogArea(VolumetricFog fog)
		{
			if (fogInstances.Contains(fog))
			{
				fogInstances.Remove(fog);
			}
		}

		private void RegisterWithRenderers()
		{
			allFogRenderers = UnityEngine.Object.FindObjectsOfType<VolumetricFog>();
			if (!_hasCamera && fogRenderer != null)
			{
				if (fogRenderer.enableMultipleCameras)
				{
					for (int i = 0; i < allFogRenderers.Length; i++)
					{
						if (allFogRenderers[i].hasCamera)
						{
							allFogRenderers[i].RegisterFogArea(this);
						}
					}
				}
				else
				{
					fogRenderer.RegisterFogArea(this);
				}
			}
			else
			{
				fogInstances.Clear();
				RegisterFogArea(this);
				for (int j = 0; j < allFogRenderers.Length; j++)
				{
					if (!allFogRenderers[j].hasCamera && (_enableMultipleCameras || allFogRenderers[j].fogRenderer == this))
					{
						RegisterFogArea(allFogRenderers[j]);
					}
				}
			}
			lastTimeSortInstances = 0f;
		}

		private void UnregisterWithRenderers()
		{
			if (allFogRenderers == null)
			{
				return;
			}
			for (int i = 0; i < allFogRenderers.Length; i++)
			{
				if (allFogRenderers[i] != null && allFogRenderers[i].hasCamera)
				{
					allFogRenderers[i].UnregisterFogArea(this);
				}
			}
		}

		public void UpdateMultiCameraSetup()
		{
			if (hasCamera)
			{
				allFogRenderers = UnityEngine.Object.FindObjectsOfType<VolumetricFog>();
				for (int i = 0; i < allFogRenderers.Length; i++)
				{
					if (allFogRenderers[i] != null && allFogRenderers[i].hasCamera)
					{
						allFogRenderers[i].SetEnableMultipleCameras(_enableMultipleCameras);
					}
				}
			}
			RegisterWithRenderers();
		}

		private void SetEnableMultipleCameras(bool state)
		{
			_enableMultipleCameras = state;
			RegisterWithRenderers();
		}

		internal void DoOnRenderImage(RenderTexture source, RenderTexture destination)
		{
			int count = fogInstances.Count;
			fogRenderInstances.Clear();
			Vector3 position = Camera.current.transform.position;
			for (int i = 0; i < count; i++)
			{
				VolumetricFog volumetricFog = fogInstances[i];
				volumetricFog.isRendering = false;
				if (volumetricFog != null && volumetricFog.isActiveAndEnabled && volumetricFog.density > 0f && (volumetricFog._visibilityScope == FOG_VISIBILITY_SCOPE.Global || volumetricFog._visibilityVolume.Contains(position)))
				{
					fogRenderInstances.Add(fogInstances[i]);
				}
			}
			_renderingInstancesCount = fogRenderInstances.Count;
			if (_renderingInstancesCount == 0 || mainCamera == null)
			{
				Graphics.Blit(source, destination);
				return;
			}
			if (_hasCamera && _density <= 0f && shouldUpdateMaterialProperties)
			{
				UpdateMaterialPropertiesNow(Camera.current);
			}
			if (_renderingInstancesCount == 1)
			{
				fogRenderInstances[0].DoOnRenderImageInstance(source, destination);
				return;
			}
			RenderTextureDescriptor descriptor = source.descriptor;
			descriptor.depthBufferBits = 0;
			descriptor.msaaSamples = 1;
			RenderTexture temporary = RenderTexture.GetTemporary(descriptor);
			fogRenderInstances[0].DoOnRenderImageInstance(source, temporary);
			if (_renderingInstancesCount == 2)
			{
				fogRenderInstances[1].DoOnRenderImageInstance(temporary, destination);
			}
			if (_renderingInstancesCount >= 3)
			{
				RenderTexture temporary2 = RenderTexture.GetTemporary(descriptor);
				RenderTexture source2 = temporary;
				RenderTexture renderTexture = temporary2;
				int num = _renderingInstancesCount - 1;
				for (int j = 1; j < num; j++)
				{
					if (j > 1)
					{
						renderTexture.DiscardContents();
					}
					fogRenderInstances[j].DoOnRenderImageInstance(source2, renderTexture);
					if (renderTexture == temporary2)
					{
						source2 = temporary2;
						renderTexture = temporary;
					}
					else
					{
						source2 = temporary;
						renderTexture = temporary2;
					}
				}
				fogRenderInstances[num].DoOnRenderImageInstance(source2, destination);
				RenderTexture.ReleaseTemporary(temporary2);
			}
			RenderTexture.ReleaseTemporary(temporary);
		}

		internal void DoOnRenderImageInstance(RenderTexture source, RenderTexture destination)
		{
			Camera current = Camera.current;
			if (current == null || fogMat == null)
			{
				Graphics.Blit(source, destination);
				return;
			}
			isRendering = true;
			if (!_hasCamera)
			{
				CheckFogAreaDimensions();
				if (_sunShadows && !fogRenderer.sunShadows)
				{
					fogRenderer.sunShadows = true;
				}
			}
			if (shouldUpdateMaterialProperties)
			{
				UpdateMaterialPropertiesNow(current);
			}
			int frameCount = Time.frameCount;
			float time = Time.time;
			if (lastFrameCount != frameCount && Application.isPlaying)
			{
				if (_useRealTime)
				{
					deltaTime = time - timeOfLastRender;
					timeOfLastRender = time;
				}
				else
				{
					deltaTime = Time.deltaTime;
				}
				UpdateWindSpeedQuick();
			}
			if (_hasCamera)
			{
				if (_spsrBehaviour == SPSR_BEHAVIOUR.AutoDetect)
				{
					useSinglePassStereoRenderingMatrix = XRSettings.stereoRenderingMode != XRSettings.StereoRenderingMode.MultiPass;
				}
				if (_spsrBehaviour == SPSR_BEHAVIOUR.ForcedOn && !_useSinglePassStereoRenderingMatrix)
				{
					useSinglePassStereoRenderingMatrix = true;
				}
				else if (_spsrBehaviour == SPSR_BEHAVIOUR.ForcedOff && _useSinglePassStereoRenderingMatrix)
				{
					useSinglePassStereoRenderingMatrix = false;
				}
			}
			bool flag = VRCheck.IsVrRunning();
			Vector3 position = current.transform.position;
			bool flag2 = fogRenderer.reduceFlickerBigWorlds;
			if (flag2)
			{
				fogMat.SetVector(ShaderParams.FlickerFreeCamPos, position);
				current.transform.position = Vector3.zero;
				if (flag)
				{
					current.ResetWorldToCameraMatrix();
				}
			}
			else
			{
				fogMat.SetVector(ShaderParams.FlickerFreeCamPos, Vector4.zero);
			}
			if (current.orthographic)
			{
				fogMat.SetVector(ShaderParams.ClipDir, current.transform.forward);
			}
			if (flag && fogRenderer.useSinglePassStereoRenderingMatrix)
			{
				fogMat.SetMatrix(ShaderParams.ClipToWorld, current.cameraToWorldMatrix);
			}
			else
			{
				fogMat.SetMatrix(ShaderParams.ClipToWorld, current.cameraToWorldMatrix * current.projectionMatrix.inverse);
			}
			if (flag2)
			{
				current.transform.position = position;
			}
			if (_lightScatteringEnabled && (bool)fogRenderer.sun)
			{
				UpdateScatteringData(current);
			}
			if (lastFrameCount != frameCount || !Application.isPlaying)
			{
				if (pointLightParams.Length != 6)
				{
					CheckPointLightData();
				}
				for (int i = 0; i < pointLightParams.Length; i++)
				{
					Light light = pointLightParams[i].light;
					if (!(light != null))
					{
						continue;
					}
					if (pointLightParams[i].color != light.color)
					{
						pointLightParams[i].color = light.color;
						isDirty = true;
					}
					if (pointLightParams[i].range != light.range)
					{
						pointLightParams[i].range = light.range;
						isDirty = true;
					}
					if (pointLightParams[i].position != light.transform.position)
					{
						pointLightParams[i].position = light.transform.position;
						isDirty = true;
					}
					if (pointLightParams[i].intensity != light.intensity)
					{
						pointLightParams[i].intensity = light.intensity;
						isDirty = true;
					}
					if (pointLightParams[i].lightParams == null)
					{
						pointLightParams[i].lightParams = pointLightParams[i].light.GetComponent<VolumetricFogLightParams>();
						if (pointLightParams[i].lightParams == null)
						{
							pointLightParams[i].lightParams = pointLightParams[i].light.gameObject.AddComponent<VolumetricFogLightParams>();
						}
					}
					pointLightParams[i].rangeMultiplier = pointLightParams[i].lightParams.rangeMultiplier;
					pointLightParams[i].intensityMultiplier = pointLightParams[i].lightParams.intensityMultiplier;
				}
				SetPointLightMaterialProperties(current);
			}
			RenderTexture renderTexture = null;
			if ((float)_downsampling > 1f || _forceComposition)
			{
				int scaledSize = GetScaledSize(source.width, _downsampling);
				int scaledSize2 = GetScaledSize(source.width, _downsampling);
				RenderTextureDescriptor descriptor = source.descriptor;
				descriptor.width = scaledSize;
				descriptor.height = scaledSize2;
				descriptor.msaaSamples = 1;
				reducedDestination = RenderTexture.GetTemporary(descriptor);
				RenderTextureDescriptor descriptor2 = source.descriptor;
				descriptor2.width = scaledSize;
				descriptor2.height = scaledSize2;
				descriptor2.msaaSamples = 1;
				descriptor.colorFormat = rtDownsampledFormat;
				RenderTexture temporary = RenderTexture.GetTemporary(descriptor);
				if (_fogBlur)
				{
					SetBlurTexture(source, descriptor);
				}
				if (!_edgeImprove || flag || SystemInfo.supportedRenderTargetCount < 2)
				{
					Graphics.Blit(source, reducedDestination, fogMat, 3);
					if (_edgeImprove)
					{
						Graphics.Blit(source, temporary, fogMat, 4);
						fogMat.SetTexture(ShaderParams.DownsampledDepth, temporary);
					}
					else
					{
						fogMat.SetTexture(ShaderParams.DownsampledDepth, null);
					}
				}
				else
				{
					fogMat.SetTexture(ShaderParams.MainTex, source);
					mrt[0] = reducedDestination.colorBuffer;
					mrt[1] = temporary.colorBuffer;
					Graphics.SetRenderTarget(mrt, reducedDestination.depthBuffer);
					Graphics.Blit(null, fogMat, 1);
					fogMat.SetTexture(ShaderParams.DownsampledDepth, temporary);
				}
				fogMat.SetTexture(ShaderParams.FogDownsampled, reducedDestination);
				Graphics.Blit(source, destination, fogMat, 2);
				RenderTexture.ReleaseTemporary(temporary);
				RenderTexture.ReleaseTemporary(reducedDestination);
			}
			else
			{
				if (_fogBlur)
				{
					RenderTextureDescriptor descriptor3 = source.descriptor;
					descriptor3.width = 256;
					descriptor3.height = 256;
					SetBlurTexture(source, descriptor3);
				}
				Graphics.Blit(source, destination, fogMat, 0);
			}
			if (flag2 && flag)
			{
				current.ResetWorldToCameraMatrix();
			}
			if ((object)renderTexture != null)
			{
				RenderTexture.ReleaseTemporary(renderTexture);
			}
			lastFrameCount = frameCount;
		}

		private int GetScaledSize(int size, float factor)
		{
			size = (int)((float)size / factor);
			size /= 4;
			if (size < 1)
			{
				size = 1;
			}
			return size * 4;
		}

		private void CleanUpDepthTexture()
		{
			if ((bool)depthTexture)
			{
				RenderTexture.ReleaseTemporary(depthTexture);
				depthTexture = null;
			}
		}

		private void GetTransparentDepth()
		{
			CleanUpDepthTexture();
			if (depthCam == null)
			{
				if (depthCamObj == null)
				{
					depthCamObj = GameObject.Find("VFMDepthCamera");
				}
				if (depthCamObj == null)
				{
					depthCamObj = new GameObject("VFMDepthCamera");
					depthCam = depthCamObj.AddComponent<Camera>();
					depthCam.enabled = false;
					depthCamObj.hideFlags = HideFlags.HideAndDontSave;
				}
				else
				{
					depthCam = depthCamObj.GetComponent<Camera>();
					if (depthCam == null)
					{
						UnityEngine.Object.DestroyImmediate(depthCamObj);
						depthCamObj = null;
						return;
					}
				}
			}
			Camera other = mainCamera;
			depthCam.CopyFrom(other);
			depthCam.depthTextureMode = DepthTextureMode.None;
			depthTexture = RenderTexture.GetTemporary(mainCamera.pixelWidth, mainCamera.pixelHeight, 24, RenderTextureFormat.Depth, RenderTextureReadWrite.Linear);
			depthCam.backgroundColor = new Color(0f, 0f, 0f, 0f);
			depthCam.clearFlags = CameraClearFlags.Color;
			depthCam.cullingMask = _transparencyLayerMask;
			depthCam.targetTexture = depthTexture;
			depthCam.renderingPath = RenderingPath.Forward;
			if ((object)depthShader == null)
			{
				depthShader = Shader.Find("VolumetricFogAndMist/CopyDepth");
			}
			if ((object)depthShaderAndTrans == null)
			{
				depthShaderAndTrans = Shader.Find("VolumetricFogAndMist/CopyDepthAndTrans");
			}
			switch (_computeDepthScope)
			{
			case COMPUTE_DEPTH_SCOPE.OnlyTreeBillboards:
				depthCam.RenderWithShader(depthShader, "RenderType");
				break;
			case COMPUTE_DEPTH_SCOPE.TreeBillboardsAndTransparentObjects:
				depthCam.RenderWithShader(depthShaderAndTrans, "RenderType");
				break;
			default:
				depthCam.RenderWithShader(depthShaderAndTrans, null);
				break;
			}
			Shader.SetGlobalTexture(ShaderParams.GlobalDepthTexture, depthTexture);
		}

		private void CastSunShadows()
		{
		}

		private void GetSunShadows()
		{
			if (_sun == null || !_sunShadows)
			{
				return;
			}
			if (depthSunCam == null)
			{
				if (depthSunCamObj == null)
				{
					depthSunCamObj = GameObject.Find("VFMDepthSunCamera");
				}
				if (depthSunCamObj == null)
				{
					depthSunCamObj = new GameObject("VFMDepthSunCamera");
					depthSunCamObj.hideFlags = HideFlags.HideAndDontSave;
					depthSunCam = depthSunCamObj.AddComponent<Camera>();
				}
				else
				{
					depthSunCam = depthSunCamObj.GetComponent<Camera>();
					if (depthSunCam == null)
					{
						UnityEngine.Object.DestroyImmediate(depthSunCamObj);
						depthSunCamObj = null;
						return;
					}
				}
				if (depthSunShader == null)
				{
					depthSunShader = Shader.Find("VolumetricFogAndMist/CopySunDepth");
				}
				depthSunCam.SetReplacementShader(depthSunShader, "RenderType");
				depthSunCam.nearClipPlane = 1f;
				depthSunCam.renderingPath = RenderingPath.Forward;
				depthSunCam.orthographic = true;
				depthSunCam.aspect = 1f;
				depthSunCam.backgroundColor = new Color(0f, 0f, 0.5f, 0f);
				depthSunCam.clearFlags = CameraClearFlags.Color;
				depthSunCam.depthTextureMode = DepthTextureMode.None;
			}
			float orthographicSize = _sunShadowsMaxDistance / 0.95f;
			depthSunCam.transform.position = mainCamera.transform.position - _sun.transform.forward * 2000f;
			depthSunCam.transform.rotation = _sun.transform.rotation;
			depthSunCam.farClipPlane = 4000f;
			depthSunCam.orthographicSize = orthographicSize;
			if (sunLight != null)
			{
				depthSunCam.cullingMask = _sunShadowsLayerMask;
			}
			if (depthSunTexture == null || currentDepthSunTextureRes != _sunShadowsResolution)
			{
				currentDepthSunTextureRes = _sunShadowsResolution;
				int width = (int)Mathf.Pow(2f, _sunShadowsResolution + 9);
				depthSunTexture = new RenderTexture(width, width, 24, RenderTextureFormat.ARGB32, RenderTextureReadWrite.Linear);
				depthSunTexture.hideFlags = HideFlags.DontSave;
				depthSunTexture.filterMode = FilterMode.Point;
				depthSunTexture.wrapMode = TextureWrapMode.Clamp;
				depthSunTexture.Create();
			}
			depthSunCam.targetTexture = depthSunTexture;
			Shader.SetGlobalFloat(ShaderParams.GlobalShadowBias, _sunShadowsBias);
			if (Application.isPlaying && _sunShadowsBakeMode == SUN_SHADOWS_BAKE_MODE.Realtime)
			{
				if (!depthSunCam.enabled)
				{
					depthSunCam.enabled = true;
				}
			}
			else
			{
				if (depthSunCam.enabled)
				{
					depthSunCam.enabled = false;
				}
				depthSunCam.Render();
			}
			Shader.SetGlobalMatrix(ShaderParams.GlobalSunProjection, depthSunCam.projectionMatrix * depthSunCam.worldToCameraMatrix);
			Shader.SetGlobalTexture(ShaderParams.GlobalSunDepthTexture, depthSunTexture);
			Vector4 value = depthSunCam.transform.position;
			value.w = Mathf.Min(_sunShadowsMaxDistance, _maxFogLength);
			Shader.SetGlobalVector(ShaderParams.GlobalSunWorldPos, value);
			UpdateSunShadowsData();
		}

		private void SetBlurTexture(RenderTexture source, RenderTextureDescriptor desc)
		{
			if (blurMat == null)
			{
				Shader shader = Shader.Find("VolumetricFogAndMist/Blur");
				blurMat = new Material(shader);
				blurMat.hideFlags = HideFlags.DontSave;
				if (blurMat == null)
				{
					return;
				}
			}
			blurMat.SetFloat(ShaderParams.BlurDepth, _fogBlurDepth);
			RenderTexture temporary = RenderTexture.GetTemporary(desc);
			Graphics.Blit(source, temporary, blurMat, 0);
			RenderTexture temporary2 = RenderTexture.GetTemporary(desc);
			Graphics.Blit(temporary, temporary2, blurMat, 1);
			blurMat.SetFloat(ShaderParams.BlurDepth, _fogBlurDepth * 2f);
			temporary.DiscardContents();
			Graphics.Blit(temporary2, temporary, blurMat, 0);
			temporary2.DiscardContents();
			Graphics.Blit(temporary, temporary2, blurMat, 1);
			fogMat.SetTexture(ShaderParams.BlurTex, temporary2);
			RenderTexture.ReleaseTemporary(temporary2);
			RenderTexture.ReleaseTemporary(temporary);
		}

		private void DestroySunShadowsDependencies()
		{
			if (depthSunCamObj != null)
			{
				UnityEngine.Object.DestroyImmediate(depthSunCamObj);
				depthSunCamObj = null;
			}
			CleanUpTextureDepthSun();
		}

		private void CleanUpTextureDepthSun()
		{
			if (depthSunTexture != null)
			{
				depthSunTexture.Release();
				depthSunTexture = null;
			}
		}

		public string GetCurrentPresetName()
		{
			return Enum.GetName(typeof(FOG_PRESET), _preset);
		}

		public void UpdatePreset()
		{
			switch (_preset)
			{
			case FOG_PRESET.Clear:
				_density = 0f;
				_fogOfWarEnabled = false;
				_fogVoidRadius = 0f;
				break;
			case FOG_PRESET.Mist:
				_skySpeed = 0.3f;
				_skyHaze = 15f;
				_skyNoiseStrength = 0.1f;
				_skyAlpha = 0.8f;
				_density = 0.3f;
				_noiseStrength = 0.6f;
				_noiseScale = 1f;
				_skyNoiseScale = 1f;
				_noiseSparse = 0f;
				_distance = 0f;
				_distanceFallOff = 0f;
				_maxFogLengthFallOff = 0.5f;
				_height = 6f;
				_heightFallOff = 0.6f;
				_deepObscurance = 1f;
				_stepping = 8f;
				_steppingNear = 0f;
				_alpha = 1f;
				_color = new Color(0.89f, 0.89f, 0.89f);
				_skyColor = new Color(0.81f, 0.81f, 0.81f);
				_specularColor = new Color(1f, 1f, 0.8f, 1f);
				_specularIntensity = 0.1f;
				_specularThreshold = 0.6f;
				_lightColor = Color.white;
				_lightIntensity = 0.12f;
				_speed = 0.01f;
				_downsampling = 1;
				_baselineRelativeToCamera = false;
				CheckWaterLevel(baseZero: false);
				_fogVoidRadius = 0f;
				CopyTransitionValues();
				break;
			case FOG_PRESET.WindyMist:
				_skySpeed = 0.3f;
				_skyHaze = 25f;
				_skyNoiseStrength = 0.1f;
				_skyAlpha = 0.85f;
				_density = 0.3f;
				_noiseStrength = 0.5f;
				_noiseScale = 1.15f;
				_skyNoiseScale = 1.15f;
				_noiseSparse = 0f;
				_distance = 0f;
				_distanceFallOff = 0f;
				_maxFogLengthFallOff = 0.5f;
				_height = 6.5f;
				_heightFallOff = 0.6f;
				_deepObscurance = 1f;
				_stepping = 10f;
				_steppingNear = 0f;
				_alpha = 1f;
				_color = new Color(0.89f, 0.89f, 0.89f, 1f);
				_skyColor = new Color(0.81f, 0.81f, 0.81f);
				_specularColor = new Color(1f, 1f, 0.8f, 1f);
				_specularIntensity = 0.1f;
				_specularThreshold = 0.6f;
				_lightColor = Color.white;
				_lightIntensity = 0f;
				_speed = 0.15f;
				_downsampling = 1;
				_baselineRelativeToCamera = false;
				CheckWaterLevel(baseZero: false);
				_fogVoidRadius = 0f;
				CopyTransitionValues();
				break;
			case FOG_PRESET.GroundFog:
				_skySpeed = 0.3f;
				_skyHaze = 0f;
				_skyNoiseStrength = 0.1f;
				_skyAlpha = 0.85f;
				_density = 0.6f;
				_noiseStrength = 0.479f;
				_noiseScale = 1.15f;
				_skyNoiseScale = 1.15f;
				_noiseSparse = 0f;
				_distance = 5f;
				_distanceFallOff = 1f;
				_maxFogLengthFallOff = 0.6f;
				_height = 1.5f;
				_heightFallOff = 0.6f;
				_deepObscurance = 1f;
				_stepping = 8f;
				_steppingNear = 0f;
				_alpha = 0.95f;
				_color = new Color(0.89f, 0.89f, 0.89f, 1f);
				_skyColor = new Color(0.79f, 0.79f, 0.79f, 1f);
				_specularColor = new Color(1f, 1f, 0.8f, 1f);
				_specularIntensity = 0.2f;
				_specularThreshold = 0.6f;
				_lightColor = Color.white;
				_lightIntensity = 0.2f;
				_speed = 0.01f;
				_downsampling = 1;
				_baselineRelativeToCamera = false;
				CheckWaterLevel(baseZero: false);
				_fogVoidRadius = 0f;
				CopyTransitionValues();
				break;
			case FOG_PRESET.FrostedGround:
				_skySpeed = 0f;
				_skyHaze = 0f;
				_skyNoiseStrength = 0.729f;
				_skyAlpha = 0.55f;
				_density = 1f;
				_noiseStrength = 0.164f;
				_noiseScale = 1.81f;
				_skyNoiseScale = 1.81f;
				_noiseSparse = 0f;
				_distance = 0f;
				_distanceFallOff = 0f;
				_height = 0.5f;
				_heightFallOff = 0.6f;
				_deepObscurance = 1f;
				_stepping = 20f;
				_steppingNear = 50f;
				_alpha = 0.97f;
				_color = new Color(0.546f, 0.648f, 0.71f, 1f);
				_skyColor = _color;
				_specularColor = new Color(0.792f, 0.792f, 0.792f, 1f);
				_specularIntensity = 1f;
				_specularThreshold = 0.866f;
				_lightColor = new Color(0.972f, 0.972f, 0.972f, 1f);
				_lightIntensity = 0.743f;
				_speed = 0f;
				_downsampling = 1;
				_baselineRelativeToCamera = false;
				CheckWaterLevel(baseZero: false);
				_fogVoidRadius = 0f;
				CopyTransitionValues();
				break;
			case FOG_PRESET.FoggyLake:
				_skySpeed = 0.3f;
				_skyHaze = 40f;
				_skyNoiseStrength = 0.574f;
				_skyAlpha = 0.827f;
				_density = 1f;
				_noiseStrength = 0.03f;
				_noiseScale = 5.77f;
				_skyNoiseScale = 5.77f;
				_noiseSparse = 0f;
				_distance = 0f;
				_distanceFallOff = 0f;
				_maxFogLengthFallOff = 0.6f;
				_height = 4f;
				_heightFallOff = 0.6f;
				_deepObscurance = 1f;
				_stepping = 6f;
				_steppingNear = 14.4f;
				_alpha = 1f;
				_color = new Color(0f, 0.96f, 1f, 1f);
				_skyColor = _color;
				_specularColor = Color.white;
				_lightColor = Color.white;
				_specularIntensity = 0.861f;
				_specularThreshold = 0.907f;
				_lightIntensity = 0.126f;
				_speed = 0f;
				_downsampling = 1;
				_baselineRelativeToCamera = false;
				CheckWaterLevel(baseZero: false);
				_fogVoidRadius = 0f;
				CopyTransitionValues();
				break;
			case FOG_PRESET.LowClouds:
				_skySpeed = 0.3f;
				_skyHaze = 60f;
				_skyNoiseStrength = 0.97f;
				_skyAlpha = 0.96f;
				_density = 1f;
				_noiseStrength = 0.7f;
				_noiseScale = 1f;
				_skyNoiseScale = 1f;
				_noiseSparse = 0f;
				_distance = 0f;
				_distanceFallOff = 0f;
				_maxFogLengthFallOff = 0.6f;
				_height = 4f;
				_heightFallOff = 0.6f;
				_deepObscurance = 1f;
				_stepping = 12f;
				_steppingNear = 0f;
				_alpha = 0.98f;
				_color = new Color(0.89f, 0.89f, 0.89f, 1f);
				_skyColor = new Color(0.79f, 0.79f, 0.79f, 1f);
				_specularColor = new Color(1f, 1f, 0.8f, 1f);
				_specularIntensity = 0.15f;
				_specularThreshold = 0.6f;
				_lightColor = Color.white;
				_lightIntensity = 0.15f;
				_speed = 0.008f;
				_downsampling = 1;
				_baselineRelativeToCamera = false;
				CheckWaterLevel(baseZero: false);
				_fogVoidRadius = 0f;
				CopyTransitionValues();
				break;
			case FOG_PRESET.SeaClouds:
				_skySpeed = 0.3f;
				_skyHaze = 60f;
				_skyNoiseStrength = 0.97f;
				_skyAlpha = 0.96f;
				_density = 1f;
				_noiseStrength = 1f;
				_noiseScale = 1.5f;
				_skyNoiseScale = 1.5f;
				_noiseSparse = 0f;
				_distance = 0f;
				_distanceFallOff = 0f;
				_maxFogLengthFallOff = 0.7f;
				_deepObscurance = 1f;
				_height = 12.4f;
				_heightFallOff = 0.6f;
				_stepping = 6f;
				_alpha = 0.98f;
				_color = new Color(0.89f, 0.89f, 0.89f, 1f);
				_skyColor = new Color(0.83f, 0.83f, 0.83f, 1f);
				_specularColor = new Color(1f, 1f, 0.8f, 1f);
				_specularIntensity = 0.259f;
				_specularThreshold = 0.6f;
				_lightColor = Color.white;
				_lightIntensity = 0.15f;
				_speed = 0.008f;
				_downsampling = 1;
				_baselineRelativeToCamera = false;
				CheckWaterLevel(baseZero: false);
				_fogVoidRadius = 0f;
				CopyTransitionValues();
				break;
			case FOG_PRESET.Fog:
				_skySpeed = 0.3f;
				_skyHaze = 144f;
				_skyNoiseStrength = 0.7f;
				_skyAlpha = 0.9f;
				_density = 0.35f;
				_noiseStrength = 0.3f;
				_noiseScale = 1f;
				_skyNoiseScale = 1f;
				_noiseSparse = 0f;
				_distance = 20f;
				_distanceFallOff = 0.7f;
				_maxFogLengthFallOff = 0.5f;
				_height = 8f;
				_heightFallOff = 0.6f;
				_deepObscurance = 1f;
				_stepping = 8f;
				_steppingNear = 0f;
				_alpha = 0.97f;
				_color = new Color(0.89f, 0.89f, 0.89f, 1f);
				_skyColor = new Color(0.79f, 0.79f, 0.79f, 1f);
				_specularColor = new Color(1f, 1f, 0.8f, 1f);
				_specularIntensity = 0f;
				_specularThreshold = 0.6f;
				_lightColor = Color.white;
				_lightIntensity = 0f;
				_speed = 0.05f;
				_downsampling = 1;
				_baselineRelativeToCamera = false;
				CheckWaterLevel(baseZero: false);
				_fogVoidRadius = 0f;
				CopyTransitionValues();
				break;
			case FOG_PRESET.HeavyFog:
				_skySpeed = 0.05f;
				_skyHaze = 500f;
				_skyNoiseStrength = 0.826f;
				_skyAlpha = 1f;
				_density = 0.35f;
				_noiseStrength = 0.1f;
				_noiseScale = 1f;
				_skyNoiseScale = 1f;
				_noiseSparse = 0f;
				_distance = 20f;
				_distanceFallOff = 0.8f;
				_deepObscurance = 1f;
				_height = 18f;
				_heightFallOff = 0.6f;
				_stepping = 6f;
				_steppingNear = 0f;
				_alpha = 1f;
				_color = new Color(0.91f, 0.91f, 0.91f, 1f);
				_skyColor = new Color(0.79f, 0.79f, 0.79f, 1f);
				_specularColor = new Color(1f, 1f, 0.8f, 1f);
				_specularIntensity = 0f;
				_specularThreshold = 0.6f;
				_lightColor = Color.white;
				_lightIntensity = 0f;
				_speed = 0.015f;
				_downsampling = 1;
				_baselineRelativeToCamera = false;
				CheckWaterLevel(baseZero: false);
				_fogVoidRadius = 0f;
				CopyTransitionValues();
				break;
			case FOG_PRESET.SandStorm1:
				_skySpeed = 0.35f;
				_skyHaze = 388f;
				_skyNoiseStrength = 0.847f;
				_skyAlpha = 1f;
				_density = 0.487f;
				_noiseStrength = 0.758f;
				_noiseScale = 1.71f;
				_skyNoiseScale = 1.71f;
				_noiseSparse = 0f;
				_distance = 0f;
				_distanceFallOff = 0f;
				_height = 16f;
				_heightFallOff = 0.6f;
				_deepObscurance = 1f;
				_stepping = 6f;
				_steppingNear = 0f;
				_alpha = 1f;
				_color = new Color(0.505f, 0.505f, 0.505f, 1f);
				_skyColor = _color;
				_specularColor = new Color(1f, 1f, 0.8f, 1f);
				_specularIntensity = 0f;
				_specularThreshold = 0.6f;
				_lightColor = Color.white;
				_lightIntensity = 0f;
				_speed = 0.3f;
				_windDirection = Vector3.right;
				_downsampling = 1;
				_baselineRelativeToCamera = false;
				CheckWaterLevel(baseZero: false);
				_fogVoidRadius = 0f;
				CopyTransitionValues();
				break;
			case FOG_PRESET.Smoke:
				_skySpeed = 0.109f;
				_skyHaze = 10f;
				_skyNoiseStrength = 0.119f;
				_skyAlpha = 1f;
				_density = 1f;
				_noiseStrength = 0.767f;
				_noiseScale = 1.6f;
				_skyNoiseScale = 1.6f;
				_noiseSparse = 0f;
				_distance = 0f;
				_distanceFallOff = 0f;
				_maxFogLengthFallOff = 0.7f;
				_height = 8f;
				_heightFallOff = 0.6f;
				_deepObscurance = 1f;
				_stepping = 12f;
				_steppingNear = 25f;
				_alpha = 1f;
				_color = new Color(0.125f, 0.125f, 0.125f, 1f);
				_skyColor = _color;
				_specularColor = new Color(1f, 1f, 1f, 1f);
				_specularIntensity = 0.575f;
				_specularThreshold = 0.6f;
				_lightColor = Color.white;
				_lightIntensity = 1f;
				_speed = 0.075f;
				_windDirection = Vector3.right;
				_downsampling = 1;
				_baselineRelativeToCamera = false;
				CheckWaterLevel(baseZero: false);
				_baselineHeight += 8f;
				_fogVoidRadius = 0f;
				CopyTransitionValues();
				break;
			case FOG_PRESET.ToxicSwamp:
				_skySpeed = 0.062f;
				_skyHaze = 22f;
				_skyNoiseStrength = 0.694f;
				_skyAlpha = 1f;
				_density = 1f;
				_noiseStrength = 1f;
				_noiseScale = 1f;
				_skyNoiseScale = 1f;
				_noiseSparse = 0f;
				_distance = 0f;
				_distanceFallOff = 0f;
				_height = 2.5f;
				_heightFallOff = 0.6f;
				_deepObscurance = 1f;
				_stepping = 20f;
				_steppingNear = 50f;
				_alpha = 0.95f;
				_color = new Color(0.0238f, 0.175f, 0.109f, 1f);
				_skyColor = _color;
				_specularColor = new Color(0.593f, 0.625f, 0.207f, 1f);
				_specularIntensity = 0.735f;
				_specularThreshold = 0.6f;
				_lightColor = new Color(0.73f, 0.746f, 0.511f, 1f);
				_lightIntensity = 0.492f;
				_speed = 0.0003f;
				_windDirection = Vector3.right;
				_downsampling = 1;
				_baselineRelativeToCamera = false;
				CheckWaterLevel(baseZero: false);
				_fogVoidRadius = 0f;
				CopyTransitionValues();
				break;
			case FOG_PRESET.SandStorm2:
				_skySpeed = 0f;
				_skyHaze = 0f;
				_skyNoiseStrength = 0.729f;
				_skyAlpha = 0.55f;
				_density = 0.545f;
				_noiseStrength = 1f;
				_noiseScale = 3f;
				_skyNoiseScale = 3f;
				_noiseSparse = 0f;
				_distance = 0f;
				_distanceFallOff = 0f;
				_height = 12f;
				_heightFallOff = 0.6f;
				_deepObscurance = 1f;
				_stepping = 5f;
				_steppingNear = 19.6f;
				_alpha = 0.96f;
				_color = new Color(0.609f, 0.609f, 0.609f, 1f);
				_skyColor = _color;
				_specularColor = new Color(0.589f, 0.621f, 0.207f, 1f);
				_specularIntensity = 0.505f;
				_specularThreshold = 0.6f;
				_lightColor = new Color(0.726f, 0.742f, 0.507f, 1f);
				_lightIntensity = 0.581f;
				_speed = 0.168f;
				_windDirection = Vector3.right;
				_downsampling = 1;
				_baselineRelativeToCamera = false;
				CheckWaterLevel(baseZero: false);
				_fogVoidRadius = 0f;
				CopyTransitionValues();
				break;
			case FOG_PRESET.WorldEdge:
			{
				_skySpeed = 0.3f;
				_skyHaze = 60f;
				_skyNoiseStrength = 0.97f;
				_skyAlpha = 0.96f;
				_density = 1f;
				_noiseStrength = 1f;
				_noiseScale = 3f;
				_skyNoiseScale = 3f;
				_noiseSparse = 0f;
				_distance = 0f;
				_distanceFallOff = 0f;
				_maxFogLengthFallOff = 1f;
				_height = 20f;
				_heightFallOff = 0.6f;
				_deepObscurance = 1f;
				_stepping = 6f;
				_alpha = 0.98f;
				_color = new Color(0.89f, 0.89f, 0.89f, 1f);
				_skyColor = _color;
				_specularColor = new Color(1f, 1f, 0.8f, 1f);
				_specularIntensity = 0.259f;
				_specularThreshold = 0.6f;
				_lightColor = Color.white;
				_lightIntensity = 0.15f;
				_speed = 0.03f;
				_downsampling = 2;
				_baselineRelativeToCamera = false;
				CheckWaterLevel(baseZero: false);
				Terrain activeTerrain = GetActiveTerrain();
				if (activeTerrain != null)
				{
					_fogVoidPosition = activeTerrain.transform.position + activeTerrain.terrainData.size * 0.5f;
					_fogVoidRadius = activeTerrain.terrainData.size.x * 0.45f;
					_fogVoidHeight = activeTerrain.terrainData.size.y;
					_fogVoidDepth = activeTerrain.terrainData.size.z * 0.45f;
					_fogVoidFallOff = 6f;
					_fogAreaRadius = 0f;
					_character = null;
					_fogAreaCenter = null;
					float x = activeTerrain.terrainData.size.x;
					if (mainCamera.farClipPlane < x)
					{
						mainCamera.farClipPlane = x;
					}
					if (_maxFogLength < x * 0.6f)
					{
						_maxFogLength = x * 0.6f;
					}
				}
				CopyTransitionValues();
				break;
			}
			}
			currentFogAlpha = _alpha;
			currentFogColor = _color;
			currentFogSpecularColor = _specularColor;
			currentLightColor = _lightColor;
			currentSkyHazeAlpha = _skyAlpha;
			UpdateSun();
			FogOfWarUpdateTexture();
			UpdateMaterialProperties(forceNow: true);
			UpdateRenderComponents();
			UpdateTextureAlpha();
			UpdateTexture();
			if (_sunShadows)
			{
				needUpdateDepthSunTexture = true;
			}
			else
			{
				DestroySunShadowsDependencies();
			}
			if (!Application.isPlaying)
			{
				UpdateWindSpeedQuick();
			}
			TrackPointLights();
			lastTimeSortInstances = 0f;
		}

		public void CheckWaterLevel(bool baseZero)
		{
			if (mainCamera == null)
			{
				return;
			}
			if (_baselineHeight > mainCamera.transform.position.y || baseZero)
			{
				_baselineHeight = 0f;
			}
			GameObject gameObject = GameObject.Find("Water");
			if (gameObject == null)
			{
				GameObject[] array = UnityEngine.Object.FindObjectsOfType<GameObject>();
				for (int i = 0; i < array.Length; i++)
				{
					if (array[i] != null && array[i].layer == 4)
					{
						gameObject = array[i];
						break;
					}
				}
			}
			if (gameObject != null)
			{
				_renderBeforeTransparent = false;
				if (_baselineHeight < gameObject.transform.position.y)
				{
					_baselineHeight = gameObject.transform.position.y;
				}
			}
			UpdateMaterialHeights(mainCamera);
		}

		public static Terrain GetActiveTerrain()
		{
			Terrain activeTerrain = Terrain.activeTerrain;
			if (activeTerrain != null && activeTerrain.isActiveAndEnabled)
			{
				return activeTerrain;
			}
			for (int i = 0; i < Terrain.activeTerrains.Length; i++)
			{
				activeTerrain = Terrain.activeTerrains[i];
				if (activeTerrain != null && activeTerrain.isActiveAndEnabled)
				{
					return activeTerrain;
				}
			}
			return null;
		}

		private void UpdateMaterialFogColor()
		{
			Color value = currentFogColor;
			value.r *= 2f * temporaryProperties.color.r;
			value.g *= 2f * temporaryProperties.color.g;
			value.b *= 2f * temporaryProperties.color.b;
			value.a = 1f - _heightFallOff;
			fogMat.SetColor(ShaderParams.FogColor, value);
		}

		private void UpdateMaterialHeights(Camera mainCamera)
		{
			currentFogAltitude = _baselineHeight;
			Vector3 vector = _fogAreaPosition;
			if (_fogAreaRadius > 0f)
			{
				currentFogAltitude += _fogAreaPosition.y;
				if (_useXYPlane)
				{
					vector.z = 0f;
				}
				else
				{
					vector.y = 0f;
				}
			}
			if (_baselineRelativeToCamera && !_useXYPlane)
			{
				oldBaselineRelativeCameraY += (mainCamera.transform.position.y - oldBaselineRelativeCameraY) * Mathf.Clamp01(1.001f - _baselineRelativeToCameraDelay);
				currentFogAltitude += oldBaselineRelativeCameraY - 1f;
			}
			float w = 0.01f / _noiseScale;
			fogMat.SetVector(ShaderParams.FogData, new Vector4(currentFogAltitude, _height, 1f / (_density * temporaryProperties.density), w));
			fogMat.SetFloat(ShaderParams.FogSkyHaze, _skyHaze + currentFogAltitude);
			Vector3 vector2 = _fogVoidPosition - currentFogAltitude * Vector3.up;
			fogMat.SetVector(ShaderParams.FogVoidPosition, vector2);
			fogMat.SetVector(ShaderParams.FogAreaPosition, vector);
		}

		public void UpdateMaterialProperties(bool forceNow = false)
		{
			if (forceNow || !Application.isPlaying)
			{
				UpdateMaterialPropertiesNow();
			}
			else
			{
				shouldUpdateMaterialProperties = true;
			}
		}

		public void UpdateMaterialPropertiesNow()
		{
			UpdateMaterialPropertiesNow(mainCamera);
		}

		private void UpdateMaterialPropertiesNow(Camera mainCamera)
		{
			if (fogMat == null || fogRenderer == null)
			{
				return;
			}
			shouldUpdateMaterialProperties = false;
			UpdateSkyColor(_skyAlpha);
			fogMat.SetFloat(ShaderParams.DeepObscurance, _deepObscurance);
			Vector4 value = new Vector4(1f / (_stepping + 1f), 1f / (1f + _steppingNear), _edgeThreshold, _dithering ? (_ditherStrength * 0.01f) : 0f);
			fogMat.SetFloat(ShaderParams.Jitter, _jitterStrength);
			if (!_edgeImprove)
			{
				value.z = 0f;
			}
			fogMat.SetVector(ShaderParams.FogStepping, value);
			fogMat.SetFloat(ShaderParams.FogAlpha, currentFogAlpha);
			UpdateMaterialHeights(mainCamera);
			float num = 0.01f / _noiseScale;
			if (_maxFogLength < 0f)
			{
				_maxFogLength = 0f;
			}
			float w = _maxFogLength - _maxFogLength * (1f - _maxFogLengthFallOff) + 1f;
			fogMat.SetVector(ShaderParams.FogDistance, new Vector4(num * num * _distance * _distance, _distanceFallOff * _distanceFallOff + 0.1f, _maxFogLength, w));
			UpdateMaterialFogColor();
			if (shaderKeywords == null)
			{
				shaderKeywords = new List<string>();
			}
			else
			{
				shaderKeywords.Clear();
			}
			if (_distance > 0f)
			{
				shaderKeywords.Add("FOG_DISTANCE_ON");
			}
			if (_fogVoidRadius > 0f && _fogVoidFallOff > 0f)
			{
				Vector4 value2 = new Vector4(1f / (1f + _fogVoidRadius), 1f / (1f + _fogVoidHeight), 1f / (1f + _fogVoidDepth), _fogVoidFallOff);
				if (_fogVoidTopology == FOG_VOID_TOPOLOGY.Box)
				{
					shaderKeywords.Add("FOG_VOID_BOX");
				}
				else
				{
					shaderKeywords.Add("FOG_VOID_SPHERE");
				}
				fogMat.SetVector(ShaderParams.FogVoidData, value2);
			}
			if (_fogAreaRadius > 0f && _fogAreaFallOff > 0f)
			{
				Vector4 value3 = new Vector4(1f / (0.0001f + _fogAreaRadius), 1f / (0.0001f + _fogAreaHeight), 1f / (0.0001f + _fogAreaDepth), _fogAreaFallOff);
				if (_fogAreaTopology == FOG_AREA_TOPOLOGY.Box)
				{
					shaderKeywords.Add("FOG_AREA_BOX");
				}
				else
				{
					shaderKeywords.Add("FOG_AREA_SPHERE");
					value3.y = _fogAreaRadius * _fogAreaRadius;
					value3.x /= num;
					value3.z /= num;
				}
				fogMat.SetVector(ShaderParams.FogAreaData, value3);
			}
			if (_skyHaze < 0f)
			{
				_skyHaze = 0f;
			}
			if (_skyHaze > 0f && _skyAlpha > 0f && !_useXYPlane && hasCamera)
			{
				shaderKeywords.Add("FOG_HAZE_ON");
			}
			if (_fogOfWarEnabled)
			{
				shaderKeywords.Add("FOG_OF_WAR_ON");
				fogMat.SetTexture(ShaderParams.FogOfWar, fogOfWarTexture);
				fogMat.SetVector(ShaderParams.FogOfWarCenter, _fogOfWarCenter);
				fogMat.SetVector(ShaderParams.FogOfWarSize, _fogOfWarSize);
				Vector3 vector = _fogOfWarCenter - 0.5f * _fogOfWarSize;
				if (_useXYPlane)
				{
					fogMat.SetVector(ShaderParams.FogOfWarCenterAdjusted, new Vector4(vector.x / _fogOfWarSize.x, vector.y / (_fogOfWarSize.y + 0.0001f), 1f));
				}
				else
				{
					fogMat.SetVector(ShaderParams.FogOfWarCenterAdjusted, new Vector4(vector.x / _fogOfWarSize.x, 1f, vector.z / (_fogOfWarSize.z + 0.0001f)));
				}
			}
			CheckPointLightData();
			bool flag = false;
			for (int i = 0; i < pointLightParams.Length; i++)
			{
				if (pointLightParams[i].light != null || pointLightParams[i].range * pointLightParams[i].intensity > 0f)
				{
					flag = true;
					break;
				}
			}
			if (flag)
			{
				fogMat.SetFloat(ShaderParams.PointLightsInsideAtten, _pointLightInsideAtten);
				shaderKeywords.Add("FOG_POINT_LIGHTS");
			}
			sunShadowsActive = false;
			if ((bool)fogRenderer.sun)
			{
				UpdateScatteringData(mainCamera);
				if (_lightScatteringEnabled && _lightScatteringExposure > 0f)
				{
					shaderKeywords.Add("FOG_SCATTERING_ON");
				}
				if (_sunShadows)
				{
					sunShadowsActive = true;
					shaderKeywords.Add("FOG_SUN_SHADOWS_ON");
					UpdateSunShadowsData();
					SetupDirectionalLightCommandBuffer();
				}
			}
			if (_fogBlur)
			{
				shaderKeywords.Add("FOG_BLUR_ON");
				fogMat.SetFloat(ShaderParams.FogBlurDepth, _fogBlurDepth);
			}
			if (_useXYPlane)
			{
				shaderKeywords.Add("FOG_USE_XY_PLANE");
			}
			if (fogRenderer.computeDepth)
			{
				shaderKeywords.Add("FOG_COMPUTE_DEPTH");
			}
			fogMat.shaderKeywords = shaderKeywords.ToArray();
			if (_computeDepth && _computeDepthScope == COMPUTE_DEPTH_SCOPE.TreeBillboardsAndTransparentObjects)
			{
				Shader.SetGlobalFloat(ShaderParams.VFM_CutOff, _transparencyCutOff);
			}
		}

		public void NotifyChangesToFogInstances()
		{
			if (!hasCamera)
			{
				return;
			}
			int num = ((fogInstances != null) ? fogInstances.Count : 0);
			for (int i = 0; i < num; i++)
			{
				VolumetricFog volumetricFog = fogInstances[i];
				if (volumetricFog != null && volumetricFog != this)
				{
					volumetricFog.UpdateMaterialProperties();
				}
			}
		}

		private void UpdateSunShadowsData()
		{
			if (_sunShadows && !(_sun == null))
			{
				float num = _sunShadowsStrength * Mathf.Clamp01((0f - _sun.transform.forward.y) * 10f);
				if (num < 0f)
				{
					num = 0f;
				}
				if (num > 0f && !fogMat.IsKeywordEnabled("FOG_SUN_SHADOWS_ON"))
				{
					fogMat.EnableKeyword("FOG_SUN_SHADOWS_ON");
				}
				else if (num <= 0f && fogMat.IsKeywordEnabled("FOG_SUN_SHADOWS_ON"))
				{
					fogMat.DisableKeyword("FOG_SUN_SHADOWS_ON");
				}
				if (_hasCamera)
				{
					Shader.SetGlobalVector(ShaderParams.GlobalSunShadowsData, new Vector4(num, _sunShadowsJitterStrength, _sunShadowsCancellation, 0f));
				}
			}
		}

		private void SetupDirectionalLightCommandBuffer()
		{
			if (!(_sun == null))
			{
				Light component = _sun.GetComponent<Light>();
				if (component == null || component.type != LightType.Directional)
				{
					UnityEngine.Debug.LogError("Sun reference does not have a valid directional light.");
				}
				else if (_sun.GetComponent<ShadowMapCopy>() == null)
				{
					_sun.AddComponent<ShadowMapCopy>();
				}
			}
		}

		private void RemoveDirectionalLightCommandBuffer()
		{
			if (!(_sun == null))
			{
				ShadowMapCopy component = _sun.GetComponent<ShadowMapCopy>();
				if (component != null)
				{
					UnityEngine.Object.DestroyImmediate(component);
				}
			}
		}

		private void UpdateWindSpeedQuick()
		{
			if (!(fogMat == null))
			{
				int frameCount = Time.frameCount;
				if (!Application.isPlaying || lastFrameAppliedWind != frameCount)
				{
					lastFrameAppliedWind = frameCount;
					windSpeedAcum += _windDirection * (deltaTime * _speed);
					Vector4 value = new Vector4(windSpeedAcum.x % (float)noiseTextureSize, 0f, windSpeedAcum.z % (float)noiseTextureSize);
					fogMat.SetVector(ShaderParams.FogWindDir, value);
					skyHazeSpeedAcum += deltaTime * _skySpeed / 20f;
					Vector4 value2 = new Vector4(_skyHaze, _skyNoiseStrength / (0.0001f + _density * temporaryProperties.density), skyHazeSpeedAcum, _skyDepth);
					fogMat.SetVector(ShaderParams.FogSkyData, value2);
				}
			}
		}

		private void UpdateScatteringData(Camera mainCamera)
		{
			bool orthographic = mainCamera.orthographic;
			Vector3 position = mainCamera.transform.position + _lightDirection * (orthographic ? 100f : 1000f);
			Vector3 vector = mainCamera.WorldToViewportPoint(position, (!XRSettings.enabled) ? Camera.MonoOrStereoscopicEye.Mono : Camera.MonoOrStereoscopicEye.Left);
			if (vector.z < 0f)
			{
				if (orthographic)
				{
					vector.y = 1f - vector.y;
					vector.x = 1f - vector.x;
				}
				Vector2 vector2 = new Vector2(vector.x, vector.y);
				float num = Mathf.Clamp01(1f - _lightDirection.y);
				if (vector2 != oldSunPos)
				{
					oldSunPos = vector2;
					sunFade = Mathf.SmoothStep(1f, 0f, (vector2 - new Vector2(0.5f, 0.5f)).magnitude * 0.5f) * num;
				}
				fogMat.SetVector(ShaderParams.SunPosition, vector2);
				if (XRSettings.enabled)
				{
					Vector3 vector3 = mainCamera.WorldToViewportPoint(position, Camera.MonoOrStereoscopicEye.Right);
					fogMat.SetVector(ShaderParams.SunPositionRightEye, vector3);
				}
				if (_lightScatteringEnabled && !fogMat.IsKeywordEnabled("FOG_SCATTERING_ON"))
				{
					fogMat.EnableKeyword("FOG_SCATTERING_ON");
				}
				float num2 = _lightScatteringExposure * sunFade;
				fogMat.SetVector(ShaderParams.FogScatteringData, new Vector4(_lightScatteringSpread / (float)_lightScatteringSamples, (num2 > 0f) ? _lightScatteringSamples : 0, num2, _lightScatteringWeight / (float)_lightScatteringSamples));
				fogMat.SetVector(ShaderParams.FogScatteringData2, new Vector4(_lightScatteringIllumination, _lightScatteringDecay, _lightScatteringJittering, _lightScatteringEnabled ? (1.2f * _lightScatteringDiffusion * num * sunLightIntensity) : 0f));
				fogMat.SetVector(ShaderParams.SunDir, -_lightDirection);
				fogMat.SetColor(ShaderParams.SunColor, _lightColor);
			}
			else if (fogMat.IsKeywordEnabled("FOG_SCATTERING_ON"))
			{
				fogMat.DisableKeyword("FOG_SCATTERING_ON");
			}
		}

		private void UpdateSun()
		{
			if (fogRenderer != null && fogRenderer.sun != null)
			{
				sunLight = fogRenderer.sun.GetComponent<Light>();
			}
			else
			{
				sunLight = null;
			}
		}

		private void UpdateSkyColor(float alpha)
		{
			if (!(fogMat == null))
			{
				Color value = skyHazeLightColor;
				value.a = alpha;
				fogMat.SetColor(ShaderParams.FogSkyColor, value);
				fogMat.SetFloat(ShaderParams.FogSkyNoiseScale, 0.01f / _skyNoiseScale);
			}
		}

		private void UpdateTextureAlpha()
		{
			if (adjustedColors == null)
			{
				return;
			}
			float num = Mathf.Clamp(_noiseStrength, 0f, 0.95f);
			for (int i = 0; i < adjustedColors.Length; i++)
			{
				float num2 = 1f - (_noiseSparse + noiseColors[i].b) * num;
				num2 *= _density * temporaryProperties.density * _noiseFinalMultiplier;
				if (num2 < 0f)
				{
					num2 = 0f;
				}
				else if (num2 > 1f)
				{
					num2 = 1f;
				}
				adjustedColors[i].a = num2;
			}
			hasChangeAdjustedColorsAlpha = true;
		}

		private void UpdateTexture()
		{
			if (!(fogMat == null))
			{
				ComputeLightColor();
				if (Application.isPlaying)
				{
					updatingTextureSlice = 0;
				}
				else
				{
					updatingTextureSlice = -1;
				}
				UpdateTextureColors(adjustedColors, hasChangeAdjustedColorsAlpha);
				needUpdateTexture = false;
				UpdateSkyColor(_skyAlpha);
			}
		}

		private void ComputeLightColor()
		{
			float num = _lightIntensity + sunLightIntensity;
			if (!_useXYPlane)
			{
				num *= Mathf.Clamp01(1f - _lightDirection.y * 2f);
			}
			switch (_lightingModel)
			{
			default:
			{
				lastRenderSettingsAmbientLight = RenderSettings.ambientLight;
				lastRenderSettingsAmbientIntensity = RenderSettings.ambientIntensity;
				Color a = lastRenderSettingsAmbientLight * lastRenderSettingsAmbientIntensity;
				updatingTextureLightColor = Color.Lerp(a, currentLightColor * num, num);
				skyHazeLightColor = Color.Lerp(a, _skyColor * num, num);
				break;
			}
			case LIGHTING_MODEL.Natural:
				lastRenderSettingsAmbientLight = RenderSettings.ambientLight;
				lastRenderSettingsAmbientIntensity = RenderSettings.ambientIntensity;
				updatingTextureLightColor = Color.Lerp(lastRenderSettingsAmbientLight, currentLightColor * num + lastRenderSettingsAmbientLight, _lightIntensity);
				skyHazeLightColor = Color.Lerp(lastRenderSettingsAmbientLight, _skyColor * num + lastRenderSettingsAmbientLight, _lightIntensity);
				break;
			case LIGHTING_MODEL.SingleLight:
				lastRenderSettingsAmbientLight = Color.black;
				lastRenderSettingsAmbientIntensity = RenderSettings.ambientIntensity;
				updatingTextureLightColor = Color.Lerp(lastRenderSettingsAmbientLight, currentLightColor * num, _lightIntensity);
				skyHazeLightColor = Color.Lerp(lastRenderSettingsAmbientLight, _skyColor * num, _lightIntensity);
				break;
			}
		}

		private void UpdateTextureColors(Color[] colors, bool forceUpdateEntireTexture)
		{
			float num = 1.0001f - _specularThreshold;
			int width = adjustedTexture.width;
			Vector3 vector = new Vector3(0f - _lightDirection.x, 0f, 0f - _lightDirection.z).normalized * 0.3f;
			vector.y = ((_lightDirection.y > 0f) ? Mathf.Clamp01(1f - _lightDirection.y) : (1f - Mathf.Clamp01(0f - _lightDirection.y)));
			int num2 = (int)((float)(Mathf.FloorToInt(vector.z * (float)width) * width) + vector.x * (float)width) + colors.Length;
			float num3 = vector.y / num;
			Color obj = currentFogSpecularColor * (1f + _specularIntensity) * _specularIntensity;
			bool flag = false;
			if (updatingTextureSlice >= 1 || forceUpdateEntireTexture)
			{
				flag = true;
			}
			float num4 = updatingTextureLightColor.r * 0.5f;
			float num5 = updatingTextureLightColor.g * 0.5f;
			float num6 = updatingTextureLightColor.b * 0.5f;
			float num7 = obj.r * 0.5f;
			float num8 = obj.g * 0.5f;
			float num9 = obj.b * 0.5f;
			int num10 = colors.Length;
			int num11 = 0;
			int num12 = num10;
			if (updatingTextureSlice >= 0)
			{
				if (updatingTextureSlice > _updateTextureSpread)
				{
					updatingTextureSlice = -1;
					needUpdateTexture = true;
					return;
				}
				num11 = num10 * updatingTextureSlice / _updateTextureSpread;
				num12 = num10 * (updatingTextureSlice + 1) / _updateTextureSpread;
			}
			int num13 = 0;
			for (int i = num11; i < num12; i++)
			{
				int num14 = (i + num2) % num10;
				float num15 = (colors[i].a - colors[num14].a) * num3;
				if (num15 < 0f)
				{
					num15 = 0f;
				}
				else if (num15 > 1f)
				{
					num15 = 1f;
				}
				float num16 = num4 + num7 * num15;
				float num17 = num5 + num8 * num15;
				float num18 = num6 + num9 * num15;
				if (!flag)
				{
					if (num13++ < 100)
					{
						if (num16 != colors[i].r || num17 != colors[i].g || num18 != colors[i].b)
						{
							flag = true;
						}
					}
					else if (!flag)
					{
						break;
					}
				}
				colors[i].r = num16;
				colors[i].g = num17;
				colors[i].b = num18;
			}
			bool flag2 = forceUpdateEntireTexture;
			if (flag)
			{
				if (updatingTextureSlice >= 0)
				{
					updatingTextureSlice++;
					if (updatingTextureSlice >= _updateTextureSpread)
					{
						updatingTextureSlice = -1;
						flag2 = true;
					}
				}
				else
				{
					flag2 = true;
				}
			}
			else
			{
				updatingTextureSlice = -1;
			}
			if (flag2)
			{
				if (Application.isPlaying && _turbulenceStrength > 0f && (bool)adjustedChaosTexture)
				{
					adjustedChaosTexture.SetPixels(adjustedColors);
					adjustedChaosTexture.Apply();
				}
				else
				{
					adjustedTexture.SetPixels(adjustedColors);
					adjustedTexture.Apply();
					fogMat.SetTexture(ShaderParams.NoiseTex, adjustedTexture);
				}
				lastTextureUpdate = Time.time;
			}
		}

		internal void ApplyChaos()
		{
			int frameCount = Time.frameCount;
			if ((bool)adjustedTexture && (!Application.isPlaying || lastFrameAppliedChaos != frameCount))
			{
				lastFrameAppliedChaos = frameCount;
				turbAcum += deltaTime * _turbulenceStrength;
				chaosLerpMat.SetFloat(ShaderParams.Amount, turbAcum);
				if (!adjustedChaosTexture)
				{
					adjustedChaosTexture = UnityEngine.Object.Instantiate(adjustedTexture);
					adjustedChaosTexture.hideFlags = HideFlags.DontSave;
				}
				rtAdjusted = RenderTexture.GetTemporary(adjustedTexture.width, adjustedTexture.height, 0, RenderTextureFormat.ARGB32, RenderTextureReadWrite.Linear);
				rtAdjusted.wrapMode = TextureWrapMode.Repeat;
				Graphics.Blit(adjustedChaosTexture, rtAdjusted, chaosLerpMat);
				fogMat.SetTexture(ShaderParams.NoiseTex, rtAdjusted);
			}
		}

		private void CopyTransitionValues()
		{
			currentFogAlpha = _alpha;
			currentSkyHazeAlpha = _skyAlpha;
			currentFogColor = _color;
			currentFogSpecularColor = _specularColor;
			currentLightColor = _lightColor;
		}

		public void SetTargetProfile(VolumetricFogProfile targetProfile, float duration)
		{
			if (_useFogVolumes)
			{
				initialProfile = ScriptableObject.CreateInstance<VolumetricFogProfile>();
				initialProfile.Save(this);
				this.targetProfile = targetProfile;
				transitionDuration = duration;
				transitionStartTime = Time.time;
				transitionProfile = true;
			}
		}

		public void ClearTargetProfile(float duration)
		{
			SetTargetProfile(initialProfile, duration);
		}

		public void SetTargetAlpha(float newFogAlpha, float newSkyHazeAlpha, float duration)
		{
			if (_useFogVolumes)
			{
				initialFogAlpha = currentFogAlpha;
				initialSkyHazeAlpha = currentSkyHazeAlpha;
				targetFogAlpha = newFogAlpha;
				targetSkyHazeAlpha = newSkyHazeAlpha;
				transitionDuration = duration;
				transitionStartTime = Time.time;
				transitionAlpha = true;
			}
		}

		public void ClearTargetAlpha(float duration)
		{
			SetTargetAlpha(-1f, -1f, duration);
		}

		public void SetTargetColor(Color newColor, float duration)
		{
			if (useFogVolumes)
			{
				initialFogColor = currentFogColor;
				targetFogColor = newColor;
				transitionDuration = duration;
				transitionStartTime = Time.time;
				transitionColor = true;
				targetColorActive = true;
			}
		}

		public void ClearTargetColor(float duration)
		{
			SetTargetColor(_color, duration);
			targetColorActive = false;
		}

		public void SetTargetSpecularColor(Color newSpecularColor, float duration)
		{
			if (useFogVolumes)
			{
				initialFogSpecularColor = currentFogSpecularColor;
				targetFogSpecularColor = newSpecularColor;
				transitionDuration = duration;
				transitionStartTime = Time.time;
				transitionSpecularColor = true;
				targetSpecularColorActive = true;
			}
		}

		public void ClearTargetSpecularColor(float duration)
		{
			SetTargetSpecularColor(_specularColor, duration);
			targetSpecularColorActive = false;
		}

		public void SetTargetLightColor(Color newLightColor, float duration)
		{
			if (useFogVolumes)
			{
				_sunCopyColor = false;
				initialLightColor = currentLightColor;
				targetLightColor = newLightColor;
				transitionDuration = duration;
				transitionStartTime = Time.time;
				transitionLightColor = true;
				targetLightColorActive = true;
			}
		}

		public void ClearTargetLightColor(float duration)
		{
			SetTargetLightColor(_lightColor, duration);
			targetLightColorActive = false;
		}

		public void CheckPointLightData()
		{
			if (_pointLightTrackingPivot == null)
			{
				_pointLightTrackingPivot = base.transform;
			}
			if (!pointLightDataMigrated)
			{
				pointLightParams = new PointLightParams[6];
				for (int i = 0; i < _pointLightColors.Length; i++)
				{
					pointLightParams[i].color = _pointLightColors[i];
					Light light = null;
					if (_pointLights[i] != null)
					{
						light = _pointLights[i].GetComponent<Light>();
					}
					pointLightParams[i].light = light;
					pointLightParams[i].intensity = _pointLightIntensities[i];
					pointLightParams[i].intensityMultiplier = _pointLightIntensitiesMultiplier[i];
					pointLightParams[i].position = _pointLightPositions[i];
					pointLightParams[i].range = _pointLightRanges[i];
					pointLightParams[i].rangeMultiplier = 1f;
				}
				for (int j = _pointLightColors.Length; j < 6; j++)
				{
					PointLightDataSetDefaults(j);
				}
				pointLightDataMigrated = true;
				isDirty = true;
			}
			if (_pointLightTrackingCount > 6)
			{
				_pointLightTrackingCount = 6;
				isDirty = true;
			}
			if (pointLightParams != null)
			{
				if (pointLightParams.Length != 6)
				{
					PointLightParams[] array = new PointLightParams[6];
					int num = Mathf.Min(array.Length, pointLightParams.Length);
					Array.Copy(pointLightParams, array, num);
					pointLightParams = array;
					for (int k = num; k < array.Length; k++)
					{
						PointLightDataSetDefaults(k);
					}
					isDirty = true;
				}
				for (int l = 0; l < pointLightParams.Length; l++)
				{
					if (pointLightParams[l].rangeMultiplier <= 0f)
					{
						pointLightParams[l].rangeMultiplier = 1f;
					}
				}
			}
			else
			{
				pointLightParams = new PointLightParams[6];
				for (int m = 0; m < pointLightParams.Length; m++)
				{
					PointLightDataSetDefaults(m);
				}
				isDirty = true;
			}
			if (currentLights == null || currentLights.Length != 6)
			{
				currentLights = new Light[6];
			}
		}

		private void PointLightDataSetDefaults(int k)
		{
			if (k < pointLightParams.Length)
			{
				pointLightParams[k].color = new Color(1f, 1f, 0f, 1f);
				pointLightParams[k].intensity = 1f;
				pointLightParams[k].intensityMultiplier = 1f;
				pointLightParams[k].range = 0f;
				pointLightParams[k].rangeMultiplier = 1f;
			}
		}

		private void SetPointLightMaterialProperties(Camera mainCamera)
		{
			int num = pointLightParams.Length;
			if (pointLightColorBuffer == null || pointLightColorBuffer.Length != num)
			{
				pointLightColorBuffer = new Vector4[num];
			}
			if (pointLightPositionBuffer == null || pointLightPositionBuffer.Length != num)
			{
				pointLightPositionBuffer = new Vector4[num];
			}
			Vector3 vector = ((mainCamera != null) ? mainCamera.transform.position : Vector3.zero);
			for (int i = 0; i < num; i++)
			{
				Vector3 position = pointLightParams[i].position;
				if (!sunShadowsActive)
				{
					position.y -= _baselineHeight;
				}
				float num2 = pointLightParams[i].range * pointLightParams[i].rangeMultiplier * _pointLightInscattering / 25f;
				float num3 = pointLightParams[i].intensity * pointLightParams[i].intensityMultiplier * _pointLightIntensity;
				if (num2 > 0f && num3 > 0f)
				{
					if (_distance > 0f)
					{
						float num4 = 0.01f / _noiseScale;
						float num5 = _distance * num4;
						float num6 = Mathf.Max(num5 * num5 - new Vector2((vector.x - position.x) * num4, (vector.z - position.z) * num4).sqrMagnitude, 0f);
						num6 *= _distanceFallOff * _distanceFallOff + 0.1f;
						num3 = ((num3 > num6) ? (num3 - num6) : 0f);
					}
					pointLightPositionBuffer[i].x = position.x;
					pointLightPositionBuffer[i].y = position.y;
					pointLightPositionBuffer[i].z = position.z;
					pointLightPositionBuffer[i].w = 0f;
					pointLightColorBuffer[i] = new Vector4(pointLightParams[i].color.r * num3, pointLightParams[i].color.g * num3, pointLightParams[i].color.b * num3, num2);
				}
				else
				{
					pointLightColorBuffer[i] = black;
				}
			}
			fogMat.SetVectorArray(ShaderParams.FogPointLightColor, pointLightColorBuffer);
			fogMat.SetVectorArray(ShaderParams.FogPointLightPosition, pointLightPositionBuffer);
		}

		public Light GetPointLight(int index)
		{
			if (index < 0 || index >= pointLightParams.Length)
			{
				return null;
			}
			return pointLightParams[index].light;
		}

		private void TrackNewLights()
		{
			lastFoundLights = UnityEngine.Object.FindObjectsOfType<Light>();
		}

		public void TrackPointLights(bool forceImmediateUpdate = false)
		{
			if (!_pointLightTrackingAuto)
			{
				return;
			}
			if (_pointLightTrackingPivot == null)
			{
				_pointLightTrackingPivot = base.transform;
			}
			if (forceImmediateUpdate || lastFoundLights == null || !Application.isPlaying || (_pointLightTrackingNewLightsCheckInterval > 0f && Time.time - trackPointCheckNewLightsLastTime > _pointLightTrackingNewLightsCheckInterval))
			{
				trackPointCheckNewLightsLastTime = Time.time;
				TrackNewLights();
			}
			int num = lastFoundLights.Length;
			if (lightBuffer == null || lightBuffer.Length != num)
			{
				lightBuffer = new Light[num];
			}
			for (int i = 0; i < num; i++)
			{
				lightBuffer[i] = lastFoundLights[i];
			}
			bool flag = false;
			for (int j = 0; j < pointLightParams.Length && j < currentLights.Length; j++)
			{
				Light light = null;
				if (j < _pointLightTrackingCount)
				{
					light = GetNearestLight(lightBuffer);
				}
				if (pointLightParams[j].light != light)
				{
					pointLightParams[j].light = light;
					pointLightParams[j].lightParams = null;
				}
				if (pointLightParams[j].range != 0f && light == null)
				{
					pointLightParams[j].range = 0f;
				}
				if (currentLights[j] != light)
				{
					currentLights[j] = light;
					flag = true;
				}
			}
			if (flag)
			{
				UpdateMaterialProperties();
			}
		}

		private Light GetNearestLight(Light[] lights)
		{
			float num = float.MaxValue;
			Vector3 position = _pointLightTrackingPivot.position;
			Light result = null;
			int num2 = -1;
			for (int i = 0; i < lights.Length; i++)
			{
				Light light = lights[i];
				if (!(light == null) && light.isActiveAndEnabled && light.type == LightType.Point)
				{
					float sqrMagnitude = (light.transform.position - position).sqrMagnitude;
					if (sqrMagnitude < num)
					{
						result = light;
						num = sqrMagnitude;
						num2 = i;
					}
				}
			}
			if (num2 >= 0)
			{
				lights[num2] = null;
			}
			return result;
		}

		public static VolumetricFog CreateFogArea(Vector3 position, float radius, float height = 16f, float fallOff = 1f)
		{
			VolumetricFog volumetricFog = CreateFogAreaPlaceholder(spherical: true, position, radius, height, radius);
			volumetricFog.preset = FOG_PRESET.SeaClouds;
			volumetricFog.transform.position = position;
			volumetricFog.skyHaze = 0f;
			volumetricFog.dithering = true;
			return volumetricFog;
		}

		public static VolumetricFog CreateFogArea(Vector3 position, Vector3 boxSize)
		{
			VolumetricFog volumetricFog = CreateFogAreaPlaceholder(spherical: false, position, boxSize.x * 0.5f, boxSize.y * 0.5f, boxSize.z * 0.5f);
			volumetricFog.preset = FOG_PRESET.SeaClouds;
			volumetricFog.transform.position = position;
			volumetricFog.height = boxSize.y * 0.98f;
			volumetricFog.skyHaze = 0f;
			return volumetricFog;
		}

		private static VolumetricFog CreateFogAreaPlaceholder(bool spherical, Vector3 position, float radius, float height, float depth)
		{
			GameObject obj = UnityEngine.Object.Instantiate(spherical ? Resources.Load<GameObject>("Prefabs/FogSphereArea") : Resources.Load<GameObject>("Prefabs/FogBoxArea"));
			obj.transform.position = position;
			obj.transform.localScale = new Vector3(radius, height, depth);
			return obj.GetComponent<VolumetricFog>();
		}

		public static void RemoveAllFogAreas()
		{
			VolumetricFog[] array = UnityEngine.Object.FindObjectsOfType<VolumetricFog>();
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i] != null && !array[i].hasCamera)
				{
					UnityEngine.Object.DestroyImmediate(array[i].gameObject);
				}
			}
		}

		private void CheckFogAreaDimensions()
		{
			if (!_hasCamera && mr == null)
			{
				mr = GetComponent<MeshRenderer>();
			}
			if (mr == null)
			{
				return;
			}
			Vector3 extents = mr.bounds.extents;
			switch (_fogAreaTopology)
			{
			case FOG_AREA_TOPOLOGY.Box:
				fogAreaRadius = extents.x;
				fogAreaHeight = extents.y;
				fogAreaDepth = extents.z;
				break;
			case FOG_AREA_TOPOLOGY.Sphere:
				fogAreaRadius = extents.x;
				if (base.transform.localScale.z != base.transform.localScale.x)
				{
					base.transform.localScale = new Vector3(base.transform.localScale.x, base.transform.localScale.y, base.transform.localScale.x);
				}
				break;
			}
			if (_fogAreaCenter != null)
			{
				if (_fogAreaFollowMode == FOG_AREA_FOLLOW_MODE.FullXYZ)
				{
					base.transform.position = _fogAreaCenter.transform.position;
				}
				else
				{
					base.transform.position = new Vector3(_fogAreaCenter.transform.position.x, base.transform.position.y, _fogAreaCenter.transform.position.z);
				}
			}
			fogAreaPosition = base.transform.position;
		}

		public void UpdateVolumeMask()
		{
			if (!_hasCamera || mainCamera == null)
			{
				return;
			}
			RemoveMaskCommandBuffer();
			if (!_enableMask)
			{
				return;
			}
			if (maskCommandBuffer != null)
			{
				maskCommandBuffer.Clear();
			}
			else
			{
				maskCommandBuffer = new CommandBuffer();
				maskCommandBuffer.name = "Volumetric Fog Mask Write";
			}
			if (maskMaterial == null)
			{
				maskMaterial = new Material(Shader.Find("VolumetricFogAndMist/MaskWrite"));
			}
			if (XRSettings.enabled)
			{
				rtMaskDesc = XRSettings.eyeTextureDesc;
			}
			else
			{
				rtMaskDesc = new RenderTextureDescriptor(mainCamera.pixelWidth, mainCamera.pixelHeight);
			}
			rtMaskDesc.colorFormat = RenderTextureFormat.Depth;
			rtMaskDesc.depthBufferBits = 24;
			rtMaskDesc.sRGB = false;
			rtMaskDesc.msaaSamples = 1;
			rtMaskDesc.useMipMap = false;
			rtMaskDesc.volumeDepth = 1;
			int num = Mathf.Max(1, _maskDownsampling);
			rtMaskDesc.width /= num;
			rtMaskDesc.height /= num;
			maskCommandBuffer.GetTemporaryRT(ShaderParams.ScreenMaskTexture, rtMaskDesc);
			maskCommandBuffer.SetRenderTarget(ShaderParams.ScreenMaskTexture);
			maskCommandBuffer.ClearRenderTarget(clearDepth: true, clearColor: false, Color.white);
			Renderer[] array = UnityEngine.Object.FindObjectsOfType<Renderer>();
			for (int i = 0; i < array.Length; i++)
			{
				if (((1 << array[i].gameObject.layer) & _maskLayer.value) != 0 && array[i].gameObject.activeSelf)
				{
					if (array[i].enabled && Application.isPlaying)
					{
						array[i].enabled = false;
					}
					maskCommandBuffer.DrawRenderer(array[i], maskMaterial);
				}
			}
			maskCommandBuffer.ReleaseTemporaryRT(ShaderParams.ScreenMaskTexture);
			mainCamera.AddCommandBuffer(CameraEvent.BeforeImageEffectsOpaque, maskCommandBuffer);
		}

		public void TogglePreviewMask()
		{
			Renderer[] array = UnityEngine.Object.FindObjectsOfType<Renderer>();
			for (int i = 0; i < array.Length; i++)
			{
				if (((1 << array[i].gameObject.layer) & _maskLayer.value) != 0 && array[i].gameObject.activeSelf)
				{
					array[i].enabled = !array[i].enabled;
				}
			}
		}

		private void RemoveMaskCommandBuffer()
		{
			if (maskCommandBuffer != null && mainCamera != null)
			{
				mainCamera.RemoveCommandBuffer(CameraEvent.BeforeImageEffectsOpaque, maskCommandBuffer);
			}
		}

		private void FogOfWarInit()
		{
			if (fowTransitionList == null || fowTransitionList.Length != 10000)
			{
				fowTransitionList = new FogOfWarTransition[10000];
			}
			if (fowTransitionIndices == null)
			{
				fowTransitionIndices = new Dictionary<int, int>(10000);
			}
			else
			{
				fowTransitionIndices.Clear();
			}
			lastTransitionPos = -1;
			if (_fogOfWarTexture == null)
			{
				FogOfWarUpdateTexture();
			}
			else if (_fogOfWarEnabled && (fogOfWarColorBuffer == null || fogOfWarColorBuffer.Length == 0))
			{
				ReloadFogOfWarTexture();
			}
		}

		private void FogOfWarDestroy()
		{
			if (canDestroyFOWTexture && _fogOfWarTexture != null)
			{
				UnityEngine.Object.DestroyImmediate(_fogOfWarTexture);
			}
			if (fowBlur1 != null)
			{
				fowBlur1.Release();
			}
			if (fowBlur2 != null)
			{
				fowBlur2.Release();
			}
		}

		public void ReloadFogOfWarTexture()
		{
			if (!(_fogOfWarTexture == null))
			{
				_fogOfWarTextureSize = _fogOfWarTexture.width;
				fogOfWarColorBuffer = _fogOfWarTexture.GetPixels32();
				lastTransitionPos = -1;
				fowTransitionIndices.Clear();
				isDirty = true;
				fogOfWarEnabled = true;
			}
		}

		private void FogOfWarUpdateTexture()
		{
			if (_fogOfWarEnabled && Application.isPlaying)
			{
				int scaledSize = GetScaledSize(_fogOfWarTextureSize, 1f);
				if (_fogOfWarTexture == null || _fogOfWarTexture.width != scaledSize || _fogOfWarTexture.height != scaledSize)
				{
					_fogOfWarTexture = new Texture2D(scaledSize, scaledSize, TextureFormat.Alpha8, mipChain: false);
					_fogOfWarTexture.hideFlags = HideFlags.DontSave;
					_fogOfWarTexture.filterMode = FilterMode.Bilinear;
					_fogOfWarTexture.wrapMode = TextureWrapMode.Clamp;
					canDestroyFOWTexture = true;
					ResetFogOfWar();
				}
			}
		}

		public void UpdateFogOfWar(bool forceUpload = false)
		{
			if (!_fogOfWarEnabled || _fogOfWarTexture == null)
			{
				return;
			}
			if (forceUpload)
			{
				requiresTextureUpload = true;
			}
			int width = _fogOfWarTexture.width;
			for (int i = 0; i <= lastTransitionPos; i++)
			{
				FogOfWarTransition fogOfWarTransition = fowTransitionList[i];
				if (!fogOfWarTransition.enabled)
				{
					continue;
				}
				float num = Time.time - fogOfWarTransition.startTime - fogOfWarTransition.startDelay;
				if (!(num > 0f))
				{
					continue;
				}
				float num2 = ((fogOfWarTransition.duration <= 0f) ? 1f : (num / fogOfWarTransition.duration));
				if (num2 < 0f)
				{
					num2 = 0f;
				}
				else if (num2 > 1f)
				{
					num2 = 1f;
				}
				int num3 = (int)((float)fogOfWarTransition.initialAlpha + (float)(fogOfWarTransition.targetAlpha - fogOfWarTransition.initialAlpha) * num2);
				int num4 = fogOfWarTransition.y * width + fogOfWarTransition.x;
				fogOfWarColorBuffer[num4].a = (byte)num3;
				requiresTextureUpload = true;
				if (num2 >= 1f)
				{
					fowTransitionList[i].enabled = false;
					if (fogOfWarTransition.targetAlpha < 255 && _fogOfWarRestoreDelay > 0f)
					{
						AddFogOfWarTransitionSlot(fogOfWarTransition.x, fogOfWarTransition.y, (byte)fogOfWarTransition.targetAlpha, byte.MaxValue, _fogOfWarRestoreDelay, _fogOfWarRestoreDuration);
					}
				}
			}
			if (requiresTextureUpload)
			{
				requiresTextureUpload = false;
				_fogOfWarTexture.SetPixels32(fogOfWarColorBuffer);
				_fogOfWarTexture.Apply();
				if (_fogOfWarBlur)
				{
					SetFowBlurTexture();
				}
			}
		}

		private void SetFowBlurTexture()
		{
			if (fowBlur == null)
			{
				fowBlur = new Material(Shader.Find("VolumetricFogAndMist/FoWBlur"));
				fowBlur.hideFlags = HideFlags.DontSave;
			}
			if (!(fowBlur == null))
			{
				if (fowBlur1 == null || fowBlur1.width != _fogOfWarTexture.width || fowBlur2 == null || fowBlur2.width != _fogOfWarTexture.width)
				{
					CreateFoWBlurRTs();
				}
				fowBlur1.DiscardContents();
				Graphics.Blit(_fogOfWarTexture, fowBlur1, fowBlur, 0);
				fowBlur2.DiscardContents();
				Graphics.Blit(fowBlur1, fowBlur2, fowBlur, 1);
				fogMat.SetTexture("_FogOfWar", fowBlur2);
			}
		}

		private void CreateFoWBlurRTs()
		{
			if (fowBlur1 != null)
			{
				fowBlur1.Release();
			}
			if (fowBlur2 != null)
			{
				fowBlur2.Release();
			}
			RenderTextureDescriptor desc = new RenderTextureDescriptor(_fogOfWarTexture.width, _fogOfWarTexture.height, RenderTextureFormat.ARGB32, 0);
			fowBlur1 = new RenderTexture(desc);
			fowBlur2 = new RenderTexture(desc);
		}

		public void SetFogOfWarAlpha(Vector3 worldPosition, float radius, float fogNewAlpha)
		{
			SetFogOfWarAlpha(worldPosition, radius, fogNewAlpha, 1f);
		}

		public void SetFogOfWarAlpha(Vector3 worldPosition, float radius, float fogNewAlpha, float duration)
		{
			SetFogOfWarAlpha(worldPosition, radius, fogNewAlpha, blendAlpha: true, duration, _fogOfWarSmoothness, _fogOfWarRestoreDelay, _fogOfWarRestoreDuration);
		}

		public void SetFogOfWarAlpha(Vector3 worldPosition, float radius, float fogNewAlpha, float duration, float smoothness)
		{
			SetFogOfWarAlpha(worldPosition, radius, fogNewAlpha, blendAlpha: true, duration, smoothness, _fogOfWarRestoreDelay, _fogOfWarRestoreDuration);
		}

		public void SetFogOfWarAlpha(Vector3 worldPosition, float radius, float fogNewAlpha, bool blendAlpha, float duration, float smoothness, float restoreDelay, float restoreDuration)
		{
			if (_fogOfWarTexture == null || fogOfWarColorBuffer == null || fogOfWarColorBuffer.Length == 0)
			{
				return;
			}
			float num = (worldPosition.x - _fogOfWarCenter.x) / _fogOfWarSize.x + 0.5f;
			if (num < 0f || num > 1f)
			{
				return;
			}
			float num2 = (worldPosition.z - _fogOfWarCenter.z) / _fogOfWarSize.z + 0.5f;
			if (num2 < 0f || num2 > 1f)
			{
				return;
			}
			int width = _fogOfWarTexture.width;
			int num3 = _fogOfWarTexture.height;
			int num4 = (int)(num * (float)width);
			int num5 = (int)(num2 * (float)num3);
			float num6 = 0.0001f + smoothness;
			int num7 = num5 * width + num4;
			byte b = (byte)(fogNewAlpha * 255f);
			float num8 = radius / _fogOfWarSize.z;
			int num9 = (int)((float)num3 * num8);
			int num10 = num9 * num9;
			for (int i = num5 - num9; i <= num5 + num9; i++)
			{
				if (i <= 0 || i >= num3 - 1)
				{
					continue;
				}
				for (int j = num4 - num9; j <= num4 + num9; j++)
				{
					if (j <= 0 || j >= width - 1)
					{
						continue;
					}
					int num11 = (num5 - i) * (num5 - i) + (num4 - j) * (num4 - j);
					if (num11 > num10)
					{
						continue;
					}
					num7 = i * width + j;
					Color32 color = fogOfWarColorBuffer[num7];
					if (!blendAlpha)
					{
						color.a = byte.MaxValue;
					}
					num11 = num10 - num11;
					float num12 = (float)num11 / ((float)num10 * num6);
					num12 = 1f - num12;
					if (num12 < 0f)
					{
						num12 = 0f;
					}
					else if (num12 > 1f)
					{
						num12 = 1f;
					}
					byte b2 = (byte)((float)(int)b + (float)(color.a - b) * num12);
					if (b2 >= byte.MaxValue)
					{
						continue;
					}
					if (duration > 0f)
					{
						AddFogOfWarTransitionSlot(j, i, color.a, b2, 0f, duration);
						continue;
					}
					color.a = b2;
					fogOfWarColorBuffer[num7] = color;
					requiresTextureUpload = true;
					if (restoreDelay > 0f)
					{
						AddFogOfWarTransitionSlot(j, i, b2, byte.MaxValue, restoreDelay, restoreDuration);
					}
				}
			}
		}

		public void SetFogOfWarAlpha(Bounds bounds, float fogNewAlpha, float duration)
		{
			SetFogOfWarAlpha(bounds, fogNewAlpha, blendAlpha: true, duration, _fogOfWarSmoothness, _fogOfWarRestoreDelay, _fogOfWarRestoreDuration);
		}

		public void SetFogOfWarAlpha(Bounds bounds, float fogNewAlpha, float duration, float smoothness)
		{
			SetFogOfWarAlpha(bounds, fogNewAlpha, blendAlpha: true, duration, smoothness, _fogOfWarRestoreDelay, _fogOfWarRestoreDuration);
		}

		public void SetFogOfWarAlpha(Bounds bounds, float fogNewAlpha, bool blendAlpha, float duration, float smoothness, float restoreDelay, float restoreDuration)
		{
			if (_fogOfWarTexture == null || fogOfWarColorBuffer == null || fogOfWarColorBuffer.Length == 0)
			{
				return;
			}
			Vector3 center = bounds.center;
			float num = (center.x - _fogOfWarCenter.x) / _fogOfWarSize.x + 0.5f;
			if (num < 0f || num > 1f)
			{
				return;
			}
			float num2 = (center.z - _fogOfWarCenter.z) / _fogOfWarSize.z + 0.5f;
			if (num2 < 0f || num2 > 1f)
			{
				return;
			}
			int width = _fogOfWarTexture.width;
			int num3 = _fogOfWarTexture.height;
			int num4 = (int)(num * (float)width);
			int num5 = (int)(num2 * (float)num3);
			int num6 = num5 * width + num4;
			byte b = (byte)(fogNewAlpha * 255f);
			float num7 = bounds.extents.z / _fogOfWarSize.z;
			float num8 = bounds.extents.x / _fogOfWarSize.x;
			float num9 = ((num8 > num7) ? 1f : (num7 / num8));
			float num10 = ((num8 > num7) ? (num8 / num7) : 1f);
			int num11 = (int)((float)num3 * num7);
			int num12 = num11 * num11;
			int num13 = (int)((float)width * num8);
			int num14 = num13 * num13;
			float num15 = 0.0001f + smoothness;
			for (int i = num5 - num11; i <= num5 + num11; i++)
			{
				if (i <= 0 || i >= num3 - 1)
				{
					continue;
				}
				int num16 = (num5 - i) * (num5 - i);
				num16 = num12 - num16;
				float num17 = (float)num16 * num9 / ((float)num12 * num15);
				for (int j = num4 - num13; j <= num4 + num13; j++)
				{
					if (j <= 0 || j >= width - 1)
					{
						continue;
					}
					int num18 = (num4 - j) * (num4 - j);
					num6 = i * width + j;
					Color32 color = fogOfWarColorBuffer[num6];
					if (!blendAlpha)
					{
						color.a = byte.MaxValue;
					}
					num18 = num14 - num18;
					float num19 = (float)num18 * num10 / ((float)num14 * num15);
					float num20 = ((num17 < num19) ? num17 : num19);
					num20 = 1f - num20;
					if (num20 < 0f)
					{
						num20 = 0f;
					}
					else if (num20 > 1f)
					{
						num20 = 1f;
					}
					byte b2 = (byte)((float)(int)b + (float)(color.a - b) * num20);
					if (b2 >= byte.MaxValue)
					{
						continue;
					}
					if (duration > 0f)
					{
						AddFogOfWarTransitionSlot(j, i, color.a, b2, 0f, duration);
						continue;
					}
					color.a = b2;
					fogOfWarColorBuffer[num6] = color;
					requiresTextureUpload = true;
					if (restoreDelay > 0f)
					{
						AddFogOfWarTransitionSlot(j, i, b2, byte.MaxValue, restoreDelay, restoreDuration);
					}
				}
			}
		}

		public void ResetFogOfWarAlpha(Vector3 worldPosition, float radius)
		{
			if (_fogOfWarTexture == null || fogOfWarColorBuffer == null || fogOfWarColorBuffer.Length == 0)
			{
				return;
			}
			float num = (worldPosition.x - _fogOfWarCenter.x) / _fogOfWarSize.x + 0.5f;
			if (num < 0f || num > 1f)
			{
				return;
			}
			float num2 = (worldPosition.z - _fogOfWarCenter.z) / _fogOfWarSize.z + 0.5f;
			if (num2 < 0f || num2 > 1f)
			{
				return;
			}
			int width = _fogOfWarTexture.width;
			int num3 = _fogOfWarTexture.height;
			int num4 = (int)(num * (float)width);
			int num5 = (int)(num2 * (float)num3);
			float num6 = radius / _fogOfWarSize.z;
			int num7 = (int)((float)num3 * num6);
			int num8 = num7 * num7;
			for (int i = num5 - num7; i <= num5 + num7; i++)
			{
				if (i <= 0 || i >= num3 - 1)
				{
					continue;
				}
				for (int j = num4 - num7; j <= num4 + num7; j++)
				{
					if (j > 0 && j < width - 1 && (num5 - i) * (num5 - i) + (num4 - j) * (num4 - j) <= num8)
					{
						int num9 = i * width + j;
						Color32 color = fogOfWarColorBuffer[num9];
						color.a = byte.MaxValue;
						fogOfWarColorBuffer[num9] = color;
						requiresTextureUpload = true;
					}
				}
			}
		}

		public void ResetFogOfWarAlpha(Bounds bounds)
		{
			ResetFogOfWarAlpha(bounds.center, bounds.extents.x, bounds.extents.z);
		}

		public void ResetFogOfWarAlpha(Vector3 position, Vector3 size)
		{
			ResetFogOfWarAlpha(position, size.x * 0.5f, size.z * 0.5f);
		}

		public void ResetFogOfWarAlpha(Vector3 position, float extentsX, float extentsZ)
		{
			if (_fogOfWarTexture == null || fogOfWarColorBuffer == null || fogOfWarColorBuffer.Length == 0)
			{
				return;
			}
			float num = (position.x - _fogOfWarCenter.x) / _fogOfWarSize.x + 0.5f;
			if (num < 0f || num > 1f)
			{
				return;
			}
			float num2 = (position.z - _fogOfWarCenter.z) / _fogOfWarSize.z + 0.5f;
			if (num2 < 0f || num2 > 1f)
			{
				return;
			}
			int width = _fogOfWarTexture.width;
			int num3 = _fogOfWarTexture.height;
			int num4 = (int)(num * (float)width);
			int num5 = (int)(num2 * (float)num3);
			float num6 = extentsZ / _fogOfWarSize.z;
			float num7 = extentsX / _fogOfWarSize.x;
			int num8 = (int)((float)num3 * num6);
			int num9 = (int)((float)width * num7);
			for (int i = num5 - num8; i <= num5 + num8; i++)
			{
				if (i <= 0 || i >= num3 - 1)
				{
					continue;
				}
				for (int j = num4 - num9; j <= num4 + num9; j++)
				{
					if (j > 0 && j < width - 1)
					{
						int num10 = i * width + j;
						Color32 color = fogOfWarColorBuffer[num10];
						color.a = byte.MaxValue;
						fogOfWarColorBuffer[num10] = color;
						requiresTextureUpload = true;
					}
				}
			}
		}

		public void ResetFogOfWar(byte alpha = byte.MaxValue)
		{
			if (!(_fogOfWarTexture == null) && isPartOfScene)
			{
				int num = _fogOfWarTexture.height;
				int width = _fogOfWarTexture.width;
				int num2 = num * width;
				if (fogOfWarColorBuffer == null || fogOfWarColorBuffer.Length != num2)
				{
					fogOfWarColorBuffer = new Color32[num2];
				}
				Color32 color = new Color32(alpha, alpha, alpha, alpha);
				for (int i = 0; i < num2; i++)
				{
					fogOfWarColorBuffer[i] = color;
				}
				_fogOfWarTexture.SetPixels32(fogOfWarColorBuffer);
				_fogOfWarTexture.Apply();
				lastTransitionPos = -1;
				fowTransitionIndices.Clear();
				isDirty = true;
			}
		}

		private void AddFogOfWarTransitionSlot(int x, int y, byte initialAlpha, byte targetAlpha, float delay, float duration)
		{
			int key = y * 64000 + x;
			if (!fowTransitionIndices.TryGetValue(key, out var value))
			{
				value = -1;
				for (int i = 0; i <= lastTransitionPos; i++)
				{
					if (!fowTransitionList[i].enabled)
					{
						value = i;
						fowTransitionIndices[key] = value;
						break;
					}
				}
			}
			if (value >= 0 && fowTransitionList[value].enabled && (fowTransitionList[value].x != x || fowTransitionList[value].y != y))
			{
				value = -1;
			}
			if (value < 0)
			{
				if (lastTransitionPos >= 9999)
				{
					return;
				}
				value = ++lastTransitionPos;
				fowTransitionIndices[key] = value;
			}
			fowTransitionList[value].x = x;
			fowTransitionList[value].y = y;
			fowTransitionList[value].duration = duration;
			fowTransitionList[value].startTime = Time.time;
			fowTransitionList[value].startDelay = delay;
			fowTransitionList[value].initialAlpha = initialAlpha;
			fowTransitionList[value].targetAlpha = targetAlpha;
			fowTransitionList[value].enabled = true;
		}

		public float GetFogOfWarAlpha(Vector3 worldPosition)
		{
			if (fogOfWarColorBuffer == null || fogOfWarColorBuffer.Length == 0 || _fogOfWarTexture == null)
			{
				return 1f;
			}
			float num = (worldPosition.x - _fogOfWarCenter.x) / _fogOfWarSize.x + 0.5f;
			if (num < 0f || num > 1f)
			{
				return 1f;
			}
			float num2 = (worldPosition.z - _fogOfWarCenter.z) / _fogOfWarSize.z + 0.5f;
			if (num2 < 0f || num2 > 1f)
			{
				return 1f;
			}
			int width = _fogOfWarTexture.width;
			int num3 = _fogOfWarTexture.height;
			int num4 = (int)(num * (float)width);
			int num5 = (int)(num2 * (float)num3) * width + num4;
			if (num5 < 0 || num5 >= fogOfWarColorBuffer.Length)
			{
				return 1f;
			}
			return (float)(int)fogOfWarColorBuffer[num5].a / 255f;
		}

		private void ShowFoWGizmo()
		{
			if (_maskEditorEnabled && _fogOfWarEnabled && !Application.isPlaying)
			{
				Vector3 center = _fogOfWarCenter;
				center.y = -10f;
				center.y += _baselineHeight + _height * 0.5f;
				Vector3 size = new Vector3(_fogOfWarSize.x, 0.1f, _fogOfWarSize.z);
				for (int i = 0; i < 5; i++)
				{
					Gizmos.color = Color.yellow;
					Gizmos.DrawWireCube(center, size);
					center.y += 0.5f;
					Gizmos.color = Color.white;
					Gizmos.DrawWireCube(center, size);
					center.y += 0.5f;
				}
			}
		}
	}
	[ExecuteInEditMode]
	public class VolumetricFogDayCycleManager : MonoBehaviour
	{
		[Range(0f, 24f)]
		public float currentTime;

		public Gradient colorOverTime;

		public AnimationCurve densityOverTime;

		private int prevTime;

		private VolumetricFog[] fogs;

		private void OnEnable()
		{
			fogs = UnityEngine.Object.FindObjectsOfType<VolumetricFog>();
			if (colorOverTime == null)
			{
				colorOverTime = new Gradient();
				GradientColorKey[] array = new GradientColorKey[2];
				array[0].color = Color.white;
				array[0].time = 0f;
				array[1].color = Color.white;
				array[1].time = 1f;
				colorOverTime.colorKeys = array;
				GradientAlphaKey[] array2 = new GradientAlphaKey[2];
				array2[0].alpha = 1f;
				array2[0].time = 0f;
				array2[1].alpha = 1f;
				array2[1].time = 1f;
				colorOverTime.alphaKeys = array2;
			}
			if (densityOverTime == null)
			{
				densityOverTime = new AnimationCurve();
				densityOverTime.AddKey(0f, 1f);
				densityOverTime.AddKey(24f, 1f);
			}
		}

		private void Update()
		{
			currentTime = GetCurrentTime();
			int num = (int)(currentTime * 60f);
			if (num == prevTime && Application.isPlaying)
			{
				return;
			}
			prevTime = num;
			Color color = colorOverTime.Evaluate(currentTime / 24f);
			float num2 = densityOverTime.Evaluate(currentTime);
			for (int i = 0; i < fogs.Length; i++)
			{
				bool flag = false;
				if (!(fogs[i] == null))
				{
					if (fogs[i].temporaryProperties.color != color)
					{
						fogs[i].color = color;
						flag = true;
					}
					if (fogs[i].temporaryProperties.density != num2)
					{
						fogs[i].density = num2;
						flag = true;
					}
					if (flag)
					{
						fogs[i].UpdateMaterialProperties();
					}
				}
			}
		}

		private float GetCurrentTime()
		{
			return currentTime;
		}
	}
	public enum MASK_TEXTURE_BRUSH_MODE
	{
		AddFog,
		RemoveFog
	}
	public class VolumetricFogLightParams : MonoBehaviour
	{
		public float rangeMultiplier = 1f;

		public float intensityMultiplier = 1f;
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(VolumetricFog))]
	public class VolumetricFogMaterialIntegration : MonoBehaviour
	{
		private enum PropertyType
		{
			Float,
			Float3,
			Float4,
			Color,
			Texture2D,
			FloatArray,
			Float4Array,
			ColorArray,
			Matrix4x4
		}

		private struct Properties
		{
			public string name;

			public PropertyType type;
		}

		private static Properties[] props = new Properties[29]
		{
			new Properties
			{
				name = "_NoiseTex",
				type = PropertyType.Texture2D
			},
			new Properties
			{
				name = "_FogAlpha",
				type = PropertyType.Float
			},
			new Properties
			{
				name = "_FogColor",
				type = PropertyType.Color
			},
			new Properties
			{
				name = "_FogDistance",
				type = PropertyType.Float4
			},
			new Properties
			{
				name = "_FogData",
				type = PropertyType.Float4
			},
			new Properties
			{
				name = "_FogWindDir",
				type = PropertyType.Float3
			},
			new Properties
			{
				name = "_FogStepping",
				type = PropertyType.Float4
			},
			new Properties
			{
				name = "_BlurTex",
				type = PropertyType.Texture2D
			},
			new Properties
			{
				name = "_FogVoidPosition",
				type = PropertyType.Float3
			},
			new Properties
			{
				name = "_FogVoidData",
				type = PropertyType.Float4
			},
			new Properties
			{
				name = "_FogAreaPosition",
				type = PropertyType.Float3
			},
			new Properties
			{
				name = "_FogAreaData",
				type = PropertyType.Float4
			},
			new Properties
			{
				name = "_FogOfWar",
				type = PropertyType.Texture2D
			},
			new Properties
			{
				name = "_FogOfWarCenter",
				type = PropertyType.Float3
			},
			new Properties
			{
				name = "_FogOfWarSize",
				type = PropertyType.Float3
			},
			new Properties
			{
				name = "_FogOfWarCenterAdjusted",
				type = PropertyType.Float3
			},
			new Properties
			{
				name = "_FogPointLightPosition",
				type = PropertyType.Float4Array
			},
			new Properties
			{
				name = "_FogPointLightColor",
				type = PropertyType.ColorArray
			},
			new Properties
			{
				name = "_SunPosition",
				type = PropertyType.Float3
			},
			new Properties
			{
				name = "_SunDir",
				type = PropertyType.Float3
			},
			new Properties
			{
				name = "_SunColor",
				type = PropertyType.Float3
			},
			new Properties
			{
				name = "_FogScatteringData",
				type = PropertyType.Float4
			},
			new Properties
			{
				name = "_FogScatteringData2",
				type = PropertyType.Float4
			},
			new Properties
			{
				name = "_VolumetricFogSunDepthTexture",
				type = PropertyType.Texture2D
			},
			new Properties
			{
				name = "_VolumetricFogSunDepthTexture_TexelSize",
				type = PropertyType.Float4
			},
			new Properties
			{
				name = "_VolumetricFogSunProj",
				type = PropertyType.Matrix4x4
			},
			new Properties
			{
				name = "_VolumetricFogSunWorldPos",
				type = PropertyType.Float4
			},
			new Properties
			{
				name = "_VolumetricFogSunShadowsData",
				type = PropertyType.Float4
			},
			new Properties
			{
				name = "_Jitter",
				type = PropertyType.Float
			}
		};

		private static string[] keywords = new string[10] { "FOG_DISTANCE_ON", "FOG_AREA_SPHERE", "FOG_AREA_BOX", "FOG_VOID_SPHERE", "FOG_VOID_BOX", "FOG_OF_WAR_ON", "FOG_SCATTERING_ON", "FOG_BLUR_ON", "FOG_POINT_LIGHTS", "FOG_SUN_SHADOWS_ON" };

		public VolumetricFog fog;

		public Renderer[] materials;

		private void OnEnable()
		{
			fog = GetComponent<VolumetricFog>();
		}

		private void OnPreRender()
		{
			if (fog == null)
			{
				return;
			}
			Material fogMat = fog.fogMat;
			if (fogMat == null || materials == null || materials.Length == 0)
			{
				return;
			}
			for (int i = 0; i < props.Length; i++)
			{
				if (!fogMat.HasProperty(props[i].name))
				{
					continue;
				}
				switch (props[i].type)
				{
				case PropertyType.Color:
				{
					Color color = fogMat.GetColor(props[i].name);
					for (int num = 0; num < materials.Length; num++)
					{
						if (materials[num] != null && materials[num].sharedMaterial != null)
						{
							materials[num].sharedMaterial.SetColor(props[i].name, color);
						}
					}
					break;
				}
				case PropertyType.ColorArray:
				{
					Color[] colorArray = fogMat.GetColorArray(props[i].name);
					if (colorArray == null)
					{
						break;
					}
					for (int m = 0; m < materials.Length; m++)
					{
						if (materials[m] != null && materials[m].sharedMaterial != null)
						{
							materials[m].sharedMaterial.SetColorArray(props[i].name, colorArray);
						}
					}
					break;
				}
				case PropertyType.FloatArray:
				{
					float[] floatArray = fogMat.GetFloatArray(props[i].name);
					if (floatArray == null)
					{
						break;
					}
					for (int num3 = 0; num3 < materials.Length; num3++)
					{
						if (materials[num3] != null && materials[num3].sharedMaterial != null)
						{
							materials[num3].sharedMaterial.SetFloatArray(props[i].name, floatArray);
						}
					}
					break;
				}
				case PropertyType.Float4Array:
				{
					Vector4[] vectorArray = fogMat.GetVectorArray(props[i].name);
					if (vectorArray == null)
					{
						break;
					}
					for (int k = 0; k < materials.Length; k++)
					{
						if (materials[k] != null && materials[k].sharedMaterial != null)
						{
							materials[k].sharedMaterial.SetVectorArray(props[i].name, vectorArray);
						}
					}
					break;
				}
				case PropertyType.Float:
				{
					for (int num2 = 0; num2 < materials.Length; num2++)
					{
						if (materials[num2] != null && materials[num2].sharedMaterial != null)
						{
							materials[num2].sharedMaterial.SetFloat(props[i].name, fogMat.GetFloat(props[i].name));
						}
					}
					break;
				}
				case PropertyType.Float3:
				case PropertyType.Float4:
				{
					for (int n = 0; n < materials.Length; n++)
					{
						if (materials[n] != null && materials[n].sharedMaterial != null)
						{
							materials[n].sharedMaterial.SetVector(props[i].name, fogMat.GetVector(props[i].name));
						}
					}
					break;
				}
				case PropertyType.Matrix4x4:
				{
					for (int l = 0; l < materials.Length; l++)
					{
						if (materials[l] != null && materials[l].sharedMaterial != null)
						{
							materials[l].sharedMaterial.SetMatrix(props[i].name, fogMat.GetMatrix(props[i].name));
						}
					}
					break;
				}
				case PropertyType.Texture2D:
				{
					for (int j = 0; j < materials.Length; j++)
					{
						if (materials[j] != null && materials[j].sharedMaterial != null)
						{
							materials[j].sharedMaterial.SetTexture(props[i].name, fogMat.GetTexture(props[i].name));
						}
					}
					break;
				}
				}
			}
			for (int num4 = 0; num4 < keywords.Length; num4++)
			{
				if (fogMat.IsKeywordEnabled(keywords[num4]))
				{
					for (int num5 = 0; num5 < materials.Length; num5++)
					{
						if (materials[num5] != null && materials[num5].sharedMaterial != null)
						{
							materials[num5].sharedMaterial.EnableKeyword(keywords[num4]);
						}
					}
					continue;
				}
				for (int num6 = 0; num6 < materials.Length; num6++)
				{
					if (materials[num6] != null && materials[num6].sharedMaterial != null)
					{
						materials[num6].sharedMaterial.DisableKeyword(keywords[num4]);
					}
				}
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("")]
	[RequireComponent(typeof(Camera))]
	[ImageEffectAllowedInSceneView]
	public class VolumetricFogPosT : MonoBehaviour, IVolumetricFogRenderComponent
	{
		private Material copyOpaqueMat;

		public VolumetricFog fog { get; set; }

		public void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (fog == null || !fog.enabled)
			{
				Graphics.Blit(source, destination);
				return;
			}
			if (fog.transparencyBlendMode == TRANSPARENT_MODE.None)
			{
				fog.DoOnRenderImage(source, destination);
				return;
			}
			RenderTexture temporary = RenderTexture.GetTemporary(source.descriptor);
			if (copyOpaqueMat == null)
			{
				copyOpaqueMat = new Material(Shader.Find("VolumetricFogAndMist/CopyOpaque"));
			}
			copyOpaqueMat.SetFloat("_BlendPower", fog.transparencyBlendPower);
			Graphics.Blit(source, destination, copyOpaqueMat, (fog.computeDepth && fog.downsampling == 1) ? 1 : 0);
			RenderTexture.ReleaseTemporary(temporary);
		}

		public void DestroySelf()
		{
			UnityEngine.Object.DestroyImmediate(this);
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("")]
	[RequireComponent(typeof(Camera))]
	[ImageEffectAllowedInSceneView]
	public class VolumetricFogPreT : MonoBehaviour, IVolumetricFogRenderComponent
	{
		private RenderTexture opaqueFrame;

		public VolumetricFog fog { get; set; }

		[ImageEffectOpaque]
		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (fog == null || !fog.enabled)
			{
				Graphics.Blit(source, destination);
				return;
			}
			if (fog.renderBeforeTransparent)
			{
				fog.DoOnRenderImage(source, destination);
				return;
			}
			RenderTextureDescriptor descriptor = source.descriptor;
			opaqueFrame = RenderTexture.GetTemporary(descriptor);
			fog.DoOnRenderImage(source, opaqueFrame);
			Shader.SetGlobalTexture("_VolumetricFog_OpaqueFrame", opaqueFrame);
			Graphics.Blit(opaqueFrame, destination);
		}

		private void OnPostRender()
		{
			if (opaqueFrame != null)
			{
				RenderTexture.ReleaseTemporary(opaqueFrame);
				opaqueFrame = null;
			}
		}

		public void DestroySelf()
		{
			UnityEngine.Object.DestroyImmediate(this);
		}
	}
	[CreateAssetMenu(fileName = "VolumetricFogProfile", menuName = "Volumetric Fog Profile", order = 100)]
	public class VolumetricFogProfile : ScriptableObject
	{
		public LIGHTING_MODEL lightingModel;

		public bool sunCopyColor = true;

		[Range(0f, 1.25f)]
		public float density = 1f;

		[Range(0f, 1f)]
		public float noiseStrength = 0.8f;

		[Range(0f, 500f)]
		public float height = 4f;

		[Range(0f, 1f)]
		public float heightFallOff = 0.6f;

		public float baselineHeight;

		[Range(0f, 1000f)]
		public float distance;

		[Range(0f, 5f)]
		public float distanceFallOff;

		public float maxFogLength = 1000f;

		[Range(0f, 1f)]
		public float maxFogLengthFallOff;

		public bool baselineRelativeToCamera;

		[Range(0f, 1f)]
		public float baselineRelativeToCameraDelay;

		[Range(0.2f, 10f)]
		public float noiseScale = 1f;

		[Range(-0.3f, 2f)]
		public float noiseSparse;

		[Range(1f, 2f)]
		public float noiseFinalMultiplier = 1f;

		[Range(0f, 1.05f)]
		public float alpha = 1f;

		public Color color = new Color(0.89f, 0.89f, 0.89f, 1f);

		[Range(0f, 1f)]
		public float deepObscurance = 1f;

		public Color specularColor = new Color(1f, 1f, 0.8f, 1f);

		[Range(0f, 1f)]
		public float specularThreshold = 0.6f;

		[Range(0f, 1f)]
		public float specularIntensity = 0.2f;

		public Vector3 lightDirection = new Vector3(1f, 0f, -1f);

		[Range(-1f, 3f)]
		public float lightIntensity = 0.2f;

		public Color lightColor = Color.white;

		[Range(0f, 1f)]
		public float speed = 0.01f;

		public bool useRealTime;

		public Vector3 windDirection = new Vector3(-1f, 0f, 0f);

		[Range(0f, 10f)]
		public float turbulenceStrength;

		public bool useXYPlane;

		public Color skyColor = new Color(0.89f, 0.89f, 0.89f, 1f);

		public float skyHaze = 50f;

		[Range(0f, 1f)]
		public float skySpeed = 0.3f;

		[Range(0f, 1f)]
		public float skyNoiseStrength = 0.1f;

		public float skyNoiseScale = 1.5f;

		[Range(0f, 1f)]
		public float skyAlpha = 1f;

		[SerializeField]
		[Range(0f, 0.999f)]
		private float skyDepth = 0.999f;

		public float stepping = 12f;

		public float steppingNear = 1f;

		public bool dithering;

		public float ditherStrength = 0.75f;

		public bool downsamplingOverride;

		[Range(1f, 8f)]
		public int downsampling = 1;

		public bool forceComposition;

		public bool edgeImprove;

		[Range(1E-05f, 0.005f)]
		public float edgeThreshold = 0.0005f;

		public bool lightScatteringOverride;

		public bool lightScatteringEnabled;

		[Range(0f, 1f)]
		public float lightScatteringDiffusion = 0.7f;

		[Range(0f, 1f)]
		public float lightScatteringSpread = 0.686f;

		[Range(4f, 64f)]
		public int lightScatteringSamples = 16;

		[Range(0f, 50f)]
		public float lightScatteringWeight = 1.9f;

		[Range(0f, 50f)]
		public float lightScatteringIllumination = 18f;

		[Range(0.9f, 1.1f)]
		public float lightScatteringDecay = 0.986f;

		[Range(0f, 0.2f)]
		public float lightScatteringExposure;

		[Range(0f, 1f)]
		public float lightScatteringJittering = 0.5f;

		[Range(1f, 4f)]
		public int lightScatteringBlurDownscale = 1;

		public bool fogVoidOverride;

		public FOG_VOID_TOPOLOGY fogVoidTopology;

		[SerializeField]
		[Range(0f, 10f)]
		public float fogVoidFallOff = 1f;

		public float fogVoidRadius;

		public Vector3 fogVoidPosition = Vector3.zero;

		public float fogVoidDepth;

		public float fogVoidHeight;

		public void Load(VolumetricFog fog)
		{
			fog.density = density;
			fog.noiseStrength = noiseStrength;
			fog.height = height;
			fog.heightFallOff = heightFallOff;
			fog.baselineHeight = baselineHeight;
			fog.distance = distance;
			fog.distanceFallOff = distanceFallOff;
			fog.maxFogLength = maxFogLength;
			fog.maxFogLengthFallOff = maxFogLengthFallOff;
			fog.baselineRelativeToCamera = baselineRelativeToCamera;
			fog.baselineRelativeToCameraDelay = baselineRelativeToCameraDelay;
			fog.noiseScale = noiseScale;
			fog.noiseSparse = noiseSparse;
			fog.noiseFinalMultiplier = noiseFinalMultiplier;
			fog.useXYPlane = useXYPlane;
			fog.lightingModel = lightingModel;
			fog.sunCopyColor = sunCopyColor;
			fog.alpha = alpha;
			fog.color = color;
			fog.deepObscurance = deepObscurance;
			fog.specularColor = specularColor;
			fog.specularThreshold = specularThreshold;
			fog.specularIntensity = specularIntensity;
			fog.lightDirection = lightDirection;
			fog.lightIntensity = lightIntensity;
			fog.lightColor = lightColor;
			fog.speed = speed;
			fog.windDirection = windDirection;
			fog.turbulenceStrength = turbulenceStrength;
			fog.useRealTime = useRealTime;
			fog.skyColor = skyColor;
			fog.skyHaze = skyHaze;
			fog.skySpeed = skySpeed;
			fog.skyNoiseStrength = skyNoiseStrength;
			fog.skyNoiseScale = skyNoiseScale;
			fog.skyAlpha = skyAlpha;
			fog.skyDepth = skyDepth;
			fog.stepping = stepping;
			fog.steppingNear = steppingNear;
			fog.dithering = dithering;
			fog.ditherStrength = ditherStrength;
			if (downsamplingOverride)
			{
				fog.downsampling = downsampling;
				fog.forceComposition = forceComposition;
				fog.edgeImprove = edgeImprove;
				fog.edgeThreshold = edgeThreshold;
			}
			if (fogVoidOverride)
			{
				fog.fogVoidTopology = fogVoidTopology;
				fog.fogVoidDepth = fogVoidDepth;
				fog.fogVoidFallOff = fogVoidFallOff;
				fog.fogVoidHeight = fogVoidHeight;
				fog.fogVoidPosition = fogVoidPosition;
				fog.fogVoidRadius = fogVoidRadius;
			}
			if (lightScatteringOverride)
			{
				fog.lightScatteringEnabled = lightScatteringEnabled;
				fog.lightScatteringDecay = lightScatteringDecay;
				fog.lightScatteringDiffusion = lightScatteringDiffusion;
				fog.lightScatteringExposure = lightScatteringExposure;
				fog.lightScatteringIllumination = lightScatteringIllumination;
				fog.lightScatteringJittering = lightScatteringJittering;
				fog.lightScatteringBlurDownscale = lightScatteringBlurDownscale;
				fog.lightScatteringSamples = lightScatteringSamples;
				fog.lightScatteringSpread = lightScatteringSpread;
				fog.lightScatteringWeight = lightScatteringWeight;
			}
		}

		public void Save(VolumetricFog fog)
		{
			density = fog.density;
			noiseStrength = fog.noiseStrength;
			height = fog.height;
			heightFallOff = fog.heightFallOff;
			baselineHeight = fog.baselineHeight;
			distance = fog.distance;
			distanceFallOff = fog.distanceFallOff;
			maxFogLength = fog.maxFogLength;
			maxFogLengthFallOff = fog.maxFogLengthFallOff;
			baselineRelativeToCamera = fog.baselineRelativeToCamera;
			baselineRelativeToCameraDelay = fog.baselineRelativeToCameraDelay;
			noiseScale = fog.noiseScale;
			noiseSparse = fog.noiseSparse;
			noiseFinalMultiplier = fog.noiseFinalMultiplier;
			useXYPlane = fog.useXYPlane;
			sunCopyColor = fog.sunCopyColor;
			alpha = fog.alpha;
			color = fog.color;
			deepObscurance = fog.deepObscurance;
			specularColor = fog.specularColor;
			specularThreshold = fog.specularThreshold;
			specularIntensity = fog.specularIntensity;
			lightDirection = fog.lightDirection;
			lightIntensity = fog.lightIntensity;
			lightColor = fog.lightColor;
			lightingModel = fog.lightingModel;
			speed = fog.speed;
			windDirection = fog.windDirection;
			turbulenceStrength = fog.turbulenceStrength;
			useRealTime = fog.useRealTime;
			skyColor = fog.skyColor;
			skyHaze = fog.skyHaze;
			skySpeed = fog.skySpeed;
			skyNoiseStrength = fog.skyNoiseStrength;
			skyNoiseScale = fog.skyNoiseScale;
			skyAlpha = fog.skyAlpha;
			skyDepth = fog.skyDepth;
			stepping = fog.stepping;
			steppingNear = fog.steppingNear;
			dithering = fog.dithering;
			ditherStrength = fog.ditherStrength;
			downsampling = fog.downsampling;
			forceComposition = fog.forceComposition;
			edgeImprove = fog.edgeImprove;
			edgeThreshold = fog.edgeThreshold;
			fogVoidTopology = fog.fogVoidTopology;
			fogVoidDepth = fog.fogVoidDepth;
			fogVoidFallOff = fog.fogVoidFallOff;
			fogVoidHeight = fog.fogVoidHeight;
			fogVoidPosition = fog.fogVoidPosition;
			fogVoidRadius = fog.fogVoidRadius;
			lightScatteringEnabled = fog.lightScatteringEnabled;
			lightScatteringDecay = fog.lightScatteringDecay;
			lightScatteringDiffusion = fog.lightScatteringDiffusion;
			lightScatteringExposure = fog.lightScatteringExposure;
			lightScatteringIllumination = fog.lightScatteringIllumination;
			lightScatteringJittering = fog.lightScatteringJittering;
			lightScatteringSamples = fog.lightScatteringSamples;
			lightScatteringSpread = fog.lightScatteringSamples;
			lightScatteringSpread = fog.lightScatteringSpread;
			lightScatteringWeight = fog.lightScatteringWeight;
			lightScatteringBlurDownscale = fog.lightScatteringBlurDownscale;
		}

		public static void Lerp(VolumetricFogProfile profile1, VolumetricFogProfile profile2, float t, VolumetricFog fog)
		{
			if (t < 0f)
			{
				t = 0f;
			}
			else if (t > 1f)
			{
				t = 1f;
			}
			fog.density = profile1.density * (1f - t) + profile2.density * t;
			fog.noiseStrength = profile1.noiseStrength * (1f - t) + profile2.noiseStrength * t;
			fog.height = profile1.height * (1f - t) + profile2.height * t;
			fog.heightFallOff = profile1.heightFallOff * (1f - t) + profile2.heightFallOff * t;
			fog.baselineHeight = profile1.baselineHeight * (1f - t) + profile2.baselineHeight * t;
			fog.distance = profile1.distance * (1f - t) + profile2.distance * t;
			fog.distanceFallOff = profile1.distanceFallOff * (1f - t) + profile2.distanceFallOff * t;
			fog.maxFogLength = profile1.maxFogLength * (1f - t) + profile2.maxFogLength * t;
			fog.maxFogLengthFallOff = profile1.maxFogLengthFallOff * (1f - t) + profile2.maxFogLengthFallOff * t;
			fog.baselineRelativeToCamera = ((t < 0.5f) ? profile1.baselineRelativeToCamera : profile2.baselineRelativeToCamera);
			fog.baselineRelativeToCameraDelay = profile1.baselineRelativeToCameraDelay * (1f - t) + profile2.baselineRelativeToCameraDelay * t;
			fog.noiseScale = profile1.noiseScale * (1f - t) + profile2.noiseScale * t;
			fog.noiseSparse = profile1.noiseSparse * (1f - t) + profile2.noiseSparse * t;
			fog.noiseFinalMultiplier = profile1.noiseFinalMultiplier * (1f - t) + profile2.noiseFinalMultiplier * t;
			fog.sunCopyColor = ((t < 0.5f) ? profile1.sunCopyColor : profile2.sunCopyColor);
			fog.alpha = profile1.alpha * (1f - t) + profile2.alpha * t;
			fog.color = profile1.color * (1f - t) + profile2.color * t;
			fog.deepObscurance = profile1.deepObscurance * (1f - t) + profile2.deepObscurance * t;
			fog.specularColor = profile1.specularColor * (1f - t) + profile2.specularColor * t;
			fog.specularThreshold = profile1.specularThreshold * (1f - t) + profile2.specularThreshold * t;
			fog.specularIntensity = profile1.specularIntensity * (1f - t) + profile2.specularIntensity * t;
			fog.lightDirection = profile1.lightDirection * (1f - t) + profile2.lightDirection * t;
			fog.lightIntensity = profile1.lightIntensity * (1f - t) + profile2.lightIntensity * t;
			fog.lightColor = profile1.lightColor * (1f - t) + profile2.lightColor * t;
			fog.speed = profile1.speed * (1f - t) + profile2.speed * t;
			fog.windDirection = profile1.windDirection * (1f - t) + profile2.windDirection * t;
			fog.turbulenceStrength = profile1.turbulenceStrength * (1f - t) + profile2.turbulenceStrength * t;
			fog.skyColor = profile1.skyColor * (1f - t) + profile2.skyColor * t;
			fog.skyHaze = profile1.skyHaze * (1f - t) + profile2.skyHaze * t;
			fog.skySpeed = profile1.skySpeed * (1f - t) + profile2.skySpeed * t;
			fog.skyNoiseStrength = profile1.skyNoiseStrength * (1f - t) + profile2.skyNoiseStrength * t;
			fog.skyNoiseScale = profile1.skyNoiseScale * (1f - t) + profile2.skyNoiseScale * t;
			fog.skyAlpha = profile1.skyAlpha * (1f - t) + profile2.skyAlpha * t;
			fog.skyDepth = profile1.skyDepth * (1f - t) + profile2.skyDepth * t;
			fog.stepping = profile1.stepping * (1f - t) + profile2.stepping * t;
			fog.steppingNear = profile1.steppingNear * (1f - t) + profile2.steppingNear * t;
			fog.dithering = ((t < 0.5f) ? profile1.dithering : profile2.dithering);
			fog.ditherStrength = profile1.ditherStrength * (1f - t) + profile2.ditherStrength * t;
			if (profile1.fogVoidOverride && profile2.fogVoidOverride)
			{
				fog.fogVoidDepth = profile1.fogVoidDepth * (1f - t) + profile2.fogVoidDepth * t;
				fog.fogVoidFallOff = profile1.fogVoidFallOff * (1f - t) + profile2.fogVoidFallOff * t;
				fog.fogVoidHeight = profile1.fogVoidHeight * (1f - t) + profile2.fogVoidHeight * t;
				fog.fogVoidPosition = profile1.fogVoidPosition * (1f - t) + profile2.fogVoidPosition * t;
				fog.fogVoidRadius = profile1.fogVoidRadius * (1f - t) + profile2.fogVoidRadius * t;
			}
			if (profile1.lightScatteringOverride && profile2.lightScatteringOverride)
			{
				fog.lightScatteringDecay = profile1.lightScatteringDecay * (1f - t) + profile2.lightScatteringDecay * t;
				fog.lightScatteringDiffusion = profile1.lightScatteringDiffusion * (1f - t) + profile2.lightScatteringDiffusion * t;
				fog.lightScatteringExposure = profile1.lightScatteringExposure * (1f - t) + profile2.lightScatteringExposure * t;
				fog.lightScatteringIllumination = profile1.lightScatteringIllumination * (1f - t) + profile2.lightScatteringIllumination * t;
				fog.lightScatteringJittering = profile1.lightScatteringJittering * (1f - t) + profile2.lightScatteringJittering * t;
				fog.lightScatteringSamples = (int)((float)profile1.lightScatteringSamples * (1f - t) + (float)profile2.lightScatteringSamples * t);
				fog.lightScatteringSpread = profile1.lightScatteringSpread * (1f - t) + profile2.lightScatteringSpread * t;
				fog.lightScatteringWeight = profile1.lightScatteringWeight * (1f - t) + profile2.lightScatteringWeight * t;
			}
		}
	}
}
namespace BoundarySystem_Ext
{
	internal static class Pvr_BoundaryAPI
	{
		private const string LibFileName = "Pvr_UnitySDK";

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void Pvr_StartSDKBoundary();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void Pvr_ShutdownSDKBoundary();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetMainSensorStateExt(ref float x, ref float y, ref float z, ref float w, ref float px, ref float py, ref float pz, ref float vfov, ref float hfov, ref int viewNumber);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr Pvr_GetCameraData_Ext();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void Pvr_ResetVrModebyForce();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_ResumeBoundaryForSTS();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_PauseBoundaryForSTS();

		public static int UPvr_GetMainSensorStateExt(ref float x, ref float y, ref float z, ref float w, ref float px, ref float py, ref float pz, ref float vfov, ref float hfov, ref int viewNumber)
		{
			return Pvr_GetMainSensorStateExt(ref x, ref y, ref z, ref w, ref px, ref py, ref pz, ref vfov, ref hfov, ref viewNumber);
		}

		public static IntPtr UPvr_GetCameraData_Ext()
		{
			_ = IntPtr.Zero;
			return Pvr_GetCameraData_Ext();
		}

		public static bool UPvr_ResumeBoundaryForSTS()
		{
			return Pvr_ResumeBoundaryForSTS();
		}

		public static void UPvr_PauseBoundaryForSTS()
		{
			Pvr_PauseBoundaryForSTS();
		}

		public static IntPtr StructToIntPtr<T>(T info)
		{
			IntPtr intPtr = Marshal.AllocHGlobal(Marshal.SizeOf(info));
			Marshal.StructureToPtr(info, intPtr, fDeleteOld: true);
			return intPtr;
		}

		public static T IntPtrToStruct<T>(IntPtr info)
		{
			return (T)Marshal.PtrToStructure(info, typeof(T));
		}
	}
	internal static class Pvr_SafeAreaAlgoAPI
	{
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		public delegate void SafeAreaCallback(IntPtr lineCollectionPtr, IntPtr safeAreaRectPtr);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		public delegate void SafeAreaCallbackShrink(IntPtr lineCollectionPtr, IntPtr safeAreaDetailRectPtr);

		public struct GSAPoint3i
		{
			public int x;

			public int y;

			public int z;
		}

		public struct GSALine
		{
			public IntPtr pointArray;

			public int pointCount;
		}

		public struct GSALineCollection
		{
			public IntPtr lineArray;

			public int lineCount;
		}

		public struct GSALegalData
		{
			public int overMaxRange;

			public int includeBigGrap;

			public int bigGapNum;

			public int centerOut;

			public int removeNarrow;

			public int overMaxRange_more;

			public int validShrinkArea;
		}

		public struct GSARect
		{
			public GSAPoint3i leftup;

			public GSAPoint3i leftdown;

			public GSAPoint3i rightup;

			public GSAPoint3i rightdown;

			public GSAPoint3i center;

			public uint width;

			public uint height;

			public int isLegal;

			public GSALegalData legalData;
		}

		private const string LibFileName = "SafetyArea";

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern int GSAInit(int width, int height);

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern int GSAShutDown();

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern int GSASetCallback(SafeAreaCallback cb);

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern int GSASetCallbackShrink(SafeAreaCallbackShrink cb);

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern int GSAUpDateData(IntPtr lineCollectionPtr);

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern int GSASetConfigFilePath(IntPtr configPath);

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool GSAGetClosedAreaUpdateFlag();

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern int GSALoadSafetyArea(IntPtr lineCollectionPtr);

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern double GSABoundaryDetector(ref GSAPoint3i pointPtr);

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern int GSALoadSafetyArea2(IntPtr lineCollectionPtr, bool isPlayArea);

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern double GSABoundaryDetector2(ref GSAPoint3i point, bool isPlayArea, ref GSAPoint3i closestPoint, ref GSAPoint3i normalDir);

		public static int Pvr_GSAInit(int width, int height)
		{
			return GSAInit(width, height);
		}

		public static int Pvr_GSASetCallback(SafeAreaCallback cb)
		{
			return GSASetCallback(cb);
		}

		public static int Pvr_GSASetCallbackShrink(SafeAreaCallbackShrink cb)
		{
			return GSASetCallbackShrink(cb);
		}

		public static int Pvr_GSAUpDateData(IntPtr lineCollectionPtr)
		{
			return GSAUpDateData(lineCollectionPtr);
		}

		public static bool Pvr_GSAGetClosedAreaUpdateFlag()
		{
			return GSAGetClosedAreaUpdateFlag();
		}

		public static int Pvr_GSASetConfigFilePath(string configPath)
		{
			int num = -1;
			IntPtr intPtr = Marshal.StringToHGlobalAnsi(configPath);
			num = GSASetConfigFilePath(intPtr);
			Marshal.FreeHGlobal(intPtr);
			return num;
		}

		public static int Pvr_GSALoadSafetyArea(IntPtr lineCollectionPtr)
		{
			return GSALoadSafetyArea(lineCollectionPtr);
		}

		public static double Pvr_GSABoundaryDetector(ref GSAPoint3i point)
		{
			return GSABoundaryDetector(ref point);
		}

		public static int Pvr_GSAShutDown()
		{
			return GSAShutDown();
		}

		public static int Pvr_GSALoadSafetyArea2(IntPtr lineCollectionPtr, bool isPlayArea)
		{
			return GSALoadSafetyArea2(lineCollectionPtr, isPlayArea);
		}

		public static double Pvr_GSABoundaryDetector2(ref GSAPoint3i point, bool isPlayArea, ref GSAPoint3i closestPoint, ref GSAPoint3i normalDir)
		{
			return GSABoundaryDetector2(ref point, isPlayArea, ref closestPoint, ref normalDir);
		}
	}
	public class Pvr_BoundarySystem
	{
		private static Pvr_BoundarySystem instance;

		public const int CameraImageWidth = 1280;

		public const int CameraImageHeight = 400;

		public IntPtr CameraFramePtr = IntPtr.Zero;

		public static Pvr_BoundarySystem Instance
		{
			get
			{
				if (instance == null)
				{
					instance = new Pvr_BoundarySystem();
				}
				return instance;
			}
		}

		public void OpenBoundary()
		{
			Pvr_BoundaryAPI.Pvr_StartSDKBoundary();
		}

		public void CloseBoundary()
		{
			Pvr_BoundaryAPI.Pvr_ShutdownSDKBoundary();
		}

		public void Reset6Dof()
		{
			Pvr_BoundaryAPI.Pvr_ResetVrModebyForce();
		}

		public float[] GetControllerFixedPoseData(int hand)
		{
			float[] result = new float[7] { 0f, 0f, 0f, 1f, 0f, 0f, 0f };
			if (Pvr_ControllerManager.controllerlink != null)
			{
				Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, Pvr_ControllerManager.controllerlink.javaCVClass, "getControllerFixedSensorState", hand);
			}
			result[2] = 0f - result[2];
			result[3] = 0f - result[3];
			return result;
		}
	}
	public class Pvr_SafeAreaAlgoModule
	{
		public struct ExtraInfo
		{
			public bool overMaxRange;

			public bool includeBigGap;

			public int bigGapNum;

			public bool centerOut;

			public bool removeNarrow;

			public bool overMaxRange_more;

			public int validShrinkArea;
		}

		public struct BoundaryPlayerArea
		{
			public Vector3 lowerleft;

			public Vector3 upperleft;

			public Vector3 upperRight;

			public Vector3 lowerRight;

			public Vector3 center;

			public uint width;

			public uint height;

			public bool isLegal;

			public ExtraInfo extraInfo;
		}

		public delegate void BoundarySystemCallback(BoundaryPlayerArea playAreaInfo, List<Vector3> boundaryPoints, List<List<Vector3>> unusedLines);

		public delegate void BoundarySystemCallbackShrink(List<Vector3> rectPoints, List<Vector3> boundaryPoints, List<List<Vector3>> unusedLines);

		private static Pvr_SafeAreaAlgoModule instance;

		private BoundarySystemCallback boundarySystemCallback;

		private BoundarySystemCallbackShrink boundarySystemCallbackShrink;

		public static Pvr_SafeAreaAlgoModule Instance
		{
			get
			{
				if (instance == null)
				{
					instance = new Pvr_SafeAreaAlgoModule();
				}
				return instance;
			}
		}

		public void RegisterCallBack(BoundarySystemCallback callback)
		{
			boundarySystemCallback = callback;
		}

		public void RegisterCallBackShrink(BoundarySystemCallbackShrink callback)
		{
			boundarySystemCallbackShrink = callback;
		}

		public bool Start()
		{
			int num = Pvr_SafeAreaAlgoAPI.Pvr_GSASetCallback(_SafeAreaCallback);
			int num2 = Pvr_SafeAreaAlgoAPI.Pvr_GSASetCallbackShrink(_SafeAreaCallbackShrink);
			if (num != 0 || num2 != 0)
			{
				UnityEngine.Debug.LogError("BoundarySystem register callback failed!");
				return false;
			}
			if (Pvr_SafeAreaAlgoAPI.Pvr_GSAInit(300, 300) != 0)
			{
				UnityEngine.Debug.LogError("BoundarySystem init failed!");
				return false;
			}
			return true;
		}

		public bool CommitNewLineData(bool isFistLine, Vector3[] points)
		{
			Pvr_SafeAreaAlgoAPI.GSALineCollection info = default(Pvr_SafeAreaAlgoAPI.GSALineCollection);
			info.lineCount = 2;
			Pvr_SafeAreaAlgoAPI.GSALine[] array = new Pvr_SafeAreaAlgoAPI.GSALine[2];
			if (isFistLine)
			{
				array[0].pointArray = IntPtr.Zero;
				array[0].pointCount = 0;
			}
			else
			{
				Pvr_SafeAreaAlgoAPI.GSAPoint3i[] arr = new Pvr_SafeAreaAlgoAPI.GSAPoint3i[1]
				{
					new Pvr_SafeAreaAlgoAPI.GSAPoint3i
					{
						x = 0,
						y = 0,
						z = 0
					}
				};
				array[0].pointArray = Marshal.UnsafeAddrOfPinnedArrayElement(arr, 0);
				array[0].pointCount = 1;
			}
			Pvr_SafeAreaAlgoAPI.GSAPoint3i[] array2 = new Pvr_SafeAreaAlgoAPI.GSAPoint3i[points.Length];
			for (int i = 0; i < points.Length; i++)
			{
				Pvr_SafeAreaAlgoAPI.GSAPoint3i gSAPoint3i = default(Pvr_SafeAreaAlgoAPI.GSAPoint3i);
				gSAPoint3i.x = (int)(points[i].x * 1000f);
				gSAPoint3i.y = (int)(points[i].y * 1000f);
				gSAPoint3i.z = (int)(points[i].z * 1000f);
				array2[i] = gSAPoint3i;
			}
			array[1].pointArray = Marshal.UnsafeAddrOfPinnedArrayElement(array2, 0);
			array[1].pointCount = array2.Length;
			info.lineArray = Marshal.UnsafeAddrOfPinnedArrayElement(array, 0);
			IntPtr intPtr = Pvr_BoundaryAPI.StructToIntPtr(info);
			int num = Pvr_SafeAreaAlgoAPI.Pvr_GSAUpDateData(intPtr);
			Marshal.FreeHGlobal(intPtr);
			if (num != 0)
			{
				UnityEngine.Debug.LogError("BoundarySystem commit new line data failed!");
				return false;
			}
			return true;
		}

		public bool Shutdown()
		{
			if (Pvr_SafeAreaAlgoAPI.Pvr_GSAShutDown() != 0)
			{
				UnityEngine.Debug.LogError("BoundarySystem shutdown failed!");
				return false;
			}
			return true;
		}

		public double QueryDistanceOfPoint(Vector3 point)
		{
			Pvr_SafeAreaAlgoAPI.GSAPoint3i point2 = default(Pvr_SafeAreaAlgoAPI.GSAPoint3i);
			point2.x = (int)(point.x * 1000f);
			point2.y = (int)(point.y * 1000f);
			point2.z = (int)(point.z * 1000f);
			return Pvr_SafeAreaAlgoAPI.Pvr_GSABoundaryDetector(ref point2) / 1000.0;
		}

		public double QueryDistanceOfPoint(Vector3 point, bool isPlayArea, ref Vector3 closestPoint, ref Vector3 normalDir)
		{
			Pvr_SafeAreaAlgoAPI.GSAPoint3i point2 = default(Pvr_SafeAreaAlgoAPI.GSAPoint3i);
			point2.x = (int)(point.x * 1000f);
			point2.y = (int)(point.y * 1000f);
			point2.z = (int)(point.z * 1000f);
			Pvr_SafeAreaAlgoAPI.GSAPoint3i closestPoint2 = default(Pvr_SafeAreaAlgoAPI.GSAPoint3i);
			Pvr_SafeAreaAlgoAPI.GSAPoint3i normalDir2 = default(Pvr_SafeAreaAlgoAPI.GSAPoint3i);
			double num = Pvr_SafeAreaAlgoAPI.Pvr_GSABoundaryDetector2(ref point2, isPlayArea, ref closestPoint2, ref normalDir2);
			closestPoint.x = (float)closestPoint2.x / 1000f;
			closestPoint.y = (float)closestPoint2.y / 1000f;
			closestPoint.z = (float)closestPoint2.z / 1000f;
			normalDir.x = (float)normalDir2.x / 1000f;
			normalDir.y = (float)normalDir2.y / 1000f;
			normalDir.z = (float)normalDir2.z / 1000f;
			return num / 1000.0;
		}

		[MonoPInvokeCallback(typeof(Pvr_SafeAreaAlgoAPI.SafeAreaCallback))]
		private static void _SafeAreaCallback(IntPtr lineCollectionPtr, IntPtr safeAreaRectPtr)
		{
			if (lineCollectionPtr == IntPtr.Zero || safeAreaRectPtr == IntPtr.Zero)
			{
				UnityEngine.Debug.LogError("BoundarySystem callback is inValid!");
			}
			else
			{
				if (instance.boundarySystemCallback == null)
				{
					return;
				}
				List<Vector3> boundaryPoints = new List<Vector3>();
				List<List<Vector3>> list = new List<List<Vector3>>();
				int num = Marshal.SizeOf(typeof(Pvr_SafeAreaAlgoAPI.GSALine));
				int num2 = Marshal.SizeOf(typeof(Pvr_SafeAreaAlgoAPI.GSAPoint3i));
				Pvr_SafeAreaAlgoAPI.GSALineCollection gSALineCollection = Pvr_BoundaryAPI.IntPtrToStruct<Pvr_SafeAreaAlgoAPI.GSALineCollection>(lineCollectionPtr);
				for (int i = 0; i < gSALineCollection.lineCount; i++)
				{
					Pvr_SafeAreaAlgoAPI.GSALine gSALine = (Pvr_SafeAreaAlgoAPI.GSALine)Marshal.PtrToStructure(new IntPtr(gSALineCollection.lineArray.ToInt64() + num * i), typeof(Pvr_SafeAreaAlgoAPI.GSALine));
					List<Vector3> list2 = new List<Vector3>();
					for (int j = 0; j < gSALine.pointCount; j++)
					{
						Pvr_SafeAreaAlgoAPI.GSAPoint3i gSAPoint3i = (Pvr_SafeAreaAlgoAPI.GSAPoint3i)Marshal.PtrToStructure(new IntPtr(gSALine.pointArray.ToInt64() + num2 * j), typeof(Pvr_SafeAreaAlgoAPI.GSAPoint3i));
						list2.Add(new Vector3((float)gSAPoint3i.x / 1000f, (float)gSAPoint3i.y / 1000f, (float)gSAPoint3i.z / 1000f));
					}
					if (i == 0)
					{
						boundaryPoints = list2;
					}
					else
					{
						list.Add(list2);
					}
				}
				Pvr_SafeAreaAlgoAPI.GSARect gSARect = Pvr_BoundaryAPI.IntPtrToStruct<Pvr_SafeAreaAlgoAPI.GSARect>(safeAreaRectPtr);
				BoundaryPlayerArea playAreaInfo = default(BoundaryPlayerArea);
				playAreaInfo.lowerleft = new Vector3((float)gSARect.leftup.x / 1000f, (float)gSARect.leftup.y / 1000f, (float)gSARect.leftup.z / 1000f);
				playAreaInfo.upperleft = new Vector3((float)gSARect.leftdown.x / 1000f, (float)gSARect.leftdown.y / 1000f, (float)gSARect.leftdown.z / 1000f);
				playAreaInfo.upperRight = new Vector3((float)gSARect.rightdown.x / 1000f, (float)gSARect.rightdown.y / 1000f, (float)gSARect.rightdown.z / 1000f);
				playAreaInfo.lowerRight = new Vector3((float)gSARect.rightup.x / 1000f, (float)gSARect.rightup.y / 1000f, (float)gSARect.rightup.z / 1000f);
				playAreaInfo.center = new Vector3((float)gSARect.center.x / 1000f, (float)gSARect.center.y / 1000f, (float)gSARect.center.z / 1000f);
				playAreaInfo.width = gSARect.width;
				playAreaInfo.height = gSARect.height;
				playAreaInfo.isLegal = ((gSARect.isLegal != 0) ? true : false);
				playAreaInfo.extraInfo.overMaxRange = ((gSARect.legalData.overMaxRange != 0) ? true : false);
				playAreaInfo.extraInfo.includeBigGap = ((gSARect.legalData.includeBigGrap != 0) ? true : false);
				playAreaInfo.extraInfo.bigGapNum = gSARect.legalData.bigGapNum;
				playAreaInfo.extraInfo.centerOut = ((gSARect.legalData.centerOut != 0) ? true : false);
				playAreaInfo.extraInfo.removeNarrow = ((gSARect.legalData.removeNarrow != 0) ? true : false);
				playAreaInfo.extraInfo.overMaxRange_more = ((gSARect.legalData.overMaxRange_more != 0) ? true : false);
				playAreaInfo.extraInfo.validShrinkArea = gSARect.legalData.validShrinkArea;
				instance.boundarySystemCallback(playAreaInfo, boundaryPoints, list);
			}
		}

		[MonoPInvokeCallback(typeof(Pvr_SafeAreaAlgoAPI.SafeAreaCallbackShrink))]
		private static void _SafeAreaCallbackShrink(IntPtr lineCollectionPtr, IntPtr safeAreaDetailRectPtr)
		{
			if (lineCollectionPtr == IntPtr.Zero || safeAreaDetailRectPtr == IntPtr.Zero)
			{
				UnityEngine.Debug.LogError("BoundarySystem callback is inValid!");
			}
			else
			{
				if (instance.boundarySystemCallbackShrink == null)
				{
					return;
				}
				List<Vector3> boundaryPoints = new List<Vector3>();
				List<List<Vector3>> list = new List<List<Vector3>>();
				int num = Marshal.SizeOf(typeof(Pvr_SafeAreaAlgoAPI.GSALine));
				int num2 = Marshal.SizeOf(typeof(Pvr_SafeAreaAlgoAPI.GSAPoint3i));
				Pvr_SafeAreaAlgoAPI.GSALineCollection gSALineCollection = Pvr_BoundaryAPI.IntPtrToStruct<Pvr_SafeAreaAlgoAPI.GSALineCollection>(lineCollectionPtr);
				for (int i = 0; i < gSALineCollection.lineCount; i++)
				{
					Pvr_SafeAreaAlgoAPI.GSALine gSALine = (Pvr_SafeAreaAlgoAPI.GSALine)Marshal.PtrToStructure(new IntPtr(gSALineCollection.lineArray.ToInt64() + num * i), typeof(Pvr_SafeAreaAlgoAPI.GSALine));
					List<Vector3> list2 = new List<Vector3>();
					for (int j = 0; j < gSALine.pointCount; j++)
					{
						Pvr_SafeAreaAlgoAPI.GSAPoint3i gSAPoint3i = (Pvr_SafeAreaAlgoAPI.GSAPoint3i)Marshal.PtrToStructure(new IntPtr(gSALine.pointArray.ToInt64() + num2 * j), typeof(Pvr_SafeAreaAlgoAPI.GSAPoint3i));
						list2.Add(new Vector3((float)gSAPoint3i.x / 1000f, (float)gSAPoint3i.y / 1000f, (float)gSAPoint3i.z / 1000f));
					}
					if (i == 0)
					{
						boundaryPoints = list2;
					}
					else
					{
						list.Add(list2);
					}
				}
				List<Vector3> list3 = new List<Vector3>();
				Pvr_SafeAreaAlgoAPI.GSALineCollection gSALineCollection2 = Pvr_BoundaryAPI.IntPtrToStruct<Pvr_SafeAreaAlgoAPI.GSALineCollection>(safeAreaDetailRectPtr);
				for (int k = 0; k < gSALineCollection2.lineCount; k++)
				{
					Pvr_SafeAreaAlgoAPI.GSALine gSALine2 = (Pvr_SafeAreaAlgoAPI.GSALine)Marshal.PtrToStructure(new IntPtr(gSALineCollection2.lineArray.ToInt64() + num * k), typeof(Pvr_SafeAreaAlgoAPI.GSALine));
					for (int l = 0; l < gSALine2.pointCount; l++)
					{
						Pvr_SafeAreaAlgoAPI.GSAPoint3i gSAPoint3i2 = (Pvr_SafeAreaAlgoAPI.GSAPoint3i)Marshal.PtrToStructure(new IntPtr(gSALine2.pointArray.ToInt64() + num2 * l), typeof(Pvr_SafeAreaAlgoAPI.GSAPoint3i));
						list3.Add(new Vector3((float)gSAPoint3i2.x / 1000f, (float)gSAPoint3i2.y / 1000f, (float)gSAPoint3i2.z / 1000f));
					}
				}
				instance.boundarySystemCallbackShrink(list3, boundaryPoints, list);
			}
		}
	}
}
namespace Pvr_UnitySDKAPI
{
	public class PvrControllerKey
	{
		public bool State;

		public bool PressedDown;

		public bool PressedUp;

		public bool LongPressed;

		public bool Click;

		public bool Touch;

		public bool TouchDown;

		public bool TouchUp;

		public PvrControllerKey()
		{
			State = false;
			PressedDown = false;
			PressedUp = false;
			LongPressed = false;
			Click = false;
			Touch = false;
			TouchDown = false;
			TouchUp = false;
		}
	}
	public class ControllerHand
	{
		public PvrControllerKey App;

		public PvrControllerKey Touch;

		public PvrControllerKey Home;

		public PvrControllerKey VolumeDown;

		public PvrControllerKey VolumeUp;

		public PvrControllerKey Trigger;

		public PvrControllerKey X;

		public PvrControllerKey Y;

		public PvrControllerKey A;

		public PvrControllerKey B;

		public PvrControllerKey Left;

		public PvrControllerKey Right;

		public PvrControllerKey Thumbrest;

		public Vector2 TouchPadPosition;

		public int TriggerNum;

		public int GripValue;

		public Quaternion Rotation;

		public Vector3 Position;

		public int Battery;

		public ControllerState ConnectState;

		public SwipeDirection SwipeDirection;

		public TouchPadClick TouchPadClick;

		public bool isShowBoundary;

		public ControllerHand()
		{
			App = new PvrControllerKey();
			Touch = new PvrControllerKey();
			Home = new PvrControllerKey();
			VolumeDown = new PvrControllerKey();
			VolumeUp = new PvrControllerKey();
			Trigger = new PvrControllerKey();
			A = new PvrControllerKey();
			B = new PvrControllerKey();
			X = new PvrControllerKey();
			Y = new PvrControllerKey();
			Left = new PvrControllerKey();
			Right = new PvrControllerKey();
			Thumbrest = new PvrControllerKey();
			TouchPadPosition = default(Vector2);
			Rotation = default(Quaternion);
			Position = default(Vector3);
			Battery = 0;
			TriggerNum = 0;
			GripValue = 0;
			ConnectState = ControllerState.Error;
			SwipeDirection = SwipeDirection.No;
			TouchPadClick = TouchPadClick.No;
			isShowBoundary = false;
		}
	}
	public enum ControllerState
	{
		Error = -1,
		DisConnected,
		Connected
	}
	public enum Pvr_KeyCode
	{
		None = 0,
		APP = 1,
		TOUCHPAD = 2,
		HOME = 4,
		VOLUMEUP = 8,
		VOLUMEDOWN = 16,
		TRIGGER = 32,
		A = 64,
		B = 128,
		X = 256,
		Y = 512,
		Left = 1024,
		Right = 2048,
		Thumbrest = 4096,
		Any = -1
	}
	public enum SwipeDirection
	{
		No,
		SwipeUp,
		SwipeDown,
		SwipeLeft,
		SwipeRight
	}
	public enum TouchPadClick
	{
		No,
		ClickUp,
		ClickDown,
		ClickLeft,
		ClickRight
	}
	[StructLayout(LayoutKind.Sequential, Size = 1)]
	public struct Controller
	{
		private const float JOYSTICK_THRESHOLD = 0.4f;

		public const string LibFileName = "Pvr_UnitySDK";

		public static Vector2 UPvr_GetTouchPadPosition(int hand)
		{
			return hand switch
			{
				0 => Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition, 
				1 => Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition, 
				_ => new Vector2(0f, 0f), 
			};
		}

		public static float UPvr_GetAxis1D(int hand, Pvr_KeyCode key)
		{
			return hand switch
			{
				0 => key switch
				{
					Pvr_KeyCode.TRIGGER => (float)Pvr_ControllerManager.controllerlink.Controller0.TriggerNum / 255f, 
					Pvr_KeyCode.Left => (float)Pvr_ControllerManager.controllerlink.Controller0.GripValue / 255f, 
					_ => 0f, 
				}, 
				1 => key switch
				{
					Pvr_KeyCode.TRIGGER => (float)Pvr_ControllerManager.controllerlink.Controller1.TriggerNum / 255f, 
					Pvr_KeyCode.Right => (float)Pvr_ControllerManager.controllerlink.Controller1.GripValue / 255f, 
					_ => 0f, 
				}, 
				_ => 0f, 
			};
		}

		public static Vector2 UPvr_GetAxis2D(int hand)
		{
			switch (hand)
			{
			case 0:
				if (Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition != Vector2.zero)
				{
					Vector2 result2 = new Vector2(Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition.x / 128f - 1f, Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition.y / 128f - 1f);
					if (result2.x > 1f || result2.x < -1f || result2.y > 1f || result2.y < -1f)
					{
						return Vector2.zero;
					}
					return result2;
				}
				return Vector2.zero;
			case 1:
				if (Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition != Vector2.zero)
				{
					Vector2 result = new Vector2(Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition.x / 128f - 1f, Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition.y / 128f - 1f);
					if (result.x > 1f || result.x < -1f || result.y > 1f || result.y < -1f)
					{
						return Vector2.zero;
					}
					return result;
				}
				return Vector2.zero;
			default:
				return Vector2.zero;
			}
		}

		public static bool UPvr_GetJoystickUp(int hand)
		{
			switch (hand)
			{
			case 0:
				if (Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition != Vector2.zero)
				{
					float value2 = Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition.x / 128f - 1f;
					float num2 = Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition.y / 128f - 1f;
					if (num2 > 0.4f && num2 > Math.Abs(value2))
					{
						return true;
					}
				}
				return false;
			case 1:
				if (Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition != Vector2.zero)
				{
					float value = Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition.x / 128f - 1f;
					float num = Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition.y / 128f - 1f;
					if (num > 0.4f && num > Math.Abs(value))
					{
						return true;
					}
				}
				return false;
			default:
				return false;
			}
		}

		public static bool UPvr_GetJoystickDown(int hand)
		{
			switch (hand)
			{
			case 0:
				if (Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition != Vector2.zero)
				{
					float value2 = Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition.x / 128f - 1f;
					float num2 = Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition.y / 128f - 1f;
					if (0f - num2 > 0.4f && 0f - num2 > Math.Abs(value2))
					{
						return true;
					}
				}
				return false;
			case 1:
				if (Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition != Vector2.zero)
				{
					float value = Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition.x / 128f - 1f;
					float num = Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition.y / 128f - 1f;
					if (0f - num > 0.4f && 0f - num > Math.Abs(value))
					{
						return true;
					}
				}
				return false;
			default:
				return false;
			}
		}

		public static bool UPvr_GetJoystickLeft(int hand)
		{
			switch (hand)
			{
			case 0:
				if (Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition != Vector2.zero)
				{
					float num2 = Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition.x / 128f - 1f;
					float value2 = Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition.y / 128f - 1f;
					if (0f - num2 > 0.4f && 0f - num2 > Math.Abs(value2))
					{
						return true;
					}
				}
				return false;
			case 1:
				if (Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition != Vector2.zero)
				{
					float num = Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition.x / 128f - 1f;
					float value = Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition.y / 128f - 1f;
					if (0f - num > 0.4f && 0f - num > Math.Abs(value))
					{
						return true;
					}
				}
				return false;
			default:
				return false;
			}
		}

		public static bool UPvr_GetJoystickRight(int hand)
		{
			switch (hand)
			{
			case 0:
				if (Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition != Vector2.zero)
				{
					float num2 = Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition.x / 128f - 1f;
					float value2 = Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition.y / 128f - 1f;
					if (num2 > 0.4f && num2 > Math.Abs(value2))
					{
						return true;
					}
				}
				return false;
			case 1:
				if (Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition != Vector2.zero)
				{
					float num = Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition.x / 128f - 1f;
					float value = Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition.y / 128f - 1f;
					if (num > 0.4f && num > Math.Abs(value))
					{
						return true;
					}
				}
				return false;
			default:
				return false;
			}
		}

		public static ControllerState UPvr_GetControllerState(int hand)
		{
			return hand switch
			{
				0 => (ControllerState)Convert.ToInt16(Pvr_ControllerManager.controllerlink.controller0Connected), 
				1 => (ControllerState)Convert.ToInt16(Pvr_ControllerManager.controllerlink.controller1Connected), 
				_ => ControllerState.Error, 
			};
		}

		public static Quaternion UPvr_GetControllerQUA(int hand)
		{
			return hand switch
			{
				0 => Pvr_ControllerManager.controllerlink.Controller0.Rotation, 
				1 => Pvr_ControllerManager.controllerlink.Controller1.Rotation, 
				_ => new Quaternion(0f, 0f, 0f, 1f), 
			};
		}

		public static Vector3 UPvr_GetControllerPOS(int hand)
		{
			return hand switch
			{
				0 => Pvr_ControllerManager.controllerlink.Controller0.Position, 
				1 => Pvr_ControllerManager.controllerlink.Controller1.Position, 
				_ => new Vector3(0f, 0f, 0f), 
			};
		}

		public static Quaternion UPvr_GetControllerPredictRotation(int hand, float predictTime)
		{
			float[] controllerPredictSensorData = Pvr_ControllerManager.controllerlink.GetControllerPredictSensorData(hand, predictTime);
			return new Quaternion(controllerPredictSensorData[0], controllerPredictSensorData[1], controllerPredictSensorData[2], controllerPredictSensorData[3]);
		}

		public static Vector3 UPvr_GetControllerPredictPosition(int hand, float predictTime)
		{
			float[] controllerPredictSensorData = Pvr_ControllerManager.controllerlink.GetControllerPredictSensorData(hand, predictTime);
			return new Vector3(controllerPredictSensorData[4] / 1000f, controllerPredictSensorData[5] / 1000f, (0f - controllerPredictSensorData[6]) / 1000f);
		}

		public static int UPvr_GetControllerTriggerValue(int hand)
		{
			return hand switch
			{
				0 => Pvr_ControllerManager.controllerlink.Controller0.TriggerNum, 
				1 => Pvr_ControllerManager.controllerlink.Controller1.TriggerNum, 
				_ => 0, 
			};
		}

		public static int UPvr_GetControllerPower(int hand)
		{
			return hand switch
			{
				0 => Pvr_ControllerManager.controllerlink.Controller0.Battery, 
				1 => Pvr_ControllerManager.controllerlink.Controller1.Battery, 
				_ => 0, 
			};
		}

		public static int UPvr_GetControllerPowerByPercent(int hand)
		{
			return hand switch
			{
				0 => Pvr_ControllerManager.controllerlink.Controller0.Battery * 20, 
				1 => Pvr_ControllerManager.controllerlink.Controller1.Battery * 20, 
				_ => 0, 
			};
		}

		public static SwipeDirection UPvr_GetSwipeDirection(int hand)
		{
			return hand switch
			{
				0 => Pvr_ControllerManager.controllerlink.Controller0.SwipeDirection, 
				1 => Pvr_ControllerManager.controllerlink.Controller1.SwipeDirection, 
				_ => SwipeDirection.No, 
			};
		}

		public static TouchPadClick UPvr_GetTouchPadClick(int hand)
		{
			return hand switch
			{
				0 => Pvr_ControllerManager.controllerlink.Controller0.TouchPadClick, 
				1 => Pvr_ControllerManager.controllerlink.Controller1.TouchPadClick, 
				_ => TouchPadClick.No, 
			};
		}

		public static bool UPvr_GetKey(int hand, Pvr_KeyCode key)
		{
			bool flag = false;
			if (hand == 0)
			{
				if ((Pvr_KeyCode.APP & key) == Pvr_KeyCode.APP)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.App.State;
				}
				if ((Pvr_KeyCode.HOME & key) == Pvr_KeyCode.HOME)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Home.State;
				}
				if ((Pvr_KeyCode.TOUCHPAD & key) == Pvr_KeyCode.TOUCHPAD)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Touch.State;
				}
				if ((Pvr_KeyCode.VOLUMEUP & key) == Pvr_KeyCode.VOLUMEUP)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.VolumeUp.State;
				}
				if ((Pvr_KeyCode.VOLUMEDOWN & key) == Pvr_KeyCode.VOLUMEDOWN)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.VolumeDown.State;
				}
				if ((Pvr_KeyCode.TRIGGER & key) == Pvr_KeyCode.TRIGGER)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Trigger.State;
				}
				if ((Pvr_KeyCode.X & key) == Pvr_KeyCode.X)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.X.State;
				}
				if ((Pvr_KeyCode.Y & key) == Pvr_KeyCode.Y)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Y.State;
				}
				if ((Pvr_KeyCode.Left & key) == Pvr_KeyCode.Left)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Left.State;
				}
			}
			if (hand == 1)
			{
				if ((Pvr_KeyCode.APP & key) == Pvr_KeyCode.APP)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.App.State;
				}
				if ((Pvr_KeyCode.HOME & key) == Pvr_KeyCode.HOME)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Home.State;
				}
				if ((Pvr_KeyCode.TOUCHPAD & key) == Pvr_KeyCode.TOUCHPAD)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Touch.State;
				}
				if ((Pvr_KeyCode.VOLUMEUP & key) == Pvr_KeyCode.VOLUMEUP)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.VolumeUp.State;
				}
				if ((Pvr_KeyCode.VOLUMEDOWN & key) == Pvr_KeyCode.VOLUMEDOWN)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.VolumeDown.State;
				}
				if ((Pvr_KeyCode.TRIGGER & key) == Pvr_KeyCode.TRIGGER)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Trigger.State;
				}
				if ((Pvr_KeyCode.A & key) == Pvr_KeyCode.A)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.A.State;
				}
				if ((Pvr_KeyCode.B & key) == Pvr_KeyCode.B)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.B.State;
				}
				if ((Pvr_KeyCode.Right & key) == Pvr_KeyCode.Right)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Right.State;
				}
			}
			return flag;
		}

		public static bool UPvr_GetKeyDown(int hand, Pvr_KeyCode key)
		{
			bool flag = false;
			if (hand == 0)
			{
				if ((Pvr_KeyCode.APP & key) == Pvr_KeyCode.APP)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.App.PressedDown;
				}
				if ((Pvr_KeyCode.HOME & key) == Pvr_KeyCode.HOME)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Home.PressedDown;
				}
				if ((Pvr_KeyCode.TOUCHPAD & key) == Pvr_KeyCode.TOUCHPAD)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Touch.PressedDown;
				}
				if ((Pvr_KeyCode.VOLUMEUP & key) == Pvr_KeyCode.VOLUMEUP)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.VolumeUp.PressedDown;
				}
				if ((Pvr_KeyCode.VOLUMEDOWN & key) == Pvr_KeyCode.VOLUMEDOWN)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.VolumeDown.PressedDown;
				}
				if ((Pvr_KeyCode.TRIGGER & key) == Pvr_KeyCode.TRIGGER)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Trigger.PressedDown;
				}
				if ((Pvr_KeyCode.X & key) == Pvr_KeyCode.X)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.X.PressedDown;
				}
				if ((Pvr_KeyCode.Y & key) == Pvr_KeyCode.Y)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Y.PressedDown;
				}
				if ((Pvr_KeyCode.Left & key) == Pvr_KeyCode.Left)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Left.PressedDown;
				}
			}
			if (hand == 1)
			{
				if ((Pvr_KeyCode.APP & key) == Pvr_KeyCode.APP)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.App.PressedDown;
				}
				if ((Pvr_KeyCode.HOME & key) == Pvr_KeyCode.HOME)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Home.PressedDown;
				}
				if ((Pvr_KeyCode.TOUCHPAD & key) == Pvr_KeyCode.TOUCHPAD)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Touch.PressedDown;
				}
				if ((Pvr_KeyCode.VOLUMEUP & key) == Pvr_KeyCode.VOLUMEUP)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.VolumeUp.PressedDown;
				}
				if ((Pvr_KeyCode.VOLUMEDOWN & key) == Pvr_KeyCode.VOLUMEDOWN)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.VolumeDown.PressedDown;
				}
				if ((Pvr_KeyCode.TRIGGER & key) == Pvr_KeyCode.TRIGGER)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Trigger.PressedDown;
				}
				if ((Pvr_KeyCode.A & key) == Pvr_KeyCode.A)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.A.PressedDown;
				}
				if ((Pvr_KeyCode.B & key) == Pvr_KeyCode.B)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.B.PressedDown;
				}
				if ((Pvr_KeyCode.Right & key) == Pvr_KeyCode.Right)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Right.PressedDown;
				}
			}
			return flag;
		}

		public static bool UPvr_GetKeyUp(int hand, Pvr_KeyCode key)
		{
			bool flag = false;
			if (hand == 0)
			{
				if ((Pvr_KeyCode.APP & key) == Pvr_KeyCode.APP)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.App.PressedUp;
				}
				if ((Pvr_KeyCode.HOME & key) == Pvr_KeyCode.HOME)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Home.PressedUp;
				}
				if ((Pvr_KeyCode.TOUCHPAD & key) == Pvr_KeyCode.TOUCHPAD)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Touch.PressedUp;
				}
				if ((Pvr_KeyCode.VOLUMEUP & key) == Pvr_KeyCode.VOLUMEUP)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.VolumeUp.PressedUp;
				}
				if ((Pvr_KeyCode.VOLUMEDOWN & key) == Pvr_KeyCode.VOLUMEDOWN)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.VolumeDown.PressedUp;
				}
				if ((Pvr_KeyCode.TRIGGER & key) == Pvr_KeyCode.TRIGGER)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Trigger.PressedUp;
				}
				if ((Pvr_KeyCode.X & key) == Pvr_KeyCode.X)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.X.PressedUp;
				}
				if ((Pvr_KeyCode.Y & key) == Pvr_KeyCode.Y)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Y.PressedUp;
				}
				if ((Pvr_KeyCode.Left & key) == Pvr_KeyCode.Left)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Left.PressedUp;
				}
			}
			if (hand == 1)
			{
				if ((Pvr_KeyCode.APP & key) == Pvr_KeyCode.APP)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.App.PressedUp;
				}
				if ((Pvr_KeyCode.HOME & key) == Pvr_KeyCode.HOME)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Home.PressedUp;
				}
				if ((Pvr_KeyCode.TOUCHPAD & key) == Pvr_KeyCode.TOUCHPAD)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Touch.PressedUp;
				}
				if ((Pvr_KeyCode.VOLUMEUP & key) == Pvr_KeyCode.VOLUMEUP)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.VolumeUp.PressedUp;
				}
				if ((Pvr_KeyCode.VOLUMEDOWN & key) == Pvr_KeyCode.VOLUMEDOWN)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.VolumeDown.PressedUp;
				}
				if ((Pvr_KeyCode.TRIGGER & key) == Pvr_KeyCode.TRIGGER)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Trigger.PressedUp;
				}
				if ((Pvr_KeyCode.A & key) == Pvr_KeyCode.A)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.A.PressedUp;
				}
				if ((Pvr_KeyCode.B & key) == Pvr_KeyCode.B)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.B.PressedUp;
				}
				if ((Pvr_KeyCode.Right & key) == Pvr_KeyCode.Right)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Right.PressedUp;
				}
			}
			return flag;
		}

		public static bool UPvr_GetTouch(int hand, Pvr_KeyCode key)
		{
			bool flag = false;
			if (hand == 0)
			{
				if ((Pvr_KeyCode.TOUCHPAD & key) == Pvr_KeyCode.TOUCHPAD)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Touch.Touch;
				}
				if ((Pvr_KeyCode.TRIGGER & key) == Pvr_KeyCode.TRIGGER)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Trigger.Touch;
				}
				if ((Pvr_KeyCode.X & key) == Pvr_KeyCode.X)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.X.Touch;
				}
				if ((Pvr_KeyCode.Y & key) == Pvr_KeyCode.Y)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Y.Touch;
				}
				if ((Pvr_KeyCode.Thumbrest & key) == Pvr_KeyCode.Thumbrest)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Thumbrest.Touch;
				}
			}
			if (hand == 1)
			{
				if ((Pvr_KeyCode.TOUCHPAD & key) == Pvr_KeyCode.TOUCHPAD)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Touch.Touch;
				}
				if ((Pvr_KeyCode.TRIGGER & key) == Pvr_KeyCode.TRIGGER)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Trigger.Touch;
				}
				if ((Pvr_KeyCode.A & key) == Pvr_KeyCode.A)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.A.Touch;
				}
				if ((Pvr_KeyCode.B & key) == Pvr_KeyCode.B)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.B.Touch;
				}
				if ((Pvr_KeyCode.Thumbrest & key) == Pvr_KeyCode.Thumbrest)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Thumbrest.Touch;
				}
			}
			return flag;
		}

		public static bool UPvr_GetTouchDown(int hand, Pvr_KeyCode key)
		{
			bool flag = false;
			if (hand == 0)
			{
				if ((Pvr_KeyCode.TOUCHPAD & key) == Pvr_KeyCode.TOUCHPAD)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Touch.TouchDown;
				}
				if ((Pvr_KeyCode.TRIGGER & key) == Pvr_KeyCode.TRIGGER)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Trigger.TouchDown;
				}
				if ((Pvr_KeyCode.X & key) == Pvr_KeyCode.X)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.X.TouchDown;
				}
				if ((Pvr_KeyCode.Y & key) == Pvr_KeyCode.Y)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Y.TouchDown;
				}
				if ((Pvr_KeyCode.Thumbrest & key) == Pvr_KeyCode.Thumbrest)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Thumbrest.TouchDown;
				}
			}
			if (hand == 1)
			{
				if ((Pvr_KeyCode.TOUCHPAD & key) == Pvr_KeyCode.TOUCHPAD)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Touch.TouchDown;
				}
				if ((Pvr_KeyCode.TRIGGER & key) == Pvr_KeyCode.TRIGGER)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Trigger.TouchDown;
				}
				if ((Pvr_KeyCode.A & key) == Pvr_KeyCode.A)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.A.TouchDown;
				}
				if ((Pvr_KeyCode.B & key) == Pvr_KeyCode.B)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.B.TouchDown;
				}
				if ((Pvr_KeyCode.Thumbrest & key) == Pvr_KeyCode.Thumbrest)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Thumbrest.TouchDown;
				}
			}
			return flag;
		}

		public static bool UPvr_GetTouchUp(int hand, Pvr_KeyCode key)
		{
			bool flag = false;
			if (hand == 0)
			{
				if ((Pvr_KeyCode.TOUCHPAD & key) == Pvr_KeyCode.TOUCHPAD)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Touch.TouchUp;
				}
				if ((Pvr_KeyCode.TRIGGER & key) == Pvr_KeyCode.TRIGGER)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Trigger.TouchUp;
				}
				if ((Pvr_KeyCode.X & key) == Pvr_KeyCode.X)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.X.TouchUp;
				}
				if ((Pvr_KeyCode.Y & key) == Pvr_KeyCode.Y)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Y.TouchUp;
				}
				if ((Pvr_KeyCode.Thumbrest & key) == Pvr_KeyCode.Thumbrest)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Thumbrest.TouchUp;
				}
			}
			if (hand == 1)
			{
				if ((Pvr_KeyCode.TOUCHPAD & key) == Pvr_KeyCode.TOUCHPAD)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Touch.TouchUp;
				}
				if ((Pvr_KeyCode.TRIGGER & key) == Pvr_KeyCode.TRIGGER)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Trigger.TouchUp;
				}
				if ((Pvr_KeyCode.A & key) == Pvr_KeyCode.A)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.A.TouchUp;
				}
				if ((Pvr_KeyCode.B & key) == Pvr_KeyCode.B)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.B.TouchUp;
				}
				if ((Pvr_KeyCode.Thumbrest & key) == Pvr_KeyCode.Thumbrest)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Thumbrest.TouchUp;
				}
			}
			return flag;
		}

		public static bool UPvr_GetKeyClick(int hand, Pvr_KeyCode key)
		{
			bool flag = false;
			if (hand == 0)
			{
				if ((Pvr_KeyCode.APP & key) == Pvr_KeyCode.APP)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.App.Click;
				}
				if ((Pvr_KeyCode.HOME & key) == Pvr_KeyCode.HOME)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Home.Click;
				}
				if ((Pvr_KeyCode.TOUCHPAD & key) == Pvr_KeyCode.TOUCHPAD)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Touch.Click;
				}
				if ((Pvr_KeyCode.VOLUMEUP & key) == Pvr_KeyCode.VOLUMEUP)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.VolumeUp.Click;
				}
				if ((Pvr_KeyCode.VOLUMEDOWN & key) == Pvr_KeyCode.VOLUMEDOWN)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.VolumeDown.Click;
				}
				if ((Pvr_KeyCode.TRIGGER & key) == Pvr_KeyCode.TRIGGER)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Trigger.Click;
				}
				if ((Pvr_KeyCode.X & key) == Pvr_KeyCode.X)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.X.Click;
				}
				if ((Pvr_KeyCode.Y & key) == Pvr_KeyCode.Y)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Y.Click;
				}
				if ((Pvr_KeyCode.Left & key) == Pvr_KeyCode.Left)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Left.Click;
				}
			}
			if (hand == 1)
			{
				if ((Pvr_KeyCode.APP & key) == Pvr_KeyCode.APP)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.App.Click;
				}
				if ((Pvr_KeyCode.HOME & key) == Pvr_KeyCode.HOME)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Home.Click;
				}
				if ((Pvr_KeyCode.TOUCHPAD & key) == Pvr_KeyCode.TOUCHPAD)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Touch.Click;
				}
				if ((Pvr_KeyCode.VOLUMEUP & key) == Pvr_KeyCode.VOLUMEUP)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.VolumeUp.Click;
				}
				if ((Pvr_KeyCode.VOLUMEDOWN & key) == Pvr_KeyCode.VOLUMEDOWN)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.VolumeDown.Click;
				}
				if ((Pvr_KeyCode.TRIGGER & key) == Pvr_KeyCode.TRIGGER)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Trigger.Click;
				}
				if ((Pvr_KeyCode.A & key) == Pvr_KeyCode.A)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.A.Click;
				}
				if ((Pvr_KeyCode.B & key) == Pvr_KeyCode.B)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.B.Click;
				}
				if ((Pvr_KeyCode.Right & key) == Pvr_KeyCode.Right)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Right.Click;
				}
			}
			return flag;
		}

		public static bool UPvr_GetKeyLongPressed(int hand, Pvr_KeyCode key)
		{
			bool flag = false;
			if (hand == 0)
			{
				if ((Pvr_KeyCode.APP & key) == Pvr_KeyCode.APP)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.App.LongPressed;
				}
				if ((Pvr_KeyCode.HOME & key) == Pvr_KeyCode.HOME)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Home.LongPressed;
				}
				if ((Pvr_KeyCode.TOUCHPAD & key) == Pvr_KeyCode.TOUCHPAD)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Touch.LongPressed;
				}
				if ((Pvr_KeyCode.VOLUMEUP & key) == Pvr_KeyCode.VOLUMEUP)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.VolumeUp.LongPressed;
				}
				if ((Pvr_KeyCode.VOLUMEDOWN & key) == Pvr_KeyCode.VOLUMEDOWN)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.VolumeDown.LongPressed;
				}
				if ((Pvr_KeyCode.TRIGGER & key) == Pvr_KeyCode.TRIGGER)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Trigger.LongPressed;
				}
				if ((Pvr_KeyCode.X & key) == Pvr_KeyCode.X)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.X.LongPressed;
				}
				if ((Pvr_KeyCode.Y & key) == Pvr_KeyCode.Y)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Y.LongPressed;
				}
				if ((Pvr_KeyCode.Left & key) == Pvr_KeyCode.Left)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Left.LongPressed;
				}
			}
			if (hand == 1)
			{
				if ((Pvr_KeyCode.APP & key) == Pvr_KeyCode.APP)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.App.LongPressed;
				}
				if ((Pvr_KeyCode.HOME & key) == Pvr_KeyCode.HOME)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Home.LongPressed;
				}
				if ((Pvr_KeyCode.TOUCHPAD & key) == Pvr_KeyCode.TOUCHPAD)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Touch.LongPressed;
				}
				if ((Pvr_KeyCode.VOLUMEUP & key) == Pvr_KeyCode.VOLUMEUP)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.VolumeUp.LongPressed;
				}
				if ((Pvr_KeyCode.VOLUMEDOWN & key) == Pvr_KeyCode.VOLUMEDOWN)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.VolumeDown.LongPressed;
				}
				if ((Pvr_KeyCode.TRIGGER & key) == Pvr_KeyCode.TRIGGER)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Trigger.LongPressed;
				}
				if ((Pvr_KeyCode.A & key) == Pvr_KeyCode.A)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.A.LongPressed;
				}
				if ((Pvr_KeyCode.B & key) == Pvr_KeyCode.B)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.B.LongPressed;
				}
				if ((Pvr_KeyCode.Right & key) == Pvr_KeyCode.Right)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Right.LongPressed;
				}
			}
			return flag;
		}

		public static bool UPvr_IsTouching(int hand)
		{
			switch (hand)
			{
			case 0:
				if (!(Math.Abs(Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition.x) > 0f))
				{
					return Math.Abs(Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition.y) > 0f;
				}
				return true;
			case 1:
				if (!(Math.Abs(Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition.x) > 0f))
				{
					return Math.Abs(Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition.y) > 0f;
				}
				return true;
			default:
				return false;
			}
		}

		public static void UPvr_SetHandNess(Pvr_Controller.UserHandNess hand)
		{
			if (Pvr_ControllerManager.controllerlink.getHandness() != (int)hand)
			{
				Pvr_ControllerManager.controllerlink.setHandness((int)hand);
			}
		}

		public static Pvr_Controller.UserHandNess UPvr_GetHandNess()
		{
			return Pvr_ControllerManager.controllerlink.handness;
		}

		public static int UPvr_GetPreferenceDevice()
		{
			int trackingmode = Pvr_ControllerManager.controllerlink.trackingmode;
			int systemProp = Pvr_ControllerManager.controllerlink.systemProp;
			if (trackingmode == 0 || trackingmode == 1 || ((trackingmode == 3 || trackingmode == 5 || trackingmode == 6) && (systemProp == 1 || systemProp == 3)))
			{
				return 1;
			}
			return 2;
		}

		public static bool UPvr_IsEnbleTrigger()
		{
			return Pvr_ControllerManager.controllerlink.IsEnbleTrigger();
		}

		public static int UPvr_GetDeviceType()
		{
			return Pvr_ControllerManager.controllerlink.controllerType;
		}

		public static int UPvr_GetMainHandNess()
		{
			return Pvr_ControllerManager.controllerlink.mainHandID;
		}

		public static void UPvr_SetMainHandNess(int hand)
		{
			Pvr_ControllerManager.controllerlink.SetMainController(hand);
		}

		public static int UPvr_GetControllerAbility(int hand)
		{
			return Pvr_ControllerManager.controllerlink.GetControllerAbility(hand);
		}

		public static void UPvr_VibrateNeo2Controller(float strength, int time, int hand)
		{
			Pvr_ControllerManager.controllerlink.VibrateNeo2Controller(strength, time, hand);
		}

		public static void UPvr_VibrateController(float strength, int time, int hand)
		{
			Pvr_ControllerManager.controllerlink.VibrateController(strength, time, hand);
		}

		public static int UPvr_GetControllerBindingState(int hand)
		{
			return Pvr_ControllerManager.controllerlink.GetControllerBindingState(hand);
		}

		public static Vector3 UPvr_GetVelocity(int hand)
		{
			return Pvr_ControllerManager.controllerlink.GetVelocity(hand);
		}

		public static Vector3 UPvr_GetAngularVelocity(int hand)
		{
			return Pvr_ControllerManager.controllerlink.GetAngularVelocity(hand);
		}

		public static Vector3 UPvr_GetAcceleration(int hand)
		{
			return Pvr_ControllerManager.controllerlink.GetAcceleration(hand);
		}

		public static void UPvr_ScanController()
		{
			Pvr_ControllerManager.controllerlink.StartScan();
		}

		public static void UPvr_StopScanController()
		{
			Pvr_ControllerManager.controllerlink.StopScan();
		}

		public static void UPvr_ConnectController(string mac)
		{
			if (mac != "")
			{
				Pvr_ControllerManager.controllerlink.hummingBirdMac = mac;
			}
			Pvr_ControllerManager.controllerlink.ConnectBLE();
		}

		public static void UPvr_DisConnectController()
		{
			Pvr_ControllerManager.controllerlink.DisConnectBLE();
		}

		public static void UPvr_ResetController(int hand)
		{
			Pvr_ControllerManager.controllerlink.ResetController(hand);
		}

		public static string UPvr_GetControllerVersion()
		{
			return Pvr_ControllerManager.controllerlink.GetControllerVersion();
		}

		public static void UPvr_GetDeviceVersion(int deviceType)
		{
			Pvr_ControllerManager.controllerlink.GetDeviceVersion(deviceType);
		}

		public static void UPvr_GetControllerSnCode(int controllerSerialNum)
		{
			Pvr_ControllerManager.controllerlink.GetControllerSnCode(controllerSerialNum);
		}

		public static void UPvr_SetControllerUnbind(int controllerSerialNum)
		{
			Pvr_ControllerManager.controllerlink.SetControllerUnbind(controllerSerialNum);
		}

		public static void UPvr_SetStationRestart()
		{
			Pvr_ControllerManager.controllerlink.SetStationRestart();
		}

		public static void UPvr_StartStationOtaUpdate()
		{
			Pvr_ControllerManager.controllerlink.StartStationOtaUpdate();
		}

		public static void UPvr_StartControllerOtaUpdate(int mode, int controllerSerialNum)
		{
			Pvr_ControllerManager.controllerlink.StartControllerOtaUpdate(mode, controllerSerialNum);
		}

		public static void UPvr_EnterPairMode(int controllerSerialNum)
		{
			Pvr_ControllerManager.controllerlink.EnterPairMode(controllerSerialNum);
		}

		public static void UPvr_SetControllerShutdown(int controllerSerialNum)
		{
			Pvr_ControllerManager.controllerlink.SetControllerShutdown(controllerSerialNum);
		}

		public static int UPvr_GetStationPairState()
		{
			return Pvr_ControllerManager.controllerlink.GetStationPairState();
		}

		public static int UPvr_GetStationOtaUpdateProgress()
		{
			return Pvr_ControllerManager.controllerlink.GetStationOtaUpdateProgress();
		}

		public static int UPvr_GetControllerOtaUpdateProgress()
		{
			return Pvr_ControllerManager.controllerlink.GetControllerOtaUpdateProgress();
		}

		public static void UPvr_GetControllerVersionAndSN(int controllerSerialNum)
		{
			Pvr_ControllerManager.controllerlink.GetControllerVersionAndSN(controllerSerialNum);
		}

		public static void UPvr_GetControllerUniqueID()
		{
			Pvr_ControllerManager.controllerlink.GetControllerUniqueID();
		}

		public void UPvr_InterruptStationPairMode()
		{
			Pvr_ControllerManager.controllerlink.InterruptStationPairMode();
		}

		public void UPvr_StartCV2PairingMode(int deviceType)
		{
			Pvr_ControllerManager.controllerlink.StartCV2PairingMode(deviceType);
		}

		public void UPvr_StopCV2PairingMode(int deviceType)
		{
			Pvr_ControllerManager.controllerlink.StopCV2PairingMode(deviceType);
		}

		public static void UPvr_SetArmModelParameters(int hand, int gazeType, float elbowHeight, float elbowDepth, float pointerTiltAngle)
		{
			Pvr_SetArmModelParameters(hand, gazeType, elbowHeight, elbowDepth, pointerTiltAngle);
		}

		public static void UPvr_CalcArmModelParameters(float[] headOrientation, float[] controllerOrientation, float[] controllerPrimary)
		{
			Pvr_CalcArmModelParameters(headOrientation, controllerOrientation, controllerPrimary);
		}

		public static void UPvr_GetPointerPose(float[] rotation, float[] position)
		{
			Pvr_GetPointerPose(rotation, position);
		}

		public static void UPvr_GetElbowPose(float[] rotation, float[] position)
		{
			Pvr_GetElbowPose(rotation, position);
		}

		public static void UPvr_GetWristPose(float[] rotation, float[] position)
		{
			Pvr_GetWristPose(rotation, position);
		}

		public static void UPvr_GetShoulderPose(float[] rotation, float[] position)
		{
			Pvr_GetShoulderPose(rotation, position);
		}

		public static void UPvr_IsEnbleHomeKey(bool state)
		{
			Pvr_ControllerManager.controllerlink.setIsEnbleHomeKey(state);
		}

		public static void UPvr_SwitchHomeKey(bool state)
		{
			Pvr_ControllerManager.controllerlink.SwitchHomeKey(state);
		}

		public static int UPvr_GetControllerSensorStatus(int id)
		{
			return Pvr_ControllerManager.controllerlink.getControllerSensorStatus(id);
		}

		public static void UPvr_SetControllerOriginOffset(int hand, Vector3 offset)
		{
			switch (hand)
			{
			case 0:
				Pvr_Controller.originOffsetL = offset;
				break;
			case 1:
				Pvr_Controller.originOffsetR = offset;
				break;
			}
		}

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_CalcArmModelParameters(float[] headOrientation, float[] controllerOrientation, float[] gyro);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_GetPointerPose(float[] rotation, float[] position);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_GetElbowPose(float[] rotation, float[] position);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_GetWristPose(float[] rotation, float[] position);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_GetShoulderPose(float[] rotation, float[] position);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetArmModelParameters(int hand, int gazeType, float elbowHeight, float elbowDepth, float pointerTiltAngle);
	}
	public enum ControllerVariety
	{
		Controller0,
		Controller1
	}
	public enum ControllerDevice
	{
		Goblin,
		Neo,
		G2,
		Neo2,
		Neo3,
		NewController
	}
	public enum PBS_SystemInfoEnum
	{
		ELECTRIC_QUANTITY,
		PUI_VERSION,
		EQUIPMENT_MODEL,
		EQUIPMENT_SN,
		CUSTOMER_SN,
		INTERNAL_STORAGE_SPACE_OF_THE_DEVICE,
		DEVICE_BLUETOOTH_STATUS,
		BLUETOOTH_NAME_CONNECTED,
		BLUETOOTH_MAC_ADDRESS,
		DEVICE_WIFI_STATUS,
		WIFI_NAME_CONNECTED,
		WLAN_MAC_ADDRESS,
		DEVICE_IP
	}
	public enum PBS_DeviceControlEnum
	{
		DEVICE_CONTROL_REBOOT,
		DEVICE_CONTROL_SHUTDOWN
	}
	public enum PBS_PackageControlEnum
	{
		PACKAGE_SILENCE_INSTALL,
		PACKAGE_SILENCE_UNINSTALL
	}
	public enum PBS_SwitchEnum
	{
		S_ON,
		S_OFF
	}
	public enum PBS_HomeEventEnum
	{
		SINGLE_CLICK,
		DOUBLE_CLICK,
		LONG_PRESS
	}
	public enum PBS_HomeFunctionEnum
	{
		VALUE_HOME_GO_TO_SETTING,
		VALUE_HOME_BACK,
		VALUE_HOME_RECENTER,
		VALUE_HOME_OPEN_APP,
		VALUE_HOME_DISABLE,
		VALUE_HOME_GO_TO_HOME,
		VALUE_HOME_SEND_BROADCAST,
		VALUE_HOME_CLEAN_MEMORY
	}
	public enum PBS_ScreenOffDelayTimeEnum
	{
		THREE = 3,
		TEN = 10,
		THIRTY = 30,
		SIXTY = 60,
		THREE_HUNDRED = 300,
		SIX_HUNDRED = 600,
		NEVER = -1
	}
	public enum PBS_SleepDelayTimeEnum
	{
		FIFTEEN = 15,
		THIRTY = 30,
		SIXTY = 60,
		THREE_HUNDRED = 300,
		SIX_HUNDRED = 600,
		ONE_THOUSAND_AND_EIGHT_HUNDRED = 1800,
		NEVER = -1
	}
	public enum PBS_SystemFunctionSwitchEnum
	{
		SFS_USB,
		SFS_AUTOSLEEP,
		SFS_SCREENON_CHARGING,
		SFS_OTG_CHARGING,
		SFS_RETURN_MENU_IN_2DMODE,
		SFS_COMBINATION_KEY,
		SFS_CALIBRATION_WITH_POWER_ON,
		SFS_SYSTEM_UPDATE,
		SFS_CAST_SERVICE,
		SFS_EYE_PROTECTION,
		SFS_SECURITY_ZONE_PERMANENTLY,
		SFS_GLOBAL_CALIBRATION,
		SFS_Auto_Calibration,
		SFS_USB_BOOT,
		SFS_VOLUME_UI,
		SFS_CONTROLLER_UI,
		SFS_NAVGATION_SWITCH
	}
	public enum PBS_USBConfigModeEnum
	{
		MTP,
		CHARGE
	}
	public struct ToBService
	{
		public static Action<bool> BoolCallback;

		public static Action<int> IntCallback;

		public static Action<long> LongCallback;

		private static AndroidJavaClass unityPlayer;

		private static AndroidJavaObject currentActivity;

		private static AndroidJavaObject tobHelper;

		private static AndroidJavaClass tobHelperClass;

		public static void UPvr_InitToBService()
		{
			tobHelperClass = new AndroidJavaClass("com.pvr.tobservice.ToBServiceHelper");
			tobHelper = tobHelperClass.CallStatic<AndroidJavaObject>("getInstance", Array.Empty<object>());
			unityPlayer = new AndroidJavaClass("com.unity3d.player.UnityPlayer");
			currentActivity = unityPlayer.GetStatic<AndroidJavaObject>("currentActivity");
		}

		public static void UPvr_SetUnityObjectName(string obj)
		{
			System.UPvr_CallMethod(tobHelper, "setUnityObjectName", obj);
		}

		public static void UPvr_BindToBService()
		{
			System.UPvr_CallMethod(tobHelper, "bindTobService", currentActivity);
		}

		public static void UPvr_UnBindToBService()
		{
			System.UPvr_CallMethod(tobHelper, "unBindTobService", currentActivity);
		}

		private static AndroidJavaObject GetEnumType(Enum enumType)
		{
			return new AndroidJavaClass("com.pvr.tobservice.enums" + enumType.GetType().ToString().Replace("Pvr_UnitySDKAPI", "")).GetStatic<AndroidJavaObject>(enumType.ToString());
		}

		public static string UPvr_StateGetDeviceInfo(PBS_SystemInfoEnum type)
		{
			string result = "";
			System.UPvr_CallMethod(ref result, tobHelper, "pbsStateGetDeviceInfo", GetEnumType(type), 0);
			return result;
		}

		public static void UPvr_ControlSetDeviceAction(PBS_DeviceControlEnum deviceControl, Action<int> callback)
		{
			if (callback != null)
			{
				IntCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsControlSetDeviceAction", GetEnumType(deviceControl), null);
		}

		public static void UPvr_ControlAPPManger(PBS_PackageControlEnum packageControl, string path, Action<int> callback)
		{
			if (callback != null)
			{
				IntCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsControlAPPManger", GetEnumType(packageControl), path, 0, null);
		}

		public static void UPvr_ControlSetAutoConnectWIFI(string ssid, string pwd, Action<bool> callback)
		{
			if (callback != null)
			{
				BoolCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsControlSetAutoConnectWIFI", ssid, pwd, 0, null);
		}

		public static void UPvr_ControlClearAutoConnectWIFI(Action<bool> callback)
		{
			if (callback != null)
			{
				BoolCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsControlClearAutoConnectWIFI", null);
		}

		public static void UPvr_PropertySetHomeKey(PBS_HomeEventEnum eventEnum, PBS_HomeFunctionEnum function, Action<bool> callback)
		{
			if (callback != null)
			{
				BoolCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsPropertySetHomeKey", GetEnumType(eventEnum), GetEnumType(function), null);
		}

		public static void UPvr_PropertySetHomeKeyAll(PBS_HomeEventEnum eventEnum, PBS_HomeFunctionEnum function, int timesetup, string pkg, string className, Action<bool> callback)
		{
			if (callback != null)
			{
				BoolCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsPropertySetHomeKeyAll", GetEnumType(eventEnum), GetEnumType(function), timesetup, pkg, className, null);
		}

		public static void UPvr_PropertyDisablePowerKey(bool isSingleTap, bool enable, Action<int> callback)
		{
			if (callback != null)
			{
				IntCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsPropertyDisablePowerKey", isSingleTap, enable, null);
		}

		public static void UPvr_PropertySetScreenOffDelay(PBS_ScreenOffDelayTimeEnum timeEnum, Action<int> callback)
		{
			if (callback != null)
			{
				IntCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsPropertySetScreenOffDelay", GetEnumType(timeEnum), null);
		}

		public static void UPvr_PropertySetSleepDelay(PBS_SleepDelayTimeEnum timeEnum)
		{
			System.UPvr_CallMethod(tobHelper, "pbsPropertySetSleepDelay", GetEnumType(timeEnum));
		}

		public static void UPvr_SwitchSystemFunction(PBS_SystemFunctionSwitchEnum systemFunction, PBS_SwitchEnum switchEnum)
		{
			System.UPvr_CallMethod(tobHelper, "pbsSwitchSystemFunction", GetEnumType(systemFunction), GetEnumType(switchEnum), 0);
		}

		public static void UPvr_SwitchSetUsbConfigurationOption(PBS_USBConfigModeEnum uSBConfigModeEnum)
		{
			System.UPvr_CallMethod(tobHelper, "pbsSwitchSetUsbConfigurationOption", GetEnumType(uSBConfigModeEnum), 0);
		}

		public static void UPvr_ScreenOn()
		{
			System.UPvr_CallMethod(tobHelper, "pbsScreenOn");
		}

		public static void UPvr_ScreenOff()
		{
			System.UPvr_CallMethod(tobHelper, "pbsScreenOff");
		}

		public static void UPvr_AcquireWakeLock()
		{
			System.UPvr_CallMethod(tobHelper, "pbsAcquireWakeLock");
		}

		public static void UPvr_ReleaseWakeLock()
		{
			System.UPvr_CallMethod(tobHelper, "pbsReleaseWakeLock");
		}

		public static void UPvr_EnableEnterKey()
		{
			System.UPvr_CallMethod(tobHelper, "pbsEnableEnterKey");
		}

		public static void UPvr_DisableEnterKey()
		{
			System.UPvr_CallMethod(tobHelper, "pbsDisableEnterKey");
		}

		public static void UPvr_EnableVolumeKey()
		{
			System.UPvr_CallMethod(tobHelper, "pbsEnableVolumeKey");
		}

		public static void UPvr_DisableVolumeKey()
		{
			System.UPvr_CallMethod(tobHelper, "pbsDisableVolumeKey");
		}

		public static void UPvr_EnableBackKey()
		{
			System.UPvr_CallMethod(tobHelper, "pbsEnableBackKey");
		}

		public static void UPvr_DisableBackKey()
		{
			System.UPvr_CallMethod(tobHelper, "pbsDisableBackKey");
		}

		public static void UPvr_WriteConfigFileToDataLocal(string path, string content, Action<bool> callback)
		{
			if (callback != null)
			{
				BoolCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsWriteConfigFileToDataLocal", path, content, null);
		}

		public static void UPvr_ResetAllKeyToDefault(Action<bool> callback)
		{
			if (callback != null)
			{
				BoolCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsResetAllKeyToDefault", null);
		}

		public static void UPvr_SetAPPAsHome(PBS_SwitchEnum switchEnum, string packageName)
		{
			System.UPvr_CallMethod(tobHelper, "pbsAppSetAPPAsHomeTwo", GetEnumType(switchEnum), packageName);
		}
	}
	public enum GlobalIntConfigs
	{
		EYE_TEXTURE_RESOLUTION0,
		EYE_TEXTURE_RESOLUTION1,
		SEENSOR_COUNT,
		ABILITY6DOF,
		PLATFORM_TYPE,
		TRACKING_MODE,
		LOG_LEVEL,
		ENBLE_HAND6DOF_BY_HEAD,
		ENBLE_6DOF_GLOBAL_TRACKING,
		TARGET_FRAME_RATE,
		iShowFPS,
		SensorMode,
		LOGICFLOW,
		EYE_TEXTURE_RES_HIGH,
		EYE_TEXTURE_RES_NORMAL,
		iCtrlModelLoadingPri,
		iPhoneHMDModeEnabled,
		isEnableBoundary,
		Enable_Activity_Rotation,
		GetDisplay_Orientation,
		GetWaitFrameNum,
		GetResetFrameNum,
		EnableFFRBYSYS,
		RotControllerMode
	}
	public enum GlobalFloatConfigs
	{
		IPD,
		VFOV,
		HFOV,
		NECK_MODEL_X,
		NECK_MODEL_Y,
		NECK_MODEL_Z,
		DISPLAY_REFRESH_RATE
	}
	public enum RenderTextureAntiAliasing
	{
		X_1 = 1,
		X_2 = 2,
		X_4 = 4,
		X_8 = 8
	}
	public enum PlatForm
	{
		Android = 1,
		IOS,
		Win,
		Notsupport
	}
	public enum RenderTextureDepth
	{
		BD_0 = 0,
		BD_16 = 16,
		BD_24 = 24
	}
	public enum RenderTextureLevel
	{
		Normal,
		High
	}
	public enum Sensorindex
	{
		Default,
		FirstSensor,
		SecondSensor
	}
	public enum Eye
	{
		LeftEye,
		RightEye,
		BothEye
	}
	public enum ResUtilsType
	{
		TYPE_TEXTSIZE,
		TYPE_COLOR,
		TYPE_TEXT,
		TYPE_FONT,
		TYPE_VALUE,
		TYPE_DRAWABLE,
		TYPE_OBJECT,
		TYPR_OBJECTARRAY
	}
	public enum TrackingOrigin
	{
		EyeLevel,
		FloorLevel,
		StageLevel
	}
	public enum EFoveationLevel
	{
		Low,
		Med,
		High,
		Top_High
	}
	public enum StereoRenderingPathPico
	{
		MultiPass,
		SinglePass
	}
	public enum ExtraLatencyMode
	{
		ExtraLatencyModeOff,
		ExtraLatencyModeOn,
		ExtraLatencyModeDynamic
	}
	public enum pvrEyePoseStatus
	{
		kGazePointValid = 1,
		kGazeVectorValid = 2,
		kEyeOpennessValid = 4,
		kEyePupilDilationValid = 8,
		kEyePositionGuideValid = 0x10
	}
	public enum TrackingMode
	{
		PVR_TRACKING_MODE_ROTATION = 1,
		PVR_TRACKING_MODE_POSITION = 2,
		PVR_TRACKING_MODE_EYE = 4
	}
	public struct EyeTrackingData
	{
		public int leftEyePoseStatus;

		public int rightEyePoseStatus;

		public int combinedEyePoseStatus;

		public Vector3 leftEyeGazePoint;

		public Vector3 rightEyeGazePoint;

		public Vector3 combinedEyeGazePoint;

		public Vector3 leftEyeGazeVector;

		public Vector3 rightEyeGazeVector;

		public Vector3 combinedEyeGazeVector;

		public float leftEyeOpenness;

		public float rightEyeOpenness;

		public float leftEyePupilDilation;

		public float rightEyePupilDilation;

		public Vector3 leftEyePositionGuide;

		public Vector3 rightEyePositionGuide;

		public Vector3 foveatedGazeDirection;

		public int foveatedGazeTrackingState;

		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 8)]
		public byte[] reserved;
	}
	public struct EyeTrackingGazeRay
	{
		public Vector3 Direction;

		public bool IsValid;

		public Vector3 Origin;
	}
	public struct EyeDeviceInfo
	{
		public ViewFrustum targetFrustumLeft;

		public ViewFrustum targetFrustumRight;
	}
	public struct ViewFrustum
	{
		public float left;

		public float right;

		public float top;

		public float bottom;

		public float near;

		public float far;
	}
	public struct EyeSetting
	{
		public Transform eyelocalPosition;

		public Rect eyeRect;

		public float eyeFov;

		public float eyeAspect;

		public Matrix4x4 eyeProjectionMatrix;

		public Shader eyeShader;
	}
	public struct Sensor
	{
		public const string LibFileName = "Pvr_UnitySDK";

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_Enable6DofModule(bool enable);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_OptionalResetSensor(int index, int resetRot, int resetPos);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_Init(int index);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_StartSensor(int index);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_StopSensor(int index);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_ResetSensor(int index);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_ResetSensorAll(int index);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetSensorState(int index, ref float x, ref float y, ref float z, ref float w, ref float px, ref float py, ref float pz);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetMainSensorState(ref float x, ref float y, ref float z, ref float w, ref float px, ref float py, ref float pz, ref float vfov, ref float hfov, ref int viewNumber);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetPsensorState();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetHmdPSensorStatus();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetSensorGyroscope(int index, ref float x, ref float y, ref float z);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetSensorMagnet(int index, ref float x, ref float y, ref float z);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_Get6DofSensorQualityStatus();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_Get6DofSafePanelFlag();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetReinPosition(float x, float y, float z, float w, float px, float py, float pz, int hand, bool valid, int key);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_SetTrackingOriginType(TrackingOrigin trackingOriginType);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_GetAcceleration(ref float x, ref float y, ref float z);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_GetAngularVelocity(ref float x, ref float y, ref float z);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_GetVelocity(ref float x, ref float y, ref float z);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_GetAngularAcceleration(ref float x, ref float y, ref float z);

		public static bool UPvr_Pvr_Get6DofSafePanelFlag()
		{
			return Pvr_Get6DofSafePanelFlag();
		}

		public static int UPvr_Init(int index)
		{
			return Pvr_Init(index);
		}

		public static void UPvr_InitPsensor()
		{
			Pvr_InitPsensor();
		}

		public static int UPvr_GetPsensorState()
		{
			int res = -1;
			Render.UPvr_GetIntConfig(4, ref res);
			if (res == 1)
			{
				return Pvr_GetPsensorState();
			}
			int num = Pvr_GetAndroidPsensorState();
			if (num != 0 && num != -1)
			{
				num = 1;
			}
			return num;
		}

		public static int UPvr_GetPSensorStatus()
		{
			return Pvr_GetHmdPSensorStatus();
		}

		public static void UPvr_UnregisterPsensor()
		{
			Pvr_UnregisterPsensor();
		}

		public static int UPvr_StartSensor(int index)
		{
			return Pvr_StartSensor(index);
		}

		public static int UPvr_StopSensor(int index)
		{
			return Pvr_StopSensor(index);
		}

		public static int UPvr_ResetSensor(int index)
		{
			Pvr_UnitySDKManager.SDK.resetBasePos = default(Vector3);
			return Pvr_ResetSensor(index);
		}

		public static int UPvr_OptionalResetSensor(int index, int resetRot, int resetPos)
		{
			return Pvr_OptionalResetSensor(index, resetRot, resetPos);
		}

		public static int UPvr_GetSensorState(int index, ref float x, ref float y, ref float z, ref float w, ref float px, ref float py, ref float pz)
		{
			return Pvr_GetSensorState(index, ref x, ref y, ref z, ref w, ref px, ref py, ref pz);
		}

		public static int UPvr_GetMainSensorState(ref float x, ref float y, ref float z, ref float w, ref float px, ref float py, ref float pz, ref float vfov, ref float hfov, ref int viewNumber)
		{
			return Pvr_GetMainSensorState(ref x, ref y, ref z, ref w, ref px, ref py, ref pz, ref vfov, ref hfov, ref viewNumber);
		}

		public static int UPvr_GetSensorGyroscope(int index, ref float x, ref float y, ref float z)
		{
			return Pvr_GetSensorGyroscope(index, ref x, ref y, ref z);
		}

		public static int UPvr_GetSensorMagnet(int index, ref float x, ref float y, ref float z)
		{
			return Pvr_GetSensorMagnet(index, ref x, ref y, ref z);
		}

		public static int UPvr_Get6DofSensorQualityStatus()
		{
			return Pvr_Get6DofSensorQualityStatus();
		}

		public static int UPvr_Enable6DofModule(bool enable)
		{
			return Pvr_Enable6DofModule(enable);
		}

		public static void Pvr_InitPsensor()
		{
			try
			{
				System.UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaSysActivityClass, "initPsensor", Pvr_UnitySDKRender.Instance.activity);
			}
			catch (Exception ex)
			{
				PLOG.E("Error :" + ex.ToString());
			}
		}

		public static bool Pvr_IsHead6dofReset()
		{
			int res = 0;
			Render.UPvr_GetIntConfig(17, ref res);
			if (res > 0)
			{
				return false;
			}
			bool result = false;
			try
			{
				System.UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaSysActivityClass, "isHead6dofReset", Pvr_UnitySDKRender.Instance.activity);
			}
			catch (Exception ex)
			{
				PLOG.E("Error :" + ex.ToString());
			}
			return result;
		}

		public static int Pvr_GetAndroidPsensorState()
		{
			int result = -1;
			try
			{
				System.UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaSysActivityClass, "getPsensorState");
			}
			catch (Exception ex)
			{
				PLOG.E("Error :" + ex.ToString());
			}
			return result;
		}

		public static void Pvr_UnregisterPsensor()
		{
			try
			{
				System.UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaSysActivityClass, "unregisterListener");
			}
			catch (Exception ex)
			{
				PLOG.E("Error :" + ex.ToString());
			}
		}

		public static int UPvr_ResetSensorAll(int index)
		{
			return Pvr_ResetSensorAll(index);
		}

		public static void UPvr_SetReinPosition(float x, float y, float z, float w, float px, float py, float pz, int hand, bool valid, int key)
		{
			if (PLOG.logLevel > 2)
			{
				PLOG.D("PvrLog UPvr_SetReinPosition" + x + y + z + w + px + py + pz + hand + valid + key);
			}
			Pvr_SetReinPosition(x, y, z, w, px, py, pz, hand, valid, key);
		}

		public static bool UPvr_SetTrackingOriginType(TrackingOrigin trackingOriginType)
		{
			return Pvr_SetTrackingOriginType(trackingOriginType);
		}

		public static Vector3 UPvr_GetAcceleration()
		{
			float x = 0f;
			float y = 0f;
			float z = 0f;
			Pvr_GetAcceleration(ref x, ref y, ref z);
			return new Vector3(0f - x, 0f - y, z);
		}

		public static Vector3 UPvr_AngularVelocity()
		{
			float x = 0f;
			float y = 0f;
			float z = 0f;
			Pvr_GetAngularVelocity(ref x, ref y, ref z);
			return new Vector3(x, y, z);
		}

		public static Vector3 UPvr_GetVelocity()
		{
			float x = 0f;
			float y = 0f;
			float z = 0f;
			Pvr_GetVelocity(ref x, ref y, ref z);
			return new Vector3(0f - x, 0f - y, z);
		}

		public static Vector3 UPvr_GetAngularAcceleration()
		{
			float x = 0f;
			float y = 0f;
			float z = 0f;
			Pvr_GetAngularAcceleration(ref x, ref y, ref z);
			return new Vector3(x, y, z);
		}
	}
	public struct Render
	{
		public const string LibFileName = "Pvr_UnitySDK";

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_ChangeScreenParameters(string model, int width, int height, double xppi, double yppi, double densityDpi);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_SetRatio(float midH, float midV);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_SetPupillaryPoint(bool enable);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr Pvr_GetSupportHMDTypes();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetCurrentHMDType([MarshalAs(UnmanagedType.LPStr)] string type);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetIntConfig(int configsenum, ref int res);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetFloatConfig(int configsenum, ref float res);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetupLayerData(int layerIndex, int sideMask, int textureId, int textureType, int layerFlags, float[] colorScaleAndOffset);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetupLayerCoords(int layerIndex, int sideMask, float[] lowerLeft, float[] lowerRight, float[] upperLeft, float[] upperRight);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetOverlayModelViewMatrix(int overlayType, int overlayShape, int texId, int eyeSide, int layerIndex, bool isHeadLocked, int layerFlags, float[] mvMatrix, float[] modelS, float[] modelR, float[] modelT, float[] cameraR, float[] cameraT, float[] colorScaleAndOffset);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_EnableFoveation(bool enable);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetFoveationParameters(int textureId, int previousId, float focalPointX, float focalPointY, float foveationGainX, float foveationGainY, float foveationArea, float foveationMinimum);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetFoveationResource(int textureId, int previousId, float focalPointX, float focalPointY);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetFoveationParameters2(float foveationGainX, float foveationGainY, float foveationArea, float foveationMinimum);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetFoveationLevel(EFoveationLevel level);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern EFoveationLevel Pvr_GetFoveationLevel();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_GetIntSysProc(string property, ref int res);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetColorspaceType(int colorspaceType);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetCastingColorspaceType(int colorspaceType);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr Pvr_CreateLayerAndroidSurface(int layerType, int layerIndex);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr Pvr_GetLayerAndroidSurface(int layerType, int layerIndex);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetMonoMode(bool openMono);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_GetStencilMesh(int eye, ref int vertexCount, ref int triangleCount, ref IntPtr vertexData, ref IntPtr indexData);

		public static void UPvr_ChangeScreenParameters(string model, int width, int height, double xppi, double yppi, double densityDpi)
		{
			Pvr_ChangeScreenParameters(model, width, height, xppi, yppi, densityDpi);
		}

		public static int UPvr_SetRatio(float midH, float midV)
		{
			return Pvr_SetRatio(midH, midV);
		}

		public static void UPvr_EnableFoveation(bool enable)
		{
			if (Pvr_UnitySDKManager.SDK.SystemFFRLevel != -1 || Pvr_UnitySDKManager.SDK.SystemDebugFFRLevel != -1)
			{
				enable = true;
			}
			Pvr_EnableFoveation(enable);
		}

		[Obsolete("This API will be removed in later versions")]
		public static void UPvr_SetFoveationParameters(int textureId, int previousId, float focalPointX, float focalPointY, float foveationGainX, float foveationGainY, float foveationArea, float foveationMinimum)
		{
			Pvr_SetFoveationParameters(textureId, previousId, focalPointX, focalPointY, foveationGainX, foveationGainY, foveationArea, foveationMinimum);
		}

		public static void UPvr_SetFoveationResource(int textureId, int previousId, float focalPointX, float focalPointY)
		{
			Pvr_SetFoveationResource(textureId, previousId, focalPointX, focalPointY);
		}

		public static void SetFoveatedRenderingLevel(EFoveationLevel level)
		{
			if (Pvr_UnitySDKManager.SDK.SystemDebugFFRLevel != -1)
			{
				Pvr_SetFoveationLevel((EFoveationLevel)Pvr_UnitySDKManager.SDK.SystemDebugFFRLevel);
			}
			else if (Pvr_UnitySDKManager.SDK.SystemFFRLevel != -1)
			{
				Pvr_SetFoveationLevel((EFoveationLevel)Pvr_UnitySDKManager.SDK.SystemFFRLevel);
			}
			else
			{
				Pvr_SetFoveationLevel(level);
			}
		}

		public static EFoveationLevel GetFoveatedRenderingLevel()
		{
			return Pvr_GetFoveationLevel();
		}

		public static void SetFoveatedRenderingParameters(Vector2 ffrGainValue, float ffrAreaValue, float ffrMinimumValue)
		{
			if (Pvr_UnitySDKManager.SDK.SystemDebugFFRLevel != -1)
			{
				Pvr_SetFoveationLevel((EFoveationLevel)Pvr_UnitySDKManager.SDK.SystemDebugFFRLevel);
			}
			else if (Pvr_UnitySDKManager.SDK.SystemFFRLevel != -1)
			{
				Pvr_SetFoveationLevel((EFoveationLevel)Pvr_UnitySDKManager.SDK.SystemFFRLevel);
			}
			else
			{
				Pvr_SetFoveationParameters2(ffrGainValue.x, ffrGainValue.y, ffrAreaValue, ffrMinimumValue);
			}
		}

		public static bool UPvr_GetIntSysProc(string property, ref int res)
		{
			return Pvr_GetIntSysProc(property, ref res);
		}

		public static int UPvr_GetIntConfig(int configsenum, ref int res)
		{
			return Pvr_GetIntConfig(configsenum, ref res);
		}

		public static int UPvr_GetFloatConfig(int configsenum, ref float res)
		{
			return Pvr_GetFloatConfig(configsenum, ref res);
		}

		public static string UPvr_GetSupportHMDTypes()
		{
			IntPtr intPtr = Pvr_GetSupportHMDTypes();
			if (intPtr != IntPtr.Zero)
			{
				return Marshal.PtrToStringAnsi(intPtr);
			}
			return null;
		}

		public static void UPvr_SetCurrentHMDType(string type)
		{
			Pvr_SetCurrentHMDType(type);
		}

		public static void UPvr_SetupLayerData(int layerIndex, int sideMask, int textureId, int textureType, int layerFlags, Vector4 colorScale, Vector4 colorOffset)
		{
			Pvr_SetupLayerData(layerIndex, sideMask, textureId, textureType, layerFlags, new float[8] { colorScale.x, colorScale.y, colorScale.z, colorScale.w, colorOffset.x, colorOffset.y, colorOffset.z, colorOffset.w });
		}

		public static void UPvr_SetupLayerCoords(int layerIndex, int sideMask, float[] lowerLeft, float[] lowerRight, float[] upperLeft, float[] upperRight)
		{
			Pvr_SetupLayerCoords(layerIndex, sideMask, lowerLeft, lowerRight, upperLeft, upperRight);
		}

		public static void UPvr_SetOverlayModelViewMatrix(int overlayType, int overlayShape, int texId, int eyeSide, int layerIndex, bool isHeadLocked, int layerFlags, Matrix4x4 mvMatrix, Vector3 modelS, Quaternion modelR, Vector3 modelT, Quaternion cameraR, Vector3 cameraT, Vector4 colorScale, Vector4 colorOffset)
		{
			Pvr_SetOverlayModelViewMatrix(overlayType, overlayShape, texId, eyeSide, layerIndex, isHeadLocked, layerFlags, new float[16]
			{
				mvMatrix.m00, mvMatrix.m01, mvMatrix.m02, mvMatrix.m03, mvMatrix.m10, mvMatrix.m11, mvMatrix.m12, mvMatrix.m13, mvMatrix.m20, mvMatrix.m21,
				mvMatrix.m22, mvMatrix.m23, mvMatrix.m30, mvMatrix.m31, mvMatrix.m32, mvMatrix.m33
			}, new float[3] { modelS.x, modelS.y, modelS.z }, new float[4] { modelR.x, modelR.y, modelR.z, modelR.w }, new float[3] { modelT.x, modelT.y, modelT.z }, new float[4] { cameraR.x, cameraR.y, cameraR.z, cameraR.w }, new float[3] { cameraT.x, cameraT.y, cameraT.z }, new float[8] { colorScale.x, colorScale.y, colorScale.z, colorScale.w, colorOffset.x, colorOffset.y, colorOffset.z, colorOffset.w });
		}

		public static void UPvr_SetColorspaceType(int colorspaceType)
		{
			Pvr_SetColorspaceType(colorspaceType);
		}

		public static void UPvr_SetCastingColorspaceType(int colorspaceType)
		{
			Pvr_SetCastingColorspaceType(colorspaceType);
		}

		public static IntPtr UPvr_CreateLayerAndroidSurface(int layerType, int layerIndex)
		{
			return Pvr_CreateLayerAndroidSurface(layerType, layerIndex);
		}

		public static IntPtr UPvr_GetLayerAndroidSurface(int layerType, int layerIndex)
		{
			return Pvr_GetLayerAndroidSurface(layerType, layerIndex);
		}

		public static void UPvr_SetMonoMode(bool openMono)
		{
			Pvr_SetMonoMode(openMono);
		}

		public static void UPvr_GetStencilMesh(int eye, ref int vertexCount, ref int triangleCount, ref IntPtr vertexDataPtr, ref IntPtr indexDataPtr)
		{
			Pvr_GetStencilMesh(eye, ref vertexCount, ref triangleCount, ref vertexDataPtr, ref indexDataPtr);
		}
	}
	public struct System
	{
		public const string LibFileName = "Pvr_UnitySDK";

		public const string UnitySDKVersion = "2.8.10.4";

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void Pvr_SetInitActivity(IntPtr activity, IntPtr vrActivityClass);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr Pvr_GetSDKVersion();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern int Pvr_GetHmdHardwareVersion();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr Pvr_GetHmdFirmwareVersion();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr Pvr_GetHmdSerialNumber();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern int PVR_GetHmdBatteryStatus();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern float PVR_GetHmdBatteryTemperature();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern int PVR_SetHmdAudioStatus(bool enable);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool Pvr_GetEyeTrackingData(ref int leftEyePoseStatus, ref int rightEyePoseStatus, ref int combinedEyePoseStatus, ref float leftEyeGazePointX, ref float leftEyeGazePointY, ref float leftEyeGazePointZ, ref float rightEyeGazePointX, ref float rightEyeGazePointY, ref float rightEyeGazePointZ, ref float combinedEyeGazePointX, ref float combinedEyeGazePointY, ref float combinedEyeGazePointZ, ref float leftEyeGazeVectorX, ref float leftEyeGazeVectorY, ref float leftEyeGazeVectorZ, ref float rightEyeGazeVectorX, ref float rightEyeGazeVectorY, ref float rightEyeGazeVectorZ, ref float combinedEyeGazeVectorX, ref float combinedEyeGazeVectorY, ref float combinedEyeGazeVectorZ, ref float leftEyeOpenness, ref float rightEyeOpenness, ref float leftEyePupilDilation, ref float rightEyePupilDilation, ref float leftEyePositionGuideX, ref float leftEyePositionGuideY, ref float leftEyePositionGuideZ, ref float rightEyePositionGuideX, ref float rightEyePositionGuideY, ref float rightEyePositionGuideZ, ref float foveatedGazeDirectionX, ref float foveatedGazeDirectionY, ref float foveatedGazeDirectionZ, ref int foveatedGazeTrackingState);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool Pvr_SetTrackingMode(int trackingMode);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern int Pvr_GetTrackingMode();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr GetRenderEventFunc();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void UnityEventData(long data);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool Pvr_EnableSinglePass(bool enable);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void Pvr_SetAntiAliasing(int antiAliasing);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void Pvr_SinglePassBeforeForwardOpaque();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void Pvr_SetCurrentRenderTexture(uint textureId);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool Pvr_SetSinglePassDepthBufferWidthHeight(int width, int height);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern int PVR_setPerformanceLevels(int cpuLevel, int gpuLevel);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool Pvr_SetIPD(float distance);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern float Pvr_GetIPD();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool Pvr_SetTrackingIPDEnabled(bool enable);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool Pvr_GetTrackingIPDEnabled();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool Pvr_GetEyeTrackingAutoIPD(ref float autoIPD);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern int PVR_GetHmdAudioStatus();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern float Pvr_GetPredictedDisplayTime();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool Pvr_SetExtraLatencyMode(int mode);

		public static bool UPvr_CallStaticMethod<T>(ref T result, AndroidJavaClass jclass, string name, params object[] args)
		{
			try
			{
				result = jclass.CallStatic<T>(name, args);
				return true;
			}
			catch (AndroidJavaException ex)
			{
				PLOG.E("Exception calling static method " + name + ": " + ex);
				return false;
			}
		}

		public static bool UPvr_CallStaticMethod(AndroidJavaObject jobj, string name, params object[] args)
		{
			try
			{
				jobj.CallStatic(name, args);
				return true;
			}
			catch (AndroidJavaException ex)
			{
				PLOG.E("CallStaticMethod  Exception calling activity method " + name + ": " + ex);
				return false;
			}
		}

		public static bool UPvr_CallMethod<T>(ref T result, AndroidJavaObject jobj, string name, params object[] args)
		{
			try
			{
				result = jobj.Call<T>(name, args);
				return true;
			}
			catch (AndroidJavaException ex)
			{
				PLOG.E("Exception calling activity method " + name + ": " + ex);
				return false;
			}
		}

		public static bool UPvr_CallMethod(AndroidJavaObject jobj, string name, params object[] args)
		{
			try
			{
				jobj.Call(name, args);
				return true;
			}
			catch (AndroidJavaException ex)
			{
				PLOG.E(" Exception calling activity method " + name + ": " + ex);
				return false;
			}
		}

		public static string UPvr_GetSDKVersion()
		{
			IntPtr intPtr = Pvr_GetSDKVersion();
			if (intPtr != IntPtr.Zero)
			{
				return Marshal.PtrToStringAnsi(intPtr);
			}
			return "";
		}

		public static string UPvr_GetUnitySDKVersion()
		{
			return "2.8.10.4";
		}

		public static string UPvr_GetDeviceMode()
		{
			return SystemInfo.deviceModel;
		}

		public static string UPvr_GetDeviceModel()
		{
			return SystemInfo.deviceModel;
		}

		public static string UPvr_GetDeviceSN()
		{
			string result = "UNKONWN";
			UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaSysActivityClass, "getDeviceSN");
			return result;
		}

		public static AndroidJavaObject UPvr_GetCurrentActivity()
		{
			return new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
		}

		public static bool UPvr_SetMonoPresentation()
		{
			return UPvr_CallMethod(UPvr_GetCurrentActivity(), "Pvr_setMonoPresentation");
		}

		public static bool UPvr_IsPresentationExisted()
		{
			bool result = false;
			return UPvr_CallMethod(ref result, UPvr_GetCurrentActivity(), "Pvr_isPresentationExisted") && result;
		}

		public static bool UPvr_GetMainActivityPauseStatus()
		{
			bool result = false;
			return UPvr_CallMethod(ref result, UPvr_GetCurrentActivity(), "Pvr_getMainActivityPauseStatus") && result;
		}

		public static void UPvr_Sleep()
		{
			UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaSysActivityClass, "Pvr_Sleep");
		}

		public static bool UPvr_StartHomeKeyReceiver(string startreceivre)
		{
			try
			{
				if (Pvr_UnitySDKRender.Instance != null)
				{
					UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaVrActivityLongReceiver, "Pvr_StartReceiver", Pvr_UnitySDKRender.Instance.activity, startreceivre);
					PLOG.I("Start home key Receiver");
					return true;
				}
			}
			catch (Exception ex)
			{
				PLOG.E("Start home key  Receiver  Error :" + ex.ToString());
				return false;
			}
			return true;
		}

		public static bool UPvr_StopHomeKeyReceiver()
		{
			try
			{
				if (Pvr_UnitySDKRender.Instance != null)
				{
					UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaVrActivityLongReceiver, "Pvr_StopReceiver", Pvr_UnitySDKRender.Instance.activity);
					PLOG.I("Stop home key Receiver");
					return true;
				}
			}
			catch (Exception ex)
			{
				PLOG.E("Stop home key Receiver Error :" + ex.ToString());
				return false;
			}
			return true;
		}

		public static void UPvr_StartVRModel()
		{
			UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaVrActivityClass, "startVRModel");
		}

		public static void UPvr_RemovePlatformLogo()
		{
			UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaVrActivityClass, "removePlatformLogo");
		}

		public static void UPvr_ShowPlatformLogo()
		{
			UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaVrActivityClass, "showPlatformLogo");
		}

		public static bool UPvr_IsPicoActivity()
		{
			bool result = false;
			return UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "isPicoActivity", UPvr_GetCurrentActivity()) && result;
		}

		public static void UPvr_StopVRModel()
		{
			UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaVrActivityClass, "stopVRModel");
		}

		public static string UPvr_GetCountryCode()
		{
			string result = "";
			UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getCountryCode", UPvr_GetCurrentActivity());
			return result;
		}

		public static bool UPvr_SetIPD(float distance)
		{
			bool flag = false;
			flag = Pvr_SetIPD(distance);
			if (flag)
			{
				for (int i = 0; i < Pvr_UnitySDKEyeManager.Instance.Eyes.Length; i++)
				{
					Pvr_UnitySDKEyeManager.Instance.Eyes[i].RefreshCameraPosition(distance);
				}
			}
			return flag;
		}

		public static float UPvr_GetIPD()
		{
			float result = Pvr_GetIPD();
			UnityEngine.Debug.Log("DISFT IPD:" + result);
			return result;
		}

		public static bool UPvr_SetTrackingIPDEnabled(bool enable)
		{
			return Pvr_SetTrackingIPDEnabled(enable);
		}

		public static bool UPvr_GetTrackingIPDEnabled()
		{
			return Pvr_GetTrackingIPDEnabled();
		}

		public static bool UPvr_GetEyeTrackingAutoIPD(ref float autoipd)
		{
			return Pvr_GetEyeTrackingAutoIPD(ref autoipd);
		}

		public static void UPvr_UnityEventData(long data)
		{
			UnityEventData(data);
		}

		public static long UPvr_GetEyeBufferData(int id)
		{
			return ((long)Pvr_UnitySDKRender.Instance.RenderviewNumber << 32) | id;
		}

		public static bool UPvr_checkDevice(string packagename)
		{
			bool result = false;
			UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "checkDevice", packagename, UPvr_GetCurrentActivity());
			return result;
		}

		public static int UPvr_GetHmdHardwareVersion()
		{
			return Pvr_GetHmdHardwareVersion();
		}

		public static string UPvr_GetHmdFirmwareVersion()
		{
			IntPtr intPtr = Pvr_GetHmdFirmwareVersion();
			if (intPtr != IntPtr.Zero)
			{
				return Marshal.PtrToStringAnsi(intPtr);
			}
			return "";
		}

		public static string UPvr_GetHmdSerialNumber()
		{
			IntPtr intPtr = Pvr_GetHmdSerialNumber();
			if (intPtr != IntPtr.Zero)
			{
				return Marshal.PtrToStringAnsi(intPtr);
			}
			return "";
		}

		public static int UPvr_GetHmdBatteryStatus()
		{
			return PVR_GetHmdBatteryStatus();
		}

		public static float UPvr_GetHmdBatteryTemperature()
		{
			return PVR_GetHmdBatteryTemperature();
		}

		public static int UPvr_SetHmdAudioStatus(bool enable)
		{
			return PVR_SetHmdAudioStatus(enable);
		}

		public static int UPvr_GetTrackingMode()
		{
			return Pvr_GetTrackingMode();
		}

		public static bool UPvr_setTrackingMode(int trackingMode)
		{
			return Pvr_SetTrackingMode(trackingMode);
		}

		public static bool UPvr_getEyeTrackingData(ref EyeTrackingData trackingData)
		{
			if (!Pvr_UnitySDKEyeManager.supportEyeTracking)
			{
				PLOG.E("The device is not supported");
				return false;
			}
			if (!Pvr_UnitySDKEyeManager.Instance.EyeTracking)
			{
				PLOG.E("Please Enable \"Pvr_UnitySDK/Head/Pvr_UnitySDKEyeManager.cs/EyeTracking\"option first.");
				return false;
			}
			bool result = Pvr_GetEyeTrackingData(ref trackingData.leftEyePoseStatus, ref trackingData.rightEyePoseStatus, ref trackingData.combinedEyePoseStatus, ref trackingData.leftEyeGazePoint.x, ref trackingData.leftEyeGazePoint.y, ref trackingData.leftEyeGazePoint.z, ref trackingData.rightEyeGazePoint.x, ref trackingData.rightEyeGazePoint.y, ref trackingData.rightEyeGazePoint.z, ref trackingData.combinedEyeGazePoint.x, ref trackingData.combinedEyeGazePoint.y, ref trackingData.combinedEyeGazePoint.z, ref trackingData.leftEyeGazeVector.x, ref trackingData.leftEyeGazeVector.y, ref trackingData.leftEyeGazeVector.z, ref trackingData.rightEyeGazeVector.x, ref trackingData.rightEyeGazeVector.y, ref trackingData.rightEyeGazeVector.z, ref trackingData.combinedEyeGazeVector.x, ref trackingData.combinedEyeGazeVector.y, ref trackingData.combinedEyeGazeVector.z, ref trackingData.leftEyeOpenness, ref trackingData.rightEyeOpenness, ref trackingData.leftEyePupilDilation, ref trackingData.rightEyePupilDilation, ref trackingData.leftEyePositionGuide.x, ref trackingData.leftEyePositionGuide.y, ref trackingData.leftEyePositionGuide.z, ref trackingData.rightEyePositionGuide.x, ref trackingData.rightEyePositionGuide.y, ref trackingData.rightEyePositionGuide.z, ref trackingData.foveatedGazeDirection.x, ref trackingData.foveatedGazeDirection.y, ref trackingData.foveatedGazeDirection.z, ref trackingData.foveatedGazeTrackingState);
			trackingData.leftEyeGazeVector.z = 0f - trackingData.leftEyeGazeVector.z;
			trackingData.rightEyeGazeVector.z = 0f - trackingData.rightEyeGazeVector.z;
			trackingData.combinedEyeGazeVector.z = 0f - trackingData.combinedEyeGazeVector.z;
			trackingData.leftEyeGazePoint.z = 0f - trackingData.leftEyeGazePoint.z;
			trackingData.rightEyeGazePoint.z = 0f - trackingData.rightEyeGazePoint.z;
			trackingData.combinedEyeGazePoint.z = 0f - trackingData.combinedEyeGazePoint.z;
			trackingData.foveatedGazeDirection.z = 0f - trackingData.foveatedGazeDirection.z;
			return result;
		}

		public static bool UPvr_getEyeTrackingGazeRay(ref EyeTrackingGazeRay gazeRay)
		{
			if (!Pvr_UnitySDKEyeManager.supportEyeTracking)
			{
				PLOG.E("The device is not supported");
				return false;
			}
			if (!Pvr_UnitySDKEyeManager.Instance.EyeTracking)
			{
				PLOG.E("Please Enable \"Pvr_UnitySDK/Head/Pvr_UnitySDKEyeManager.cs/EyeTracking\"option first.");
				return false;
			}
			EyeTrackingData trackingData = default(EyeTrackingData);
			UPvr_getEyeTrackingData(ref trackingData);
			gazeRay.IsValid = ((uint)trackingData.combinedEyePoseStatus & (true ? 1u : 0u)) != 0 && (trackingData.combinedEyePoseStatus & 2) != 0;
			if (gazeRay.IsValid)
			{
				gazeRay.Direction = trackingData.combinedEyeGazeVector;
				gazeRay.Origin = trackingData.combinedEyeGazePoint;
				gazeRay.Origin = Pvr_UnitySDKSensor.Instance.HeadPose.Matrix.MultiplyPoint(gazeRay.Origin);
				gazeRay.Direction = Pvr_UnitySDKSensor.Instance.HeadPose.Matrix.MultiplyVector(gazeRay.Direction);
				return true;
			}
			return false;
		}

		public static bool UPvr_getEyeTrackingGazeRayWorld(ref EyeTrackingGazeRay gazeRay)
		{
			if (!Pvr_UnitySDKEyeManager.supportEyeTracking)
			{
				PLOG.E("The device is not supported");
				return false;
			}
			if (!Pvr_UnitySDKEyeManager.Instance.EyeTracking)
			{
				PLOG.E("Please Enable \"Pvr_UnitySDK/Head/Pvr_UnitySDKEyeManager.cs/EyeTracking\"option first.");
				return false;
			}
			Transform transform = Pvr_UnitySDKEyeManager.Instance.transform;
			Matrix4x4 matrix4x = Matrix4x4.TRS(transform.position, transform.rotation, Vector3.one);
			EyeTrackingData trackingData = default(EyeTrackingData);
			UPvr_getEyeTrackingData(ref trackingData);
			gazeRay.IsValid = ((uint)trackingData.combinedEyePoseStatus & (true ? 1u : 0u)) != 0 && (trackingData.combinedEyePoseStatus & 2) != 0;
			if (gazeRay.IsValid)
			{
				gazeRay.Direction = trackingData.combinedEyeGazeVector;
				gazeRay.Origin = trackingData.combinedEyeGazePoint;
				gazeRay.Origin = matrix4x.MultiplyPoint(gazeRay.Origin);
				gazeRay.Direction = matrix4x.MultiplyVector(gazeRay.Direction);
				return true;
			}
			return false;
		}

		public static Vector3 UPvr_getEyeTrackingPos()
		{
			if (!Pvr_UnitySDKEyeManager.supportEyeTracking)
			{
				PLOG.E("The device is not supported");
				return Vector3.zero;
			}
			if (!Pvr_UnitySDKEyeManager.Instance.EyeTracking)
			{
				PLOG.E("Please Enable \"Pvr_UnitySDK/Head/Pvr_UnitySDKEyeManager.cs/EyeTracking\"option first.");
				return Vector3.zero;
			}
			return Pvr_UnitySDKEyeManager.Instance.GetEyeTrackingPos();
		}

		public static int UPvr_GetPhoneScreenBrightness()
		{
			int result = 0;
			UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClientClass, "Pvr_GetScreen_Brightness", UPvr_GetCurrentActivity());
			return result;
		}

		public static void UPvr_SetPhoneScreenBrightness(int level)
		{
			UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaVrActivityClientClass, "Pvr_setAPPScreen_Brightness", UPvr_GetCurrentActivity(), level);
		}

		public static bool UPvr_IsPicoDefaultActivity()
		{
			using (AndroidJavaClass androidJavaClass = new AndroidJavaClass("com.unity3d.player.UnityPlayer"))
			{
				using AndroidJavaObject androidJavaObject = androidJavaClass.GetStatic<AndroidJavaObject>("currentActivity");
				if (androidJavaObject.Call<string>("getLocalClassName", Array.Empty<object>()) == "com.unity3d.player.UnityPlayerNativeActivityPico")
				{
					return true;
				}
			}
			return false;
		}

		public static bool UPvr_EnableSinglePass(bool enable)
		{
			return Pvr_EnableSinglePass(enable);
		}

		public static void UPvr_SetAntiAliasing(int antiAliasing)
		{
			Pvr_SetAntiAliasing(antiAliasing);
		}

		public static void UPvr_SinglePassBeforeForwardOpaque()
		{
			Pvr_SinglePassBeforeForwardOpaque();
		}

		public static void UPvr_SetCurrentRenderTexture(uint textureId)
		{
			Pvr_SetCurrentRenderTexture(textureId);
		}

		public static bool UPvr_SetSinglePassDepthBufferWidthHeight(int width, int height)
		{
			return Pvr_SetSinglePassDepthBufferWidthHeight(width, height);
		}

		public static int UPVR_setPerformanceLevels(int cpuLevel, int gpuLevel)
		{
			return PVR_setPerformanceLevels(cpuLevel, gpuLevel);
		}

		public static int UPvr_GetColorRes(string name)
		{
			int result = -1;
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getColorRes", name);
			}
			catch (Exception ex)
			{
				PLOG.E("GetColorResError :" + ex.ToString());
			}
			return result;
		}

		public static int UPvr_GetConfigInt(string name)
		{
			int result = -1;
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getConfigInt", name);
			}
			catch (Exception ex)
			{
				PLOG.E("GetConfigIntError :" + ex.ToString());
			}
			return result;
		}

		public static string UPvr_GetConfigString(string name)
		{
			string result = "";
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getConfigString", name);
			}
			catch (Exception ex)
			{
				PLOG.E("GetConfigStringError :" + ex.ToString());
			}
			return result;
		}

		public static string UPvr_GetDrawableLocation(string name)
		{
			string result = "";
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getDrawableLocation", name);
			}
			catch (Exception ex)
			{
				PLOG.E("GetDrawableLocationError :" + ex.ToString());
			}
			return result;
		}

		public static int UPvr_GetTextSize(string name)
		{
			int result = -1;
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getTextSize", name);
			}
			catch (Exception ex)
			{
				PLOG.E("GetTextSizeError :" + ex.ToString());
			}
			return result;
		}

		public static string UPvr_GetLangString(string name)
		{
			string result = "";
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getLangString", name);
			}
			catch (Exception ex)
			{
				PLOG.E("GetLangStringError :" + ex.ToString());
			}
			return result;
		}

		public static string UPvr_GetStringValue(string id, int type)
		{
			string result = "";
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getStringValue", id, type);
			}
			catch (Exception ex)
			{
				PLOG.E("GetStringValueError :" + ex.ToString());
			}
			return result;
		}

		public static int UPvr_GetIntValue(string id, int type)
		{
			int result = -1;
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getIntValue", id, type);
			}
			catch (Exception ex)
			{
				PLOG.E("GetIntValueError :" + ex.ToString());
			}
			return result;
		}

		public static float UPvr_GetFloatValue(string id)
		{
			float result = -1f;
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getFloatValue", id);
			}
			catch (Exception ex)
			{
				PLOG.E("GetFloatValueError :" + ex.ToString());
			}
			return result;
		}

		public static string UPvr_GetObjectOrArray(string id, int type)
		{
			string result = "";
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getObjectOrArray", id, type);
			}
			catch (Exception ex)
			{
				PLOG.E("GetObjectOrArrayError :" + ex.ToString());
			}
			return result;
		}

		public static int UPvr_GetCharSpace(string id)
		{
			int result = -1;
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getCharSpace", id);
			}
			catch (Exception ex)
			{
				PLOG.E("GetCharSpaceError :" + ex.ToString());
			}
			return result;
		}

		public static bool UPvr_SetExtraLatencyMode(ExtraLatencyMode mode)
		{
			return Pvr_SetExtraLatencyMode((int)mode);
		}

		public static float UPvr_GetPredictedDisplayTime()
		{
			float result = 0f;
			try
			{
				result = Pvr_GetPredictedDisplayTime();
			}
			catch (Exception ex)
			{
				UnityEngine.Debug.Log("UPvr_GetPredictedDisplayTime :" + ex.ToString());
			}
			return result;
		}
	}
	public struct BoundarySystem
	{
		public enum BoundaryType
		{
			OuterBoundary,
			PlayArea
		}

		public struct BoundaryTestResult
		{
			public bool IsTriggering;

			public float ClosestDistance;

			public Vector3 ClosestPoint;

			public Vector3 ClosestPointNormal;
		}

		public enum BoundaryTrackingNode
		{
			HandLeft,
			HandRight,
			Head
		}

		public enum BoundaryTrackingState
		{
			LostNoReason = 3,
			LostCamera,
			LostHighLight,
			LostLowLight,
			LostLowFeatureCount,
			LostReLocation,
			LostInitialization,
			LostNoCamera,
			LostNoIMU,
			LostIMUJitter,
			LostUnknown
		}

		public const string LibFileName = "Pvr_UnitySDK";

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern float Pvr_GetFloorHeight();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetSeeThroughState();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_BoundarySetSTBackground(bool value);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetTrackingState();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_GetFrameRateLimit();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_IsBoundaryEnable();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_BoundaryGetConfigured();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_BoundaryTestNode(int node, bool isPlayArea, ref bool isTriggering, ref float closestDistance, ref float px, ref float py, ref float pz, ref float nx, ref float ny, ref float nz);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_BoundaryTestPoint(float x, float y, float z, bool isPlayArea, ref bool isTriggering, ref float closestDistance, ref float px, ref float py, ref float pz, ref float nx, ref float ny, ref float nz);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_BoundaryGetGeometry(out IntPtr handle, bool isPlayArea);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_BoundaryGetDimensions(ref float x, ref float y, ref float z, bool isPlayArea);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_BoundaryGetEnabled();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_BoundarySetVisible(bool value);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_BoundaryGetVisible();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_EnableLWRP(bool enable);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_SetViewportSize(int w, int h);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_BoundarySetSeeThroughVisible(bool value);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void PVR_SetCameraImageRect(int width, int height);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetGuardianSystemDisable(bool value);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetDialogState();

		public static float UPvr_GetFloorHeight()
		{
			return Pvr_GetFloorHeight();
		}

		public static int UPvr_GetSeeThroughState()
		{
			return Pvr_GetSeeThroughState();
		}

		public static void UPvr_EnableSeeThroughManual(bool enable)
		{
			Pvr_BoundarySetSTBackground(enable);
		}

		public static BoundaryTrackingState UPvr_GetTrackingState()
		{
			return (BoundaryTrackingState)Pvr_GetTrackingState();
		}

		public static bool UPvr_GetFrameRateLimit()
		{
			return Pvr_GetFrameRateLimit();
		}

		public static bool UPvr_IsBoundaryEnable()
		{
			return Pvr_IsBoundaryEnable();
		}

		public static bool UPvr_BoundaryGetConfigured()
		{
			return Pvr_BoundaryGetConfigured();
		}

		public static BoundaryTestResult UPvr_BoundaryTestNode(BoundaryTrackingNode node, BoundaryType boundaryType)
		{
			BoundaryTestResult result = default(BoundaryTestResult);
			bool num = Pvr_BoundaryTestNode((int)node, boundaryType == BoundaryType.PlayArea, ref result.IsTriggering, ref result.ClosestDistance, ref result.ClosestPoint.x, ref result.ClosestPoint.y, ref result.ClosestPoint.z, ref result.ClosestPointNormal.x, ref result.ClosestPointNormal.y, ref result.ClosestPointNormal.z);
			result.ClosestPoint.z = 0f - result.ClosestPoint.z;
			result.ClosestPointNormal.z = 0f - result.ClosestPointNormal.z;
			if (!num)
			{
				UnityEngine.Debug.LogError($"UPvr_BoundaryTestNode({node}, {boundaryType}) API call failed!");
			}
			return result;
		}

		public static BoundaryTestResult UPvr_BoundaryTestPoint(Vector3 point, BoundaryType boundaryType)
		{
			BoundaryTestResult result = default(BoundaryTestResult);
			if (!Pvr_BoundaryTestPoint(point.x, point.y, 0f - point.z, boundaryType == BoundaryType.PlayArea, ref result.IsTriggering, ref result.ClosestDistance, ref result.ClosestPoint.x, ref result.ClosestPoint.y, ref result.ClosestPoint.z, ref result.ClosestPointNormal.x, ref result.ClosestPointNormal.y, ref result.ClosestPointNormal.z))
			{
				UnityEngine.Debug.LogError($"UPvr_BoundaryTestPoint({point}, {boundaryType}) API call failed!");
			}
			return result;
		}

		public static Vector3[] UPvr_BoundaryGetGeometry(BoundaryType boundaryType)
		{
			IntPtr handle = IntPtr.Zero;
			int num = Pvr_BoundaryGetGeometry(out handle, boundaryType == BoundaryType.PlayArea);
			if (num <= 0)
			{
				UnityEngine.Debug.LogError("Boundary geometry point count is " + num);
				return null;
			}
			int num2 = num * 3;
			float[] array = new float[num2];
			Marshal.Copy(handle, array, 0, num2);
			Vector3[] array2 = new Vector3[num];
			for (int i = 0; i < num; i++)
			{
				array2[i] = new Vector3
				{
					x = array[3 * i],
					y = array[3 * i + 1],
					z = 0f - array[3 * i + 2]
				};
			}
			return array2;
		}

		public static Vector3 UPvr_BoundaryGetDimensions(BoundaryType boundaryType)
		{
			float x = 0f;
			float y = 0f;
			float z = 0f;
			Pvr_BoundaryGetDimensions(ref x, ref y, ref z, boundaryType == BoundaryType.PlayArea);
			return new Vector3(x, y, z);
		}

		public static bool UPvr_BoundaryGetEnabled()
		{
			return Pvr_BoundaryGetEnabled();
		}

		public static void UPvr_BoundarySetVisible(bool value)
		{
			Pvr_BoundarySetVisible(value);
		}

		public static bool UPvr_BoundaryGetVisible()
		{
			return Pvr_BoundaryGetVisible();
		}

		public static bool UPvr_EnableLWRP(bool enable)
		{
			return Pvr_EnableLWRP(enable);
		}

		public static bool UPvr_SetViewportSize(int width, int height)
		{
			return Pvr_SetViewportSize(width, height);
		}

		public static void UPvr_StartCameraFrame()
		{
			try
			{
				Pvr_UnitySDKPluginEvent.Issue(RenderEventType.StartCameraFrame);
			}
			catch (Exception ex)
			{
				PLOG.E("UPvr_StartCameraFrame :" + ex.ToString());
			}
		}

		public static void UPvr_StopCameraFrame()
		{
			try
			{
				Pvr_UnitySDKPluginEvent.Issue(RenderEventType.StopCameraFrame);
			}
			catch (Exception ex)
			{
				PLOG.E("UPvr_StopCameraFrame :" + ex.ToString());
			}
		}

		public static void UPvr_BoundaryGetSeeThroughData(int cameraIndex, RenderTexture renderTexture)
		{
			try
			{
				if (renderTexture.IsCreated())
				{
					System.UPvr_UnityEventData(renderTexture.GetNativeTexturePtr().ToInt32());
					switch (cameraIndex)
					{
					case 0:
						Pvr_UnitySDKPluginEvent.Issue(RenderEventType.CameraFrameLeft);
						break;
					case 1:
						Pvr_UnitySDKPluginEvent.Issue(RenderEventType.CameraFrameRight);
						break;
					}
				}
			}
			catch (Exception ex)
			{
				PLOG.E("UPvr_BoundaryGetSeeThroughDataError :" + ex.ToString());
			}
		}

		public static void UPvr_BoundarySetCameraImageRect(int width, int height)
		{
			try
			{
				PVR_SetCameraImageRect(width, height);
			}
			catch (Exception ex)
			{
				PLOG.E("UPvr_BoundarySetCameraImageRectError :" + ex.ToString());
			}
		}

		public static void UPvr_BoundarySetSeeThroughVisible(bool value)
		{
			try
			{
				Pvr_BoundarySetSeeThroughVisible(value);
			}
			catch (Exception ex)
			{
				PLOG.E("UPvr_BoundarySetSeeThroughVisibleError :" + ex.ToString());
			}
		}

		public static void UPvr_SetGuardianSystemDisable(bool value)
		{
			try
			{
				Pvr_SetGuardianSystemDisable(value);
			}
			catch (Exception ex)
			{
				PLOG.E("UPvr_SetGuardianSystemDisableError :" + ex.ToString());
			}
		}

		public static int UPvr_GetDialogState()
		{
			int result = 0;
			try
			{
				result = Pvr_GetDialogState();
			}
			catch (Exception ex)
			{
				PLOG.E("UPvr_GetDialogStateError :" + ex.ToString());
			}
			return result;
		}
	}
	[StructLayout(LayoutKind.Sequential, Size = 1)]
	public struct PlatformSettings
	{
		public static Pvr_UnitySDKPlatformSetting.simulationType UPvr_IsCurrentDeviceValid()
		{
			if (Pvr_UnitySDKPlatformSetting.Entitlementchecksimulation)
			{
				if (Pvr_UnitySDKPlatformSetting.Instance.deviceSN.Count <= 0)
				{
					UnityEngine.Debug.Log("DISFT Entitlement Check Simulation deviceSN is Null");
					return Pvr_UnitySDKPlatformSetting.simulationType.Null;
				}
				foreach (string item in Pvr_UnitySDKPlatformSetting.Instance.deviceSN)
				{
					if (System.UPvr_GetDeviceSN() == item)
					{
						return Pvr_UnitySDKPlatformSetting.simulationType.Valid;
					}
				}
				UnityEngine.Debug.Log("DISFT Entitlement Check Simulation deviceSN is Invalid");
				return Pvr_UnitySDKPlatformSetting.simulationType.Invalid;
			}
			UnityEngine.Debug.Log("DISFT Entitlement Check Simulation DO NOT Enable");
			return Pvr_UnitySDKPlatformSetting.simulationType.Invalid;
		}

		public static bool UPvr_AppEntitlementCheck(string appid)
		{
			bool result = false;
			try
			{
				System.UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "verifyAPP", System.UPvr_GetCurrentActivity(), appid, "");
			}
			catch (Exception ex)
			{
				PLOG.E("Error :" + ex.ToString());
			}
			UnityEngine.Debug.Log("PvrLog UPvr_AppEntitlementCheck" + result);
			return result;
		}

		[Obsolete("This API will be removed in later versions")]
		public static bool UPvr_KeyEntitlementCheck(string publicKey)
		{
			bool result = false;
			try
			{
				System.UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "verifyAPP", System.UPvr_GetCurrentActivity(), "", publicKey);
			}
			catch (Exception ex)
			{
				PLOG.E("Error :" + ex.ToString());
			}
			UnityEngine.Debug.Log("PvrLog UPvr_KeyEntitlementCheck" + result);
			return result;
		}

		public static int UPvr_AppEntitlementCheckExtra(string appid)
		{
			return 0;
		}

		public static int UPvr_KeyEntitlementCheckExtra(string publicKey)
		{
			int result = -1;
			try
			{
				System.UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "verifyAPPExt", System.UPvr_GetCurrentActivity(), "", publicKey);
			}
			catch (Exception ex)
			{
				PLOG.E("Error :" + ex.ToString());
			}
			UnityEngine.Debug.Log("PvrLog UPvr_KeyEntitlementCheck" + result);
			return result;
		}

		public static int UPvr_GetHmdAudioStatus()
		{
			return System.PVR_GetHmdAudioStatus();
		}
	}
	public enum DeviceCommand
	{
		SET_PICO_NEO_HMD_BRIGHTNESS = 12,
		SET_PICO_NEO_HMD_SLEEPDELAY
	}
	public enum BrightnessLevel
	{
		VR_BRIGHTNESS_LEVEL_MIN = 1,
		VR_BRIGHTNESS_LEVEL_MAX = 100,
		VR_BRIGHTNESS_LEVEL_DOWN = 1000,
		VR_BRIGHTNESS_LEVEL_UP = 1001,
		VR_BRIGHTNESS_LEVEL_SCREEN_OFF = -100
	}
	public struct VolumePowerBrightness
	{
		public const string LibFileName = "Pvr_UnitySDK";

		public AndroidJavaObject activity;

		public static AndroidJavaClass javaSysActivityClass;

		private static AndroidJavaClass batteryjavaVrActivityClass;

		private static AndroidJavaClass volumejavaVrActivityClass;

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void Pvr_SetInitActivity(IntPtr activity, IntPtr vrActivityClass);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_IsHmdExist();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetHmdScreenBrightness();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_SetHmdScreenBrightness(int brightness);

		public static bool UPvr_IsHmdExist()
		{
			return Pvr_IsHmdExist();
		}

		public static int UPvr_GetHmdScreenBrightness()
		{
			return Pvr_GetHmdScreenBrightness();
		}

		public static bool UPvr_SetHmdScreenBrightness(int brightness)
		{
			return Pvr_SetHmdScreenBrightness(brightness);
		}

		public static bool UPvr_SetCommonBrightness(int brightness)
		{
			bool flag = false;
			if (UPvr_IsHmdExist())
			{
				return UPvr_SetHmdScreenBrightness(brightness);
			}
			return UPvr_SetBrightness(brightness);
		}

		public static int UPvr_GetCommonBrightness()
		{
			int num = 0;
			if (UPvr_IsHmdExist())
			{
				return UPvr_GetHmdScreenBrightness();
			}
			return UPvr_GetCurrentBrightness();
		}

		public static int[] UPvr_GetScreenBrightnessLevel()
		{
			return Pvr_GetScreenBrightnessLevel();
		}

		public static void UPvr_SetScreenBrightnessLevel(int vrBrightness, int level)
		{
			Pvr_SetScreenBrightnessLevel(vrBrightness, level);
		}

		public static bool UPvr_SetDevicePropForUser(DeviceCommand deviceid, string number)
		{
			return setDevicePropForUser(deviceid, number);
		}

		public static string UPvr_GetDevicePropForUser(DeviceCommand deviceid)
		{
			return getDevicePropForUser(deviceid);
		}

		public static bool UPvr_InitBatteryClass()
		{
			try
			{
				if (javaSysActivityClass == null)
				{
					javaSysActivityClass = new AndroidJavaClass("com.psmart.aosoperation.SysActivity");
				}
				if (javaSysActivityClass != null && Pvr_UnitySDKRender.Instance.activity != null)
				{
					if (batteryjavaVrActivityClass == null)
					{
						batteryjavaVrActivityClass = new AndroidJavaClass("com.psmart.aosoperation.BatteryReceiver");
					}
					return true;
				}
				return false;
			}
			catch (Exception ex)
			{
				PLOG.E("startReceiver Error :" + ex.ToString());
				return false;
			}
		}

		public static bool UPvr_InitBatteryVolClass()
		{
			try
			{
				javaSysActivityClass = new AndroidJavaClass("com.psmart.aosoperation.SysActivity");
				if (javaSysActivityClass != null && Pvr_UnitySDKRender.Instance.activity != null)
				{
					batteryjavaVrActivityClass = new AndroidJavaClass("com.psmart.aosoperation.BatteryReceiver");
					volumejavaVrActivityClass = new AndroidJavaClass("com.psmart.aosoperation.AudioReceiver");
					System.UPvr_CallStaticMethod(javaSysActivityClass, "Pvr_InitAudioDevice", Pvr_UnitySDKRender.Instance.activity);
					return true;
				}
				return false;
			}
			catch (Exception ex)
			{
				PLOG.E("startReceiver Error :" + ex.ToString());
				return false;
			}
		}

		public static bool UPvr_StartBatteryReceiver(string startreceivre)
		{
			try
			{
				System.UPvr_CallStaticMethod(batteryjavaVrActivityClass, "Pvr_StartReceiver", Pvr_UnitySDKRender.Instance.activity, startreceivre);
				return true;
			}
			catch (Exception ex)
			{
				PLOG.E("startReceiver Error :" + ex.ToString());
				return false;
			}
		}

		public static bool UPvr_StopBatteryReceiver()
		{
			try
			{
				System.UPvr_CallStaticMethod(batteryjavaVrActivityClass, "Pvr_StopReceiver", Pvr_UnitySDKRender.Instance.activity);
				return true;
			}
			catch (Exception ex)
			{
				PLOG.E("startReceiver Error :" + ex.ToString());
				return false;
			}
		}

		public static bool UPvr_SetBrightness(int brightness)
		{
			try
			{
				System.UPvr_CallStaticMethod(javaSysActivityClass, "Pvr_SetScreen_Brightness", brightness, Pvr_UnitySDKRender.Instance.activity);
				return true;
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
				return false;
			}
		}

		public static int UPvr_GetCurrentBrightness()
		{
			int result = 0;
			try
			{
				System.UPvr_CallStaticMethod(ref result, javaSysActivityClass, "Pvr_GetScreen_Brightness", Pvr_UnitySDKRender.Instance.activity);
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
			}
			return result;
		}

		public static int[] Pvr_GetScreenBrightnessLevel()
		{
			int[] result = new int[1];
			try
			{
				System.UPvr_CallStaticMethod(ref result, javaSysActivityClass, "getScreenBrightnessLevel");
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
			}
			return result;
		}

		public static void Pvr_SetScreenBrightnessLevel(int vrBrightness, int level)
		{
			try
			{
				System.UPvr_CallStaticMethod(javaSysActivityClass, "setScreenBrightnessLevel", vrBrightness, level);
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
			}
		}

		public static bool UPvr_StartAudioReceiver(string startreceivre)
		{
			try
			{
				System.UPvr_CallStaticMethod(volumejavaVrActivityClass, "Pvr_StartReceiver", Pvr_UnitySDKRender.Instance.activity, startreceivre);
				return true;
			}
			catch (Exception ex)
			{
				PLOG.E("startReceiver Error :" + ex.ToString());
				return false;
			}
		}

		public static bool UPvr_StopAudioReceiver()
		{
			try
			{
				System.UPvr_CallStaticMethod(volumejavaVrActivityClass, "Pvr_StopReceiver", Pvr_UnitySDKRender.Instance.activity);
				return true;
			}
			catch (Exception ex)
			{
				PLOG.E("startReceiver Error :" + ex.ToString());
				return false;
			}
		}

		public static int UPvr_GetMaxVolumeNumber()
		{
			int result = 0;
			try
			{
				System.UPvr_CallStaticMethod(ref result, javaSysActivityClass, "Pvr_GetMaxAudionumber");
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
			}
			return result;
		}

		public static int UPvr_GetCurrentVolumeNumber()
		{
			int result = 0;
			try
			{
				System.UPvr_CallStaticMethod(ref result, javaSysActivityClass, "Pvr_GetAudionumber");
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
			}
			return result;
		}

		public static bool UPvr_VolumeUp()
		{
			try
			{
				System.UPvr_CallStaticMethod(javaSysActivityClass, "Pvr_UpAudio");
				return true;
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
				return false;
			}
		}

		public static bool UPvr_VolumeDown()
		{
			try
			{
				System.UPvr_CallStaticMethod(javaSysActivityClass, "Pvr_DownAudio");
				return true;
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
				return false;
			}
		}

		public static bool UPvr_SetVolumeNum(int volume)
		{
			try
			{
				System.UPvr_CallStaticMethod(javaSysActivityClass, "Pvr_ChangeAudio", volume);
				return true;
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
				return false;
			}
		}

		public static bool UPvr_SetAudio(string s)
		{
			return false;
		}

		public static bool UPvr_SetBattery(string s)
		{
			return false;
		}

		private static string getDevicePropForUser(DeviceCommand deviceid)
		{
			string result = "0";
			System.UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getDevicePropForUser", (int)deviceid);
			return result;
		}

		private static bool setDevicePropForUser(DeviceCommand deviceid, string number)
		{
			bool result = false;
			System.UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "setDevicePropForUser", (int)deviceid, number);
			return result;
		}
	}
}
namespace Pvr_UnitySDKAPI.Achievement
{
	public sealed class AchievementCore
	{
		private static bool IsPlatformInitialized = true;

		public static bool LogMessages = false;

		public static bool IsInitialized()
		{
			return IsPlatformInitialized;
		}

		public static void Initialize()
		{
		}

		public static void RegisterNetwork()
		{
			Pvr_AchievementAPI.RegisterNetwork();
		}

		public static void UnRegisterNetwork()
		{
			Pvr_AchievementAPI.UnRegisterNetwork();
		}
	}
	public static class Achievements
	{
		public static Pvr_Request<Pvr_AchievementUpdate> Init()
		{
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementUpdate>(Pvr_AchievementAPI.Init());
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementUpdate> AddCount(string name, long count)
		{
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementUpdate>(Pvr_AchievementAPI.pvr_Achievements_AddCount(name, count));
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementUpdate> AddFields(string name, string fields)
		{
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementUpdate>(Pvr_AchievementAPI.pvr_Achievements_AddFields(name, fields));
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementDefinitionList> GetAllDefinitions()
		{
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementDefinitionList>(Pvr_AchievementAPI.pvr_Achievements_GetAllDefinitions());
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementProgressList> GetAllProgress()
		{
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementProgressList>(Pvr_AchievementAPI.pvr_Achievements_GetAllProgress());
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementDefinitionList> GetDefinitionsByName(string[] names)
		{
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementDefinitionList>(Pvr_AchievementAPI.pvr_Achievements_GetDefinitionsByName(names, (names != null) ? names.Length : 0));
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementProgressList> GetProgressByName(string[] names)
		{
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementProgressList>(Pvr_AchievementAPI.pvr_Achievements_GetProgressByName(names, (names != null) ? names.Length : 0));
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementUpdate> Unlock(string name)
		{
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementUpdate>(Pvr_AchievementAPI.pvr_Achievements_Unlock(name));
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementDefinitionList> GetNextAchievementDefinitionListPage(Pvr_AchievementDefinitionList list)
		{
			if (!list.HasNextPage)
			{
				UnityEngine.Debug.LogWarning("Platform.GetNextAchievementDefinitionListPage: List has no next page");
				return null;
			}
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementDefinitionList>(Pvr_AchievementAPI.pvr_HTTP_GetWithMessageType(list.NextUrl, Pvr_Message.MessageType.Achievements_GetNextAchievementDefinitionArrayPage));
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementProgressList> GetNextAchievementProgressListPage(Pvr_AchievementProgressList list)
		{
			if (!list.HasNextPage)
			{
				UnityEngine.Debug.LogWarning("Platform.GetNextAchievementProgressListPage: List has no next page");
				return null;
			}
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementProgressList>(Pvr_AchievementAPI.pvr_HTTP_GetWithMessageType(list.NextUrl, Pvr_Message.MessageType.Achievements_GetNextAchievementProgressArrayPage));
			}
			return null;
		}
	}
	public enum AchievementType
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("SIMPLE")]
		Simple,
		[Description("BITFIELD")]
		Bitfield,
		[Description("COUNT")]
		Count
	}
	public class Pvr_AchievementAPI
	{
		private static AndroidJavaClass achievementAPI = new AndroidJavaClass("com.pico.achievement.AchievementAPI");

		private static AndroidJavaClass definitionArrayHandle = new AndroidJavaClass("com.picovr.achievement.utils.pvrAchievementDefinitionArrayHandle");

		private static AndroidJavaClass definitionHandle = new AndroidJavaClass("com.picovr.achievement.utils.pvrAchievementDefinitionHandle");

		private static AndroidJavaClass progressArrayHandle = new AndroidJavaClass("com.picovr.achievement.utils.pvrAchievementProgressArrayHandle");

		private static AndroidJavaClass progressHandle = new AndroidJavaClass("com.picovr.achievement.utils.pvrAchievementProgressHandle");

		private static AndroidJavaClass updateHandle = new AndroidJavaClass("com.picovr.achievement.utils.pvrAchievementUpdateHandle");

		private static AndroidJavaObject errorHandle = new AndroidJavaObject("com.picovr.achievement.utils.pvrAchievementErrorHandle");

		private static AndroidJavaObject unityInterface = new AndroidJavaObject("com.pico.loginpaysdk.UnityInterface");

		private static string openId;

		private static string accessToken;

		private static string appId = Pvr_UnitySDKPlatformSetting.Instance.appID;

		internal static long Init()
		{
			AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
			unityInterface.Call("init", @static);
			unityInterface.Call("authSSO");
			AndroidJavaObject androidJavaObject = new AndroidJavaClass("com.pico.loginpaysdk.utils.PicoAccessTokenKeeper").CallStatic<AndroidJavaObject>("readAccessToken", new object[1] { @static });
			accessToken = androidJavaObject.Call<string>("getAccessToken", Array.Empty<object>());
			openId = androidJavaObject.Call<string>("getOpenId", Array.Empty<object>());
			return achievementAPI.CallStatic<long>("init", new object[3] { accessToken, openId, @static });
		}

		internal static void RegisterNetwork()
		{
			AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
			achievementAPI.CallStatic("registerNetwork", @static);
		}

		internal static void UnRegisterNetwork()
		{
			achievementAPI.CallStatic("unregisterNetwork");
		}

		internal static AndroidJavaObject PopMessage()
		{
			return achievementAPI.CallStatic<AndroidJavaObject>("pvr_PopMessage", Array.Empty<object>());
		}

		internal static string pvr_Error_GetMessage(AndroidJavaObject popMessage)
		{
			return errorHandle.CallStatic<string>("pvr_Error_GetMessage", new object[1] { popMessage });
		}

		internal static int pvr_Error_GetHttpCode(AndroidJavaObject popMessage)
		{
			return errorHandle.CallStatic<int>("pvr_Error_GetHttpCode", new object[1] { popMessage });
		}

		internal static int pvr_Error_GetCode(AndroidJavaObject popMessage)
		{
			return errorHandle.CallStatic<int>("pvr_Error_GetCode", new object[1] { popMessage });
		}

		internal static long pvr_Achievements_AddCount(string name, long count)
		{
			return achievementAPI.CallStatic<long>("pvr_Achievements_AddCount", new object[3] { name, count, accessToken });
		}

		internal static long pvr_Achievements_AddFields(string name, string fields)
		{
			return achievementAPI.CallStatic<long>("pvr_Achievements_AddFields", new object[3] { name, fields, accessToken });
		}

		internal static long pvr_Achievements_GetAllDefinitions()
		{
			AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
			return achievementAPI.CallStatic<long>("pvr_Achievements_GetAllDefinitions", new object[2] { appId, @static });
		}

		internal static long pvr_Achievements_GetAllProgress()
		{
			return achievementAPI.CallStatic<long>("pvr_Achievements_GetAllProgress", new object[1] { accessToken });
		}

		internal static long pvr_Achievements_GetDefinitionsByName(string[] names, int v)
		{
			AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
			return achievementAPI.CallStatic<long>("pvr_Achievements_GetDefinitionsByName", new object[2] { names, @static });
		}

		internal static long pvr_Achievements_GetProgressByName(string[] names, int v)
		{
			return achievementAPI.CallStatic<long>("pvr_Achievements_GetProgressByName", new object[2] { names, accessToken });
		}

		internal static long pvr_Achievements_Unlock(string name)
		{
			return achievementAPI.CallStatic<long>("pvr_Achievements_Unlock", new object[2] { name, accessToken });
		}

		internal static long pvr_HTTP_GetWithMessageType(string nextUrl, Pvr_Message.MessageType messageType)
		{
			long result = 0L;
			switch (messageType)
			{
			case Pvr_Message.MessageType.Achievements_GetNextAchievementDefinitionArrayPage:
			{
				AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
				result = achievementAPI.CallStatic<long>("pvr_Achievements_GetAllDefinitionsByUrl", new object[2] { nextUrl, @static });
				break;
			}
			case Pvr_Message.MessageType.Achievements_GetNextAchievementProgressArrayPage:
				result = achievementAPI.CallStatic<long>("pvr_Achievements_GetAllProgressByUrl", new object[1] { nextUrl });
				break;
			}
			return result;
		}

		internal static long pvr_Message_GetType(AndroidJavaObject popMessage)
		{
			return popMessage.Call<AndroidJavaObject>("getHandleType", Array.Empty<object>()).Call<long>("getIndex", Array.Empty<object>());
		}

		internal static bool pvr_Message_IsError(AndroidJavaObject popMessage)
		{
			return popMessage.Call<bool>("isMessage_IsError", Array.Empty<object>());
		}

		internal static long pvr_Message_GetRequestID(AndroidJavaObject popMessage)
		{
			return popMessage.Call<long>("getId", Array.Empty<object>());
		}

		internal static string pvr_Message_GetString(AndroidJavaObject popMessage)
		{
			return popMessage.Call<string>("getContent", Array.Empty<object>());
		}

		internal static bool pvr_AchievementUpdate_GetJustUnlocked(AndroidJavaObject popMessage)
		{
			return updateHandle.CallStatic<bool>("pvr_AchievementUpdate_GetJustUnlocked", new object[1] { popMessage });
		}

		internal static string pvr_AchievementUpdate_GetName(AndroidJavaObject popMessage)
		{
			return updateHandle.CallStatic<string>("pvr_AchievementUpdate_GetName", new object[1] { popMessage });
		}

		internal static int pvr_AchievementProgressArray_GetSize(AndroidJavaObject msg)
		{
			return progressArrayHandle.CallStatic<int>("pvr_AchievementProgressArray_GetSize", new object[1] { msg });
		}

		internal static AndroidJavaObject pvr_AchievementProgressArray_GetElement(AndroidJavaObject msg, int index)
		{
			return progressArrayHandle.CallStatic<AndroidJavaObject>("pvr_AchievementProgressArray_GetElement", new object[2] { msg, index });
		}

		internal static string pvr_AchievementProgressArray_GetNextUrl(AndroidJavaObject msg)
		{
			return progressArrayHandle.CallStatic<string>("pvr_AchievementProgressArray_GetNextUrl", new object[1] { msg });
		}

		internal static string pvr_AchievementProgress_GetBitfield(AndroidJavaObject msg)
		{
			return progressHandle.CallStatic<string>("pvr_AchievementProgress_GetBitfield", new object[1] { msg });
		}

		internal static long pvr_AchievementProgress_GetCount(AndroidJavaObject msg)
		{
			return progressHandle.CallStatic<long>("pvr_AchievementProgress_GetCount", new object[1] { msg });
		}

		internal static bool pvr_AchievementProgress_GetIsUnlocked(AndroidJavaObject msg)
		{
			return progressHandle.CallStatic<bool>("pvr_AchievementProgress_GetIsUnlocked", new object[1] { msg });
		}

		internal static string pvr_AchievementProgress_GetName(AndroidJavaObject msg)
		{
			return progressHandle.CallStatic<string>("pvr_AchievementProgress_GetName", new object[1] { msg });
		}

		internal static DateTime pvr_AchievementProgress_GetUnlockTime(AndroidJavaObject msg)
		{
			new DateTime(1970, 1, 1, 0, 0, 0, 0);
			return DateTimeFromNative(progressHandle.CallStatic<long>("pvr_AchievementProgress_GetUnlockTime", new object[1] { msg }));
		}

		internal static DateTime DateTimeFromNative(long seconds_since_the_one_true_epoch)
		{
			return new DateTime(1970, 1, 1, 0, 0, 0, 0).AddSeconds(seconds_since_the_one_true_epoch).ToLocalTime();
		}

		internal static int pvr_AchievementDefinitionArray_GetSize(AndroidJavaObject msg)
		{
			return definitionArrayHandle.CallStatic<int>("pvr_AchievementDefinitionArray_GetSize", new object[1] { msg });
		}

		internal static AndroidJavaObject pvr_AchievementDefinitionArray_GetElement(AndroidJavaObject msg, int index)
		{
			return definitionArrayHandle.CallStatic<AndroidJavaObject>("pvr_AchievementDefinitionArray_GetElement", new object[2] { msg, index });
		}

		internal static string pvr_AchievementDefinitionArray_GetNextUrl(AndroidJavaObject msg)
		{
			return definitionArrayHandle.CallStatic<string>("pvr_AchievementDefinitionArray_GetNextUrl", new object[1] { msg });
		}

		internal static AchievementType pvr_AchievementDefinition_GetType(AndroidJavaObject msg)
		{
			return (AchievementType)definitionHandle.CallStatic<AndroidJavaObject>("pvr_AchievementDefinition_GetType", new object[1] { msg }).Call<int>("getIndex", Array.Empty<object>());
		}

		internal static string pvr_AchievementDefinition_GetName(AndroidJavaObject msg)
		{
			return definitionHandle.CallStatic<string>("pvr_AchievementDefinition_GetName", new object[1] { msg });
		}

		internal static int pvr_AchievementDefinition_GetBitfieldLength(AndroidJavaObject msg)
		{
			return definitionHandle.CallStatic<int>("pvr_AchievementDefinition_GetBitfieldLength", new object[1] { msg });
		}

		internal static long pvr_AchievementDefinition_GetTarget(AndroidJavaObject msg)
		{
			return definitionHandle.CallStatic<long>("pvr_AchievementDefinition_GetTarget", new object[1] { msg });
		}

		internal static string pvr_AchievementDefinition_GetTitle(AndroidJavaObject msg)
		{
			return definitionHandle.CallStatic<string>("pvr_AchievementDefinition_GetTitle", new object[1] { msg });
		}

		internal static string pvr_AchievementDefinition_GetUnlockedDescription(AndroidJavaObject msg)
		{
			return definitionHandle.CallStatic<string>("pvr_AchievementDefinition_GetUnlocked_description", new object[1] { msg });
		}

		internal static string pvr_AchievementDefinition_GetLockedIcon(AndroidJavaObject msg)
		{
			return definitionHandle.CallStatic<string>("pvr_AchievementDefinition_GetLocked_image", new object[1] { msg });
		}

		internal static bool pvr_AchievementDefinition_GetIsSecrect(AndroidJavaObject msg)
		{
			return definitionHandle.CallStatic<bool>("pvr_AchievementDefinition_GetIs_secret", new object[1] { msg });
		}

		internal static string pvr_AchievementDefinition_GetUnlockedIcon(AndroidJavaObject msg)
		{
			return definitionHandle.CallStatic<string>("pvr_AchievementDefinition_GetUnlocked_image", new object[1] { msg });
		}

		internal static string pvr_AchievementDefinition_GetDescription(AndroidJavaObject msg)
		{
			return definitionHandle.CallStatic<string>("pvr_AchievementDefinition_GetDescription", new object[1] { msg });
		}
	}
	public class Pvr_AchievementDefinition
	{
		public readonly AchievementType Type;

		public readonly string Name;

		public readonly int BitfieldLength;

		public readonly long Target;

		public readonly string Title;

		public readonly string Description;

		public readonly string UnlockedDescription;

		public readonly string UnlockedIcon;

		public readonly string LockedIcon;

		public readonly bool IsSecrect;

		public Pvr_AchievementDefinition(AndroidJavaObject msg)
		{
			Type = Pvr_AchievementAPI.pvr_AchievementDefinition_GetType(msg);
			Name = Pvr_AchievementAPI.pvr_AchievementDefinition_GetName(msg);
			BitfieldLength = Pvr_AchievementAPI.pvr_AchievementDefinition_GetBitfieldLength(msg);
			Target = Pvr_AchievementAPI.pvr_AchievementDefinition_GetTarget(msg);
			Title = Pvr_AchievementAPI.pvr_AchievementDefinition_GetTitle(msg);
			Description = Pvr_AchievementAPI.pvr_AchievementDefinition_GetDescription(msg);
			UnlockedDescription = Pvr_AchievementAPI.pvr_AchievementDefinition_GetUnlockedDescription(msg);
			UnlockedIcon = Pvr_AchievementAPI.pvr_AchievementDefinition_GetUnlockedIcon(msg);
			LockedIcon = Pvr_AchievementAPI.pvr_AchievementDefinition_GetLockedIcon(msg);
			IsSecrect = Pvr_AchievementAPI.pvr_AchievementDefinition_GetIsSecrect(msg);
		}
	}
	public class Pvr_AchievementDefinitionList : Pvr_DeserializableList<Pvr_AchievementDefinition>
	{
		public Pvr_AchievementDefinitionList(AndroidJavaObject msg)
		{
			int num = Pvr_AchievementAPI.pvr_AchievementDefinitionArray_GetSize(msg);
			data = new List<Pvr_AchievementDefinition>(num);
			for (int i = 0; i < num; i++)
			{
				data.Add(new Pvr_AchievementDefinition(Pvr_AchievementAPI.pvr_AchievementDefinitionArray_GetElement(msg, i)));
			}
			nextUrl = Pvr_AchievementAPI.pvr_AchievementDefinitionArray_GetNextUrl(msg);
		}
	}
	public class Pvr_AchievementProgress
	{
		public readonly string Bitfield;

		public readonly long Count;

		public readonly bool IsUnlocked;

		public readonly string Name;

		public readonly DateTime UnlockTime;

		public Pvr_AchievementProgress(AndroidJavaObject msg)
		{
			Bitfield = Pvr_AchievementAPI.pvr_AchievementProgress_GetBitfield(msg);
			Count = Pvr_AchievementAPI.pvr_AchievementProgress_GetCount(msg);
			IsUnlocked = Pvr_AchievementAPI.pvr_AchievementProgress_GetIsUnlocked(msg);
			Name = Pvr_AchievementAPI.pvr_AchievementProgress_GetName(msg);
			UnlockTime = Pvr_AchievementAPI.pvr_AchievementProgress_GetUnlockTime(msg);
		}
	}
	public class Pvr_AchievementProgressList : Pvr_DeserializableList<Pvr_AchievementProgress>
	{
		public Pvr_AchievementProgressList(AndroidJavaObject msg)
		{
			int num = Pvr_AchievementAPI.pvr_AchievementProgressArray_GetSize(msg);
			data = new List<Pvr_AchievementProgress>(num);
			for (int i = 0; i < num; i++)
			{
				data.Add(new Pvr_AchievementProgress(Pvr_AchievementAPI.pvr_AchievementProgressArray_GetElement(msg, i)));
			}
			nextUrl = Pvr_AchievementAPI.pvr_AchievementProgressArray_GetNextUrl(msg);
		}
	}
	public class Pvr_AchievementUpdate
	{
		public readonly bool JustUnlocked;

		public readonly string Name;

		public Pvr_AchievementUpdate(AndroidJavaObject msg)
		{
			JustUnlocked = Pvr_AchievementAPI.pvr_AchievementUpdate_GetJustUnlocked(msg);
			Name = Pvr_AchievementAPI.pvr_AchievementUpdate_GetName(msg);
		}
	}
	public class Pvr_DeserializableList<T> : IList<T>, ICollection<T>, IEnumerable<T>, IEnumerable
	{
		protected List<T> data;

		protected string nextUrl;

		protected string previousUrl;

		public int Count => data.Count;

		bool ICollection<T>.IsReadOnly => ((ICollection<T>)data).IsReadOnly;

		public T this[int index]
		{
			get
			{
				return data[index];
			}
			set
			{
				data[index] = value;
			}
		}

		public bool HasNextPage => !string.IsNullOrEmpty(NextUrl);

		public bool HasPreviousPage => !string.IsNullOrEmpty(PreviousUrl);

		public string NextUrl => nextUrl;

		public string PreviousUrl => previousUrl;

		public int IndexOf(T obj)
		{
			return data.IndexOf(obj);
		}

		public void Add(T item)
		{
			data.Add(item);
		}

		public void Clear()
		{
			data.Clear();
		}

		public bool Contains(T item)
		{
			return data.Contains(item);
		}

		public void CopyTo(T[] array, int arrayIndex)
		{
			data.CopyTo(array, arrayIndex);
		}

		public IEnumerator<T> GetEnumerator()
		{
			return data.GetEnumerator();
		}

		public void Insert(int index, T item)
		{
			data.Insert(index, item);
		}

		public bool Remove(T item)
		{
			return data.Remove(item);
		}

		public void RemoveAt(int index)
		{
			data.RemoveAt(index);
		}

		private IEnumerator GetEnumerator1()
		{
			return GetEnumerator();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator1();
		}
	}
	public static class Pvr_Callback
	{
		private class RequestCallback
		{
			private Pvr_Message.Callback messageCallback;

			public RequestCallback()
			{
			}

			public RequestCallback(Pvr_Message.Callback callback)
			{
				messageCallback = callback;
			}

			public virtual void HandleMessage(Pvr_Message msg)
			{
				if (messageCallback != null)
				{
					messageCallback(msg);
				}
			}
		}

		private sealed class RequestCallback<T> : RequestCallback
		{
			private Pvr_Message<T>.Callback callback;

			public RequestCallback(Pvr_Message<T>.Callback callback)
			{
				this.callback = callback;
			}

			public override void HandleMessage(Pvr_Message msg)
			{
				if (callback != null)
				{
					if (msg is Pvr_Message<T>)
					{
						callback((Pvr_Message<T>)msg);
					}
					else
					{
						UnityEngine.Debug.LogError("Unable to handle message: " + msg.GetType());
					}
				}
			}
		}

		private static Dictionary<long, Request> requestIDsToRequests = new Dictionary<long, Request>();

		private static Dictionary<Pvr_Message.MessageType, RequestCallback> notificationCallbacks = new Dictionary<Pvr_Message.MessageType, RequestCallback>();

		internal static void AddRequest(Request request)
		{
			if (request.RequestID <= 2)
			{
				long requestID = request.RequestID;
				if ((ulong)requestID <= 2uL)
				{
					switch (requestID)
					{
					case 0L:
						UnityEngine.Debug.LogError("An PARAM_INVALIDE error occurred. Request failed.");
						return;
					case 1L:
						UnityEngine.Debug.LogError("An NETWORK_INVALIDE error occurred. Request failed.");
						return;
					case 2L:
						UnityEngine.Debug.LogError("An NOT_INTIALIZE error occurred. Request failed.");
						return;
					}
				}
				UnityEngine.Debug.LogError("An unknown error occurred. Request failed.");
			}
			else
			{
				requestIDsToRequests[request.RequestID] = request;
			}
		}

		internal static void RunCallbacks()
		{
			while (true)
			{
				Pvr_Message pvr_Message = Pvr_Message.PopMessage();
				if (pvr_Message != null)
				{
					HandleMessage(pvr_Message);
					continue;
				}
				break;
			}
		}

		internal static void RunLimitedCallbacks(uint limit)
		{
			for (int i = 0; i < limit; i++)
			{
				Pvr_Message pvr_Message = Pvr_Message.PopMessage();
				if (pvr_Message != null)
				{
					HandleMessage(pvr_Message);
					continue;
				}
				break;
			}
		}

		internal static void OnApplicationQuit()
		{
			requestIDsToRequests.Clear();
			notificationCallbacks.Clear();
		}

		internal static void HandleMessage(Pvr_Message msg)
		{
			if (msg.RequestID != 0L && requestIDsToRequests.TryGetValue(msg.RequestID, out var value))
			{
				try
				{
					value.HandleMessage(msg);
					return;
				}
				finally
				{
					requestIDsToRequests.Remove(msg.RequestID);
				}
			}
			if (notificationCallbacks.TryGetValue(msg.Type, out var value2))
			{
				value2.HandleMessage(msg);
			}
		}
	}
	public class Pvr_CallbackRunner : MonoBehaviour
	{
		public bool IsPersistantBetweenSceneLoads = true;

		private void Awake()
		{
			if (UnityEngine.Object.FindObjectOfType<Pvr_CallbackRunner>() != this)
			{
				UnityEngine.Debug.LogWarning("You only need one instance of CallbackRunner");
			}
			if (IsPersistantBetweenSceneLoads)
			{
				UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
			}
		}

		private void Update()
		{
			Request.RunCallbacks();
		}

		private void OnApplicationQuit()
		{
			Pvr_Callback.OnApplicationQuit();
		}
	}
	public abstract class Pvr_Message<T> : Pvr_Message
	{
		public new delegate void Callback(Pvr_Message<T> message);

		private T data;

		public T Data => data;

		public Pvr_Message(AndroidJavaObject msg)
			: base(msg)
		{
			if (!base.IsError)
			{
				data = GetDataFromMessage(msg);
			}
		}

		protected abstract T GetDataFromMessage(AndroidJavaObject msg);
	}
	public class Pvr_Message
	{
		public delegate void Callback(Pvr_Message message);

		public enum MessageType : uint
		{
			Unknown = 0u,
			Achievements_AddCount = 65495601u,
			Achievements_AddFields = 346693929u,
			Achievements_GetAllDefinitions = 64177549u,
			Achievements_GetAllProgress = 1335877149u,
			Achievements_GetDefinitionsByName = 1653670332u,
			Achievements_GetNextAchievementDefinitionArrayPage = 712888917u,
			Achievements_GetNextAchievementProgressArrayPage = 792913703u,
			Achievements_GetProgressByName = 354837425u,
			Achievements_Unlock = 1497156573u,
			Achievements_WriteAchievementProgress = 121027549u,
			Achievements_VerifyAccessToken = 53284924u
		}

		internal delegate Pvr_Message ExtraMessageTypesHandler(AndroidJavaObject messageHandle, MessageType message_type);

		private MessageType type;

		private long requestID;

		private Error error;

		public MessageType Type => type;

		public bool IsError => error != null;

		public long RequestID => requestID;

		internal static ExtraMessageTypesHandler HandleExtraMessageTypes { private get; set; }

		public Pvr_Message(AndroidJavaObject msg)
		{
			type = (MessageType)Pvr_AchievementAPI.pvr_Message_GetType(msg);
			bool num = Pvr_AchievementAPI.pvr_Message_IsError(msg);
			requestID = Pvr_AchievementAPI.pvr_Message_GetRequestID(msg);
			if (num)
			{
				error = new Error(Pvr_AchievementAPI.pvr_Error_GetCode(msg), Pvr_AchievementAPI.pvr_Error_GetMessage(msg), Pvr_AchievementAPI.pvr_Error_GetHttpCode(msg));
			}
			else if (AchievementCore.LogMessages)
			{
				string text = Pvr_AchievementAPI.pvr_Message_GetString(msg);
				if (text != null)
				{
					UnityEngine.Debug.Log(text);
				}
				else
				{
					UnityEngine.Debug.Log($"null message string {msg}");
				}
			}
		}

		public virtual Error GetError()
		{
			return error;
		}

		public virtual Pvr_AchievementDefinitionList GetAchievementDefinitions()
		{
			return null;
		}

		public virtual Pvr_AchievementProgressList GetAchievementProgressList()
		{
			return null;
		}

		public virtual Pvr_AchievementUpdate GetAchievementUpdate()
		{
			return null;
		}

		public virtual string GetString()
		{
			return null;
		}

		internal static Pvr_Message ParseMessageHandle(AndroidJavaObject messageHandle)
		{
			if (messageHandle == null)
			{
				return null;
			}
			Pvr_Message result = null;
			switch ((MessageType)Pvr_AchievementAPI.pvr_Message_GetType(messageHandle))
			{
			case MessageType.Achievements_GetAllDefinitions:
			case MessageType.Achievements_GetNextAchievementDefinitionArrayPage:
			case MessageType.Achievements_GetDefinitionsByName:
				result = new MessageWithAchievementDefinitions(messageHandle);
				break;
			case MessageType.Achievements_GetProgressByName:
			case MessageType.Achievements_GetNextAchievementProgressArrayPage:
			case MessageType.Achievements_GetAllProgress:
				result = new MessageWithAchievementProgressList(messageHandle);
				break;
			case MessageType.Achievements_VerifyAccessToken:
			case MessageType.Achievements_AddCount:
			case MessageType.Achievements_AddFields:
			case MessageType.Achievements_Unlock:
				result = new MessageWithAchievementUpdate(messageHandle);
				break;
			}
			return result;
		}

		public static Pvr_Message PopMessage()
		{
			return ParseMessageHandle(Pvr_AchievementAPI.PopMessage());
		}
	}
	public class MessageWithAchievementDefinitions : Pvr_Message<Pvr_AchievementDefinitionList>
	{
		public MessageWithAchievementDefinitions(AndroidJavaObject msg)
			: base(msg)
		{
		}

		public override Pvr_AchievementDefinitionList GetAchievementDefinitions()
		{
			return base.Data;
		}

		protected override Pvr_AchievementDefinitionList GetDataFromMessage(AndroidJavaObject msg)
		{
			return new Pvr_AchievementDefinitionList(msg);
		}
	}
	public class MessageWithAchievementProgressList : Pvr_Message<Pvr_AchievementProgressList>
	{
		public MessageWithAchievementProgressList(AndroidJavaObject msg)
			: base(msg)
		{
		}

		public override Pvr_AchievementProgressList GetAchievementProgressList()
		{
			return base.Data;
		}

		protected override Pvr_AchievementProgressList GetDataFromMessage(AndroidJavaObject msg)
		{
			return new Pvr_AchievementProgressList(msg);
		}
	}
	public class MessageWithAchievementUpdate : Pvr_Message<Pvr_AchievementUpdate>
	{
		public MessageWithAchievementUpdate(AndroidJavaObject msg)
			: base(msg)
		{
		}

		public override Pvr_AchievementUpdate GetAchievementUpdate()
		{
			return base.Data;
		}

		protected override Pvr_AchievementUpdate GetDataFromMessage(AndroidJavaObject msg)
		{
			return new Pvr_AchievementUpdate(msg);
		}
	}
	public class MessageWithString : Pvr_Message<string>
	{
		public MessageWithString(AndroidJavaObject msg)
			: base(msg)
		{
		}

		public override string GetString()
		{
			return base.Data;
		}

		protected override string GetDataFromMessage(AndroidJavaObject msg)
		{
			return Pvr_AchievementAPI.pvr_Message_GetString(msg);
		}
	}
	public class Error
	{
		public readonly int Code;

		public readonly int HttpCode;

		public readonly string Message;

		public Error(int code, string message, int httpCode)
		{
			Message = message;
			Code = code;
			HttpCode = httpCode;
		}
	}
	public sealed class Pvr_Request<T> : Request
	{
		private Pvr_Message<T>.Callback callback_;

		public Pvr_Request(long requestID)
			: base(requestID)
		{
		}

		public Pvr_Request<T> OnComplete(Pvr_Message<T>.Callback callback)
		{
			if (callback_ != null)
			{
				throw new UnityException("Attempted to attach multiple handlers to a Request.  This is not allowed.");
			}
			callback_ = callback;
			Pvr_Callback.AddRequest(this);
			return this;
		}

		public override void HandleMessage(Pvr_Message msg)
		{
			if (!(msg is Pvr_Message<T>))
			{
				UnityEngine.Debug.LogError("Unable to handle message: " + msg.GetType());
				return;
			}
			if (callback_ != null)
			{
				callback_((Pvr_Message<T>)msg);
				return;
			}
			throw new UnityException("Request with no handler.  This should never happen.");
		}
	}
	public class Request
	{
		private Pvr_Message.Callback callback_;

		public long RequestID { get; set; }

		public Request(long requestID)
		{
			RequestID = requestID;
		}

		public Request OnComplete(Pvr_Message.Callback callback)
		{
			callback_ = callback;
			Pvr_Callback.AddRequest(this);
			return this;
		}

		public virtual void HandleMessage(Pvr_Message msg)
		{
			if (callback_ != null)
			{
				callback_(msg);
				return;
			}
			throw new UnityException("Request with no handler.  This should never happen.");
		}

		public static void RunCallbacks(uint limit = 0u)
		{
			if (limit == 0)
			{
				Pvr_Callback.RunCallbacks();
			}
			else
			{
				Pvr_Callback.RunLimitedCallbacks(limit);
			}
		}
	}
}
namespace MagicLightProbes
{
	public class MLPDataSaver
	{
		public static void SaveData<T>(T data, string fullFilePath, string consoleString = "")
		{
			BinaryFormatter binaryFormatter = new BinaryFormatter();
			FileStream fileStream = null;
			try
			{
				fileStream = new FileStream(fullFilePath, FileMode.Create);
				binaryFormatter.Serialize(fileStream, data);
				fileStream.Close();
				if (consoleString.Length > 0)
				{
					UnityEngine.Debug.Log(consoleString);
				}
			}
			catch (Exception message)
			{
				UnityEngine.Debug.LogError(message);
				fileStream.Close();
			}
		}

		public static T LoadData<T>(T dataRecipient, string fullFilePath, string consoleStringSuccess = "", string consoleStringFail = "")
		{
			BinaryFormatter binaryFormatter = new BinaryFormatter();
			FileStream fileStream = null;
			bool flag = false;
			try
			{
				if (File.Exists(fullFilePath))
				{
					fileStream = new FileStream(fullFilePath, FileMode.Open);
					flag = true;
				}
				if (flag)
				{
					dataRecipient = (T)binaryFormatter.Deserialize(fileStream);
					fileStream.Close();
					if (consoleStringSuccess.Length > 0)
					{
						UnityEngine.Debug.Log(consoleStringSuccess);
					}
					return dataRecipient;
				}
				if (consoleStringFail.Length > 0)
				{
					UnityEngine.Debug.Log(consoleStringSuccess);
				}
				return dataRecipient;
			}
			catch (Exception message)
			{
				UnityEngine.Debug.LogError(message);
				fileStream.Close();
				return default(T);
			}
		}
	}
	public static class TransformExtensions
	{
		public static bool MLP_IsVisibleFrom(this Transform transform, Camera camera)
		{
			return GeometryUtility.TestPlanesAABB(bounds: new Bounds(transform.position, transform.localScale), planes: GeometryUtility.CalculateFrustumPlanes(camera));
		}
	}
	[ExecuteInEditMode]
	[HelpURL("https://motion-games-studio.gitbook.io/magic-light-probes/system-components/mlp-combined-volume")]
	public class MLPCombinedVolume : MonoBehaviour
	{
	}
	[DisallowMultipleComponent]
	[ExecuteInEditMode]
	[HelpURL("https://motion-games-studio.gitbook.io/magic-light-probes/system-components/mlp-light")]
	public class MLPLight : MonoBehaviour
	{
		public enum CalculationMode
		{
			AccurateShadows,
			LightIntensity
		}

		public enum MLPLightType
		{
			Spot,
			Directional,
			Point,
			Area,
			Mesh
		}

		public enum MLPLightTypeMA
		{
			Area = 3,
			Mesh
		}

		public enum TracePointSettingMode
		{
			Auto,
			Custom
		}

		public enum ShadowmaskMode
		{
			Shadowmask,
			DistanceShadowmask
		}

		public MLPLightType lightType;

		public MLPLightType lastLightType;

		public MLPLightTypeMA lightTypeMA;

		public CalculationMode calculationMode;

		public TracePointSettingMode tracePointSettingMode;

		public LightmapBakeType lightMode;

		public ShadowmaskMode shadowmaskMode;

		public Light targetLight;

		public GameObject parentGameObject;

		public Vector3 position;

		public Vector3 forward;

		public bool saveNearbyProbes;

		public float saveRadius;

		public float range;

		public bool useSourceParameters;

		public bool reverseDirection;

		public float angle;

		public bool customTracePoints;

		public bool accurateTrace;

		public int accuracy;

		public int lastAccuracy;

		public bool isDirectional;

		public float tracePointSize = 0.3f;

		public float lastTracePointSize;

		public MeshFilter lastMesh;

		public List<GameObject> tracePoints = new List<GameObject>();

		public List<MLPTracePoint> tracePointsData = new List<MLPTracePoint>();

		public MLPTracePoint mainTracePoint;

		public MagicLightProbes parentVolume;

		public bool showOptionsInManagerWindow;

		public float intensity;

		public bool resetEditor;

		public bool showLightOnScene;

		public bool saveOnOutOfRange;

		public bool isHDRP;

		public Vector2 hdrpAreaSize;
	}
	public class MLPPointData
	{
		public float lightIntensity;

		public float maxIntencity;

		public Vector3 position;

		public int col;

		public int row;

		public int depth;

		public List<float> distancesToLights = new List<float>();

		public List<Vector3> collisionPoints = new List<Vector3>();

		public List<MLPPointData> nearbyPoints = new List<MLPPointData>();

		public List<MLPPointData> nearbyPointsOptimaziable = new List<MLPPointData>();

		public bool removed;

		public bool outOfRange;

		public bool inSaveRange;

		public bool savedNearGeometry;

		public bool contrastOnOutOfRangeArea;

		public bool inRangeOfLight;

		public bool contrastOnShadingArea;

		public bool equalIntensity;

		public bool equalColor;

		public bool borderPoint;

		public bool outOfMaxHeight;

		public float angleToLight;

		public Vector3 contactPoint;

		public bool inCorner;

		public bool lockForCull;

		public bool onGeometryEdge;

		public bool lightLeakLocked;

		public Vector3 collisionNormal;

		public List<MLPLight> inRangeForLights = new List<MLPLight>();

		public List<MLPLight> inShadowForLights = new List<MLPLight>();

		public GameObject temporaryObject;

		public GameObject collisionObject;

		public Color averagedColor;

		public bool xEndPoint;

		public bool yEndPoint;

		public bool zEndPoint;

		public bool xStartPoint;

		public bool yStartPoint;

		public bool zStartPoint;

		public int equivalent;

		public float avaragedColorValue;

		public bool isUnlit;

		public void SetPosition(Vector3 position)
		{
			this.position = position;
		}

		public void SetOutOfRange(bool visibility)
		{
			outOfRange = visibility;
		}

		public void SetLightIntensity(float intensity)
		{
			lightIntensity = intensity;
		}

		public void SetInSaveRange(bool value)
		{
			inSaveRange = value;
		}

		public void SetInContrastArea(bool value)
		{
			contrastOnShadingArea = value;
		}
	}
	[ExecuteInEditMode]
	public class MLPPortal : MonoBehaviour
	{
		public float yStep;

		public float zStep;

		public int yCounter;

		public int zCounter;

		public bool calculate;

		private void Start()
		{
		}

		private void Update()
		{
			if (calculate)
			{
				calculate = false;
				DrawRayX(Vector3.zero);
			}
		}

		private void DrawRayX(Vector3 dir)
		{
			Vector3 vector = ((!(dir == Vector3.zero)) ? dir : Vector3.forward);
			if (yCounter < (int)(360f / yStep))
			{
				yCounter++;
				UnityEngine.Debug.DrawRay(base.transform.position, vector, Color.blue, 1E+09f);
				DrawRayX(Quaternion.AngleAxis(0f - yStep, Vector3.up) * vector);
				DrawRayZ(Vector3.zero);
			}
		}

		private void DrawRayZ(Vector3 dir)
		{
			Vector3 vector = ((!(dir == Vector3.zero)) ? dir : Vector3.forward);
			if (zCounter < (int)(360f / yStep))
			{
				zCounter++;
				UnityEngine.Debug.DrawRay(base.transform.position, vector, Color.blue, 1E+09f);
				DrawRayZ(Quaternion.AngleAxis(0f - zStep, Vector3.left) * vector);
			}
		}
	}
	[HelpURL("https://motion-games-studio.gitbook.io/magic-light-probes/system-components/mlp-quick-editing")]
	public class MLPQuickEditing : MonoBehaviour
	{
		public MagicLightProbes parent;

		public float gizmoScale;

		public float drawDistance = 10f;
	}
	[Serializable]
	public class MLPTracePoint
	{
		public Vector3 position;

		public Vector3 forward;

		public string name;

		public GameObject pointGameObject;
	}
	[ExecuteInEditMode]
	public class MLPVolume : MonoBehaviour
	{
		[HideInInspector]
		public MagicLightProbes parentRootComponent;

		[HideInInspector]
		public MeshRenderer selfRenderer;

		[HideInInspector]
		public bool showGizmo;

		public bool showGizmoSelected;

		public bool isPartVolume;

		public bool isSubdividedPart;

		public bool isCalculated;

		public bool isInProcess;

		public bool skipped;

		public int id;

		public Color colorOnSelection;

		public List<MLPPointData> localAcceptedPoints = new List<MLPPointData>();

		public List<MLPPointData> localNearbyGeometryPoints = new List<MLPPointData>();

		public List<MLPPointData> localContrastPoints = new List<MLPPointData>();

		public List<MLPPointData> localCornerPoints = new List<MLPPointData>();

		public List<Vector3> localNearbyGeometryPointsPositions = new List<Vector3>();

		public List<Vector3> resultNearbyGeometryPointsPositions = new List<Vector3>();

		public List<Vector3> localCornerPointsPositions = new List<Vector3>();

		public List<Vector3> resultLocalCornerPointsPositions = new List<Vector3>();

		public List<Vector3> localEquivalentPointsPositions = new List<Vector3>();

		public List<Vector3> resultLocalEquivalentPointsPositions = new List<Vector3>();

		public List<Vector3> resultLocalFreePointsPositions = new List<Vector3>();

		public List<Vector3> localUnlitPointsPositions = new List<Vector3>();

		public List<Vector3> localFreePointsPositions = new List<Vector3>();

		public List<Vector3> resultLocalUnlitPointsPositions = new List<Vector3>();

		public List<Vector3> localDirections = new List<Vector3>();

		public List<Vector3> localAvaragedDirections = new List<Vector3>();

		public List<MLPPointData> localColorThresholdEditingPoints = new List<MLPPointData>();

		public int objectsInside;
	}
	[ExecuteInEditMode]
	[HelpURL("https://motion-games-studio.gitbook.io/magic-light-probes/system-components/main-component")]
	public class MagicLightProbes : MonoBehaviour
	{
		public struct VolumeParameters
		{
			public int volumeIndex;

			public Vector3 position;

			public Vector3 demensions;

			public VolumeParameters(int _volumeIndex, Vector3 _position, Vector3 _demensions)
			{
				volumeIndex = _volumeIndex;
				position = _position;
				demensions = _demensions;
			}
		}

		public enum FillingMode
		{
			VerticalDublicating,
			FullFilling,
			SeparateFilling
		}

		public enum Workflow
		{
			Simple,
			Advanced
		}

		public enum BoundsDisplayMode
		{
			Always,
			OnSelection
		}

		public enum DebugPasses
		{
			MaximumHeight,
			GeometryCollision,
			GeometryIntersections,
			NearGeometry,
			OutOfRange,
			OutOfRangeBorders,
			ShadingBorders,
			ContrastAreas,
			NearLights,
			LightIntensity,
			UnlitProbes,
			EqualProbes,
			GeometryEdges,
			EqualColor
		}

		public enum DrawModes
		{
			Accepted,
			Culled,
			Both
		}

		public enum CalculationTarget
		{
			GeometryEdges,
			GeneralCalculation
		}

		[Serializable]
		private struct TempPointData
		{
			public float xPos;

			public float yPos;

			public float zPos;

			public TempPointData(Vector3 _position)
			{
				xPos = _position.x;
				yPos = _position.y;
				zPos = _position.z;
			}
		}

		[Serializable]
		public class WorkPathFoundEvent : UnityEvent<string>
		{
		}

		private const string COMPUTE_SHADERS_FOLDER = "/Passes/Compute Shaders/";

		public IEnumerator colorThresholdRecalculationRoutine;

		public IEnumerator lightProbesVolumeCalculatingRoutine;

		public IEnumerator lightProbesVolumeCalculatingSubRoutine;

		public IEnumerator executingPassesRoutine;

		public IEnumerator volumeDivideingRoutine;

		public List<string> groundAndFloorKeywords = new List<string>();

		public List<string> storedGroundAndFloorKeywords = new List<string>();

		public GameObject probesVolume;

		public bool useDynamicDensity;

		public float volumeSpacing = 0.4f;

		public float volumeSpacingMin = 0.4f;

		public float volumeSpacingMax = 5f;

		public float cornersDetectionThreshold = 0.4f;

		public float cornersDetectionThresholdMin = 0.4f;

		public float cornersDetectionThresholdMax = 5f;

		public float lastCornersDetectionThreshold;

		public float lastCornersDetectionThresholdMin;

		public float lastCornersDetectionThresholdMax;

		public int lastMaxProbesInVolume;

		public int maxProbesInVolume = 10000;

		public int defaultMaxProbesCount;

		public float lastVolumeSpacing;

		public float lastVolumeSpacingMin;

		public float lastVolumeSpacingMax;

		public bool volumeSpacingChanged;

		public bool tooManySubVolumes;

		public FillingMode fillingMode = FillingMode.SeparateFilling;

		public Workflow workflow;

		public float maxHeightAboveGeometry = 3.5f;

		public float lastMaxHeightAboveGeometry;

		public float maxHeightAboveTerrain = 3.5f;

		public bool considerDistanceToLights = true;

		public float lightIntensityTreshold = 0.5f;

		public float colorTreshold = 0.01f;

		public float collisionDetectionRadius = 0.1f;

		public bool saveProbesNearbyGeometry = true;

		public float cornerProbesSpacing = 0.5f;

		public float nearbyGeometryDetectionRadius = 0.5f;

		public float nearbyGeometryDetectionRadiusMin;

		public float nearbyGeometryDetectionRadiusMax;

		public float distanceFromNearbyGeometry = 0.1f;

		public bool fillEquivalentVolume;

		public float equivalentVolumeFillingRate;

		public bool fillUnlitVolume;

		public bool fillFreeVolume = true;

		public float unlitVolumeFillingRate;

		public float freeVolumeFillingRate = 0.01f;

		public bool cullAcceptedVolume;

		public float acceptedVolumeFillingRate;

		public float nearbyGeometryVolumeFillingRate;

		public float verticalDublicatingHeight = 3.5f;

		public float verticalDublicatingStep = 1f;

		public LayerMask raycastFilter;

		public List<MLPLight> excludedLights = new List<MLPLight>();

		public LayerMask layerMask = 1;

		public int firstCollisionLayer;

		public bool useMultithreading = true;

		public GameObject previousSelection;

		public bool unloaded;

		public bool sceneChanging;

		public bool waitForPrevious;

		public MagicLightProbes previousVolume;

		public bool optimizeForMixedLighting;

		public bool lastOptimizeForMixedLightingValue;

		public bool lastUseDynamicDensityValue;

		public bool preventLeakageThroughWalls;

		public bool useVolumeBottom;

		public bool placeProbesOnGeometryEdges = true;

		public float lastColorThreshold;

		public float lastLightIntensityThreshold;

		public float lastEquivalentVolumeFillingRate;

		public float lastUnlitVolumeFillingRate;

		public float lastFreeVolumeFillingRate;

		public float lastCornerProbesSpacing;

		public float lastDistanceFromGeometry;

		public bool debugMode;

		public float debugObjectScale = 0.1f;

		public BoundsDisplayMode boundsDisplayMode;

		public DebugPasses debugPass;

		public DrawModes drawMode;

		public bool debugShowLightIntensity;

		public bool showPreviewGrid;

		public bool nextStep;

		public bool cullByColor = true;

		public bool forceSaveProbesOnShadingBorders = true;

		public string dataPath;

		public string workPath;

		public bool workPathFound;

		public List<Vector3> localFinishedPositions = new List<Vector3>();

		public ComputeShader calculateVolumeFilling;

		public ComputeShader calculateProbeSpacing;

		public ComputeShader calculateDistanceFromGeometry;

		public MLPVolume currentVolume;

		public MLPQuickEditing quickEditingComponent;

		public bool recalculationRequired;

		private List<Collider> lightColliders = new List<Collider>();

		private List<Collider> objectColliders = new List<Collider>();

		private List<MLPPointData> finalDebugAcceptedPoints = new List<MLPPointData>();

		private List<MLPPointData> finalDebugCulledPoints = new List<MLPPointData>();

		private List<GameObject> tempObjects = new List<GameObject>();

		private List<GameObject> temporarilyDisabledDynamicObjects = new List<GameObject>();

		private List<GameObject> staticObjectsWithoutCollider = new List<GameObject>();

		private GameObject combinedVolumeObject;

		private VolumeParameters currentEditingVolume;

		private Vector3 currentSelectedObjectLastPosition;

		private GameObject lastSelectedObject;

		public bool cancelCombination;

		public List<IEnumerator> passesToExecute = new List<IEnumerator>();

		public List<GameObject> staticObjects = new List<GameObject>();

		public List<MLPLight> lights = new List<MLPLight>();

		public List<MLPPointData> tmpSharedPointsArray = new List<MLPPointData>();

		public List<MLPPointData> tmpOutOfRangePoints = new List<MLPPointData>();

		public List<MLPPointData> tmpOutOfMaxHeightPoints = new List<MLPPointData>();

		public List<MLPPointData> tmpGeometryCollisionPoints = new List<MLPPointData>();

		public List<MLPPointData> tmpContrastOnOutOfRangePoints = new List<MLPPointData>();

		public List<MLPPointData> tmpContrastShadingBordersPoints = new List<MLPPointData>();

		public List<MLPPointData> tmpUnlitPoints = new List<MLPPointData>();

		public List<MLPPointData> tmpFreePoints = new List<MLPPointData>();

		public List<MLPPointData> tmpNearbyGeometryPoints = new List<MLPPointData>();

		public List<MLPPointData> tmpPointsNearGeometryIntersections = new List<MLPPointData>();

		public List<MLPPointData> tmpNearbyLightsPoints = new List<MLPPointData>();

		public List<MLPPointData> tmpEqualPoints = new List<MLPPointData>();

		public List<MLPPointData> debugCulledPoints = new List<MLPPointData>();

		public List<MLPPointData> debugAcceptedPoints = new List<MLPPointData>();

		public List<GameObject> subVolumesDivided = new List<GameObject>();

		public List<Vector3> points = new List<Vector3>();

		public List<VolumeParameters> innerVolumes = new List<VolumeParameters>();

		public List<VolumeParameters> subVolumesParameters = new List<VolumeParameters>();

		public List<MagicLightProbes> innerVolumesObjects = new List<MagicLightProbes>();

		public List<LayerMask> layerMasks = new List<LayerMask>();

		public List<Vector3> transformedPoints = new List<Vector3>();

		public string assetEditorPath;

		public MagicLightProbes parentVolume;

		public static bool operationalDataLost = true;

		public bool localOperationalDataLost = true;

		public bool recombinationNeeded;

		public bool isInBackground;

		public bool realtimeEditing;

		public bool calculated;

		public bool calculatingError;

		public int xPointsCount;

		public int yPointsCount;

		public int zPointsCount;

		public float prevVolumeScaleX;

		public float prevVolumeScaleY;

		public float prevVolumeScaleZ;

		public int totalProbes;

		public int totalProbesInSubVolume;

		public int totalProbesInVolume;

		public bool calculatingVolume;

		public bool calculatingVolumeSubPass;

		public string currentPass;

		public int currentPassProgressCounter;

		public int currentPassProgressFrameSkipper;

		public float totalProgress;

		public float currentPassProgress;

		public int selectedTab;

		public bool showOptionsInManagerWindow;

		public bool restored = true;

		public int currentVolumePart;

		public float eta;

		public bool changed;

		public bool redivideParts;

		public bool combinedVolumeError;

		private bool passesExecuting;

		private int totalProgressCounter;

		private int totalProgressFrameSkipper;

		private float startTime;

		private float endTime;

		private bool scenePreparing;

		public void CheckForNearContrast(MLPPointData pointForCheck)
		{
			bool flag = true;
			List<MLPPointData> list = new List<MLPPointData>();
			foreach (MLPPointData item in tmpSharedPointsArray)
			{
				if (Vector3.Distance(item.position, pointForCheck.position) <= 2f)
				{
					list.Add(item);
				}
			}
			foreach (MLPPointData item2 in list)
			{
				if (!item2.contrastOnOutOfRangeArea && !item2.contrastOnShadingArea)
				{
					flag = false;
					break;
				}
			}
			if (flag)
			{
				tmpSharedPointsArray.Add(pointForCheck);
			}
		}

		public bool UpdateProgress(int count, int period = 100)
		{
			currentPassProgress = (float)currentPassProgressCounter / (float)count * 100f;
			currentPassProgressCounter++;
			currentPassProgressFrameSkipper++;
			if (currentPassProgressFrameSkipper == period)
			{
				currentPassProgressFrameSkipper = 0;
				return true;
			}
			return false;
		}

		private bool UpdateTotalProgress(int count, int period = 100)
		{
			totalProgress = (float)totalProgressCounter / (float)count * 100f;
			totalProgressCounter++;
			totalProgressFrameSkipper++;
			if (totalProgressFrameSkipper == period)
			{
				totalProgressFrameSkipper = 0;
				return true;
			}
			return false;
		}
	}
	public class CheckForLightLeakAreas
	{
		public IEnumerator ExecutePass(MagicLightProbes parent)
		{
			parent.totalProbesInSubVolume = parent.tmpSharedPointsArray.Count;
			parent.currentPass = "Check For Light Leak Areas...";
			parent.currentPassProgressCounter = 0;
			parent.currentPassProgressFrameSkipper = 0;
			for (int i = 0; i < parent.tmpNearbyGeometryPoints.Count; i++)
			{
				GameObject gameObject = GameObject.CreatePrimitive(PrimitiveType.Sphere);
				gameObject.name = "Temporary Point " + i;
				gameObject.transform.position = parent.tmpNearbyGeometryPoints[i].position;
				gameObject.transform.localScale = new Vector3(0.1f, 0.1f, 0.1f);
				gameObject.AddComponent<SphereCollider>().radius = 0.1f;
				parent.tmpNearbyGeometryPoints[i].temporaryObject = gameObject;
				if (!parent.isInBackground && parent.UpdateProgress(parent.tmpNearbyGeometryPoints.Count))
				{
					yield return null;
				}
			}
			for (int j = 0; j < parent.tmpNearbyGeometryPoints.Count; j++)
			{
				if (parent.tmpNearbyGeometryPoints[j].collisionObject != null)
				{
					parent.tmpNearbyGeometryPoints[j].collisionObject.SetActive(value: false);
					if (Physics.Raycast(new Ray(parent.tmpNearbyGeometryPoints[j].position, (parent.tmpNearbyGeometryPoints[j].contactPoint - parent.tmpNearbyGeometryPoints[j].position).normalized), out var hitInfo, float.PositiveInfinity, parent.layerMask) && hitInfo.collider.name.Contains("Temporary Point"))
					{
						parent.tmpNearbyGeometryPoints[j].lightLeakLocked = true;
					}
					parent.tmpNearbyGeometryPoints[j].collisionObject.SetActive(value: true);
				}
			}
			for (int k = 0; k < parent.tmpNearbyGeometryPoints.Count; k++)
			{
				UnityEngine.Object.DestroyImmediate(parent.tmpNearbyGeometryPoints[k].temporaryObject);
			}
			parent.totalProbesInSubVolume = parent.tmpSharedPointsArray.Count;
			parent.calculatingVolumeSubPass = false;
		}
	}
	public class DublicateVertical
	{
		public IEnumerator ExecutePass(MagicLightProbes parent)
		{
			parent.currentPass = "Check For Nearby Geometry...";
			parent.currentPassProgressCounter = 0;
			parent.currentPassProgressFrameSkipper = 0;
			int steps = Mathf.RoundToInt(parent.verticalDublicatingHeight / parent.verticalDublicatingStep);
			List<MLPPointData> candidates = new List<MLPPointData>();
			List<MLPPointData> savedNearGeometry = new List<MLPPointData>();
			parent.tmpSharedPointsArray.AddRange(parent.tmpNearbyGeometryPoints);
			for (int j = 0; j < parent.tmpSharedPointsArray.Count; j++)
			{
				if (parent.tmpSharedPointsArray[j].savedNearGeometry)
				{
					if (Vector3.Dot(-Vector3.up, (parent.tmpSharedPointsArray[j].contactPoint - parent.tmpSharedPointsArray[j].position).normalized) == 1f)
					{
						candidates.Add(parent.tmpSharedPointsArray[j]);
					}
					else
					{
						savedNearGeometry.Add(parent.tmpSharedPointsArray[j]);
					}
				}
				if (parent.UpdateProgress(parent.tmpSharedPointsArray.Count, 1000))
				{
					yield return null;
				}
			}
			parent.tmpSharedPointsArray.Clear();
			for (int j = 0; j < steps; j++)
			{
				parent.currentPass = "Vertical Dublicating Step " + j + "/" + steps;
				parent.currentPassProgressCounter = 0;
				parent.currentPassProgressFrameSkipper = 0;
				foreach (MLPPointData item in candidates)
				{
					MLPPointData mLPPointData = new MLPPointData();
					mLPPointData.position = new Vector3(item.position.x, item.position.y + parent.verticalDublicatingStep * (float)j, item.position.z);
					if (parent.probesVolume.GetComponent<MeshRenderer>().bounds.Contains(mLPPointData.position))
					{
						parent.tmpSharedPointsArray.Add(mLPPointData);
					}
					if (!parent.isInBackground && parent.UpdateProgress(parent.tmpSharedPointsArray.Count, 1000))
					{
						yield return null;
					}
				}
			}
			parent.tmpSharedPointsArray.AddRange(candidates);
			parent.tmpSharedPointsArray.AddRange(savedNearGeometry);
			parent.tmpSharedPointsArray.AddRange(parent.tmpPointsNearGeometryIntersections);
			parent.calculatingVolumeSubPass = false;
		}
	}
	public static class RandomGen
	{
		private static System.Random _global = new System.Random();

		[ThreadStatic]
		private static System.Random _local;

		public static int Next(int min, int max)
		{
			System.Random random = _local;
			if (random == null)
			{
				int seed;
				lock (_global)
				{
					seed = _global.Next(min, max);
				}
				random = (_local = new System.Random(seed));
			}
			return random.Next(min, max);
		}
	}
	public class EquivalentProbesOptimization
	{
		public IEnumerator ExecutePass(MagicLightProbes parent, MLPVolume currentVolume = null, bool realtimeEditing = false)
		{
			parent.currentPass = "Equivalent Probes Optimization...";
			parent.currentPassProgressCounter = 0;
			parent.currentPassProgressFrameSkipper = 0;
			if (parent.debugMode)
			{
				parent.tmpSharedPointsArray.Clear();
				parent.debugAcceptedPoints.Clear();
			}
			if (currentVolume.localEquivalentPointsPositions.Count > 0)
			{
				currentVolume.resultLocalEquivalentPointsPositions.Clear();
				ComputeBuffer computeBuffer = new ComputeBuffer(currentVolume.localEquivalentPointsPositions.Count, 12, ComputeBufferType.Default);
				ComputeBuffer computeBuffer2 = new ComputeBuffer(currentVolume.localEquivalentPointsPositions.Count, 12, ComputeBufferType.Default);
				computeBuffer.SetData(currentVolume.localEquivalentPointsPositions.ToArray());
				computeBuffer2.SetData(currentVolume.localEquivalentPointsPositions.ToArray());
				parent.calculateVolumeFilling.SetBuffer(parent.calculateVolumeFilling.FindKernel("CSMain"), "inputArray", computeBuffer);
				parent.calculateVolumeFilling.SetBuffer(parent.calculateVolumeFilling.FindKernel("CSMain"), "exitArray", computeBuffer2);
				parent.calculateVolumeFilling.SetFloat("threshold", parent.equivalentVolumeFillingRate);
				parent.calculateVolumeFilling.Dispatch(parent.calculateVolumeFilling.FindKernel("CSMain"), 256, 1, 1);
				Vector3[] exit = new Vector3[computeBuffer.count];
				computeBuffer2.GetData(exit);
				computeBuffer.Dispose();
				computeBuffer2.Dispose();
				List<MLPPointData> tempList = new List<MLPPointData>();
				tempList.AddRange(parent.tmpEqualPoints);
				for (int i = 0; i < exit.Length; i++)
				{
					if (!(exit[i] == Vector3.zero))
					{
						if (!realtimeEditing)
						{
							tempList[i].position = exit[i];
							parent.tmpSharedPointsArray.Add(tempList[i]);
						}
						currentVolume.resultLocalEquivalentPointsPositions.Add(exit[i]);
						if (!parent.isInBackground && parent.UpdateProgress(exit.Length, 1000))
						{
							yield return null;
						}
					}
				}
				if (parent.debugMode)
				{
					parent.debugAcceptedPoints.AddRange(parent.tmpSharedPointsArray);
				}
			}
			parent.totalProbesInSubVolume = parent.tmpSharedPointsArray.Count;
			parent.calculatingVolumeSubPass = false;
		}
	}
	public class PartialVolumeFilling
	{
		public enum TargetPoint
		{
			Unlit,
			Equivalent,
			Free
		}

		public IEnumerator ExecutePass(MagicLightProbes parent, TargetPoint targetPoint, MLPVolume currentVolume = null, bool realtimeEditing = false)
		{
			List<MLPPointData> tempList = new List<MLPPointData>();
			List<Vector3> realTimeEditingList = new List<Vector3>();
			List<Vector3> targetPoints = new List<Vector3>();
			float fillingRate = 0f;
			switch (targetPoint)
			{
			case TargetPoint.Unlit:
				parent.currentPass = "Unlit Probes Processing Pass 1/2";
				targetPoints.AddRange(currentVolume.localUnlitPointsPositions);
				currentVolume.resultLocalFreePointsPositions.Clear();
				currentVolume.resultLocalUnlitPointsPositions.Clear();
				fillingRate = parent.unlitVolumeFillingRate;
				tempList.AddRange(parent.tmpUnlitPoints);
				break;
			case TargetPoint.Equivalent:
				parent.currentPass = "Equivalent Probes Processing Pass 1/2";
				targetPoints.AddRange(currentVolume.localEquivalentPointsPositions);
				currentVolume.resultLocalFreePointsPositions.Clear();
				currentVolume.resultLocalEquivalentPointsPositions.Clear();
				fillingRate = parent.equivalentVolumeFillingRate;
				tempList.AddRange(parent.tmpEqualPoints);
				break;
			case TargetPoint.Free:
				parent.currentPass = "Free Probes Processing";
				targetPoints.AddRange(currentVolume.localFreePointsPositions);
				currentVolume.resultLocalFreePointsPositions.Clear();
				currentVolume.resultLocalEquivalentPointsPositions.Clear();
				currentVolume.resultLocalUnlitPointsPositions.Clear();
				fillingRate = parent.freeVolumeFillingRate;
				tempList.AddRange(parent.tmpFreePoints);
				break;
			}
			_ = realtimeEditing;
			realTimeEditingList.AddRange(targetPoints);
			parent.currentPassProgressCounter = 0;
			parent.currentPassProgressFrameSkipper = 0;
			if (targetPoints.Count > 0)
			{
				if (SystemInfo.supportsComputeShaders)
				{
					ComputeBuffer computeBuffer = new ComputeBuffer(targetPoints.Count, 12, ComputeBufferType.Default);
					ComputeBuffer computeBuffer2 = new ComputeBuffer(targetPoints.Count, 12, ComputeBufferType.Default);
					computeBuffer.SetData(targetPoints.ToArray());
					computeBuffer2.SetData(targetPoints.ToArray());
					parent.calculateVolumeFilling.SetBuffer(parent.calculateVolumeFilling.FindKernel("CSMain"), "inputArray", computeBuffer);
					parent.calculateVolumeFilling.SetBuffer(parent.calculateVolumeFilling.FindKernel("CSMain"), "exitArray", computeBuffer2);
					parent.calculateVolumeFilling.SetFloat("threshold", fillingRate);
					parent.calculateVolumeFilling.Dispatch(parent.calculateVolumeFilling.FindKernel("CSMain"), 256, 1, 1);
					Vector3[] exit = new Vector3[computeBuffer.count];
					computeBuffer2.GetData(exit);
					computeBuffer.Dispose();
					computeBuffer2.Dispose();
					for (int j = 0; j < exit.Length; j++)
					{
						if (!(exit[j] == Vector3.zero))
						{
							if (!realtimeEditing)
							{
								tempList[j].position = exit[j];
								parent.tmpSharedPointsArray.Add(tempList[j]);
							}
							switch (targetPoint)
							{
							case TargetPoint.Unlit:
								currentVolume.resultLocalUnlitPointsPositions.Add(exit[j]);
								break;
							case TargetPoint.Equivalent:
								currentVolume.resultLocalEquivalentPointsPositions.Add(exit[j]);
								break;
							case TargetPoint.Free:
								currentVolume.resultLocalFreePointsPositions.Add(exit[j]);
								break;
							}
							if (parent.UpdateProgress(exit.Length, 1000))
							{
								yield return null;
							}
						}
					}
				}
				else
				{
					for (int j = 0; j < Mathf.RoundToInt((float)targetPoints.Count * (1f - fillingRate)); j++)
					{
						realTimeEditingList.Remove(realTimeEditingList[UnityEngine.Random.Range(0, realTimeEditingList.Count)]);
						if (parent.UpdateProgress(Mathf.RoundToInt((float)targetPoints.Count * (1f - fillingRate))))
						{
							yield return null;
						}
					}
					if (!realtimeEditing)
					{
						parent.tmpSharedPointsArray.AddRange(tempList);
						for (int l = 0; l < tempList.Count; l++)
						{
							switch (targetPoint)
							{
							case TargetPoint.Unlit:
								currentVolume.resultLocalUnlitPointsPositions.Add(tempList[l].position);
								break;
							case TargetPoint.Equivalent:
								currentVolume.resultLocalEquivalentPointsPositions.Add(tempList[l].position);
								break;
							case TargetPoint.Free:
								currentVolume.resultLocalFreePointsPositions.Add(tempList[l].position);
								break;
							}
						}
					}
					else
					{
						for (int m = 0; m < realTimeEditingList.Count; m++)
						{
							switch (targetPoint)
							{
							case TargetPoint.Unlit:
								currentVolume.resultLocalUnlitPointsPositions.Add(realTimeEditingList[m]);
								break;
							case TargetPoint.Equivalent:
								currentVolume.resultLocalEquivalentPointsPositions.Add(realTimeEditingList[m]);
								break;
							case TargetPoint.Free:
								currentVolume.resultLocalFreePointsPositions.Add(realTimeEditingList[m]);
								break;
							}
						}
					}
				}
				if (targetPoint == TargetPoint.Unlit && !realtimeEditing)
				{
					parent.currentPass = "Unlit Probes Optimization Pass 2/2";
					parent.currentPassProgressCounter = 0;
					parent.currentPassProgressFrameSkipper = 0;
					for (int j = 0; j < tempList.Count; j++)
					{
						if (!tempList[j].lockForCull)
						{
							parent.CheckForNearContrast(tempList[j]);
						}
						if (!parent.isInBackground && parent.UpdateProgress(tempList.Count))
						{
							yield return null;
						}
					}
				}
			}
			parent.totalProbesInSubVolume = parent.tmpSharedPointsArray.Count;
			parent.calculatingVolumeSubPass = false;
		}
	}
	public class RemoveUnusedPoints
	{
		public IEnumerator ExecutePass(MagicLightProbes parent)
		{
			parent.currentPass = "Romoving Unused Points...";
			parent.currentPassProgressCounter = 0;
			parent.currentPassProgressFrameSkipper = 0;
			List<MLPPointData> pointsToRemove = new List<MLPPointData>();
			if (parent.debugMode)
			{
				if (parent.subVolumesDivided.Count > 0)
				{
					for (int i = 0; i < parent.debugAcceptedPoints.Count; i++)
					{
						if (parent.debugAcceptedPoints[i].col == parent.xPointsCount - 1 || parent.debugAcceptedPoints[i].depth == parent.zPointsCount)
						{
							pointsToRemove.Add(parent.debugAcceptedPoints[i]);
						}
						if (!parent.isInBackground && parent.UpdateProgress(parent.debugAcceptedPoints.Count))
						{
							yield return null;
						}
					}
					for (int k = 0; k < pointsToRemove.Count; k++)
					{
						parent.debugAcceptedPoints.Remove(pointsToRemove[k]);
					}
				}
			}
			else if (parent.subVolumesDivided.Count > 0)
			{
				for (int i = 0; i < parent.tmpNearbyGeometryPoints.Count; i++)
				{
					if (parent.tmpNearbyGeometryPoints[i].col == parent.xPointsCount - 1 || parent.tmpNearbyGeometryPoints[i].depth == parent.zPointsCount)
					{
						pointsToRemove.Add(parent.tmpNearbyGeometryPoints[i]);
					}
					if (!parent.isInBackground && parent.UpdateProgress(parent.tmpNearbyGeometryPoints.Count))
					{
						yield return null;
					}
				}
				for (int l = 0; l < pointsToRemove.Count; l++)
				{
					parent.tmpNearbyGeometryPoints.Remove(pointsToRemove[l]);
				}
			}
			pointsToRemove.Clear();
			parent.calculatingVolumeSubPass = false;
		}
	}
	public class SetDistanceFromGeometry
	{
		public IEnumerator ExecutePass(MagicLightProbes parent, MLPVolume currentVolume)
		{
			currentVolume.resultLocalCornerPointsPositions.Clear();
			ComputeBuffer computeBuffer = new ComputeBuffer(currentVolume.localCornerPointsPositions.Count, 12, ComputeBufferType.Default);
			ComputeBuffer computeBuffer2 = new ComputeBuffer(currentVolume.localCornerPointsPositions.Count, 12, ComputeBufferType.Default);
			ComputeBuffer computeBuffer3 = new ComputeBuffer(currentVolume.localCornerPointsPositions.Count, 12, ComputeBufferType.Default);
			computeBuffer.SetData(currentVolume.localCornerPointsPositions.ToArray());
			computeBuffer2.SetData(currentVolume.localCornerPointsPositions.ToArray());
			computeBuffer3.SetData(currentVolume.localAvaragedDirections.ToArray());
			parent.calculateDistanceFromGeometry.SetBuffer(parent.calculateDistanceFromGeometry.FindKernel("CSMain"), "inputArray", computeBuffer);
			parent.calculateDistanceFromGeometry.SetBuffer(parent.calculateDistanceFromGeometry.FindKernel("CSMain"), "exitArray", computeBuffer2);
			parent.calculateDistanceFromGeometry.SetBuffer(parent.calculateDistanceFromGeometry.FindKernel("CSMain"), "directionsArray", computeBuffer3);
			parent.calculateDistanceFromGeometry.SetFloat("distance", parent.unlitVolumeFillingRate);
			parent.calculateDistanceFromGeometry.Dispatch(parent.calculateDistanceFromGeometry.FindKernel("CSMain"), 256, 1, 1);
			Vector3[] exit = new Vector3[computeBuffer.count];
			computeBuffer2.GetData(exit);
			computeBuffer.Dispose();
			computeBuffer2.Dispose();
			currentVolume.localCornerPointsPositions.Clear();
			for (int i = 0; i < exit.Length; i++)
			{
				if (!(exit[i] == Vector3.zero))
				{
					currentVolume.localCornerPointsPositions.Add(exit[i]);
					if (parent.UpdateProgress(exit.Length, 1000))
					{
						yield return null;
					}
				}
			}
		}
	}
}
namespace BeautifyEffect
{
	public class CameraAnimator : MonoBehaviour
	{
		private void Update()
		{
			base.transform.Rotate(new Vector3(0f, 0f, Time.deltaTime * 10f));
		}
	}
	public class Demo1 : MonoBehaviour
	{
		private float deltaTime;

		private bool benchmarkEnabled;

		private GUIStyle style;

		private Rect rect;

		private void Update()
		{
			if (Input.GetKeyDown(KeyCode.J))
			{
				Beautify.instance.bloomIntensity += 0.1f;
			}
			if (Input.GetKeyDown(KeyCode.T) || Input.GetMouseButtonDown(0))
			{
				Beautify.instance.enabled = !Beautify.instance.enabled;
				UpdateText();
			}
			if (Input.GetKeyDown(KeyCode.F))
			{
				benchmarkEnabled = !benchmarkEnabled;
			}
			deltaTime += (Time.deltaTime - deltaTime) * 0.1f;
			if (Input.GetKeyDown(KeyCode.B))
			{
				Beautify.instance.Blink(0.1f);
			}
		}

		private void UpdateText()
		{
			if (Beautify.instance.enabled)
			{
				GameObject.Find("Beautify").GetComponent<Text>().text = "Beautify ON";
			}
			else
			{
				GameObject.Find("Beautify").GetComponent<Text>().text = "Beautify OFF";
			}
		}

		private void OnGUI()
		{
			if (benchmarkEnabled)
			{
				int width = Screen.width;
				int height = Screen.height;
				if (style == null)
				{
					style = new GUIStyle();
					rect = new Rect(0f, 0f, width, height * 4 / 100);
					style.alignment = TextAnchor.UpperLeft;
					style.fontSize = height * 4 / 100;
					style.normal.textColor = Color.white;
				}
				float num = deltaTime * 1000f;
				float num2 = 1f / deltaTime;
				string text = $"{num:0.0} ms ({num2:0.} fps)";
				GUI.Label(rect, text, style);
			}
		}
	}
	public class Demo2 : MonoBehaviour
	{
		private int demoMode;

		private void Start()
		{
			UpdateDemoMode();
		}

		private void Update()
		{
			if (Input.GetMouseButtonDown(0))
			{
				demoMode++;
				if (demoMode >= 11)
				{
					demoMode = 0;
				}
				UpdateDemoMode();
			}
			else if (Input.GetKeyDown(KeyCode.T))
			{
				if (demoMode > 0)
				{
					demoMode = 0;
				}
				else
				{
					demoMode = 1;
				}
				UpdateDemoMode();
			}
		}

		private void UpdateDemoMode()
		{
			string text = "";
			Beautify.instance.enabled = demoMode > 0;
			switch (demoMode)
			{
			case 0:
				text = "BEAUTIFY OFF (click to enable)";
				break;
			case 1:
				text = "BEAUTIFY ON";
				Beautify.instance.lut = false;
				Beautify.instance.outline = false;
				Beautify.instance.nightVision = false;
				Beautify.instance.bloom = false;
				Beautify.instance.anamorphicFlares = false;
				Beautify.instance.lensDirt = false;
				Beautify.instance.vignetting = false;
				Beautify.instance.frame = false;
				Beautify.instance.sunFlares = false;
				break;
			case 2:
				text = "BEAUTIFY ON + vignetting";
				Beautify.instance.vignetting = true;
				Beautify.instance.vignettingColor = new Color(0f, 0f, 0f, 0.05f);
				break;
			case 3:
				text = "BEAUTIFY ON + vignetting + bloom";
				Beautify.instance.bloom = true;
				break;
			case 4:
				text = "BEAUTIFY ON + vignetting + sun flares";
				Beautify.instance.sunFlares = true;
				break;
			case 5:
				text = "BEAUTIFY ON + vignetting + bloom + lens dirt";
				Beautify.instance.lensDirt = true;
				break;
			case 6:
				text = "BEAUTIFY ON + vignetting + lens dirt + anamorphic flares";
				Beautify.instance.bloom = false;
				Beautify.instance.anamorphicFlares = true;
				break;
			case 7:
				text = "BEAUTIFY ON + vignetting + lens dirt + vertical anamorphic flares";
				Beautify.instance.anamorphicFlaresVertical = true;
				break;
			case 8:
				text = "BEAUTIFY ON + vignetting + bloom + lens dirt + night vision";
				Beautify.instance.bloom = true;
				Beautify.instance.anamorphicFlares = false;
				Beautify.instance.nightVision = true;
				break;
			case 9:
				text = "BEAUTIFY ON + red vignetting + bloom + lens dirt + thermal vision";
				Beautify.instance.thermalVision = true;
				break;
			case 10:
				text = "BEAUTIFY ON + LUT sepia + outline + frame";
				Beautify.instance.thermalVision = false;
				Beautify.instance.vignetting = false;
				Beautify.instance.lut = true;
				Beautify.instance.outline = true;
				Beautify.instance.bloom = false;
				Beautify.instance.anamorphicFlares = false;
				Beautify.instance.anamorphicFlaresVertical = false;
				Beautify.instance.lensDirt = false;
				Beautify.instance.frame = true;
				break;
			}
			GameObject.Find("Beautify").GetComponent<Text>().text = text;
		}
	}
	public class Demo4 : MonoBehaviour
	{
		private void Update()
		{
			if (Input.GetKeyDown(KeyCode.T))
			{
				Beautify.instance.depthOfFieldTransparencySupport = !Beautify.instance.depthOfFieldTransparencySupport;
				GameObject.Find("Beautify").GetComponent<Text>().text = (Beautify.instance.depthOfFieldTransparencySupport ? "Beautify (DoF transparency support is ON)" : "Beautify (Dof transparency support is OFF)");
			}
		}
	}
	public class FreeCameraMove : MonoBehaviour
	{
		public float cameraSensitivity = 150f;

		public float climbSpeed = 20f;

		public float normalMoveSpeed = 20f;

		public float slowMoveFactor = 0.25f;

		public float fastMoveFactor = 3f;

		private float rotationX;

		private float rotationY;

		private Quaternion originalRotation;

		private void Start()
		{
			Cursor.lockState = CursorLockMode.Locked;
			originalRotation = Camera.main.transform.rotation;
		}

		private void Update()
		{
			Vector2 vector = Input.mousePosition;
			if (!(vector.x < 0f) && !(vector.x > (float)Screen.width) && !(vector.y < 0f) && !(vector.y > (float)Screen.height))
			{
				rotationX += Input.GetAxis("Mouse X") * cameraSensitivity * Time.deltaTime;
				rotationY += Input.GetAxis("Mouse Y") * cameraSensitivity * Time.deltaTime;
				rotationY = Mathf.Clamp(rotationY, -90f, 90f);
				base.transform.localRotation = Quaternion.AngleAxis(rotationX, Vector3.up);
				base.transform.localRotation *= Quaternion.AngleAxis(rotationY, Vector3.left);
				base.transform.localRotation *= originalRotation;
				if (Input.GetKey(KeyCode.LeftShift) || Input.GetKey(KeyCode.RightShift))
				{
					base.transform.position += base.transform.forward * (normalMoveSpeed * fastMoveFactor) * Input.GetAxis("Vertical") * Time.deltaTime;
					base.transform.position += base.transform.right * (normalMoveSpeed * fastMoveFactor) * Input.GetAxis("Horizontal") * Time.deltaTime;
				}
				else if (Input.GetKey(KeyCode.LeftControl) || Input.GetKey(KeyCode.RightControl))
				{
					base.transform.position += base.transform.forward * (normalMoveSpeed * slowMoveFactor) * Input.GetAxis("Vertical") * Time.deltaTime;
					base.transform.position += base.transform.right * (normalMoveSpeed * slowMoveFactor) * Input.GetAxis("Horizontal") * Time.deltaTime;
				}
				else
				{
					base.transform.position += base.transform.forward * normalMoveSpeed * Input.GetAxis("Vertical") * Time.deltaTime;
					base.transform.position += base.transform.right * normalMoveSpeed * Input.GetAxis("Horizontal") * Time.deltaTime;
				}
				if (Input.GetKey(KeyCode.Q))
				{
					base.transform.position -= base.transform.up * climbSpeed * Time.deltaTime;
				}
				if (Input.GetKey(KeyCode.E))
				{
					base.transform.position += base.transform.up * climbSpeed * Time.deltaTime;
				}
				if (base.transform.position.y < 1f)
				{
					base.transform.position += Vector3.up * (1f - base.transform.position.y);
				}
			}
		}
	}
	public class SphereAnimator : MonoBehaviour
	{
		private Rigidbody rb;

		private void Start()
		{
			rb = GetComponent<Rigidbody>();
		}

		private void FixedUpdate()
		{
			if (base.transform.position.z < 1f)
			{
				rb.AddForce(Vector3.forward * 10f);
			}
			else if (base.transform.position.z > 8f)
			{
				rb.AddForce(-Vector3.forward * 10f);
			}
		}
	}
	public delegate float OnBeforeFocusEvent(float currentFocusDistance);
	public enum BEAUTIFY_QUALITY
	{
		BestQuality,
		BestPerformance,
		Basic
	}
	public enum BEAUTIFY_PRESET
	{
		Soft = 10,
		Medium = 20,
		Strong = 30,
		Exaggerated = 40,
		Custom = 999
	}
	public enum BEAUTIFY_TMO
	{
		Linear = 0,
		ACES = 10
	}
	public enum BEAUTIFY_PRERENDER_EVENT
	{
		OnPreCull,
		OnPreRender
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(Camera))]
	[AddComponentMenu("Image Effects/Rendering/Beautify")]
	[HelpURL("http://kronnect.com/taptapgo")]
	[ImageEffectAllowedInSceneView]
	public class Beautify : MonoBehaviour
	{
		[SerializeField]
		private BEAUTIFY_PRESET _preset = BEAUTIFY_PRESET.Medium;

		[SerializeField]
		private BEAUTIFY_QUALITY _quality;

		[SerializeField]
		private BeautifyProfile _profile;

		[SerializeField]
		private bool _syncWithProfile = true;

		[SerializeField]
		private bool _compareMode;

		[SerializeField]
		[Range(-(float)Math.PI, (float)Math.PI)]
		private float _compareLineAngle = 1.4f;

		[SerializeField]
		[Range(0.0001f, 0.05f)]
		private float _compareLineWidth = 0.002f;

		[SerializeField]
		[Range(0f, 0.2f)]
		private float _dither = 0.02f;

		[SerializeField]
		[Range(0f, 1f)]
		private float _ditherDepth;

		[SerializeField]
		[Range(0f, 1f)]
		private float _sharpenMinDepth;

		[SerializeField]
		[Range(0f, 1.1f)]
		private float _sharpenMaxDepth = 0.999f;

		[SerializeField]
		[Range(0f, 1f)]
		private float _sharpenMinMaxDepthFallOff;

		[SerializeField]
		[Range(0f, 15f)]
		private float _sharpen = 2f;

		[SerializeField]
		[Range(0f, 0.05f)]
		private float _sharpenDepthThreshold = 0.035f;

		[SerializeField]
		private Color _tintColor = new Color(1f, 1f, 1f, 0f);

		[SerializeField]
		[Range(0f, 0.2f)]
		private float _sharpenRelaxation = 0.08f;

		[SerializeField]
		[Range(0f, 1f)]
		private float _sharpenClamp = 0.45f;

		[SerializeField]
		[Range(0f, 1f)]
		private float _sharpenMotionSensibility = 0.5f;

		[SerializeField]
		[Range(-2f, 3f)]
		private float _saturate = 1f;

		[SerializeField]
		[Range(0.5f, 1.5f)]
		private float _contrast = 1.02f;

		[SerializeField]
		private float _brightness = 1.05f;

		[SerializeField]
		[Range(0f, 2f)]
		private float _daltonize;

		[SerializeField]
		private bool _vignetting;

		[SerializeField]
		private Color _vignettingColor = new Color(0.3f, 0.3f, 0.3f, 0.05f);

		[SerializeField]
		[Range(0f, 1f)]
		private float _vignettingFade;

		[SerializeField]
		private bool _vignettingCircularShape;

		[SerializeField]
		private float _vignettingAspectRatio = 1f;

		[SerializeField]
		[Range(0f, 1f)]
		private float _vignettingBlink;

		[SerializeField]
		private Texture2D _vignettingMask;

		[SerializeField]
		private bool _frame;

		[SerializeField]
		private Color _frameColor = new Color(1f, 1f, 1f, 0.047f);

		[SerializeField]
		private Texture2D _frameMask;

		[SerializeField]
		private bool _lut;

		[SerializeField]
		[Range(0f, 1f)]
		private float _lutIntensity = 1f;

		[SerializeField]
		private Texture2D _lutTexture;

		[SerializeField]
		private bool _nightVision;

		[SerializeField]
		private Color _nightVisionColor = new Color(0.5f, 1f, 0.5f, 0.5f);

		[SerializeField]
		private bool _outline;

		[SerializeField]
		private Color _outlineColor = new Color(0f, 0f, 0f, 0.8f);

		[SerializeField]
		private bool _thermalVision;

		[SerializeField]
		private bool _lensDirt;

		[SerializeField]
		[Range(0f, 1f)]
		private float _lensDirtThreshold = 0.5f;

		[SerializeField]
		[Range(0f, 1f)]
		private float _lensDirtIntensity = 0.9f;

		[SerializeField]
		private Texture2D _lensDirtTexture;

		[SerializeField]
		private bool _bloom;

		[SerializeField]
		private LayerMask _bloomCullingMask = 0;

		[SerializeField]
		[Range(1f, 4f)]
		private float _bloomLayerMaskDownsampling = 1f;

		[SerializeField]
		[Range(0f, 10f)]
		private float _bloomIntensity = 1f;

		[SerializeField]
		private float _bloomMaxBrightness = 1000f;

		[SerializeField]
		[Range(0f, 3f)]
		private float _bloomBoost0;

		[SerializeField]
		[Range(0f, 3f)]
		private float _bloomBoost1;

		[SerializeField]
		[Range(0f, 3f)]
		private float _bloomBoost2;

		[SerializeField]
		[Range(0f, 3f)]
		private float _bloomBoost3;

		[SerializeField]
		[Range(0f, 3f)]
		private float _bloomBoost4;

		[SerializeField]
		[Range(0f, 3f)]
		private float _bloomBoost5;

		[SerializeField]
		private bool _bloomAntiflicker;

		[SerializeField]
		private bool _bloomUltra;

		[SerializeField]
		[Range(1f, 10f)]
		private int _bloomUltraResolution = 10;

		[SerializeField]
		[Range(0f, 5f)]
		private float _bloomThreshold = 0.75f;

		[SerializeField]
		private bool _bloomCustomize;

		[SerializeField]
		private bool _bloomDebug;

		[SerializeField]
		[Range(0f, 1f)]
		private float _bloomWeight0 = 0.5f;

		[SerializeField]
		[Range(0f, 1f)]
		private float _bloomWeight1 = 0.5f;

		[SerializeField]
		[Range(0f, 1f)]
		private float _bloomWeight2 = 0.5f;

		[SerializeField]
		[Range(0f, 1f)]
		private float _bloomWeight3 = 0.5f;

		[SerializeField]
		[Range(0f, 1f)]
		private float _bloomWeight4 = 0.5f;

		[SerializeField]
		[Range(0f, 1f)]
		private float _bloomWeight5 = 0.5f;

		[SerializeField]
		private bool _bloomBlur = true;

		[SerializeField]
		private bool _bloomQuickerBlur;

		[SerializeField]
		[Range(0f, 1f)]
		private float _bloomDepthAtten;

		[SerializeField]
		[Range(-1f, 1f)]
		private float _bloomLayerZBias = 0.0001f;

		[SerializeField]
		private BEAUTIFY_PRERENDER_EVENT _preRenderCameraEvent;

		[SerializeField]
		private bool _anamorphicFlares;

		[SerializeField]
		[Range(0f, 10f)]
		private float _anamorphicFlaresIntensity = 1f;

		[SerializeField]
		private bool _anamorphicFlaresAntiflicker;

		[SerializeField]
		private bool _anamorphicFlaresUltra;

		[SerializeField]
		[Range(1f, 10f)]
		private int _anamorphicUltraResolution = 10;

		[SerializeField]
		[Range(0f, 5f)]
		private float _anamorphicFlaresThreshold = 0.75f;

		[SerializeField]
		[Range(0.1f, 2f)]
		private float _anamorphicFlaresSpread = 1f;

		[SerializeField]
		private bool _anamorphicFlaresVertical;

		[SerializeField]
		private Color _anamorphicFlaresTint = new Color(0.5f, 0.5f, 1f, 0f);

		[SerializeField]
		private bool _anamorphicFlaresBlur = true;

		[SerializeField]
		private bool _depthOfField;

		[SerializeField]
		private bool _depthOfFieldTransparencySupport;

		[SerializeField]
		private LayerMask _depthOfFieldTransparencyLayerMask = -1;

		[SerializeField]
		private Transform _depthOfFieldTargetFocus;

		[SerializeField]
		private bool _depthOfFieldDebug;

		[SerializeField]
		private bool _depthOfFieldAutofocus;

		[SerializeField]
		private Vector2 _depthofFieldAutofocusViewportPoint = new Vector2(0.5f, 0.5f);

		[SerializeField]
		private float _depthOfFieldAutofocusMinDistance;

		[SerializeField]
		private float _depthOfFieldAutofocusMaxDistance = 10000f;

		[SerializeField]
		private LayerMask _depthOfFieldAutofocusLayerMask = -1;

		[SerializeField]
		private LayerMask _depthOfFieldExclusionLayerMask = 0;

		[SerializeField]
		[Range(1f, 4f)]
		private float _depthOfFieldExclusionLayerMaskDownsampling = 1f;

		[SerializeField]
		[Range(1f, 4f)]
		private float _depthOfFieldTransparencySupportDownsampling = 1f;

		[SerializeField]
		[Range(0.9f, 1f)]
		private float _depthOfFieldExclusionBias = 0.99f;

		[SerializeField]
		[Range(1f, 100f)]
		private float _depthOfFieldDistance = 1f;

		[SerializeField]
		[Range(0.001f, 5f)]
		private float _depthOfFieldFocusSpeed = 1f;

		[SerializeField]
		[Range(1f, 5f)]
		private int _depthOfFieldDownsampling = 2;

		[SerializeField]
		[Range(2f, 16f)]
		private int _depthOfFieldMaxSamples = 4;

		[SerializeField]
		[Range(0.005f, 0.5f)]
		private float _depthOfFieldFocalLength = 0.05f;

		[SerializeField]
		private float _depthOfFieldAperture = 2.8f;

		[SerializeField]
		private bool _depthOfFieldForegroundBlur = true;

		[SerializeField]
		private bool _depthOfFieldForegroundBlurHQ;

		[SerializeField]
		private float _depthOfFieldForegroundDistance = 0.25f;

		[SerializeField]
		private bool _depthOfFieldBokeh = true;

		[SerializeField]
		[Range(0.5f, 3f)]
		private float _depthOfFieldBokehThreshold = 1f;

		[SerializeField]
		[Range(0f, 8f)]
		private float _depthOfFieldBokehIntensity = 2f;

		[SerializeField]
		private float _depthOfFieldMaxBrightness = 1000f;

		[SerializeField]
		[Range(0f, 1f)]
		private float _depthOfFieldMaxDistance = 1f;

		[SerializeField]
		private FilterMode _depthOfFieldFilterMode = FilterMode.Bilinear;

		[NonSerialized]
		public OnBeforeFocusEvent OnBeforeFocus;

		[SerializeField]
		private bool _eyeAdaptation;

		[SerializeField]
		[Range(0f, 1f)]
		private float _eyeAdaptationMinExposure = 0.2f;

		[SerializeField]
		[Range(1f, 100f)]
		private float _eyeAdaptationMaxExposure = 5f;

		[SerializeField]
		[Range(0f, 1f)]
		private float _eyeAdaptationSpeedToLight = 0.4f;

		[SerializeField]
		[Range(0f, 1f)]
		private float _eyeAdaptationSpeedToDark = 0.2f;

		[SerializeField]
		private bool _purkinje;

		[SerializeField]
		[Range(0f, 5f)]
		private float _purkinjeAmount = 1f;

		[SerializeField]
		[Range(0f, 1f)]
		private float _purkinjeLuminanceThreshold = 0.15f;

		[SerializeField]
		private BEAUTIFY_TMO _tonemap;

		[SerializeField]
		private bool _sunFlares;

		[SerializeField]
		private Transform _sun;

		[SerializeField]
		private LayerMask _sunFlaresLayerMask = -1;

		[SerializeField]
		[Range(0f, 1f)]
		private float _sunFlaresIntensity = 1f;

		[SerializeField]
		[Range(0f, 1f)]
		private float _sunFlaresSolarWindSpeed = 0.01f;

		[SerializeField]
		private Color _sunFlaresTint = new Color(1f, 1f, 1f);

		[SerializeField]
		[Range(1f, 5f)]
		private int _sunFlaresDownsampling = 1;

		[SerializeField]
		[Range(0f, 1f)]
		private float _sunFlaresSunIntensity = 0.1f;

		[SerializeField]
		[Range(0f, 1f)]
		private float _sunFlaresSunDiskSize = 0.05f;

		[SerializeField]
		[Range(0f, 10f)]
		private float _sunFlaresSunRayDiffractionIntensity = 3.5f;

		[SerializeField]
		[Range(0f, 1f)]
		private float _sunFlaresSunRayDiffractionThreshold = 0.13f;

		[SerializeField]
		[Range(0f, 0.2f)]
		private float _sunFlaresCoronaRays1Length = 0.02f;

		[SerializeField]
		[Range(2f, 30f)]
		private int _sunFlaresCoronaRays1Streaks = 12;

		[SerializeField]
		[Range(0f, 0.1f)]
		private float _sunFlaresCoronaRays1Spread = 0.001f;

		[SerializeField]
		[Range(0f, (float)Math.PI * 2f)]
		private float _sunFlaresCoronaRays1AngleOffset;

		[SerializeField]
		[Range(0f, 0.2f)]
		private float _sunFlaresCoronaRays2Length = 0.05f;

		[SerializeField]
		[Range(2f, 30f)]
		private int _sunFlaresCoronaRays2Streaks = 12;

		[SerializeField]
		[Range(0f, 0.1f)]
		private float _sunFlaresCoronaRays2Spread = 0.1f;

		[SerializeField]
		[Range(0f, (float)Math.PI * 2f)]
		private float _sunFlaresCoronaRays2AngleOffset;

		[SerializeField]
		[Range(0f, 1f)]
		private float _sunFlaresGhosts1Size = 0.03f;

		[SerializeField]
		[Range(-3f, 3f)]
		private float _sunFlaresGhosts1Offset = 1.04f;

		[SerializeField]
		[Range(0f, 1f)]
		private float _sunFlaresGhosts1Brightness = 0.037f;

		[SerializeField]
		[Range(0f, 1f)]
		private float _sunFlaresGhosts2Size = 0.1f;

		[SerializeField]
		[Range(-3f, 3f)]
		private float _sunFlaresGhosts2Offset = 0.71f;

		[SerializeField]
		[Range(0f, 1f)]
		private float _sunFlaresGhosts2Brightness = 0.03f;

		[SerializeField]
		[Range(0f, 1f)]
		private float _sunFlaresGhosts3Size = 0.24f;

		[SerializeField]
		[Range(-3f, 3f)]
		private float _sunFlaresGhosts3Brightness = 0.025f;

		[SerializeField]
		[Range(0f, 1f)]
		private float _sunFlaresGhosts3Offset = 0.31f;

		[SerializeField]
		[Range(0f, 1f)]
		private float _sunFlaresGhosts4Size = 0.016f;

		[SerializeField]
		[Range(-3f, 3f)]
		private float _sunFlaresGhosts4Offset;

		[SerializeField]
		[Range(0f, 1f)]
		private float _sunFlaresGhosts4Brightness = 0.017f;

		[SerializeField]
		[Range(0f, 1f)]
		private float _sunFlaresHaloOffset = 0.22f;

		[SerializeField]
		[Range(0f, 50f)]
		private float _sunFlaresHaloAmplitude = 15.1415f;

		[SerializeField]
		[Range(0f, 1f)]
		private float _sunFlaresHaloIntensity = 0.01f;

		[SerializeField]
		private bool _sunFlaresRotationDeadZone;

		[SerializeField]
		private bool _blur;

		[SerializeField]
		[Range(0f, 4f)]
		private float _blurIntensity = 1f;

		[SerializeField]
		[Range(1f, 8f)]
		private int _downscale = 1;

		[SerializeField]
		[Range(1f, 256f)]
		private int _pixelateAmount = 1;

		[SerializeField]
		private bool _pixelateDownscale;

		[SerializeField]
		[Range(0f, 20f)]
		private float _antialiasStrength = 5f;

		[SerializeField]
		[Range(0f, 0.05f)]
		private float _antialiasDepthThreshold = 0.001f;

		public bool isDirty;

		private static Beautify _beautify;

		public const string SKW_BLOOM = "BEAUTIFY_BLOOM";

		public const string SKW_LUT = "BEAUTIFY_LUT";

		public const string SKW_NIGHT_VISION = "BEAUTIFY_NIGHT_VISION";

		public const string SKW_THERMAL_VISION = "BEAUTIFY_THERMAL_VISION";

		public const string SKW_OUTLINE = "BEAUTIFY_OUTLINE";

		public const string SKW_FRAME = "BEAUTIFY_FRAME";

		public const string SKW_FRAME_MASK = "BEAUTIFY_FRAME_MASK";

		public const string SKW_DALTONIZE = "BEAUTIFY_DALTONIZE";

		public const string SKW_DIRT = "BEAUTIFY_DIRT";

		public const string SKW_VIGNETTING = "BEAUTIFY_VIGNETTING";

		public const string SKW_VIGNETTING_MASK = "BEAUTIFY_VIGNETTING_MASK";

		public const string SKW_DEPTH_OF_FIELD = "BEAUTIFY_DEPTH_OF_FIELD";

		public const string SKW_DEPTH_OF_FIELD_TRANSPARENT = "BEAUTIFY_DEPTH_OF_FIELD_TRANSPARENT";

		public const string SKW_EYE_ADAPTATION = "BEAUTIFY_EYE_ADAPTATION";

		public const string SKW_TONEMAP_ACES = "BEAUTIFY_TONEMAP_ACES";

		public const string SKW_PURKINJE = "BEAUTIFY_PURKINJE";

		public const string SKW_BLOOM_USE_DEPTH = "BEAUTIFY_BLOOM_USE_DEPTH";

		public const string SKW_BLOOM_USE_LAYER = "BEAUTIFY_BLOOM_USE_LAYER";

		private Material bMatDesktop;

		private Material bMatMobile;

		private Material bMatBasic;

		[SerializeField]
		private Material bMat;

		private Camera currentCamera;

		private Vector3 camPrevForward;

		private Vector3 camPrevPos;

		private float currSens;

		private int renderPass;

		private RenderTextureFormat rtFormat;

		private RenderTexture[] rt;

		private RenderTexture[] rtAF;

		private RenderTexture[] rtEA;

		private RenderTexture rtEAacum;

		private RenderTexture rtEAHist;

		private float dofPrevDistance;

		private float dofLastAutofocusDistance;

		private Vector4 dofLastBokehData;

		private Camera sceneCamera;

		private Camera depthCam;

		private GameObject depthCamObj;

		private List<string> shaderKeywords;

		private Shader depthShader;

		private Shader dofExclusionShader;

		private bool shouldUpdateMaterialProperties;

		private const string BEAUTIFY_BUILD_HINT = "BeautifyBuildHint731RC1";

		private float sunFlareCurrentIntensity;

		private Vector4 sunLastScrPos;

		private float sunLastRot;

		private Texture2D flareNoise;

		private RenderTexture dofDepthTexture;

		private RenderTexture dofExclusionTexture;

		private RenderTexture bloomSourceTexture;

		private RenderTexture bloomSourceDepthTexture;

		private RenderTexture bloomSourceTextureRightEye;

		private RenderTexture bloomSourceDepthTextureRightEye;

		private RenderTexture pixelateTexture;

		private RenderTextureDescriptor rtDescBase;

		private float sunFlareTime;

		private int dofCurrentLayerMaskValue;

		private int bloomCurrentLayerMaskValue;

		private int eyeWidth;

		private int eyeHeight;

		public BEAUTIFY_PRESET preset
		{
			get
			{
				return _preset;
			}
			set
			{
				if (_preset != value)
				{
					_preset = value;
					UpdateMaterialProperties();
				}
			}
		}

		public BEAUTIFY_QUALITY quality
		{
			get
			{
				return _quality;
			}
			set
			{
				if (_quality != value)
				{
					_quality = value;
					UpdateQualitySettings();
					UpdateMaterialProperties();
				}
			}
		}

		public BeautifyProfile profile
		{
			get
			{
				return _profile;
			}
			set
			{
				if (_profile != value)
				{
					_profile = value;
					if (_profile != null)
					{
						_profile.Load(this);
						_preset = BEAUTIFY_PRESET.Custom;
					}
				}
			}
		}

		public bool syncWithProfile
		{
			get
			{
				return _syncWithProfile;
			}
			set
			{
				_syncWithProfile = value;
			}
		}

		public bool compareMode
		{
			get
			{
				return _compareMode;
			}
			set
			{
				if (_compareMode != value)
				{
					_compareMode = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float compareLineAngle
		{
			get
			{
				return _compareLineAngle;
			}
			set
			{
				if (_compareLineAngle != value)
				{
					_compareLineAngle = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float compareLineWidth
		{
			get
			{
				return _compareLineWidth;
			}
			set
			{
				if (_compareLineWidth != value)
				{
					_compareLineWidth = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float dither
		{
			get
			{
				return _dither;
			}
			set
			{
				if (_dither != value)
				{
					_preset = BEAUTIFY_PRESET.Custom;
					_dither = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float ditherDepth
		{
			get
			{
				return _ditherDepth;
			}
			set
			{
				if (_ditherDepth != value)
				{
					_preset = BEAUTIFY_PRESET.Custom;
					_ditherDepth = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float sharpenMinDepth
		{
			get
			{
				return _sharpenMinDepth;
			}
			set
			{
				if (_sharpenMinDepth != value)
				{
					_sharpenMinDepth = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float sharpenMaxDepth
		{
			get
			{
				return _sharpenMaxDepth;
			}
			set
			{
				if (_sharpenMaxDepth != value)
				{
					_sharpenMaxDepth = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float sharpenMinMaxDepthFallOff
		{
			get
			{
				return _sharpenMinMaxDepthFallOff;
			}
			set
			{
				if (_sharpenMinMaxDepthFallOff != value)
				{
					_sharpenMinMaxDepthFallOff = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float sharpen
		{
			get
			{
				return _sharpen;
			}
			set
			{
				if (_sharpen != value)
				{
					_preset = BEAUTIFY_PRESET.Custom;
					_sharpen = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float sharpenDepthThreshold
		{
			get
			{
				return _sharpenDepthThreshold;
			}
			set
			{
				if (_sharpenDepthThreshold != value)
				{
					_preset = BEAUTIFY_PRESET.Custom;
					_sharpenDepthThreshold = value;
					UpdateMaterialProperties();
				}
			}
		}

		public Color tintColor
		{
			get
			{
				return _tintColor;
			}
			set
			{
				if (_tintColor != value)
				{
					_tintColor = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float sharpenRelaxation
		{
			get
			{
				return _sharpenRelaxation;
			}
			set
			{
				if (_sharpenRelaxation != value)
				{
					_preset = BEAUTIFY_PRESET.Custom;
					_sharpenRelaxation = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float sharpenClamp
		{
			get
			{
				return _sharpenClamp;
			}
			set
			{
				if (_sharpenClamp != value)
				{
					_preset = BEAUTIFY_PRESET.Custom;
					_sharpenClamp = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float sharpenMotionSensibility
		{
			get
			{
				return _sharpenMotionSensibility;
			}
			set
			{
				if (_sharpenMotionSensibility != value)
				{
					_sharpenMotionSensibility = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float saturate
		{
			get
			{
				return _saturate;
			}
			set
			{
				if (_saturate != value)
				{
					_preset = BEAUTIFY_PRESET.Custom;
					_saturate = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float contrast
		{
			get
			{
				return _contrast;
			}
			set
			{
				if (_contrast != value)
				{
					_preset = BEAUTIFY_PRESET.Custom;
					_contrast = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float brightness
		{
			get
			{
				return _brightness;
			}
			set
			{
				if (_brightness != value)
				{
					_preset = BEAUTIFY_PRESET.Custom;
					_brightness = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float daltonize
		{
			get
			{
				return _daltonize;
			}
			set
			{
				if (_daltonize != value)
				{
					_preset = BEAUTIFY_PRESET.Custom;
					_daltonize = value;
					UpdateMaterialProperties();
				}
			}
		}

		public bool vignetting
		{
			get
			{
				return _vignetting;
			}
			set
			{
				if (_vignetting != value)
				{
					_vignetting = value;
					UpdateMaterialProperties();
				}
			}
		}

		public Color vignettingColor
		{
			get
			{
				return _vignettingColor;
			}
			set
			{
				if (_vignettingColor != value)
				{
					_vignettingColor = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float vignettingFade
		{
			get
			{
				return _vignettingFade;
			}
			set
			{
				if (_vignettingFade != value)
				{
					_vignettingFade = value;
					UpdateMaterialProperties();
				}
			}
		}

		public bool vignettingCircularShape
		{
			get
			{
				return _vignettingCircularShape;
			}
			set
			{
				if (_vignettingCircularShape != value)
				{
					_vignettingCircularShape = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float vignettingAspectRatio
		{
			get
			{
				return _vignettingAspectRatio;
			}
			set
			{
				if (_vignettingAspectRatio != value)
				{
					_vignettingAspectRatio = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float vignettingBlink
		{
			get
			{
				return _vignettingBlink;
			}
			set
			{
				if (_vignettingBlink != value)
				{
					_vignettingBlink = value;
					UpdateMaterialProperties();
				}
			}
		}

		public Texture2D vignettingMask
		{
			get
			{
				return _vignettingMask;
			}
			set
			{
				if (_vignettingMask != value)
				{
					_vignettingMask = value;
					UpdateMaterialProperties();
				}
			}
		}

		public bool frame
		{
			get
			{
				return _frame;
			}
			set
			{
				if (_frame != value)
				{
					_frame = value;
					UpdateMaterialProperties();
				}
			}
		}

		public Color frameColor
		{
			get
			{
				return _frameColor;
			}
			set
			{
				if (_frameColor != value)
				{
					_frameColor = value;
					UpdateMaterialProperties();
				}
			}
		}

		public Texture2D frameMask
		{
			get
			{
				return _frameMask;
			}
			set
			{
				if (_frameMask != value)
				{
					_frameMask = value;
					UpdateMaterialProperties();
				}
			}
		}

		public bool lut
		{
			get
			{
				return _lut;
			}
			set
			{
				if (_lut != value)
				{
					_lut = value;
					if (_lut)
					{
						_nightVision = false;
						_thermalVision = false;
					}
					UpdateMaterialProperties();
				}
			}
		}

		public float lutIntensity
		{
			get
			{
				return _lutIntensity;
			}
			set
			{
				if (_lutIntensity != value)
				{
					_lutIntensity = value;
					UpdateMaterialProperties();
				}
			}
		}

		public Texture2D lutTexture
		{
			get
			{
				return _lutTexture;
			}
			set
			{
				if (_lutTexture != value)
				{
					_lutTexture = value;
					UpdateMaterialProperties();
				}
			}
		}

		public bool nightVision
		{
			get
			{
				return _nightVision;
			}
			set
			{
				if (_nightVision != value)
				{
					_nightVision = value;
					if (_nightVision)
					{
						_thermalVision = false;
						_lut = false;
						_vignetting = true;
						_vignettingFade = 0f;
						_vignettingColor = new Color(0f, 0f, 0f, 0.1254902f);
						_vignettingCircularShape = true;
					}
					else
					{
						_vignetting = false;
					}
					UpdateMaterialProperties();
				}
			}
		}

		public Color nightVisionColor
		{
			get
			{
				return _nightVisionColor;
			}
			set
			{
				if (_nightVisionColor != value)
				{
					_nightVisionColor = value;
					UpdateMaterialProperties();
				}
			}
		}

		public bool outline
		{
			get
			{
				return _outline;
			}
			set
			{
				if (_outline != value)
				{
					_outline = value;
					UpdateMaterialProperties();
				}
			}
		}

		public Color outlineColor
		{
			get
			{
				return _outlineColor;
			}
			set
			{
				if (_outlineColor != value)
				{
					_outlineColor = value;
					UpdateMaterialProperties();
				}
			}
		}

		public bool thermalVision
		{
			get
			{
				return _thermalVision;
			}
			set
			{
				if (_thermalVision != value)
				{
					_thermalVision = value;
					if (_thermalVision)
					{
						_nightVision = false;
						_lut = false;
						_vignetting = true;
						_vignettingFade = 0f;
						_vignettingColor = new Color(1f, 0.0627451f, 0.0627451f, 6f / 85f);
						_vignettingCircularShape = true;
					}
					else
					{
						_vignetting = false;
					}
					UpdateMaterialProperties();
				}
			}
		}

		public bool lensDirt
		{
			get
			{
				return _lensDirt;
			}
			set
			{
				if (_lensDirt != value)
				{
					_lensDirt = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float lensDirtThreshold
		{
			get
			{
				return _lensDirtThreshold;
			}
			set
			{
				if (_lensDirtThreshold != value)
				{
					_lensDirtThreshold = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float lensDirtIntensity
		{
			get
			{
				return _lensDirtIntensity;
			}
			set
			{
				if (_lensDirtIntensity != value)
				{
					_lensDirtIntensity = value;
					UpdateMaterialProperties();
				}
			}
		}

		public Texture2D lensDirtTexture
		{
			get
			{
				return _lensDirtTexture;
			}
			set
			{
				if (_lensDirtTexture != value)
				{
					_lensDirtTexture = value;
					UpdateMaterialProperties();
				}
			}
		}

		public bool bloom
		{
			get
			{
				return _bloom;
			}
			set
			{
				if (_bloom != value)
				{
					_bloom = value;
					UpdateMaterialProperties();
				}
			}
		}

		public LayerMask bloomCullingMask
		{
			get
			{
				return _bloomCullingMask;
			}
			set
			{
				if ((int)_bloomCullingMask != (int)value)
				{
					_bloomCullingMask = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float bloomLayerMaskDownsampling
		{
			get
			{
				return _bloomLayerMaskDownsampling;
			}
			set
			{
				if (_bloomLayerMaskDownsampling != value)
				{
					_bloomLayerMaskDownsampling = Mathf.Max(value, 1f);
					UpdateMaterialProperties();
				}
			}
		}

		public float bloomIntensity
		{
			get
			{
				return _bloomIntensity;
			}
			set
			{
				if (_bloomIntensity != value)
				{
					_bloomIntensity = Mathf.Abs(value);
					UpdateMaterialProperties();
				}
			}
		}

		public float bloomMaxBrightness
		{
			get
			{
				return _bloomMaxBrightness;
			}
			set
			{
				if (_bloomMaxBrightness != value)
				{
					_bloomMaxBrightness = Mathf.Abs(value);
					UpdateMaterialProperties();
				}
			}
		}

		public float bloomBoost0
		{
			get
			{
				return _bloomBoost0;
			}
			set
			{
				if (_bloomBoost0 != value)
				{
					_bloomBoost0 = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float bloomBoost1
		{
			get
			{
				return _bloomBoost1;
			}
			set
			{
				if (_bloomBoost1 != value)
				{
					_bloomBoost1 = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float bloomBoost2
		{
			get
			{
				return _bloomBoost2;
			}
			set
			{
				if (_bloomBoost2 != value)
				{
					_bloomBoost2 = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float bloomBoost3
		{
			get
			{
				return _bloomBoost3;
			}
			set
			{
				if (_bloomBoost3 != value)
				{
					_bloomBoost3 = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float bloomBoost4
		{
			get
			{
				return _bloomBoost4;
			}
			set
			{
				if (_bloomBoost4 != value)
				{
					_bloomBoost4 = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float bloomBoost5
		{
			get
			{
				return _bloomBoost5;
			}
			set
			{
				if (_bloomBoost5 != value)
				{
					_bloomBoost5 = value;
					UpdateMaterialProperties();
				}
			}
		}

		public bool bloomAntiflicker
		{
			get
			{
				return _bloomAntiflicker;
			}
			set
			{
				if (_bloomAntiflicker != value)
				{
					_bloomAntiflicker = value;
					UpdateMaterialProperties();
				}
			}
		}

		public bool bloomUltra
		{
			get
			{
				return _bloomUltra;
			}
			set
			{
				if (_bloomUltra != value)
				{
					_bloomUltra = value;
					UpdateMaterialProperties();
				}
			}
		}

		public int bloomUltraResolution
		{
			get
			{
				return _bloomUltraResolution;
			}
			set
			{
				if (_bloomUltraResolution != value)
				{
					_bloomUltraResolution = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float bloomThreshold
		{
			get
			{
				return _bloomThreshold;
			}
			set
			{
				if (_bloomThreshold != value)
				{
					_bloomThreshold = value;
					UpdateMaterialProperties();
				}
			}
		}

		public bool bloomCustomize
		{
			get
			{
				return _bloomCustomize;
			}
			set
			{
				if (_bloomCustomize != value)
				{
					_bloomCustomize = value;
					UpdateMaterialProperties();
				}
			}
		}

		public bool bloomDebug
		{
			get
			{
				return _bloomDebug;
			}
			set
			{
				if (_bloomDebug != value)
				{
					_bloomDebug = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float bloomWeight0
		{
			get
			{
				return _bloomWeight0;
			}
			set
			{
				if (_bloomWeight0 != value)
				{
					_bloomWeight0 = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float bloomWeight1
		{
			get
			{
				return _bloomWeight1;
			}
			set
			{
				if (_bloomWeight1 != value)
				{
					_bloomWeight1 = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float bloomWeight2
		{
			get
			{
				return _bloomWeight2;
			}
			set
			{
				if (_bloomWeight2 != value)
				{
					_bloomWeight2 = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float bloomWeight3
		{
			get
			{
				return _bloomWeight3;
			}
			set
			{
				if (_bloomWeight3 != value)
				{
					_bloomWeight3 = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float bloomWeight4
		{
			get
			{
				return _bloomWeight4;
			}
			set
			{
				if (_bloomWeight4 != value)
				{
					_bloomWeight4 = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float bloomWeight5
		{
			get
			{
				return _bloomWeight5;
			}
			set
			{
				if (_bloomWeight5 != value)
				{
					_bloomWeight5 = value;
					UpdateMaterialProperties();
				}
			}
		}

		public bool bloomBlur
		{
			get
			{
				return _bloomBlur;
			}
			set
			{
				if (_bloomBlur != value)
				{
					_bloomBlur = value;
					UpdateMaterialProperties();
				}
			}
		}

		public bool bloomQuickerBlur
		{
			get
			{
				return _bloomQuickerBlur;
			}
			set
			{
				if (_bloomQuickerBlur != value)
				{
					_bloomQuickerBlur = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float bloomDepthAtten
		{
			get
			{
				return _bloomDepthAtten;
			}
			set
			{
				if (_bloomDepthAtten != value)
				{
					_bloomDepthAtten = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float bloomLayerZBias
		{
			get
			{
				return _bloomLayerZBias;
			}
			set
			{
				if (_bloomLayerZBias != value)
				{
					_bloomLayerZBias = Mathf.Clamp(value, -1f, 1f);
					UpdateMaterialProperties();
				}
			}
		}

		public BEAUTIFY_PRERENDER_EVENT preRenderCameraEvent
		{
			get
			{
				return _preRenderCameraEvent;
			}
			set
			{
				if (_preRenderCameraEvent != value)
				{
					_preRenderCameraEvent = value;
				}
			}
		}

		public bool anamorphicFlares
		{
			get
			{
				return _anamorphicFlares;
			}
			set
			{
				if (_anamorphicFlares != value)
				{
					_anamorphicFlares = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float anamorphicFlaresIntensity
		{
			get
			{
				return _anamorphicFlaresIntensity;
			}
			set
			{
				if (_anamorphicFlaresIntensity != value)
				{
					_anamorphicFlaresIntensity = Mathf.Abs(value);
					UpdateMaterialProperties();
				}
			}
		}

		public bool anamorphicFlaresAntiflicker
		{
			get
			{
				return _anamorphicFlaresAntiflicker;
			}
			set
			{
				if (_anamorphicFlaresAntiflicker != value)
				{
					_anamorphicFlaresAntiflicker = value;
					UpdateMaterialProperties();
				}
			}
		}

		public bool anamorphicFlaresUltra
		{
			get
			{
				return _anamorphicFlaresUltra;
			}
			set
			{
				if (_anamorphicFlaresUltra != value)
				{
					_anamorphicFlaresUltra = value;
					UpdateMaterialProperties();
				}
			}
		}

		public int anamorphicUltraResolution
		{
			get
			{
				return _anamorphicUltraResolution;
			}
			set
			{
				if (_anamorphicUltraResolution != value)
				{
					_anamorphicUltraResolution = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float anamorphicFlaresThreshold
		{
			get
			{
				return _anamorphicFlaresThreshold;
			}
			set
			{
				if (_anamorphicFlaresThreshold != value)
				{
					_anamorphicFlaresThreshold = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float anamorphicFlaresSpread
		{
			get
			{
				return _anamorphicFlaresSpread;
			}
			set
			{
				if (_anamorphicFlaresSpread != value)
				{
					_anamorphicFlaresSpread = value;
					UpdateMaterialProperties();
				}
			}
		}

		public bool anamorphicFlaresVertical
		{
			get
			{
				return _anamorphicFlaresVertical;
			}
			set
			{
				if (_anamorphicFlaresVertical != value)
				{
					_anamorphicFlaresVertical = value;
					UpdateMaterialProperties();
				}
			}
		}

		public Color anamorphicFlaresTint
		{
			get
			{
				return _anamorphicFlaresTint;
			}
			set
			{
				if (_anamorphicFlaresTint != value)
				{
					_anamorphicFlaresTint = value;
					UpdateMaterialProperties();
				}
			}
		}

		public bool anamorphicFlaresBlur
		{
			get
			{
				return _anamorphicFlaresBlur;
			}
			set
			{
				if (_anamorphicFlaresBlur != value)
				{
					_anamorphicFlaresBlur = value;
					UpdateMaterialProperties();
				}
			}
		}

		public bool depthOfField
		{
			get
			{
				return _depthOfField;
			}
			set
			{
				if (_depthOfField != value)
				{
					_depthOfField = value;
					UpdateMaterialProperties();
				}
			}
		}

		public bool depthOfFieldTransparencySupport
		{
			get
			{
				return _depthOfFieldTransparencySupport;
			}
			set
			{
				if (_depthOfFieldTransparencySupport != value)
				{
					_depthOfFieldTransparencySupport = value;
					UpdateMaterialProperties();
				}
			}
		}

		public LayerMask depthOfFieldTransparencyLayerMask
		{
			get
			{
				return _depthOfFieldTransparencyLayerMask;
			}
			set
			{
				if ((int)_depthOfFieldTransparencyLayerMask != (int)value)
				{
					_depthOfFieldTransparencyLayerMask = value;
					UpdateMaterialProperties();
				}
			}
		}

		public Transform depthOfFieldTargetFocus
		{
			get
			{
				return _depthOfFieldTargetFocus;
			}
			set
			{
				if (_depthOfFieldTargetFocus != value)
				{
					_depthOfFieldTargetFocus = value;
					UpdateMaterialProperties();
				}
			}
		}

		public bool depthOfFieldDebug
		{
			get
			{
				return _depthOfFieldDebug;
			}
			set
			{
				if (_depthOfFieldDebug != value)
				{
					_depthOfFieldDebug = value;
					UpdateMaterialProperties();
				}
			}
		}

		public bool depthOfFieldAutofocus
		{
			get
			{
				return _depthOfFieldAutofocus;
			}
			set
			{
				if (_depthOfFieldAutofocus != value)
				{
					_depthOfFieldAutofocus = value;
					UpdateMaterialProperties();
				}
			}
		}

		public Vector2 depthofFieldAutofocusViewportPoint
		{
			get
			{
				return _depthofFieldAutofocusViewportPoint;
			}
			set
			{
				if (_depthofFieldAutofocusViewportPoint != value)
				{
					_depthofFieldAutofocusViewportPoint = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float depthOfFieldAutofocusMinDistance
		{
			get
			{
				return _depthOfFieldAutofocusMinDistance;
			}
			set
			{
				if (_depthOfFieldAutofocusMinDistance != value)
				{
					_depthOfFieldAutofocusMinDistance = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float depthOfFieldAutofocusMaxDistance
		{
			get
			{
				return _depthOfFieldAutofocusMaxDistance;
			}
			set
			{
				if (_depthOfFieldAutofocusMaxDistance != value)
				{
					_depthOfFieldAutofocusMaxDistance = value;
					UpdateMaterialProperties();
				}
			}
		}

		public LayerMask depthOfFieldAutofocusLayerMask
		{
			get
			{
				return _depthOfFieldAutofocusLayerMask;
			}
			set
			{
				if ((int)_depthOfFieldAutofocusLayerMask != (int)value)
				{
					_depthOfFieldAutofocusLayerMask = value;
					UpdateMaterialProperties();
				}
			}
		}

		public LayerMask depthOfFieldExclusionLayerMask
		{
			get
			{
				return _depthOfFieldExclusionLayerMask;
			}
			set
			{
				if ((int)_depthOfFieldExclusionLayerMask != (int)value)
				{
					_depthOfFieldExclusionLayerMask = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float depthOfFieldExclusionLayerMaskDownsampling
		{
			get
			{
				return _depthOfFieldExclusionLayerMaskDownsampling;
			}
			set
			{
				if (_depthOfFieldExclusionLayerMaskDownsampling != value)
				{
					_depthOfFieldExclusionLayerMaskDownsampling = Mathf.Max(value, 1f);
					UpdateMaterialProperties();
				}
			}
		}

		public float depthOfFieldTransparencySupportDownsampling
		{
			get
			{
				return _depthOfFieldTransparencySupportDownsampling;
			}
			set
			{
				if (_depthOfFieldTransparencySupportDownsampling != value)
				{
					_depthOfFieldTransparencySupportDownsampling = Mathf.Max(value, 1f);
					UpdateMaterialProperties();
				}
			}
		}

		public float depthOfFieldExclusionBias
		{
			get
			{
				return _depthOfFieldExclusionBias;
			}
			set
			{
				if (_depthOfFieldExclusionBias != value)
				{
					_depthOfFieldExclusionBias = Mathf.Clamp01(value);
					UpdateMaterialProperties();
				}
			}
		}

		public float depthOfFieldDistance
		{
			get
			{
				return _depthOfFieldDistance;
			}
			set
			{
				if (_depthOfFieldDistance != value)
				{
					_depthOfFieldDistance = Mathf.Max(value, 1f);
					UpdateMaterialProperties();
				}
			}
		}

		public float depthOfFieldFocusSpeed
		{
			get
			{
				return _depthOfFieldFocusSpeed;
			}
			set
			{
				if (_depthOfFieldFocusSpeed != value)
				{
					_depthOfFieldFocusSpeed = Mathf.Clamp(value, 0.001f, 1f);
					UpdateMaterialProperties();
				}
			}
		}

		public int depthOfFieldDownsampling
		{
			get
			{
				return _depthOfFieldDownsampling;
			}
			set
			{
				if (_depthOfFieldDownsampling != value)
				{
					_depthOfFieldDownsampling = Mathf.Max(value, 1);
					UpdateMaterialProperties();
				}
			}
		}

		public int depthOfFieldMaxSamples
		{
			get
			{
				return _depthOfFieldMaxSamples;
			}
			set
			{
				if (_depthOfFieldMaxSamples != value)
				{
					_depthOfFieldMaxSamples = Mathf.Max(value, 2);
					UpdateMaterialProperties();
				}
			}
		}

		public float depthOfFieldFocalLength
		{
			get
			{
				return _depthOfFieldFocalLength;
			}
			set
			{
				if (_depthOfFieldFocalLength != value)
				{
					_depthOfFieldFocalLength = Mathf.Abs(value);
					UpdateMaterialProperties();
				}
			}
		}

		public float depthOfFieldAperture
		{
			get
			{
				return _depthOfFieldAperture;
			}
			set
			{
				if (_depthOfFieldAperture != value)
				{
					_depthOfFieldAperture = Mathf.Abs(value);
					UpdateMaterialProperties();
				}
			}
		}

		public bool depthOfFieldForegroundBlur
		{
			get
			{
				return _depthOfFieldForegroundBlur;
			}
			set
			{
				if (_depthOfFieldForegroundBlur != value)
				{
					_depthOfFieldForegroundBlur = value;
					UpdateMaterialProperties();
				}
			}
		}

		public bool depthOfFieldForegroundBlurHQ
		{
			get
			{
				return _depthOfFieldForegroundBlurHQ;
			}
			set
			{
				if (_depthOfFieldForegroundBlurHQ != value)
				{
					_depthOfFieldForegroundBlurHQ = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float depthOfFieldForegroundDistance
		{
			get
			{
				return _depthOfFieldForegroundDistance;
			}
			set
			{
				if (_depthOfFieldForegroundDistance != value)
				{
					_depthOfFieldForegroundDistance = value;
					UpdateMaterialProperties();
				}
			}
		}

		public bool depthOfFieldBokeh
		{
			get
			{
				return _depthOfFieldBokeh;
			}
			set
			{
				if (_depthOfFieldBokeh != value)
				{
					_depthOfFieldBokeh = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float depthOfFieldBokehThreshold
		{
			get
			{
				return _depthOfFieldBokehThreshold;
			}
			set
			{
				if (_depthOfFieldBokehThreshold != value)
				{
					_depthOfFieldBokehThreshold = Mathf.Max(value, 0f);
					UpdateMaterialProperties();
				}
			}
		}

		public float depthOfFieldBokehIntensity
		{
			get
			{
				return _depthOfFieldBokehIntensity;
			}
			set
			{
				if (_depthOfFieldBokehIntensity != value)
				{
					_depthOfFieldBokehIntensity = Mathf.Max(value, 0f);
					UpdateMaterialProperties();
				}
			}
		}

		public float depthOfFieldMaxBrightness
		{
			get
			{
				return _depthOfFieldMaxBrightness;
			}
			set
			{
				if (_depthOfFieldMaxBrightness != value)
				{
					_depthOfFieldMaxBrightness = Mathf.Abs(value);
					UpdateMaterialProperties();
				}
			}
		}

		public float depthOfFieldMaxDistance
		{
			get
			{
				return _depthOfFieldMaxDistance;
			}
			set
			{
				if (_depthOfFieldMaxDistance != value)
				{
					_depthOfFieldMaxDistance = Mathf.Abs(value);
					UpdateMaterialProperties();
				}
			}
		}

		public FilterMode depthOfFieldFilterMode
		{
			get
			{
				return _depthOfFieldFilterMode;
			}
			set
			{
				if (_depthOfFieldFilterMode != value)
				{
					_depthOfFieldFilterMode = value;
					UpdateMaterialProperties();
				}
			}
		}

		public bool eyeAdaptation
		{
			get
			{
				return _eyeAdaptation;
			}
			set
			{
				if (_eyeAdaptation != value)
				{
					_eyeAdaptation = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float eyeAdaptationMinExposure
		{
			get
			{
				return _eyeAdaptationMinExposure;
			}
			set
			{
				if (_eyeAdaptationMinExposure != value)
				{
					_eyeAdaptationMinExposure = Mathf.Clamp01(value);
					UpdateMaterialProperties();
				}
			}
		}

		public float eyeAdaptationMaxExposure
		{
			get
			{
				return _eyeAdaptationMaxExposure;
			}
			set
			{
				if (_eyeAdaptationMaxExposure != value)
				{
					_eyeAdaptationMaxExposure = Mathf.Clamp(value, 1f, 100f);
					UpdateMaterialProperties();
				}
			}
		}

		public float eyeAdaptationSpeedToLight
		{
			get
			{
				return _eyeAdaptationSpeedToLight;
			}
			set
			{
				if (_eyeAdaptationSpeedToLight != value)
				{
					_eyeAdaptationSpeedToLight = Mathf.Clamp01(value);
					UpdateMaterialProperties();
				}
			}
		}

		public float eyeAdaptationSpeedToDark
		{
			get
			{
				return _eyeAdaptationSpeedToDark;
			}
			set
			{
				if (_eyeAdaptationSpeedToDark != value)
				{
					_eyeAdaptationSpeedToDark = Mathf.Clamp01(value);
					UpdateMaterialProperties();
				}
			}
		}

		public bool purkinje
		{
			get
			{
				return _purkinje;
			}
			set
			{
				if (_purkinje != value)
				{
					_purkinje = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float purkinjeAmount
		{
			get
			{
				return _purkinjeAmount;
			}
			set
			{
				if (_purkinjeAmount != value)
				{
					_purkinjeAmount = Mathf.Clamp(value, 0f, 5f);
					UpdateMaterialProperties();
				}
			}
		}

		public float purkinjeLuminanceThreshold
		{
			get
			{
				return _purkinjeLuminanceThreshold;
			}
			set
			{
				if (purkinjeLuminanceThreshold != value)
				{
					_purkinjeLuminanceThreshold = Mathf.Clamp(value, 0f, 1f);
					UpdateMaterialProperties();
				}
			}
		}

		public BEAUTIFY_TMO tonemap
		{
			get
			{
				return _tonemap;
			}
			set
			{
				if (_tonemap != value)
				{
					_tonemap = value;
					if (_tonemap == BEAUTIFY_TMO.ACES)
					{
						_saturate = 0f;
						_contrast = 1f;
					}
					UpdateMaterialProperties();
				}
			}
		}

		public bool sunFlares
		{
			get
			{
				return _sunFlares;
			}
			set
			{
				if (_sunFlares != value)
				{
					_sunFlares = value;
					UpdateMaterialProperties();
				}
			}
		}

		public Transform sun
		{
			get
			{
				return _sun;
			}
			set
			{
				if (_sun != value)
				{
					_sun = value;
					UpdateMaterialProperties();
				}
			}
		}

		public LayerMask sunFlaresLayerMask
		{
			get
			{
				return _sunFlaresLayerMask;
			}
			set
			{
				if ((int)_sunFlaresLayerMask != (int)value)
				{
					_sunFlaresLayerMask = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float sunFlaresIntensity
		{
			get
			{
				return _sunFlaresIntensity;
			}
			set
			{
				if (_sunFlaresIntensity != value)
				{
					_sunFlaresIntensity = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float sunFlaresSolarWindSpeed
		{
			get
			{
				return _sunFlaresSolarWindSpeed;
			}
			set
			{
				if (_sunFlaresSolarWindSpeed != value)
				{
					_sunFlaresSolarWindSpeed = value;
					UpdateMaterialProperties();
				}
			}
		}

		public Color sunFlaresTint
		{
			get
			{
				return _sunFlaresTint;
			}
			set
			{
				if (_sunFlaresTint != value)
				{
					_sunFlaresTint = value;
					UpdateMaterialProperties();
				}
			}
		}

		public int sunFlaresDownsampling
		{
			get
			{
				return _sunFlaresDownsampling;
			}
			set
			{
				if (_sunFlaresDownsampling != value)
				{
					_sunFlaresDownsampling = Mathf.Max(value, 1);
					UpdateMaterialProperties();
				}
			}
		}

		public float sunFlaresSunIntensity
		{
			get
			{
				return _sunFlaresSunIntensity;
			}
			set
			{
				if (_sunFlaresSunIntensity != value)
				{
					_sunFlaresSunIntensity = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float sunFlaresSunDiskSize
		{
			get
			{
				return _sunFlaresSunDiskSize;
			}
			set
			{
				if (_sunFlaresSunDiskSize != value)
				{
					_sunFlaresSunDiskSize = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float sunFlaresSunRayDiffractionIntensity
		{
			get
			{
				return _sunFlaresSunRayDiffractionIntensity;
			}
			set
			{
				if (_sunFlaresSunRayDiffractionIntensity != value)
				{
					_sunFlaresSunRayDiffractionIntensity = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float sunFlaresSunRayDiffractionThreshold
		{
			get
			{
				return _sunFlaresSunRayDiffractionThreshold;
			}
			set
			{
				if (_sunFlaresSunRayDiffractionThreshold != value)
				{
					_sunFlaresSunRayDiffractionThreshold = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float sunFlaresCoronaRays1Length
		{
			get
			{
				return _sunFlaresCoronaRays1Length;
			}
			set
			{
				if (_sunFlaresCoronaRays1Length != value)
				{
					_sunFlaresCoronaRays1Length = value;
					UpdateMaterialProperties();
				}
			}
		}

		public int sunFlaresCoronaRays1Streaks
		{
			get
			{
				return _sunFlaresCoronaRays1Streaks;
			}
			set
			{
				if (_sunFlaresCoronaRays1Streaks != value)
				{
					_sunFlaresCoronaRays1Streaks = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float sunFlaresCoronaRays1Spread
		{
			get
			{
				return _sunFlaresCoronaRays1Spread;
			}
			set
			{
				if (_sunFlaresCoronaRays1Spread != value)
				{
					_sunFlaresCoronaRays1Spread = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float sunFlaresCoronaRays1AngleOffset
		{
			get
			{
				return _sunFlaresCoronaRays1AngleOffset;
			}
			set
			{
				if (_sunFlaresCoronaRays1AngleOffset != value)
				{
					_sunFlaresCoronaRays1AngleOffset = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float sunFlaresCoronaRays2Length
		{
			get
			{
				return _sunFlaresCoronaRays2Length;
			}
			set
			{
				if (_sunFlaresCoronaRays2Length != value)
				{
					_sunFlaresCoronaRays2Length = value;
					UpdateMaterialProperties();
				}
			}
		}

		public int sunFlaresCoronaRays2Streaks
		{
			get
			{
				return _sunFlaresCoronaRays2Streaks;
			}
			set
			{
				if (_sunFlaresCoronaRays2Streaks != value)
				{
					_sunFlaresCoronaRays2Streaks = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float sunFlaresCoronaRays2Spread
		{
			get
			{
				return _sunFlaresCoronaRays2Spread;
			}
			set
			{
				if (_sunFlaresCoronaRays2Spread != value)
				{
					_sunFlaresCoronaRays2Spread = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float sunFlaresCoronaRays2AngleOffset
		{
			get
			{
				return _sunFlaresCoronaRays2AngleOffset;
			}
			set
			{
				if (_sunFlaresCoronaRays2AngleOffset != value)
				{
					_sunFlaresCoronaRays2AngleOffset = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float sunFlaresGhosts1Size
		{
			get
			{
				return _sunFlaresGhosts1Size;
			}
			set
			{
				if (_sunFlaresGhosts1Size != value)
				{
					_sunFlaresGhosts1Size = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float sunFlaresGhosts1Offset
		{
			get
			{
				return _sunFlaresGhosts1Offset;
			}
			set
			{
				if (_sunFlaresGhosts1Offset != value)
				{
					_sunFlaresGhosts1Offset = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float sunFlaresGhosts1Brightness
		{
			get
			{
				return _sunFlaresGhosts1Brightness;
			}
			set
			{
				if (_sunFlaresGhosts1Brightness != value)
				{
					_sunFlaresGhosts1Brightness = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float sunFlaresGhosts2Size
		{
			get
			{
				return _sunFlaresGhosts2Size;
			}
			set
			{
				if (_sunFlaresGhosts2Size != value)
				{
					_sunFlaresGhosts2Size = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float sunFlaresGhosts2Offset
		{
			get
			{
				return _sunFlaresGhosts2Offset;
			}
			set
			{
				if (_sunFlaresGhosts2Offset != value)
				{
					_sunFlaresGhosts2Offset = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float sunFlaresGhosts2Brightness
		{
			get
			{
				return _sunFlaresGhosts2Brightness;
			}
			set
			{
				if (_sunFlaresGhosts2Brightness != value)
				{
					_sunFlaresGhosts2Brightness = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float sunFlaresGhosts3Size
		{
			get
			{
				return _sunFlaresGhosts3Size;
			}
			set
			{
				if (_sunFlaresGhosts3Size != value)
				{
					_sunFlaresGhosts3Size = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float sunFlaresGhosts3Brightness
		{
			get
			{
				return _sunFlaresGhosts3Brightness;
			}
			set
			{
				if (_sunFlaresGhosts3Brightness != value)
				{
					_sunFlaresGhosts3Brightness = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float sunFlaresGhosts3Offset
		{
			get
			{
				return _sunFlaresGhosts3Offset;
			}
			set
			{
				if (_sunFlaresGhosts3Offset != value)
				{
					_sunFlaresGhosts3Offset = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float sunFlaresGhosts4Size
		{
			get
			{
				return _sunFlaresGhosts4Size;
			}
			set
			{
				if (_sunFlaresGhosts4Size != value)
				{
					_sunFlaresGhosts4Size = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float sunFlaresGhosts4Offset
		{
			get
			{
				return _sunFlaresGhosts4Offset;
			}
			set
			{
				if (_sunFlaresGhosts4Offset != value)
				{
					_sunFlaresGhosts4Offset = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float sunFlaresGhosts4Brightness
		{
			get
			{
				return _sunFlaresGhosts4Brightness;
			}
			set
			{
				if (_sunFlaresGhosts4Brightness != value)
				{
					_sunFlaresGhosts4Brightness = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float sunFlaresHaloOffset
		{
			get
			{
				return _sunFlaresHaloOffset;
			}
			set
			{
				if (_sunFlaresHaloOffset != value)
				{
					_sunFlaresHaloOffset = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float sunFlaresHaloAmplitude
		{
			get
			{
				return _sunFlaresHaloAmplitude;
			}
			set
			{
				if (_sunFlaresHaloAmplitude != value)
				{
					_sunFlaresHaloAmplitude = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float sunFlaresHaloIntensity
		{
			get
			{
				return _sunFlaresHaloIntensity;
			}
			set
			{
				if (_sunFlaresHaloIntensity != value)
				{
					_sunFlaresHaloIntensity = value;
					UpdateMaterialProperties();
				}
			}
		}

		public bool sunFlaresRotationDeadZone
		{
			get
			{
				return _sunFlaresRotationDeadZone;
			}
			set
			{
				if (_sunFlaresRotationDeadZone != value)
				{
					_sunFlaresRotationDeadZone = value;
					UpdateMaterialProperties();
				}
			}
		}

		public bool blur
		{
			get
			{
				return _blur;
			}
			set
			{
				if (_blur != value)
				{
					_blur = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float blurIntensity
		{
			get
			{
				return _blurIntensity;
			}
			set
			{
				if (_blurIntensity != value)
				{
					_blurIntensity = value;
					UpdateMaterialProperties();
				}
			}
		}

		public int downscale
		{
			get
			{
				return _downscale;
			}
			set
			{
				if (_downscale != value)
				{
					_downscale = value;
					UpdateMaterialProperties();
				}
			}
		}

		public int pixelateAmount
		{
			get
			{
				return _pixelateAmount;
			}
			set
			{
				if (_pixelateAmount != value)
				{
					_pixelateAmount = value;
					UpdateMaterialProperties();
				}
			}
		}

		public bool pixelateDownscale
		{
			get
			{
				return _pixelateDownscale;
			}
			set
			{
				if (_pixelateDownscale != value)
				{
					_pixelateDownscale = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float antialiasStrength
		{
			get
			{
				return _antialiasStrength;
			}
			set
			{
				if (_antialiasStrength != value)
				{
					_antialiasStrength = value;
					UpdateMaterialProperties();
				}
			}
		}

		public float antialiasDepthThreshold
		{
			get
			{
				return _antialiasDepthThreshold;
			}
			set
			{
				if (_antialiasDepthThreshold != value)
				{
					_antialiasDepthThreshold = value;
					UpdateMaterialProperties();
				}
			}
		}

		public static Beautify instance
		{
			get
			{
				if (_beautify == null)
				{
					Camera[] allCameras = Camera.allCameras;
					for (int i = 0; i < allCameras.Length; i++)
					{
						_beautify = allCameras[i].GetComponent<Beautify>();
						if (_beautify != null)
						{
							break;
						}
					}
				}
				return _beautify;
			}
		}

		public Camera cameraEffect => currentCamera;

		public float depthOfFieldCurrentFocalPointDistance => dofLastAutofocusDistance;

		private void OnEnable()
		{
			currentCamera = GetComponent<Camera>();
			rtDescBase = XRSettings.eyeTextureDesc;
			if (_syncWithProfile && _profile != null)
			{
				_profile.Load(this);
			}
			if (XRSettings.enabled)
			{
				_downscale = 1;
				_pixelateDownscale = false;
			}
			UpdateMaterialPropertiesNow();
		}

		private void OnDestroy()
		{
			CleanUpRT();
			if (depthCamObj != null)
			{
				UnityEngine.Object.DestroyImmediate(depthCamObj);
				depthCamObj = null;
			}
			if (rtEAacum != null)
			{
				rtEAacum.Release();
			}
			if (rtEAHist != null)
			{
				rtEAHist.Release();
			}
			if (bMatDesktop != null)
			{
				UnityEngine.Object.DestroyImmediate(bMatDesktop);
				bMatDesktop = null;
			}
			if (bMatMobile != null)
			{
				UnityEngine.Object.DestroyImmediate(bMatMobile);
				bMatMobile = null;
			}
			if (bMatBasic != null)
			{
				UnityEngine.Object.DestroyImmediate(bMatBasic);
				bMatBasic = null;
			}
			bMat = null;
		}

		private void Reset()
		{
			UpdateMaterialPropertiesNow();
		}

		private void LateUpdate()
		{
			if (bMat == null || !Application.isPlaying || _sharpenMotionSensibility <= 0f)
			{
				return;
			}
			float num = Vector3.Angle(camPrevForward, currentCamera.transform.forward) * _sharpenMotionSensibility;
			float num2 = (currentCamera.transform.position - camPrevPos).sqrMagnitude * 10f * _sharpenMotionSensibility;
			float num3 = num + num2;
			if (num3 > 0.1f)
			{
				camPrevForward = currentCamera.transform.forward;
				camPrevPos = currentCamera.transform.position;
				if (num3 > _sharpenMotionSensibility)
				{
					num3 = _sharpenMotionSensibility;
				}
				currSens += num3;
				float min = _sharpen * _sharpenMotionSensibility * 0.75f;
				float max = _sharpen * (1f + _sharpenMotionSensibility) * 0.5f;
				currSens = Mathf.Clamp(currSens, min, max);
			}
			else
			{
				if (currSens <= 0.001f)
				{
					return;
				}
				currSens *= 0.75f;
			}
			float num4 = Mathf.Clamp(_sharpen - currSens, 0f, _sharpen);
			UpdateSharpenParams(num4);
		}

		private void OnPreCull()
		{
			if (_preRenderCameraEvent == BEAUTIFY_PRERENDER_EVENT.OnPreCull)
			{
				DoOnPreRenderTasks();
			}
		}

		private void DoOnPreRenderTasks()
		{
			CleanUpRT();
			if (base.enabled && base.gameObject.activeSelf && !(currentCamera == null) && !(bMat == null) && (_depthOfField || _bloom || _anamorphicFlares))
			{
				if (dofCurrentLayerMaskValue != _depthOfFieldExclusionLayerMask.value)
				{
					shouldUpdateMaterialProperties = true;
				}
				if (depthOfField && (_depthOfFieldTransparencySupport || (int)_depthOfFieldExclusionLayerMask != 0))
				{
					CheckDoFTransparencySupport();
					CheckDoFExclusionMask();
				}
				if (_bloomCullingMask.value != bloomCurrentLayerMaskValue)
				{
					shouldUpdateMaterialProperties = true;
				}
				if ((_bloom || _anamorphicFlares) && (int)_bloomCullingMask > 0)
				{
					CheckBloomCullingLayer();
				}
			}
		}

		private void OnPreRender()
		{
			if (_preRenderCameraEvent == BEAUTIFY_PRERENDER_EVENT.OnPreRender)
			{
				DoOnPreRenderTasks();
			}
			if (_downscale > 1 && rtDescBase.width > 1)
			{
				_pixelateAmount = 1;
				RenderTextureDescriptor desc = rtDescBase;
				desc.width = Mathf.RoundToInt(Mathf.Max(1, currentCamera.pixelWidth / _downscale));
				float num = (float)currentCamera.pixelHeight / (float)currentCamera.pixelWidth;
				desc.height = Mathf.Max(1, Mathf.RoundToInt((float)desc.width * num));
				pixelateTexture = RenderTexture.GetTemporary(desc);
				currentCamera.targetTexture = pixelateTexture;
			}
			else if (_pixelateDownscale && _pixelateAmount > 1 && rtDescBase.width > 1 && rtDescBase.height > 1)
			{
				RenderTextureDescriptor desc2 = rtDescBase;
				desc2.width = Mathf.RoundToInt(Mathf.Max(1, currentCamera.pixelWidth / _pixelateAmount));
				float num2 = (float)currentCamera.pixelHeight / (float)currentCamera.pixelWidth;
				desc2.height = Mathf.Max(1, Mathf.RoundToInt((float)desc2.width * num2));
				pixelateTexture = RenderTexture.GetTemporary(desc2);
				currentCamera.targetTexture = pixelateTexture;
			}
		}

		private void CleanUpRT()
		{
			if (dofDepthTexture != null)
			{
				RenderTexture.ReleaseTemporary(dofDepthTexture);
				dofDepthTexture = null;
			}
			if (dofExclusionTexture != null)
			{
				RenderTexture.ReleaseTemporary(dofExclusionTexture);
				dofExclusionTexture = null;
			}
			if (bloomSourceTexture != null)
			{
				RenderTexture.ReleaseTemporary(bloomSourceTexture);
				bloomSourceTexture = null;
			}
			if (bloomSourceDepthTexture != null)
			{
				RenderTexture.ReleaseTemporary(bloomSourceDepthTexture);
				bloomSourceDepthTexture = null;
			}
			if (bloomSourceTextureRightEye != null)
			{
				RenderTexture.ReleaseTemporary(bloomSourceTextureRightEye);
				bloomSourceTextureRightEye = null;
			}
			if (bloomSourceDepthTextureRightEye != null)
			{
				RenderTexture.ReleaseTemporary(bloomSourceDepthTextureRightEye);
				bloomSourceDepthTextureRightEye = null;
			}
			if (pixelateTexture != null)
			{
				RenderTexture.ReleaseTemporary(pixelateTexture);
				pixelateTexture = null;
			}
		}

		private void CheckDoFTransparencySupport()
		{
			if (depthCam == null)
			{
				if (depthCamObj == null)
				{
					depthCamObj = new GameObject("DepthCamera");
					depthCamObj.hideFlags = HideFlags.HideAndDontSave;
					depthCam = depthCamObj.AddComponent<Camera>();
					depthCam.enabled = false;
				}
				else
				{
					depthCam = depthCamObj.GetComponent<Camera>();
					if (depthCam == null)
					{
						UnityEngine.Object.DestroyImmediate(depthCamObj);
						depthCamObj = null;
						return;
					}
				}
			}
			depthCam.CopyFrom(currentCamera);
			depthCam.rect = new Rect(0f, 0f, 1f, 1f);
			depthCam.depthTextureMode = DepthTextureMode.None;
			depthCam.renderingPath = RenderingPath.Forward;
			float num = _depthOfFieldTransparencySupportDownsampling * (float)_depthOfFieldDownsampling;
			dofDepthTexture = RenderTexture.GetTemporary((int)((float)currentCamera.pixelWidth / num), (int)((float)currentCamera.pixelHeight / num), 16, RenderTextureFormat.ARGB32, RenderTextureReadWrite.Linear);
			dofDepthTexture.filterMode = FilterMode.Point;
			depthCam.backgroundColor = new Color(84f / 85f, 0.4470558f, 0.75f, 0f);
			depthCam.clearFlags = CameraClearFlags.Color;
			depthCam.targetTexture = dofDepthTexture;
			depthCam.cullingMask = _depthOfFieldTransparencyLayerMask;
			if (depthShader == null)
			{
				depthShader = Shader.Find("Beautify/CopyDepth");
			}
			depthCam.RenderWithShader(depthShader, "RenderType");
			bMat.SetTexture("_DepthTexture", dofDepthTexture);
		}

		private void CheckDoFExclusionMask()
		{
			if (depthCam == null)
			{
				if (depthCamObj == null)
				{
					depthCamObj = new GameObject("DepthCamera");
					depthCamObj.hideFlags = HideFlags.HideAndDontSave;
					depthCam = depthCamObj.AddComponent<Camera>();
					depthCam.enabled = false;
				}
				else
				{
					depthCam = depthCamObj.GetComponent<Camera>();
					if (depthCam == null)
					{
						UnityEngine.Object.DestroyImmediate(depthCamObj);
						depthCamObj = null;
						return;
					}
				}
			}
			depthCam.CopyFrom(currentCamera);
			depthCam.rect = new Rect(0f, 0f, 1f, 1f);
			depthCam.depthTextureMode = DepthTextureMode.None;
			depthCam.renderingPath = RenderingPath.Forward;
			float num = _depthOfFieldExclusionLayerMaskDownsampling * (float)_depthOfFieldDownsampling;
			dofExclusionTexture = RenderTexture.GetTemporary((int)((float)currentCamera.pixelWidth / num), (int)((float)currentCamera.pixelHeight / num), 16, RenderTextureFormat.ARGB32, RenderTextureReadWrite.Linear);
			dofExclusionTexture.filterMode = FilterMode.Point;
			depthCam.backgroundColor = new Color(84f / 85f, 0.4470558f, 0.75f, 0f);
			depthCam.clearFlags = CameraClearFlags.Color;
			depthCam.targetTexture = dofExclusionTexture;
			depthCam.cullingMask = _depthOfFieldExclusionLayerMask;
			if (dofExclusionShader == null)
			{
				dofExclusionShader = Shader.Find("Beautify/CopyDepthBiased");
			}
			depthCam.RenderWithShader(dofExclusionShader, null);
			bMat.SetTexture("_DofExclusionTexture", dofExclusionTexture);
		}

		private void CheckBloomCullingLayer()
		{
			if (rtDescBase.volumeDepth == 0)
			{
				return;
			}
			if (depthCam == null)
			{
				if (depthCamObj == null)
				{
					depthCamObj = new GameObject("DepthCamera");
					depthCamObj.hideFlags = HideFlags.HideAndDontSave;
					depthCam = depthCamObj.AddComponent<Camera>();
					depthCam.enabled = false;
				}
				else
				{
					depthCam = depthCamObj.GetComponent<Camera>();
					if (depthCam == null)
					{
						UnityEngine.Object.DestroyImmediate(depthCamObj);
						depthCamObj = null;
						return;
					}
				}
			}
			depthCam.CopyFrom(currentCamera);
			depthCam.rect = new Rect(0f, 0f, 1f, 1f);
			depthCam.depthTextureMode = DepthTextureMode.None;
			depthCam.allowMSAA = false;
			depthCam.allowHDR = false;
			depthCam.clearFlags = CameraClearFlags.Color;
			depthCam.stereoTargetEye = StereoTargetEyeMask.None;
			depthCam.renderingPath = RenderingPath.Forward;
			depthCam.backgroundColor = Color.black;
			depthCam.cullingMask = _bloomCullingMask;
			if (XRSettings.enabled)
			{
				depthCam.projectionMatrix = cameraEffect.GetStereoProjectionMatrix(Camera.StereoscopicEye.Left);
			}
			if (_quality == BEAUTIFY_QUALITY.BestPerformance)
			{
				eyeWidth = 256;
			}
			else
			{
				eyeWidth = (_bloomUltra ? ((int)(Mathf.Lerp(512f, currentCamera.pixelHeight, (float)_bloomUltraResolution / 10f) / 4f) * 4) : 512);
				eyeWidth = (int)((float)eyeWidth * (1f / _bloomLayerMaskDownsampling) / 4f) * 4;
			}
			float num = (float)currentCamera.pixelHeight / (float)currentCamera.pixelWidth;
			eyeHeight = Mathf.Max(1, (int)((float)eyeWidth * num));
			RenderLeftEyeDepth();
			if (XRSettings.enabled)
			{
				depthCam.projectionMatrix = cameraEffect.GetStereoProjectionMatrix(Camera.StereoscopicEye.Right);
				RenderRightEyeDepth();
			}
		}

		private void RenderLeftEyeDepth()
		{
			RenderTextureDescriptor desc = rtDescBase;
			desc.width = eyeWidth;
			desc.height = eyeHeight;
			desc.depthBufferBits = 24;
			desc.colorFormat = RenderTextureFormat.Depth;
			bloomSourceDepthTexture = RenderTexture.GetTemporary(desc);
			desc.depthBufferBits = 0;
			desc.colorFormat = rtFormat;
			bloomSourceTexture = RenderTexture.GetTemporary(desc);
			depthCam.SetTargetBuffers(bloomSourceTexture.colorBuffer, bloomSourceDepthTexture.depthBuffer);
			depthCam.Render();
			bMat.SetTexture("_BloomSourceTex", bloomSourceTexture);
			bMat.SetTexture("_BloomSourceDepth", bloomSourceDepthTexture);
		}

		private void RenderRightEyeDepth()
		{
			RenderTextureDescriptor desc = rtDescBase;
			desc.width = eyeWidth;
			desc.height = eyeHeight;
			desc.depthBufferBits = 24;
			desc.colorFormat = RenderTextureFormat.Depth;
			bloomSourceDepthTextureRightEye = RenderTexture.GetTemporary(desc);
			desc.depthBufferBits = 0;
			desc.colorFormat = rtFormat;
			bloomSourceTextureRightEye = RenderTexture.GetTemporary(desc);
			depthCam.SetTargetBuffers(bloomSourceTextureRightEye.colorBuffer, bloomSourceDepthTextureRightEye.depthBuffer);
			depthCam.Render();
			bMat.SetTexture("_BloomSourceTexRightEye", bloomSourceTextureRightEye);
			bMat.SetTexture("_BloomSourceDepthRightEye", bloomSourceDepthTextureRightEye);
		}

		protected virtual void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (bMat == null || !base.enabled)
			{
				Graphics.Blit(source, destination);
				return;
			}
			if (shouldUpdateMaterialProperties)
			{
				UpdateMaterialPropertiesNow();
			}
			bool flag = _quality != BEAUTIFY_QUALITY.Basic;
			rtDescBase = source.descriptor;
			rtDescBase.msaaSamples = 1;
			rtDescBase.colorFormat = rtFormat;
			rtDescBase.depthBufferBits = 0;
			RenderTexture renderTexture = null;
			RenderTexture renderTexture2 = null;
			RenderTexture renderTexture3 = null;
			float num = (float)source.height / (float)source.width;
			bool flag2 = _blur && _blurIntensity > 0f && flag;
			if (renderPass == 0 || flag2)
			{
				if (flag2)
				{
					int num2;
					if (_blurIntensity < 1f)
					{
						num2 = (int)Mathf.Lerp(currentCamera.pixelWidth, 512f, _blurIntensity);
						if (_quality == BEAUTIFY_QUALITY.BestPerformance)
						{
							num2 /= 2;
						}
					}
					else
					{
						num2 = ((_quality == BEAUTIFY_QUALITY.BestQuality) ? 512 : 256);
						num2 = (int)((float)num2 / _blurIntensity);
					}
					RenderTextureDescriptor desc = rtDescBase;
					desc.width = num2;
					desc.height = Mathf.Max(1, (int)((float)num2 * num));
					renderTexture2 = RenderTexture.GetTemporary(desc);
					if (renderPass == 0)
					{
						renderTexture = RenderTexture.GetTemporary(desc);
					}
				}
				else
				{
					renderTexture = RenderTexture.GetTemporary(rtDescBase);
				}
			}
			RenderTexture renderTexture4 = null;
			RenderTexture renderTexture5 = null;
			RenderTexture renderTexture6 = null;
			if (flag)
			{
				if (_pixelateAmount > 1)
				{
					source.filterMode = FilterMode.Point;
					if (!_pixelateDownscale)
					{
						RenderTextureDescriptor desc2 = rtDescBase;
						desc2.width = Mathf.RoundToInt(Mathf.Max(1, source.width / _pixelateAmount));
						desc2.height = Mathf.Max(1, Mathf.RoundToInt((float)desc2.width * num));
						renderTexture4 = RenderTexture.GetTemporary(desc2);
						renderTexture4.filterMode = FilterMode.Point;
						Graphics.Blit(source, renderTexture4, bMat, (_quality == BEAUTIFY_QUALITY.BestQuality) ? 22 : 18);
						source = renderTexture4;
					}
				}
				if (_depthOfField)
				{
					UpdateDepthOfFieldData();
					int pass = ((_quality == BEAUTIFY_QUALITY.BestQuality) ? 12 : 6);
					RenderTextureDescriptor desc3 = rtDescBase;
					desc3.width = source.width / _depthOfFieldDownsampling;
					desc3.height = source.height / _depthOfFieldDownsampling;
					renderTexture5 = RenderTexture.GetTemporary(desc3);
					renderTexture5.filterMode = _depthOfFieldFilterMode;
					Graphics.Blit(source, renderTexture5, bMat, pass);
					pass = ((_quality != 0) ? (_depthOfFieldBokeh ? 8 : 15) : (_depthOfFieldBokeh ? 14 : 19));
					if (_quality == BEAUTIFY_QUALITY.BestQuality && _depthOfFieldForegroundBlur && _depthOfFieldForegroundBlurHQ)
					{
						BlurThisAlpha(renderTexture5, 16f);
					}
					BlurThisDoF(renderTexture5, pass);
					if (_depthOfFieldDebug)
					{
						source.MarkRestoreExpected();
						pass = ((_quality == BEAUTIFY_QUALITY.BestQuality) ? 13 : 7);
						Graphics.Blit(renderTexture5, destination, bMat, pass);
						RenderTexture.ReleaseTemporary(renderTexture5);
						return;
					}
					bMat.SetTexture("_DoFTex", renderTexture5);
				}
			}
			bool flag3 = _sunFlares && _sun != null;
			if (flag && (_lensDirt || _bloom || _anamorphicFlares || flag3))
			{
				RenderTexture renderTexture7 = null;
				int num3;
				int num4;
				if (_quality == BEAUTIFY_QUALITY.BestPerformance)
				{
					num3 = 4;
					num4 = 256;
				}
				else
				{
					num3 = 5;
					num4 = (_bloomUltra ? ((int)Mathf.Lerp(512f, source.height, (float)_bloomUltraResolution / 10f) / 4 * 4) : 512);
				}
				if (rt == null || rt.Length != num3 + 1)
				{
					rt = new RenderTexture[num3 + 1];
				}
				if (rtAF == null || rtAF.Length != num3 + 1)
				{
					rtAF = new RenderTexture[num3 + 1];
				}
				if (_bloom || (_lensDirt && !_anamorphicFlares))
				{
					UpdateMaterialBloomIntensityAndThreshold();
					RenderTextureDescriptor desc4 = rtDescBase;
					for (int i = 0; i <= num3; i++)
					{
						desc4.width = num4;
						desc4.height = Mathf.Max(1, (int)((float)num4 * num));
						rt[i] = RenderTexture.GetTemporary(desc4);
						num4 /= 2;
					}
					renderTexture7 = rt[0];
					if (_quality == BEAUTIFY_QUALITY.BestQuality && _bloomAntiflicker)
					{
						Graphics.Blit(source, rt[0], bMat, 9);
					}
					else
					{
						Graphics.Blit(source, rt[0], bMat, 2);
					}
					BlurThis(rt[0]);
					for (int j = 0; j < num3; j++)
					{
						if (_quality == BEAUTIFY_QUALITY.BestPerformance)
						{
							if (_bloomBlur)
							{
								BlurThisDownscaling(rt[j], rt[j + 1]);
							}
							else
							{
								Graphics.Blit(rt[j], rt[j + 1], bMat, 18);
							}
						}
						else if (_bloomQuickerBlur)
						{
							BlurThisDownscaling(rt[j], rt[j + 1]);
						}
						else
						{
							Graphics.Blit(rt[j], rt[j + 1], bMat, 7);
							BlurThis(rt[j + 1]);
						}
					}
					if (_bloom)
					{
						for (int num5 = num3; num5 > 0; num5--)
						{
							rt[num5 - 1].MarkRestoreExpected();
							Graphics.Blit(rt[num5], rt[num5 - 1], bMat, (_quality == BEAUTIFY_QUALITY.BestQuality) ? 8 : 13);
						}
						if (quality == BEAUTIFY_QUALITY.BestQuality && _bloomCustomize)
						{
							bMat.SetTexture("_BloomTex4", rt[4]);
							bMat.SetTexture("_BloomTex3", rt[3]);
							bMat.SetTexture("_BloomTex2", rt[2]);
							bMat.SetTexture("_BloomTex1", rt[1]);
							bMat.SetTexture("_BloomTex", rt[0]);
							renderTexture3 = RenderTexture.GetTemporary(rt[0].descriptor);
							renderTexture7 = renderTexture3;
							Graphics.Blit(rt[num3], renderTexture7, bMat, 6);
						}
					}
				}
				if (_anamorphicFlares)
				{
					UpdateMaterialAnamorphicIntensityAndThreshold();
					int num6 = ((_quality == BEAUTIFY_QUALITY.BestPerformance) ? 256 : ((!_anamorphicFlaresUltra) ? 512 : ((int)Mathf.Lerp(512f, source.height, _anamorphicUltraResolution / 10))));
					RenderTextureDescriptor desc5 = rtDescBase;
					int num7 = num6;
					for (int k = 0; k <= num3; k++)
					{
						if (_anamorphicFlaresVertical)
						{
							desc5.width = num7;
							desc5.height = Mathf.Max(1, (int)((float)num6 * num / _anamorphicFlaresSpread));
							rtAF[k] = RenderTexture.GetTemporary(desc5);
						}
						else
						{
							desc5.width = Mathf.Max(1, (int)((float)num6 * num / _anamorphicFlaresSpread));
							desc5.height = num7;
							rtAF[k] = RenderTexture.GetTemporary(desc5);
						}
						num6 /= 2;
					}
					if (_anamorphicFlaresAntiflicker && _quality == BEAUTIFY_QUALITY.BestQuality)
					{
						Graphics.Blit(source, rtAF[0], bMat, 9);
					}
					else
					{
						Graphics.Blit(source, rtAF[0], bMat, 2);
					}
					rtAF[0] = BlurThisOneDirection(rtAF[0], _anamorphicFlaresVertical);
					for (int l = 0; l < num3; l++)
					{
						if (_quality == BEAUTIFY_QUALITY.BestPerformance)
						{
							Graphics.Blit(rtAF[l], rtAF[l + 1], bMat, 18);
							if (_anamorphicFlaresBlur)
							{
								rtAF[l + 1] = BlurThisOneDirection(rtAF[l + 1], _anamorphicFlaresVertical);
							}
						}
						else
						{
							Graphics.Blit(rtAF[l], rtAF[l + 1], bMat, 7);
							rtAF[l + 1] = BlurThisOneDirection(rtAF[l + 1], _anamorphicFlaresVertical);
						}
					}
					for (int num8 = num3; num8 > 0; num8--)
					{
						rtAF[num8 - 1].MarkRestoreExpected();
						if (num8 == 1)
						{
							Graphics.Blit(rtAF[num8], rtAF[num8 - 1], bMat, (_quality == BEAUTIFY_QUALITY.BestQuality) ? 10 : 14);
						}
						else
						{
							Graphics.Blit(rtAF[num8], rtAF[num8 - 1], bMat, (_quality == BEAUTIFY_QUALITY.BestQuality) ? 8 : 13);
						}
					}
					if (_bloom)
					{
						if (_lensDirt)
						{
							rt[3].MarkRestoreExpected();
							Graphics.Blit(rtAF[3], rt[3], bMat, (_quality == BEAUTIFY_QUALITY.BestQuality) ? 11 : 13);
						}
						renderTexture7.MarkRestoreExpected();
						Graphics.Blit(rtAF[0], renderTexture7, bMat, (_quality == BEAUTIFY_QUALITY.BestQuality) ? 11 : 13);
					}
					else
					{
						renderTexture7 = rtAF[0];
					}
					UpdateMaterialBloomIntensityAndThreshold();
				}
				if (flag3)
				{
					Vector3 vector = currentCamera.transform.position - _sun.transform.forward * 1000f;
					Vector3 vector2 = currentCamera.WorldToViewportPoint(vector, (!XRSettings.enabled) ? Camera.MonoOrStereoscopicEye.Mono : Camera.MonoOrStereoscopicEye.Left);
					float num9 = 0f;
					if (vector2.z > 0f && vector2.x >= -0.1f && vector2.x < 1.1f && vector2.y >= -0.1f && vector2.y < 1.1f && !Physics.Raycast(new Ray(currentCamera.transform.position, (vector - currentCamera.transform.position).normalized), currentCamera.farClipPlane, _sunFlaresLayerMask))
					{
						Vector2 vector3 = vector2 - Vector3.one * 0.5f;
						num9 = _sunFlaresIntensity * Mathf.Clamp01((0.6f - Mathf.Max(Mathf.Abs(vector3.x), Mathf.Abs(vector3.y))) / 0.6f);
					}
					sunFlareCurrentIntensity = Mathf.Lerp(sunFlareCurrentIntensity, num9, Application.isPlaying ? 0.5f : 1f);
					if (sunFlareCurrentIntensity > 0f)
					{
						if (num9 > 0f)
						{
							sunLastScrPos = vector2;
						}
						bMat.SetColor("_SunTint", _sunFlaresTint * sunFlareCurrentIntensity);
						sunLastScrPos.z = 0.5f + sunFlareTime * _sunFlaresSolarWindSpeed;
						Vector2 vector4 = new Vector2(0.5f - sunLastScrPos.y, sunLastScrPos.x - 0.5f);
						if (!_sunFlaresRotationDeadZone || vector4.sqrMagnitude > 0.00025f)
						{
							sunLastRot = Mathf.Atan2(vector4.x, vector4.y);
						}
						sunLastScrPos.w = sunLastRot;
						sunFlareTime += Time.deltaTime;
						bMat.SetVector("_SunPos", sunLastScrPos);
						if (XRSettings.enabled)
						{
							Vector3 vector5 = currentCamera.WorldToViewportPoint(vector, Camera.MonoOrStereoscopicEye.Right);
							bMat.SetVector("_SunPosRightEye", vector5);
						}
						RenderTextureDescriptor desc6 = rtDescBase;
						desc6.width /= _sunFlaresDownsampling;
						desc6.height /= _sunFlaresDownsampling;
						renderTexture6 = RenderTexture.GetTemporary(desc6);
						Graphics.Blit(pass: (_quality != 0) ? ((renderTexture7 != null) ? 17 : 16) : ((renderTexture7 != null) ? 21 : 20), source: (renderTexture7 != null) ? renderTexture7 : source, dest: renderTexture6, mat: bMat);
						if (_lensDirt && _bloom)
						{
							rt[3].MarkRestoreExpected();
							Graphics.Blit(renderTexture6, rt[3], bMat, (_quality == BEAUTIFY_QUALITY.BestQuality) ? 11 : 13);
						}
						renderTexture7 = renderTexture6;
						if (!_bloom && !_anamorphicFlares)
						{
							bMat.SetVector("_Bloom", Vector4.one);
							if (!bMat.IsKeywordEnabled("BEAUTIFY_BLOOM"))
							{
								bMat.EnableKeyword("BEAUTIFY_BLOOM");
							}
						}
					}
				}
				if (renderTexture7 != null)
				{
					bMat.SetTexture("_BloomTex", renderTexture7);
				}
				else
				{
					if (bMat.IsKeywordEnabled("BEAUTIFY_BLOOM"))
					{
						bMat.DisableKeyword("BEAUTIFY_BLOOM");
					}
					bMat.SetVector("_Bloom", Vector4.zero);
				}
				if (_lensDirt)
				{
					bMat.SetTexture("_ScreenLum", (_anamorphicFlares && !_bloom) ? rtAF[3] : rt[3]);
				}
			}
			if (_lensDirt)
			{
				Vector4 value = new Vector4(1f, 1f / (1.01f - _lensDirtIntensity), _lensDirtThreshold, Mathf.Max(_bloomIntensity, 1f));
				bMat.SetVector("_Dirt", value);
			}
			if (Application.isPlaying && flag && (_eyeAdaptation || _purkinje))
			{
				int num10 = ((_quality == BEAUTIFY_QUALITY.BestQuality) ? 9 : 8);
				int num11 = (int)Mathf.Pow(2f, num10);
				if (rtEA == null || rtEA.Length < num10)
				{
					rtEA = new RenderTexture[num10];
				}
				RenderTextureDescriptor desc7 = rtDescBase;
				for (int m = 0; m < num10; m++)
				{
					desc7.width = num11;
					desc7.height = num11;
					rtEA[m] = RenderTexture.GetTemporary(desc7);
					num11 /= 2;
				}
				Graphics.Blit(source, rtEA[0], bMat, (_quality == BEAUTIFY_QUALITY.BestQuality) ? 22 : 18);
				int num12 = num10 - 1;
				int num13 = ((_quality == BEAUTIFY_QUALITY.BestQuality) ? 15 : 9);
				for (int n = 0; n < num12; n++)
				{
					Graphics.Blit(rtEA[n], rtEA[n + 1], bMat, (n == 0) ? num13 : (num13 + 1));
				}
				bMat.SetTexture("_EALumSrc", rtEA[num12]);
				if (rtEAacum == null)
				{
					int pass3 = ((_quality == BEAUTIFY_QUALITY.BestQuality) ? 22 : 18);
					RenderTextureDescriptor desc8 = rtDescBase;
					desc8.width = 2;
					desc8.height = 2;
					rtEAacum = new RenderTexture(desc8);
					Graphics.Blit(rtEA[num12], rtEAacum, bMat, pass3);
					rtEAHist = new RenderTexture(desc8);
					Graphics.Blit(rtEAacum, rtEAHist, bMat, pass3);
				}
				else
				{
					rtEAacum.MarkRestoreExpected();
					Graphics.Blit(rtEA[num12], rtEAacum, bMat, num13 + 2);
					Graphics.Blit(rtEAacum, rtEAHist, bMat, num13 + 3);
				}
				bMat.SetTexture("_EAHist", rtEAHist);
			}
			if (renderTexture != null)
			{
				Graphics.Blit(source, renderTexture, bMat, 1);
				bMat.SetTexture("_CompareTex", renderTexture);
			}
			if (renderTexture2 != null)
			{
				float blurScale = ((_blurIntensity > 1f) ? 1f : _blurIntensity);
				if (renderTexture != null)
				{
					Graphics.Blit(renderTexture, renderTexture2, bMat, renderPass);
					BlurThis(renderTexture2, blurScale);
				}
				else
				{
					BlurThisDownscaling(source, renderTexture2, blurScale);
				}
				BlurThis(renderTexture2, blurScale);
				if (_quality == BEAUTIFY_QUALITY.BestQuality)
				{
					BlurThis(renderTexture2, blurScale);
				}
				if (renderTexture != null)
				{
					bMat.SetTexture("_CompareTex", renderTexture2);
					Graphics.Blit(source, destination, bMat, renderPass);
				}
				else
				{
					Graphics.Blit(renderTexture2, destination, bMat, renderPass);
				}
				RenderTexture.ReleaseTemporary(renderTexture2);
			}
			else
			{
				Graphics.Blit(source, destination, bMat, renderPass);
			}
			if (rtEA != null)
			{
				for (int num14 = 0; num14 < rtEA.Length; num14++)
				{
					if (rtEA[num14] != null)
					{
						RenderTexture.ReleaseTemporary(rtEA[num14]);
						rtEA[num14] = null;
					}
				}
			}
			if (rt != null)
			{
				for (int num15 = 0; num15 < rt.Length; num15++)
				{
					if (rt[num15] != null)
					{
						RenderTexture.ReleaseTemporary(rt[num15]);
						rt[num15] = null;
					}
				}
			}
			if (rtAF != null)
			{
				for (int num16 = 0; num16 < rtAF.Length; num16++)
				{
					if (rtAF[num16] != null)
					{
						RenderTexture.ReleaseTemporary(rtAF[num16]);
						rtAF[num16] = null;
					}
				}
			}
			if (renderTexture3 != null)
			{
				RenderTexture.ReleaseTemporary(renderTexture3);
			}
			if (renderTexture5 != null)
			{
				RenderTexture.ReleaseTemporary(renderTexture5);
			}
			if (renderTexture != null)
			{
				RenderTexture.ReleaseTemporary(renderTexture);
			}
			if (renderTexture4 != null)
			{
				RenderTexture.ReleaseTemporary(renderTexture4);
			}
			if (renderTexture6 != null)
			{
				RenderTexture.ReleaseTemporary(renderTexture6);
			}
		}

		private void OnPostRender()
		{
			if (_downscale > 1 && pixelateTexture != null)
			{
				RenderTexture.active = null;
				currentCamera.targetTexture = null;
				Graphics.Blit((Texture)pixelateTexture, (RenderTexture)null);
			}
			else if (_pixelateDownscale && _pixelateAmount > 1 && pixelateTexture != null)
			{
				RenderTexture.active = null;
				currentCamera.targetTexture = null;
				pixelateTexture.filterMode = FilterMode.Point;
				Graphics.Blit((Texture)pixelateTexture, (RenderTexture)null);
			}
		}

		private void BlurThis(RenderTexture rt, float blurScale = 1f)
		{
			RenderTexture temporary = RenderTexture.GetTemporary(rt.descriptor);
			temporary.filterMode = FilterMode.Bilinear;
			bMat.SetFloat("_BlurScale", blurScale);
			Graphics.Blit(rt, temporary, bMat, 4);
			rt.DiscardContents();
			Graphics.Blit(temporary, rt, bMat, 5);
			RenderTexture.ReleaseTemporary(temporary);
		}

		private void BlurThisDownscaling(RenderTexture rt, RenderTexture downscaled, float blurScale = 1f)
		{
			RenderTextureDescriptor descriptor = rt.descriptor;
			descriptor.width = downscaled.width;
			descriptor.height = downscaled.height;
			RenderTexture temporary = RenderTexture.GetTemporary(descriptor);
			temporary.filterMode = FilterMode.Bilinear;
			float num = rt.width / descriptor.width;
			bMat.SetFloat("_BlurScale", blurScale * num);
			Graphics.Blit(rt, temporary, bMat, 4);
			bMat.SetFloat("_BlurScale", blurScale);
			downscaled.DiscardContents();
			Graphics.Blit(temporary, downscaled, bMat, 5);
			RenderTexture.ReleaseTemporary(temporary);
		}

		private RenderTexture BlurThisOneDirection(RenderTexture rt, bool vertical, float blurScale = 1f)
		{
			RenderTexture temporary = RenderTexture.GetTemporary(rt.descriptor);
			temporary.filterMode = FilterMode.Bilinear;
			bMat.SetFloat("_BlurScale", blurScale);
			Graphics.Blit(rt, temporary, bMat, vertical ? 5 : 4);
			RenderTexture.ReleaseTemporary(rt);
			return temporary;
		}

		private void BlurThisDoF(RenderTexture rt, int renderPass)
		{
			RenderTextureDescriptor descriptor = rt.descriptor;
			RenderTexture temporary = RenderTexture.GetTemporary(descriptor);
			RenderTexture temporary2 = RenderTexture.GetTemporary(descriptor);
			temporary.filterMode = _depthOfFieldFilterMode;
			temporary2.filterMode = _depthOfFieldFilterMode;
			UpdateDepthOfFieldBlurData(new Vector2(0.44721f, -0.89443f));
			Graphics.Blit(rt, temporary, bMat, renderPass);
			UpdateDepthOfFieldBlurData(new Vector2(-1f, 0f));
			Graphics.Blit(temporary, temporary2, bMat, renderPass);
			UpdateDepthOfFieldBlurData(new Vector2(0.44721f, 0.89443f));
			rt.DiscardContents();
			Graphics.Blit(temporary2, rt, bMat, renderPass);
			RenderTexture.ReleaseTemporary(temporary2);
			RenderTexture.ReleaseTemporary(temporary);
		}

		private void BlurThisAlpha(RenderTexture rt, float blurScale = 1f)
		{
			RenderTexture temporary = RenderTexture.GetTemporary(rt.descriptor);
			temporary.filterMode = FilterMode.Bilinear;
			bMat.SetFloat("_BlurScale", blurScale);
			Graphics.Blit(rt, temporary, bMat, 23);
			rt.DiscardContents();
			Graphics.Blit(temporary, rt, bMat, 24);
			RenderTexture.ReleaseTemporary(temporary);
		}

		private void OnDidApplyAnimationProperties()
		{
			shouldUpdateMaterialProperties = true;
		}

		public void UpdateQualitySettings()
		{
			switch (_quality)
			{
			case BEAUTIFY_QUALITY.BestPerformance:
				_depthOfFieldDownsampling = 2;
				_depthOfFieldMaxSamples = 4;
				_sunFlaresDownsampling = 2;
				break;
			case BEAUTIFY_QUALITY.BestQuality:
				_depthOfFieldDownsampling = 1;
				_depthOfFieldMaxSamples = 8;
				_sunFlaresDownsampling = 1;
				break;
			}
			isDirty = true;
		}

		public void UpdateMaterialProperties()
		{
			if (Application.isPlaying)
			{
				shouldUpdateMaterialProperties = true;
			}
			else
			{
				UpdateMaterialPropertiesNow();
			}
		}

		public void UpdateMaterialPropertiesNow()
		{
			shouldUpdateMaterialProperties = false;
			if (currentCamera != null && currentCamera.depthTextureMode == DepthTextureMode.None && _quality != BEAUTIFY_QUALITY.Basic)
			{
				currentCamera.depthTextureMode = DepthTextureMode.Depth;
			}
			string graphicsDeviceName = SystemInfo.graphicsDeviceName;
			if (graphicsDeviceName != null && graphicsDeviceName.ToUpper().Contains("MALI-T720"))
			{
				rtFormat = RenderTextureFormat.Default;
				_bloomBlur = false;
				_anamorphicFlaresBlur = false;
			}
			else
			{
				rtFormat = (SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.ARGBHalf) ? RenderTextureFormat.ARGBHalf : RenderTextureFormat.ARGB32);
			}
			switch (_quality)
			{
			case BEAUTIFY_QUALITY.BestQuality:
				if (bMatDesktop == null)
				{
					bMatDesktop = new Material(Shader.Find("Beautify/Beautify"));
					bMatDesktop.hideFlags = HideFlags.DontSave;
				}
				bMat = bMatDesktop;
				break;
			case BEAUTIFY_QUALITY.BestPerformance:
				if (bMatMobile == null)
				{
					bMatMobile = new Material(Shader.Find("Beautify/BeautifyMobile"));
					bMatMobile.hideFlags = HideFlags.DontSave;
				}
				bMat = bMatMobile;
				break;
			case BEAUTIFY_QUALITY.Basic:
				if (bMatBasic == null)
				{
					bMatBasic = new Material(Shader.Find("Beautify/BeautifyBasic"));
					bMatBasic.hideFlags = HideFlags.DontSave;
				}
				bMat = bMatBasic;
				break;
			}
			bool flag = QualitySettings.activeColorSpace == ColorSpace.Linear;
			switch (_preset)
			{
			case BEAUTIFY_PRESET.Soft:
				_sharpen = 2f;
				if (flag)
				{
					_sharpen *= 2f;
				}
				_sharpenDepthThreshold = 0.035f;
				_sharpenRelaxation = 0.065f;
				_sharpenClamp = 0.4f;
				_saturate = 0.5f;
				_contrast = 1.005f;
				_brightness = 1.05f;
				_dither = 0.02f;
				_ditherDepth = 0f;
				_daltonize = 0f;
				break;
			case BEAUTIFY_PRESET.Medium:
				_sharpen = 3f;
				if (flag)
				{
					_sharpen *= 2f;
				}
				_sharpenDepthThreshold = 0.035f;
				_sharpenRelaxation = 0.07f;
				_sharpenClamp = 0.45f;
				_saturate = 1f;
				_contrast = 1.02f;
				_brightness = 1.05f;
				_dither = 0.02f;
				_ditherDepth = 0f;
				_daltonize = 0f;
				break;
			case BEAUTIFY_PRESET.Strong:
				_sharpen = 4.75f;
				if (flag)
				{
					_sharpen *= 2f;
				}
				_sharpenDepthThreshold = 0.035f;
				_sharpenRelaxation = 0.075f;
				_sharpenClamp = 0.5f;
				_saturate = 1.5f;
				_contrast = 1.03f;
				_brightness = 1.05f;
				_dither = 0.022f;
				_ditherDepth = 0f;
				_daltonize = 0f;
				break;
			case BEAUTIFY_PRESET.Exaggerated:
				_sharpen = 6f;
				if (flag)
				{
					_sharpen *= 2f;
				}
				_sharpenDepthThreshold = 0.035f;
				_sharpenRelaxation = 0.08f;
				_sharpenClamp = 0.55f;
				_saturate = 2.25f;
				_contrast = 1.035f;
				_brightness = 1.05f;
				_dither = 0.025f;
				_ditherDepth = 0f;
				_daltonize = 0f;
				break;
			}
			isDirty = true;
			if (bMat == null)
			{
				return;
			}
			renderPass = 1;
			if (_pixelateAmount > 1)
			{
				if (QualitySettings.antiAliasing > 1)
				{
					QualitySettings.antiAliasing = 1;
				}
				if (_pixelateDownscale)
				{
					_dither = 0f;
				}
			}
			UpdateSharpenParams(_sharpen);
			bool flag2 = currentCamera != null && currentCamera.orthographic;
			bMat.SetVector("_Dither", new Vector4(_dither, flag2 ? 0f : _ditherDepth, (_sharpenMaxDepth + _sharpenMinDepth) * 0.5f, Mathf.Abs(_sharpenMaxDepth - _sharpenMinDepth) * 0.5f + (flag2 ? 1000f : 0f)));
			bMat.SetFloat("_SharpenDepthFallOff", _sharpenMinMaxDepthFallOff);
			bMat.SetVector("_AntialiasData", new Vector3(_antialiasStrength, _antialiasDepthThreshold, 0f));
			float y = (flag ? (1f + (_contrast - 1f) / 2.2f) : _contrast);
			bMat.SetVector("_ColorBoost", new Vector4(_brightness, y, _saturate, _daltonize * 10f));
			Color value = _vignettingColor;
			value.a *= (_vignetting ? 32f : 0f);
			float num = 1f - _vignettingBlink * 2f;
			if (num < 0f)
			{
				num = 0f;
			}
			value.r *= num;
			value.g *= num;
			value.b *= num;
			bMat.SetColor("_Vignetting", value);
			if (currentCamera != null)
			{
				bMat.SetFloat("_VignettingAspectRatio", (_vignettingCircularShape && _vignettingBlink <= 0f) ? (1f / currentCamera.aspect) : (_vignettingAspectRatio + 1.001f / (1.001f - _vignettingBlink) - 1f));
			}
			if (_frame)
			{
				Vector4 value2 = new Vector4(_frameColor.r, _frameColor.g, _frameColor.b, (1.00001f - _frameColor.a) * 0.5f);
				bMat.SetVector("_Frame", value2);
			}
			bMat.SetColor("_Outline", _outlineColor);
			float num2 = 1E-05f + _bloomWeight0 + _bloomWeight1 + _bloomWeight2 + _bloomWeight3 + _bloomWeight4 + _bloomWeight5;
			bMat.SetVector("_BloomWeights", new Vector4(_bloomWeight0 / num2 + _bloomBoost0, _bloomWeight1 / num2 + _bloomBoost1, _bloomWeight2 / num2 + _bloomBoost2, _bloomWeight3 / num2 + _bloomBoost3));
			bMat.SetVector("_BloomWeights2", new Vector4(_bloomWeight4 / num2 + _bloomBoost4, _bloomWeight5 / num2 + _bloomBoost5, _bloomMaxBrightness, num2));
			if (_bloomDebug && (_bloom || _anamorphicFlares || _sunFlares))
			{
				renderPass = 3;
			}
			bloomCurrentLayerMaskValue = _bloomCullingMask.value;
			if (_sunFlares)
			{
				bMat.SetVector("_SunData", new Vector4(_sunFlaresSunIntensity, _sunFlaresSunDiskSize, _sunFlaresSunRayDiffractionIntensity, _sunFlaresSunRayDiffractionThreshold));
				bMat.SetVector("_SunCoronaRays1", new Vector4(_sunFlaresCoronaRays1Length, Mathf.Max((float)_sunFlaresCoronaRays1Streaks / 2f, 1f), Mathf.Max(_sunFlaresCoronaRays1Spread, 0.0001f), _sunFlaresCoronaRays1AngleOffset));
				bMat.SetVector("_SunCoronaRays2", new Vector4(_sunFlaresCoronaRays2Length, Mathf.Max((float)_sunFlaresCoronaRays2Streaks / 2f, 1f), Mathf.Max(_sunFlaresCoronaRays2Spread + 0.0001f), _sunFlaresCoronaRays2AngleOffset));
				bMat.SetVector("_SunGhosts1", new Vector4(0f, _sunFlaresGhosts1Size, _sunFlaresGhosts1Offset, _sunFlaresGhosts1Brightness));
				bMat.SetVector("_SunGhosts2", new Vector4(0f, _sunFlaresGhosts2Size, _sunFlaresGhosts2Offset, _sunFlaresGhosts2Brightness));
				bMat.SetVector("_SunGhosts3", new Vector4(0f, _sunFlaresGhosts3Size, _sunFlaresGhosts3Offset, _sunFlaresGhosts3Brightness));
				bMat.SetVector("_SunGhosts4", new Vector4(0f, _sunFlaresGhosts4Size, _sunFlaresGhosts4Offset, _sunFlaresGhosts4Brightness));
				bMat.SetVector("_SunHalo", new Vector3(_sunFlaresHaloOffset, _sunFlaresHaloAmplitude, _sunFlaresHaloIntensity * 100f));
			}
			if (_lensDirtTexture == null)
			{
				_lensDirtTexture = Resources.Load<Texture2D>("Textures/dirt2");
			}
			bMat.SetTexture("_OverlayTex", _lensDirtTexture);
			bMat.SetColor("_AFTint", _anamorphicFlaresTint);
			if (_depthOfField && (int)_depthOfFieldAutofocusLayerMask != 0)
			{
				Shader.SetGlobalFloat("_BeautifyDepthBias", _depthOfFieldExclusionBias);
			}
			dofCurrentLayerMaskValue = _depthOfFieldExclusionLayerMask.value;
			if (_compareMode)
			{
				renderPass = 0;
				bMat.SetVector("_CompareParams", new Vector4(Mathf.Cos(_compareLineAngle), Mathf.Sin(_compareLineAngle), 0f - Mathf.Cos(_compareLineAngle), _compareLineWidth));
			}
			if (shaderKeywords == null)
			{
				shaderKeywords = new List<string>();
			}
			else
			{
				shaderKeywords.Clear();
			}
			if (_quality != BEAUTIFY_QUALITY.Basic)
			{
				if (_lut && _lutTexture != null)
				{
					shaderKeywords.Add("BEAUTIFY_LUT");
					bMat.SetTexture("_LUTTex", _lutTexture);
					bMat.SetColor("_FXColor", new Color(0f, 0f, 0f, _lutIntensity));
				}
				else if (_nightVision)
				{
					shaderKeywords.Add("BEAUTIFY_NIGHT_VISION");
					Color value3 = _nightVisionColor;
					if (flag)
					{
						value3.a *= 5f * value3.a;
					}
					else
					{
						value3.a *= 3f * value3.a;
					}
					value3.r *= value3.a;
					value3.g *= value3.a;
					value3.b *= value3.a;
					bMat.SetColor("_FXColor", value3);
				}
				else if (_thermalVision)
				{
					shaderKeywords.Add("BEAUTIFY_THERMAL_VISION");
				}
				else if (_daltonize > 0f)
				{
					shaderKeywords.Add("BEAUTIFY_DALTONIZE");
				}
				else
				{
					bMat.SetColor("_FXColor", new Color(0f, 0f, 0f, _lutIntensity));
				}
				bMat.SetColor("_TintColor", _tintColor);
				if (_sunFlares)
				{
					if (flareNoise == null)
					{
						flareNoise = Resources.Load<Texture2D>("Textures/flareNoise");
					}
					flareNoise.wrapMode = TextureWrapMode.Repeat;
					bMat.SetTexture("_FlareTex", flareNoise);
					if (_sun == null)
					{
						Light[] array = UnityEngine.Object.FindObjectsOfType<Light>();
						foreach (Light light in array)
						{
							if (light.type == LightType.Directional && light.enabled && light.gameObject.activeSelf)
							{
								_sun = light.transform;
								break;
							}
						}
					}
				}
				if (_vignetting)
				{
					if (_vignettingMask != null)
					{
						bMat.SetTexture("_VignettingMask", _vignettingMask);
						shaderKeywords.Add("BEAUTIFY_VIGNETTING_MASK");
					}
					else
					{
						shaderKeywords.Add("BEAUTIFY_VIGNETTING");
					}
				}
				if (_frame)
				{
					if (_frameMask != null)
					{
						bMat.SetTexture("_FrameMask", _frameMask);
						shaderKeywords.Add("BEAUTIFY_FRAME_MASK");
					}
					else
					{
						shaderKeywords.Add("BEAUTIFY_FRAME");
					}
				}
				if (_outline)
				{
					shaderKeywords.Add("BEAUTIFY_OUTLINE");
				}
				if (_lensDirt)
				{
					shaderKeywords.Add("BEAUTIFY_DIRT");
				}
				if (_bloom || _anamorphicFlares || _sunFlares)
				{
					shaderKeywords.Add("BEAUTIFY_BLOOM");
					if (_bloomDepthAtten > 0f)
					{
						bMat.SetFloat("_BloomDepthTreshold", _bloomDepthAtten);
						shaderKeywords.Add("BEAUTIFY_BLOOM_USE_DEPTH");
					}
					if ((_bloom || _anamorphicFlares) && (int)_bloomCullingMask > 0)
					{
						bMat.SetFloat("_BloomLayerZBias", _bloomLayerZBias);
						shaderKeywords.Add("BEAUTIFY_BLOOM_USE_LAYER");
					}
				}
				if (_depthOfField)
				{
					if (_depthOfFieldTransparencySupport || (int)_depthOfFieldExclusionLayerMask != 0)
					{
						shaderKeywords.Add("BEAUTIFY_DEPTH_OF_FIELD_TRANSPARENT");
					}
					else
					{
						shaderKeywords.Add("BEAUTIFY_DEPTH_OF_FIELD");
					}
				}
				if (_eyeAdaptation)
				{
					Vector4 value4 = new Vector4(_eyeAdaptationMinExposure, _eyeAdaptationMaxExposure, _eyeAdaptationSpeedToDark, _eyeAdaptationSpeedToLight);
					bMat.SetVector("_EyeAdaptation", value4);
					shaderKeywords.Add("BEAUTIFY_EYE_ADAPTATION");
				}
				if (_quality == BEAUTIFY_QUALITY.BestQuality && _tonemap == BEAUTIFY_TMO.ACES)
				{
					shaderKeywords.Add("BEAUTIFY_TONEMAP_ACES");
				}
				if (_purkinje || _vignetting)
				{
					float z = _vignettingFade + _vignettingBlink * 0.5f;
					if (_vignettingBlink > 0.99f)
					{
						z = 1f;
					}
					Vector3 vector = new Vector3(_purkinjeAmount, _purkinjeLuminanceThreshold, z);
					bMat.SetVector("_Purkinje", vector);
					shaderKeywords.Add("BEAUTIFY_PURKINJE");
				}
			}
			bMat.shaderKeywords = shaderKeywords.ToArray();
		}

		private void UpdateMaterialBloomIntensityAndThreshold()
		{
			float num = _bloomThreshold;
			if (QualitySettings.activeColorSpace == ColorSpace.Linear)
			{
				num *= num;
			}
			bMat.SetVector("_Bloom", new Vector4(_bloomIntensity + (_anamorphicFlares ? 0.0001f : 0f), 0f, 0f, num));
		}

		private void UpdateMaterialAnamorphicIntensityAndThreshold()
		{
			float num = _anamorphicFlaresThreshold;
			if (QualitySettings.activeColorSpace == ColorSpace.Linear)
			{
				num *= num;
			}
			float x = _anamorphicFlaresIntensity / (_bloomIntensity + 0.0001f);
			bMat.SetVector("_Bloom", new Vector4(x, 0f, 0f, num));
		}

		private void UpdateSharpenParams(float sharpen)
		{
			bMat.SetVector("_Sharpen", new Vector4(sharpen, _sharpenDepthThreshold, _sharpenClamp, _sharpenRelaxation));
		}

		private void UpdateDepthOfFieldData()
		{
			float num;
			if (!_depthOfFieldAutofocus)
			{
				num = ((!(_depthOfFieldTargetFocus != null)) ? _depthOfFieldDistance : ((!(currentCamera.WorldToScreenPoint(_depthOfFieldTargetFocus.position).z < 0f)) ? Vector3.Distance(currentCamera.transform.position, _depthOfFieldTargetFocus.position) : currentCamera.farClipPlane));
			}
			else
			{
				UpdateDoFAutofocusDistance();
				num = ((dofLastAutofocusDistance > 0f) ? dofLastAutofocusDistance : currentCamera.farClipPlane);
			}
			if (OnBeforeFocus != null)
			{
				num = OnBeforeFocus(num);
			}
			dofPrevDistance = Mathf.Lerp(dofPrevDistance, num, Application.isPlaying ? (_depthOfFieldFocusSpeed * Time.deltaTime * 30f) : 1f);
			float y = _depthOfFieldAperture * (_depthOfFieldFocalLength / Mathf.Max(dofPrevDistance - _depthOfFieldFocalLength, 0.001f)) * 41.666668f;
			dofLastBokehData = new Vector4(dofPrevDistance, y, 0f, 0f);
			bMat.SetVector("_BokehData", dofLastBokehData);
			bMat.SetVector("_BokehData2", new Vector4(_depthOfFieldForegroundBlur ? _depthOfFieldForegroundDistance : currentCamera.farClipPlane, _depthOfFieldMaxSamples, _depthOfFieldBokehThreshold, _depthOfFieldBokehIntensity * _depthOfFieldBokehIntensity));
			bMat.SetVector("_BokehData3", new Vector3(_depthOfFieldMaxBrightness, _depthOfFieldMaxDistance * (currentCamera.farClipPlane + 1f), 0f));
		}

		private void UpdateDepthOfFieldBlurData(Vector2 blurDir)
		{
			float num = 1f / (float)_depthOfFieldDownsampling;
			blurDir *= num;
			dofLastBokehData.z = blurDir.x;
			dofLastBokehData.w = blurDir.y;
			bMat.SetVector("_BokehData", dofLastBokehData);
		}

		private void UpdateDoFAutofocusDistance()
		{
			Vector3 pos = _depthofFieldAutofocusViewportPoint;
			pos.z = 10f;
			if (Physics.Raycast(currentCamera.ViewportPointToRay(pos), out var hitInfo, currentCamera.farClipPlane, _depthOfFieldAutofocusLayerMask))
			{
				dofLastAutofocusDistance = Mathf.Clamp(hitInfo.distance, _depthOfFieldAutofocusMinDistance, _depthOfFieldAutofocusMaxDistance);
			}
			else
			{
				dofLastAutofocusDistance = currentCamera.farClipPlane;
			}
		}

		public void Blink(float duration, float maxValue = 1f)
		{
			if (!(duration <= 0f))
			{
				StartCoroutine(DoBlink(duration, maxValue));
			}
		}

		private IEnumerator DoBlink(float duration, float maxValue)
		{
			float start2 = Time.time;
			WaitForEndOfFrame w = new WaitForEndOfFrame();
			float t2;
			do
			{
				t2 = (Time.time - start2) / duration;
				if (t2 > 1f)
				{
					t2 = 1f;
				}
				float num = t2 * (2f - t2);
				vignettingBlink = num * maxValue;
				yield return w;
			}
			while (t2 < 1f);
			start2 = Time.time;
			do
			{
				t2 = (Time.time - start2) / duration;
				if (t2 > 1f)
				{
					t2 = 1f;
				}
				float num2 = t2 * t2;
				vignettingBlink = (1f - num2) * maxValue;
				yield return w;
			}
			while (t2 < 1f);
		}
	}
	[CreateAssetMenu(fileName = "BeautifyProfile", menuName = "Beautify Profile", order = 101)]
	public class BeautifyProfile : ScriptableObject
	{
		[Range(0f, 0.2f)]
		public float dither = 0.02f;

		[Range(0f, 1f)]
		public float ditherDepth;

		[Range(0f, 1f)]
		public float sharpenMinDepth;

		[Range(0f, 1.1f)]
		public float sharpenMaxDepth = 0.999f;

		[Range(0f, 15f)]
		public float sharpen = 2f;

		[Range(0f, 1f)]
		public float sharpenMinMaxDepthFallOff;

		[Range(0f, 0.05f)]
		public float sharpenDepthThreshold = 0.035f;

		public Color tintColor = new Color(1f, 1f, 1f, 0f);

		[Range(0f, 0.2f)]
		public float sharpenRelaxation = 0.08f;

		[Range(0f, 1f)]
		public float sharpenClamp = 0.45f;

		[Range(0f, 1f)]
		public float sharpenMotionSensibility = 0.5f;

		[Range(0f, 20f)]
		public float antialiasStrength = 5f;

		[Range(0f, 0.05f)]
		public float antialiasDepthThreshold = 0.001f;

		[Range(1f, 8f)]
		public int downscale = 1;

		[Range(-2f, 3f)]
		public float saturate = 1f;

		[Range(0.5f, 1.5f)]
		public float contrast = 1.02f;

		[Range(0f, 2f)]
		public float brightness = 1.05f;

		[Range(0f, 2f)]
		public float daltonize;

		public bool vignetting;

		public Color vignettingColor = new Color(0.3f, 0.3f, 0.3f, 0.05f);

		public float vignettingFade;

		public bool vignettingCircularShape;

		public float vignettingAspectRatio = 1f;

		[Range(0f, 1f)]
		public float vignettingBlink;

		public Texture2D vignettingMask;

		public bool frame;

		public Color frameColor = new Color(1f, 1f, 1f, 0.047f);

		public Texture2D frameMask;

		public bool lut;

		[Range(0f, 1f)]
		public float lutIntensity = 1f;

		public Texture2D lutTexture;

		public bool nightVision;

		public Color nightVisionColor = new Color(0.5f, 1f, 0.5f, 0.5f);

		public bool outline;

		public Color outlineColor = new Color(0f, 0f, 0f, 0.8f);

		public bool thermalVision;

		public bool lensDirt;

		[Range(0f, 1f)]
		public float lensDirtThreshold = 0.5f;

		[Range(0f, 1f)]
		public float lensDirtIntensity = 0.9f;

		public Texture2D lensDirtTexture;

		public bool bloom;

		public LayerMask bloomCullingMask = 0;

		[Range(1f, 4f)]
		public float bloomLayerMaskDownsampling = 1f;

		[Range(0f, 10f)]
		public float bloomIntensity = 1f;

		public float bloomMaxBrightness = 1000f;

		[Range(0f, 3f)]
		public float bloomBoost0;

		[Range(0f, 3f)]
		public float bloomBoost1;

		[Range(0f, 3f)]
		public float bloomBoost2;

		[Range(0f, 3f)]
		public float bloomBoost3;

		[Range(0f, 3f)]
		public float bloomBoost4;

		[Range(0f, 3f)]
		public float bloomBoost5;

		public bool bloomAntiflicker;

		public bool bloomUltra;

		[Range(1f, 10f)]
		public int bloomUltraResolution = 10;

		[Range(0f, 5f)]
		public float bloomThreshold = 0.75f;

		public bool bloomCustomize;

		[Range(0f, 1f)]
		public float bloomWeight0 = 0.5f;

		[Range(0f, 1f)]
		public float bloomWeight1 = 0.5f;

		[Range(0f, 1f)]
		public float bloomWeight2 = 0.5f;

		[Range(0f, 1f)]
		public float bloomWeight3 = 0.5f;

		[Range(0f, 1f)]
		public float bloomWeight4 = 0.5f;

		[Range(0f, 1f)]
		public float bloomWeight5 = 0.5f;

		public bool bloomBlur = true;

		[Range(0f, 1f)]
		public float bloomDepthAtten;

		[Range(-1f, 1f)]
		public float bloomLayerZBias;

		public bool anamorphicFlares;

		[Range(0f, 10f)]
		public float anamorphicFlaresIntensity = 1f;

		public bool anamorphicFlaresAntiflicker;

		public bool anamorphicFlaresUltra;

		[Range(1f, 10f)]
		public int anamorphicFlaresUltraResolution = 10;

		[Range(0f, 5f)]
		public float anamorphicFlaresThreshold = 0.75f;

		[Range(0.1f, 2f)]
		public float anamorphicFlaresSpread = 1f;

		public bool anamorphicFlaresVertical;

		public Color anamorphicFlaresTint = new Color(0.5f, 0.5f, 1f, 0f);

		public bool anamorphicFlaresBlur = true;

		public bool depthOfField;

		public bool depthOfFieldTransparencySupport;

		public Transform depthOfFieldTargetFocus;

		public bool depthOfFieldAutofocus;

		public Vector2 depthofFieldAutofocusViewportPoint = new Vector2(0.5f, 0.5f);

		public LayerMask depthOfFieldAutofocusLayerMask = -1;

		public float depthOfFieldAutofocusMinDistance;

		public float depthOfFieldAutofocusMaxDistance = 10000f;

		public LayerMask depthOfFieldExclusionLayerMask = 0;

		[Range(1f, 4f)]
		public float depthOfFieldExclusionLayerMaskDownsampling = 1f;

		[Range(1f, 4f)]
		public float depthOfFieldTransparencySupportDownsampling = 1f;

		[Range(0.9f, 1f)]
		public float depthOfFieldExclusionBias = 0.99f;

		[Range(1f, 100f)]
		public float depthOfFieldDistance = 1f;

		[Range(0.001f, 1f)]
		public float depthOfFieldFocusSpeed = 1f;

		[Range(1f, 5f)]
		public int depthOfFieldDownsampling = 2;

		[Range(2f, 16f)]
		public int depthOfFieldMaxSamples = 4;

		[Range(0.005f, 0.5f)]
		public float depthOfFieldFocalLength = 0.05f;

		public float depthOfFieldAperture = 2.8f;

		public bool depthOfFieldForegroundBlur = true;

		public bool depthOfFieldForegroundBlurHQ;

		public float depthOfFieldForegroundDistance = 0.25f;

		public bool depthOfFieldBokeh = true;

		[Range(0.5f, 3f)]
		public float depthOfFieldBokehThreshold = 1f;

		[Range(0f, 8f)]
		public float depthOfFieldBokehIntensity = 2f;

		public float depthOfFieldMaxBrightness = 1000f;

		public float depthOfFieldMaxDistance = 1f;

		public FilterMode depthOfFieldFilterMode = FilterMode.Bilinear;

		public LayerMask depthOfFieldTransparencyLayerMask = -1;

		public bool eyeAdaptation;

		[Range(0f, 1f)]
		public float eyeAdaptationMinExposure = 0.2f;

		[Range(1f, 100f)]
		public float eyeAdaptationMaxExposure = 5f;

		[Range(0f, 1f)]
		public float eyeAdaptationSpeedToLight = 1f;

		[Range(0f, 1f)]
		public float eyeAdaptationSpeedToDark = 0.7f;

		public bool purkinje;

		[Range(0f, 5f)]
		public float purkinjeAmount = 1f;

		[Range(0f, 1f)]
		public float purkinjeLuminanceThreshold = 0.15f;

		public BEAUTIFY_TMO tonemap;

		public bool sunFlares;

		[Range(0f, 1f)]
		public float sunFlaresIntensity = 1f;

		[Range(0f, 1f)]
		public float sunFlaresSolarWindSpeed = 0.01f;

		public Color sunFlaresTint = new Color(1f, 1f, 1f);

		[Range(1f, 5f)]
		public int sunFlaresDownsampling = 1;

		[Range(0f, 1f)]
		public float sunFlaresSunIntensity = 0.1f;

		[Range(0f, 1f)]
		public float sunFlaresSunDiskSize = 0.05f;

		[Range(0f, 10f)]
		public float sunFlaresSunRayDiffractionIntensity = 3.5f;

		[Range(0f, 1f)]
		public float sunFlaresSunRayDiffractionThreshold = 0.13f;

		[Range(0f, 0.2f)]
		public float sunFlaresCoronaRays1Length = 0.02f;

		[Range(2f, 30f)]
		public int sunFlaresCoronaRays1Streaks = 12;

		[Range(0f, 0.1f)]
		public float sunFlaresCoronaRays1Spread = 0.001f;

		[Range(0f, (float)Math.PI * 2f)]
		public float sunFlaresCoronaRays1AngleOffset;

		[Range(0f, 0.2f)]
		public float sunFlaresCoronaRays2Length = 0.05f;

		[Range(2f, 30f)]
		public int sunFlaresCoronaRays2Streaks = 12;

		[Range(0f, 0.1f)]
		public float sunFlaresCoronaRays2Spread = 0.1f;

		[Range(0f, (float)Math.PI * 2f)]
		public float sunFlaresCoronaRays2AngleOffset;

		[Range(0f, 1f)]
		public float sunFlaresGhosts1Size = 0.03f;

		[Range(-3f, 3f)]
		public float sunFlaresGhosts1Offset = 1.04f;

		[Range(0f, 1f)]
		public float sunFlaresGhosts1Brightness = 0.037f;

		[Range(0f, 1f)]
		public float sunFlaresGhosts2Size = 0.1f;

		[Range(-3f, 3f)]
		public float sunFlaresGhosts2Offset = 0.71f;

		[Range(0f, 1f)]
		public float sunFlaresGhosts2Brightness = 0.03f;

		[Range(0f, 1f)]
		public float sunFlaresGhosts3Size = 0.24f;

		[Range(-3f, 3f)]
		public float sunFlaresGhosts3Brightness = 0.025f;

		[Range(0f, 1f)]
		public float sunFlaresGhosts3Offset = 0.31f;

		[Range(0f, 1f)]
		public float sunFlaresGhosts4Size = 0.016f;

		[Range(-3f, 3f)]
		public float sunFlaresGhosts4Offset;

		[Range(0f, 1f)]
		public float sunFlaresGhosts4Brightness = 0.017f;

		[Range(0f, 1f)]
		public float sunFlaresHaloOffset = 0.22f;

		[Range(0f, 50f)]
		public float sunFlaresHaloAmplitude = 15.1415f;

		[Range(0f, 1f)]
		public float sunFlaresHaloIntensity = 0.01f;

		public bool sunFlaresRotationDeadZone;

		public bool blur;

		[Range(0f, 4f)]
		public float blurIntensity = 1f;

		public int pixelateAmount = 1;

		public bool pixelateDownscale;

		public void Load(Beautify b)
		{
			b.downscale = downscale;
			b.dither = dither;
			b.ditherDepth = ditherDepth;
			b.sharpenMinDepth = sharpenMinDepth;
			b.sharpenMaxDepth = sharpenMaxDepth;
			b.sharpenMinMaxDepthFallOff = sharpenMinMaxDepthFallOff;
			b.sharpen = sharpen;
			b.sharpenDepthThreshold = sharpenDepthThreshold;
			b.tintColor = tintColor;
			b.sharpenRelaxation = sharpenRelaxation;
			b.sharpenClamp = sharpenClamp;
			b.sharpenMotionSensibility = sharpenMotionSensibility;
			b.antialiasStrength = antialiasStrength;
			b.antialiasDepthThreshold = antialiasDepthThreshold;
			b.saturate = saturate;
			b.contrast = contrast;
			b.brightness = brightness;
			b.daltonize = daltonize;
			b.vignetting = vignetting;
			b.vignettingColor = vignettingColor;
			b.vignettingFade = vignettingFade;
			b.vignettingCircularShape = vignettingCircularShape;
			b.vignettingAspectRatio = vignettingAspectRatio;
			b.vignettingBlink = vignettingBlink;
			b.vignettingMask = vignettingMask;
			b.frame = frame;
			b.frameColor = frameColor;
			b.frameMask = frameMask;
			b.lut = lut;
			b.lutTexture = lutTexture;
			b.lutIntensity = lutIntensity;
			b.nightVision = nightVision;
			b.nightVisionColor = nightVisionColor;
			b.outline = outline;
			b.outlineColor = outlineColor;
			b.thermalVision = thermalVision;
			b.lensDirt = lensDirt;
			b.lensDirtThreshold = lensDirtThreshold;
			b.lensDirtIntensity = lensDirtIntensity;
			b.lensDirtTexture = lensDirtTexture;
			b.bloom = bloom;
			b.bloomCullingMask = bloomCullingMask;
			b.bloomLayerMaskDownsampling = bloomLayerMaskDownsampling;
			b.bloomIntensity = bloomIntensity;
			b.bloomMaxBrightness = bloomMaxBrightness;
			b.bloomBoost0 = bloomBoost0;
			b.bloomBoost1 = bloomBoost1;
			b.bloomBoost2 = bloomBoost2;
			b.bloomBoost3 = bloomBoost3;
			b.bloomBoost4 = bloomBoost4;
			b.bloomBoost5 = bloomBoost5;
			b.bloomAntiflicker = bloomAntiflicker;
			b.bloomUltra = bloomUltra;
			b.bloomUltraResolution = bloomUltraResolution;
			b.bloomThreshold = bloomThreshold;
			b.bloomCustomize = bloomCustomize;
			b.bloomWeight0 = bloomWeight0;
			b.bloomWeight1 = bloomWeight1;
			b.bloomWeight2 = bloomWeight2;
			b.bloomWeight3 = bloomWeight3;
			b.bloomWeight4 = bloomWeight4;
			b.bloomWeight5 = bloomWeight5;
			b.bloomBlur = bloomBlur;
			b.bloomDepthAtten = bloomDepthAtten;
			b.bloomLayerZBias = bloomLayerZBias;
			b.anamorphicFlares = anamorphicFlares;
			b.anamorphicFlaresIntensity = anamorphicFlaresIntensity;
			b.anamorphicFlaresAntiflicker = anamorphicFlaresAntiflicker;
			b.anamorphicFlaresUltra = anamorphicFlaresUltra;
			b.anamorphicUltraResolution = anamorphicFlaresUltraResolution;
			b.anamorphicFlaresThreshold = anamorphicFlaresThreshold;
			b.anamorphicFlaresSpread = anamorphicFlaresSpread;
			b.anamorphicFlaresVertical = anamorphicFlaresVertical;
			b.anamorphicFlaresTint = anamorphicFlaresTint;
			b.anamorphicFlaresBlur = anamorphicFlaresBlur;
			b.depthOfField = depthOfField;
			b.depthOfFieldTransparencySupport = depthOfFieldTransparencySupport;
			b.depthOfFieldTargetFocus = depthOfFieldTargetFocus;
			b.depthOfFieldAutofocus = depthOfFieldAutofocus;
			b.depthofFieldAutofocusViewportPoint = depthofFieldAutofocusViewportPoint;
			b.depthOfFieldAutofocusLayerMask = depthOfFieldAutofocusLayerMask;
			b.depthOfFieldAutofocusMinDistance = depthOfFieldAutofocusMinDistance;
			b.depthOfFieldAutofocusMaxDistance = depthOfFieldAutofocusMaxDistance;
			b.depthOfFieldExclusionLayerMask = depthOfFieldExclusionLayerMask;
			b.depthOfFieldExclusionLayerMaskDownsampling = depthOfFieldExclusionLayerMaskDownsampling;
			b.depthOfFieldTransparencySupportDownsampling = depthOfFieldTransparencySupportDownsampling;
			b.depthOfFieldExclusionBias = depthOfFieldExclusionBias;
			b.depthOfFieldDistance = depthOfFieldDistance;
			b.depthOfFieldFocusSpeed = depthOfFieldFocusSpeed;
			b.depthOfFieldDownsampling = depthOfFieldDownsampling;
			b.depthOfFieldMaxSamples = depthOfFieldMaxSamples;
			b.depthOfFieldFocalLength = depthOfFieldFocalLength;
			b.depthOfFieldAperture = depthOfFieldAperture;
			b.depthOfFieldForegroundBlur = depthOfFieldForegroundBlur;
			b.depthOfFieldForegroundBlurHQ = depthOfFieldForegroundBlurHQ;
			b.depthOfFieldForegroundDistance = depthOfFieldForegroundDistance;
			b.depthOfFieldBokeh = depthOfFieldBokeh;
			b.depthOfFieldBokehThreshold = depthOfFieldBokehThreshold;
			b.depthOfFieldBokehIntensity = depthOfFieldBokehIntensity;
			b.depthOfFieldMaxBrightness = depthOfFieldMaxBrightness;
			b.depthOfFieldMaxDistance = depthOfFieldMaxDistance;
			b.depthOfFieldFilterMode = depthOfFieldFilterMode;
			b.depthOfFieldTransparencyLayerMask = depthOfFieldTransparencyLayerMask;
			b.eyeAdaptation = eyeAdaptation;
			b.eyeAdaptationMaxExposure = eyeAdaptationMaxExposure;
			b.eyeAdaptationMinExposure = eyeAdaptationMinExposure;
			b.eyeAdaptationSpeedToDark = eyeAdaptationSpeedToDark;
			b.eyeAdaptationSpeedToLight = eyeAdaptationSpeedToLight;
			b.purkinje = purkinje;
			b.purkinjeAmount = purkinjeAmount;
			b.purkinjeLuminanceThreshold = purkinjeLuminanceThreshold;
			b.tonemap = tonemap;
			b.sunFlares = sunFlares;
			b.sunFlaresIntensity = sunFlaresIntensity;
			b.sunFlaresSolarWindSpeed = sunFlaresSolarWindSpeed;
			b.sunFlaresTint = sunFlaresTint;
			b.sunFlaresDownsampling = sunFlaresDownsampling;
			b.sunFlaresSunIntensity = sunFlaresSunIntensity;
			b.sunFlaresSunDiskSize = sunFlaresSunDiskSize;
			b.sunFlaresSunRayDiffractionIntensity = sunFlaresSunRayDiffractionIntensity;
			b.sunFlaresSunRayDiffractionThreshold = sunFlaresSunRayDiffractionThreshold;
			b.sunFlaresCoronaRays1Length = sunFlaresCoronaRays1Length;
			b.sunFlaresCoronaRays1Spread = sunFlaresCoronaRays1Spread;
			b.sunFlaresCoronaRays1AngleOffset = sunFlaresCoronaRays1AngleOffset;
			b.sunFlaresCoronaRays1Streaks = sunFlaresCoronaRays1Streaks;
			b.sunFlaresCoronaRays2Length = sunFlaresCoronaRays2Length;
			b.sunFlaresCoronaRays2Spread = sunFlaresCoronaRays2Spread;
			b.sunFlaresCoronaRays2AngleOffset = sunFlaresCoronaRays2AngleOffset;
			b.sunFlaresCoronaRays2Streaks = sunFlaresCoronaRays2Streaks;
			b.sunFlaresGhosts1Size = sunFlaresGhosts1Size;
			b.sunFlaresGhosts1Offset = sunFlaresGhosts1Offset;
			b.sunFlaresGhosts1Brightness = sunFlaresGhosts1Brightness;
			b.sunFlaresGhosts2Size = sunFlaresGhosts2Size;
			b.sunFlaresGhosts2Offset = sunFlaresGhosts2Offset;
			b.sunFlaresGhosts2Brightness = sunFlaresGhosts2Brightness;
			b.sunFlaresGhosts3Size = sunFlaresGhosts3Size;
			b.sunFlaresGhosts3Offset = sunFlaresGhosts3Offset;
			b.sunFlaresGhosts3Brightness = sunFlaresGhosts3Brightness;
			b.sunFlaresGhosts4Size = sunFlaresGhosts4Size;
			b.sunFlaresGhosts4Offset = sunFlaresGhosts4Offset;
			b.sunFlaresGhosts4Brightness = sunFlaresGhosts4Brightness;
			b.sunFlaresHaloOffset = sunFlaresHaloOffset;
			b.sunFlaresHaloAmplitude = sunFlaresHaloAmplitude;
			b.sunFlaresHaloIntensity = sunFlaresHaloIntensity;
			b.sunFlaresRotationDeadZone = sunFlaresRotationDeadZone;
			b.blur = blur;
			b.blurIntensity = blurIntensity;
			b.pixelateAmount = pixelateAmount;
			b.pixelateDownscale = pixelateDownscale;
		}

		public void Save(Beautify b)
		{
			downscale = b.downscale;
			dither = b.dither;
			ditherDepth = b.ditherDepth;
			sharpenMinDepth = b.sharpenMinDepth;
			sharpenMaxDepth = b.sharpenMaxDepth;
			sharpenMinMaxDepthFallOff = b.sharpenMinMaxDepthFallOff;
			sharpen = b.sharpen;
			sharpenDepthThreshold = b.sharpenDepthThreshold;
			tintColor = b.tintColor;
			sharpenRelaxation = b.sharpenRelaxation;
			sharpenClamp = b.sharpenClamp;
			sharpenMotionSensibility = b.sharpenMotionSensibility;
			antialiasStrength = b.antialiasStrength;
			antialiasDepthThreshold = b.antialiasDepthThreshold;
			saturate = b.saturate;
			contrast = b.contrast;
			brightness = b.brightness;
			daltonize = b.daltonize;
			vignetting = b.vignetting;
			vignettingColor = b.vignettingColor;
			vignettingFade = b.vignettingFade;
			vignettingCircularShape = b.vignettingCircularShape;
			vignettingMask = b.vignettingMask;
			vignettingAspectRatio = b.vignettingAspectRatio;
			vignettingBlink = b.vignettingBlink;
			frame = b.frame;
			frameColor = b.frameColor;
			frameMask = b.frameMask;
			lut = b.lut;
			lutTexture = b.lutTexture;
			lutIntensity = b.lutIntensity;
			nightVision = b.nightVision;
			nightVisionColor = b.nightVisionColor;
			outline = b.outline;
			outlineColor = b.outlineColor;
			thermalVision = b.thermalVision;
			lensDirt = b.lensDirt;
			lensDirtThreshold = b.lensDirtThreshold;
			lensDirtIntensity = b.lensDirtIntensity;
			lensDirtTexture = b.lensDirtTexture;
			bloom = b.bloom;
			bloomCullingMask = b.bloomCullingMask;
			bloomLayerMaskDownsampling = b.bloomLayerMaskDownsampling;
			bloomIntensity = b.bloomIntensity;
			bloomMaxBrightness = b.bloomMaxBrightness;
			bloomBoost0 = b.bloomBoost0;
			bloomBoost1 = b.bloomBoost1;
			bloomBoost2 = b.bloomBoost2;
			bloomBoost3 = b.bloomBoost3;
			bloomBoost4 = b.bloomBoost4;
			bloomBoost5 = b.bloomBoost5;
			bloomAntiflicker = b.bloomAntiflicker;
			bloomUltra = b.bloomUltra;
			bloomUltraResolution = b.bloomUltraResolution;
			bloomThreshold = b.bloomThreshold;
			bloomCustomize = b.bloomCustomize;
			bloomWeight0 = b.bloomWeight0;
			bloomWeight1 = b.bloomWeight1;
			bloomWeight2 = b.bloomWeight2;
			bloomWeight3 = b.bloomWeight3;
			bloomWeight4 = b.bloomWeight4;
			bloomWeight5 = b.bloomWeight5;
			bloomBlur = b.bloomBlur;
			bloomDepthAtten = b.bloomDepthAtten;
			bloomLayerZBias = b.bloomLayerZBias;
			anamorphicFlares = b.anamorphicFlares;
			anamorphicFlaresIntensity = b.anamorphicFlaresIntensity;
			anamorphicFlaresAntiflicker = b.anamorphicFlaresAntiflicker;
			anamorphicFlaresUltraResolution = b.anamorphicUltraResolution;
			anamorphicFlaresUltra = b.anamorphicFlaresUltra;
			anamorphicFlaresThreshold = b.anamorphicFlaresThreshold;
			anamorphicFlaresSpread = b.anamorphicFlaresSpread;
			anamorphicFlaresVertical = b.anamorphicFlaresVertical;
			anamorphicFlaresTint = b.anamorphicFlaresTint;
			anamorphicFlaresBlur = b.anamorphicFlaresBlur;
			depthOfField = b.depthOfField;
			depthOfFieldTransparencySupport = b.depthOfFieldTransparencySupport;
			depthOfFieldTargetFocus = b.depthOfFieldTargetFocus;
			depthOfFieldAutofocus = b.depthOfFieldAutofocus;
			depthofFieldAutofocusViewportPoint = b.depthofFieldAutofocusViewportPoint;
			depthOfFieldAutofocusLayerMask = b.depthOfFieldAutofocusLayerMask;
			depthOfFieldAutofocusMinDistance = b.depthOfFieldAutofocusMinDistance;
			depthOfFieldAutofocusMaxDistance = b.depthOfFieldAutofocusMaxDistance;
			depthOfFieldExclusionLayerMask = b.depthOfFieldExclusionLayerMask;
			depthOfFieldExclusionLayerMaskDownsampling = b.depthOfFieldExclusionLayerMaskDownsampling;
			depthOfFieldTransparencySupportDownsampling = b.depthOfFieldTransparencySupportDownsampling;
			depthOfFieldExclusionBias = b.depthOfFieldExclusionBias;
			depthOfFieldDistance = b.depthOfFieldDistance;
			depthOfFieldFocusSpeed = b.depthOfFieldFocusSpeed;
			depthOfFieldDownsampling = b.depthOfFieldDownsampling;
			depthOfFieldMaxSamples = b.depthOfFieldMaxSamples;
			depthOfFieldFocalLength = b.depthOfFieldFocalLength;
			depthOfFieldAperture = b.depthOfFieldAperture;
			depthOfFieldForegroundBlur = b.depthOfFieldForegroundBlur;
			depthOfFieldForegroundBlurHQ = b.depthOfFieldForegroundBlurHQ;
			depthOfFieldForegroundDistance = b.depthOfFieldForegroundDistance;
			depthOfFieldBokeh = b.depthOfFieldBokeh;
			depthOfFieldBokehThreshold = b.depthOfFieldBokehThreshold;
			depthOfFieldBokehIntensity = b.depthOfFieldBokehIntensity;
			depthOfFieldMaxBrightness = b.depthOfFieldMaxBrightness;
			depthOfFieldMaxDistance = b.depthOfFieldMaxDistance;
			depthOfFieldFilterMode = b.depthOfFieldFilterMode;
			depthOfFieldTransparencyLayerMask = b.depthOfFieldTransparencyLayerMask;
			eyeAdaptation = b.eyeAdaptation;
			eyeAdaptationMaxExposure = b.eyeAdaptationMaxExposure;
			eyeAdaptationMinExposure = b.eyeAdaptationMinExposure;
			eyeAdaptationSpeedToDark = b.eyeAdaptationSpeedToDark;
			eyeAdaptationSpeedToLight = b.eyeAdaptationSpeedToLight;
			purkinje = b.purkinje;
			purkinjeAmount = b.purkinjeAmount;
			purkinjeLuminanceThreshold = b.purkinjeLuminanceThreshold;
			tonemap = b.tonemap;
			sunFlares = b.sunFlares;
			sunFlaresIntensity = b.sunFlaresIntensity;
			sunFlaresSolarWindSpeed = b.sunFlaresSolarWindSpeed;
			sunFlaresTint = b.sunFlaresTint;
			sunFlaresDownsampling = b.sunFlaresDownsampling;
			sunFlaresSunIntensity = b.sunFlaresSunIntensity;
			sunFlaresSunDiskSize = b.sunFlaresSunDiskSize;
			sunFlaresSunRayDiffractionIntensity = b.sunFlaresSunRayDiffractionIntensity;
			sunFlaresSunRayDiffractionThreshold = b.sunFlaresSunRayDiffractionThreshold;
			sunFlaresCoronaRays1Length = b.sunFlaresCoronaRays1Length;
			sunFlaresCoronaRays1Spread = b.sunFlaresCoronaRays1Spread;
			sunFlaresCoronaRays1AngleOffset = b.sunFlaresCoronaRays1AngleOffset;
			sunFlaresCoronaRays1Streaks = b.sunFlaresCoronaRays1Streaks;
			sunFlaresCoronaRays2Length = b.sunFlaresCoronaRays2Length;
			sunFlaresCoronaRays2Spread = b.sunFlaresCoronaRays2Spread;
			sunFlaresCoronaRays2AngleOffset = b.sunFlaresCoronaRays2AngleOffset;
			sunFlaresCoronaRays2Streaks = b.sunFlaresCoronaRays2Streaks;
			sunFlaresGhosts1Size = b.sunFlaresGhosts1Size;
			sunFlaresGhosts1Offset = b.sunFlaresGhosts1Offset;
			sunFlaresGhosts1Brightness = b.sunFlaresGhosts1Brightness;
			sunFlaresGhosts2Size = b.sunFlaresGhosts2Size;
			sunFlaresGhosts2Offset = b.sunFlaresGhosts2Offset;
			sunFlaresGhosts2Brightness = b.sunFlaresGhosts2Brightness;
			sunFlaresGhosts3Size = b.sunFlaresGhosts3Size;
			sunFlaresGhosts3Offset = b.sunFlaresGhosts3Offset;
			sunFlaresGhosts3Brightness = b.sunFlaresGhosts3Brightness;
			sunFlaresGhosts4Size = b.sunFlaresGhosts4Size;
			sunFlaresGhosts4Offset = b.sunFlaresGhosts4Offset;
			sunFlaresGhosts4Brightness = b.sunFlaresGhosts4Brightness;
			sunFlaresHaloOffset = b.sunFlaresHaloOffset;
			sunFlaresHaloAmplitude = b.sunFlaresHaloAmplitude;
			sunFlaresHaloIntensity = b.sunFlaresHaloIntensity;
			sunFlaresRotationDeadZone = b.sunFlaresRotationDeadZone;
			blur = b.blur;
			blurIntensity = b.blurIntensity;
			pixelateAmount = b.pixelateAmount;
			pixelateDownscale = b.pixelateDownscale;
		}
	}
}
