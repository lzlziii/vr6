using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.NetworkInformation;
using System.Net.Security;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;
using AOT;
using BoingKit;
using BombDisposal;
using BoundarySystem_Ext;
using CRCI_FruitCut;
using Cinemachine;
using Common;
using DG.Tweening;
using FogOfWar;
using Guava;
using HighlightPlus;
using J_LitCSV;
using J_LitJson;
using J_VRHandMenu;
using LT_Task;
using LitJson;
using Mirror;
using NPinyin;
using NatSuite.Examples;
using NatSuite.Recorders;
using NatSuite.Recorders.Clocks;
using NatSuite.Recorders.Inputs;
using NatSuite.Recorders.Internal;
using Pvr_UnitySDKAPI;
using Pvr_UnitySDKAPI.Achievement;
using SplineMesh;
using TMPro;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;
using UnityEngine.Android;
using UnityEngine.Animations;
using UnityEngine.Audio;
using UnityEngine.EventSystems;
using UnityEngine.Events;
using UnityEngine.Experimental.Rendering;
using UnityEngine.Networking;
using UnityEngine.Rendering;
using UnityEngine.SceneManagement;
using UnityEngine.Sprites;
using UnityEngine.UI;
using UnityEngine.Video;
using UnityEngine.XR;
using UnityStandardAssets.CrossPlatformInput;
using UnityStandardAssets.Effects;
using Valve.VR.InteractionSystem;
using ZXing;
using __;
using agora_gaming_rtc;
using agora_utilities;
using hj;

[assembly: CompilationRelaxations(8)]
[assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)]
[assembly: Debuggable(DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)]
[assembly: AssemblyVersion("0.0.0.0")]
public class RandomMaterial : MonoBehaviour
{
	public Renderer targetRenderer;

	public Material[] materials;

	public void Start()
	{
		ChangeMaterial();
	}

	public void ChangeMaterial()
	{
		targetRenderer.sharedMaterial = materials[UnityEngine.Random.Range(0, materials.Length)];
	}
}
public class UnluckDistanceDisabler : MonoBehaviour
{
	public int _distanceDisable = 1000;

	public Transform _distanceFrom;

	public bool _distanceFromMainCam;

	public float _disableCheckInterval = 10f;

	public float _enableCheckInterval = 1f;

	public bool _disableOnStart;

	public void Start()
	{
		if (_distanceFromMainCam)
		{
			_distanceFrom = Camera.main.transform;
		}
		InvokeRepeating("CheckDisable", _disableCheckInterval + UnityEngine.Random.value * _disableCheckInterval, _disableCheckInterval);
		InvokeRepeating("CheckEnable", _enableCheckInterval + UnityEngine.Random.value * _enableCheckInterval, _enableCheckInterval);
		Invoke("DisableOnStart", 0.01f);
	}

	public void DisableOnStart()
	{
		if (_disableOnStart)
		{
			base.gameObject.SetActive(value: false);
		}
	}

	public void CheckDisable()
	{
		if (base.gameObject.activeInHierarchy && (base.transform.position - _distanceFrom.position).sqrMagnitude > (float)(_distanceDisable * _distanceDisable))
		{
			base.gameObject.SetActive(value: false);
		}
	}

	public void CheckEnable()
	{
		if (!base.gameObject.activeInHierarchy && (base.transform.position - _distanceFrom.position).sqrMagnitude < (float)(_distanceDisable * _distanceDisable))
		{
			base.gameObject.SetActive(value: true);
		}
	}
}
public class LookAtCamera : MonoBehaviour
{
	public Camera lookAtCamera;

	public bool lookOnlyOnAwake;

	public void Start()
	{
		if (lookAtCamera == null)
		{
			lookAtCamera = Camera.main;
		}
		if (lookOnlyOnAwake)
		{
			LookCam();
		}
	}

	public void Update()
	{
		if (!lookOnlyOnAwake)
		{
			LookCam();
		}
	}

	public void LookCam()
	{
		base.transform.LookAt(lookAtCamera.transform);
	}
}
public class FlockChild : MonoBehaviour
{
	[HideInInspector]
	public FlockController _spawner;

	[HideInInspector]
	public Vector3 _wayPoint;

	public float _speed;

	[HideInInspector]
	public bool _dived = true;

	[HideInInspector]
	public float _stuckCounter;

	[HideInInspector]
	public float _damping;

	[HideInInspector]
	public bool _soar = true;

	[HideInInspector]
	public bool _landing;

	[HideInInspector]
	public float _targetSpeed;

	[HideInInspector]
	public bool _move = true;

	public GameObject _model;

	public Transform _modelT;

	[HideInInspector]
	public float _avoidValue;

	[HideInInspector]
	public float _avoidDistance;

	private float _soarTimer;

	private bool _instantiated;

	private static int _updateNextSeed;

	private int _updateSeed = -1;

	[HideInInspector]
	public bool _avoid = true;

	public Transform _thisT;

	public Vector3 _landingPosOffset;

	public void Start()
	{
		FindRequiredComponents();
		Wander(0f);
		SetRandomScale();
		_thisT.position = findWaypoint();
		RandomizeStartAnimationFrame();
		InitAvoidanceValues();
		_speed = _spawner._minSpeed;
		_spawner._activeChildren += 1f;
		_instantiated = true;
		if (_spawner._updateDivisor > 1)
		{
			int num = _spawner._updateDivisor - 1;
			_updateNextSeed++;
			_updateSeed = _updateNextSeed;
			_updateNextSeed %= num;
		}
	}

	public void Update()
	{
		if (_spawner._updateDivisor <= 1 || _spawner._updateCounter == _updateSeed)
		{
			SoarTimeLimit();
			CheckForDistanceToWaypoint();
			RotationBasedOnWaypointOrAvoidance();
			LimitRotationOfModel();
		}
	}

	public void OnDisable()
	{
		CancelInvoke();
		_spawner._activeChildren -= 1f;
	}

	public void OnEnable()
	{
		if (_instantiated)
		{
			_spawner._activeChildren += 1f;
			if (_landing)
			{
				_model.GetComponent<Animation>().Play(_spawner._idleAnimation);
			}
			else
			{
				_model.GetComponent<Animation>().Play(_spawner._flapAnimation);
			}
		}
	}

	public void FindRequiredComponents()
	{
		if (_thisT == null)
		{
			_thisT = base.transform;
		}
		if (_model == null)
		{
			_model = _thisT.Find("Model").gameObject;
		}
		if (_modelT == null)
		{
			_modelT = _model.transform;
		}
	}

	public void RandomizeStartAnimationFrame()
	{
		foreach (UnityEngine.AnimationState item in _model.GetComponent<Animation>())
		{
			item.time = UnityEngine.Random.value * item.length;
		}
	}

	public void InitAvoidanceValues()
	{
		_avoidValue = UnityEngine.Random.Range(0.3f, 0.1f);
		if (_spawner._birdAvoidDistanceMax != _spawner._birdAvoidDistanceMin)
		{
			_avoidDistance = UnityEngine.Random.Range(_spawner._birdAvoidDistanceMax, _spawner._birdAvoidDistanceMin);
		}
		else
		{
			_avoidDistance = _spawner._birdAvoidDistanceMin;
		}
	}

	public void SetRandomScale()
	{
		float num = UnityEngine.Random.Range(_spawner._minScale, _spawner._maxScale);
		_thisT.localScale = new Vector3(num, num, num);
	}

	public void SoarTimeLimit()
	{
		if (_soar && _spawner._soarMaxTime > 0f)
		{
			if (_soarTimer > _spawner._soarMaxTime)
			{
				Flap();
				_soarTimer = 0f;
			}
			else
			{
				_soarTimer += _spawner._newDelta;
			}
		}
	}

	public void CheckForDistanceToWaypoint()
	{
		if (!_landing && (_thisT.position - _wayPoint).magnitude < _spawner._waypointDistance + _stuckCounter)
		{
			Wander(0f);
			_stuckCounter = 0f;
		}
		else if (!_landing)
		{
			_stuckCounter += _spawner._newDelta;
		}
		else
		{
			_stuckCounter = 0f;
		}
	}

	public void RotationBasedOnWaypointOrAvoidance()
	{
		Vector3 vector = _wayPoint - _thisT.position;
		if (_targetSpeed > -1f && vector != Vector3.zero)
		{
			Quaternion b = Quaternion.LookRotation(vector);
			_thisT.rotation = Quaternion.Slerp(_thisT.rotation, b, _spawner._newDelta * _damping);
		}
		if (_spawner._childTriggerPos && (_thisT.position - _spawner._posBuffer).magnitude < 1f)
		{
			_spawner.SetFlockRandomPosition();
		}
		_speed = Mathf.Lerp(_speed, _targetSpeed, _spawner._newDelta * 2.5f);
		if (_move)
		{
			_thisT.position += _thisT.forward * _speed * _spawner._newDelta;
			if (_avoid && _spawner._birdAvoid)
			{
				Avoidance();
			}
		}
	}

	public bool Avoidance()
	{
		RaycastHit hitInfo = default(RaycastHit);
		Vector3 forward = _modelT.forward;
		bool result = false;
		Quaternion identity = Quaternion.identity;
		Vector3 zero = Vector3.zero;
		Vector3 zero2 = Vector3.zero;
		zero2 = _thisT.position;
		identity = _thisT.rotation;
		zero = _thisT.rotation.eulerAngles;
		if (Physics.Raycast(_thisT.position, forward + _modelT.right * _avoidValue, out hitInfo, _avoidDistance, _spawner._avoidanceMask))
		{
			zero.y -= (float)_spawner._birdAvoidHorizontalForce * _spawner._newDelta * _damping;
			identity.eulerAngles = zero;
			_thisT.rotation = identity;
			result = true;
		}
		else if (Physics.Raycast(_thisT.position, forward + _modelT.right * (0f - _avoidValue), out hitInfo, _avoidDistance, _spawner._avoidanceMask))
		{
			zero.y += (float)_spawner._birdAvoidHorizontalForce * _spawner._newDelta * _damping;
			identity.eulerAngles = zero;
			_thisT.rotation = identity;
			result = true;
		}
		if (_spawner._birdAvoidDown && !_landing && Physics.Raycast(_thisT.position, -Vector3.up, out hitInfo, _avoidDistance, _spawner._avoidanceMask))
		{
			zero.x -= (float)_spawner._birdAvoidVerticalForce * _spawner._newDelta * _damping;
			identity.eulerAngles = zero;
			_thisT.rotation = identity;
			zero2.y += (float)_spawner._birdAvoidVerticalForce * _spawner._newDelta * 0.01f;
			_thisT.position = zero2;
			result = true;
		}
		else if (_spawner._birdAvoidUp && !_landing && Physics.Raycast(_thisT.position, Vector3.up, out hitInfo, _avoidDistance, _spawner._avoidanceMask))
		{
			zero.x += (float)_spawner._birdAvoidVerticalForce * _spawner._newDelta * _damping;
			identity.eulerAngles = zero;
			_thisT.rotation = identity;
			zero2.y -= (float)_spawner._birdAvoidVerticalForce * _spawner._newDelta * 0.01f;
			_thisT.position = zero2;
			result = true;
		}
		return result;
	}

	public void LimitRotationOfModel()
	{
		Quaternion identity = Quaternion.identity;
		Vector3 zero = Vector3.zero;
		identity = _modelT.localRotation;
		zero = identity.eulerAngles;
		if ((((_soar && _spawner._flatSoar) || (_spawner._flatFly && !_soar)) && _wayPoint.y > _thisT.position.y) || _landing)
		{
			zero.x = Mathf.LerpAngle(_modelT.localEulerAngles.x, 0f - _thisT.localEulerAngles.x, _spawner._newDelta * 1.75f);
			identity.eulerAngles = zero;
			_modelT.localRotation = identity;
		}
		else
		{
			zero.x = Mathf.LerpAngle(_modelT.localEulerAngles.x, 0f, _spawner._newDelta * 1.75f);
			identity.eulerAngles = zero;
			_modelT.localRotation = identity;
		}
	}

	public void Wander(float delay)
	{
		if (!_landing)
		{
			_damping = UnityEngine.Random.Range(_spawner._minDamping, _spawner._maxDamping);
			_targetSpeed = UnityEngine.Random.Range(_spawner._minSpeed, _spawner._maxSpeed);
			Invoke("SetRandomMode", delay);
		}
	}

	public void SetRandomMode()
	{
		CancelInvoke("SetRandomMode");
		if (!_dived && UnityEngine.Random.value < _spawner._soarFrequency)
		{
			Soar();
		}
		else if (!_dived && UnityEngine.Random.value < _spawner._diveFrequency)
		{
			Dive();
		}
		else
		{
			Flap();
		}
	}

	public void Flap()
	{
		if (_move)
		{
			if (_model != null)
			{
				_model.GetComponent<Animation>().CrossFade(_spawner._flapAnimation, 0.5f);
			}
			_soar = false;
			animationSpeed();
			_wayPoint = findWaypoint();
			_dived = false;
		}
	}

	public Vector3 findWaypoint()
	{
		Vector3 zero = Vector3.zero;
		zero.x = UnityEngine.Random.Range(0f - _spawner._spawnSphere, _spawner._spawnSphere) + _spawner._posBuffer.x;
		zero.z = UnityEngine.Random.Range(0f - _spawner._spawnSphereDepth, _spawner._spawnSphereDepth) + _spawner._posBuffer.z;
		zero.y = UnityEngine.Random.Range(0f - _spawner._spawnSphereHeight, _spawner._spawnSphereHeight) + _spawner._posBuffer.y;
		return zero;
	}

	public void Soar()
	{
		if (_move)
		{
			_model.GetComponent<Animation>().CrossFade(_spawner._soarAnimation, 1.5f);
			_wayPoint = findWaypoint();
			_soar = true;
		}
	}

	public void Dive()
	{
		if (_spawner._soarAnimation != null)
		{
			_model.GetComponent<Animation>().CrossFade(_spawner._soarAnimation, 1.5f);
		}
		else
		{
			foreach (UnityEngine.AnimationState item in _model.GetComponent<Animation>())
			{
				if (_thisT.position.y < _wayPoint.y + 25f)
				{
					item.speed = 0.1f;
				}
			}
		}
		_wayPoint = findWaypoint();
		_wayPoint.y -= _spawner._diveValue;
		_dived = true;
	}

	public void animationSpeed()
	{
		foreach (UnityEngine.AnimationState item in _model.GetComponent<Animation>())
		{
			if (!_dived && !_landing)
			{
				item.speed = UnityEngine.Random.Range(_spawner._minAnimationSpeed, _spawner._maxAnimationSpeed);
			}
			else
			{
				item.speed = _spawner._maxAnimationSpeed;
			}
		}
	}
}
[RequireComponent(typeof(AudioSource))]
public class FlockChildSound : MonoBehaviour
{
	public AudioClip[] _idleSounds;

	public float _idleSoundRandomChance = 0.05f;

	public AudioClip[] _flightSounds;

	public float _flightSoundRandomChance = 0.05f;

	public AudioClip[] _scareSounds;

	public float _pitchMin = 0.85f;

	public float _pitchMax = 1f;

	public float _volumeMin = 0.6f;

	public float _volumeMax = 0.8f;

	private FlockChild _flockChild;

	private AudioSource _audio;

	private bool _hasLanded;

	public void Start()
	{
		_flockChild = GetComponent<FlockChild>();
		_audio = GetComponent<AudioSource>();
		InvokeRepeating("PlayRandomSound", UnityEngine.Random.value + 1f, 1f);
		if (_scareSounds.Length != 0)
		{
			InvokeRepeating("ScareSound", 1f, 0.01f);
		}
	}

	public void PlayRandomSound()
	{
		if (base.gameObject.activeInHierarchy)
		{
			if (!_audio.isPlaying && _flightSounds.Length != 0 && _flightSoundRandomChance > UnityEngine.Random.value && !_flockChild._landing)
			{
				_audio.clip = _flightSounds[UnityEngine.Random.Range(0, _flightSounds.Length)];
				_audio.pitch = UnityEngine.Random.Range(_pitchMin, _pitchMax);
				_audio.volume = UnityEngine.Random.Range(_volumeMin, _volumeMax);
				_audio.Play();
			}
			else if (!_audio.isPlaying && _idleSounds.Length != 0 && _idleSoundRandomChance > UnityEngine.Random.value && _flockChild._landing)
			{
				_audio.clip = _idleSounds[UnityEngine.Random.Range(0, _idleSounds.Length)];
				_audio.pitch = UnityEngine.Random.Range(_pitchMin, _pitchMax);
				_audio.volume = UnityEngine.Random.Range(_volumeMin, _volumeMax);
				_audio.Play();
				_hasLanded = true;
			}
		}
	}

	public void ScareSound()
	{
		if (base.gameObject.activeInHierarchy && _hasLanded && !_flockChild._landing && _idleSoundRandomChance * 2f > UnityEngine.Random.value)
		{
			_audio.clip = _scareSounds[UnityEngine.Random.Range(0, _scareSounds.Length)];
			_audio.volume = UnityEngine.Random.Range(_volumeMin, _volumeMax);
			_audio.PlayDelayed(UnityEngine.Random.value * 0.2f);
			_hasLanded = false;
		}
	}
}
public class FlockController : MonoBehaviour
{
	public FlockChild _childPrefab;

	public int _childAmount = 250;

	public bool _slowSpawn;

	public float _spawnSphere = 3f;

	public float _spawnSphereHeight = 3f;

	public float _spawnSphereDepth = -1f;

	public float _minSpeed = 6f;

	public float _maxSpeed = 10f;

	public float _minScale = 0.7f;

	public float _maxScale = 1f;

	public float _soarFrequency;

	public string _soarAnimation = "Soar";

	public string _flapAnimation = "Flap";

	public string _idleAnimation = "Idle";

	public float _diveValue = 7f;

	public float _diveFrequency = 0.5f;

	public float _minDamping = 1f;

	public float _maxDamping = 2f;

	public float _waypointDistance = 1f;

	public float _minAnimationSpeed = 2f;

	public float _maxAnimationSpeed = 4f;

	public float _randomPositionTimer = 10f;

	public float _positionSphere = 25f;

	public float _positionSphereHeight = 25f;

	public float _positionSphereDepth = -1f;

	public bool _childTriggerPos;

	public bool _forceChildWaypoints;

	public float _forcedRandomDelay = 1.5f;

	public bool _flatFly;

	public bool _flatSoar;

	public bool _birdAvoid;

	public int _birdAvoidHorizontalForce = 1000;

	public bool _birdAvoidDown;

	public bool _birdAvoidUp;

	public int _birdAvoidVerticalForce = 300;

	public float _birdAvoidDistanceMax = 4.5f;

	public float _birdAvoidDistanceMin = 5f;

	public float _soarMaxTime;

	public LayerMask _avoidanceMask = -1;

	public List<FlockChild> _roamers;

	public Vector3 _posBuffer;

	public int _updateDivisor = 1;

	public float _newDelta;

	public int _updateCounter;

	public float _activeChildren;

	public bool _groupChildToNewTransform;

	public Transform _groupTransform;

	public string _groupName = "";

	public bool _groupChildToFlock;

	public Vector3 _startPosOffset;

	public Transform _thisT;

	public void Start()
	{
		_thisT = base.transform;
		if (_positionSphereDepth == -1f)
		{
			_positionSphereDepth = _positionSphere;
		}
		if (_spawnSphereDepth == -1f)
		{
			_spawnSphereDepth = _spawnSphere;
		}
		_posBuffer = _thisT.position + _startPosOffset;
		if (!_slowSpawn)
		{
			AddChild(_childAmount);
		}
		if (_randomPositionTimer > 0f)
		{
			InvokeRepeating("SetFlockRandomPosition", _randomPositionTimer, _randomPositionTimer);
		}
	}

	public void AddChild(int amount)
	{
		if (_groupChildToNewTransform)
		{
			InstantiateGroup();
		}
		for (int i = 0; i < amount; i++)
		{
			FlockChild flockChild = UnityEngine.Object.Instantiate(_childPrefab);
			flockChild._spawner = this;
			_roamers.Add(flockChild);
			AddChildToParent(flockChild.transform);
		}
	}

	public void AddChildToParent(Transform obj)
	{
		if (_groupChildToFlock)
		{
			obj.parent = base.transform;
		}
		else if (_groupChildToNewTransform)
		{
			obj.parent = _groupTransform;
		}
	}

	public void RemoveChild(int amount)
	{
		for (int i = 0; i < amount; i++)
		{
			FlockChild flockChild = _roamers[_roamers.Count - 1];
			_roamers.RemoveAt(_roamers.Count - 1);
			UnityEngine.Object.Destroy(flockChild.gameObject);
		}
	}

	public void Update()
	{
		if (_activeChildren > 0f)
		{
			if (_updateDivisor > 1)
			{
				_updateCounter++;
				_updateCounter %= _updateDivisor;
				_newDelta = Time.deltaTime * (float)_updateDivisor;
			}
			else
			{
				_newDelta = Time.deltaTime;
			}
		}
		UpdateChildAmount();
	}

	public void InstantiateGroup()
	{
		if (!(_groupTransform != null))
		{
			GameObject gameObject = new GameObject();
			_groupTransform = gameObject.transform;
			_groupTransform.position = _thisT.position;
			if (_groupName != "")
			{
				gameObject.name = _groupName;
			}
			else
			{
				gameObject.name = _thisT.name + " Fish Container";
			}
		}
	}

	public void UpdateChildAmount()
	{
		if (_childAmount >= 0 && _childAmount < _roamers.Count)
		{
			RemoveChild(1);
		}
		else if (_childAmount > _roamers.Count)
		{
			AddChild(1);
		}
	}

	public void OnDrawGizmos()
	{
		if (_thisT == null)
		{
			_thisT = base.transform;
		}
		if (!Application.isPlaying && _posBuffer != _thisT.position + _startPosOffset)
		{
			_posBuffer = _thisT.position + _startPosOffset;
		}
		if (_positionSphereDepth == -1f)
		{
			_positionSphereDepth = _positionSphere;
		}
		if (_spawnSphereDepth == -1f)
		{
			_spawnSphereDepth = _spawnSphere;
		}
		Gizmos.color = Color.blue;
		Gizmos.DrawWireCube(_posBuffer, new Vector3(_spawnSphere * 2f, _spawnSphereHeight * 2f, _spawnSphereDepth * 2f));
		Gizmos.color = Color.cyan;
		Gizmos.DrawWireCube(_thisT.position, new Vector3(_positionSphere * 2f + _spawnSphere * 2f, _positionSphereHeight * 2f + _spawnSphereHeight * 2f, _positionSphereDepth * 2f + _spawnSphereDepth * 2f));
	}

	public void SetFlockRandomPosition()
	{
		Vector3 zero = Vector3.zero;
		zero.x = UnityEngine.Random.Range(0f - _positionSphere, _positionSphere) + _thisT.position.x;
		zero.z = UnityEngine.Random.Range(0f - _positionSphereDepth, _positionSphereDepth) + _thisT.position.z;
		zero.y = UnityEngine.Random.Range(0f - _positionSphereHeight, _positionSphereHeight) + _thisT.position.y;
		_posBuffer = zero;
		if (_forceChildWaypoints)
		{
			for (int i = 0; i < _roamers.Count; i++)
			{
				_roamers[i].Wander(UnityEngine.Random.value * _forcedRandomDelay);
			}
		}
	}

	public void destroyBirds()
	{
		for (int i = 0; i < _roamers.Count; i++)
		{
			UnityEngine.Object.Destroy(_roamers[i].gameObject);
		}
		_childAmount = 0;
		_roamers.Clear();
	}
}
public class FlockScare : MonoBehaviour
{
	public LandingSpotController[] landingSpotControllers;

	public float scareInterval = 0.1f;

	public float distanceToScare = 2f;

	public int checkEveryNthLandingSpot = 1;

	public int InvokeAmounts = 1;

	private int lsc;

	private int ls;

	private LandingSpotController currentController;

	private void CheckProximityToLandingSpots()
	{
		IterateLandingSpots();
		if (currentController._activeLandingSpots > 0 && CheckDistanceToLandingSpot(landingSpotControllers[lsc]))
		{
			landingSpotControllers[lsc].ScareAll();
		}
		Invoke("CheckProximityToLandingSpots", scareInterval);
	}

	private void IterateLandingSpots()
	{
		ls += checkEveryNthLandingSpot;
		currentController = landingSpotControllers[lsc];
		int childCount = currentController.transform.childCount;
		if (ls > childCount - 1)
		{
			ls -= childCount;
			if (lsc < landingSpotControllers.Length - 1)
			{
				lsc++;
			}
			else
			{
				lsc = 0;
			}
		}
	}

	private bool CheckDistanceToLandingSpot(LandingSpotController lc)
	{
		Transform child = lc.transform.GetChild(ls);
		if (child.GetComponent<LandingSpot>().landingChild != null && (child.position - base.transform.position).sqrMagnitude < distanceToScare * distanceToScare)
		{
			return true;
		}
		return false;
	}

	private void Invoker()
	{
		for (int i = 0; i < InvokeAmounts; i++)
		{
			float num = scareInterval / (float)InvokeAmounts * (float)i;
			Invoke("CheckProximityToLandingSpots", scareInterval + num);
		}
	}

	private void OnEnable()
	{
		CancelInvoke("CheckProximityToLandingSpots");
		if (landingSpotControllers.Length != 0)
		{
			Invoker();
		}
	}

	private void OnDisable()
	{
		CancelInvoke("CheckProximityToLandingSpots");
	}
}
public class FlockWaypointTrigger : MonoBehaviour
{
	public float _timer = 1f;

	public FlockChild _flockChild;

	public void Start()
	{
		if (_flockChild == null)
		{
			_flockChild = base.transform.parent.GetComponent<FlockChild>();
		}
		float num = UnityEngine.Random.Range(_timer, _timer * 3f);
		InvokeRepeating("Trigger", num, num);
	}

	public void Trigger()
	{
		_flockChild.Wander(0f);
	}
}
public class LandingButtons : MonoBehaviour
{
	public LandingSpotController _landingSpotController;

	public FlockController _flockController;

	public float hSliderValue = 250f;

	public void OnGUI()
	{
		GUI.Label(new Rect(20f, 20f, 125f, 18f), "Landing Spots: " + _landingSpotController.transform.childCount);
		if (GUI.Button(new Rect(20f, 40f, 125f, 18f), "Scare All"))
		{
			_landingSpotController.ScareAll();
		}
		if (GUI.Button(new Rect(20f, 60f, 125f, 18f), "Land In Reach"))
		{
			_landingSpotController.LandAll();
		}
		if (GUI.Button(new Rect(20f, 80f, 125f, 18f), "Land Instant"))
		{
			StartCoroutine(_landingSpotController.InstantLand(0.01f));
		}
		if (GUI.Button(new Rect(20f, 100f, 125f, 18f), "Destroy"))
		{
			_flockController.destroyBirds();
		}
		GUI.Label(new Rect(20f, 120f, 125f, 18f), "Bird Amount: " + _flockController._childAmount);
		_flockController._childAmount = (int)GUI.HorizontalSlider(new Rect(20f, 140f, 125f, 18f), _flockController._childAmount, 0f, 250f);
	}
}
public class LandingSpot : MonoBehaviour
{
	[HideInInspector]
	public FlockChild landingChild;

	[HideInInspector]
	public bool landing;

	private int lerpCounter;

	[HideInInspector]
	public LandingSpotController _controller;

	private bool _idle;

	public Transform _thisT;

	public bool _gotcha;

	public void Start()
	{
		if (_thisT == null)
		{
			_thisT = base.transform;
		}
		if (_controller == null)
		{
			_controller = _thisT.parent.GetComponent<LandingSpotController>();
		}
		if (_controller._autoCatchDelay.x > 0f)
		{
			StartCoroutine(GetFlockChild(_controller._autoCatchDelay.x, _controller._autoCatchDelay.y));
		}
	}

	public void OnDrawGizmos()
	{
		if (_thisT == null)
		{
			_thisT = base.transform;
		}
		if (_controller == null)
		{
			_controller = _thisT.parent.GetComponent<LandingSpotController>();
		}
		Gizmos.color = Color.yellow;
		if (landingChild != null && landing)
		{
			Gizmos.DrawLine(_thisT.position, landingChild._thisT.position);
		}
		if (_thisT.rotation.eulerAngles.x != 0f || _thisT.rotation.eulerAngles.z != 0f)
		{
			_thisT.eulerAngles = new Vector3(0f, _thisT.eulerAngles.y, 0f);
		}
		Gizmos.DrawCube(new Vector3(_thisT.position.x, _thisT.position.y, _thisT.position.z), Vector3.one * _controller._gizmoSize);
		Gizmos.DrawCube(_thisT.position + _thisT.forward * _controller._gizmoSize, Vector3.one * _controller._gizmoSize * 0.5f);
		Gizmos.color = new Color(1f, 1f, 0f, 0.05f);
		Gizmos.DrawWireSphere(_thisT.position, _controller._maxBirdDistance);
	}

	public void LateUpdate()
	{
		if (landingChild == null)
		{
			_gotcha = false;
			_idle = false;
			lerpCounter = 0;
			return;
		}
		if (_gotcha)
		{
			landingChild.transform.position = _thisT.position + landingChild._landingPosOffset;
			RotateBird();
			return;
		}
		if (_controller._flock.gameObject.activeInHierarchy && landing && landingChild != null)
		{
			if (!landingChild.gameObject.activeInHierarchy)
			{
				Invoke("ReleaseFlockChild", 0f);
			}
			float num = Vector3.Distance(landingChild._thisT.position, _thisT.position + landingChild._landingPosOffset);
			if (num < 5f && num > 0.5f)
			{
				if (_controller._soarLand)
				{
					landingChild._model.GetComponent<Animation>().CrossFade(landingChild._spawner._soarAnimation, 0.5f);
					if (num < 2f)
					{
						landingChild._model.GetComponent<Animation>().CrossFade(landingChild._spawner._flapAnimation, 0.5f);
					}
				}
				landingChild._targetSpeed = landingChild._spawner._maxSpeed * _controller._landingSpeedModifier;
				landingChild._wayPoint = _thisT.position + landingChild._landingPosOffset;
				landingChild._damping = _controller._landingTurnSpeedModifier;
				landingChild._avoid = false;
			}
			else if (num <= 0.5f)
			{
				landingChild._wayPoint = _thisT.position + landingChild._landingPosOffset;
				if (num < _controller._snapLandDistance && !_idle)
				{
					_idle = true;
					landingChild._model.GetComponent<Animation>().CrossFade(landingChild._spawner._idleAnimation, 0.55f);
				}
				if (num > _controller._snapLandDistance)
				{
					landingChild._targetSpeed = landingChild._spawner._minSpeed * _controller._landingSpeedModifier;
					landingChild._thisT.position += (_thisT.position + landingChild._landingPosOffset - landingChild._thisT.position) * Time.deltaTime * landingChild._speed * _controller._landingSpeedModifier * 2f;
				}
				else
				{
					_gotcha = true;
				}
				landingChild._move = false;
				RotateBird();
			}
			else
			{
				landingChild._wayPoint = _thisT.position + landingChild._landingPosOffset;
			}
			landingChild._damping += 0.01f;
		}
		StraightenBird();
	}

	public void StraightenBird()
	{
		if (landingChild._thisT.eulerAngles.x != 0f)
		{
			Vector3 eulerAngles = landingChild._thisT.eulerAngles;
			eulerAngles.z = 0f;
			landingChild._thisT.eulerAngles = eulerAngles;
		}
	}

	public void RotateBird()
	{
		if (!_controller._randomRotate || !_idle)
		{
			lerpCounter++;
			Quaternion rotation = landingChild._thisT.rotation;
			Vector3 eulerAngles = rotation.eulerAngles;
			eulerAngles.y = Mathf.LerpAngle(landingChild._thisT.rotation.eulerAngles.y, _thisT.rotation.eulerAngles.y, (float)lerpCounter * Time.deltaTime * _controller._landedRotateSpeed);
			rotation.eulerAngles = eulerAngles;
			landingChild._thisT.rotation = rotation;
		}
	}

	public IEnumerator GetFlockChild(float minDelay, float maxDelay)
	{
		yield return new WaitForSeconds(UnityEngine.Random.Range(minDelay, maxDelay));
		if (!_controller._flock.gameObject.activeInHierarchy || !(landingChild == null))
		{
			yield break;
		}
		FlockChild flockChild = null;
		for (int i = 0; i < _controller._flock._roamers.Count; i++)
		{
			FlockChild flockChild2 = _controller._flock._roamers[i];
			if (flockChild2._landing || flockChild2._dived)
			{
				continue;
			}
			if (!_controller._onlyBirdsAbove)
			{
				if (flockChild == null && _controller._maxBirdDistance > Vector3.Distance(flockChild2._thisT.position, _thisT.position) && _controller._minBirdDistance < Vector3.Distance(flockChild2._thisT.position, _thisT.position))
				{
					flockChild = flockChild2;
					if (!_controller._takeClosest)
					{
						break;
					}
				}
				else if (flockChild != null && Vector3.Distance(flockChild._thisT.position, _thisT.position) > Vector3.Distance(flockChild2._thisT.position, _thisT.position))
				{
					flockChild = flockChild2;
				}
			}
			else if (flockChild == null && flockChild2._thisT.position.y > _thisT.position.y && _controller._maxBirdDistance > Vector3.Distance(flockChild2._thisT.position, _thisT.position) && _controller._minBirdDistance < Vector3.Distance(flockChild2._thisT.position, _thisT.position))
			{
				flockChild = flockChild2;
				if (!_controller._takeClosest)
				{
					break;
				}
			}
			else if (flockChild != null && flockChild2._thisT.position.y > _thisT.position.y && Vector3.Distance(flockChild._thisT.position, _thisT.position) > Vector3.Distance(flockChild2._thisT.position, _thisT.position))
			{
				flockChild = flockChild2;
			}
		}
		if (flockChild != null)
		{
			landingChild = flockChild;
			landing = true;
			landingChild._landing = true;
			if (_controller._autoDismountDelay.x > 0f)
			{
				Invoke("ReleaseFlockChild", UnityEngine.Random.Range(_controller._autoDismountDelay.x, _controller._autoDismountDelay.y));
			}
			_controller._activeLandingSpots++;
		}
		else if (_controller._autoCatchDelay.x > 0f)
		{
			StartCoroutine(GetFlockChild(_controller._autoCatchDelay.x, _controller._autoCatchDelay.y));
		}
	}

	public void InstantLand()
	{
		if (!_controller._flock.gameObject.activeInHierarchy || !(landingChild == null))
		{
			return;
		}
		FlockChild flockChild = null;
		for (int i = 0; i < _controller._flock._roamers.Count; i++)
		{
			FlockChild flockChild2 = _controller._flock._roamers[i];
			if (!flockChild2._landing && !flockChild2._dived)
			{
				flockChild = flockChild2;
			}
		}
		if (flockChild != null)
		{
			landingChild = flockChild;
			landing = true;
			_controller._activeLandingSpots++;
			landingChild._landing = true;
			landingChild._thisT.position = _thisT.position + landingChild._landingPosOffset;
			landingChild._model.GetComponent<Animation>().Play(landingChild._spawner._idleAnimation);
			landingChild._thisT.Rotate(Vector3.up, UnityEngine.Random.Range(0f, 360f));
			if (_controller._autoDismountDelay.x > 0f)
			{
				Invoke("ReleaseFlockChild", UnityEngine.Random.Range(_controller._autoDismountDelay.x, _controller._autoDismountDelay.y));
			}
		}
		else if (_controller._autoCatchDelay.x > 0f)
		{
			StartCoroutine(GetFlockChild(_controller._autoCatchDelay.x, _controller._autoCatchDelay.y));
		}
	}

	public void ReleaseFlockChild()
	{
		if (_controller._flock.gameObject.activeInHierarchy && landingChild != null)
		{
			_gotcha = false;
			lerpCounter = 0;
			if (_controller._featherPS != null)
			{
				_controller._featherPS.position = landingChild._thisT.position;
				_controller._featherPS.GetComponent<ParticleSystem>().Emit(UnityEngine.Random.Range(0, 3));
			}
			landing = false;
			_idle = false;
			landingChild._avoid = true;
			landingChild._damping = landingChild._spawner._maxDamping;
			landingChild._model.GetComponent<Animation>().CrossFade(landingChild._spawner._flapAnimation, 0.2f);
			landingChild._dived = true;
			landingChild._speed = 0f;
			landingChild._move = true;
			landingChild._landing = false;
			landingChild.Flap();
			landingChild._wayPoint = new Vector3(landingChild._wayPoint.x, _thisT.position.y + 10f, landingChild._wayPoint.z);
			if (_controller._autoCatchDelay.x > 0f)
			{
				StartCoroutine(GetFlockChild(_controller._autoCatchDelay.x + 0.1f, _controller._autoCatchDelay.y + 0.1f));
			}
			landingChild = null;
			_controller._activeLandingSpots--;
		}
	}
}
public class LandingSpotController : MonoBehaviour
{
	public bool _randomRotate = true;

	public Vector2 _autoCatchDelay = new Vector2(10f, 20f);

	public Vector2 _autoDismountDelay = new Vector2(10f, 20f);

	public float _maxBirdDistance = 20f;

	public float _minBirdDistance = 5f;

	public bool _takeClosest;

	public FlockController _flock;

	public bool _landOnStart;

	public bool _soarLand = true;

	public bool _onlyBirdsAbove;

	public float _landingSpeedModifier = 0.5f;

	public float _landingTurnSpeedModifier = 5f;

	public Transform _featherPS;

	public Transform _thisT;

	public int _activeLandingSpots;

	public float _snapLandDistance = 0.1f;

	public float _landedRotateSpeed = 0.01f;

	public float _gizmoSize = 0.2f;

	public void Start()
	{
		if (_thisT == null)
		{
			_thisT = base.transform;
		}
		if (_flock == null)
		{
			_flock = (FlockController)UnityEngine.Object.FindObjectOfType(typeof(FlockController));
			UnityEngine.Debug.Log(string.Concat(this, " has no assigned FlockController, a random FlockController has been assigned"));
		}
		if (_landOnStart)
		{
			StartCoroutine(InstantLandOnStart(0.1f));
		}
	}

	public void ScareAll()
	{
		ScareAll(0f, 1f);
	}

	public void ScareAll(float minDelay, float maxDelay)
	{
		for (int i = 0; i < _thisT.childCount; i++)
		{
			if (_thisT.GetChild(i).GetComponent<LandingSpot>() != null)
			{
				_thisT.GetChild(i).GetComponent<LandingSpot>().Invoke("ReleaseFlockChild", UnityEngine.Random.Range(minDelay, maxDelay));
			}
		}
	}

	public void LandAll()
	{
		for (int i = 0; i < _thisT.childCount; i++)
		{
			if (_thisT.GetChild(i).GetComponent<LandingSpot>() != null)
			{
				LandingSpot component = _thisT.GetChild(i).GetComponent<LandingSpot>();
				StartCoroutine(component.GetFlockChild(0f, 2f));
			}
		}
	}

	public IEnumerator InstantLandOnStart(float delay)
	{
		yield return new WaitForSeconds(delay);
		for (int i = 0; i < _thisT.childCount; i++)
		{
			if (_thisT.GetChild(i).GetComponent<LandingSpot>() != null)
			{
				_thisT.GetChild(i).GetComponent<LandingSpot>().InstantLand();
			}
		}
	}

	public IEnumerator InstantLand(float delay)
	{
		yield return new WaitForSeconds(delay);
		for (int i = 0; i < _thisT.childCount; i++)
		{
			if (_thisT.GetChild(i).GetComponent<LandingSpot>() != null)
			{
				_thisT.GetChild(i).GetComponent<LandingSpot>().InstantLand();
			}
		}
	}
}
public class JPG : MonoBehaviour
{
	[Header("GIF Settings")]
	public int imageWidth = 640;

	public int imageHeight = 480;

	private JPGRecorder recorder;

	private CameraInput cameraInput;

	public Camera cam;

	private bool isPhoto;

	public void StartRecording()
	{
		if (!isPhoto)
		{
			isPhoto = true;
			recorder = new JPGRecorder(imageWidth, imageHeight);
			cameraInput = new CameraInput(recorder, new RealtimeClock(), cam);
			cameraInput.frameSkip = 40;
			UnityEngine.Debug.Log(" StartRecording ");
		}
	}

	public async void StopRecording()
	{
		isPhoto = false;
		cameraInput.Dispose();
		string text = await recorder.FinishWriting();
		UnityEngine.Debug.Log("Saved animated jpg image to: " + text);
		Application.OpenURL(((Application.platform == RuntimePlatform.IPhonePlayer) ? "file://" : "") + text);
	}
}
public class JPGButton : MonoBehaviour, IPointerDownHandler, IEventSystemHandler, IPointerUpHandler
{
	public UnityEvent onTouchDown;

	public UnityEvent onTouchUp;

	private void Start()
	{
	}

	private void Update()
	{
	}

	void IPointerDownHandler.OnPointerDown(PointerEventData eventData)
	{
		UnityEngine.Debug.Log(" OnPointerDown ");
		onTouchDown?.Invoke();
	}

	void IPointerUpHandler.OnPointerUp(PointerEventData eventData)
	{
		onTouchUp?.Invoke();
	}
}
public class Engine : MonoBehaviour
{
	public static Engine Instance;

	private void Awake()
	{
		Instance = this;
	}

	private void Start()
	{
		Application.runInBackground = true;
		Screen.sleepTimeout = -1;
		Application.targetFrameRate = 60;
		UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
	}

	private void Update()
	{
		TimerManager.timerList.ForEach(delegate(IAnimatable advance)
		{
			try
			{
				advance.AdvanceTime();
			}
			catch (Exception ex)
			{
				UnityEngine.Debug.LogError(ex.Message);
			}
		});
	}

	private void OnDestroy()
	{
	}
}
public delegate void Handler();
public delegate void Handler<T1>(T1 param1);
public delegate void Handler<T1, T2>(T1 param1, T2 param2);
public delegate void Handler<T1, T2, T3>(T1 param1, T2 param2, T3 param3);
public delegate bool LoopHandler();
public delegate bool LoopHandler<T1>(T1 param1);
public delegate bool LoopHandler<T1, T2>(T1 param1, T2 param2);
public delegate bool LoopHandler<T1, T2, T3>(T1 param1, T2 param2, T3 param3);
public interface IAnimatable
{
	void AdvanceTime();
}
public abstract class TimerBaseManager<T> where T : new()
{
	public class TimerHandler
	{
		public int delay;

		public bool repeat;

		public bool userFrame;

		public long exeTime;

		public Delegate method;

		public object[] args;

		public void clear()
		{
			method = null;
			args = null;
		}
	}

	private static T _instance;

	private List<TimerHandler> _pool = new List<TimerHandler>();

	public List<TimerHandler> _handlers = new List<TimerHandler>();

	private int _currFrame;

	private uint _index;

	public static T instance
	{
		get
		{
			if (_instance == null)
			{
				_instance = new T();
			}
			return _instance;
		}
	}

	public virtual long currentTime => (long)(Time.unscaledTime * 1000f);

	public void AdvanceTime()
	{
		_currFrame++;
		for (int i = 0; i < _handlers.Count; i++)
		{
			TimerHandler timerHandler = _handlers[i];
			long num = (timerHandler.userFrame ? _currFrame : currentTime);
			if (num < timerHandler.exeTime)
			{
				continue;
			}
			Delegate method = timerHandler.method;
			object[] args = timerHandler.args;
			if (timerHandler.repeat)
			{
				while (num >= timerHandler.exeTime)
				{
					timerHandler.exeTime += timerHandler.delay;
					method.DynamicInvoke(args);
				}
			}
			else
			{
				RemoveHandler(timerHandler.method);
				method.DynamicInvoke(args);
			}
		}
	}

	private object create(bool useFrame, bool repeat, bool cover, int delay, Delegate method, params object[] args)
	{
		if ((object)method == null)
		{
			return null;
		}
		if (delay < 1)
		{
			method.DynamicInvoke(args);
			return -1;
		}
		TimerHandler timerHandler = _handlers.Find((TimerHandler han) => han.method == method);
		TimerHandler timerHandler2;
		if (cover && timerHandler != null)
		{
			timerHandler2 = timerHandler;
			_handlers.Remove(timerHandler);
		}
		else if (_pool.Count > 0)
		{
			timerHandler2 = _pool[_pool.Count - 1];
			_pool.Remove(timerHandler2);
		}
		else
		{
			timerHandler2 = new TimerHandler();
		}
		timerHandler2.userFrame = useFrame;
		timerHandler2.repeat = repeat;
		timerHandler2.delay = delay;
		timerHandler2.method = method;
		timerHandler2.args = args;
		timerHandler2.exeTime = delay + (useFrame ? _currFrame : currentTime);
		_handlers.Add(timerHandler2);
		return method;
	}

	public void DoOnce(int delay, Handler method, bool cover = false, params object[] args)
	{
		create(useFrame: false, repeat: false, cover, delay, method, args);
	}

	public void DoOnce<T1>(int delay, Handler<T1> method, bool cover = false, params object[] args)
	{
		create(useFrame: false, repeat: false, cover, delay, method, args);
	}

	public void DoOnce<T1, T2>(int delay, Handler<T1, T2> method, bool cover = false, params object[] args)
	{
		create(useFrame: false, repeat: false, cover, delay, method, args);
	}

	public void DoOnce<T1, T2, T3>(int delay, Handler<T1, T2, T3> method, bool cover = false, params object[] args)
	{
		create(useFrame: false, repeat: false, cover, delay, method, args);
	}

	public void DoLoop(int delay, Handler method, bool cover = false, params object[] args)
	{
		create(useFrame: false, repeat: true, cover, delay, method, args);
	}

	public void DoLoop<T1>(int delay, Handler<T1> method, bool cover = false, params object[] args)
	{
		create(useFrame: false, repeat: true, cover, delay, method, args);
	}

	public void DoLoop<T1, T2>(int delay, Handler<T1, T2> method, bool cover = false, params object[] args)
	{
		create(useFrame: false, repeat: true, cover, delay, method, args);
	}

	public void DoLoop<T1, T2, T3>(int delay, Handler<T1, T2, T3> method, bool cover = false, params object[] args)
	{
		create(useFrame: false, repeat: true, cover, delay, method, args);
	}

	public void DoFrameOnce(int delay, Handler method, bool cover = false, params object[] args)
	{
		create(useFrame: true, repeat: false, cover, delay, method, args);
	}

	public void DoFrameOnce<T1>(int delay, Handler<T1> method, bool cover = false, params object[] args)
	{
		create(useFrame: true, repeat: false, cover, delay, method, args);
	}

	public void DoFrameOnce<T1, T2>(int delay, Handler<T1, T2> method, bool cover = false, params object[] args)
	{
		create(useFrame: true, repeat: false, cover, delay, method, args);
	}

	public void DoFrameOnce<T1, T2, T3>(int delay, Handler<T1, T2, T3> method, bool cover = false, params object[] args)
	{
		create(useFrame: true, repeat: false, cover, delay, method, args);
	}

	public void DoFrameLoop(int delay, Handler method, bool cover = false, params object[] args)
	{
		create(useFrame: true, repeat: true, cover, delay, method, args);
	}

	public void DoFrameLoop<T1>(int delay, Handler<T1> method, bool cover = false, params object[] args)
	{
		create(useFrame: true, repeat: true, cover, delay, method, args);
	}

	public void DoFrameLoop<T1, T2>(int delay, Handler<T1, T2> method, bool cover = false, params object[] args)
	{
		create(useFrame: true, repeat: true, cover, delay, method, args);
	}

	public void DoFrameLoop<T1, T2, T3>(int delay, Handler<T1, T2, T3> method, bool cover = false, params object[] args)
	{
		create(useFrame: true, repeat: true, cover, delay, method, args);
	}

	public void RemoveHandler(Handler method)
	{
		RemoveHandler((Delegate)method);
	}

	public void RemoveHandler<T1>(Handler<T1> method)
	{
		RemoveHandler((Delegate)method);
	}

	public void RemoveHandler<T1, T2>(Handler<T1, T2> method)
	{
		RemoveHandler((Delegate)method);
	}

	public void RemoveHandler<T1, T2, T3>(Handler<T1, T2, T3> method)
	{
		RemoveHandler((Delegate)method);
	}

	private void RemoveHandler(Delegate method)
	{
		List<TimerHandler> list = _handlers.FindAll((TimerHandler t) => t.method == method);
		if (list.Count <= 0)
		{
			return;
		}
		list.ForEach(delegate(TimerHandler a)
		{
			_handlers.Remove(a);
			a.clear();
			if (Engine.Instance != null)
			{
				Engine.Instance.StartCoroutine(AddPool(a));
			}
			else
			{
				_pool.Add(a);
			}
		});
	}

	public IEnumerator AddPool(TimerHandler handler)
	{
		yield return new WaitForSeconds(1f);
		_pool.Add(handler);
	}

	public void RemoveAllHandler()
	{
		while (_handlers.Count > 0)
		{
			RemoveHandler(_handlers[0].method);
		}
	}
}
public class TimerManager : TimerBaseManager<TimerManager>, IAnimatable
{
	public static List<IAnimatable> timerList = new List<IAnimatable>();

	public static long serviceTime;

	public override long currentTime => (long)(Time.unscaledTime * 1000f);

	public TimerManager()
	{
		timerList.Add(this);
	}

	public static void RemoveTimer(IAnimatable timerMgr)
	{
		timerList.Remove(timerMgr);
	}
}
public class TimerUtils
{
	public static string toTimeString(float time_seconds)
	{
		int num = (int)time_seconds / 3600;
		int num2 = (int)time_seconds % 3600 / 60;
		int num3 = (int)time_seconds % 3600 % 60;
		return $"{num:D2}:{num2:D2}:{num3:D2}";
	}

	public static bool ToDayNum(long time_seconds)
	{
		return (int)(time_seconds / 3600000 / 24) > 30;
	}

	public static string ToTimeStringMS(float time_seconds)
	{
		int num = (int)time_seconds / 60;
		int num2 = (int)time_seconds % 60;
		return $"{num:D2}:{num2:D2}";
	}

	public static string timeDifference(long endTime)
	{
		return $"{timeDifferenceInt(endTime):D2}";
	}

	public static int timeDifferenceInt(long endTime)
	{
		return (int)((endTime - TimerManager.serviceTime) / 1000);
	}

	public static long GetTimeStamp()
	{
		return (long)(DateTime.Now - new DateTime(1970, 1, 1, 0, 0, 0).ToLocalTime()).TotalMilliseconds;
	}

	public static long GetNowTimeStamp(string time)
	{
		DateTime dateTime = Convert.ToDateTime(time);
		DateTime dateTime2 = TimeZone.CurrentTimeZone.ToLocalTime(new DateTime(1970, 1, 1, 0, 0, 0, 0));
		return (dateTime.Ticks - dateTime2.Ticks) / 10000;
	}

	public static string GetTimeStamp(DateTime time)
	{
		return ConvertDateTimeToInt(time).ToString();
	}

	public static long ConvertDateTimeToInt(DateTime time)
	{
		return Convert.ToInt64((time - new DateTime(1970, 1, 1, 0, 0, 0, 0)).TotalSeconds);
	}

	public static long GetLongTime(DateTime time1, DateTime time2)
	{
		return Convert.ToInt64((time1 - time2).TotalSeconds);
	}
}
public class UiCanvas : MonoBehaviour
{
	private Text uiText;

	private Text btnText;

	public ReplayCam cam;

	private int timeNum;

	private RecordType recordType;

	private void Awake()
	{
		uiText = base.transform.Find("Text").GetComponent<Text>();
		btnText = base.transform.Find("Button/Text").GetComponent<Text>();
	}

	private void Start()
	{
		base.transform.Find("Button").GetComponent<Button>().onClick.AddListener(Btn);
	}

	private void OnEnable()
	{
		recordType = RecordType.Null;
		SetRecordType();
	}

	private void Btn()
	{
		SetRecordType();
	}

	private void SetRecordType()
	{
		switch (recordType)
		{
		case RecordType.Null:
			recordType = RecordType.StartRecord;
			uiText.text = "";
			break;
		case RecordType.StartRecord:
			StartRectord();
			recordType = RecordType.StopRecord;
			break;
		case RecordType.StopRecord:
			StopRectord();
			recordType = RecordType.StartRecord;
			break;
		}
		btnText.text = ((recordType == RecordType.StopRecord) ? "停止录屏" : "开始录屏");
	}

	private void Update()
	{
	}

	public void StartRectord()
	{
		timeNum = 0;
		cam.StartRecording();
		TimerBaseManager<TimerManager>.instance.DoLoop(1000, SetTimeText, false);
	}

	public void StopRectord()
	{
		cam.StopRecording();
		TimerBaseManager<TimerManager>.instance.RemoveHandler(SetTimeText);
		uiText.text = "视屏保存完成,时长:" + timeNum + "秒";
	}

	public void SetTimeText()
	{
		timeNum++;
		uiText.text = "录屏时长:" + timeNum + "秒";
	}

	private void replayAction()
	{
		uiText.text = "视屏保存完成,时长:" + timeNum + "秒";
	}
}
public enum RecordType
{
	Null,
	StartRecord,
	StopRecord
}
public class AppConfig
{
	public PaperType paperType;

	public int paperIndex;

	public int sealIndex;

	public int sealNameIndex = -1;

	public int sealGameIndex;

	public int audioToggle = 1;

	public double audioVolume = 0.5;

	public int fontType;
}
public class ChineseBrushMain : MonoBehaviour
{
	public TableManager tableManager;

	public Transform rightHand;

	public RawImage paperImage;

	public LayerMask drawLayer;

	public LayerMask colorLayer;

	public LayerMask penLayer;

	public LayerMask sealLayer;

	public LayerMask inkstoneLayer;

	public GameObject controller;

	public PenConfig[] penConfigs;

	public SealConfig[] sealConfigs;

	public PaintingChineseBrush chineseBrush;

	private bool isDown;

	private Transform rayTransform;

	private Ray ray;

	private RaycastHit hitinfo;

	private PenConfig curPenConfig;

	private bool isChange;

	private InkstoneConfig curInkstoneConfig;

	private bool isSealDown;

	private Vector3 lastPoint = GlobeConfig.errorPoint;

	private SelectGame showTipGame;

	private void Awake()
	{
		BaseManager<HttpDataManager>.Instance.CheckData();
		AddListeners();
		SetPenConfig(penConfigs[0]);
		SetColor(BaseManager<ColorManager>.Instance.GetColor);
		GlobeConfig.pickGameType = PickGameType.None;
		GlobeConfig.selectType = SelectType.None;
		tableManager.PickGame(0);
		SetSelect();
		rightHand = controller.transform;
	}

	private void Update()
	{
		SelectGameObject();
		if (rayTransform == null)
		{
			return;
		}
		bool flag = false;
		ray.direction = -rayTransform.up;
		ray.origin = rayTransform.position;
		switch (GlobeConfig.pickGameType)
		{
		case PickGameType.Pen:
			if (Physics.Raycast(ray, out hitinfo, 0.3f, inkstoneLayer.value))
			{
				flag = true;
				if (hitinfo.collider.GetComponent<InkstoneConfig>() != null)
				{
					SetBrushAlpha(1f, isRecover: true);
				}
			}
			if (!Physics.Raycast(ray, out hitinfo, 0.3f, drawLayer.value))
			{
				break;
			}
			flag = true;
			if (hitinfo.distance <= curPenConfig.centerLength)
			{
				List<Vector3> list = curPenConfig.SetBrushDirection(hitinfo.point);
				isDown = true;
				if (list.Count > 0)
				{
					float[] array = new float[list.Count];
					for (int i = 0; i < list.Count; i++)
					{
						array[i] = GetPenBrushSize(hitinfo.point, i, list.Count);
					}
					PenBrushs(list.ToArray(), array);
				}
				if (lastPoint != GlobeConfig.errorPoint)
				{
					SetBrushAlpha(Vector3.Distance(lastPoint, hitinfo.point) / 10f);
				}
				lastPoint = hitinfo.point;
			}
			else
			{
				curPenConfig.SetBrushDirection(hitinfo.point, isReset: false, isLookReset: true);
				chineseBrush.OnMouseMoveUps();
			}
			break;
		case PickGameType.Seal:
			if (Physics.Raycast(ray, out hitinfo, 0.15f, drawLayer.value))
			{
				flag = true;
				if (!isSealDown && hitinfo.distance <= 0.1f)
				{
					isSealDown = true;
					Vector2 sealSize = sealConfigs[tableManager.sealIndex].sealSize;
					Texture seal = chineseBrush.seal;
					sealSize *= 1000f;
					chineseBrush.DrawSeal(hitinfo.point, sealSize, seal);
				}
			}
			break;
		}
		if (!flag && (isDown || isSealDown) && (bool)chineseBrush)
		{
			isSealDown = false;
			isDown = false;
			curPenConfig.SetBrushDirection(BezierCurse.errorPoint, isReset: true);
			chineseBrush.OnMouseMoveUps();
		}
		ColorShade();
	}

	private void OnApplicationQuit()
	{
		JsonMgr.Instance.SaveData(GlobeConfig.ArtInfoManager, GlobeConfig.ArtFileName);
		JsonMgr.Instance.SaveData(GlobeConfig.SealManager, GlobeConfig.SealFileName);
		JsonMgr.Instance.SaveData(GlobeConfig.AppConfig, GlobeConfig.AppConfigFileName, JsonType.JsonUtlity);
	}

	private void SelectGameObject()
	{
		bool flag = Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.TRIGGER);
		ray.direction = rightHand.forward;
		ray.origin = rightHand.position;
		if (Physics.Raycast(ray, out hitinfo, 10f, penLayer.value | sealLayer.value))
		{
			SelectGame selectGame = hitinfo.collider.GetComponent<SelectGame>();
			if (!selectGame)
			{
				return;
			}
			PickGameType pickGameType = selectGame.pickGameType;
			if (pickGameType != PickGameType.Pen && pickGameType == PickGameType.Seal)
			{
				selectGame = tableManager.seals[tableManager.sealIndex];
			}
			selectGame.ShowTip();
			if (showTipGame != null && showTipGame != selectGame)
			{
				showTipGame.HideTip();
			}
			showTipGame = selectGame;
			if (!flag)
			{
				return;
			}
			showTipGame.HideTip();
			showTipGame = null;
			switch (selectGame.pickGameType)
			{
			case PickGameType.Pen:
				if (((bool)selectGame.meshRenderer && selectGame.meshRenderer.enabled) || ((bool)selectGame.skinnedMeshRenderer && selectGame.skinnedMeshRenderer.enabled))
				{
					GlobeConfig.pickGameType = PickGameType.Pen;
					GlobeConfig.selectType = SelectType.Pen;
				}
				else
				{
					GlobeConfig.pickGameType = PickGameType.None;
					GlobeConfig.selectType = SelectType.None;
				}
				tableManager.PickGame(selectGame.Index);
				SetSelect();
				break;
			case PickGameType.Seal:
				if (((bool)selectGame.meshRenderer && selectGame.meshRenderer.enabled) || ((bool)selectGame.skinnedMeshRenderer && selectGame.skinnedMeshRenderer.enabled))
				{
					GlobeConfig.pickGameType = PickGameType.Seal;
					GlobeConfig.selectType = SelectType.Seal;
				}
				else
				{
					GlobeConfig.pickGameType = PickGameType.None;
					GlobeConfig.selectType = SelectType.None;
				}
				tableManager.PickGame(selectGame.Index);
				SetSelect();
				break;
			}
		}
		else if ((bool)showTipGame)
		{
			showTipGame.HideTip();
			showTipGame = null;
		}
	}

	private void AddListeners()
	{
		BaseManager<EventCenter>.Instance.AddEventListener<PenConfig>(EventNames.SetPenConfig, SetPenConfig);
		BaseManager<EventCenter>.Instance.AddEventListener<Vector2>(EventNames.SetPapaerSize, SetPaperSize);
		BaseManager<EventCenter>.Instance.AddEventListener<Color>(EventNames.SetColor, SetColor);
		BaseManager<EventCenter>.Instance.AddEventListener(EventNames.SelectSeal, SelectSeal);
	}

	public void SetPenConfig(PenConfig penConfig)
	{
		curPenConfig = penConfig;
		rayTransform = curPenConfig.rayGame.transform;
	}

	public void SetSelect()
	{
		switch (GlobeConfig.selectType)
		{
		case SelectType.None:
			SelectNone();
			break;
		case SelectType.Pen:
			SelectPen();
			break;
		case SelectType.Seal:
			SelectSeal();
			break;
		}
	}

	private void SelectNone()
	{
		if (GlobeConfig.selectType == SelectType.None)
		{
			rayTransform = null;
			for (int i = 0; i < penConfigs.Length; i++)
			{
				GlobeConfig.SetActive(penConfigs[i].transform.gameObject, active: false);
			}
			for (int j = 0; j < sealConfigs.Length; j++)
			{
				GlobeConfig.SetActive(sealConfigs[j].transform.gameObject, active: false);
			}
			GlobeConfig.SetActive(controller, active: true);
		}
	}

	private void SelectPen()
	{
		if (GlobeConfig.selectType == SelectType.Pen)
		{
			rayTransform = penConfigs[tableManager.penIndex].rayGame.transform;
			SetPenConfig(penConfigs[tableManager.penIndex]);
			for (int i = 0; i < penConfigs.Length; i++)
			{
				GlobeConfig.SetActive(penConfigs[i].transform.gameObject, tableManager.penIndex == i);
			}
			for (int j = 0; j < sealConfigs.Length; j++)
			{
				GlobeConfig.SetActive(sealConfigs[j].transform.gameObject, active: false);
			}
			GlobeConfig.SetActive(controller, active: false);
		}
	}

	private void SelectSeal()
	{
		if (GlobeConfig.selectType == SelectType.Seal)
		{
			for (int i = 0; i < penConfigs.Length; i++)
			{
				GlobeConfig.SetActive(penConfigs[i].transform.gameObject, active: false);
			}
			rayTransform = sealConfigs[tableManager.penIndex].rayGame.transform;
			for (int j = 0; j < sealConfigs.Length; j++)
			{
				GlobeConfig.SetActive(sealConfigs[j].transform.gameObject, tableManager.sealIndex == j);
			}
			GlobeConfig.SetActive(controller, active: false);
		}
	}

	public void SetPaperSize(Vector2 size)
	{
		paperImage.rectTransform.sizeDelta = size;
		BoxCollider component = paperImage.GetComponent<BoxCollider>();
		if ((bool)component)
		{
			component.size = new Vector3(size.x, size.y, 1f);
		}
	}

	public void SetBrushAlpha(float alpha, bool isRecover = false)
	{
		alpha = ((!isRecover) ? ((1f - alpha) * chineseBrush.curColor.a) : (alpha + chineseBrush.curColor.a));
		chineseBrush.curColor.a = Mathf.Max(Mathf.Min(alpha, 1f), 0f);
	}

	public void SetColor(Color color)
	{
		chineseBrush.curColor = color;
		for (int i = 0; i < penConfigs.Length; i++)
		{
			penConfigs[i].SetPenBrushColor(color);
		}
	}

	private void ColorShade()
	{
		if (rayTransform == null || GlobeConfig.selectType == SelectType.Seal)
		{
			return;
		}
		ray.direction = -rayTransform.up;
		ray.origin = rayTransform.position;
		if (!Physics.Raycast(ray, out hitinfo, 0.3f, colorLayer.value))
		{
			return;
		}
		if (hitinfo.distance <= curPenConfig.centerLength)
		{
			if (!curInkstoneConfig || curInkstoneConfig.gameObject.name != hitinfo.collider.name)
			{
				curInkstoneConfig = hitinfo.collider.GetComponent<InkstoneConfig>();
			}
			isChange = true;
			float num = Vector3.Distance(hitinfo.point, curPenConfig.transform.position) / curPenConfig.headLength;
			BaseManager<ColorManager>.Instance.OnColorShade(curInkstoneConfig.color, num * Time.deltaTime);
		}
		else if (isChange)
		{
			SetColor(BaseManager<ColorManager>.Instance.GetColor);
		}
	}

	public void PenBrushs(Vector3[] worldPoints, float[] sizes)
	{
		if (!isDown)
		{
			chineseBrush.SaveTexture();
			isDown = true;
		}
		chineseBrush.OnMouseMoves(worldPoints, sizes);
	}

	public bool PenBrush(Vector3 world_point, float size)
	{
		if (!isDown)
		{
			chineseBrush.SaveTexture();
			isDown = true;
		}
		chineseBrush.OnMouseMove(world_point, size);
		return true;
	}

	private float GetPenBrushSize(Vector3 world_point, int index, int count)
	{
		return curPenConfig.GetPenBrushSize(world_point, index, count);
	}
}
public class PaperTypeController : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
	}
}
public class ShowController : MonoBehaviour
{
	public Camera showCamera;

	public GameObject sealsParent;

	public GameObject inkstonesParent;

	public RawImage showSealPanel;

	public RawImage showInkstonePanel;

	private GameObject[] seals;

	private GameObject[] inkstones;

	[NonSerialized]
	public AssetsGameType assetsGameType;

	[NonSerialized]
	public int assetsIndex;

	private RenderTexture cameraSealTexture;

	private RenderTexture cameraInkstoneTexture;

	public void Awake()
	{
		seals = new GameObject[sealsParent.transform.childCount];
		inkstones = new GameObject[inkstonesParent.transform.childCount];
		for (int i = 0; i < seals.Length; i++)
		{
			seals[i] = sealsParent.transform.GetChild(i).gameObject;
			GlobeConfig.SetActive(seals[i], active: false);
		}
		for (int j = 0; j < inkstones.Length; j++)
		{
			inkstones[j] = inkstonesParent.transform.GetChild(j).gameObject;
			GlobeConfig.SetActive(inkstones[j], active: false);
		}
		cameraSealTexture = new RenderTexture((int)showSealPanel.rectTransform.sizeDelta.x, (int)showSealPanel.rectTransform.sizeDelta.y, (int)showCamera.depth, RenderTextureFormat.ARGB32);
		cameraInkstoneTexture = new RenderTexture((int)showInkstonePanel.rectTransform.sizeDelta.x, (int)showInkstonePanel.rectTransform.sizeDelta.y, (int)showCamera.depth, RenderTextureFormat.ARGB32);
		showCamera.targetTexture = cameraSealTexture;
		showSealPanel.texture = cameraSealTexture;
		showInkstonePanel.texture = cameraInkstoneTexture;
	}

	public void LeftEvent()
	{
		RotateController(Vector2.zero, isBack: true);
		assetsIndex--;
		assetsIndex = ((assetsIndex >= 0) ? assetsIndex : 0);
		Show(assetsGameType, assetsIndex);
	}

	public void RightEvent()
	{
		switch (assetsGameType)
		{
		case AssetsGameType.Seal:
			RotateController(Vector2.zero, isBack: true);
			assetsIndex++;
			assetsIndex = ((assetsIndex > seals.Length - 1) ? (seals.Length - 1) : assetsIndex);
			Show(assetsGameType, assetsIndex);
			break;
		case AssetsGameType.Inkstone:
			RotateController(Vector2.zero, isBack: true);
			assetsIndex++;
			assetsIndex = ((assetsIndex > inkstones.Length - 1) ? (inkstones.Length - 1) : assetsIndex);
			Show(assetsGameType, assetsIndex);
			break;
		}
	}

	public void Show(AssetsGameType type, int index)
	{
		if (assetsGameType != type)
		{
			RotateController(Vector2.zero, isBack: true);
		}
		assetsIndex = ((index >= 0) ? index : 0);
		assetsGameType = type;
		switch (type)
		{
		case AssetsGameType.Seal:
		{
			if (showCamera.targetTexture != cameraSealTexture)
			{
				showCamera.targetTexture = cameraSealTexture;
			}
			for (int k = 0; k < seals.Length; k++)
			{
				GlobeConfig.SetActive(seals[k], k == assetsIndex);
			}
			for (int l = 0; l < inkstones.Length; l++)
			{
				GlobeConfig.SetActive(inkstones[l], active: false);
			}
			break;
		}
		case AssetsGameType.Inkstone:
		{
			if (showCamera.targetTexture != cameraInkstoneTexture)
			{
				showCamera.targetTexture = cameraInkstoneTexture;
			}
			for (int i = 0; i < seals.Length; i++)
			{
				GlobeConfig.SetActive(seals[i], active: false);
			}
			for (int j = 0; j < inkstones.Length; j++)
			{
				GlobeConfig.SetActive(inkstones[j], j == assetsIndex);
			}
			break;
		}
		}
	}

	public void RotateController(Vector2 rotate, bool isBack)
	{
		switch (assetsGameType)
		{
		case AssetsGameType.Seal:
			if (isBack)
			{
				sealsParent.transform.eulerAngles = new Vector3(0f, 0f, 0f);
			}
			else
			{
				sealsParent.transform.eulerAngles += new Vector3(0f, 0f - rotate.x, 0f);
			}
			break;
		case AssetsGameType.Inkstone:
			if (isBack)
			{
				inkstonesParent.transform.eulerAngles = new Vector3(0f, 0f, 0f);
			}
			else
			{
				inkstonesParent.transform.eulerAngles += new Vector3(0f, 0f - rotate.x, 0f);
			}
			break;
		}
	}
}
public enum SendType
{
	Image,
	Video,
	Seal
}
public enum SealType
{
	Name_Seal,
	Idle_Seal,
	Identification_Seal
}
public class ArtPostInfo
{
	public string id = "";

	public string artwork_image_id = "";

	public string artwork_video_id = "";

	public string artwork_seal_id = "";

	public string artwork_res_image_id = "";
}
public class SealPostInfo
{
	public string id = "";

	public string seal_type = "";

	public string seal_text = "";

	public string seal_font = "";

	public string seal_file_id = "";
}
public struct UploadInfo
{
	public string[] urls;

	public string[] prefixs;

	public byte[][] filebytes;

	public List<qiniuyun_DataRequestResult> results;
}
public class SealItem
{
	public string id { get; set; }

	public int seal_type { get; set; }

	public string seal_txt { get; set; }

	public string seal_font { get; set; }

	public string created_at { get; set; }

	public string updated_at { get; set; }

	public string seal_file_url { get; set; }
}
public class SealData
{
	public List<SealItem> data { get; set; }
}
public class WorkItem
{
	public string id { get; set; }

	public int status { get; set; }

	public string created_at { get; set; }

	public string updated_at { get; set; }

	public string artwork_image_url { get; set; }

	public string artwork_video_url { get; set; }

	public string artwork_res_image { get; set; }

	public SealInfo seal { get; set; }
}
public class WorkData
{
	public List<WorkItem> data { get; set; }
}
public class HttpDataManager : BaseManager<HttpDataManager>
{
	public bool isCloseNet;

	public void CheckData()
	{
		UnityWebRequestHelper.Instance.Get(UrlUtils.baseUrl_brush + UrlUtils.artUrl, delegate(RequestStatus getStatus, string getSesults)
		{
			bool flag2 = false;
			if (getStatus == RequestStatus.success)
			{
				WorkData workData = JsonMgr.Instance.ToObejct<WorkData>(getSesults);
				for (int k = 0; k < GlobeConfig.ArtInfoManager.artInfos.Count; k++)
				{
					bool isSelf2 = isContain(workData.data, GlobeConfig.ArtInfoManager.artInfos[k], (WorkItem workItem, ArtInfo artInfo) => workItem.id == artInfo.artPostInfo.id);
					GlobeConfig.ArtInfoManager.artInfos[k].isSelf = isSelf2;
				}
				int loadIndex2 = 0;
				for (int l = 0; l < workData.data.Count; l++)
				{
					if (!isContain(GlobeConfig.ArtInfoManager.artInfos, workData.data[l], (ArtInfo artInfo, WorkItem workItem) => workItem.id == artInfo.artPostInfo.id))
					{
						flag2 = true;
						string assetPath = ((workData.data[l].artwork_video_url != null && workData.data[l].artwork_video_url != "") ? GlobeConfig.VideoTexturePaths : GlobeConfig.AssetsPath);
						DownLoadFile(assetPath, workData.data[l].artwork_image_url, l, delegate(string imageName, int index0)
						{
							if (imageName == "")
							{
								loadIndex2++;
								if (loadIndex2 == workData.data.Count)
								{
									BaseManager<EventCenter>.Instance.EventTrigger(EventNames.InitWorkArt);
								}
							}
							else
							{
								string assetPath2 = ((workData.data[index0].artwork_video_url != null && workData.data[index0].artwork_video_url != "") ? GlobeConfig.VideoTexturePaths : GlobeConfig.AssetsPath);
								DownLoadFile(assetPath2, workData.data[index0].artwork_res_image, index0, delegate(string res_imageName, int index1)
								{
									if (res_imageName == "")
									{
										int num = loadIndex2;
										loadIndex2 = num + 1;
										if (loadIndex2 == workData.data.Count)
										{
											BaseManager<EventCenter>.Instance.EventTrigger(EventNames.InitWorkArt);
										}
									}
									else
									{
										DownLoadFile(GlobeConfig.VideoPaths, workData.data[index1].artwork_video_url, index1, delegate(string videoName, int index2)
										{
											ArtInfo artInfo2 = new ArtInfo();
											artInfo2.imagePath = imageName;
											artInfo2.imageResPath = res_imageName;
											artInfo2.videoPath = videoName;
											artInfo2.isSelf = true;
											artInfo2.artPostInfo = new ArtPostInfo();
											artInfo2.artPostInfo.id = workData.data[index2].id;
											artInfo2.artPostInfo.artwork_image_id = workData.data[index2].artwork_image_url;
											artInfo2.artPostInfo.artwork_seal_id = workData.data[index2].seal?.sealPostInfo?.seal_file_id;
											artInfo2.artPostInfo.artwork_video_id = workData.data[index2].artwork_video_url;
											artInfo2.artPostInfo.artwork_res_image_id = workData.data[index2].artwork_res_image;
											GlobeConfig.ArtInfoManager.artInfos.Add(artInfo2);
											int num2 = loadIndex2;
											loadIndex2 = num2 + 1;
											if (loadIndex2 == workData.data.Count)
											{
												BaseManager<EventCenter>.Instance.EventTrigger(EventNames.InitWorkArt);
											}
										});
									}
								});
							}
						});
					}
				}
			}
			if (!flag2)
			{
				BaseManager<EventCenter>.Instance.EventTrigger(EventNames.InitWorkArt);
			}
		});
		UnityWebRequestHelper.Instance.Get(UrlUtils.baseUrl_brush + UrlUtils.sealUrl, delegate(RequestStatus getStatus, string getSesults)
		{
			bool flag = false;
			if (getStatus == RequestStatus.success)
			{
				SealData sealData = JsonMgr.Instance.ToObejct<SealData>(getSesults);
				for (int i = 0; i < GlobeConfig.SealManager.sealPostInfos.Count; i++)
				{
					bool isSelf = isContain(sealData.data, GlobeConfig.SealManager.sealPostInfos[i], (SealItem sealItem, SealInfo sealInfo) => sealItem.id == sealInfo.sealPostInfo.id);
					GlobeConfig.SealManager.sealPostInfos[i].isSelf = isSelf;
				}
				int loadIndex = 0;
				for (int j = 0; j < sealData.data.Count; j++)
				{
					if (!isContain(GlobeConfig.SealManager.sealPostInfos, sealData.data[j], (SealInfo sealInfo, SealItem sealItem) => sealItem.id == sealInfo.sealPostInfo.id))
					{
						flag = true;
						DownLoadFile(GlobeConfig.AssetsPath, sealData.data[j].seal_file_url, j, delegate(string fileName, int index)
						{
							loadIndex++;
							SealInfo sealInfo2 = new SealInfo();
							sealInfo2.sealPath = fileName;
							sealInfo2.sealPostInfo = new SealPostInfo();
							sealInfo2.sealPostInfo.seal_type = sealData.data[index].seal_type.ToString();
							sealInfo2.sealPostInfo.seal_file_id = sealData.data[index].id;
							sealInfo2.sealPostInfo.seal_font = sealData.data[index].seal_font;
							sealInfo2.sealPostInfo.seal_text = sealData.data[index].seal_txt;
							GlobeConfig.SealManager.sealPostInfos.Add(sealInfo2);
							if (loadIndex == sealData.data.Count)
							{
								BaseManager<EventCenter>.Instance.EventTrigger(EventNames.InitSealConfig);
							}
						});
					}
				}
			}
			if (!flag)
			{
				BaseManager<EventCenter>.Instance.EventTrigger(EventNames.InitSealConfig);
			}
		});
	}

	private bool isContain<T1, T2>(List<T1> listArr, T2 item, Func<T1, T2, bool> equalFunc)
	{
		for (int i = 0; i < listArr.Count; i++)
		{
			if (equalFunc(listArr[i], item))
			{
				return true;
			}
		}
		return false;
	}

	private void DownLoadFile(string assetPath, string path, int index, Action<string, int> action)
	{
		if (path == null || path == "")
		{
			action?.Invoke("", index);
			return;
		}
		Singleton<MiniMonoBehaviour>.Instance.StartCoroutine(LoadManager.LoadFile(path, delegate(byte[] data)
		{
			if (data == null)
			{
				action?.Invoke("", index);
			}
			else
			{
				string[] array = path.Split('/');
				string text = assetPath + "/" + array[^1];
				BaseManager<AssetsManager>.Instance.SaveBytes(assetPath, text, data);
				action?.Invoke(text, index);
			}
		}));
	}

	public void SaveWorkDatas(string imagePath, string resPath, string videoPath, SendType sendType, Action<ArtPostInfo> callback)
	{
		if (isCloseNet)
		{
			ArtPostInfo obj = new ArtPostInfo();
			callback(obj);
			return;
		}
		byte[][] fileBytes = GetFileBytes(imagePath, resPath, videoPath, sendType);
		UploadInfo uploadInfo = GetUploadInfo(sendType, fileBytes);
		UploadFiles(0, uploadInfo, delegate(List<qiniuyun_DataRequestResult> result)
		{
			ArtPostInfo artPostInfo = new ArtPostInfo();
			if (result != null)
			{
				artPostInfo.artwork_image_id = result[0].id;
				SendType sendType2 = sendType;
				if (sendType2 == SendType.Video)
				{
					artPostInfo.artwork_video_id = result[2].id;
				}
				else
				{
					artPostInfo.artwork_video_id = "";
				}
				artPostInfo.artwork_seal_id = "";
				artPostInfo.artwork_res_image_id = result[1].id;
				WWWForm sendWorkForm = GetSendWorkForm(sendType, result);
				string url = UrlUtils.baseUrl_brush + UrlUtils.artUrl;
				UnityWebRequestHelper.Instance.Post(url, sendWorkForm, delegate(RequestStatus status, string results)
				{
					if (status == RequestStatus.success)
					{
						UnityWebRequestHelper.Instance.Get(UrlUtils.baseUrl_brush + UrlUtils.artUrl, delegate(RequestStatus getStatus, string getSesults)
						{
							if (getStatus == RequestStatus.success)
							{
								WorkData workData = JsonMgr.Instance.ToObejct<WorkData>(getSesults);
								artPostInfo.id = workData.data[workData.data.Count - 1].id;
								callback(artPostInfo);
							}
							else
							{
								callback(artPostInfo);
							}
						});
					}
					else
					{
						callback(artPostInfo);
					}
				});
			}
			else
			{
				callback(artPostInfo);
			}
		});
	}

	public void SaveSealDatas(string sealPath, SealType sealType, string font, string text, Action<SealPostInfo> callback)
	{
		if (isCloseNet)
		{
			SealPostInfo obj = new SealPostInfo();
			callback(obj);
			return;
		}
		SendType sendType = SendType.Seal;
		byte[][] fileBytes = GetFileBytes(sealPath, "", "", sendType);
		UploadInfo uploadInfo = GetUploadInfo(sendType, fileBytes);
		UploadFiles(0, uploadInfo, delegate(List<qiniuyun_DataRequestResult> result)
		{
			SealPostInfo sealPostInfo = new SealPostInfo();
			if (result != null)
			{
				string url = UrlUtils.baseUrl_brush + UrlUtils.artUrl;
				sealPostInfo.seal_type = sealType.ToString();
				sealPostInfo.seal_file_id = result[0].id;
				sealPostInfo.seal_font = font;
				sealPostInfo.seal_text = text;
				WWWForm sealForm = GetSealForm(sealPostInfo);
				UnityWebRequestHelper.Instance.Post(url, sealForm, delegate(RequestStatus status, string results)
				{
					if (status == RequestStatus.success)
					{
						UnityWebRequestHelper.Instance.Get(UrlUtils.baseUrl_brush + UrlUtils.sealUrl, delegate(RequestStatus getStatus, string getSesults)
						{
							if (getStatus == RequestStatus.success)
							{
								SealData sealData = JsonMgr.Instance.ToObejct<SealData>(getSesults);
								sealPostInfo.id = sealData.data[sealData.data.Count - 1].id;
								callback(sealPostInfo);
							}
							else
							{
								callback(sealPostInfo);
							}
						});
					}
					else
					{
						callback(sealPostInfo);
					}
				});
			}
			else
			{
				callback(sealPostInfo);
			}
		});
	}

	public void EditorWorkData(ArtPostInfo artPostInfo, Action callback)
	{
		if (artPostInfo.id != null && artPostInfo.id != "")
		{
			string url = UrlUtils.baseUrl_brush + UrlUtils.artUrl + "{" + artPostInfo.id + "}";
			WWWForm workForn = GetWorkForn(artPostInfo);
			UnityWebRequestHelper.Instance.Post(url, workForn, delegate(RequestStatus status, string results)
			{
				if (status == RequestStatus.success)
				{
					callback();
				}
				else
				{
					callback();
				}
			});
		}
		else
		{
			callback();
		}
	}

	public void DeleteWorkData(ArtPostInfo artPostInfo, Action callback)
	{
		if (isCloseNet)
		{
			callback();
		}
		else if (artPostInfo.id != null && artPostInfo.id != "")
		{
			string url = UrlUtils.baseUrl_brush + UrlUtils.artDeleteUrl;
			WWWForm wWWForm = new WWWForm();
			wWWForm.AddField("id", artPostInfo.id);
			UnityWebRequestHelper.Instance.Post(url, wWWForm, delegate(RequestStatus status, string results)
			{
				if (status == RequestStatus.success)
				{
					callback();
				}
				else
				{
					callback();
				}
			});
		}
		else
		{
			callback();
		}
	}

	public void DeleteSealData(SealPostInfo sealPostInfo, Action callback)
	{
		if (isCloseNet)
		{
			callback();
		}
		else if (sealPostInfo.id != null && sealPostInfo.id != "")
		{
			string url = UrlUtils.baseUrl_brush + UrlUtils.sealDeleteUrl;
			WWWForm wWWForm = new WWWForm();
			wWWForm.AddField("id", sealPostInfo.id);
			UnityWebRequestHelper.Instance.Post(url, wWWForm, delegate(RequestStatus status, string results)
			{
				if (status == RequestStatus.success)
				{
					callback();
				}
				else
				{
					callback();
				}
			});
		}
		else
		{
			callback();
		}
	}

	public byte[][] GetFileBytes(string imagePath, string resPath, string videoPath, SendType sendType)
	{
		List<string> list = new List<string>(3);
		switch (sendType)
		{
		case SendType.Image:
			list.Add(imagePath);
			list.Add(resPath);
			break;
		case SendType.Video:
			list.Add(imagePath);
			list.Add(resPath);
			list.Add(videoPath);
			break;
		case SendType.Seal:
			list.Add(imagePath);
			break;
		}
		byte[][] array = new byte[list.Count][];
		for (int i = 0; i < list.Count; i++)
		{
			array[i] = File.ReadAllBytes(list[i]);
		}
		return array;
	}

	public WWWForm GetSendWorkForm(SendType sendType, List<qiniuyun_DataRequestResult> result)
	{
		WWWForm result2 = new WWWForm();
		switch (sendType)
		{
		case SendType.Image:
		{
			ArtPostInfo artPostInfo2 = new ArtPostInfo
			{
				artwork_image_id = result[0].id,
				artwork_video_id = "",
				artwork_seal_id = "",
				artwork_res_image_id = result[1].id
			};
			result2 = GetWorkForn(artPostInfo2);
			break;
		}
		case SendType.Video:
		{
			ArtPostInfo artPostInfo = new ArtPostInfo
			{
				artwork_image_id = result[0].id,
				artwork_video_id = result[2].id,
				artwork_seal_id = "",
				artwork_res_image_id = result[1].id
			};
			result2 = GetWorkForn(artPostInfo);
			break;
		}
		}
		return result2;
	}

	public UploadInfo GetUploadInfo(SendType sendType, byte[][] bytes)
	{
		UploadInfo result = default(UploadInfo);
		result.filebytes = bytes;
		string text = "Image";
		string text2 = "Video";
		string text3 = UrlUtils.baseUrl_brush + UrlUtils.Qiniuyun_Token;
		switch (sendType)
		{
		case SendType.Image:
			result.urls = new string[2] { text3, text3 };
			result.prefixs = new string[2] { text, text };
			result.results = new List<qiniuyun_DataRequestResult>(2);
			break;
		case SendType.Video:
			result.urls = new string[3] { text3, text3, text3 };
			result.prefixs = new string[3] { text, text, text2 };
			result.results = new List<qiniuyun_DataRequestResult>(3);
			break;
		case SendType.Seal:
			result.urls = new string[1] { text };
			result.prefixs = new string[1] { text3 };
			result.results = new List<qiniuyun_DataRequestResult>(1);
			break;
		}
		return result;
	}

	public void UploadFiles(int index, UploadInfo uploadInfo, Action<List<qiniuyun_DataRequestResult>> callback)
	{
		VoiceRecUtility_adhd.UploadFileToQiniuyun(uploadInfo.urls[index], uploadInfo.prefixs[index], uploadInfo.filebytes[index], delegate(string result)
		{
			if (result != null)
			{
				index++;
				DataRequestResult_03 dataRequestResult_ = JsonMgr.Instance.ToObejct<DataRequestResult_03>(result);
				uploadInfo.results.Add(dataRequestResult_.data);
				if (index < uploadInfo.urls.Length)
				{
					UploadFiles(index, uploadInfo, callback);
				}
				else
				{
					callback(uploadInfo.results);
				}
			}
			else
			{
				callback(null);
			}
		});
	}

	public WWWForm GetWorkForn(ArtPostInfo artPostInfo)
	{
		WWWForm wWWForm = new WWWForm();
		wWWForm.AddField("artwork_image_id", (artPostInfo.artwork_image_id == null) ? "" : artPostInfo.artwork_image_id, Encoding.UTF8);
		wWWForm.AddField("artwork_video_id", (artPostInfo.artwork_video_id == null) ? "" : artPostInfo.artwork_video_id, Encoding.UTF8);
		wWWForm.AddField("artwork_seal_id", (artPostInfo.artwork_seal_id == null) ? "" : artPostInfo.artwork_seal_id, Encoding.UTF8);
		wWWForm.AddField("artwork_res_image_id", (artPostInfo.artwork_res_image_id == null) ? "" : artPostInfo.artwork_res_image_id, Encoding.UTF8);
		return wWWForm;
	}

	public WWWForm GetSealForm(SealPostInfo sealPostInfo)
	{
		WWWForm wWWForm = new WWWForm();
		wWWForm.AddField("seal_type", sealPostInfo.seal_type, Encoding.UTF8);
		wWWForm.AddField("seal_txt", sealPostInfo.seal_text, Encoding.UTF8);
		wWWForm.AddField("seal_font", sealPostInfo.seal_font, Encoding.UTF8);
		wWWForm.AddField("seal_file_id", sealPostInfo.seal_file_id, Encoding.UTF8);
		return wWWForm;
	}
}
public class ArtInfo
{
	public string imagePath = "";

	public string imageResPath = "";

	public string videoPath = "";

	public bool isSelf = true;

	public int paperIndex;

	public int outLineIndex = -1;

	public PaperType paperType;

	public PaperType outLineType = PaperType.None;

	public ArtPostInfo artPostInfo = new ArtPostInfo();
}
public class ArtInfoManager
{
	public List<ArtInfo> artInfos = new List<ArtInfo>();
}
public class ColorManager : BaseManager<ColorManager>
{
	public GameObject[] inkstones;

	private Color curColor = Color.black;

	private Color targetColor;

	private float curValue;

	public Color GetColor => curColor;

	public void OnColorShade(Color target, float value)
	{
		if (target != targetColor)
		{
			curColor = targetColor;
			targetColor = target;
		}
		curValue = Mathf.Max(curValue, value);
		if (curValue >= 1f)
		{
			curColor = target;
			curValue = 0f;
		}
	}
}
public enum SelectType
{
	None,
	Pen,
	Seal
}
public enum PickGameType
{
	None,
	Pen,
	Seal
}
public enum AssetsGameType
{
	Seal,
	Inkstone,
	Texture
}
public enum ShowType
{
	Game,
	Customer,
	Name,
	Create
}
public enum PanelType
{
	Main,
	Work,
	Setting,
	Recorder,
	Quit,
	Paper,
	Seal,
	Inkstone
}
public class EventNames
{
	public static string SetPenConfig = "SetPenConfig";

	public static string SetPapaerSize = "SetPapaerSize";

	public static string SetColor = "SetColor";

	public static string SelectSeal = "SelectSeal";

	public static string AddTextureConfig = "AddTextureConfig";

	public static string RemoveTextureConfig = "RemoveTextureConfig";

	public static string AddVideoConfig = "AddVideoConfig";

	public static string RemoveVideoConfig = "RemoveVideoConfig";

	public static string InitWorkArt = "InitWorkArt";

	public static string InitSealConfig = "InitSealConfig";

	public static string ShowPanel = "ShowPanel";

	public static string MainClearClick = "MainClearClick";

	public static string MainCancleClick = "MainCancleClick";

	public static string MainSaveClick = "MainSaveClick";

	public static string MainQuitClick = "MainQuitClick";

	public static string WorkLeftClick = "WorkLeftClick";

	public static string WorkRightClick = "WorkRightClick";

	public static string WorkBackClick = "WorkBackClick";

	public static string WorkApplyClick = "WorkApplyClick";

	public static string WorkDeleteClick = "WorkDeleteClick";

	public static string AssetsBackClick = "AssetsBackClick";

	public static string AssetsLeftClick = "AssetsLeftClick";

	public static string AssetsRightClick = "AssetsRightClick";

	public static string AssetsApplySealTextureClick = "AssetsAppltSealTextureClick";

	public static string AssetsApplySealNameClick = "AssetsApplySealNameClick";

	public static string AssetsApplySealGameClick = "AssetsAppltSealGameClick";

	public static string AssetsApplyInkstoneGameClick = "AssetsAppltInkstoneGameClick";

	public static string AssetsSealAddTextureConfig = " AssetsSealAddTextureConfig";

	public static string AssetsShowPanel = "AssetsShowPanel";

	public static string SealCreateSave = "SealCreateSave";

	public static string PaperTextureClick = "PaperTextureClick";

	public static string SettingAudioToggle = "SettingAudioToggle";

	public static string SettingAudioSilder = "SettingAudioSilder";

	public static string ShowToast = "ShowToast";

	public static string MoveStart = "MoveStart";

	public static string MoveDone = "MoveDone";

	public static string QuitApplation = "QuitApplation";

	public static string SaveImageFile = "SaveImageFile";
}
public class PaperConfig
{
	public string paperType;

	public Vector2 sizeData;

	public PaperConfig(string paperType, Vector2 sizeData)
	{
		this.paperType = paperType;
		this.sizeData = sizeData;
	}
}
public class GlobeConfig
{
	public static Vector3 errorPoint = new Vector3(-1000f, -1000f, -1000f);

	public static string poolRenderTextureName = "renderTexture";

	private static string assetsPath;

	private static string artFileName = null;

	private static string sealFileName = null;

	private static string appConfigFileName = null;

	public static string imageForwardName = "Image";

	public static string imageResForwardName = "ImageRes";

	public static string sealForwardName = "Seal";

	public static string videoForwardName = "Video";

	private static string sealNamePaths;

	public static string paperPaths = "textures/papers";

	public static string sealPaths = "textures/seals";

	private static string videoPaths;

	private static string videoTexturePaths;

	public static string videoName = "video";

	public static string videoPath = "prefabs/video";

	public static string textureName = "texture";

	public static string texturePath = "prefabs/texture";

	public static PickGameType pickGameType = PickGameType.None;

	public static SelectType selectType = SelectType.None;

	public static PanelType currentPanel = PanelType.Main;

	public static int textureWidth = 300;

	public static int textureHeight = 150;

	public static int videoWidth = 300;

	public static int videoHeight = 300;

	public static int paperRatio = 8;

	public static int paperUiRatio = 3;

	public static Vector2 sealSize = new Vector2(300f, 300f);

	private static SealInfoManager sealManager = null;

	private static AppConfig appConfig = null;

	private static ArtInfoManager artInfoManager = null;

	public static string AssetsPath
	{
		get
		{
			if (assetsPath == null)
			{
				assetsPath = Application.persistentDataPath + "/images";
			}
			return assetsPath;
		}
	}

	public static string ArtFileName
	{
		get
		{
			if (artFileName == null)
			{
				artFileName = Application.persistentDataPath + "/artFile";
			}
			return artFileName;
		}
	}

	public static string SealFileName
	{
		get
		{
			if (sealFileName == null)
			{
				sealFileName = Application.persistentDataPath + "/sealFile";
			}
			return sealFileName;
		}
	}

	public static string AppConfigFileName
	{
		get
		{
			if (appConfigFileName == null)
			{
				appConfigFileName = Application.persistentDataPath + "/appConfig";
			}
			return appConfigFileName;
		}
	}

	public static string SealNamePaths
	{
		get
		{
			if (sealNamePaths == null)
			{
				sealNamePaths = Application.persistentDataPath + "/sealName";
			}
			return sealNamePaths;
		}
	}

	public static string VideoPaths
	{
		get
		{
			if (videoPaths == null)
			{
				videoPaths = Application.persistentDataPath + "/videos";
			}
			return videoPaths;
		}
	}

	public static string VideoTexturePaths
	{
		get
		{
			if (videoTexturePaths == null)
			{
				videoTexturePaths = Application.persistentDataPath + "/videos/textures";
			}
			return videoTexturePaths;
		}
	}

	public static ArtInfoManager ArtInfoManager
	{
		get
		{
			if (artInfoManager == null)
			{
				artInfoManager = JsonMgr.Instance.LoadData<ArtInfoManager>(ArtFileName);
			}
			return artInfoManager;
		}
		set
		{
			artInfoManager = value;
		}
	}

	public static SealInfoManager SealManager
	{
		get
		{
			if (sealManager == null)
			{
				sealManager = JsonMgr.Instance.LoadData<SealInfoManager>(SealFileName);
			}
			return sealManager;
		}
		set
		{
			sealManager = value;
		}
	}

	public static AppConfig AppConfig
	{
		get
		{
			if (appConfig == null)
			{
				appConfig = JsonMgr.Instance.LoadData<AppConfig>(AppConfigFileName);
			}
			return appConfig;
		}
		set
		{
			appConfig = value;
		}
	}

	public static void SetActive(GameObject target, bool active)
	{
		if ((bool)target && target.activeSelf != active)
		{
			target.SetActive(active);
		}
	}

	public static Vector2 GetNameWidthHeight(string path)
	{
		Vector2 result = default(Vector2);
		string[] array = path.Split('/')[^1].Split('.')[0].Split('X');
		string value = Regex.Replace(array[0], "[^\\d]*", "");
		string value2 = Regex.Replace(array[1], "[^\\d]*", "");
		result.x = Convert.ToInt32(value);
		result.y = Convert.ToInt32(value2);
		return result;
	}

	public static Texture[] LoadTexture(string path)
	{
		return Resources.LoadAll<Texture>(path);
	}
}
public enum DrawNormal
{
	Up,
	Down,
	Right,
	Left,
	Forward,
	Back
}
public enum RectangularType
{
	center,
	left,
	right
}
public enum AixsType
{
	X,
	Y
}
public class GridConfig
{
	public Vector2 leftMin;

	public Vector2 rightMax;

	public float otherAixs;

	public DrawNormal drawNormal;

	public Material material;

	public Color color = Color.blue;

	public int widthScale;

	public float lineScale;

	public bool isOpen = true;
}
public class GridDrawLine : MonoBehaviour
{
	private Mesh mesh;

	private GridConfig gridConfig;

	public void UpdateDrawState(GridConfig gridConfig)
	{
		this.gridConfig = gridConfig;
		mesh = GetGLDrawMesh(gridConfig.leftMin, gridConfig.rightMax, gridConfig.otherAixs, gridConfig.widthScale, gridConfig.lineScale, gridConfig.drawNormal);
		gridConfig.material.SetPass(0);
		gridConfig.material.SetColor("_Color", gridConfig.color);
	}

	private void Update()
	{
		if (gridConfig.isOpen)
		{
			Graphics.DrawMesh(mesh, base.transform.position, base.transform.rotation, gridConfig.material, 0);
		}
	}

	private void OnRenderObject()
	{
	}

	public void GLDraw(Material material, Mesh mesh, Color color)
	{
		material.SetPass(0);
		material.SetColor("_Color", color);
		GL.wireframe = true;
		GL.Color(color);
		GL.PushMatrix();
		GL.Begin(4);
		for (int i = 0; i < mesh.triangles.Length - 2; i += 3)
		{
			GL.Vertex(mesh.vertices[mesh.triangles[i]]);
			GL.Vertex(mesh.vertices[mesh.triangles[i + 1]]);
			GL.Vertex(mesh.vertices[mesh.triangles[i + 2]]);
		}
		GL.End();
		GL.PopMatrix();
		GL.wireframe = false;
	}

	private Mesh GetGLDrawMesh(Vector2 leftMin, Vector2 rightMax, float otherAixs, int widthScale, float lineScale, DrawNormal drawNormal)
	{
		Mesh obj = new Mesh();
		Vector3[] vertices = GetVertices(leftMin, rightMax, otherAixs, widthScale, lineScale, drawNormal);
		int[] triangles = GetTriangles(vertices);
		obj.vertices = vertices;
		obj.triangles = triangles;
		return obj;
	}

	private Vector3[] GetVertices(Vector2 leftMin, Vector2 rightMax, float otherAixs, int widthScale, float lineScale, DrawNormal drawNormal)
	{
		lineScale = Mathf.Max(lineScale, 0.0001f);
		float num = rightMax.x - leftMin.x;
		float num2 = rightMax.y - leftMin.y;
		float num3 = num2 / (float)widthScale / 2f;
		int num4 = (int)(num / num3) + 1;
		int num5 = (int)(num2 / num3) + 1;
		List<Vector3> vertices = new List<Vector3>((num4 + num5) * 4);
		for (int i = 0; i < num4; i++)
		{
			float width = lineScale / (float)((i % 2 == 0) ? 1 : 2);
			Vector2 start = new Vector2(leftMin.x + (float)i * num3, leftMin.y + ((i == 0 || i == num4 - 1) ? ((0f - lineScale) / 2f) : 0f));
			Vector2 end = new Vector2(leftMin.x + (float)i * num3, rightMax.y + ((i == 0 || i == num4 - 1) ? (lineScale / 2f) : 0f));
			Vector2[] rectanglePoints = GetRectanglePoints(start, end, width, RectangularType.center, AixsType.X);
			RectanglePointsToVertices(ref vertices, rectanglePoints, otherAixs, drawNormal);
		}
		for (int j = 0; j < num5; j++)
		{
			float width2 = lineScale / (float)((j % 2 == 0) ? 1 : 2);
			Vector2 start2 = new Vector2(leftMin.x, leftMin.y + (float)j * num3);
			Vector2 end2 = new Vector2(rightMax.x, leftMin.y + (float)j * num3);
			Vector2[] rectanglePoints2 = GetRectanglePoints(start2, end2, width2, RectangularType.center, AixsType.Y);
			RectanglePointsToVertices(ref vertices, rectanglePoints2, otherAixs, drawNormal);
		}
		return vertices.ToArray();
	}

	private void RectanglePointsToVertices(ref List<Vector3> vertices, Vector2[] points, float otherAixs, DrawNormal drawNormal)
	{
		switch (drawNormal)
		{
		case DrawNormal.Up:
			vertices.Add(new Vector3(points[0].x, otherAixs, points[0].y));
			vertices.Add(new Vector3(points[1].x, otherAixs, points[1].y));
			vertices.Add(new Vector3(points[2].x, otherAixs, points[2].y));
			vertices.Add(new Vector3(points[3].x, otherAixs, points[3].y));
			break;
		case DrawNormal.Down:
			vertices.Add(new Vector3(points[3].x, otherAixs, points[3].y));
			vertices.Add(new Vector3(points[2].x, otherAixs, points[2].y));
			vertices.Add(new Vector3(points[1].x, otherAixs, points[1].y));
			vertices.Add(new Vector3(points[0].x, otherAixs, points[0].y));
			break;
		case DrawNormal.Right:
			vertices.Add(new Vector3(otherAixs, points[0].y, points[0].x));
			vertices.Add(new Vector3(otherAixs, points[1].y, points[1].x));
			vertices.Add(new Vector3(otherAixs, points[2].y, points[2].x));
			vertices.Add(new Vector3(otherAixs, points[3].y, points[3].x));
			break;
		case DrawNormal.Left:
			vertices.Add(new Vector3(otherAixs, points[3].y, points[3].x));
			vertices.Add(new Vector3(otherAixs, points[2].y, points[2].x));
			vertices.Add(new Vector3(otherAixs, points[1].y, points[1].x));
			vertices.Add(new Vector3(otherAixs, points[0].y, points[0].x));
			break;
		case DrawNormal.Forward:
			vertices.Add(new Vector3(points[3].x, points[3].y, otherAixs));
			vertices.Add(new Vector3(points[2].x, points[2].y, otherAixs));
			vertices.Add(new Vector3(points[1].x, points[1].y, otherAixs));
			vertices.Add(new Vector3(points[0].x, points[0].y, otherAixs));
			break;
		case DrawNormal.Back:
			vertices.Add(new Vector3(points[0].x, points[0].y, otherAixs));
			vertices.Add(new Vector3(points[1].x, points[1].y, otherAixs));
			vertices.Add(new Vector3(points[2].x, points[2].y, otherAixs));
			vertices.Add(new Vector3(points[3].x, points[3].y, otherAixs));
			break;
		}
	}

	private Vector2[] GetRectanglePoints(Vector2 start, Vector2 end, float width, RectangularType rectangularType, AixsType aixsType)
	{
		Vector2[] array = new Vector2[4];
		switch (rectangularType)
		{
		case RectangularType.center:
			switch (aixsType)
			{
			case AixsType.X:
				array[0] = new Vector2(start.x + width / 2f, start.y);
				array[1] = new Vector2(start.x - width / 2f, start.y);
				array[2] = new Vector2(end.x - width / 2f, end.y);
				array[3] = new Vector2(end.x + width / 2f, end.y);
				break;
			case AixsType.Y:
				array[0] = new Vector2(start.x, start.y - width / 2f);
				array[1] = new Vector2(start.x, start.y + width / 2f);
				array[2] = new Vector2(end.x, end.y + width / 2f);
				array[3] = new Vector2(end.x, end.y - width / 2f);
				break;
			}
			break;
		case RectangularType.left:
			switch (aixsType)
			{
			case AixsType.X:
				array[0] = new Vector2(start.x, start.y);
				array[1] = new Vector2(start.x - width, start.y);
				array[2] = new Vector2(end.x - width, end.y);
				array[3] = new Vector2(end.x, end.y);
				break;
			case AixsType.Y:
				array[0] = new Vector2(start.x, start.y - width);
				array[1] = new Vector2(start.x, start.y);
				array[2] = new Vector2(end.x, end.y);
				array[3] = new Vector2(end.x, end.y - width);
				break;
			}
			break;
		case RectangularType.right:
			switch (aixsType)
			{
			case AixsType.X:
				array[0] = new Vector2(start.x + width, start.y);
				array[1] = new Vector2(start.x, start.y);
				array[2] = new Vector2(end.x, end.y);
				array[3] = new Vector2(end.x + width, end.y);
				break;
			case AixsType.Y:
				array[0] = new Vector2(start.x, start.y);
				array[1] = new Vector2(start.x, start.y + width);
				array[2] = new Vector2(end.x, end.y + width);
				array[3] = new Vector2(end.x, end.y);
				break;
			}
			break;
		}
		return array;
	}

	private int[] GetTriangles(Vector3[] vertices)
	{
		List<int> list = new List<int>(vertices.Length / 4 * 6);
		for (int i = 0; i < vertices.Length; i += 4)
		{
			list.Add(i);
			list.Add(i + 1);
			list.Add(i + 2);
			list.Add(i);
			list.Add(i + 2);
			list.Add(i + 3);
		}
		return list.ToArray();
	}
}
public class InkstoneConfig : MonoBehaviour
{
	public Color color = Color.black;
}
public class PaintingChineseBrush : MonoBehaviour
{
	public Transform sealParent;

	public Transform inkstoneParent;

	public RectTransform gridPanelRectTr;

	public GridPanel gridPanel;

	private RenderTexture paperRender;

	private Texture paperTexture;

	private RenderTexture drawRender;

	private RenderTexture resultRender;

	public Material matPaint;

	public Material matPaper;

	public Material matSeal;

	public Texture brushTypeTexture;

	public RawImage raw;

	public RawImage drawImage;

	[SerializeField]
	private int numBrush = 50;

	[SerializeField]
	public float widthPower = 0.5f;

	private float rawWidth;

	private float rawHeight;

	[SerializeField]
	private const int maxCancleStep = 5;

	[SerializeField]
	public List<RenderTexture> savedList = new List<RenderTexture>(5);

	[SerializeField]
	private RawImage saveImage;

	private float brushScale = 0.5f;

	private float lastDistance;

	private Vector3[] PositionArray = new Vector3[3];

	private int a;

	private List<Vector3> positions = new List<Vector3>();

	public Color curColor = Color.clear;

	private float radioBrushWidth;

	private Vector3 startPosition = Vector3.zero;

	private Vector3 endPosition = Vector3.zero;

	private static int listCount = 30;

	private List<Vector3> startPositions = new List<Vector3>(listCount);

	private List<Vector3> endPositions = new List<Vector3>(listCount);

	private List<List<Vector3>> PositionArrays = new List<List<Vector3>>(listCount);

	private List<int> firsts = new List<int>(listCount);

	private readonly Vector2[] clearTexCoord2s = new Vector2[4]
	{
		new Vector2(0f, 0f),
		new Vector2(1f, 0f),
		new Vector2(1f, 1f),
		new Vector2(0f, 1f)
	};

	[NonSerialized]
	public Texture[] seals;

	[NonSerialized]
	public Texture seal;

	private bool isInit;

	private bool isSaveRender;

	private int jumpIndex = 1;

	private void Awake()
	{
		LoadAssets();
		BaseManager<EventCenter>.Instance.AddEventListener<string>(EventNames.SaveImageFile, SaveFile);
		BaseManager<EventCenter>.Instance.AddEventListener(EventNames.MainCancleClick, CanclePaint);
		BaseManager<EventCenter>.Instance.AddEventListener(EventNames.MainClearClick, ClearPaint);
		BaseManager<EventCenter>.Instance.AddEventListener<Texture[]>(EventNames.WorkApplyClick, DrawTexture);
		BaseManager<EventCenter>.Instance.AddEventListener<Texture>(EventNames.PaperTextureClick, ApplyPaperTexture);
		BaseManager<EventCenter>.Instance.AddEventListener<int>(EventNames.AssetsApplySealTextureClick, ApplySealTexture);
		BaseManager<EventCenter>.Instance.AddEventListener<int>(EventNames.AssetsApplySealNameClick, ApplySealName);
		BaseManager<EventCenter>.Instance.AddEventListener<bool>(EventNames.QuitApplation, QuitApplation);
		for (int i = 0; i < listCount; i++)
		{
			startPositions.Add(Vector3.zero);
			endPositions.Add(Vector3.zero);
			PositionArrays.Add(new List<Vector3>(3));
			for (int j = 0; j < 4; j++)
			{
				PositionArrays[i].Add(Vector3.zero);
			}
			firsts.Add(0);
		}
		UpdateRawSize(raw.rectTransform.sizeDelta);
		isInit = true;
	}

	public void DestroyRender(RenderTexture renderTexture)
	{
		if ((bool)renderTexture)
		{
			UnityEngine.Object.Destroy(renderTexture);
		}
	}

	private void UpdateRawSize(Vector2 size)
	{
		if (size.x != rawWidth || size.y != rawHeight)
		{
			rawWidth = size.x;
			rawHeight = size.y;
			DestroyRender(paperRender);
			DestroyRender(drawRender);
			DestroyRender(resultRender);
			paperRender = new RenderTexture((int)rawWidth, (int)rawHeight, 24, RenderTextureFormat.ARGB32);
			drawRender = new RenderTexture((int)rawWidth, (int)rawHeight, 24, RenderTextureFormat.ARGB32);
			resultRender = new RenderTexture((int)rawWidth, (int)rawHeight, 24, RenderTextureFormat.ARGB32);
			raw.texture = paperRender;
			raw.rectTransform.sizeDelta = size;
			drawImage.texture = drawRender;
			drawImage.rectTransform.sizeDelta = size;
			BoxCollider component = raw.GetComponent<BoxCollider>();
			if ((bool)component)
			{
				component.size = new Vector3(rawWidth, rawHeight, 1f);
			}
			sealParent.transform.position = raw.transform.position + new Vector3((0f - rawWidth) / 2f / 1000f - 0.2f, 0f, (0f - rawHeight) / 2f / 1000f);
			inkstoneParent.transform.position = raw.transform.position + new Vector3(rawWidth / 2f / 1000f + 0.2f, 0f, (0f - rawHeight) / 2f / 1000f);
			gridPanelRectTr.localPosition = raw.rectTransform.localPosition + new Vector3(rawWidth / 2f, (0f - rawHeight) / 2f, 0f);
		}
	}

	private void Update()
	{
		if (isInit)
		{
			if (Input.GetKeyDown(KeyCode.R) || Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.A))
			{
				CanclePaint();
			}
			if (Input.GetKeyDown(KeyCode.C) || Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.B))
			{
				ClearPaint();
			}
			DrawImage();
		}
	}

	private void QuitApplation(bool isQuit)
	{
		isInit = false;
		UnityEngine.Object.Destroy(paperRender);
		UnityEngine.Object.Destroy(drawRender);
		UnityEngine.Object.Destroy(resultRender);
	}

	private void LoadAssets()
	{
		seals = Resources.LoadAll<Texture>(GlobeConfig.sealPaths);
		if (GlobeConfig.AppConfig.sealIndex != -1)
		{
			seal = seals[GlobeConfig.AppConfig.sealIndex];
			matSeal.SetTexture("_MainTex", seal);
		}
		if (GlobeConfig.AppConfig.sealNameIndex != -1)
		{
			SealInfo sealInfo = GlobeConfig.SealManager.sealPostInfos[GlobeConfig.AppConfig.sealNameIndex];
			seal = BaseManager<AssetsManager>.Instance.LoadImage(sealInfo.sealPath);
			matSeal.SetTexture("_MainTex", seal);
		}
	}

	public void ApplySealTexture(int index)
	{
		GlobeConfig.AppConfig.sealIndex = index;
		GlobeConfig.AppConfig.sealNameIndex = -1;
		seal = seals[GlobeConfig.AppConfig.sealIndex];
		matSeal.SetTexture("_MainTex", seal);
		BaseManager<EventCenter>.Instance.EventTrigger(EventNames.ShowToast, "应用成功！");
		JsonMgr.Instance.SaveData(GlobeConfig.AppConfig, GlobeConfig.AppConfigFileName, JsonType.JsonUtlity);
	}

	public void ApplySealName(int index)
	{
		GlobeConfig.AppConfig.sealNameIndex = index;
		GlobeConfig.AppConfig.sealIndex = -1;
		SealInfo sealInfo = GlobeConfig.SealManager.sealPostInfos[index];
		seal = BaseManager<AssetsManager>.Instance.LoadImage(sealInfo.sealPath);
		matSeal.SetTexture("_MainTex", seal);
		BaseManager<EventCenter>.Instance.EventTrigger(EventNames.ShowToast, "应用成功！");
		JsonMgr.Instance.SaveData(GlobeConfig.AppConfig, GlobeConfig.AppConfigFileName, JsonType.JsonUtlity);
	}

	public void ApplyPaperTexture(Texture texture)
	{
		UpdateRawSize(GlobeConfig.GetNameWidthHeight(texture.name) * GlobeConfig.paperRatio);
		paperTexture = texture;
		gridPanel.UpdateConfig();
		Clear(paperRender, Color.white);
		Clear(drawRender, Color.clear);
		JsonMgr.Instance.SaveData(GlobeConfig.AppConfig, GlobeConfig.AppConfigFileName, JsonType.JsonUtlity);
	}

	public void DrawTexture(Texture[] textures)
	{
		Vector2[] texCoord2s = new Vector2[4]
		{
			new Vector2(0f, 0f),
			new Vector2(1f, 0f),
			new Vector2(1f, 1f),
			new Vector2(0f, 1f)
		};
		UpdateRawSize(GlobeConfig.GetNameWidthHeight(textures[0].name) * GlobeConfig.paperRatio);
		gridPanel.UpdateConfig();
		paperTexture = textures[0];
		ClearPaint();
		Draw(texCoord2s, matPaper, paperRender, textures[0], Color.white);
		Draw(texCoord2s, matPaper, drawRender, textures[1], Color.white);
		JsonMgr.Instance.SaveData(GlobeConfig.AppConfig, GlobeConfig.AppConfigFileName, JsonType.JsonUtlity);
	}

	public void CanclePaint()
	{
		if (savedList.Count > 0)
		{
			RenderTexture renderTexture = savedList[savedList.Count - 1];
			savedList.RemoveAt(savedList.Count - 1);
			Graphics.Blit(renderTexture, drawRender);
			BaseManager<PoolManager>.Instance.SetPool(GlobeConfig.poolRenderTextureName, renderTexture);
		}
		else
		{
			BaseManager<EventCenter>.Instance.EventTrigger(EventNames.ShowToast, "仅允许撤销五步！");
		}
		if (isSaveRender)
		{
			isSaveRender = false;
			CanclePaint();
		}
	}

	public void ClearPaint()
	{
		Clear(paperRender, Color.white);
		Clear(drawRender, Color.clear);
		Clear(resultRender, Color.white);
		for (int i = 0; i < savedList.Count; i++)
		{
			BaseManager<PoolManager>.Instance.SetPool(GlobeConfig.poolRenderTextureName, savedList[i]);
		}
		savedList.Clear();
	}

	private void DrawImage()
	{
		if (raw.texture != paperRender)
		{
			raw.texture = paperRender;
		}
		if (drawImage.texture != drawRender)
		{
			drawImage.texture = drawRender;
		}
	}

	public void DrawImageResult(Texture[] textures)
	{
		Clear(resultRender, Color.white);
		Vector2[] texCoord2s = new Vector2[4]
		{
			new Vector2(0f, 0f),
			new Vector2(1f, 0f),
			new Vector2(1f, 1f),
			new Vector2(0f, 1f)
		};
		for (int i = 1; i < textures.Length; i++)
		{
			Draw(texCoord2s, matPaper, resultRender, textures[i], Color.white);
		}
	}

	public void SaveFile(string videoPath)
	{
		string path = ((videoPath != null && videoPath != "") ? GlobeConfig.VideoTexturePaths : GlobeConfig.AssetsPath);
		string fileName;
		bool flag = BaseManager<AssetsManager>.Instance.SaveTexture(path, drawRender, GlobeConfig.imageForwardName, out fileName);
		Texture[] textures = new Texture[2] { paperRender, drawRender };
		DrawImageResult(textures);
		BaseManager<AssetsManager>.Instance.SaveTexture(path, resultRender, GlobeConfig.imageResForwardName, out var fileName2);
		if (flag)
		{
			SendType sendType = SendType.Image;
			ArtInfo artInfo = new ArtInfo();
			artInfo.isSelf = true;
			artInfo.imagePath = fileName;
			artInfo.imageResPath = fileName2;
			artInfo.paperType = GlobeConfig.AppConfig.paperType;
			artInfo.paperIndex = GlobeConfig.AppConfig.paperIndex;
			if (videoPath != null && videoPath != "")
			{
				sendType = SendType.Video;
				artInfo.videoPath = videoPath;
			}
			BaseManager<HttpDataManager>.Instance.SaveWorkDatas(artInfo.imagePath, artInfo.imageResPath, artInfo.videoPath, sendType, delegate(ArtPostInfo artPostInfo)
			{
				artInfo.artPostInfo = artPostInfo;
				switch (sendType)
				{
				case SendType.Image:
					BaseManager<EventCenter>.Instance.EventTrigger(EventNames.AddTextureConfig, artInfo);
					break;
				case SendType.Video:
					BaseManager<EventCenter>.Instance.EventTrigger(EventNames.AddVideoConfig, artInfo);
					break;
				}
				BaseManager<EventCenter>.Instance.EventTrigger(EventNames.ShowToast, "保存成功");
			});
		}
		else
		{
			BaseManager<EventCenter>.Instance.EventTrigger(EventNames.ShowToast, "保存失败");
		}
	}

	public void SaveTexture()
	{
		UnityEngine.Object pool = BaseManager<PoolManager>.Instance.GetPool(GlobeConfig.poolRenderTextureName);
		RenderTexture renderTexture = ((!(pool == null)) ? (pool as RenderTexture) : new RenderTexture(drawRender));
		Graphics.Blit(drawRender, renderTexture);
		if (savedList.Count >= 5)
		{
			BaseManager<PoolManager>.Instance.SetPool(GlobeConfig.poolRenderTextureName, savedList[0]);
			savedList.RemoveAt(0);
		}
		savedList.Add(renderTexture);
		isSaveRender = true;
	}

	public void DrawSeal(Vector3 point, Vector2 size, Texture texture)
	{
		point = WorldToLocal(point);
		Vector2[] texCoord2s = GetTexCoord2s(new Rect((int)point.x, (int)point.y, size.x, size.y), 1f);
		matSeal.SetInt("_IsReverse", 0);
		Draw(texCoord2s, matSeal, drawRender, texture, Color.red);
		SaveTexture();
	}

	public void OnMouseMove(Vector3 pos, float brushSize = 0f)
	{
		radioBrushWidth = brushSize;
		pos = WorldToLocal(pos);
		if (startPosition == Vector3.zero)
		{
			startPosition = new Vector3(pos.x, pos.y, 0f);
		}
		endPosition = pos;
		float num = Vector3.Distance(startPosition, endPosition);
		brushScale = SetScale(num);
		DrawBrush(pos, endPosition, num);
		startPosition = endPosition;
		lastDistance = num;
	}

	public void OnMouseMoves(Vector3[] points, float[] brushSizes)
	{
		for (int i = jumpIndex; i < points.Length; i++)
		{
			Vector3 world_position = points[i];
			radioBrushWidth = brushSizes[i];
			world_position = WorldToLocal(world_position);
			if (startPositions[i] == Vector3.zero)
			{
				startPositions[i] = new Vector3(world_position.x, world_position.y, 0f);
			}
			endPositions[i] = world_position;
			float num = Vector3.Distance(startPositions[i], endPositions[i]);
			brushScale = SetScale(num);
			DrawBrushs(world_position, endPositions[i], num, i);
			startPositions[i] = endPositions[i];
			lastDistance = num;
		}
		ClearOther(points.Length);
	}

	public void ClearOther(int index)
	{
		if (index < 0)
		{
			index = 0;
		}
		for (int i = index; i < firsts.Count; i++)
		{
			if (startPositions[i] != Vector3.zero)
			{
				startPositions[i] = Vector3.zero;
			}
			if (firsts[i] != 0)
			{
				firsts[i] = 0;
				continue;
			}
			break;
		}
	}

	public void OnMouseMoveUps()
	{
		if (!(startPositions[jumpIndex] == Vector3.zero))
		{
			for (int i = jumpIndex; i < firsts.Count && !(startPositions[i] == Vector3.zero); i++)
			{
				startPositions[i] = Vector3.zero;
				firsts[i] = 0;
			}
			SaveTexture();
		}
	}

	public void OnMouseMoveUp()
	{
		if (!(startPosition == Vector3.zero))
		{
			startPosition = Vector3.zero;
			a = 0;
			SaveTexture();
		}
	}

	public Vector3 WorldToLocal(Vector3 world_position)
	{
		Vector3 vector = base.transform.InverseTransformPoint(world_position);
		float x = vector.x + rawWidth / 2f;
		float y = vector.y + rawHeight / 2f;
		return new Vector3(x, y, 0f);
	}

	public void Clear(RenderTexture destTexture, Color color, bool isBg = true)
	{
		if (isBg)
		{
			Graphics.SetRenderTarget(destTexture);
			GL.PushMatrix();
			GL.Clear(clearDepth: true, clearColor: true, color);
			GL.PopMatrix();
			Draw(clearTexCoord2s, matPaper, destTexture, paperTexture, color, isClear: true);
		}
		else
		{
			Graphics.SetRenderTarget(destTexture);
			GL.PushMatrix();
			GL.Clear(clearDepth: true, clearColor: true, Color.clear);
			GL.PopMatrix();
		}
	}

	private float SetScale(float distance)
	{
		return radioBrushWidth;
	}

	private void DrawBrushs(Vector3 pos, Vector3 endPos, float distance, int index)
	{
		RenderTexture destTexture = drawRender;
		Texture texture = brushTypeTexture;
		float subNum = numBrush;
		Color color = curColor;
		Material destMat = matPaint;
		TwoOrderBézierCurses(positions, pos, endPos, distance, subNum, index);
		for (int i = 0; i < positions.Count; i++)
		{
			Vector3 vector = positions[i];
			Vector2[] texCoord2s = GetTexCoord2s(new Rect((int)vector.x, (int)vector.y, texture.width, texture.height), vector.z);
			Draw(texCoord2s, destMat, destTexture, texture, color);
		}
	}

	private void DrawBrush(Vector3 pos, Vector3 endPos, float distance)
	{
		RenderTexture destTexture = drawRender;
		Texture texture = brushTypeTexture;
		float subNum = numBrush;
		Color color = curColor;
		Material destMat = matPaint;
		TwoOrderBézierCurse(positions, pos, endPos, distance, subNum);
		for (int i = 0; i < positions.Count; i++)
		{
			Vector3 vector = positions[i];
			Vector2[] texCoord2s = GetTexCoord2s(new Rect((int)vector.x, (int)vector.y, texture.width, texture.height), vector.z);
			Draw(texCoord2s, destMat, destTexture, texture, color);
		}
	}

	private Vector2[] GetTexCoord2s(Rect destRect, float scale)
	{
		float x = (destRect.xMin - destRect.width * scale / 2f) / rawWidth;
		float x2 = (destRect.xMin + destRect.width * scale / 2f) / rawWidth;
		float y = (destRect.yMin - destRect.height * scale / 2f) / rawHeight;
		float y2 = (destRect.yMin + destRect.height * scale / 2f) / rawHeight;
		return new Vector2[4]
		{
			new Vector2(x, y),
			new Vector2(x2, y),
			new Vector2(x2, y2),
			new Vector2(x, y2)
		};
	}

	private void Draw(Vector2[] texCoord2s, Material destMat, RenderTexture destTexture, Texture sourceTexture, Color color, bool isClear = false)
	{
		Graphics.SetRenderTarget(destTexture);
		GL.PushMatrix();
		GL.LoadOrtho();
		destMat.SetTexture("_MainTex", sourceTexture);
		destMat.SetColor("_Color", color);
		destMat.SetPass(0);
		GL.Begin(7);
		GL.TexCoord2(isClear ? texCoord2s[0].x : 0f, isClear ? texCoord2s[0].y : 0f);
		GL.Vertex3(texCoord2s[0].x, texCoord2s[0].y, 0f);
		GL.TexCoord2(isClear ? texCoord2s[1].x : 1f, isClear ? texCoord2s[1].y : 0f);
		GL.Vertex3(texCoord2s[1].x, texCoord2s[1].y, 0f);
		GL.TexCoord2(isClear ? texCoord2s[2].x : 1f, isClear ? texCoord2s[2].y : 1f);
		GL.Vertex3(texCoord2s[2].x, texCoord2s[2].y, 0f);
		GL.TexCoord2(isClear ? texCoord2s[3].x : 0f, isClear ? texCoord2s[3].y : 1f);
		GL.Vertex3(texCoord2s[3].x, texCoord2s[3].y, 0f);
		GL.End();
		GL.PopMatrix();
	}

	private void SmoothPoints(List<Vector3> points, Vector3 point, float smooth)
	{
		if (points.Count == 0)
		{
			points.Add(point);
			return;
		}
		float z = point.z;
		Vector2 vector = points[points.Count - 1];
		Vector2 vector2 = point;
		float num = Vector2.Distance(vector, point);
		if (num >= smooth)
		{
			Vector2 normalized = (vector2 - vector).normalized;
			int num2 = (int)(num / smooth);
			for (int i = 0; i < num2; i++)
			{
				Vector2 vector3 = vector + normalized * smooth * (i + 1);
				points.Add(new Vector3(vector3.x, vector3.y, z));
			}
		}
	}

	public void TwoOrderBézierCurses(List<Vector3> positions, Vector3 pos, Vector3 endPos, float distance, float subNum, int index)
	{
		positions.Clear();
		PositionArrays[index][firsts[index]] = pos;
		firsts[index]++;
		if (firsts[index] == 3)
		{
			for (int i = 0; (float)i < subNum; i++)
			{
				Vector3 vector = (PositionArrays[index][0] + PositionArrays[index][2]) / 2f;
				PositionArrays[index][1] = (PositionArrays[index][1] - vector) / 2f + vector;
				float num = 1f / subNum * (float)i / 2f;
				Vector3 vector2 = Mathf.Pow(1f - num, 2f) * PositionArrays[index][0] + 2f * (1f - num) * num * PositionArrays[index][1] + Mathf.Pow(num, 2f) * PositionArrays[index][2];
				float num2 = (distance - lastDistance) / subNum;
				positions.Add(new Vector3(vector2.x, vector2.y, SetScale(lastDistance + num2 * (float)i)));
			}
			PositionArrays[index][0] = PositionArrays[index][1];
			PositionArrays[index][1] = PositionArrays[index][2];
			firsts[index] = 2;
		}
		else
		{
			positions.Add(new Vector3(endPos.x, endPos.y, brushScale));
		}
	}

	public void TwoOrderBézierCurse(List<Vector3> positions, Vector3 pos, Vector3 endPos, float distance, float subNum)
	{
		positions.Clear();
		PositionArray[a] = pos;
		a++;
		if (a == 3)
		{
			int num = (int)((double)subNum * 0.8);
			Vector3 vector = (PositionArray[0] + PositionArray[2]) / 2f;
			PositionArray[1] = (PositionArray[1] - vector) / 2f + vector;
			for (int i = 0; (float)i < subNum; i++)
			{
				float num2 = 1f / subNum * (float)i;
				Vector3 vector2 = Mathf.Pow(1f - num2, 2f) * PositionArray[0] + 2f * (1f - num2) * num2 * PositionArray[1] + Mathf.Pow(num2, 2f) * PositionArray[2];
				float num3 = (distance - lastDistance) / subNum;
				Vector3 item = new Vector3(vector2.x, vector2.y, SetScale(lastDistance + num3 * (float)i));
				positions.Add(item);
				if (num == i)
				{
					PositionArray[1] = vector2;
					break;
				}
			}
			PositionArray[0] = PositionArray[1];
			PositionArray[1] = PositionArray[2];
			a = 2;
		}
		else
		{
			positions.Add(new Vector3(endPos.x, endPos.y, brushScale));
		}
	}
}
public class PenConfig : MonoBehaviour
{
	public float centerLength;

	public float headLength;

	public float subLength;

	public int penMatIndex;

	public float penSize;

	public GameObject rayGame;

	private readonly float radio = 1f;

	private Material[] materials;

	private List<Transform> brushHeads = new List<Transform>(20);

	private List<Vector3> touchPoints = new List<Vector3>(20);

	private Vector3 lastDir = Vector3.zero;

	private bool isLockHead;

	private float subBodyLength;

	private Vector3 startPoint;

	private bool isLimit;

	private bool isLock;

	private bool isLookAt = true;

	private int lookAtIndex;

	private float limitLength = 0.015f;

	private Vector3 lastHitPoint = BezierCurse.errorPoint;

	private Vector3 lastPenPoint = BezierCurse.errorPoint;

	private List<Vector3> pathPoints;

	private float pathMinDistance = 0.0005f;

	private int pathCount = 10;

	private void Awake()
	{
		LoadAsset();
	}

	public void OnDestroy()
	{
		brushHeads.Clear();
	}

	private void LoadAsset()
	{
		if (brushHeads.Count > 0)
		{
			return;
		}
		penSize *= radio;
		materials = base.transform.Find(base.transform.name).GetComponent<SkinnedMeshRenderer>().sharedMaterials;
		Transform child = base.transform.Find("ROOT").GetChild(0);
		while (child.childCount > 0)
		{
			child = child.GetChild(0);
			brushHeads.Add(child);
		}
		for (int i = 0; i < brushHeads.Count; i++)
		{
			if (Vector3.Distance(base.transform.position, brushHeads[i].transform.position) < limitLength * 2f)
			{
				lookAtIndex = i;
				break;
			}
		}
		pathPoints = new List<Vector3>(pathCount);
		subBodyLength = headLength - subLength;
		startPoint = base.transform.localPosition;
	}

	public float GetPenBrushSize(Vector3 world_point, int index, int count)
	{
		if (!isLookAt)
		{
			return Mathf.Max(Mathf.Max(Mathf.Min(Vector3.Distance(world_point, base.transform.position) / headLength, 1f), 1E-06f) * penSize, 0.017f);
		}
		float num = Vector3.Distance(world_point, base.transform.position);
		if (count == 0)
		{
			return Mathf.Max(Mathf.Max(Mathf.Min(num / headLength * 1.5f, 0.5f), 1E-06f) * penSize, 0.017f);
		}
		return Mathf.Max(Mathf.Max(Mathf.Min(((float)index + 1f) / (float)count * (num / headLength) * 1.5f, 0.5f), 0.0001f) * penSize, 0.017f);
	}

	public void SetPenBrushColor(Color color)
	{
		LoadAsset();
		materials[penMatIndex].color = color;
	}

	private void LimitBrush(Vector3 hitPoint, bool isReset)
	{
		if (Vector3.Dot(hitPoint - base.transform.position, base.transform.up) >= limitLength && hitPoint != Vector3.zero)
		{
			base.transform.position = hitPoint - limitLength * base.transform.up;
		}
		if (isReset)
		{
			base.transform.localPosition = startPoint;
		}
	}

	private Vector3 GetDirection(float size)
	{
		if (size > 0f)
		{
			if (!isLockHead || size < headLength / 5f)
			{
				isLockHead = true;
				Vector3 vector = -base.transform.up;
				Vector3 vector2 = new Vector3(vector.x, 0f, vector.z);
				if (lastDir != Vector3.zero && Vector3.Dot(vector2.normalized, lastDir) < -0.8f)
				{
					vector2 = -vector2;
				}
				return vector2.normalized;
			}
		}
		else
		{
			isLockHead = false;
		}
		return lastDir;
	}

	private Vector3 RotateNormal(Vector3 currentNormal, Vector3 targetNormal, float speed)
	{
		return Quaternion.AngleAxis((0f - Vector3.Angle(currentNormal, targetNormal)) * speed * Time.deltaTime, Vector3.up) * currentNormal;
	}

	public List<Vector3> SetBrushDirection(Vector3 hitPoint, bool isReset = false, bool isLookReset = false)
	{
		if (isLimit)
		{
			LimitBrush(hitPoint, isReset);
		}
		touchPoints.Clear();
		if (lastHitPoint == hitPoint)
		{
			return touchPoints;
		}
		lastHitPoint = hitPoint;
		float num = Vector3.Dot(hitPoint - base.transform.position, base.transform.up);
		if (isReset || isLookReset || num < 0f)
		{
			pathPoints.Clear();
			lastPenPoint = BezierCurse.errorPoint;
			lastHitPoint = BezierCurse.errorPoint;
			for (int i = 0; i < brushHeads.Count; i++)
			{
				brushHeads[i].transform.localEulerAngles = Vector3.zero;
			}
			lastDir = Vector3.zero;
			isLockHead = false;
			if (num < 0f)
			{
				return touchPoints;
			}
			touchPoints.Add(hitPoint);
			return touchPoints;
		}
		float a = Vector3.Distance(hitPoint, base.transform.position) / headLength * 2f;
		a = Mathf.Max(Mathf.Min(a, 1f), 0.001f);
		if (lastPenPoint == BezierCurse.errorPoint)
		{
			lastPenPoint = brushHeads[brushHeads.Count - 1].transform.position;
		}
		if (lastDir == Vector3.zero)
		{
			lastDir = GetDirection(a);
		}
		if (!isLock)
		{
			Vector3 normal = lastPenPoint - hitPoint;
			lastDir = GetMoveAxisNormal(normal, 1);
		}
		if (isLookAt)
		{
			for (int j = 0; j < brushHeads.Count; j++)
			{
				Vector3 vector = lastDir;
				Vector3 lookPos = hitPoint + vector * (headLength * (float)(j + 1) / (float)brushHeads.Count) * Mathf.Pow(1.1f, j - lookAtIndex) * a;
				AxisLookAt(brushHeads[j].transform, lookPos, Vector3.up);
				float num2 = Vector3.Dot(brushHeads[j].transform.position - hitPoint, vector);
				if (num2 > 0f)
				{
					Vector3 item = num2 * vector + hitPoint;
					touchPoints.Add(item);
				}
			}
		}
		else
		{
			touchPoints.Add(hitPoint);
		}
		if (touchPoints.Count > 0)
		{
			GetTouchPoints(0.002f, hitPoint, touchPoints[touchPoints.Count - 1], touchPoints[0], ref touchPoints);
		}
		lastPenPoint = brushHeads[brushHeads.Count - 1].transform.position;
		return touchPoints;
	}

	private Vector3 GetMoveDirection(Vector3 hitPoint, Vector3 dir, Vector3 lastPosition)
	{
		Vector3 result = dir;
		if (pathPoints.Count == 0)
		{
			pathPoints.Add(hitPoint);
		}
		else
		{
			Vector3 vector = hitPoint - pathPoints[0];
			float a = Vector3.Distance(hitPoint, lastPosition) / (float)pathCount;
			a = Mathf.Max(a, pathMinDistance);
			float magnitude = vector.magnitude;
			if (magnitude >= a)
			{
				int num = (int)(magnitude / a);
				vector = vector.normalized;
				Vector3 vector2 = pathPoints[0];
				for (int i = 0; i < num; i++)
				{
					pathPoints.Insert(0, vector2 + vector * a);
				}
				for (int num2 = pathPoints.Count - 1; num2 >= pathCount; num2--)
				{
					pathPoints.RemoveAt(pathCount);
				}
			}
			result = (pathPoints[pathPoints.Count - 1] - hitPoint).normalized;
		}
		return result;
	}

	private Vector3 GetMoveAxisNormal(Vector3 normal, int moveAixs)
	{
		switch (moveAixs)
		{
		case 0:
			normal.x = 0f;
			break;
		case 1:
			normal.y = 0f;
			break;
		case 2:
			normal.z = 0f;
			break;
		}
		return normal.normalized;
	}

	private void GetTouchPoints(float size, Vector3 hitPoint, Vector3 min, Vector3 max, ref List<Vector3> touchPoints)
	{
		touchPoints.Clear();
		float num = Vector3.Distance(min, max);
		int num2 = (int)(num / size);
		if (num == 0f)
		{
			touchPoints.Add(hitPoint);
			return;
		}
		Vector3 normalized = (max - min).normalized;
		touchPoints.Add(min);
		for (int i = 1; i < num2; i++)
		{
			float num3 = Mathf.Pow(1.1f, i) * size;
			num3 = ((num3 > size * 4f * penSize) ? (size * 4f * penSize) : num3);
			Vector3 vector = min + normalized * num3 * i;
			float num4 = Vector3.Distance(min, vector);
			if (!(num <= num4))
			{
				touchPoints.Add(vector);
				continue;
			}
			break;
		}
	}

	private Vector3 GetMoveRight(Vector3 direction, Vector3 curNormal)
	{
		Vector3 normalized = new Vector3(curNormal.z, 0f, 0f - curNormal.x).normalized;
		return Vector3.Dot(direction, normalized) * normalized;
	}

	private void AxisLookAt(Transform tr_self, Vector3 lookPos, Vector3 directionAxis)
	{
		Quaternion rotation = tr_self.rotation;
		Vector3 vector = lookPos - tr_self.position;
		Vector3 vector2 = tr_self.rotation * directionAxis;
		Vector3 normalized = Vector3.Cross(vector2, vector).normalized;
		float angle = Vector3.Angle(vector2, vector);
		tr_self.rotation = Quaternion.AngleAxis(angle, normalized) * rotation;
		Vector3 eulerAngles = tr_self.eulerAngles;
		eulerAngles.x = LimitNumber(new Vector2(-180f, 360f), new Vector2(180f, 360f), eulerAngles.x);
		eulerAngles.y = LimitNumber(new Vector2(-180f, 360f), new Vector2(180f, 360f), eulerAngles.y);
		eulerAngles.z = LimitNumber(new Vector2(-180f, 360f), new Vector2(180f, 360f), eulerAngles.z);
		tr_self.eulerAngles = eulerAngles;
	}

	private float LimitNumber(Vector2 min, Vector2 max, float number)
	{
		if (!(number < min.x))
		{
			if (!(number > max.x))
			{
				return number;
			}
			return number - max.y;
		}
		return number + min.y;
	}
}
public class SealConfig : MonoBehaviour
{
	public Vector2 sealSize;

	public GameObject rayGame;
}
public class SealInfo
{
	public string sealPath = "";

	public bool isSelf = true;

	public SealPostInfo sealPostInfo = new SealPostInfo();
}
public class SealInfoManager
{
	public List<SealInfo> sealPostInfos = new List<SealInfo>();
}
public class TextureConfig
{
	public string path = "";

	public int width;

	public int height;

	public PaperType paperType;

	public int paperIndex;

	public PaperType outLineType = PaperType.None;

	public int outLineIndex = -1;

	public ArtPostInfo artPostInfo = new ArtPostInfo();

	public SealPostInfo sealPostInfo = new SealPostInfo();
}
public class TextureConfigManager
{
	public List<TextureConfig> textureConfigs = new List<TextureConfig>();
}
public class VideoConfig
{
	public string path = "";

	public string texturePath = "";

	public int width;

	public int height;

	public ArtPostInfo artPostInfo = new ArtPostInfo();
}
public class VideoConfigManager
{
	public List<VideoConfig> videoConfigs = new List<VideoConfig>();
}
public class VideoToImage : MonoBehaviour, IPointerDownHandler, IEventSystemHandler
{
	public RawImage icon;

	public VideoPlayer videoPlayer;

	public Image playIcon;

	private RenderTexture renderTexture;

	private Texture2D firstTexture;

	public void Init(ArtInfo videoConfig)
	{
		videoPlayer.source = VideoSource.Url;
		videoPlayer.SetDirectAudioVolume(0, 1f);
		videoPlayer.url = videoConfig.videoPath;
		renderTexture = new RenderTexture((int)icon.rectTransform.sizeDelta.x, (int)icon.rectTransform.sizeDelta.y, 24, RenderTextureFormat.ARGB32);
		videoPlayer.targetTexture = renderTexture;
		firstTexture = BaseManager<AssetsManager>.Instance.LoadImage(videoConfig.imageResPath);
		icon.texture = firstTexture;
	}

	public void OnDestroy()
	{
		videoPlayer.targetTexture = null;
		icon.texture = null;
		UnityEngine.Object.Destroy(renderTexture);
		UnityEngine.Object.Destroy(firstTexture);
	}

	public void OnPointerDown(PointerEventData eventData)
	{
		if (videoPlayer.isPlaying)
		{
			icon.texture = firstTexture;
			videoPlayer.Stop();
			GlobeConfig.SetActive(playIcon.gameObject, active: true);
		}
		else
		{
			icon.texture = renderTexture;
			videoPlayer.Play();
			GlobeConfig.SetActive(playIcon.gameObject, active: false);
		}
	}
}
public class SelectGame : MonoBehaviour
{
	public MeshRenderer meshRenderer;

	public SkinnedMeshRenderer skinnedMeshRenderer;

	public PickGameType pickGameType;

	public int Index;

	public GameObject tipGameObejct;

	public MeshRenderer tipGame;

	public SkinnedMeshRenderer tipGame2;

	public void Init()
	{
		GlobeConfig.SetActive(base.gameObject, active: true);
		if ((bool)tipGameObejct)
		{
			GlobeConfig.SetActive(tipGameObejct, active: true);
		}
		HideTip();
		switch (pickGameType)
		{
		case PickGameType.None:
		case PickGameType.Seal:
			HideSelect();
			break;
		case PickGameType.Pen:
			ShowSelect();
			break;
		}
	}

	public void HideSelect()
	{
		SetEnable(meshRenderer, isEnable: false);
		SetEnable(skinnedMeshRenderer, isEnable: false);
	}

	public void ShowSelect()
	{
		SetEnable(meshRenderer, isEnable: true);
		SetEnable(skinnedMeshRenderer, isEnable: true);
	}

	public void ShowTip()
	{
		SetEnable(tipGame, isEnable: true);
		SetEnable(tipGame2, isEnable: true);
	}

	public void HideTip()
	{
		SetEnable(tipGame, isEnable: false);
		SetEnable(tipGame2, isEnable: false);
	}

	private void SetEnable(MeshRenderer meshRenderer, bool isEnable)
	{
		if ((bool)meshRenderer && meshRenderer.enabled != isEnable)
		{
			meshRenderer.enabled = isEnable;
		}
	}

	private void SetEnable(SkinnedMeshRenderer skinnedMeshRenderer, bool isEnable)
	{
		if ((bool)skinnedMeshRenderer && skinnedMeshRenderer.enabled != isEnable)
		{
			skinnedMeshRenderer.enabled = isEnable;
		}
	}
}
public class TableManager : MonoBehaviour
{
	public SelectGame[] pens;

	public GameObject[] inkstones;

	public SelectGame[] seals;

	public ParticleSystem effect;

	public int penIndex;

	public int inkstoneIndex;

	public int sealIndex;

	public void Awake()
	{
		Init();
	}

	private void Init()
	{
		penIndex = 0;
		inkstoneIndex = 0;
		sealIndex = 0;
		BaseManager<EventCenter>.Instance.AddEventListener<int>(EventNames.AssetsApplySealGameClick, SelectSeal);
		BaseManager<EventCenter>.Instance.AddEventListener<int>(EventNames.AssetsApplyInkstoneGameClick, SelectInkstone);
		for (int i = 0; i < pens.Length; i++)
		{
			pens[i].Init();
		}
		for (int j = 0; j < seals.Length; j++)
		{
			seals[j].Init();
		}
	}

	public void PickGame(int index)
	{
		switch (GlobeConfig.pickGameType)
		{
		case PickGameType.None:
		{
			for (int l = 0; l < pens.Length; l++)
			{
				pens[l].ShowSelect();
			}
			for (int m = 0; m < seals.Length; m++)
			{
				if (sealIndex == m)
				{
					seals[sealIndex].ShowSelect();
				}
				else
				{
					seals[m].HideSelect();
				}
			}
			for (int n = 0; n < inkstones.Length; n++)
			{
				if (n == inkstoneIndex)
				{
					GlobeConfig.SetActive(inkstones[n], active: true);
				}
				else
				{
					GlobeConfig.SetActive(inkstones[n], active: false);
				}
			}
			break;
		}
		case PickGameType.Pen:
		{
			penIndex = index;
			for (int num = 0; num < pens.Length; num++)
			{
				if (num == penIndex)
				{
					pens[num].HideSelect();
				}
				else
				{
					pens[num].ShowSelect();
				}
			}
			for (int num2 = 0; num2 < seals.Length; num2++)
			{
				if (sealIndex == num2)
				{
					seals[sealIndex].ShowSelect();
				}
				else
				{
					seals[num2].HideSelect();
				}
			}
			for (int num3 = 0; num3 < inkstones.Length; num3++)
			{
				if (num3 == inkstoneIndex)
				{
					GlobeConfig.SetActive(inkstones[num3], active: true);
				}
				else
				{
					GlobeConfig.SetActive(inkstones[num3], active: false);
				}
			}
			break;
		}
		case PickGameType.Seal:
		{
			sealIndex = index;
			for (int i = 0; i < pens.Length; i++)
			{
				pens[i].ShowSelect();
			}
			for (int j = 0; j < seals.Length; j++)
			{
				seals[sealIndex].HideSelect();
			}
			for (int k = 0; k < inkstones.Length; k++)
			{
				if (k == inkstoneIndex)
				{
					GlobeConfig.SetActive(inkstones[k], active: true);
				}
				else
				{
					GlobeConfig.SetActive(inkstones[k], active: false);
				}
			}
			break;
		}
		}
	}

	public void SelectInkstone(int index)
	{
		inkstoneIndex = index;
		for (int i = 0; i < inkstones.Length; i++)
		{
			if (i != inkstoneIndex)
			{
				if (inkstones[i].activeInHierarchy)
				{
					inkstones[i].SetActive(value: false);
				}
				continue;
			}
			if (!inkstones[i].activeInHierarchy)
			{
				inkstones[i].SetActive(value: true);
			}
			ChangeEffectTip(inkstones[i].transform);
		}
	}

	public void SelectSeal(int index)
	{
		sealIndex = index;
		for (int i = 0; i < seals.Length; i++)
		{
			if (i != sealIndex)
			{
				seals[i].HideSelect();
				continue;
			}
			if (GlobeConfig.pickGameType == PickGameType.Seal)
			{
				seals[i].HideSelect();
				BaseManager<EventCenter>.Instance.EventTrigger(EventNames.SelectSeal);
			}
			else
			{
				seals[i].ShowSelect();
			}
			ChangeEffectTip(seals[i].transform);
		}
	}

	public void ChangeEffectTip(Transform transform)
	{
		BaseManager<EventCenter>.Instance.EventTrigger(EventNames.ShowToast, "应用成功！");
		effect.transform.position = transform.transform.position;
		effect.Play();
	}
}
public class AssetsGamePanel : MonoBehaviour, IDragHandler, IEventSystemHandler
{
	public ShowController showController;

	public void OnDrag(PointerEventData eventData)
	{
		showController.RotateController(eventData.delta, isBack: false);
	}
}
public class AssetsPanel : MonoBehaviour, IPanel
{
	public Button applyBtn;

	public Button backBtn;

	public Button leftBtn;

	public Button rightBtn;

	public Button sealGameBtn;

	public Button sealTextureBtn;

	public Button sealBtn;

	public Button sealNameBtn;

	public Button sealNameDestroyBtn;

	public Button sealCreateBtn;

	public Toggle sealToggle;

	public Toggle inkstoneToggle;

	public Toggle paperToggle;

	public GreatScrollPanel paperScollView;

	public Transform paperContent;

	public GreatScrollPanel sealScrollView;

	public Transform sealContent;

	public GreatScrollPanel sealNameScrollView;

	public Transform sealNameContent;

	public ShowController showController;

	public GameObject[] panels;

	private ShowType showType;

	public void Init()
	{
		BaseManager<EventCenter>.Instance.AddEventListener<SealInfo>(EventNames.AssetsSealAddTextureConfig, AddSealTextureConfig);
		BaseManager<EventCenter>.Instance.AddEventListener<ShowType>(EventNames.AssetsShowPanel, ShowPanel);
		leftBtn.onClick.AddListener(LeftEvent);
		rightBtn.onClick.AddListener(RightEvent);
		backBtn.onClick.AddListener(BackEvent);
		applyBtn.onClick.AddListener(ApplyEvent);
		sealToggle.onValueChanged.AddListener(SealEvent);
		inkstoneToggle.onValueChanged.AddListener(InkstoneEvent);
		paperToggle.onValueChanged.AddListener(PaperEvent);
		sealGameBtn.onClick.AddListener(ShowSealGameEvent);
		sealTextureBtn.onClick.AddListener(ShowSealTextureEvent);
		sealBtn.onClick.AddListener(ShowSealTextureEvent);
		sealNameBtn.onClick.AddListener(ShowSealNameEvent);
		sealCreateBtn.onClick.AddListener(ShowSealCreateEvent);
		sealNameDestroyBtn.onClick.AddListener(DestrorEvent);
		ShowPanel(ShowType.Game);
		LoadRawImages(GlobeConfig.paperPaths, paperContent, "纸张类型:", new Vector2(GlobeConfig.textureWidth, GlobeConfig.textureHeight), paperScollView);
		InitGreatScrollPanel(paperScollView);
		LoadRawImages(GlobeConfig.sealPaths, sealContent, "闲章:", GlobeConfig.sealSize, sealScrollView);
		InitGreatScrollPanel(sealScrollView);
		InitSealInfo(sealNameScrollView, sealNameContent, GlobeConfig.SealManager.sealPostInfos, GlobeConfig.SealNamePaths, GlobeConfig.sealSize, isShowName: false);
	}

	public void Clear()
	{
		leftBtn.onClick.RemoveAllListeners();
		rightBtn.onClick.RemoveAllListeners();
		backBtn.onClick.RemoveAllListeners();
		applyBtn.onClick.RemoveAllListeners();
		sealToggle.onValueChanged.RemoveAllListeners();
		inkstoneToggle.onValueChanged.RemoveAllListeners();
		paperToggle.onValueChanged.RemoveAllListeners();
		sealGameBtn.onClick.RemoveAllListeners();
		sealTextureBtn.onClick.RemoveAllListeners();
		sealBtn.onClick.RemoveAllListeners();
		sealNameBtn.onClick.RemoveAllListeners();
		sealCreateBtn.onClick.RemoveAllListeners();
		sealNameDestroyBtn.onClick.RemoveAllListeners();
		for (int num = paperContent.childCount - 1; num >= 0; num--)
		{
			Transform child = paperContent.GetChild(num);
			child.parent = null;
			UnityEngine.Object.Destroy(child.gameObject);
		}
		for (int num2 = sealContent.childCount - 1; num2 >= 0; num2--)
		{
			Transform child2 = sealContent.GetChild(num2);
			child2.parent = null;
			UnityEngine.Object.Destroy(child2.gameObject);
		}
		for (int num3 = sealNameContent.childCount - 1; num3 >= 0; num3--)
		{
			Transform child3 = sealNameContent.GetChild(num3);
			child3.parent = null;
			UnityEngine.Object.Destroy(child3.gameObject);
		}
	}

	public void Show()
	{
	}

	public void Hide()
	{
	}

	public void AddSealTextureConfig(SealInfo textureConfig)
	{
		if (textureConfig != null && !GlobeConfig.SealManager.sealPostInfos.Contains(textureConfig))
		{
			GlobeConfig.SealManager.sealPostInfos.Add(textureConfig);
			JsonMgr.Instance.SaveData(GlobeConfig.SealManager, GlobeConfig.SealFileName);
			AddSealContentChild(textureConfig, sealNameContent);
			if (!sealNameScrollView.isAwake)
			{
				sealNameScrollView.Awake();
			}
			sealNameScrollView.Init();
			sealNameScrollView.SnapItem(sealNameScrollView.CenterIndex);
		}
	}

	public void RemoveTextureConfig(SealInfo textureConfig)
	{
		if (textureConfig != null && GlobeConfig.SealManager.sealPostInfos.Contains(textureConfig))
		{
			GlobeConfig.SealManager.sealPostInfos.Remove(textureConfig);
			JsonMgr.Instance.SaveData(GlobeConfig.SealManager, GlobeConfig.SealFileName);
		}
	}

	public void DestrorEvent()
	{
		int contentIndex = GetContentIndex();
		if (contentIndex == -1)
		{
			BaseManager<EventCenter>.Instance.EventTrigger(EventNames.ShowToast, "删除失败！");
			return;
		}
		BaseManager<AssetsManager>.Instance.DeleteFile(GlobeConfig.SealNamePaths + "/" + GlobeConfig.SealManager.sealPostInfos[contentIndex].sealPath);
		RemoveTextureConfig(GlobeConfig.SealManager.sealPostInfos[contentIndex]);
		UnityEngine.Object.DestroyImmediate(sealNameContent.GetChild(contentIndex).gameObject);
		if (sealNameScrollView.transform.childCount > 0)
		{
			sealNameScrollView.Init();
			sealNameScrollView.SnapItem((contentIndex - 1 > 0) ? (contentIndex - 1) : 0);
		}
		BaseManager<EventCenter>.Instance.EventTrigger(EventNames.ShowToast, "删除成功！");
	}

	public int GetContentIndex()
	{
		int result = -1;
		if ((bool)sealNameScrollView)
		{
			result = sealNameScrollView.CenterIndex;
		}
		return result;
	}

	public void InitGreatScrollPanel(GreatScrollPanel greatScrollPanel)
	{
		if (!greatScrollPanel.isAwake)
		{
			greatScrollPanel.Awake();
		}
		greatScrollPanel.Init();
		greatScrollPanel.SnapItem(0);
	}

	public void LoadRawImages(string path, Transform content, string nameHead, Vector2 size, GreatScrollPanel greatScrollPanel)
	{
		greatScrollPanel._itemSize = size;
		Texture[] array = Resources.LoadAll<Texture>(path);
		for (int i = 0; i < array.Length; i++)
		{
			GameObject obj = BaseManager<PoolManager>.Instance.GetPrefab(GlobeConfig.textureName, GlobeConfig.texturePath) as GameObject;
			obj.transform.parent = content;
			RawImage component = obj.transform.Find("Icon").GetComponent<RawImage>();
			component.rectTransform.sizeDelta = size;
			component.texture = array[i];
			Transform obj2 = obj.transform.Find("bg");
			Vector3 localPosition = obj2.transform.localPosition;
			localPosition.y = (0f - size.y) / 2f;
			obj2.transform.localPosition = localPosition;
			Text component2 = obj.transform.Find("name").GetComponent<Text>();
			component2.text = nameHead + (i + 1);
			Vector3 localPosition2 = component2.transform.localPosition;
			localPosition2.y = (0f - size.y) / 2f;
			component2.transform.localPosition = localPosition2;
		}
	}

	public void ApplyEvent()
	{
		switch (showType)
		{
		case ShowType.Game:
			switch (showController.assetsGameType)
			{
			case AssetsGameType.Seal:
				BaseManager<EventCenter>.Instance.EventTrigger(EventNames.AssetsApplySealGameClick, showController.assetsIndex);
				break;
			case AssetsGameType.Inkstone:
				BaseManager<EventCenter>.Instance.EventTrigger(EventNames.AssetsApplyInkstoneGameClick, showController.assetsIndex);
				break;
			}
			break;
		case ShowType.Customer:
			BaseManager<EventCenter>.Instance.EventTrigger(EventNames.AssetsApplySealTextureClick, sealScrollView.CenterIndex);
			break;
		case ShowType.Name:
		{
			int contentIndex = GetContentIndex();
			if (contentIndex == -1 || !sealNameContent.GetChild(contentIndex))
			{
				BaseManager<EventCenter>.Instance.EventTrigger(EventNames.ShowToast, "应用失败！");
			}
			else
			{
				BaseManager<EventCenter>.Instance.EventTrigger(EventNames.AssetsApplySealNameClick, contentIndex);
			}
			break;
		}
		case ShowType.Create:
			break;
		}
	}

	public void ShowSealGameEvent()
	{
		ShowPanel(ShowType.Game);
		showController.Show(AssetsGameType.Seal, -1);
	}

	public void ShowSealTextureEvent()
	{
		ShowPanel(ShowType.Customer);
		showController.Show(AssetsGameType.Texture, -1);
	}

	public void ShowSealNameEvent()
	{
		ShowPanel(ShowType.Name);
		showController.Show(AssetsGameType.Texture, -1);
	}

	public void ShowSealCreateEvent()
	{
		ShowPanel(ShowType.Create);
		showController.Show(AssetsGameType.Texture, -1);
	}

	public void SealEvent(bool isOn)
	{
		if (isOn)
		{
			ShowPanel(ShowType.Customer);
		}
	}

	public void InkstoneEvent(bool isOn)
	{
		if (isOn)
		{
			ShowPanel(ShowType.Game);
			showController.Show(AssetsGameType.Inkstone, -1);
		}
	}

	public void PaperEvent(bool isOn)
	{
	}

	public void ShowPanel(ShowType showType)
	{
		this.showType = showType;
		for (int i = 0; i < panels.Length; i++)
		{
			GlobeConfig.SetActive(panels[i], i == showType.GetHashCode());
		}
	}

	public void LeftEvent()
	{
		switch (showType)
		{
		case ShowType.Customer:
		{
			int num = sealScrollView.CenterIndex - 1;
			num = ((num >= 0) ? num : 0);
			sealScrollView.SnapItem(num);
			break;
		}
		case ShowType.Game:
			showController.LeftEvent();
			break;
		case ShowType.Name:
		{
			int num = sealNameScrollView.CenterIndex - 1;
			num = ((num >= 0) ? num : 0);
			sealNameScrollView.SnapItem(num);
			break;
		}
		case ShowType.Create:
			break;
		}
	}

	public void RightEvent()
	{
		switch (showType)
		{
		case ShowType.Customer:
		{
			int num = sealScrollView.CenterIndex + 1;
			num = ((num > sealContent.childCount - 1) ? (sealContent.transform.childCount - 1) : num);
			sealScrollView.SnapItem(num);
			break;
		}
		case ShowType.Game:
			showController.RightEvent();
			break;
		case ShowType.Name:
		{
			int num = sealNameScrollView.CenterIndex + 1;
			num = ((num > sealNameContent.childCount - 1) ? (sealNameContent.transform.childCount - 1) : num);
			sealNameScrollView.SnapItem(num);
			break;
		}
		case ShowType.Create:
			break;
		}
	}

	public void BackEvent()
	{
		BaseManager<EventCenter>.Instance.EventTrigger(EventNames.ShowPanel, PanelType.Main);
	}

	public void InitSealInfo(GreatScrollPanel greatScrollPanel, Transform content, List<SealInfo> imageInfos, string forwardPath, Vector2 size, bool isShowName = true)
	{
		List<SealInfo> list = new List<SealInfo>();
		greatScrollPanel._itemSize = size;
		for (int i = 0; i < imageInfos.Count; i++)
		{
			SealInfo sealInfo = imageInfos[i];
			if (File.Exists(forwardPath + "/" + sealInfo.sealPath))
			{
				AddSealContentChild(sealInfo, content, isShowName);
			}
			else
			{
				list.Add(sealInfo);
			}
		}
		for (int j = 0; j < list.Count; j++)
		{
			imageInfos.Remove(list[j]);
		}
	}

	public void AddSealContentChild(SealInfo sealInfo, Transform content, bool isShowName = true)
	{
		GameObject obj = BaseManager<PoolManager>.Instance.GetPrefab(GlobeConfig.textureName, GlobeConfig.texturePath) as GameObject;
		float num = (float)GlobeConfig.paperRatio / ((float)GlobeConfig.paperUiRatio * 1f);
		Texture2D texture2D = BaseManager<AssetsManager>.Instance.LoadImage(sealInfo.sealPath);
		RawImage component = obj.transform.Find("Icon").GetComponent<RawImage>();
		component.texture = texture2D;
		component.rectTransform.sizeDelta = new Vector2((float)texture2D.width / num, (float)texture2D.height / num);
		GlobeConfig.SetActive(obj.transform.Find("IconForward").gameObject, active: false);
		Transform transform = obj.transform.Find("bg");
		Text component2 = obj.transform.Find("name").GetComponent<Text>();
		transform.gameObject.SetActive(isShowName);
		component2.gameObject.SetActive(isShowName);
		Vector3 localPosition = transform.transform.localPosition;
		localPosition.y = (float)(-texture2D.height) / num;
		transform.transform.localPosition = localPosition;
		Vector3 localPosition2 = component2.transform.localPosition;
		localPosition2.y = (float)(-texture2D.height) / num;
		component2.transform.localPosition = localPosition2;
		component2.text = "";
		obj.transform.parent = content;
	}
}
public class AssetsSealPanel : MonoBehaviour
{
	public Text inputText;

	public Button selectBtn;

	public Button applyLightBtn;

	public Button applyShadeBtn;

	public Button saveBtn;

	public RawImage showRawIamge;

	public Material sealMaterial;

	public Font[] fonts;

	public Dropdown fontDropdown;

	private RenderTexture textRenderTexture;

	private Texture sealBg;

	private string sealBgPath = "textures/sealBg/sealBg1";

	private bool isCreate;

	private void Awake()
	{
		sealBg = Resources.Load<Texture>(sealBgPath);
		selectBtn.onClick.AddListener(SelectEvent);
		applyLightBtn.onClick.AddListener(ApplyLightEvent);
		applyShadeBtn.onClick.AddListener(ApplyShadeEvent);
		saveBtn.onClick.AddListener(SaveEvent);
		fontDropdown.onValueChanged.AddListener(FontDropdownValueChange);
		BaseManager<EventCenter>.Instance.AddEventListener(EventNames.SealCreateSave, SaveEvent);
		textRenderTexture = new RenderTexture((int)GlobeConfig.sealSize.x, (int)GlobeConfig.sealSize.y, 24, RenderTextureFormat.ARGB32);
		ClearImage();
	}

	private void OnDisable()
	{
		ClearImage();
	}

	private void ClearImage()
	{
		textRenderTexture = BaseManager<SealManager>.Instance.Clear(textRenderTexture, sealMaterial, sealBg, Color.red);
		showRawIamge.texture = textRenderTexture;
		isCreate = false;
	}

	public void SelectEvent()
	{
		ClearImage();
		BaseManager<EventCenter>.Instance.EventTrigger(EventNames.AssetsShowPanel, ShowType.Name);
	}

	public void FontDropdownValueChange(int value)
	{
		value = Mathf.Max(Mathf.Min(value, fonts.Length - 1), 0);
		inputText.font = fonts[value];
	}

	public void ApplyLightEvent()
	{
		ClearImage();
		textRenderTexture = BaseManager<SealManager>.Instance.GetSealTexture(inputText.text, textRenderTexture, sealMaterial, inputText, Color.red, isReverse: false);
		showRawIamge.texture = textRenderTexture;
		isCreate = true;
	}

	public void ApplyShadeEvent()
	{
		ClearImage();
		textRenderTexture = BaseManager<SealManager>.Instance.GetSealTexture(inputText.text, textRenderTexture, sealMaterial, inputText, Color.red, isReverse: true);
		showRawIamge.texture = textRenderTexture;
		isCreate = true;
	}

	public void SaveEvent()
	{
		if (!isCreate)
		{
			BaseManager<EventCenter>.Instance.EventTrigger(EventNames.ShowToast, "请生成阴阳章，再保存！");
			return;
		}
		_ = GlobeConfig.sealSize;
		_ = GlobeConfig.sealSize;
		if (BaseManager<AssetsManager>.Instance.SaveTexture(GlobeConfig.SealNamePaths, textRenderTexture, GlobeConfig.sealForwardName, out var fileName))
		{
			BaseManager<HttpDataManager>.Instance.SaveSealDatas(fileName, SealType.Name_Seal, inputText.font.name, inputText.text, delegate(SealPostInfo sealPostInfo)
			{
				SealInfo info = new SealInfo
				{
					sealPath = fileName,
					sealPostInfo = sealPostInfo
				};
				BaseManager<EventCenter>.Instance.EventTrigger(EventNames.AssetsSealAddTextureConfig, info);
				BaseManager<EventCenter>.Instance.EventTrigger(EventNames.ShowToast, "保存成功");
			});
		}
		else
		{
			BaseManager<EventCenter>.Instance.EventTrigger(EventNames.ShowToast, "保存失败");
		}
	}
}
public class GridPanel : MonoBehaviour
{
	public GameObject silderBg;

	public Slider widthScaleSlider;

	public Text widthScaleText;

	public Slider lineScaleSlider;

	public Text lineScaleText;

	public Toggle isOpen;

	public GridDrawLine drawLine;

	public Material gridMat;

	public Color gridColor;

	public RawImage paperImage;

	private GridConfig gridConfig = new GridConfig();

	public void Awake()
	{
		widthScaleSlider.onValueChanged.AddListener(ScaleSliderChange);
		lineScaleSlider.onValueChanged.AddListener(LineSliderChange);
		isOpen.onValueChanged.AddListener(OpenToggle);
		UpdateConfig();
		drawLine.transform.position = paperImage.transform.position;
	}

	public void OnDestroy()
	{
		widthScaleSlider.onValueChanged.RemoveAllListeners();
		lineScaleSlider.onValueChanged.RemoveAllListeners();
		isOpen.onValueChanged.RemoveAllListeners();
	}

	public void ScaleSliderChange(float value)
	{
		gridConfig.widthScale = (int)value;
		widthScaleText.text = "尺寸:" + gridConfig.widthScale;
		drawLine.UpdateDrawState(gridConfig);
	}

	public void LineSliderChange(float value)
	{
		gridConfig.lineScale = GetDecimal(value, 1000);
		lineScaleText.text = "线框:" + gridConfig.lineScale;
		drawLine.UpdateDrawState(gridConfig);
	}

	public void OpenToggle(bool isOn)
	{
		silderBg.SetActive(isOn);
		UpdateConfig();
	}

	public float GetDecimal(float number, int radio)
	{
		return (float)(int)(number * (float)radio) / ((float)radio * 1f);
	}

	public void UpdateConfig()
	{
		float num = paperImage.rectTransform.sizeDelta.x / 1000f;
		float num2 = paperImage.rectTransform.sizeDelta.y / 1000f;
		gridConfig.leftMin = new Vector2((0f - num) / 2f, (0f - num2) / 2f);
		gridConfig.rightMax = new Vector2(num / 2f, num2 / 2f);
		gridConfig.otherAixs = 0.0001f;
		gridConfig.drawNormal = DrawNormal.Up;
		gridConfig.material = gridMat;
		gridConfig.color = gridColor;
		gridConfig.widthScale = (int)widthScaleSlider.value;
		gridConfig.lineScale = GetDecimal(lineScaleSlider.value, 1000);
		gridConfig.isOpen = isOpen.isOn;
		widthScaleText.text = "尺寸:" + gridConfig.widthScale;
		lineScaleText.text = "线框:" + gridConfig.lineScale;
		drawLine.UpdateDrawState(gridConfig);
	}
}
public class InkstonePanel : MonoBehaviour, IPanel
{
	public Button applyBtn;

	public Button backBtn;

	public Button leftBtn;

	public Button rightBtn;

	public ShowController showController;

	public void Init()
	{
		leftBtn.onClick.AddListener(LeftEvent);
		rightBtn.onClick.AddListener(RightEvent);
		backBtn.onClick.AddListener(BackEvent);
		applyBtn.onClick.AddListener(ApplyEvent);
	}

	public void Clear()
	{
		leftBtn.onClick.RemoveAllListeners();
		rightBtn.onClick.RemoveAllListeners();
		backBtn.onClick.RemoveAllListeners();
		applyBtn.onClick.RemoveAllListeners();
	}

	public void Hide()
	{
	}

	public void Show()
	{
		showController.Show(AssetsGameType.Inkstone, 0);
	}

	public void ApplyEvent()
	{
		AssetsGameType assetsGameType = showController.assetsGameType;
		if (assetsGameType == AssetsGameType.Inkstone)
		{
			BaseManager<EventCenter>.Instance.EventTrigger(EventNames.AssetsApplyInkstoneGameClick, showController.assetsIndex);
		}
	}

	public void LeftEvent()
	{
		showController.LeftEvent();
	}

	public void RightEvent()
	{
		showController.RightEvent();
	}

	public void BackEvent()
	{
		BaseManager<EventCenter>.Instance.EventTrigger(EventNames.ShowPanel, PanelType.Main);
	}
}
public interface IPanel
{
	void Init();

	void Show();

	void Hide();

	void Clear();
}
public class MainPanel : MonoBehaviour, IPanel
{
	public Button paperBtn;

	public Button sealBtn;

	public Button inkstoneBtn;

	public Button workBtn;

	public Button recorderBtn;

	public Button cancleBtn;

	public Button clearBtn;

	public Button settingBtn;

	public Button saveBtn;

	public Button quitBtn;

	public void Init()
	{
		paperBtn.onClick.AddListener(PapaerEvent);
		sealBtn.onClick.AddListener(SealEvent);
		inkstoneBtn.onClick.AddListener(InkstoneEvent);
		workBtn.onClick.AddListener(WorkEvent);
		recorderBtn.onClick.AddListener(RecorderEvent);
		cancleBtn.onClick.AddListener(CancleEvent);
		clearBtn.onClick.AddListener(ClearEvent);
		settingBtn.onClick.AddListener(SettingEvent);
		saveBtn.onClick.AddListener(SaveEvent);
		quitBtn.onClick.AddListener(QuitEvent);
	}

	public void Clear()
	{
		paperBtn.onClick.RemoveAllListeners();
		sealBtn.onClick.RemoveAllListeners();
		inkstoneBtn.onClick.RemoveAllListeners();
		workBtn.onClick.RemoveAllListeners();
		recorderBtn.onClick.RemoveAllListeners();
		cancleBtn.onClick.RemoveAllListeners();
		clearBtn.onClick.RemoveAllListeners();
		settingBtn.onClick.RemoveAllListeners();
		saveBtn.onClick.RemoveAllListeners();
		quitBtn.onClick.RemoveAllListeners();
	}

	private void InkstoneEvent()
	{
		BaseManager<EventCenter>.Instance.EventTrigger(EventNames.ShowPanel, PanelType.Inkstone);
	}

	private void SealEvent()
	{
		BaseManager<EventCenter>.Instance.EventTrigger(EventNames.ShowPanel, PanelType.Seal);
	}

	private void PapaerEvent()
	{
		BaseManager<EventCenter>.Instance.EventTrigger(EventNames.ShowPanel, PanelType.Paper);
	}

	public void Show()
	{
	}

	public void Hide()
	{
	}

	public void WorkEvent()
	{
		BaseManager<EventCenter>.Instance.EventTrigger(EventNames.ShowPanel, PanelType.Work);
	}

	public void RecorderEvent()
	{
		BaseManager<EventCenter>.Instance.EventTrigger(EventNames.ShowPanel, PanelType.Recorder);
	}

	public void ClearEvent()
	{
		BaseManager<EventCenter>.Instance.EventTrigger(EventNames.MainClearClick);
	}

	public void CancleEvent()
	{
		BaseManager<EventCenter>.Instance.EventTrigger(EventNames.MainCancleClick);
	}

	public void SettingEvent()
	{
		BaseManager<EventCenter>.Instance.EventTrigger(EventNames.ShowPanel, PanelType.Setting);
	}

	public void SaveEvent()
	{
		BaseManager<EventCenter>.Instance.EventTrigger(EventNames.MainSaveClick, info: false);
	}

	public void QuitEvent()
	{
		BaseManager<EventCenter>.Instance.EventTrigger(EventNames.ShowPanel, PanelType.Quit);
	}
}
public enum PaperType
{
	ColorA_Type_All,
	ColorA_Type_Rectangle,
	ColorA_Type_Three,
	ColorB_Type_All,
	ColorB_Type_Rectangle,
	ColorB_Type_Three,
	ColorC_Type_All,
	ColorC_Type_Rectangle,
	ColorC_Type_Three,
	Color_Select,
	None
}
public class PaperPanel : MonoBehaviour, IPanel
{
	public Button leftBtn;

	public Button rightBtn;

	public Button backBtn;

	public Button applyBtn;

	public Button colorBtn;

	public Button scaleBtn;

	public Button allBtn;

	public Button rectangleBtn;

	public Button threeBtn;

	public GameObject scaleBtns;

	public GreatScrollPanel paperScrollView;

	public Transform paperContent;

	private int typeIndex;

	private PaperType lastPaperType;

	private PaperType curPaperType;

	private int curIndex;

	public void Init()
	{
		leftBtn.onClick.AddListener(LeftEvent);
		rightBtn.onClick.AddListener(RightEvent);
		backBtn.onClick.AddListener(BackEvent);
		applyBtn.onClick.AddListener(ApplyEvent);
		colorBtn.onClick.AddListener(ColorEvent);
		scaleBtn.onClick.AddListener(ScaleEvent);
		allBtn.onClick.AddListener(AllEvent);
		rectangleBtn.onClick.AddListener(RectangleEvent);
		threeBtn.onClick.AddListener(ThreeEvent);
		GlobeConfig.SetActive(scaleBtns, active: true);
		ApplyTexture();
		curIndex = GlobeConfig.AppConfig.paperIndex;
		curPaperType = GlobeConfig.AppConfig.paperType;
		ShowPaper(curPaperType, isInit: true);
	}

	public void Clear()
	{
		leftBtn.onClick.RemoveAllListeners();
		rightBtn.onClick.RemoveAllListeners();
		backBtn.onClick.RemoveAllListeners();
		applyBtn.onClick.RemoveAllListeners();
		colorBtn.onClick.RemoveAllListeners();
		scaleBtn.onClick.RemoveAllListeners();
		allBtn.onClick.RemoveAllListeners();
		rectangleBtn.onClick.RemoveAllListeners();
		threeBtn.onClick.RemoveAllListeners();
		for (int num = paperContent.childCount - 1; num >= 0; num--)
		{
			Transform child = paperContent.GetChild(num);
			child.parent = null;
			UnityEngine.Object.Destroy(child.gameObject);
		}
	}

	private void ShowPaper(PaperType paperType, bool isInit = false)
	{
		if (paperType != curPaperType || isInit)
		{
			curPaperType = paperType;
			switch (paperType)
			{
			case PaperType.ColorA_Type_All:
			case PaperType.ColorB_Type_All:
			case PaperType.ColorC_Type_All:
				typeIndex = 0;
				lastPaperType = paperType;
				break;
			case PaperType.ColorA_Type_Rectangle:
			case PaperType.ColorB_Type_Rectangle:
			case PaperType.ColorC_Type_Rectangle:
				lastPaperType = paperType;
				typeIndex = 1;
				break;
			case PaperType.ColorA_Type_Three:
			case PaperType.ColorB_Type_Three:
			case PaperType.ColorC_Type_Three:
				lastPaperType = paperType;
				typeIndex = 2;
				break;
			}
			ClearScroll();
			InitScroll(BaseManager<AssetsManager>.Instance.Papers[paperType], paperContent, paperScrollView);
		}
	}

	private void InitScroll(Texture[] textures, Transform content, GreatScrollPanel greatScrollPanel)
	{
		for (int i = 0; i < textures.Length; i++)
		{
			GameObject game = BaseManager<PoolManager>.Instance.GetPrefab(GlobeConfig.textureName, GlobeConfig.texturePath) as GameObject;
			AddContent(game, content, textures[i]);
		}
		if (!greatScrollPanel.isAwake)
		{
			greatScrollPanel.Awake();
		}
		greatScrollPanel.Init();
		curIndex = ((curIndex < 0 || curIndex >= content.childCount) ? greatScrollPanel.CenterIndex : curIndex);
		greatScrollPanel.SnapItem(curIndex);
	}

	private void AddContent(GameObject game, Transform parent, Texture texture, bool isShowName = false)
	{
		game.transform.SetParent(parent);
		Transform obj = game.transform.Find("Icon");
		Text component = game.transform.Find("name").GetComponent<Text>();
		Transform transform = game.transform.Find("bg");
		Transform transform2 = game.transform.Find("IconForward");
		Transform transform3 = game.transform.Find("outLine");
		RawImage component2 = obj.GetComponent<RawImage>();
		component2.texture = texture;
		Vector2 sizeDelta = GlobeConfig.GetNameWidthHeight(texture.name) * GlobeConfig.paperUiRatio;
		component2.rectTransform.sizeDelta = sizeDelta;
		transform.gameObject.SetActive(isShowName);
		Vector3 localPosition = transform.transform.localPosition;
		localPosition.y = (0f - sizeDelta.y) / 2f;
		transform.transform.localPosition = localPosition;
		component.gameObject.SetActive(isShowName);
		Vector3 localPosition2 = component.transform.localPosition;
		localPosition2.y = (0f - sizeDelta.y) / 2f;
		component.transform.localPosition = localPosition2;
		component.text = texture.name;
		GlobeConfig.SetActive(transform2.gameObject, active: false);
		GlobeConfig.SetActive(transform3.gameObject, active: false);
	}

	private void ClearScroll()
	{
		for (int num = paperContent.childCount - 1; num >= 0; num--)
		{
			Transform child = paperContent.GetChild(num);
			child.parent = null;
			BaseManager<PoolManager>.Instance.SetPool(GlobeConfig.textureName, child.gameObject);
		}
	}

	public void Hide()
	{
	}

	public void Show()
	{
	}

	private void ThreeEvent()
	{
		PaperType paperType = PaperType.ColorA_Type_All;
		switch (curPaperType)
		{
		case PaperType.ColorA_Type_All:
		case PaperType.ColorA_Type_Rectangle:
		case PaperType.ColorA_Type_Three:
			paperType = PaperType.ColorA_Type_Three;
			break;
		case PaperType.ColorB_Type_All:
		case PaperType.ColorB_Type_Rectangle:
		case PaperType.ColorB_Type_Three:
			paperType = PaperType.ColorB_Type_Three;
			break;
		case PaperType.ColorC_Type_All:
		case PaperType.ColorC_Type_Rectangle:
		case PaperType.ColorC_Type_Three:
			paperType = PaperType.ColorC_Type_Three;
			break;
		case PaperType.Color_Select:
			curPaperType = lastPaperType;
			ThreeEvent();
			return;
		}
		ShowPaper(paperType);
	}

	private void RectangleEvent()
	{
		PaperType paperType = PaperType.ColorA_Type_All;
		switch (curPaperType)
		{
		case PaperType.ColorA_Type_All:
		case PaperType.ColorA_Type_Rectangle:
		case PaperType.ColorA_Type_Three:
			paperType = PaperType.ColorA_Type_Rectangle;
			break;
		case PaperType.ColorB_Type_All:
		case PaperType.ColorB_Type_Rectangle:
		case PaperType.ColorB_Type_Three:
			paperType = PaperType.ColorB_Type_Rectangle;
			break;
		case PaperType.ColorC_Type_All:
		case PaperType.ColorC_Type_Rectangle:
		case PaperType.ColorC_Type_Three:
			paperType = PaperType.ColorC_Type_Rectangle;
			break;
		case PaperType.Color_Select:
			curPaperType = lastPaperType;
			RectangleEvent();
			return;
		}
		ShowPaper(paperType);
	}

	private void AllEvent()
	{
		PaperType paperType = PaperType.ColorA_Type_All;
		switch (curPaperType)
		{
		case PaperType.ColorA_Type_All:
		case PaperType.ColorA_Type_Rectangle:
		case PaperType.ColorA_Type_Three:
			paperType = PaperType.ColorA_Type_All;
			break;
		case PaperType.ColorB_Type_All:
		case PaperType.ColorB_Type_Rectangle:
		case PaperType.ColorB_Type_Three:
			paperType = PaperType.ColorB_Type_All;
			break;
		case PaperType.ColorC_Type_All:
		case PaperType.ColorC_Type_Rectangle:
		case PaperType.ColorC_Type_Three:
			paperType = PaperType.ColorC_Type_All;
			break;
		case PaperType.Color_Select:
			curPaperType = lastPaperType;
			AllEvent();
			return;
		}
		ShowPaper(paperType);
	}

	private void ScaleEvent()
	{
		ShowPaper(lastPaperType);
	}

	private void ColorEvent()
	{
		ShowPaper(PaperType.Color_Select);
	}

	private void ApplyEvent()
	{
		int contentIndex = GetContentIndex();
		switch (curPaperType)
		{
		case PaperType.ColorA_Type_All:
		case PaperType.ColorA_Type_Rectangle:
		case PaperType.ColorA_Type_Three:
		case PaperType.ColorB_Type_All:
		case PaperType.ColorB_Type_Rectangle:
		case PaperType.ColorB_Type_Three:
		case PaperType.ColorC_Type_All:
		case PaperType.ColorC_Type_Rectangle:
		case PaperType.ColorC_Type_Three:
			curIndex = contentIndex;
			GlobeConfig.AppConfig.paperIndex = contentIndex;
			GlobeConfig.AppConfig.paperType = curPaperType;
			ApplyTexture();
			break;
		case PaperType.Color_Select:
			SelectShowPaper(contentIndex);
			break;
		}
	}

	private void ApplyTexture()
	{
		BaseManager<EventCenter>.Instance.EventTrigger(EventNames.PaperTextureClick, BaseManager<AssetsManager>.Instance.Papers[GlobeConfig.AppConfig.paperType][GlobeConfig.AppConfig.paperIndex]);
	}

	private void SelectShowPaper(int index)
	{
		switch (index)
		{
		case 0:
			if (typeIndex == 0)
			{
				ShowPaper(PaperType.ColorA_Type_All);
			}
			else if (typeIndex == 1)
			{
				ShowPaper(PaperType.ColorA_Type_Rectangle);
			}
			else if (typeIndex == 2)
			{
				ShowPaper(PaperType.ColorA_Type_Three);
			}
			break;
		case 1:
			if (typeIndex == 0)
			{
				ShowPaper(PaperType.ColorB_Type_All);
			}
			else if (typeIndex == 1)
			{
				ShowPaper(PaperType.ColorB_Type_Rectangle);
			}
			else if (typeIndex == 2)
			{
				ShowPaper(PaperType.ColorB_Type_Three);
			}
			break;
		case 2:
			if (typeIndex == 0)
			{
				ShowPaper(PaperType.ColorC_Type_All);
			}
			else if (typeIndex == 1)
			{
				ShowPaper(PaperType.ColorC_Type_Rectangle);
			}
			else if (typeIndex == 2)
			{
				ShowPaper(PaperType.ColorC_Type_Three);
			}
			break;
		}
	}

	public int GetContentIndex()
	{
		int result = -1;
		if ((bool)paperScrollView)
		{
			result = paperScrollView.CenterIndex;
		}
		return result;
	}

	public void LeftEvent()
	{
		int num = paperScrollView.CenterIndex - 1;
		num = ((num >= 0) ? num : 0);
		paperScrollView.SnapItem(num);
	}

	public void RightEvent()
	{
		int num = paperScrollView.CenterIndex + 1;
		num = ((num > paperContent.childCount - 1) ? (paperContent.transform.childCount - 1) : num);
		paperScrollView.SnapItem(num);
	}

	public void BackEvent()
	{
		BaseManager<EventCenter>.Instance.EventTrigger(EventNames.ShowPanel, PanelType.Main);
	}
}
public class QuitPanel : MonoBehaviour, IPanel
{
	public Button quitBtn;

	public Button backBtn;

	private bool isQuit;

	public void Init()
	{
		isQuit = false;
		quitBtn.onClick.AddListener(QuitEvent);
		backBtn.onClick.AddListener(BackEvent);
	}

	public void Show()
	{
	}

	public void Hide()
	{
	}

	public void Clear()
	{
		quitBtn.onClick.RemoveAllListeners();
		backBtn.onClick.RemoveAllListeners();
	}

	public void QuitEvent()
	{
		if (!isQuit)
		{
			isQuit = true;
			BaseManager<EventCenter>.Instance.EventTrigger(EventNames.QuitApplation, info: true);
			BaseManager<EventCenter>.Instance.Clear();
			BaseManager<PoolManager>.Instance.Clear();
			ScenesHelper.LoadScene(ScenesHelper.MetaverseSceneName);
		}
	}

	public void BackEvent()
	{
		BaseManager<EventCenter>.Instance.EventTrigger(EventNames.ShowPanel, PanelType.Main);
	}
}
public class RecorderPanel : MonoBehaviour, IPanel
{
	public Text uiText;

	public Button recorderBtn;

	public Text recorderBtnText;

	public Button backBtn;

	public ReplayCam replayCam;

	private int timeNum;

	[NonSerialized]
	public RecordType recordType;

	private RenderTexture renderTexture;

	public void Init()
	{
		recordType = RecordType.Null;
		RecorderEvent();
		recorderBtn.onClick.AddListener(RecorderEvent);
		backBtn.onClick.AddListener(BackEvent);
		renderTexture = new RenderTexture(GlobeConfig.videoWidth, GlobeConfig.videoHeight, 24, RenderTextureFormat.ARGB32);
		replayCam.cam.targetTexture = renderTexture;
		BaseManager<EventCenter>.Instance.AddEventListener<bool>(EventNames.QuitApplation, QuitEvent);
		BaseManager<EventCenter>.Instance.AddEventListener<bool>(EventNames.MainSaveClick, QuitEvent);
	}

	public void Show()
	{
	}

	public void Hide()
	{
	}

	public void Clear()
	{
		replayCam.cam.targetTexture = null;
		UnityEngine.Object.Destroy(renderTexture);
		recorderBtn.onClick.RemoveAllListeners();
		backBtn.onClick.RemoveAllListeners();
	}

	public void QuitEvent(bool isQuit)
	{
		if (recordType == RecordType.StopRecord)
		{
			RecorderEvent();
		}
		if (!isQuit && recordType != RecordType.StopRecord)
		{
			BaseManager<EventCenter>.Instance.EventTrigger(EventNames.SaveImageFile, "");
		}
	}

	public void RecorderEvent()
	{
		switch (recordType)
		{
		case RecordType.Null:
			recordType = RecordType.StartRecord;
			uiText.text = "";
			break;
		case RecordType.StartRecord:
			StartRectord();
			recordType = RecordType.StopRecord;
			break;
		case RecordType.StopRecord:
			StopRectord();
			recordType = RecordType.StartRecord;
			break;
		}
		recorderBtnText.text = ((recordType == RecordType.StopRecord) ? "停止录屏" : "开始录屏");
	}

	public void BackEvent()
	{
		BaseManager<EventCenter>.Instance.EventTrigger(EventNames.ShowPanel, PanelType.Main);
	}

	public void StartRectord()
	{
		timeNum = 0;
		replayCam.StartRecording();
		TimerBaseManager<TimerManager>.instance.DoLoop(1000, SetTimeText, false);
	}

	public void StopRectord()
	{
		replayCam.StopRecording();
		TimerBaseManager<TimerManager>.instance.RemoveHandler(SetTimeText);
		uiText.text = "视屏保存完成,时长:" + timeNum + "秒";
		BaseManager<EventCenter>.Instance.EventTrigger(EventNames.SaveImageFile, ReplayCam.videoPath);
	}

	public void SetTimeText()
	{
		timeNum++;
		uiText.text = "录屏时长:" + timeNum + "秒";
	}
}
public class SealPanel : MonoBehaviour, IPanel
{
	public Button applyBtn;

	public Button backBtn;

	public Button leftBtn;

	public Button rightBtn;

	public Button gameBtn;

	public Button cutomerBtn;

	public Button nameBtn;

	public Button destroyBtn;

	public Button createBtn;

	public GreatScrollPanel sealScrollView;

	public Transform sealContent;

	public GreatScrollPanel sealNameScrollView;

	public Transform sealNameContent;

	public ShowController showController;

	public GameObject[] panels;

	public ImeDelegateImpl imeDelegateImpl;

	private ShowType showType = ShowType.Customer;

	public void Init()
	{
		BaseManager<EventCenter>.Instance.AddEventListener<SealInfo>(EventNames.AssetsSealAddTextureConfig, AddSealTextureConfig);
		BaseManager<EventCenter>.Instance.AddEventListener<ShowType>(EventNames.AssetsShowPanel, ShowPanel);
		leftBtn.onClick.AddListener(LeftEvent);
		rightBtn.onClick.AddListener(RightEvent);
		backBtn.onClick.AddListener(BackEvent);
		applyBtn.onClick.AddListener(ApplyEvent);
		gameBtn.onClick.AddListener(ShowSealGameEvent);
		cutomerBtn.onClick.AddListener(ShowSealTextureEvent);
		nameBtn.onClick.AddListener(ShowSealNameEvent);
		createBtn.onClick.AddListener(ShowSealCreateEvent);
		destroyBtn.onClick.AddListener(DestrorEvent);
		ShowPanel(ShowType.Customer);
		LoadRawImages(GlobeConfig.sealPaths, sealContent, "闲章:", GlobeConfig.sealSize, sealScrollView);
		InitGreatScrollPanel(sealScrollView);
		InitSealInfo(sealNameScrollView, sealNameContent, GlobeConfig.SealManager.sealPostInfos, GlobeConfig.sealSize, isShowName: false);
	}

	public void Clear()
	{
		leftBtn.onClick.RemoveAllListeners();
		rightBtn.onClick.RemoveAllListeners();
		backBtn.onClick.RemoveAllListeners();
		applyBtn.onClick.RemoveAllListeners();
		gameBtn.onClick.RemoveAllListeners();
		cutomerBtn.onClick.RemoveAllListeners();
		nameBtn.onClick.RemoveAllListeners();
		createBtn.onClick.RemoveAllListeners();
		destroyBtn.onClick.RemoveAllListeners();
		for (int num = sealContent.childCount - 1; num >= 0; num--)
		{
			Transform child = sealContent.GetChild(num);
			child.parent = null;
			UnityEngine.Object.Destroy(child.gameObject);
		}
		for (int num2 = sealNameContent.childCount - 1; num2 >= 0; num2--)
		{
			Transform child2 = sealContent.GetChild(num2);
			child2.parent = null;
			UnityEngine.Object.Destroy(child2.gameObject);
		}
	}

	public void Show()
	{
		ShowPanel(ShowType.Customer);
		showController.Show(AssetsGameType.Seal, -1);
	}

	public void Hide()
	{
	}

	public void AddSealTextureConfig(SealInfo textureConfig)
	{
		if (textureConfig != null && !GlobeConfig.SealManager.sealPostInfos.Contains(textureConfig))
		{
			GlobeConfig.SealManager.sealPostInfos.Add(textureConfig);
			JsonMgr.Instance.SaveData(GlobeConfig.SealManager, GlobeConfig.SealFileName);
			AddSealContentChild(textureConfig, sealNameContent, isShowName: false);
			if (!sealNameScrollView.isAwake)
			{
				sealNameScrollView.Awake();
			}
			sealNameScrollView.Init();
			sealNameScrollView.SnapItem(sealNameScrollView.CenterIndex);
		}
	}

	public void RemoveTextureConfig(SealInfo sealInfo)
	{
		if (sealInfo != null && GlobeConfig.SealManager.sealPostInfos.Contains(sealInfo))
		{
			GlobeConfig.SealManager.sealPostInfos.Remove(sealInfo);
			JsonMgr.Instance.SaveData(GlobeConfig.SealManager, GlobeConfig.SealFileName);
		}
	}

	public void DestrorEvent()
	{
		int index = GetContentIndex();
		if (index == -1)
		{
			BaseManager<EventCenter>.Instance.EventTrigger(EventNames.ShowToast, "删除失败！");
			return;
		}
		SealInfo sealInfo = GlobeConfig.SealManager.sealPostInfos[index];
		BaseManager<HttpDataManager>.Instance.DeleteSealData(sealInfo.sealPostInfo, delegate
		{
			BaseManager<AssetsManager>.Instance.DeleteFile(sealInfo.sealPath);
			RemoveTextureConfig(sealInfo);
			UnityEngine.Object.DestroyImmediate(sealNameContent.GetChild(index).gameObject);
			if (sealNameScrollView.transform.childCount > 0)
			{
				sealNameScrollView.Init();
				sealNameScrollView.SnapItem((index - 1 > 0) ? (index - 1) : 0);
			}
			BaseManager<EventCenter>.Instance.EventTrigger(EventNames.ShowToast, "删除成功！");
		});
	}

	public int GetContentIndex()
	{
		int result = -1;
		if ((bool)sealNameScrollView)
		{
			result = sealNameScrollView.CenterIndex;
		}
		return result;
	}

	public void InitGreatScrollPanel(GreatScrollPanel greatScrollPanel)
	{
		if (!greatScrollPanel.isAwake)
		{
			greatScrollPanel.Awake();
		}
		greatScrollPanel.Init();
		greatScrollPanel.SnapItem(0);
	}

	public void LoadRawImages(string path, Transform content, string nameHead, Vector2 size, GreatScrollPanel greatScrollPanel)
	{
		greatScrollPanel._itemSize = size;
		Texture[] array = Resources.LoadAll<Texture>(path);
		for (int i = 0; i < array.Length; i++)
		{
			GameObject obj = BaseManager<PoolManager>.Instance.GetPrefab(GlobeConfig.textureName, GlobeConfig.texturePath) as GameObject;
			obj.transform.SetParent(content);
			RawImage component = obj.transform.Find("Icon").GetComponent<RawImage>();
			Transform transform = obj.transform.Find("bg");
			Text component2 = obj.transform.Find("name").GetComponent<Text>();
			Transform transform2 = obj.transform.Find("IconForward");
			Transform obj2 = obj.transform.Find("outLine");
			component.rectTransform.sizeDelta = size;
			component.texture = array[i];
			Vector3 localPosition = transform.transform.localPosition;
			localPosition.y = (0f - size.y) / 2f;
			transform.transform.localPosition = localPosition;
			component2.text = nameHead + (i + 1);
			Vector3 localPosition2 = component2.transform.localPosition;
			localPosition2.y = (0f - size.y) / 2f;
			component2.transform.localPosition = localPosition2;
			GlobeConfig.SetActive(transform2.gameObject, active: false);
			GlobeConfig.SetActive(obj2.gameObject, active: false);
		}
	}

	public void ApplyEvent()
	{
		switch (showType)
		{
		case ShowType.Game:
			if (showController.assetsGameType == AssetsGameType.Seal)
			{
				BaseManager<EventCenter>.Instance.EventTrigger(EventNames.AssetsApplySealGameClick, showController.assetsIndex);
			}
			break;
		case ShowType.Customer:
			BaseManager<EventCenter>.Instance.EventTrigger(EventNames.AssetsApplySealTextureClick, sealScrollView.CenterIndex);
			break;
		case ShowType.Name:
		{
			int contentIndex = GetContentIndex();
			if (contentIndex == -1 || !sealNameContent.GetChild(contentIndex))
			{
				BaseManager<EventCenter>.Instance.EventTrigger(EventNames.ShowToast, "应用失败！");
			}
			else
			{
				BaseManager<EventCenter>.Instance.EventTrigger(EventNames.AssetsApplySealNameClick, contentIndex);
			}
			break;
		}
		case ShowType.Create:
			BaseManager<EventCenter>.Instance.EventTrigger(EventNames.SealCreateSave);
			ShowPanel(ShowType.Name);
			showController.Show(AssetsGameType.Texture, -1);
			break;
		}
	}

	public void ShowSealGameEvent()
	{
		ShowPanel(ShowType.Game);
		showController.Show(AssetsGameType.Seal, -1);
	}

	public void ShowSealTextureEvent()
	{
		ShowPanel(ShowType.Customer);
		showController.Show(AssetsGameType.Texture, -1);
	}

	public void ShowSealNameEvent()
	{
		ShowPanel(ShowType.Name);
		showController.Show(AssetsGameType.Texture, -1);
	}

	public void ShowSealCreateEvent()
	{
		ShowPanel(ShowType.Create);
		showController.Show(AssetsGameType.Texture, -1);
	}

	public void ShowPanel(ShowType showType)
	{
		this.showType = showType;
		for (int i = 0; i < panels.Length; i++)
		{
			GlobeConfig.SetActive(panels[i], i == showType.GetHashCode());
		}
	}

	public void LeftEvent()
	{
		switch (showType)
		{
		case ShowType.Customer:
		{
			int num = sealScrollView.CenterIndex - 1;
			num = ((num >= 0) ? num : 0);
			sealScrollView.SnapItem(num);
			break;
		}
		case ShowType.Game:
			showController.LeftEvent();
			break;
		case ShowType.Name:
		{
			int num = sealNameScrollView.CenterIndex - 1;
			num = ((num >= 0) ? num : 0);
			sealNameScrollView.SnapItem(num);
			break;
		}
		case ShowType.Create:
			break;
		}
	}

	public void RightEvent()
	{
		switch (showType)
		{
		case ShowType.Customer:
		{
			int num = sealScrollView.CenterIndex + 1;
			num = ((num > sealContent.childCount - 1) ? (sealContent.transform.childCount - 1) : num);
			sealScrollView.SnapItem(num);
			break;
		}
		case ShowType.Game:
			showController.RightEvent();
			break;
		case ShowType.Name:
		{
			int num = sealNameScrollView.CenterIndex + 1;
			num = ((num > sealNameContent.childCount - 1) ? (sealNameContent.transform.childCount - 1) : num);
			sealNameScrollView.SnapItem(num);
			break;
		}
		case ShowType.Create:
			break;
		}
	}

	public void BackEvent()
	{
		BaseManager<EventCenter>.Instance.EventTrigger(EventNames.ShowPanel, PanelType.Main);
		imeDelegateImpl.mManager.Hide();
	}

	public void InitSealInfo(GreatScrollPanel greatScrollPanel, Transform content, List<SealInfo> imageInfos, Vector2 size, bool isShowName = true)
	{
		List<SealInfo> list = new List<SealInfo>();
		greatScrollPanel._itemSize = size;
		for (int i = 0; i < imageInfos.Count; i++)
		{
			SealInfo sealInfo = imageInfos[i];
			if (File.Exists(sealInfo.sealPath))
			{
				AddSealContentChild(sealInfo, content, isShowName);
			}
			else
			{
				list.Add(sealInfo);
			}
		}
		for (int j = 0; j < list.Count; j++)
		{
			imageInfos.Remove(list[j]);
		}
	}

	public void AddSealContentChild(SealInfo sealInfo, Transform content, bool isShowName = true)
	{
		GameObject obj = BaseManager<PoolManager>.Instance.GetPrefab(GlobeConfig.textureName, GlobeConfig.texturePath) as GameObject;
		obj.transform.parent = content;
		float num = (float)GlobeConfig.paperRatio / ((float)GlobeConfig.paperUiRatio * 1f);
		Texture2D texture2D = BaseManager<AssetsManager>.Instance.LoadImage(sealInfo.sealPath);
		Transform transform = obj.transform.Find("Icon");
		Transform transform2 = obj.transform.Find("IconForward");
		Transform transform3 = obj.transform.Find("bg");
		Text component = obj.transform.Find("name").GetComponent<Text>();
		RawImage component2 = transform.GetComponent<RawImage>();
		component2.texture = texture2D;
		component2.rectTransform.sizeDelta = new Vector2((float)texture2D.width / num, (float)texture2D.height / num);
		GlobeConfig.SetActive(transform2.gameObject, active: false);
		transform3.gameObject.SetActive(isShowName);
		Vector3 localPosition = transform3.transform.localPosition;
		localPosition.y = (float)(-texture2D.height) / num;
		transform3.transform.localPosition = localPosition;
		component.gameObject.SetActive(isShowName);
		Vector3 localPosition2 = component.transform.localPosition;
		localPosition2.y = (float)(-texture2D.height) / num;
		component.transform.localPosition = localPosition2;
		component.text = "";
	}
}
public class SettingPanel : MonoBehaviour, IPanel
{
	public Button backBtn;

	public Toggle audioToggle;

	public Slider audiuSilder;

	public AudioSource audioSource;

	public VideoPlayer videoPlayer;

	public void Init()
	{
		backBtn.onClick.AddListener(BackEvent);
		audioToggle.isOn = GlobeConfig.AppConfig.audioToggle == 1;
		AudioToggle(GlobeConfig.AppConfig.audioToggle == 1);
		AudioSilder((float)GlobeConfig.AppConfig.audioVolume);
		audioToggle.onValueChanged.AddListener(AudioToggle);
		audiuSilder.onValueChanged.AddListener(AudioSilder);
	}

	public void Show()
	{
	}

	public void Hide()
	{
	}

	public void Clear()
	{
		backBtn.onClick.RemoveAllListeners();
		audioToggle.onValueChanged.RemoveAllListeners();
		audiuSilder.onValueChanged.RemoveAllListeners();
	}

	public void BackEvent()
	{
		BaseManager<EventCenter>.Instance.EventTrigger(EventNames.ShowPanel, PanelType.Main);
	}

	public void AudioToggle(bool isOn)
	{
		GlobeConfig.AppConfig.audioToggle = (isOn ? 1 : 0);
		if (isOn)
		{
			AudioSilder((float)GlobeConfig.AppConfig.audioVolume);
			if ((bool)audioSource)
			{
				audioSource.Play();
			}
			if ((bool)videoPlayer)
			{
				videoPlayer.Play();
			}
		}
		else
		{
			if ((bool)audioSource)
			{
				audioSource.Stop();
			}
			if ((bool)videoPlayer)
			{
				videoPlayer.Stop();
			}
		}
		BaseManager<EventCenter>.Instance.EventTrigger(EventNames.SettingAudioToggle, isOn);
		JsonMgr.Instance.SaveData(GlobeConfig.AppConfig, GlobeConfig.AppConfigFileName, JsonType.JsonUtlity);
	}

	public void AudioSilder(float value)
	{
		GlobeConfig.AppConfig.audioVolume = value;
		if ((bool)audioSource)
		{
			audioSource.volume = value;
		}
		if ((bool)videoPlayer)
		{
			videoPlayer.SetDirectAudioVolume(0, value);
		}
		BaseManager<EventCenter>.Instance.EventTrigger(EventNames.SettingAudioSilder, value);
	}
}
public class ToastPanel : MonoBehaviour
{
	public Text toastText;

	public void Init()
	{
		BaseManager<EventCenter>.Instance.AddEventListener<string>(EventNames.ShowToast, ShowToast);
		HideToast();
	}

	public void ShowToast(string data)
	{
		if (data == "" || data == null)
		{
			HideToast();
			return;
		}
		CancelInvoke();
		toastText.text = data;
		base.gameObject.SetActive(value: true);
		Invoke("HideToast", 2f);
	}

	public void HideToast()
	{
		base.gameObject.SetActive(value: false);
		toastText.text = "";
	}
}
public class UIManager : MonoBehaviour
{
	public MainPanel mainPanel;

	public WorkPanel workPanel;

	public SettingPanel settingPanel;

	public RecorderPanel recorderPanel;

	public QuitPanel quitPanel;

	public PaperPanel paperPanel;

	public SealPanel sealPanel;

	public InkstonePanel inkstonePanel;

	public ToastPanel toastPanel;

	private GameObject[] panelGames;

	private IPanel[] panels;

	private int currentIndex = -1;

	private void Awake()
	{
		Init();
	}

	public void Init()
	{
		panelGames = new GameObject[8] { mainPanel.gameObject, workPanel.gameObject, settingPanel.gameObject, recorderPanel.gameObject, quitPanel.gameObject, paperPanel.gameObject, sealPanel.gameObject, inkstonePanel.gameObject };
		panels = new IPanel[8] { mainPanel, workPanel, settingPanel, recorderPanel, quitPanel, paperPanel, sealPanel, inkstonePanel };
		toastPanel.Init();
		for (int i = 0; i < panels.Length; i++)
		{
			panels[i].Init();
			panels[i].Hide();
			GlobeConfig.SetActive(panelGames[i].gameObject, active: false);
		}
		GlobeConfig.SetActive(mainPanel.gameObject, active: true);
		ShowPanel(PanelType.Main);
		BaseManager<EventCenter>.Instance.AddEventListener<PanelType>(EventNames.ShowPanel, ShowPanel);
		BaseManager<EventCenter>.Instance.AddEventListener<bool>(EventNames.QuitApplation, QuitApplation);
	}

	public void QuitApplation(bool isQuit)
	{
		if (panels.Length > currentIndex)
		{
			panels[currentIndex].Clear();
		}
	}

	public void ShowPanel(PanelType panelType)
	{
		if (currentIndex > -1)
		{
			if (panelGames.Length > currentIndex)
			{
				GlobeConfig.SetActive(panelGames[currentIndex].gameObject, active: false);
			}
			if (panels.Length > currentIndex)
			{
				panels[currentIndex].Hide();
			}
		}
		currentIndex = (int)panelType;
		if (panelGames.Length > currentIndex)
		{
			GlobeConfig.SetActive(panelGames[currentIndex].gameObject, active: true);
		}
		if (panels.Length > currentIndex)
		{
			panels[currentIndex].Show();
		}
	}
}
public class WorkPanel : MonoBehaviour, IPanel
{
	public Button leftBtn;

	public Button rightBtn;

	public Button backBtn;

	public Button applyBtn;

	public Button destroyBtn;

	public Button paperBtn;

	public Button videoBtn;

	public Button frameBtn;

	public Button type0Btn;

	public Button type1Btn;

	public Button type2Btn;

	public GameObject frameBtns;

	public Transform paperContent;

	public GreatScrollPanel paperGreatScrollPanel;

	public Transform videoContent;

	public GreatScrollPanel videoGreatScrollPanel;

	public void Init()
	{
		leftBtn.onClick.AddListener(LeftEvent);
		rightBtn.onClick.AddListener(RightEvent);
		backBtn.onClick.AddListener(BackEvent);
		applyBtn.onClick.AddListener(ApplyEvent);
		destroyBtn.onClick.AddListener(DestrorEvent);
		paperBtn.onClick.AddListener(PaperEvent);
		videoBtn.onClick.AddListener(VideoEvent);
		frameBtn.onClick.AddListener(FrameEvent);
		type0Btn.onClick.AddListener(Type0Event);
		type1Btn.onClick.AddListener(Type1Event);
		type2Btn.onClick.AddListener(Type2Event);
		PaperEvent();
		BaseManager<EventCenter>.Instance.AddEventListener<ArtInfo>(EventNames.AddTextureConfig, AddTextureConfig);
		BaseManager<EventCenter>.Instance.AddEventListener<ArtInfo>(EventNames.RemoveTextureConfig, RemoveTextureConfig);
		BaseManager<EventCenter>.Instance.AddEventListener<ArtInfo>(EventNames.AddVideoConfig, AddVideoConfig);
		BaseManager<EventCenter>.Instance.AddEventListener<ArtInfo>(EventNames.RemoveVideoConfig, RemoveVideoConfig);
		BaseManager<EventCenter>.Instance.AddEventListener(EventNames.InitWorkArt, InitWorkArt);
	}

	public void Clear()
	{
		for (int num = paperContent.childCount - 1; num >= 0; num--)
		{
			Transform child = paperContent.GetChild(num);
			child.parent = null;
			UnityEngine.Object.Destroy(child.gameObject);
		}
		for (int num2 = videoContent.childCount - 1; num2 >= 0; num2--)
		{
			Transform child2 = videoContent.GetChild(num2);
			child2.parent = null;
			UnityEngine.Object.Destroy(child2.gameObject);
		}
		leftBtn.onClick.RemoveAllListeners();
		rightBtn.onClick.RemoveAllListeners();
		backBtn.onClick.RemoveAllListeners();
		applyBtn.onClick.RemoveAllListeners();
		destroyBtn.onClick.RemoveAllListeners();
		paperBtn.onClick.RemoveAllListeners();
		videoBtn.onClick.RemoveAllListeners();
		frameBtn.onClick.RemoveAllListeners();
		type0Btn.onClick.RemoveAllListeners();
		type1Btn.onClick.RemoveAllListeners();
		type2Btn.onClick.RemoveAllListeners();
	}

	public void InitWorkArt()
	{
		for (int num = paperContent.childCount - 1; num >= 0; num--)
		{
			Transform child = paperContent.GetChild(num);
			child.parent = null;
			BaseManager<PoolManager>.Instance.SetPool(GlobeConfig.textureName, child.gameObject);
		}
		for (int num2 = videoContent.childCount - 1; num2 >= 0; num2--)
		{
			Transform child2 = videoContent.GetChild(num2);
			child2.parent = null;
			BaseManager<PoolManager>.Instance.SetPool(GlobeConfig.videoName, child2);
		}
		Vector2 itemSize = new Vector2(GlobeConfig.textureWidth, GlobeConfig.textureHeight);
		List<ArtInfo> list = new List<ArtInfo>();
		paperGreatScrollPanel._itemSize = itemSize;
		videoGreatScrollPanel._itemSize = new Vector2(GlobeConfig.videoWidth, GlobeConfig.videoHeight);
		for (int i = 0; i < GlobeConfig.ArtInfoManager.artInfos.Count; i++)
		{
			ArtInfo artInfo = GlobeConfig.ArtInfoManager.artInfos[i];
			if (!artInfo.isSelf)
			{
				continue;
			}
			if (artInfo.videoPath == null || artInfo.videoPath == "")
			{
				if (File.Exists(artInfo.imagePath))
				{
					AddTextureChild(artInfo, paperContent);
				}
				else
				{
					list.Add(artInfo);
				}
			}
			else if (File.Exists(artInfo.videoPath))
			{
				AddVideoChild(artInfo, videoContent);
			}
			else
			{
				list.Add(artInfo);
			}
		}
		for (int j = 0; j < list.Count; j++)
		{
			GlobeConfig.ArtInfoManager.artInfos.Remove(list[j]);
		}
		JsonMgr.Instance.SaveData(GlobeConfig.ArtInfoManager, GlobeConfig.ArtFileName);
	}

	public void AddVideoChild(ArtInfo videoConfig, Transform content)
	{
		GameObject obj = BaseManager<PoolManager>.Instance.GetPrefab(GlobeConfig.videoName, GlobeConfig.videoPath) as GameObject;
		obj.transform.SetParent(content);
		obj.GetComponent<VideoToImage>().Init(videoConfig);
	}

	public void Show()
	{
		GlobeConfig.SetActive(base.gameObject, active: true);
	}

	public void Hide()
	{
		GlobeConfig.SetActive(base.gameObject, active: false);
	}

	public void RemoveVideoConfig(ArtInfo videoConfig)
	{
		if (videoConfig != null && GlobeConfig.ArtInfoManager.artInfos.Contains(videoConfig))
		{
			GlobeConfig.ArtInfoManager.artInfos.Remove(videoConfig);
			JsonMgr.Instance.SaveData(GlobeConfig.ArtInfoManager, GlobeConfig.ArtFileName);
		}
	}

	public void AddVideoConfig(ArtInfo videoConfig)
	{
		if (videoConfig == null)
		{
			return;
		}
		if (!GlobeConfig.ArtInfoManager.artInfos.Contains(videoConfig))
		{
			GlobeConfig.ArtInfoManager.artInfos.Add(videoConfig);
			JsonMgr.Instance.SaveData(GlobeConfig.ArtInfoManager, GlobeConfig.ArtFileName);
		}
		int num = 0;
		for (int i = 0; i < GlobeConfig.ArtInfoManager.artInfos.Count; i++)
		{
			string videoPath = GlobeConfig.ArtInfoManager.artInfos[i].videoPath;
			if (videoPath != null && videoPath != "")
			{
				num++;
			}
		}
		if (videoContent.childCount < num && videoConfig.videoPath != null && !(videoConfig.videoPath == ""))
		{
			AddVideoChild(videoConfig, videoContent);
			if (!videoGreatScrollPanel.isAwake)
			{
				videoGreatScrollPanel.Awake();
			}
			videoGreatScrollPanel.Init();
			videoGreatScrollPanel.SnapItem(videoGreatScrollPanel.CenterIndex);
		}
	}

	public void RemoveTextureConfig(ArtInfo imageInfo)
	{
		if (imageInfo != null && GlobeConfig.ArtInfoManager.artInfos.Contains(imageInfo))
		{
			GlobeConfig.ArtInfoManager.artInfos.Remove(imageInfo);
			JsonMgr.Instance.SaveData(GlobeConfig.ArtInfoManager, GlobeConfig.ArtFileName);
		}
	}

	public void AddTextureConfig(ArtInfo imageInfo)
	{
		if (imageInfo == null)
		{
			return;
		}
		if (!GlobeConfig.ArtInfoManager.artInfos.Contains(imageInfo))
		{
			GlobeConfig.ArtInfoManager.artInfos.Add(imageInfo);
			JsonMgr.Instance.SaveData(GlobeConfig.ArtInfoManager, GlobeConfig.ArtFileName);
		}
		if (videoContent.childCount < GlobeConfig.ArtInfoManager.artInfos.Count && (imageInfo.videoPath == null || !(imageInfo.videoPath != "")))
		{
			AddTextureChild(imageInfo, paperContent);
			if (!paperGreatScrollPanel.isAwake)
			{
				paperGreatScrollPanel.Awake();
			}
			paperGreatScrollPanel.Init();
			paperGreatScrollPanel.SnapItem(paperGreatScrollPanel.CenterIndex);
		}
	}

	public void FrameEvent()
	{
		GlobeConfig.SetActive(frameBtns, !frameBtns.activeInHierarchy);
	}

	public void Type0Event()
	{
		int contentIndex = GetContentIndex();
		ArtInfo artInfo = GlobeConfig.ArtInfoManager.artInfos[contentIndex];
		Transform transform = paperContent.GetChild(contentIndex).Find("outLine");
		RawImage component = transform.GetComponent<RawImage>();
		PaperType paperType = ((artInfo.outLineType == PaperType.None) ? artInfo.paperType : artInfo.outLineType);
		switch (paperType)
		{
		case PaperType.ColorA_Type_All:
		case PaperType.ColorA_Type_Rectangle:
		case PaperType.ColorA_Type_Three:
			GlobeConfig.SetActive(transform.gameObject, !transform.gameObject.activeSelf);
			break;
		case PaperType.ColorB_Type_All:
		case PaperType.ColorC_Type_All:
			GlobeConfig.SetActive(transform.gameObject, active: true);
			paperType = PaperType.ColorA_Type_All;
			break;
		case PaperType.ColorB_Type_Rectangle:
		case PaperType.ColorC_Type_Rectangle:
			GlobeConfig.SetActive(transform.gameObject, active: true);
			paperType = PaperType.ColorA_Type_Rectangle;
			break;
		case PaperType.ColorB_Type_Three:
		case PaperType.ColorC_Type_Three:
			GlobeConfig.SetActive(transform.gameObject, active: true);
			paperType = PaperType.ColorA_Type_Three;
			break;
		}
		SetOutLineTexture(paperType, component, transform, artInfo);
	}

	public void Type1Event()
	{
		int contentIndex = GetContentIndex();
		ArtInfo artInfo = GlobeConfig.ArtInfoManager.artInfos[contentIndex];
		Transform transform = paperContent.GetChild(contentIndex).Find("outLine");
		RawImage component = transform.GetComponent<RawImage>();
		PaperType paperType = ((artInfo.outLineType == PaperType.None) ? artInfo.paperType : artInfo.outLineType);
		switch (paperType)
		{
		case PaperType.ColorB_Type_All:
		case PaperType.ColorB_Type_Rectangle:
		case PaperType.ColorB_Type_Three:
			GlobeConfig.SetActive(transform.gameObject, !transform.gameObject.activeSelf);
			break;
		case PaperType.ColorA_Type_All:
		case PaperType.ColorC_Type_All:
			GlobeConfig.SetActive(transform.gameObject, active: true);
			paperType = PaperType.ColorB_Type_All;
			break;
		case PaperType.ColorA_Type_Rectangle:
		case PaperType.ColorC_Type_Rectangle:
			GlobeConfig.SetActive(transform.gameObject, active: true);
			paperType = PaperType.ColorB_Type_Rectangle;
			break;
		case PaperType.ColorA_Type_Three:
		case PaperType.ColorC_Type_Three:
			GlobeConfig.SetActive(transform.gameObject, active: true);
			paperType = PaperType.ColorB_Type_Three;
			break;
		}
		SetOutLineTexture(paperType, component, transform, artInfo);
	}

	public void Type2Event()
	{
		int contentIndex = GetContentIndex();
		ArtInfo artInfo = GlobeConfig.ArtInfoManager.artInfos[contentIndex];
		Transform transform = paperContent.GetChild(contentIndex).Find("outLine");
		RawImage component = transform.GetComponent<RawImage>();
		PaperType paperType = ((artInfo.outLineType == PaperType.None) ? artInfo.paperType : artInfo.outLineType);
		switch (paperType)
		{
		case PaperType.ColorC_Type_All:
		case PaperType.ColorC_Type_Rectangle:
		case PaperType.ColorC_Type_Three:
			GlobeConfig.SetActive(transform.gameObject, !transform.gameObject.activeSelf);
			break;
		case PaperType.ColorA_Type_All:
		case PaperType.ColorB_Type_All:
			GlobeConfig.SetActive(transform.gameObject, active: true);
			paperType = PaperType.ColorC_Type_All;
			break;
		case PaperType.ColorA_Type_Rectangle:
		case PaperType.ColorB_Type_Rectangle:
			GlobeConfig.SetActive(transform.gameObject, active: true);
			paperType = PaperType.ColorC_Type_Rectangle;
			break;
		case PaperType.ColorA_Type_Three:
		case PaperType.ColorB_Type_Three:
			GlobeConfig.SetActive(transform.gameObject, active: true);
			paperType = PaperType.ColorC_Type_Three;
			break;
		}
		SetOutLineTexture(paperType, component, transform, artInfo);
	}

	private void SetOutLineTexture(PaperType paperType, RawImage rawImage, Transform outLine, ArtInfo textureConfig)
	{
		textureConfig.outLineType = paperType;
		rawImage.texture = BaseManager<AssetsManager>.Instance.OutLines[paperType][textureConfig.paperIndex];
		rawImage.rectTransform.sizeDelta = GlobeConfig.GetNameWidthHeight(rawImage.texture.name) * GlobeConfig.paperUiRatio;
		if (outLine.gameObject.activeSelf)
		{
			textureConfig.outLineIndex = textureConfig.paperIndex;
		}
		else
		{
			textureConfig.outLineIndex = -1;
			rawImage.texture = null;
		}
		JsonMgr.Instance.SaveData(GlobeConfig.ArtInfoManager, GlobeConfig.ArtFileName);
	}

	public void PaperEvent()
	{
		GlobeConfig.SetActive(paperGreatScrollPanel.gameObject, active: true);
		GlobeConfig.SetActive(videoGreatScrollPanel.gameObject, active: false);
		GlobeConfig.SetActive(paperBtn.gameObject, active: false);
		GlobeConfig.SetActive(videoBtn.gameObject, active: true);
	}

	public void VideoEvent()
	{
		GlobeConfig.SetActive(paperGreatScrollPanel.gameObject, active: false);
		GlobeConfig.SetActive(videoGreatScrollPanel.gameObject, active: true);
		GlobeConfig.SetActive(paperBtn.gameObject, active: true);
		GlobeConfig.SetActive(videoBtn.gameObject, active: false);
	}

	public void ApplyEvent()
	{
		int contentIndex = GetContentIndex();
		if (contentIndex == -1 || !paperContent.GetChild(contentIndex))
		{
			BaseManager<EventCenter>.Instance.EventTrigger(EventNames.ShowToast, "应用失败！");
			return;
		}
		ArtInfo artInfo = GlobeConfig.ArtInfoManager.artInfos[contentIndex];
		GlobeConfig.AppConfig.paperIndex = artInfo.paperIndex;
		GlobeConfig.AppConfig.paperType = artInfo.paperType;
		Texture[] info = new Texture[2]
		{
			BaseManager<AssetsManager>.Instance.Papers[GlobeConfig.AppConfig.paperType][GlobeConfig.AppConfig.paperIndex],
			paperContent.GetChild(contentIndex).Find("IconForward").GetComponent<RawImage>()
				.texture
		};
		BaseManager<EventCenter>.Instance.EventTrigger(EventNames.WorkApplyClick, info);
		BaseManager<EventCenter>.Instance.EventTrigger(EventNames.ShowToast, "应用成功！");
	}

	public void DestrorEvent()
	{
		if (paperGreatScrollPanel.gameObject.activeInHierarchy)
		{
			int index = GetContentIndex();
			if (index == -1)
			{
				BaseManager<EventCenter>.Instance.EventTrigger(EventNames.ShowToast, "删除失败！");
				return;
			}
			int artIndex = GetArtIndex(index, isTexture: true);
			if (artIndex == -1)
			{
				BaseManager<EventCenter>.Instance.EventTrigger(EventNames.ShowToast, "删除失败！");
				return;
			}
			ArtInfo imageInfo = GlobeConfig.ArtInfoManager.artInfos[artIndex];
			BaseManager<HttpDataManager>.Instance.DeleteWorkData(imageInfo.artPostInfo, delegate
			{
				BaseManager<AssetsManager>.Instance.DeleteFile(imageInfo.imagePath);
				BaseManager<AssetsManager>.Instance.DeleteFile(imageInfo.imageResPath);
				RemoveTextureConfig(imageInfo);
				Transform child2 = paperContent.GetChild(index);
				child2.SetParent(null);
				GlobeConfig.SetActive(child2.transform.Find("IconForward").gameObject, active: false);
				BaseManager<PoolManager>.Instance.SetPool(GlobeConfig.textureName, child2.gameObject);
				if (paperGreatScrollPanel.transform.childCount > 0)
				{
					paperGreatScrollPanel.Init();
					paperGreatScrollPanel.SnapItem((index - 1 > 0) ? (index - 1) : 0);
				}
				BaseManager<EventCenter>.Instance.EventTrigger(EventNames.ShowToast, "删除成功！");
			});
		}
		else
		{
			if (!videoGreatScrollPanel.gameObject.activeInHierarchy)
			{
				return;
			}
			int index2 = -1;
			if ((bool)videoGreatScrollPanel)
			{
				index2 = videoGreatScrollPanel.CenterIndex;
			}
			if (index2 == -1)
			{
				BaseManager<EventCenter>.Instance.EventTrigger(EventNames.ShowToast, "删除失败！");
				return;
			}
			int artIndex2 = GetArtIndex(index2, isTexture: false);
			if (artIndex2 == -1)
			{
				BaseManager<EventCenter>.Instance.EventTrigger(EventNames.ShowToast, "删除失败！");
				return;
			}
			ArtInfo videoConfig = GlobeConfig.ArtInfoManager.artInfos[artIndex2];
			BaseManager<HttpDataManager>.Instance.DeleteWorkData(videoConfig.artPostInfo, delegate
			{
				BaseManager<AssetsManager>.Instance.DeleteFile(videoConfig.imagePath);
				BaseManager<AssetsManager>.Instance.DeleteFile(videoConfig.imageResPath);
				BaseManager<AssetsManager>.Instance.DeleteFile(videoConfig.videoPath);
				RemoveVideoConfig(videoConfig);
				Transform child = videoContent.GetChild(index2);
				child.SetParent(null);
				BaseManager<PoolManager>.Instance.SetPool(GlobeConfig.videoName, child.gameObject);
				if (videoGreatScrollPanel.transform.childCount > 0)
				{
					videoGreatScrollPanel.Init();
					videoGreatScrollPanel.SnapItem((index2 - 1 > 0) ? (index2 - 1) : 0);
				}
				BaseManager<EventCenter>.Instance.EventTrigger(EventNames.ShowToast, "删除成功！");
			});
		}
	}

	public int GetArtIndex(int index, bool isTexture)
	{
		int num = -1;
		for (int i = 0; i < GlobeConfig.ArtInfoManager.artInfos.Count; i++)
		{
			if (isTexture && GlobeConfig.ArtInfoManager.artInfos[i].videoPath == "")
			{
				num++;
			}
			else if (!isTexture && GlobeConfig.ArtInfoManager.artInfos[i].videoPath != "")
			{
				num++;
			}
			if (num == index)
			{
				return i;
			}
		}
		return num;
	}

	public int GetContentIndex()
	{
		int result = -1;
		if ((bool)paperGreatScrollPanel)
		{
			result = paperGreatScrollPanel.CenterIndex;
		}
		return result;
	}

	public void LeftEvent()
	{
		if (paperGreatScrollPanel.gameObject.activeSelf)
		{
			int num = paperGreatScrollPanel.CenterIndex - 1;
			num = ((num >= 0) ? num : 0);
			paperGreatScrollPanel.SnapItem(num);
		}
		if (videoGreatScrollPanel.gameObject.activeSelf)
		{
			int num2 = videoGreatScrollPanel.CenterIndex - 1;
			num2 = ((num2 >= 0) ? num2 : 0);
			videoGreatScrollPanel.SnapItem(num2);
		}
	}

	public void RightEvent()
	{
		if (paperGreatScrollPanel.gameObject.activeSelf)
		{
			int num = paperGreatScrollPanel.CenterIndex + 1;
			num = ((num > paperContent.childCount - 1) ? (paperContent.transform.childCount - 1) : num);
			num = ((num >= 0) ? num : 0);
			paperGreatScrollPanel.SnapItem(num);
		}
		if (videoGreatScrollPanel.gameObject.activeSelf)
		{
			int num2 = videoGreatScrollPanel.CenterIndex + 1;
			num2 = ((num2 > videoContent.childCount - 1) ? (videoContent.transform.childCount - 1) : num2);
			num2 = ((num2 >= 0) ? num2 : 0);
			videoGreatScrollPanel.SnapItem(num2);
		}
	}

	public void BackEvent()
	{
		BaseManager<EventCenter>.Instance.EventTrigger(EventNames.ShowPanel, PanelType.Main);
	}

	public void AddTextureChild(ArtInfo imageInfo, Transform content, bool isShowName = false)
	{
		GameObject obj = BaseManager<PoolManager>.Instance.GetPrefab(GlobeConfig.textureName, GlobeConfig.texturePath) as GameObject;
		obj.transform.SetParent(content);
		float num = (float)GlobeConfig.paperRatio / ((float)GlobeConfig.paperUiRatio * 1f);
		Texture2D texture2D = BaseManager<AssetsManager>.Instance.LoadImage(imageInfo.imagePath);
		Transform transform = obj.transform.Find("Icon");
		Transform transform2 = obj.transform.Find("IconForward");
		Transform transform3 = obj.transform.Find("outLine");
		Transform transform4 = obj.transform.Find("bg");
		Text component = obj.transform.Find("name").GetComponent<Text>();
		RawImage component2 = transform.GetComponent<RawImage>();
		component2.texture = BaseManager<AssetsManager>.Instance.Papers[imageInfo.paperType][imageInfo.paperIndex];
		component2.rectTransform.sizeDelta = new Vector2((float)texture2D.width / num, (float)texture2D.height / num);
		GlobeConfig.SetActive(transform2.gameObject, active: true);
		RawImage component3 = transform2.GetComponent<RawImage>();
		component3.texture = texture2D;
		component3.rectTransform.sizeDelta = new Vector2((float)texture2D.width / num, (float)texture2D.height / num);
		GlobeConfig.SetActive(transform3.gameObject, active: false);
		GlobeConfig.SetActive(transform4.gameObject, isShowName);
		Vector3 localPosition = transform4.transform.localPosition;
		localPosition.y = (float)(-texture2D.height) / num;
		transform4.transform.localPosition = localPosition;
		GlobeConfig.SetActive(component.gameObject, isShowName);
		Vector3 localPosition2 = component.transform.localPosition;
		localPosition2.y = (float)(-texture2D.height) / num;
		component.transform.localPosition = localPosition2;
		component.text = "";
	}
}
public class SealDraw : MonoBehaviour
{
	public Texture paperTexture;

	public Material paperMat;

	public RawImage sealRawImage;

	public RenderTexture sealTexture;

	private int width;

	private int height;

	public TextUvs textUvs;

	public Text drawText;

	public Material drawMat;

	private Texture drawTexture;

	private Color drawColor;

	public Button showBtn;

	public Button bgBtn;

	public Button reverseBtn;

	public Button saveBtn;

	public Button applyBtn;

	private Vector2[] targetUVs = new Vector2[16]
	{
		new Vector2(0.5f, 0.5f),
		new Vector2(0.9f, 0.5f),
		new Vector2(0.9f, 0.9f),
		new Vector2(0.5f, 0.9f),
		new Vector2(0.5f, 0.1f),
		new Vector2(0.9f, 0.1f),
		new Vector2(0.9f, 0.5f),
		new Vector2(0.5f, 0.5f),
		new Vector2(0.1f, 0.5f),
		new Vector2(0.5f, 0.5f),
		new Vector2(0.5f, 0.9f),
		new Vector2(0.1f, 0.9f),
		new Vector2(0.1f, 0.1f),
		new Vector2(0.5f, 0.1f),
		new Vector2(0.5f, 0.5f),
		new Vector2(0.1f, 0.5f)
	};

	private void Awake()
	{
		InitTextDraw();
	}

	public void InitTextDraw()
	{
		width = (int)drawText.rectTransform.sizeDelta.x;
		height = (int)drawText.rectTransform.sizeDelta.y;
		sealTexture = new RenderTexture(width, height, 24, RenderTextureFormat.ARGB32);
		drawMat = drawText.font.material;
		drawTexture = drawText.font.material.mainTexture;
		drawColor = Color.red;
		Clear(sealTexture, paperMat, paperTexture, drawColor);
		showBtn?.onClick.AddListener(ShowSeal);
		saveBtn?.onClick.AddListener(SaveSeal);
		bgBtn?.onClick.AddListener(BackGroundSeal);
		reverseBtn?.onClick.AddListener(ReverseSeal);
		applyBtn?.onClick.AddListener(ApplySeal);
	}

	public void ReverseSeal()
	{
	}

	public void BackGroundSeal()
	{
	}

	public void ApplySeal()
	{
	}

	public void SaveSeal()
	{
		Texture2D texture2D = new Texture2D(width, height, TextureFormat.RGBA32, mipChain: false);
		Rect source = new Rect(0f, 0f, width, height);
		RenderTexture.active = sealTexture;
		texture2D.ReadPixels(source, 0, 0);
		texture2D.Apply();
		RenderTexture.active = null;
		byte[] bytes = texture2D.EncodeToPNG();
		string text = DateTime.Now.ToLocalTime().ToString("yyyy-MM-dd HH:mm:ss");
		File.WriteAllBytes(GlobeConfig.AssetsPath + text + ".png", bytes);
	}

	public void ShowSeal()
	{
		Vector2[] uvs = textUvs.uvs;
		for (int i = 0; i < uvs.Length && i < targetUVs.Length; i += 4)
		{
			Vector2[] texCoord2s = new Vector2[4]
			{
				uvs[i + 3],
				uvs[i + 2],
				uvs[i + 1],
				uvs[i]
			};
			Vector2[] targets = new Vector2[4]
			{
				targetUVs[i],
				targetUVs[i + 1],
				targetUVs[i + 2],
				targetUVs[i + 3]
			};
			DrawString(sealTexture, drawMat, drawTexture, drawColor, texCoord2s, targets);
		}
		sealRawImage.texture = sealTexture;
	}

	public void Clear(RenderTexture destTexture, Material drawMat, Texture bgTexture, Color drawColor)
	{
		Graphics.SetRenderTarget(destTexture);
		GL.PushMatrix();
		GL.Clear(clearDepth: true, clearColor: true, Color.clear);
		GL.PopMatrix();
		DrawTexture(destTexture, drawMat, bgTexture, drawColor);
	}

	private void DrawString(RenderTexture destTexture, Material drawMat, Texture drawTexture, Color drawColor, Vector2[] texCoord2s, Vector2[] targets)
	{
		Graphics.SetRenderTarget(destTexture);
		GL.PushMatrix();
		GL.LoadOrtho();
		drawMat.SetTexture("_MainTex", drawTexture);
		drawMat.SetColor("_Color", drawColor);
		drawMat.SetPass(0);
		GL.Begin(7);
		GL.TexCoord2(texCoord2s[0].x, texCoord2s[0].y);
		GL.Vertex3(targets[0].x, targets[0].y, 0f);
		GL.TexCoord2(texCoord2s[1].x, texCoord2s[1].y);
		GL.Vertex3(targets[1].x, targets[1].y, 0f);
		GL.TexCoord2(texCoord2s[2].x, texCoord2s[2].y);
		GL.Vertex3(targets[2].x, targets[2].y, 0f);
		GL.TexCoord2(texCoord2s[3].x, texCoord2s[3].y);
		GL.Vertex3(targets[3].x, targets[3].y, 0f);
		GL.End();
		GL.PopMatrix();
	}

	private void DrawTexture(RenderTexture destTexture, Material drawMat, Texture drawTexture, Color drawColor)
	{
		Graphics.SetRenderTarget(destTexture);
		GL.PushMatrix();
		GL.LoadOrtho();
		drawMat.SetTexture("_MainTex", drawTexture);
		drawMat.SetColor("_Color", drawColor);
		drawMat.SetPass(0);
		GL.Begin(7);
		GL.TexCoord2(0f, 0f);
		GL.Vertex3(0f, 0f, 0f);
		GL.TexCoord2(1f, 0f);
		GL.Vertex3(1f, 0f, 0f);
		GL.TexCoord2(1f, 1f);
		GL.Vertex3(1f, 1f, 0f);
		GL.TexCoord2(0f, 1f);
		GL.Vertex3(0f, 1f, 0f);
		GL.End();
		GL.PopMatrix();
	}
}
public class SealManager : BaseManager<SealManager>
{
	private Vector2[] targetUV4s = new Vector2[16]
	{
		new Vector2(0.5f, 0.5f),
		new Vector2(0.9f, 0.5f),
		new Vector2(0.9f, 0.9f),
		new Vector2(0.5f, 0.9f),
		new Vector2(0.5f, 0.1f),
		new Vector2(0.9f, 0.1f),
		new Vector2(0.9f, 0.5f),
		new Vector2(0.5f, 0.5f),
		new Vector2(0.1f, 0.5f),
		new Vector2(0.5f, 0.5f),
		new Vector2(0.5f, 0.9f),
		new Vector2(0.1f, 0.9f),
		new Vector2(0.1f, 0.1f),
		new Vector2(0.5f, 0.1f),
		new Vector2(0.5f, 0.5f),
		new Vector2(0.1f, 0.5f)
	};

	private Vector2[] targetUV2s = new Vector2[8]
	{
		new Vector2(0.1f, 0.5f),
		new Vector2(0.9f, 0.5f),
		new Vector2(0.9f, 0.9f),
		new Vector2(0.1f, 0.9f),
		new Vector2(0.1f, 0.1f),
		new Vector2(0.9f, 0.1f),
		new Vector2(0.9f, 0.5f),
		new Vector2(0.1f, 0.5f)
	};

	public RenderTexture GetSealTexture(string sealData, RenderTexture renderTexture, Material sealMat, Text text, Color color, bool isReverse)
	{
		if (sealData.Length == 1 || sealData.Length == 3)
		{
			sealData += "印";
		}
		text.text = sealData;
		TextUvs component = text.GetComponent<TextUvs>();
		if (!component)
		{
			return renderTexture;
		}
		Vector2[] uvs = component.uvs;
		sealMat.SetInt("_IsReverse", isReverse ? 1 : 0);
		Texture mainTexture = text.font.material.mainTexture;
		if (sealData.Length <= 2)
		{
			for (int i = 0; i < uvs.Length && i < targetUV2s.Length; i += 4)
			{
				Vector2[] texCoord2s = new Vector2[4]
				{
					uvs[i + 3],
					uvs[i + 2],
					uvs[i + 1],
					uvs[i]
				};
				Vector2[] targets = new Vector2[4]
				{
					targetUV2s[i],
					targetUV2s[i + 1],
					targetUV2s[i + 2],
					targetUV2s[i + 3]
				};
				DrawString(renderTexture, sealMat, mainTexture, color, texCoord2s, targets);
			}
		}
		else
		{
			for (int j = 0; j < uvs.Length && j < targetUV4s.Length; j += 4)
			{
				Vector2[] texCoord2s2 = new Vector2[4]
				{
					uvs[j + 3],
					uvs[j + 2],
					uvs[j + 1],
					uvs[j]
				};
				Vector2[] targets2 = new Vector2[4]
				{
					targetUV4s[j],
					targetUV4s[j + 1],
					targetUV4s[j + 2],
					targetUV4s[j + 3]
				};
				DrawString(renderTexture, sealMat, mainTexture, color, texCoord2s2, targets2);
			}
		}
		return renderTexture;
	}

	public RenderTexture Clear(RenderTexture destTexture, Material drawMat, Texture bgTexture, Color drawColor)
	{
		Graphics.SetRenderTarget(destTexture);
		GL.PushMatrix();
		GL.Clear(clearDepth: true, clearColor: true, Color.clear);
		GL.PopMatrix();
		drawMat.SetInt("_IsReverse", 0);
		DrawTexture(destTexture, drawMat, bgTexture, drawColor);
		return destTexture;
	}

	private void DrawString(RenderTexture destTexture, Material drawMat, Texture drawTexture, Color drawColor, Vector2[] texCoord2s, Vector2[] targets)
	{
		Graphics.SetRenderTarget(destTexture);
		GL.PushMatrix();
		GL.LoadOrtho();
		drawMat.SetTexture("_MainTex", drawTexture);
		drawMat.SetColor("_Color", drawColor);
		drawMat.SetPass(0);
		GL.Begin(7);
		GL.TexCoord2(texCoord2s[0].x, texCoord2s[0].y);
		GL.Vertex3(targets[0].x, targets[0].y, 0f);
		GL.TexCoord2(texCoord2s[1].x, texCoord2s[1].y);
		GL.Vertex3(targets[1].x, targets[1].y, 0f);
		GL.TexCoord2(texCoord2s[2].x, texCoord2s[2].y);
		GL.Vertex3(targets[2].x, targets[2].y, 0f);
		GL.TexCoord2(texCoord2s[3].x, texCoord2s[3].y);
		GL.Vertex3(targets[3].x, targets[3].y, 0f);
		GL.End();
		GL.PopMatrix();
	}

	private void DrawTexture(RenderTexture destTexture, Material drawMat, Texture drawTexture, Color drawColor)
	{
		Graphics.SetRenderTarget(destTexture);
		GL.PushMatrix();
		GL.LoadOrtho();
		drawMat.SetTexture("_MainTex", drawTexture);
		drawMat.SetColor("_Color", drawColor);
		drawMat.SetPass(0);
		GL.Begin(7);
		GL.TexCoord2(0f, 0f);
		GL.Vertex3(0f, 0f, 0f);
		GL.TexCoord2(1f, 0f);
		GL.Vertex3(1f, 0f, 0f);
		GL.TexCoord2(1f, 1f);
		GL.Vertex3(1f, 1f, 0f);
		GL.TexCoord2(0f, 1f);
		GL.Vertex3(0f, 1f, 0f);
		GL.End();
		GL.PopMatrix();
	}
}
public class TextUvs : BaseMeshEffect
{
	public Vector2[] uvs;

	public override void ModifyMesh(VertexHelper vh)
	{
		UIVertex vertex = default(UIVertex);
		uvs = new Vector2[vh.currentVertCount];
		for (int i = 0; i < vh.currentVertCount; i++)
		{
			vh.PopulateUIVertex(ref vertex, i);
			vertex.uv1 = new Vector2(vertex.position.x, vertex.position.y);
			uvs[i] = new Vector2(vertex.uv0.x, vertex.uv0.y);
			vh.SetUIVertex(vertex, i);
		}
	}
}
public class ColorPick : MonoBehaviour
{
	public RawImage paint;

	public RawImage saturation;

	public RawImage hue;

	public RawImage alpha;

	public Button paintBtn;

	public ScrollRectClick scrollRectSaturation;

	public Scrollbar scrollbarHue;

	public Scrollbar scrollbarAlpha;

	private Vector4 currentColorHSV = new Vector4(0f, 1f, 1f, 1f);

	private readonly float piexlWidth = 256f;

	private readonly float piexlHeight = 256f;

	private readonly float huePiexWidth = 50f;

	private Texture2D saturationTexture2D;

	private Texture2D hueTexture2D;

	private Texture2D alphaTexture2D;

	private bool isShowPanel = true;

	public Color PaintColor => HSVToRGB(currentColorHSV);

	private void Start()
	{
		InitPaintPick();
	}

	public void UpdateColor(Color color)
	{
		color.a = currentColorHSV.w;
		currentColorHSV = RGBToHSV(color);
		PaintChange();
		UpdateSaturation(currentColorHSV);
		scrollbarHue.value = 1f - currentColorHSV.x;
		UpdateAlpha();
		UpdateSaturationPoint(currentColorHSV);
	}

	private void InitPaintPick()
	{
		paintBtn.onClick.AddListener(OnPaintClick);
		scrollRectSaturation.onValueChanged.AddListener(OnSaturationClick);
		scrollbarHue.onValueChanged.AddListener(OnHueClick);
		scrollbarAlpha.onValueChanged.AddListener(OnAlphaClick);
		PaintChange();
		saturationTexture2D = new Texture2D((int)piexlWidth, (int)piexlHeight);
		saturation.texture = saturationTexture2D;
		hueTexture2D = new Texture2D((int)huePiexWidth, (int)piexlHeight);
		hue.texture = hueTexture2D;
		alphaTexture2D = new Texture2D((int)huePiexWidth, (int)piexlHeight);
		alpha.texture = alphaTexture2D;
		scrollbarHue.value = 1f - currentColorHSV.x;
		scrollbarAlpha.value = currentColorHSV.w;
		UpdateSaturation(currentColorHSV);
		UpdateHue();
		UpdateAlpha();
		UpdateSaturationPoint(currentColorHSV);
	}

	private void PaintChange()
	{
		paint.color = PaintColor;
	}

	private void OnPaintClick()
	{
		isShowPanel = !isShowPanel;
		saturation.gameObject.SetActive(isShowPanel);
		hue.gameObject.SetActive(isShowPanel);
		alpha.gameObject.SetActive(isShowPanel);
	}

	public void OnSaturationClick(Vector2 point)
	{
		Vector2 saturationHSV = GetSaturationHSV(point);
		currentColorHSV.y = saturationHSV.x;
		currentColorHSV.z = saturationHSV.y;
		UpdateSaturationPoint(currentColorHSV);
		PaintChange();
		UpdateAlpha();
	}

	public void OnHueClick(float value)
	{
		currentColorHSV.x = 1f - value;
		UpdateSaturationPoint(currentColorHSV);
		PaintChange();
		UpdateSaturation(currentColorHSV);
		UpdateAlpha();
	}

	public void OnAlphaClick(float value)
	{
		currentColorHSV.w = value;
		UpdateSaturationPoint(currentColorHSV);
		PaintChange();
	}

	public void UpdateSaturation(Vector4 hsv)
	{
		for (int i = 0; (float)i < piexlHeight; i++)
		{
			for (int j = 0; (float)j < piexlWidth; j++)
			{
				Color color = GetSaturation(hsv, (float)j / piexlWidth, (float)i / piexlHeight);
				saturationTexture2D.SetPixel(j, i, color);
			}
		}
		saturationTexture2D.Apply();
		saturation.texture = saturationTexture2D;
	}

	public void UpdateHue()
	{
		for (int i = 0; (float)i < piexlHeight; i++)
		{
			for (int j = 0; (float)j < huePiexWidth; j++)
			{
				Color color = GetHue((float)i / piexlHeight);
				hueTexture2D.SetPixel(j, i, color);
			}
		}
		hueTexture2D.Apply();
		hue.texture = hueTexture2D;
	}

	public void UpdateAlpha()
	{
		for (int i = 0; (float)i < piexlHeight; i++)
		{
			Color color = GetAlpha((float)i / piexlHeight);
			for (int j = 0; (float)j < huePiexWidth; j++)
			{
				alphaTexture2D.SetPixel(j, (int)piexlHeight - i, color);
			}
		}
		alphaTexture2D.Apply();
		alpha.texture = alphaTexture2D;
	}

	private Color GetSaturation(Vector4 hsv, float x, float y)
	{
		Vector4 hsv2 = hsv;
		hsv2.y = x;
		hsv2.z = y;
		hsv2.w = 1f;
		return HSVToRGB(hsv2);
	}

	private Color GetHue(float y)
	{
		Vector4 hsv = new Vector4(y, currentColorHSV.y, currentColorHSV.z, 1f);
		return HSVToRGB(hsv);
	}

	private Color GetAlpha(float y)
	{
		Vector4 hsv = new Vector4(currentColorHSV.x, currentColorHSV.y, currentColorHSV.z, y);
		return HSVToRGB(hsv);
	}

	private Color HSVToRGB(Vector4 hsv)
	{
		Color result = Color.HSVToRGB(hsv.x, hsv.y, hsv.z);
		result.a = hsv.w;
		return result;
	}

	private Vector4 RGBToHSV(Color color)
	{
		Color.RGBToHSV(color, out var H, out var S, out var V);
		return new Vector4(H, S, V, color.a);
	}

	public void UpdateSaturationPoint(Vector4 hsv)
	{
		Vector2 saturationPoint = GetSaturationPoint(hsv);
		scrollRectSaturation.content.anchoredPosition = saturationPoint;
	}

	private Vector2 GetSaturationHSV(Vector2 point)
	{
		Vector2 result = default(Vector2);
		result.x = point.x / saturation.rectTransform.sizeDelta.x + 0.5f;
		result.y = point.y / saturation.rectTransform.sizeDelta.y + 0.5f;
		return result;
	}

	private Vector2 GetSaturationPoint(Vector4 hsv)
	{
		Vector2 result = default(Vector2);
		result.x = (hsv.y - 0.5f) * saturation.rectTransform.sizeDelta.x;
		result.y = (hsv.z - 0.5f) * saturation.rectTransform.sizeDelta.y;
		return result;
	}
}
public class ColorPicks : MonoBehaviour
{
	private void Awake()
	{
		Init();
	}

	private void Init()
	{
		int childCount = base.transform.childCount;
		for (int i = 0; i < childCount; i++)
		{
			RectTransform component = base.transform.GetChild(i).GetComponent<RectTransform>();
			component.GetComponent<BoxCollider>().size = new Vector3(component.sizeDelta.x, component.sizeDelta.y, 0f);
		}
	}

	public Color OnColorShade(Color destColor, Color sourceColor, float value)
	{
		Color color = sourceColor - destColor;
		color.a = ((color.g > 0f) ? Mathf.Max(color.a, 0f) : color.a);
		color.g = ((color.b > 0f) ? Mathf.Max(color.g, 0f) : color.g);
		color.b = ((color.a > 0f) ? Mathf.Max(color.b, 0f) : color.b);
		destColor += color * Mathf.Max(Mathf.Min(value, 1f), 0.01f);
		return destColor;
	}
}
public class ScrollRectClick : Selectable, IPointerDownHandler, IEventSystemHandler, IDragHandler
{
	public Camera headCamera;

	public RectTransform content;

	public Vector3 contentPoint;

	public Vector4 limitBounds;

	public ScrollRect.ScrollRectEvent onValueChanged;

	private RectTransform rect;

	private Vector3 screenPoint;

	protected override void Awake()
	{
		rect = base.transform.GetComponent<RectTransform>();
		limitBounds.x = (0f - rect.sizeDelta.x) / 2f;
		limitBounds.y = rect.sizeDelta.x / 2f;
		limitBounds.z = (0f - rect.sizeDelta.y) / 2f;
		limitBounds.w = rect.sizeDelta.y / 2f;
	}

	public override void OnPointerDown(PointerEventData eventData)
	{
		screenPoint = headCamera.WorldToScreenPoint(base.transform.position);
		Vector3 position = headCamera.ScreenToWorldPoint(new Vector3(eventData.position.x, eventData.position.y, screenPoint.z));
		contentPoint = rect.InverseTransformPoint(position);
		contentPoint.x = Mathf.Max(limitBounds.x, Mathf.Min(limitBounds.y, contentPoint.x));
		contentPoint.y = Mathf.Max(limitBounds.z, Mathf.Min(limitBounds.w, contentPoint.y));
		content.anchoredPosition = contentPoint;
		onValueChanged.Invoke(contentPoint);
	}

	public void OnDrag(PointerEventData eventData)
	{
		screenPoint = headCamera.WorldToScreenPoint(base.transform.position);
		Vector3 position = headCamera.ScreenToWorldPoint(new Vector3(eventData.position.x, eventData.position.y, screenPoint.z));
		contentPoint = rect.InverseTransformPoint(position);
		contentPoint.x = Mathf.Max(limitBounds.x, Mathf.Min(limitBounds.y, contentPoint.x));
		contentPoint.y = Mathf.Max(limitBounds.z, Mathf.Min(limitBounds.w, contentPoint.y));
		content.anchoredPosition = contentPoint;
		onValueChanged.Invoke(contentPoint);
	}
}
public class AssetsManager : BaseManager<AssetsManager>
{
	private Dictionary<PaperType, Texture[]> papers;

	private Dictionary<PaperType, Texture[]> outLines;

	public Dictionary<PaperType, Texture[]> OutLines
	{
		get
		{
			if (outLines == null)
			{
				LoadOutLines();
			}
			return outLines;
		}
	}

	public Dictionary<PaperType, Texture[]> Papers
	{
		get
		{
			if (papers == null)
			{
				LoadPapers();
			}
			return papers;
		}
	}

	private void LoadOutLines()
	{
		outLines = new Dictionary<PaperType, Texture[]>();
		OutLines[PaperType.ColorA_Type_All] = GlobeConfig.LoadTexture("textures/outLines/outLine0/type0");
		OutLines[PaperType.ColorA_Type_Rectangle] = GlobeConfig.LoadTexture("textures/outLines/outLine0/type1");
		OutLines[PaperType.ColorA_Type_Three] = GlobeConfig.LoadTexture("textures/outLines/outLine0/type2");
		OutLines[PaperType.ColorB_Type_All] = GlobeConfig.LoadTexture("textures/outLines/outLine1/type0");
		OutLines[PaperType.ColorB_Type_Rectangle] = GlobeConfig.LoadTexture("textures/outLines/outLine1/type1");
		OutLines[PaperType.ColorB_Type_Three] = GlobeConfig.LoadTexture("textures/outLines/outLine1/type2");
		OutLines[PaperType.ColorC_Type_All] = GlobeConfig.LoadTexture("textures/outLines/outLine2/type0");
		OutLines[PaperType.ColorC_Type_Rectangle] = GlobeConfig.LoadTexture("textures/outLines/outLine2/type1");
		OutLines[PaperType.ColorC_Type_Three] = GlobeConfig.LoadTexture("textures/outLines/outLine2/type2");
	}

	public void LoadPapers()
	{
		papers = new Dictionary<PaperType, Texture[]>();
		Papers[PaperType.ColorA_Type_All] = GlobeConfig.LoadTexture("textures/papers/paper0/type0");
		Papers[PaperType.ColorA_Type_Rectangle] = GlobeConfig.LoadTexture("textures/papers/paper0/type1");
		Papers[PaperType.ColorA_Type_Three] = GlobeConfig.LoadTexture("textures/papers/paper0/type2");
		Papers[PaperType.ColorB_Type_All] = GlobeConfig.LoadTexture("textures/papers/paper1/type0");
		Papers[PaperType.ColorB_Type_Rectangle] = GlobeConfig.LoadTexture("textures/papers/paper1/type1");
		Papers[PaperType.ColorB_Type_Three] = GlobeConfig.LoadTexture("textures/papers/paper1/type2");
		Papers[PaperType.ColorC_Type_All] = GlobeConfig.LoadTexture("textures/papers/paper2/type0");
		Papers[PaperType.ColorC_Type_Rectangle] = GlobeConfig.LoadTexture("textures/papers/paper2/type1");
		Papers[PaperType.ColorC_Type_Three] = GlobeConfig.LoadTexture("textures/papers/paper2/type2");
		Texture[] value = new Texture[3]
		{
			Papers[PaperType.ColorA_Type_All][0],
			Papers[PaperType.ColorB_Type_All][0],
			Papers[PaperType.ColorC_Type_All][0]
		};
		Papers[PaperType.Color_Select] = value;
	}

	public List<Texture2D> LoadImages(string path, int width, int height)
	{
		List<Texture2D> list = new List<Texture2D>();
		if (Directory.Exists(path))
		{
			FileInfo[] files = new DirectoryInfo(path).GetFiles("*");
			for (int i = 0; i < files.Length; i++)
			{
				if (!files[i].Name.EndsWith(".meta"))
				{
					Texture2D texture2D = new Texture2D(width, height);
					texture2D.LoadImage(File.ReadAllBytes(path + "/" + files[i].Name));
					list.Add(texture2D);
				}
			}
		}
		return list;
	}

	public Texture2D LoadImage(string path, int width = 0, int height = 0)
	{
		if (File.Exists(path))
		{
			return BytesToTexture2D(File.ReadAllBytes(path), width, height);
		}
		return null;
	}

	public Texture2D BytesToTexture2D(byte[] data, int width, int height)
	{
		Texture2D texture2D = new Texture2D(width, height);
		texture2D.LoadImage(data);
		return texture2D;
	}

	public Texture2D RenderToTexture(RenderTexture target)
	{
		int width = target.width;
		int height = target.height;
		Texture2D texture2D = new Texture2D(width, height);
		Rect source = new Rect(0f, 0f, width, height);
		RenderTexture.active = target;
		texture2D.ReadPixels(source, 0, 0);
		texture2D.Apply();
		RenderTexture.active = null;
		return texture2D;
	}

	public byte[] RenderTextureToBytes(RenderTexture target)
	{
		Texture2D texture2D = RenderToTexture(target);
		byte[] result = texture2D.EncodeToPNG();
		UnityEngine.Object.Destroy(texture2D);
		return result;
	}

	public string GetTimeName()
	{
		return DateTime.Now.ToLocalTime().ToString("yyyy.MM.dd_HH.mm.ss");
	}

	public bool SaveTexture(string path, RenderTexture target, string forwardName, out string fileName)
	{
		try
		{
			byte[] data = RenderTextureToBytes(target);
			string timeName = GetTimeName();
			fileName = path + "/" + forwardName + timeName + ".png";
			SaveBytes(path, fileName, data);
		}
		catch
		{
			fileName = "";
			return false;
		}
		return true;
	}

	public void SaveBytes(string path, string fileName, byte[] data)
	{
		if (!Directory.Exists(path))
		{
			Directory.CreateDirectory(path);
		}
		File.WriteAllBytes(fileName, data);
	}

	public bool DeleteFile(string path)
	{
		if (File.Exists(path))
		{
			File.Delete(path);
			return true;
		}
		return false;
	}
}
public class BaseManager<T> where T : new()
{
	private static T instance;

	public static T Instance
	{
		get
		{
			if (instance == null)
			{
				instance = new T();
			}
			return instance;
		}
	}
}
public class BezierCurse
{
	public static Vector3 errorPoint = new Vector3(-1000f, -1000f, -1000f);

	public static Vector3[] GetBezierCurse(Vector3 start, Vector3[] centers, Vector3 end, int count)
	{
		Vector3[] array = new Vector3[count];
		int num = centers.Length + 1;
		int[,] yanhui = YangHui(num + 1);
		for (int i = 0; i < count; i++)
		{
			float num2 = 1f / (float)count * (float)(i + 1);
			array[i] = start * Mathf.Pow(1f - num2, num) + end * Mathf.Pow(num2, num);
			Vector3 bezierCurseOffset = GetBezierCurseOffset(centers, yanhui, num, num2, 1);
			if (bezierCurseOffset != errorPoint)
			{
				array[i] += bezierCurseOffset;
			}
		}
		return array;
	}

	private static Vector3 GetBezierCurseOffset(Vector3[] centers, int[,] yanhui, int n, float t, int index)
	{
		Vector3 result = errorPoint;
		if (index < n)
		{
			result = centers[index - 1] * Mathf.Pow(1f - t, n - index) * Mathf.Pow(t, index) * yanhui[n, index];
			Vector3 bezierCurseOffset = GetBezierCurseOffset(centers, yanhui, n, t, index + 1);
			if (bezierCurseOffset != errorPoint)
			{
				result += bezierCurseOffset;
			}
		}
		return result;
	}

	public static int[,] YangHui(int value)
	{
		int[,] array = new int[value, value];
		for (int i = 0; i < value; i++)
		{
			for (int j = 0; j <= i; j++)
			{
				if (i == j || j == 0)
				{
					array[i, j] = 1;
				}
				else
				{
					array[i, j] = array[i - 1, j - 1] + array[i - 1, j];
				}
			}
		}
		return array;
	}
}
public interface IEventInfo
{
}
public class EventInfo<T> : IEventInfo
{
	public UnityAction<T> actions;

	public EventInfo(UnityAction<T> action)
	{
		actions = (UnityAction<T>)Delegate.Combine(actions, action);
	}
}
public class EventInfo : IEventInfo
{
	public UnityAction actions;

	public EventInfo(UnityAction action)
	{
		actions = (UnityAction)Delegate.Combine(actions, action);
	}
}
public class EventCenter : BaseManager<EventCenter>
{
	private Dictionary<string, IEventInfo> eventDic = new Dictionary<string, IEventInfo>();

	public void AddEventListener<T>(string name, UnityAction<T> action)
	{
		if (eventDic.ContainsKey(name))
		{
			EventInfo<T> obj = eventDic[name] as EventInfo<T>;
			obj.actions = (UnityAction<T>)Delegate.Combine(obj.actions, action);
		}
		else
		{
			eventDic.Add(name, new EventInfo<T>(action));
		}
	}

	public void AddEventListener(string name, UnityAction action)
	{
		if (eventDic.ContainsKey(name))
		{
			EventInfo obj = eventDic[name] as EventInfo;
			obj.actions = (UnityAction)Delegate.Combine(obj.actions, action);
		}
		else
		{
			eventDic.Add(name, new EventInfo(action));
		}
	}

	public void RemoveEventListener<T>(string name, UnityAction<T> action)
	{
		if (eventDic.ContainsKey(name))
		{
			EventInfo<T> obj = eventDic[name] as EventInfo<T>;
			obj.actions = (UnityAction<T>)Delegate.Remove(obj.actions, action);
		}
	}

	public void RemoveEventListener(string name, UnityAction action)
	{
		if (eventDic.ContainsKey(name))
		{
			EventInfo obj = eventDic[name] as EventInfo;
			obj.actions = (UnityAction)Delegate.Remove(obj.actions, action);
		}
	}

	public void EventTrigger<T>(string name, T info)
	{
		if (eventDic.ContainsKey(name) && (eventDic[name] as EventInfo<T>).actions != null)
		{
			(eventDic[name] as EventInfo<T>).actions(info);
		}
	}

	public void EventTrigger(string name)
	{
		if (eventDic.ContainsKey(name) && (eventDic[name] as EventInfo).actions != null)
		{
			(eventDic[name] as EventInfo).actions();
		}
	}

	public void Clear()
	{
		eventDic.Clear();
	}
}
public enum JsonType
{
	JsonUtlity,
	LitJson
}
public class JsonMgr
{
	private static JsonMgr instance = new JsonMgr();

	public static JsonMgr Instance => instance;

	private JsonMgr()
	{
	}

	public void SaveData(object data, string fileName, JsonType type = JsonType.LitJson)
	{
		string path = fileName + ".json";
		string contents = ToJson(data, type);
		File.WriteAllText(path, contents);
	}

	public T LoadData<T>(string fileName, JsonType type = JsonType.LitJson) where T : new()
	{
		string path = fileName + ".json";
		if (!File.Exists(path))
		{
			path = Application.persistentDataPath + "/" + fileName + ".json";
		}
		if (!File.Exists(path))
		{
			return new T();
		}
		string jsonStr = File.ReadAllText(path);
		return ToObejct<T>(jsonStr, type);
	}

	public string ToJson(object data, JsonType type = JsonType.LitJson)
	{
		string result = "";
		switch (type)
		{
		case JsonType.JsonUtlity:
			result = JsonUtility.ToJson(data);
			break;
		case JsonType.LitJson:
			result = LitJson.JsonMapper.ToJson(data);
			break;
		}
		return result;
	}

	public T ToObejct<T>(string jsonStr, JsonType type = JsonType.LitJson) where T : new()
	{
		T val = default(T);
		return type switch
		{
			JsonType.JsonUtlity => JsonUtility.FromJson<T>(jsonStr), 
			JsonType.LitJson => LitJson.JsonMapper.ToObject<T>(jsonStr), 
			_ => val, 
		};
	}
}
public class MonoController : MonoBehaviour
{
	private event UnityAction updateEvent;

	private void Start()
	{
		UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
	}

	private void Update()
	{
		if (this.updateEvent != null)
		{
			this.updateEvent();
		}
	}

	public void AddUpdateListener(UnityAction fun)
	{
		updateEvent += fun;
	}

	public void RemoveUpdateListener(UnityAction fun)
	{
		updateEvent -= fun;
	}
}
public class MonoMgr : BaseManager<MonoMgr>
{
	private MonoController controller;

	public MonoMgr()
	{
		GameObject gameObject = new GameObject("MonoController");
		controller = gameObject.AddComponent<MonoController>();
	}

	public void AddUpdateListener(UnityAction fun)
	{
		controller.AddUpdateListener(fun);
	}

	public void RemoveUpdateListener(UnityAction fun)
	{
		controller.RemoveUpdateListener(fun);
	}

	public Coroutine StartCoroutine(IEnumerator routine)
	{
		return controller.StartCoroutine(routine);
	}

	public Coroutine StartCoroutine(string methodName, [DefaultValue("null")] object value)
	{
		return controller.StartCoroutine(methodName, value);
	}

	public Coroutine StartCoroutine(string methodName)
	{
		return controller.StartCoroutine(methodName);
	}
}
public class PoolData
{
	private UnityEngine.Object poolGame;

	public UnityEngine.Object GetPool()
	{
		if (poolGame != null)
		{
			return poolGame;
		}
		return null;
	}

	public void SetPool(UnityEngine.Object game)
	{
		if (game != null)
		{
			poolGame = game;
		}
	}

	public void Clear()
	{
		if (poolGame != null)
		{
			UnityEngine.Object.Destroy(poolGame);
		}
		poolGame = null;
	}
}
public class PoolData2
{
	private int maxCount = 100;

	private Stack<UnityEngine.Object> pool = new Stack<UnityEngine.Object>();

	public int PoolCount => pool.Count;

	public UnityEngine.Object GetPool()
	{
		if (pool.Count == 0)
		{
			return null;
		}
		return pool.Pop();
	}

	public void SetPool(UnityEngine.Object game)
	{
		if (!(game == null))
		{
			if (pool.Count >= maxCount)
			{
				UnityEngine.Object.Destroy(game);
			}
			if (!pool.Contains(game))
			{
				pool.Push(game);
			}
		}
	}

	public void Clear()
	{
		for (int i = 0; i < pool.Count; i++)
		{
			UnityEngine.Object.Destroy(pool.Pop());
		}
		pool.Clear();
	}
}
public class PoolManager : BaseManager<PoolManager>
{
	private Dictionary<string, PoolData2> poolDic = new Dictionary<string, PoolData2>();

	private Dictionary<string, PoolData> poolPrefabs = new Dictionary<string, PoolData>();

	public UnityEngine.Object GetPrefab(string name, string path)
	{
		if (poolDic.ContainsKey(name) && poolDic[name].PoolCount > 0)
		{
			return poolDic[name].GetPool();
		}
		if (!poolPrefabs.ContainsKey(name))
		{
			poolPrefabs[name] = new PoolData();
			poolPrefabs[name].SetPool(BaseManager<ResMgr>.Instance.Load<GameObject>(path));
		}
		return UnityEngine.Object.Instantiate(poolPrefabs[name].GetPool());
	}

	public UnityEngine.Object GetPool(string name)
	{
		if (poolDic.ContainsKey(name) && poolDic[name].PoolCount > 0)
		{
			return poolDic[name].GetPool();
		}
		return null;
	}

	public void SetPool(string name, UnityEngine.Object obj)
	{
		if (!(obj == null))
		{
			if (!poolDic.ContainsKey(name))
			{
				poolDic[name] = new PoolData2();
			}
			poolDic[name].SetPool(obj);
		}
	}

	public void Clear()
	{
		foreach (string key in poolDic.Keys)
		{
			poolDic[key].Clear();
		}
		foreach (string key2 in poolPrefabs.Keys)
		{
			poolPrefabs[key2].Clear();
		}
		poolDic.Clear();
		poolPrefabs.Clear();
	}
}
public class ResMgr : BaseManager<ResMgr>
{
	public T Load<T>(string name) where T : UnityEngine.Object
	{
		T val = Resources.Load<T>(name);
		if (val is GameObject)
		{
			return UnityEngine.Object.Instantiate(val);
		}
		return val;
	}

	public void LoadAsync<T>(string name, UnityAction<T> callback) where T : UnityEngine.Object
	{
		BaseManager<MonoMgr>.Instance.StartCoroutine(ReallyLoadAsync(name, callback));
	}

	private IEnumerator ReallyLoadAsync<T>(string name, UnityAction<T> callback) where T : UnityEngine.Object
	{
		ResourceRequest r = Resources.LoadAsync<T>(name);
		yield return r;
		if (r.asset is GameObject)
		{
			callback(UnityEngine.Object.Instantiate(r.asset) as T);
		}
		else
		{
			callback(r.asset as T);
		}
	}
}
[Serializable]
public class ScrollEffect
{
	public enum EffectType
	{
		LocalEularAnglesX,
		LocalEularAnglesY,
		LocalEularAnglesZ,
		LocalScaleX,
		LocalScaleY,
		LocalPositionZ,
		CustomEffect
	}

	public EffectType _effectType;

	public float _effectSpaceMin;

	public float _effectSpaceMax;

	public float _effectValueMin;

	public float _effectValueMax;

	public AnimationCurve _effectCurve;

	public float GetEffectValue(float space)
	{
		if (_effectCurve == null)
		{
			return 0f;
		}
		return _effectCurve.Evaluate(space);
	}
}
[RequireComponent(typeof(GreatScrollPanel))]
public class GreatScrollEffect : MonoBehaviour
{
	public class EffectEvent : UnityEvent<Transform, float>
	{
	}

	public List<ScrollEffect> _scrollEffects = new List<ScrollEffect>();

	private GreatScrollPanel _scrollPanel;

	private EffectEvent _onCustomEffect;

	public EffectEvent OnCustomEffect
	{
		get
		{
			if (_onCustomEffect == null)
			{
				_onCustomEffect = new EffectEvent();
			}
			return _onCustomEffect;
		}
	}

	private void Awake()
	{
		_scrollPanel = GetComponent<GreatScrollPanel>();
	}

	private void Update()
	{
		OnScrollEffect();
	}

	private void OnScrollEffect()
	{
		if (_scrollEffects.Count == 0)
		{
			return;
		}
		RectTransform[] itemsRT = _scrollPanel.ItemsRT;
		foreach (Transform transform in itemsRT)
		{
			float space = _scrollPanel.SpaceFromCenter(transform.position);
			foreach (ScrollEffect scrollEffect in _scrollEffects)
			{
				switch (scrollEffect._effectType)
				{
				case ScrollEffect.EffectType.LocalEularAnglesX:
				{
					Vector3 localEulerAngles3 = transform.localEulerAngles;
					localEulerAngles3.x = scrollEffect.GetEffectValue(space);
					transform.localRotation = Quaternion.Euler(localEulerAngles3);
					break;
				}
				case ScrollEffect.EffectType.LocalEularAnglesY:
				{
					Vector3 localEulerAngles2 = transform.localEulerAngles;
					localEulerAngles2.y = scrollEffect.GetEffectValue(space);
					transform.localRotation = Quaternion.Euler(localEulerAngles2);
					break;
				}
				case ScrollEffect.EffectType.LocalEularAnglesZ:
				{
					Vector3 localEulerAngles = transform.localEulerAngles;
					localEulerAngles.z = scrollEffect.GetEffectValue(space);
					transform.localRotation = Quaternion.Euler(localEulerAngles);
					break;
				}
				case ScrollEffect.EffectType.LocalScaleX:
					transform.localScale = new Vector3(scrollEffect.GetEffectValue(space), transform.localScale.y, 1f);
					break;
				case ScrollEffect.EffectType.LocalScaleY:
					transform.localScale = new Vector3(transform.localScale.x, scrollEffect.GetEffectValue(space), 1f);
					break;
				case ScrollEffect.EffectType.LocalPositionZ:
				{
					Vector3 localPosition = transform.localPosition;
					localPosition.z = scrollEffect.GetEffectValue(space);
					transform.localPosition = localPosition;
					break;
				}
				case ScrollEffect.EffectType.CustomEffect:
					OnCustomEffect.Invoke(transform, scrollEffect.GetEffectValue(space));
					break;
				}
			}
		}
	}
}
public class GreatScrollPanel : MonoBehaviour, IBeginDragHandler, IEventSystemHandler, IDragHandler, IEndDragHandler, IPointerDownHandler, IPointerUpHandler
{
	public enum ScrollAxis
	{
		Horizontal,
		Vertical,
		Free
	}

	public enum ItemSizeType
	{
		Custom,
		Fit
	}

	public enum ItemInitType
	{
		Dynamic,
		Static
	}

	public class ItemInitEvent : UnityEvent<Transform, int>
	{
	}

	public class ItemCenterEvent : UnityEvent<int>
	{
	}

	public ScrollAxis _scrollAxis;

	public ItemInitType _itemInitType = ItemInitType.Static;

	public GameObject _itemPrefab;

	public int _itemsCount;

	public bool _itemAutoLayout = true;

	public ItemSizeType _itemSizeType;

	public Vector2 _itemSize = new Vector2(120f, 170f);

	public float _itemSpacing = 20f;

	public bool _infinite;

	public float _snapSpeed = 10f;

	public float _snapThreshold = 0.01f;

	public bool _inertia;

	public int _startingIndex;

	public bool isAwake;

	private Canvas _canvas;

	private RectTransform _canvasRT;

	private CanvasScaler _canvasScaler;

	private ScrollRect _scrollRect;

	private Vector2 _infiniteContentSize;

	private Vector2 _scaledContentSize;

	private Vector2 _centerPos;

	private Vector2 _targetPos;

	private bool _pressing;

	private bool _dragging;

	private bool _snapping;

	private ItemInitEvent _onItemInit;

	private ItemCenterEvent _onItemCenter;

	public RectTransform Content => _scrollRect.content;

	public RectTransform Viewport => _scrollRect.viewport;

	public RectTransform[] ItemsRT { get; set; }

	public int ItemsCount => _itemsCount;

	public int CenterIndex { get; set; }

	public ItemInitEvent OnItemInit
	{
		get
		{
			if (_onItemInit == null)
			{
				_onItemInit = new ItemInitEvent();
			}
			return _onItemInit;
		}
	}

	public ItemCenterEvent OnItemCenter
	{
		get
		{
			if (_onItemCenter == null)
			{
				_onItemCenter = new ItemCenterEvent();
			}
			return _onItemCenter;
		}
	}

	public void Awake()
	{
		if (!isAwake)
		{
			_scrollRect = GetComponent<ScrollRect>();
			_canvas = GetComponentInParent<Canvas>();
			_canvasScaler = _canvas.GetComponent<CanvasScaler>();
			_canvasRT = _canvas.GetComponent<RectTransform>();
			isAwake = true;
		}
	}

	private void Start()
	{
		Init();
		SnapItem(_startingIndex);
	}

	private void Update()
	{
		if (ItemsCount != 0)
		{
			OnSnapScrolling();
		}
	}

	public void OnBeginDrag(PointerEventData eventData)
	{
		_snapping = false;
		_dragging = true;
	}

	public void OnDrag(PointerEventData eventData)
	{
		OnInfiniteScrolling();
	}

	public void OnEndDrag(PointerEventData eventData)
	{
		_dragging = false;
		SnapNearestCenterItem();
	}

	public void OnPointerDown(PointerEventData eventData)
	{
		_pressing = true;
	}

	public void OnPointerUp(PointerEventData eventData)
	{
		_pressing = false;
	}

	public void Init()
	{
		_scrollRect.horizontal = _scrollAxis != ScrollAxis.Vertical;
		_scrollRect.vertical = _scrollAxis != ScrollAxis.Horizontal;
		_scrollRect.movementType = ScrollRect.MovementType.Unrestricted;
		_scrollRect.inertia = _inertia;
		_scrollRect.scrollSensitivity = 0f;
		Viewport.pivot = new Vector2(0.5f, 0.5f);
		InitItems();
		if (_itemAutoLayout)
		{
			Content.anchorMin = new Vector2((_scrollAxis == ScrollAxis.Horizontal) ? 0f : 0.5f, (_scrollAxis == ScrollAxis.Vertical) ? 0f : 0.5f);
			Content.anchorMax = new Vector2((_scrollAxis == ScrollAxis.Horizontal) ? 0f : 0.5f, (_scrollAxis == ScrollAxis.Vertical) ? 0f : 0.5f);
			Content.pivot = new Vector2((_scrollAxis == ScrollAxis.Horizontal) ? 0f : 0.5f, (_scrollAxis == ScrollAxis.Vertical) ? 0f : 0.5f);
			float x = ((_scrollAxis == ScrollAxis.Horizontal) ? ((float)ItemsCount * _itemSize.x + (float)(ItemsCount - 1) * _itemSpacing) : _itemSize.x);
			float y = ((_scrollAxis == ScrollAxis.Vertical) ? ((float)ItemsCount * _itemSize.y + (float)(ItemsCount - 1) * _itemSpacing) : _itemSize.y);
			Content.sizeDelta = new Vector2(x, y);
		}
		if (_infinite)
		{
			_infiniteContentSize = Content.sizeDelta + new Vector2((_scrollAxis == ScrollAxis.Horizontal) ? _itemSpacing : 0f, (_scrollAxis == ScrollAxis.Vertical) ? _itemSpacing : 0f);
			_scaledContentSize.x = Content.sizeDelta.x * Content.lossyScale.x;
			_scaledContentSize.y = Content.sizeDelta.y * Content.lossyScale.y;
			if (_canvasScaler != null && _canvas.renderMode != 0)
			{
				_scaledContentSize.x /= _canvasRT.localScale.x;
				_scaledContentSize.y /= _canvasRT.localScale.y;
			}
		}
		float x2 = ((_scrollAxis != ScrollAxis.Vertical) ? (Viewport.rect.width / 2f) : 0f);
		float y2 = ((_scrollAxis != 0) ? (Viewport.rect.height / 2f) : 0f);
		_centerPos = new Vector2(x2, y2);
		if (_startingIndex < ItemsRT.Length)
		{
			Content.anchoredPosition = _centerPos - ItemsRT[_startingIndex].anchoredPosition;
		}
		CenterIndex = _startingIndex;
	}

	private void InitItems()
	{
		_itemSize = ((_itemSizeType == ItemSizeType.Custom) ? _itemSize : new Vector2(Viewport.rect.width, Viewport.rect.height));
		if (_itemInitType == ItemInitType.Static)
		{
			_itemsCount = Content.childCount;
			ItemsRT = new RectTransform[ItemsCount];
			for (int i = 0; i < ItemsCount; i++)
			{
				InitItem(i, Content.GetChild(i).transform as RectTransform);
			}
		}
		else
		{
			ItemsRT = new RectTransform[ItemsCount];
			for (int j = 1; j < ItemsCount; j++)
			{
				InitItem(j, UnityEngine.Object.Instantiate(_itemPrefab, Content).transform as RectTransform);
			}
			InitItem(0, _itemPrefab.transform as RectTransform);
		}
	}

	private void InitItem(int index, RectTransform item)
	{
		ItemsRT[index] = item;
		ItemsRT[index].pivot = new Vector2(0.5f, 0.5f);
		ItemsRT[index].anchorMin = new Vector2((_scrollAxis != ScrollAxis.Vertical) ? 0f : 0.5f, (_scrollAxis != 0) ? 0f : 0.5f);
		ItemsRT[index].anchorMax = new Vector2((_scrollAxis != ScrollAxis.Vertical) ? 0f : 0.5f, (_scrollAxis != 0) ? 0f : 0.5f);
		if (_itemAutoLayout)
		{
			ItemsRT[index].sizeDelta = _itemSize;
			float x = ((_scrollAxis == ScrollAxis.Horizontal) ? ((float)index * (_itemSpacing + _itemSize.x) + _itemSize.x / 2f) : 0f);
			float y = ((_scrollAxis == ScrollAxis.Vertical) ? ((float)index * (_itemSpacing + _itemSize.y) + _itemSize.y / 2f) : 0f);
			ItemsRT[index].anchoredPosition = new Vector2(x, y);
		}
		OnItemInit.Invoke(item, index);
	}

	private void OnSnapScrolling()
	{
		if (!_dragging && !_pressing && _snapping)
		{
			OnInfiniteScrolling();
			Content.anchoredPosition = Vector2.Lerp(Content.anchoredPosition, _targetPos, Time.deltaTime * _snapSpeed);
			if (Vector2.Distance(Content.anchoredPosition, _targetPos) < _snapThreshold)
			{
				Content.anchoredPosition = _targetPos;
				_snapping = false;
			}
		}
	}

	private void OnInfiniteScrolling()
	{
		if (!_infinite)
		{
			return;
		}
		for (int i = 0; i < ItemsCount; i++)
		{
			float num = SpaceFromCenter(ItemsRT[i].position);
			if (_scrollAxis == ScrollAxis.Horizontal)
			{
				if (num > _scaledContentSize.x / 2f)
				{
					ItemsRT[i].anchoredPosition -= new Vector2(_infiniteContentSize.x, 0f);
				}
				else if (num < (0f - _scaledContentSize.x) / 2f)
				{
					ItemsRT[i].anchoredPosition += new Vector2(_infiniteContentSize.x, 0f);
				}
			}
			else if (_scrollAxis == ScrollAxis.Vertical)
			{
				if (num > _scaledContentSize.y / 2f)
				{
					ItemsRT[i].anchoredPosition -= new Vector2(0f, _infiniteContentSize.y);
				}
				else if (num < -1f * _scaledContentSize.y / 2f)
				{
					ItemsRT[i].anchoredPosition += new Vector2(0f, _infiniteContentSize.y);
				}
			}
		}
	}

	private void SnapNearestCenterItem()
	{
		if (ItemsRT.Length == 0)
		{
			return;
		}
		int index = 0;
		float a = Mathf.Abs(SpaceFromCenter(ItemsRT[0].position));
		for (int i = 1; i < ItemsCount; i++)
		{
			float num = Mathf.Abs(SpaceFromCenter(ItemsRT[i].position));
			if (Mathf.Min(a, num) == num)
			{
				index = i;
				a = num;
			}
		}
		SnapItem(index);
	}

	public void SnapItem(int index)
	{
		if (index <= ItemsRT.Length - 1)
		{
			CenterIndex = index;
			OnItemCenter.Invoke(CenterIndex);
			_targetPos = _centerPos - ItemsRT[index].anchoredPosition;
			_snapping = true;
		}
	}

	public float SpaceFromCenter(Vector2 point)
	{
		if (_scrollAxis == ScrollAxis.Horizontal)
		{
			return (point.x - Viewport.position.x) / _canvasRT.localScale.x;
		}
		if (_scrollAxis == ScrollAxis.Vertical)
		{
			return (point.y - Viewport.position.y) / _canvasRT.localScale.y;
		}
		return Vector2.Distance(point, Viewport.position) / _canvasRT.localScale.x;
	}
}
public class DemoEventItem : MonoBehaviour
{
	public CanvasGroup _panel;

	public Text _textIndex;

	public Image _imgBg;

	public Color _on;

	public Color _off;

	public void OnInit(int index)
	{
		_textIndex.text = index.ToString();
		_imgBg.color = _off;
	}

	public void OnCenter(bool value)
	{
		_imgBg.color = (value ? _on : _off);
	}

	public void UpdataEffect(float effectValue)
	{
		_panel.alpha = effectValue;
	}
}
public class DemoEventScrollManager : MonoBehaviour
{
	public GreatScrollPanel _scrollPanel;

	public GreatScrollEffect _scrollEffect;

	private int _centerIndex = -1;

	private void Awake()
	{
		_scrollPanel.OnItemInit.AddListener(OnItemInit);
		_scrollPanel.OnItemCenter.AddListener(OnItemCenter);
		_scrollEffect.OnCustomEffect.AddListener(UpdateScrollEffect);
	}

	private void OnItemInit(Transform item, int index)
	{
		item.GetComponent<DemoEventItem>().OnInit(index);
	}

	private void OnItemCenter(int index)
	{
		if (_centerIndex != -1)
		{
			_scrollPanel.ItemsRT[_centerIndex].GetComponent<DemoEventItem>().OnCenter(value: false);
		}
		_scrollPanel.ItemsRT[index].GetComponent<DemoEventItem>().OnCenter(value: true);
		_centerIndex = index;
	}

	private void UpdateScrollEffect(Transform item, float effectValue)
	{
		item.GetComponent<DemoEventItem>().UpdataEffect(effectValue);
	}
}
internal interface ImeBase
{
	bool Create(ImeDelegateBase pDelegate);

	void GetSize(ref Vector2 size);

	void Draw(Texture2D tex);

	void OnTouch(float x, float y, SGImeMotionEventType type);

	void UpdateData();

	void Show(SGImeInputType typeInput, SGImeTextType typeText);

	void Hide();
}
public enum SGImeError
{
	UNKNOWN,
	SERVICE_NOT_CONNECTED
}
public enum SGImeKey
{
	KEYCODE_COMMIT = -1,
	KEYCODE_UNKNOWN = 0,
	KEYCODE_ENTER = 66,
	KEYCODE_DEL = 67,
	KEYCODE_VOICE_START = 1000,
	KEYCODE_VOICE_END = 1001
}
public enum SGImeInputType
{
	TYPE_CLASS_TEXT = 1,
	TYPE_CLASS_NUMBER,
	TYPE_CLASS_PHONE,
	TYPE_CLASS_DATETIME,
	TYPE_CLASS_MUTE_TEXT
}
public enum SGImeTextType
{
	TYPE_TEXT_VARIATION_NORMAL = 0,
	TYPE_TEXT_VARIATION_URI = 16,
	TYPE_TEXT_VARIATION_EMAIL_ADDRESS = 32,
	TYPE_TEXT_VARIATION_EMAIL_SUBJECT = 48,
	TYPE_TEXT_VARIATION_SHORT_MESSAGE = 64,
	TYPE_TEXT_VARIATION_LONG_MESSAGE = 80,
	TYPE_TEXT_VARIATION_PERSON_NAME = 96,
	TYPE_TEXT_VARIATION_POSTAL_ADDRESS = 112,
	TYPE_TEXT_VARIATION_PASSWORD = 128,
	TYPE_TEXT_VARIATION_VISIBLE_PASSWORD = 144,
	TYPE_TEXT_VARIATION_WEB_EDIT_TEXT = 160,
	TYPE_TEXT_VARIATION_FILTER = 176,
	TYPE_TEXT_VARIATION_PHONETIC = 192,
	TYPE_TEXT_VARIATION_WEB_EMAIL_ADDRESS = 208,
	TYPE_TEXT_VARIATION_WEB_PASSWORD = 224
}
public enum SGImeMotionEventType
{
	ACTION_DOWN = 0,
	ACTION_UP = 1,
	ACTION_MOVE = 2,
	ACTION_CANCEL = 3,
	ACTION_OUTSIDE = 4,
	ACTION_POINTER_DOWN = 5,
	ACTION_POINTER_UP = 6,
	ACTION_HOVER_MOVE = 7,
	ACTION_SCROLL = 8,
	ACTION_HOVER_ENTER = 9,
	ACTION_HOVER_EXIT = 10,
	ACTION_BUTTON_PRESS = 11,
	ACTION_BUTTON_RELEASE = 12,
	ACTION_LONGPRESS = 100
}
public abstract class ImeDelegateBase : MonoBehaviour
{
	public abstract void OnIMEShow(Vector2 vSize);

	public abstract void OnIMEHide();

	public abstract void OnIMECommit(string strCommit);

	public abstract void OnIMEKey(SGImeKey key);

	public abstract void OnIMEError(SGImeError nType, string strErr);
}
public class DummyIme : ImeBase
{
	public bool Create(ImeDelegateBase pDelegate)
	{
		UnityEngine.Debug.Log("ime create");
		return true;
	}

	public void GetSize(ref Vector2 size)
	{
		UnityEngine.Debug.Log("ime getsize");
		size[0] = 780f;
		size[1] = 390f;
	}

	public void Draw(Texture2D tex)
	{
	}

	public void OnTouch(float x, float y, SGImeMotionEventType type)
	{
		UnityEngine.Debug.Log("ime ontouch:(" + x + "," + y + "),type=" + type);
	}

	public void UpdateData()
	{
	}

	public void Show(SGImeInputType typeInput, SGImeTextType typeText)
	{
		UnityEngine.Debug.Log(string.Concat("ime show:", typeInput, ",texttype:", typeText));
	}

	public void Hide()
	{
		UnityEngine.Debug.Log("ime hide");
	}
}
public class SGIme : ImeBase
{
	private bool mUseAndroid = true;

	private AndroidJavaObject javaIme;

	private ImeDelegateBase mDelegate;

	private Vector2 mTextureSize;

	private string mStrCommit;

	private bool mShow;

	public bool Create(ImeDelegateBase pDelegate)
	{
		UnityEngine.Debug.Log("sogou SGIme ime create");
		mDelegate = pDelegate;
		JavaInit();
		Hide();
		return true;
	}

	public void GetSize(ref Vector2 size)
	{
		size = mTextureSize;
		UnityEngine.Debug.Log("sogou SGIme ime getsize func : " + size[0] + "," + size[1]);
	}

	public void Draw(Texture2D tex)
	{
		if (IsInited() && IsNeedUpdate())
		{
			UnityEngine.Debug.Log("sogou SGIme ime draw");
			byte[] data = javaIme.Call<byte[]>("getTextureData", Array.Empty<object>());
			tex.LoadRawTextureData(data);
			tex.Apply();
		}
	}

	public void Show(SGImeInputType typeInput, SGImeTextType typeText)
	{
		if (IsInited())
		{
			UnityEngine.Debug.Log(string.Concat("sogou SGIme ime show:", typeInput, ",", typeText));
			javaIme.Call<bool>("show", new object[2]
			{
				(int)typeInput,
				(int)typeText
			});
		}
	}

	public void Hide()
	{
		if (IsInited())
		{
			UnityEngine.Debug.Log("sogou SGIme ime hide");
			javaIme.Call<bool>("hide", Array.Empty<object>());
		}
	}

	public void OnTouch(float x, float y, SGImeMotionEventType type)
	{
		if (IsInited())
		{
			UnityEngine.Debug.Log("sogou SGIme ime ontouch:(" + x + "," + y + "),type=" + type);
			javaIme.Call<bool>("onTouch", new object[3]
			{
				x,
				y,
				(int)type
			});
		}
	}

	public void UpdateData()
	{
		if (IsInited())
		{
			SGImeKey commitCode = (SGImeKey)GetCommitCode();
			switch (commitCode)
			{
			case SGImeKey.KEYCODE_COMMIT:
				mStrCommit = GetCommitString();
				UnityEngine.Debug.Log("sogou SGIme ime updatedata commit string:" + mStrCommit);
				mDelegate.OnIMECommit(mStrCommit);
				break;
			default:
				UnityEngine.Debug.Log("sogou SGIme ime updatedata commit key:" + commitCode);
				mDelegate.OnIMEKey(commitCode);
				break;
			case SGImeKey.KEYCODE_UNKNOWN:
				break;
			}
			bool flag = IsShow();
			if (!flag && mShow)
			{
				mShow = flag;
				mDelegate.OnIMEHide();
			}
			else if (flag && !mShow)
			{
				mShow = flag;
				mDelegate.OnIMEShow(mTextureSize);
			}
		}
	}

	private void JavaInit()
	{
		UnityEngine.Debug.Log("sogou SGIme ime start JavaInit");
		if (mUseAndroid)
		{
			javaIme = new AndroidJavaObject("com.sohu.inputmethod.sogou.sgrenderproxy.RenderProxyUnity");
			int[] array = javaIme.Call<int[]>("getSize", Array.Empty<object>());
			mTextureSize[0] = array[0];
			mTextureSize[1] = array[1];
			UnityEngine.Debug.Log("sogou ime start JavaInit, getKeyBoardSize size = " + mTextureSize[0] + ":" + mTextureSize[1]);
		}
	}

	private bool IsInited()
	{
		if (mUseAndroid)
		{
			return javaIme != null;
		}
		return false;
	}

	private bool IsNeedUpdate()
	{
		return javaIme.Call<bool>("isNeedRefresh", Array.Empty<object>());
	}

	private int GetCommitCode()
	{
		return javaIme.Call<int>("getCommitCode", Array.Empty<object>());
	}

	private string GetCommitString()
	{
		return javaIme.Call<string>("getCommitString", Array.Empty<object>());
	}

	private bool IsShow()
	{
		return javaIme.Call<bool>("isShow", Array.Empty<object>());
	}
}
public class ImeManager : MonoBehaviour
{
	public ImeDelegateBase mDelegate;

	private ImeBase mIme;

	private Vector2 mSize;

	private bool mIsStart;

	private void Start()
	{
		if (null != mDelegate)
		{
			mIme = new SGIme();
			mIme.Create(mDelegate);
		}
		mIsStart = true;
	}

	private void Update()
	{
		if (mIme != null && mIsStart)
		{
			mIme.UpdateData();
		}
	}

	public void Show(SGImeInputType typeInput, SGImeTextType typeText)
	{
		mIme.Show(typeInput, typeText);
		mIme.GetSize(ref mSize);
	}

	public void Hide()
	{
		mIme.Hide();
		mDelegate.OnIMEHide();
	}

	public void Draw(Texture2D tex)
	{
		mIme.Draw(tex);
	}

	public void OnTouch(float x, float y, SGImeMotionEventType type)
	{
		mIme.OnTouch(x, y, type);
	}

	private void OnDestroy()
	{
		mIsStart = false;
		mIme = null;
	}

	private void OnApplicationPause(bool pauseStatus)
	{
		if (pauseStatus)
		{
			Hide();
		}
	}
}
public class ImeDelegateImpl : ImeDelegateBase
{
	public Text mText;

	public GameObject[] mKbdViews;

	public SGViewGather mKbdView;

	public ImeManager mManager;

	private Texture2D mTexture;

	private Vector2 mTextureSize = new Vector2(780f, 390f);

	private Vector2 mPtKbd;

	private SGClickTracker mTracker = new SGClickTracker();

	public Pvr_ControllerDemo_VRInput controller;

	public override void OnIMEShow(Vector2 vSize)
	{
		UnityEngine.Debug.Log("sogou DelegateImpl OnIMEShow");
		mTextureSize = vSize;
		UnityEngine.Debug.Log("sogou DelegateImpl OnIMEShow, size = " + mTextureSize[0] + ":" + mTextureSize[1]);
		CreateTexture(vSize);
		mManager.Draw(mTexture);
		mKbdView?.SetActive(bActive: true);
	}

	public override void OnIMEHide()
	{
		UnityEngine.Debug.Log("sogou DelegateImpl OnIMEHide");
		mKbdView?.SetActive(bActive: false);
	}

	public override void OnIMECommit(string strCommit)
	{
		mText.text += strCommit;
	}

	public override void OnIMEKey(SGImeKey key)
	{
		switch (key)
		{
		case SGImeKey.KEYCODE_DEL:
		{
			string text = mText.text;
			mText.text = text.Remove(text.Length - 1);
			break;
		}
		case SGImeKey.KEYCODE_ENTER:
			mText.text = "";
			break;
		}
	}

	public override void OnIMEError(SGImeError nType, string strErr)
	{
	}

	private void Start()
	{
		mKbdView = new SGViewGather(mKbdViews);
		mKbdView.SetActive(bActive: false);
	}

	private void Update()
	{
		CheckMouseEvent();
		mManager.Draw(mTexture);
	}

	private void CreateTexture(Vector2 vSize)
	{
		if (!mTexture)
		{
			mTexture = new Texture2D((int)vSize.x, (int)vSize.y, TextureFormat.RGBA32, mipChain: false);
			mTexture.filterMode = FilterMode.Trilinear;
			mTexture.Apply();
			UnityEngine.Debug.Log(" sogou DelegateImpl_kbd CreateTexture: texture created");
			mKbdView.SetTexture(mTexture);
		}
	}

	private void DispatchMessageToAndroid(SGImeMotionEventType type, Vector2 pt)
	{
		if (null != mManager)
		{
			mManager.OnTouch(pt.x, pt.y, type);
		}
	}

	private void LogEvent(string prefix, PointerEventData eventData)
	{
		UnityEngine.Debug.Log(prefix + ": " + eventData.pointerCurrentRaycast.gameObject.name + " x=" + eventData.position.x + ",y=" + eventData.position.y);
	}

	private void CheckMouseEvent()
	{
		if (Point2UV(controller.ray, ref mPtKbd))
		{
			if (mTracker.Track(mPtKbd, Input.GetKeyDown(KeyCode.JoystickButton0) || Controller.UPvr_GetKeyClick(0, Pvr_KeyCode.TOUCHPAD) || Controller.UPvr_GetKeyClick(0, Pvr_KeyCode.TRIGGER) || Controller.UPvr_GetKeyClick(0, Pvr_KeyCode.X) || Controller.UPvr_GetKeyClick(1, Pvr_KeyCode.TOUCHPAD) || Controller.UPvr_GetKeyClick(1, Pvr_KeyCode.TRIGGER) || Controller.UPvr_GetKeyClick(1, Pvr_KeyCode.A)))
			{
				DispatchMessageToAndroid(mTracker.GetEvent(), mTracker.GetPoint());
			}
			else if (mTracker.Track(mPtKbd, Controller.UPvr_GetKeyClick(0, Pvr_KeyCode.Y) || Controller.UPvr_GetKeyClick(1, Pvr_KeyCode.B) || Controller.UPvr_GetKeyClick(0, Pvr_KeyCode.APP) || Controller.UPvr_GetKeyClick(1, Pvr_KeyCode.APP)))
			{
				mManager.Hide();
			}
		}
		else if (mTracker.TrackOuter())
		{
			DispatchMessageToAndroid(mTracker.GetEvent(), mTracker.GetPoint());
		}
	}

	private bool Point2UV(Ray ray, ref Vector2 ptUV)
	{
		bool result = false;
		if (Physics.Raycast(ray, out var hitInfo))
		{
			string text = hitInfo.collider.gameObject.name;
			if (mKbdView.FindName(text))
			{
				hitInfo.collider.gameObject.transform.InverseTransformPoint(hitInfo.point);
				Vector2 textureCoord = hitInfo.textureCoord;
				hitInfo.transform.GetComponent<Renderer>();
				ptUV.x = textureCoord.x * mTextureSize.x;
				ptUV.y = (1f - textureCoord.y) * mTextureSize.y;
				result = true;
			}
		}
		return result;
	}
}
public class SGViewGather
{
	private GameObject[] mViews;

	public SGViewGather(GameObject[] param)
	{
		mViews = param;
	}

	public void SetActive(bool bActive)
	{
		GameObject[] array = mViews;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetActive(bActive);
		}
	}

	public bool FindName(string name)
	{
		GameObject[] array = mViews;
		for (int i = 0; i < array.Length; i++)
		{
			if (array[i].name == name)
			{
				return true;
			}
		}
		return false;
	}

	public void SetTexture(Texture2D tex)
	{
		GameObject[] array = mViews;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].GetComponent<Renderer>().material.mainTexture = tex;
		}
	}
}
public class SGClickTracker
{
	private bool mDownOld;

	private Vector2 mPtOld;

	private SGImeMotionEventType mEvent;

	private const float mTrackRadius = 10f;

	private long mTimeDown;

	private bool mLongPressed;

	private long mIntervelLongPress = 100L;

	public bool Track(Vector2 pt, bool bDown)
	{
		bool flag = false;
		if (bDown)
		{
			if (mDownOld)
			{
				mEvent = SGImeMotionEventType.ACTION_MOVE;
				if (!mLongPressed && DateTime.Now.Ticks - mTimeDown > mIntervelLongPress)
				{
					mLongPressed = true;
					mEvent = SGImeMotionEventType.ACTION_LONGPRESS;
					flag = true;
				}
			}
			else
			{
				mEvent = SGImeMotionEventType.ACTION_DOWN;
				mTimeDown = DateTime.Now.Ticks;
				mLongPressed = false;
			}
		}
		else if (mDownOld)
		{
			mEvent = SGImeMotionEventType.ACTION_UP;
		}
		else
		{
			mEvent = SGImeMotionEventType.ACTION_MOVE;
		}
		if (mDownOld != bDown)
		{
			flag = true;
		}
		else if (PointDist(mPtOld, pt) > 10f)
		{
			flag = true;
		}
		mDownOld = bDown;
		if (flag)
		{
			mPtOld = pt;
		}
		return flag;
	}

	public bool TrackOuter()
	{
		if (mEvent != SGImeMotionEventType.ACTION_OUTSIDE)
		{
			_ = mEvent;
			mEvent = SGImeMotionEventType.ACTION_OUTSIDE;
		}
		return false;
	}

	public Vector2 GetPoint()
	{
		return mPtOld;
	}

	public SGImeMotionEventType GetEvent()
	{
		return mEvent;
	}

	private float PointDist(Vector2 ptNew, Vector2 ptOld)
	{
		return Math.Abs(ptNew[0] - ptOld[0]) + Math.Abs(ptNew[1] - ptOld[1]);
	}
}
public class Pvr_ControllerDemo_VRInput : MonoBehaviour
{
	public GameObject HeadSetController;

	public GameObject controller0;

	public GameObject controller1;

	public Ray ray;

	private GameObject currentController;

	private Transform lastHit;

	private Transform currentHit;

	private bool noClick;

	private GameObject referenceObj;

	public float rayDefaultLength = 4f;

	private bool isHasController;

	private bool headcontrolmode;

	private void Start()
	{
		ray = default(Ray);
		if (Pvr_UnitySDKManager.SDK.isHasController)
		{
			Pvr_ControllerManager.PvrServiceStartSuccessEvent += ServiceStartSuccess;
			Pvr_ControllerManager.SetControllerStateChangedEvent += ControllerStateListener;
			Pvr_ControllerManager.ControllerStatusChangeEvent += CheckControllerStateForGoblin;
			isHasController = true;
		}
		referenceObj = new GameObject("ReferenceObj");
	}

	private void OnDestroy()
	{
		if (isHasController)
		{
			Pvr_ControllerManager.PvrServiceStartSuccessEvent -= ServiceStartSuccess;
			Pvr_ControllerManager.SetControllerStateChangedEvent -= ControllerStateListener;
			Pvr_ControllerManager.ControllerStatusChangeEvent -= CheckControllerStateForGoblin;
		}
	}

	private void Update()
	{
		if (HeadSetController.activeSelf)
		{
			HeadSetController.transform.parent.localRotation = Quaternion.Euler(Pvr_UnitySDKSensor.Instance.HeadPose.Orientation.eulerAngles.x, Pvr_UnitySDKSensor.Instance.HeadPose.Orientation.eulerAngles.y, 0f);
			ray.direction = HeadSetController.transform.position - HeadSetController.transform.parent.parent.Find("Head").position;
			ray.origin = HeadSetController.transform.parent.parent.Find("Head").position;
			if (Physics.Raycast(ray, out var hitInfo))
			{
				if (HeadSetController.name == "SightPointer")
				{
					HeadSetController.transform.localScale = new Vector3(0.09f, 0.09f, 0.09f);
				}
				currentHit = hitInfo.transform;
				if (currentHit != null && lastHit != null && currentHit != lastHit && (bool)lastHit.GetComponent<Pvr_UIGraphicRaycaster>() && lastHit.transform.gameObject.activeInHierarchy && lastHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled)
				{
					lastHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled = false;
				}
				if (currentHit != null && lastHit != null && currentHit == lastHit && (bool)currentHit.GetComponent<Pvr_UIGraphicRaycaster>() && !currentHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled)
				{
					currentHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled = true;
				}
				lastHit = hitInfo.transform;
				UnityEngine.Debug.DrawLine(ray.origin, hitInfo.point, Color.red);
				if (Pvr_ControllerManager.Instance.LengthAdaptiveRay)
				{
					HeadSetController.transform.position = hitInfo.point;
					HeadSetController.transform.position -= (hitInfo.point - HeadSetController.transform.parent.parent.Find("Head").position).normalized * 0.02f;
					float num = 0.008f * hitInfo.distance / 4f;
					Mathf.Clamp(num, 0.002f, 0.008f);
					HeadSetController.transform.localScale = new Vector3(num, num, 1f);
				}
			}
			else
			{
				if (HeadSetController.name == "SightPointer")
				{
					HeadSetController.transform.localScale = Vector3.zero;
				}
				currentHit = null;
				noClick = false;
				if (Pvr_ControllerManager.Instance.LengthAdaptiveRay)
				{
					HeadSetController.transform.position = HeadSetController.transform.parent.parent.Find("Head").position + ray.direction.normalized * (0.5f + rayDefaultLength);
					HeadSetController.transform.localScale = new Vector3(0.008f, 0.008f, 1f);
				}
			}
		}
		else
		{
			if (!(currentController != null))
			{
				return;
			}
			ray.direction = currentController.transform.Find("dot").position - currentController.transform.Find("start").position;
			ray.origin = currentController.transform.Find("start").position;
			if (Physics.Raycast(ray, out var hitInfo2))
			{
				currentHit = hitInfo2.transform;
				if (currentHit != null && lastHit != null && currentHit != lastHit && (bool)lastHit.GetComponent<Pvr_UIGraphicRaycaster>() && lastHit.transform.gameObject.activeInHierarchy && lastHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled)
				{
					lastHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled = false;
				}
				if (currentHit != null && lastHit != null && currentHit == lastHit && (bool)currentHit.GetComponent<Pvr_UIGraphicRaycaster>() && !currentHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled)
				{
					currentHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled = true;
				}
				lastHit = hitInfo2.transform;
				UnityEngine.Debug.DrawLine(ray.origin, hitInfo2.point, Color.red);
				currentController.transform.Find("dot").position = hitInfo2.point;
				if (Pvr_ControllerManager.Instance.LengthAdaptiveRay)
				{
					float num2 = 0.178f * currentController.transform.Find("dot").localPosition.z / 3.3f;
					Mathf.Clamp(num2, 0.05f, 0.178f);
					currentController.transform.Find("dot").localScale = new Vector3(num2, num2, 1f);
				}
			}
			else
			{
				currentHit = null;
				noClick = false;
				if (Pvr_ControllerManager.Instance.LengthAdaptiveRay)
				{
					currentController.transform.Find("dot").localScale = new Vector3(0.178f, 0.178f, 1f);
					currentController.transform.Find("dot").position = currentController.transform.position + currentController.transform.forward.normalized * (0.5f + rayDefaultLength);
				}
			}
		}
	}

	private void ServiceStartSuccess()
	{
		if (Controller.UPvr_GetControllerState(0) == ControllerState.Connected || Controller.UPvr_GetControllerState(1) == ControllerState.Connected)
		{
			HeadSetController.SetActive(value: false);
		}
		else
		{
			HeadSetController.SetActive(value: true);
		}
		if (Controller.UPvr_GetMainHandNess() == 0)
		{
			currentController = controller0;
		}
		if (Controller.UPvr_GetMainHandNess() == 1)
		{
			currentController = controller1;
		}
	}

	private void ControllerStateListener(string data)
	{
		if (Controller.UPvr_GetControllerState(0) == ControllerState.Connected || Controller.UPvr_GetControllerState(1) == ControllerState.Connected)
		{
			HeadSetController.SetActive(value: false);
		}
		else
		{
			HeadSetController.SetActive(value: true);
		}
		if (Controller.UPvr_GetMainHandNess() == 0)
		{
			currentController = controller0;
		}
		if (Controller.UPvr_GetMainHandNess() == 1)
		{
			currentController = controller1;
		}
	}

	private void CheckControllerStateForGoblin(string state)
	{
		HeadSetController.SetActive(!Convert.ToBoolean(Convert.ToInt16(state)));
	}

	public void SwitchControlMode()
	{
	}
}
public class TextHandler : MonoBehaviour, IPointerEnterHandler, IEventSystemHandler, IPointerExitHandler
{
	public ImeManager mManager;

	public SGImeInputType mInputType;

	public SGImeTextType mTextType;

	private bool isSelect;

	private void Start()
	{
	}

	private void Update()
	{
		if (isSelect && (Input.GetKeyDown(KeyCode.JoystickButton0) || Controller.UPvr_GetKeyClick(0, Pvr_KeyCode.TOUCHPAD) || Controller.UPvr_GetKeyClick(0, Pvr_KeyCode.TRIGGER) || Controller.UPvr_GetKeyClick(0, Pvr_KeyCode.X) || Controller.UPvr_GetKeyClick(1, Pvr_KeyCode.TOUCHPAD) || Controller.UPvr_GetKeyClick(1, Pvr_KeyCode.TRIGGER) || Controller.UPvr_GetKeyClick(1, Pvr_KeyCode.A)))
		{
			mManager.Show(mInputType, mTextType);
		}
	}

	public void OnPointerEnter(PointerEventData eventData)
	{
		UnityEngine.Debug.Log("TextHandler OnPointerEnter");
		isSelect = true;
	}

	public void OnPointerExit(PointerEventData eventData)
	{
		UnityEngine.Debug.Log("TextHandler OnPointerExit");
		isSelect = false;
	}
}
public class _testScript : MonoBehaviour
{
	public UnityEngine.Object objtetet;

	public string m_txt1;

	private void Start()
	{
	}

	private IEnumerator yieldttt1()
	{
		UnityEngine.Debug.Log(1);
		yield return new WaitForSeconds(2f);
		yieldttt2();
		yield return yieldttt3();
		UnityEngine.Debug.Log(4);
	}

	private IEnumerator yieldttt2()
	{
		yield return new WaitForSeconds(2f);
		UnityEngine.Debug.Log(2);
	}

	private IEnumerator yieldttt3()
	{
		yield return new WaitForSeconds(2f);
		UnityEngine.Debug.Log(3);
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.B))
		{
			StartCoroutine(yieldttt1());
		}
	}
}
internal class AutoSetCvs : MonoBehaviour
{
	public List<Pvr_UICanvas> lastFindCvs;

	public void Change(GameObject menu, bool isHide)
	{
		if (isHide)
		{
			if (lastFindCvs == null)
			{
				lastFindCvs = new List<Pvr_UICanvas>();
				Pvr_UICanvas[] array = null;
				Pvr_UICanvas component = menu.GetComponent<Pvr_UICanvas>();
				if (component == null)
				{
					array = menu.GetComponentsInChildren<Pvr_UICanvas>(includeInactive: true);
					if (array == null || array.Length < 1)
					{
						return;
					}
				}
				else
				{
					array = new Pvr_UICanvas[1] { component };
				}
				GameObject[] rootGameObjects = SceneManager.GetActiveScene().GetRootGameObjects();
				for (int i = 0; i < rootGameObjects.Length; i++)
				{
					Pvr_UICanvas[] componentsInChildren = rootGameObjects[i].GetComponentsInChildren<Pvr_UICanvas>(includeInactive: true);
					if (componentsInChildren == null || componentsInChildren.Length == 0)
					{
						continue;
					}
					Pvr_UICanvas[] array2 = componentsInChildren;
					foreach (Pvr_UICanvas pvr_UICanvas in array2)
					{
						if (pvr_UICanvas.enabled && !array.Contains(pvr_UICanvas))
						{
							lastFindCvs.Add(pvr_UICanvas);
						}
					}
				}
			}
			{
				foreach (Pvr_UICanvas lastFindCv in lastFindCvs)
				{
					lastFindCv.enabled = false;
				}
				return;
			}
		}
		if (lastFindCvs == null)
		{
			return;
		}
		foreach (Pvr_UICanvas lastFindCv2 in lastFindCvs)
		{
			lastFindCv2.enabled = true;
		}
	}

	private void OnEnable()
	{
		UnityEngine.Debug.Log("enb");
		Change(base.gameObject, isHide: true);
	}

	private void OnDisable()
	{
		UnityEngine.Debug.Log("dis");
		Change(base.gameObject, isHide: false);
	}
}
public class DontDestory : MonoBehaviour
{
	private void Start()
	{
		UnityEngine.Object.DontDestroyOnLoad(this);
		SceneManager.activeSceneChanged += SceneManager_activeSceneChanged;
	}

	private void SceneManager_activeSceneChanged(Scene arg0, Scene a)
	{
		UnityEngine.Debug.Log(a.name);
		if ("1_登录页,0_AppUpgradeScene,".Contains(a.name))
		{
			return;
		}
		try
		{
			string url = UrlUtils.baseUrl_es + "api/version";
			UnityWebRequestHelper.Instance.Get(url, delegate(RequestStatus status, string result)
			{
				if (status == RequestStatus.fail)
				{
					Msgpanel.ShowMsg("请求网络失败:" + result + "，请尝试重新登录，或检查网络正常后，再进行测评");
				}
			}, isToken: true);
		}
		catch
		{
			Msgpanel.ShowMsg();
		}
	}
}
public class Load : MonoBehaviour
{
	public class Res1
	{
		public List<ResRoot> data;
	}

	public class ResRoot
	{
		public int id { get; set; }

		public string name { get; set; }

		public int type { get; set; }

		public string file_name { get; set; }

		public string file_url { get; set; }

		public string description { get; set; }

		public int version { get; set; }

		public string created_at { get; set; }

		public string updated_at { get; set; }
	}

	public Text LoadingTxt;

	public Text JinduTxt;

	public static string LoadType = "";

	public static string url = "";

	public static string sceneName = "";

	public static string sceneNameVer = "";

	private static Dictionary<string, int> LocalVersion = new Dictionary<string, int>();

	public static Dictionary<string, ResRoot> Version = new Dictionary<string, ResRoot>();

	public static Vector3 lastPostion;

	private static bool isLoading = false;

	private static GameObject LoadingPanel;

	private static string BASEAB => Application.persistentDataPath + "/abpack/";

	private static string BASEVERFILE => Application.persistentDataPath + "/abver.txt";

	private void Awake()
	{
		if (base.name.Contains("StartSceneCtrl"))
		{
			if ((bool)MainPlayController.Inst)
			{
				UnityEngine.Object.Destroy(MainPlayController.Inst.gameObject);
				MainPlayController.Inst = null;
			}
			if ((bool)WaveVRHead.Inst)
			{
				UnityEngine.Object.Destroy(WaveVRHead.Inst.gameObject);
				WaveVRHead.Inst = null;
			}
		}
	}

	public static void LoadMain()
	{
		LoadScene2("2_MainStart");
	}

	public void Start()
	{
		if (!base.name.Contains("LoadingPanel"))
		{
			return;
		}
		if (LoadType == "file")
		{
			StartCoroutine(_LoadFile(url));
		}
		else if (LoadType == "net")
		{
			StartCoroutine(_LoadNet(url));
		}
		else if (LoadType == "error")
		{
			try
			{
				isLoading = false;
				SceneManager.LoadScene(sceneName);
				HideLoading();
				UnityEngine.Debug.Log("加载场景失败:" + sceneName);
			}
			catch (Exception ex)
			{
				LoadingTxt.text = "加载场景失败:" + sceneName + "," + ex.Message;
			}
		}
	}

	private IEnumerator _LoadNet(string p)
	{
		using UnityWebRequest a = UnityWebRequest.Get(p);
		a.SendWebRequest();
		LoadingTxt.text = "下载资源中，请稍后...";
		while (!a.isDone)
		{
			JinduTxt.text = (a.downloadProgress * 100f).ToString("F2") + "%";
			yield return null;
		}
		if (!string.IsNullOrEmpty(a.error))
		{
			LoadingTxt.text = "下载错误:" + a.error;
			yield break;
		}
		byte[] buf = a.downloadHandler.data;
		LocalVersion[sceneNameVer] = Version[sceneNameVer].version;
		File.WriteAllText(BASEVERFILE, LitJson.JsonMapper.ToJson(LocalVersion));
		string text = BASEAB + sceneName;
		if (File.Exists(text))
		{
			File.Delete(text);
		}
		File.WriteAllBytes(text + "2", buf);
		yield return _Recompress(text + "2", text);
		yield return _LoadMemory(buf);
	}

	private IEnumerator _Recompress(string f1, string f2)
	{
		AssetBundleRecompressOperation a = AssetBundle.RecompressAssetBundleAsync(f1, f2, BuildCompression.Uncompressed);
		LoadingTxt.text = "解压资源中，请稍后...";
		DateTime st = DateTime.Now;
		while (!a.isDone && (DateTime.Now - st).TotalSeconds < 45.0)
		{
			JinduTxt.text = (a.progress * 100f).ToString("F2") + "%";
			yield return null;
		}
	}

	private IEnumerator _LoadMemory(byte[] buf)
	{
		AssetBundleCreateRequest a = AssetBundle.LoadFromMemoryAsync(buf);
		LoadingTxt.text = "加载内存资源中，请稍后...";
		DateTime st = DateTime.Now;
		while (!a.isDone && (DateTime.Now - st).TotalSeconds < 30.0)
		{
			JinduTxt.text = (a.progress * 100f).ToString("F2") + "%";
			yield return null;
		}
		yield return _LoadScene();
	}

	private IEnumerator _LoadFile(string p)
	{
		AssetBundleCreateRequest a = AssetBundle.LoadFromFileAsync(p);
		LoadingTxt.text = "加载本地资源中，请稍后...";
		if (p.Contains("登录") || p.Contains("2_MainStart"))
		{
			yield return new WaitForSecondsRealtime(0.5f);
		}
		DateTime st = DateTime.Now;
		while (!a.isDone && (DateTime.Now - st).TotalSeconds < 30.0)
		{
			JinduTxt.text = (a.progress * 100f).ToString("F2") + "%";
			yield return null;
		}
		yield return _LoadScene();
	}

	private IEnumerator _LoadScene()
	{
		isLoading = false;
		LoadingTxt.text = "加载场景资源中，请稍后...";
		UnityEngine.AsyncOperation a2;
		try
		{
			a2 = SceneManager.LoadSceneAsync(sceneName);
		}
		catch
		{
			goto IL_0110;
		}
		if (a2 != null)
		{
			DateTime st = DateTime.Now;
			while (!a2.isDone && (DateTime.Now - st).TotalSeconds < 30.0)
			{
				JinduTxt.text = (a2.progress * 100f).ToString("F2") + "%";
				yield return null;
			}
			yield return new WaitForSecondsRealtime(0.5f);
		}
		goto IL_0110;
		IL_0110:
		HideLoading();
	}

	public static void LocalScene(string name)
	{
		SceneManager.LoadScene(name);
	}

	public void LoadScene(string name)
	{
		LoadScene2(name);
	}

	public static void LoadScene2(string name)
	{
		if (isLoading)
		{
			return;
		}
		isLoading = true;
		sceneName = name;
		name = name.ToLower();
		sceneNameVer = name;
		string path = BASEAB + name;
		if (Version.ContainsKey(name))
		{
			if (!LocalVersion.ContainsKey(name) || Version[name].version > LocalVersion[name])
			{
				LoadType = "net";
				url = Version[name].file_url;
			}
			else if (File.Exists(path))
			{
				url = path;
				LoadType = "file";
			}
			else
			{
				LoadType = "net";
				url = Version[name].file_url;
			}
		}
		else if (File.Exists(path))
		{
			url = path;
			LoadType = "file";
		}
		else
		{
			LoadType = "error";
		}
		ShowLoading();
	}

	private static void ShowLoading()
	{
		Transform transform = getPicoVr().transform.Find("Head");
		if ((bool)transform)
		{
			LoadingPanel = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("LoadingPanel"), transform);
		}
	}

	private static void HideLoading()
	{
		isLoading = false;
		if ((bool)LoadingPanel)
		{
			UnityEngine.Object.Destroy(LoadingPanel);
			LoadingPanel = null;
		}
	}

	public static void InitVersion(Action cb = null)
	{
		if (!Directory.Exists(BASEAB))
		{
			Directory.CreateDirectory(BASEAB);
		}
		if (File.Exists(BASEVERFILE))
		{
			LocalVersion = LitJson.JsonMapper.ToObject<Dictionary<string, int>>(File.ReadAllText(BASEVERFILE));
		}
		if (LocalVersion == null)
		{
			LocalVersion = new Dictionary<string, int>();
		}
		Version = new Dictionary<string, ResRoot>();
		UnityWebRequestHelper.Instance.Get(UrlUtils.baseUrl_es + "api/metaversefile/1", delegate(RequestStatus status, string result)
		{
			if (status == RequestStatus.success)
			{
				foreach (ResRoot datum in LitJson.JsonMapper.ToObject<Res1>(result).data)
				{
					if (!Version.ContainsKey(datum.file_name))
					{
						Version.Add(datum.file_name, datum);
					}
				}
			}
			cb?.Invoke();
		});
	}

	public static Pvr_UnitySDKManager getPicoVr()
	{
		return Pvr_UnitySDKManager.SDK;
	}

	private static Pvr_UnitySDKManager findPicoVr(Transform a, int depth, int maxDepth = 6)
	{
		if (depth >= maxDepth)
		{
			return null;
		}
		Pvr_UnitySDKManager component = a.gameObject.GetComponent<Pvr_UnitySDKManager>();
		if ((bool)component)
		{
			return component;
		}
		for (int i = 0; i < a.childCount; i++)
		{
			Pvr_UnitySDKManager pvr_UnitySDKManager = findPicoVr(a.GetChild(i), depth + 1, maxDepth);
			if ((bool)pvr_UnitySDKManager)
			{
				return pvr_UnitySDKManager;
			}
		}
		return null;
	}
}
public class MoveCamera : MonoBehaviour
{
	public float turnSpeed = 4f;

	public float panSpeed = 4f;

	public float zoomSpeed = 4f;

	private Vector3 mouseOrigin;

	private bool isPanning;

	private bool isRotating;

	private bool isZooming;

	private void Update()
	{
		if (Input.GetMouseButtonDown(0))
		{
			mouseOrigin = Input.mousePosition;
			isRotating = true;
		}
		if (Input.GetMouseButtonDown(1))
		{
			mouseOrigin = Input.mousePosition;
			isPanning = true;
		}
		if (Input.GetMouseButtonDown(2))
		{
			mouseOrigin = Input.mousePosition;
			isZooming = true;
		}
		if (!Input.GetMouseButton(0))
		{
			isRotating = false;
		}
		if (!Input.GetMouseButton(1))
		{
			isPanning = false;
		}
		if (!Input.GetMouseButton(2))
		{
			isZooming = false;
		}
		if (isRotating)
		{
			Vector3 vector = Camera.main.ScreenToViewportPoint(Input.mousePosition - mouseOrigin);
			base.transform.RotateAround(base.transform.position, base.transform.right, (0f - vector.y) * turnSpeed);
			base.transform.RotateAround(base.transform.position, Vector3.up, vector.x * turnSpeed);
		}
		if (isPanning)
		{
			Vector3 vector2 = Camera.main.ScreenToViewportPoint(Input.mousePosition - mouseOrigin);
			Vector3 translation = new Vector3(vector2.x * panSpeed, vector2.y * panSpeed, 0f);
			base.transform.Translate(translation, Space.Self);
		}
		if (isZooming)
		{
			Vector3 translation2 = Camera.main.ScreenToViewportPoint(Input.mousePosition - mouseOrigin).y * zoomSpeed * base.transform.forward;
			base.transform.Translate(translation2, Space.World);
		}
	}
}
public class Msgpanel : MonoBehaviour
{
	private float hidetime;

	public Text tt;

	private static GameObject msgPanel = null;

	private static string txt = "";

	private void Start()
	{
		hidetime = Time.time + 8f;
		if (txt != "")
		{
			tt.text = txt;
		}
	}

	private void Update()
	{
		if (Time.time > hidetime)
		{
			UnityEngine.Object.Destroy(base.gameObject);
			msgPanel = null;
		}
	}

	public static void ShowMsg(string a = "")
	{
		if (msgPanel != null)
		{
			UnityEngine.Object.Destroy(msgPanel);
		}
		txt = a;
		Transform transform = Load.getPicoVr().transform.Find("Head");
		if ((bool)transform)
		{
			msgPanel = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("MsgPanel"), transform);
		}
	}
}
public class Pvr_ctr : MonoBehaviour
{
	public static Pvr_ctr Ins;

	public GameObject controller0;

	public GameObject controller1;

	public float rayDefaultLength = 4f;

	private RaycastHit hit;

	private GameObject rayLine;

	public GameObject dot;

	private GameObject _currentController;

	private bool isHasController;

	private Ray ray;

	private LineRenderer rayRender;

	private Transform startobj;

	private bool setCvsZ;

	private GameObject currentController
	{
		get
		{
			return _currentController;
		}
		set
		{
			_currentController = value;
			if (dot != null)
			{
				dot.SetActive(value: false);
			}
			if (rayLine != null)
			{
				rayLine.SetActive(value: false);
			}
			dot = _currentController.transform.Find("dot").gameObject;
			rayLine = _currentController.transform.Find("ray_LengthAdaptive").gameObject;
			dot.SetActive(value: true);
			rayLine.SetActive(value: true);
			rayRender = rayLine.GetComponent<LineRenderer>();
			startobj = _currentController.transform.Find("start");
		}
	}

	public static bool IsMainKeyDown()
	{
		if (!Controller.UPvr_GetKeyDown(Pvr_ControllerManager.controllerlink.mainHandID, Pvr_KeyCode.TRIGGER))
		{
			return Input.GetKeyDown(KeyCode.Mouse0);
		}
		return true;
	}

	public static bool IsMainKeyUp()
	{
		if (!Controller.UPvr_GetKeyUp(Pvr_ControllerManager.controllerlink.mainHandID, Pvr_KeyCode.TRIGGER))
		{
			return Input.GetKeyUp(KeyCode.Mouse0);
		}
		return true;
	}

	private void Start()
	{
		Ins = this;
		ray = default(Ray);
		hit = default(RaycastHit);
		Pvr_ControllerManager.PvrServiceStartSuccessEvent += ServiceStartSuccess;
		Pvr_ControllerManager.SetControllerStateChangedEvent += ControllerStateListener;
	}

	private void Update()
	{
		if (!(currentController == null))
		{
			ray.direction = currentController.transform.forward - currentController.transform.up * 0.25f;
			ray.origin = startobj.position;
			if (Physics.Raycast(ray, out hit, 100f, -8193))
			{
				dot.transform.position = hit.point;
				dot.transform.forward = hit.normal;
			}
			rayRender.SetPosition(0, currentController.transform.TransformPoint(0f, 0f, 0.072f));
			rayRender.SetPosition(1, dot.transform.position);
		}
	}

	public Ray GetRay()
	{
		ray.direction = currentController.transform.forward - currentController.transform.up * 0.25f;
		ray.origin = startobj.position;
		return ray;
	}

	private void OnDestroy()
	{
		Pvr_ControllerManager.PvrServiceStartSuccessEvent -= ServiceStartSuccess;
		Pvr_ControllerManager.SetControllerStateChangedEvent -= ControllerStateListener;
	}

	private void ServiceStartSuccess()
	{
		if (Controller.UPvr_GetMainHandNess() == 0)
		{
			currentController = controller0;
		}
		if (Controller.UPvr_GetMainHandNess() == 1)
		{
			currentController = controller1;
		}
	}

	private void ControllerStateListener(string data)
	{
		if (Controller.UPvr_GetMainHandNess() == 0)
		{
			currentController = controller0;
		}
		if (Controller.UPvr_GetMainHandNess() == 1)
		{
			currentController = controller1;
		}
	}
}
public class Item_TrainNameFruit : MonoBehaviour
{
	public string word;

	public List<string> wordsSmillar;

	public AudioClip m_nameAudio;

	public bool isWordsMatch(string voiceRecWords)
	{
		if (voiceRecWords.Contains(word))
		{
			return true;
		}
		foreach (string item in wordsSmillar)
		{
			if (!string.IsNullOrEmpty(item) && voiceRecWords.Contains(item))
			{
				return true;
			}
		}
		return false;
	}
}
public class setCvs : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
		Pvr_UIGraphicRaycaster component = GetComponent<Pvr_UIGraphicRaycaster>();
		if (component != null)
		{
			component.enabled = true;
		}
		GraphicRaycaster component2 = GetComponent<GraphicRaycaster>();
		if (component2 != null)
		{
			component2.enabled = true;
		}
	}
}
public class TrainControl_Communication : MonoBehaviour
{
	public class M_communicationScene
	{
		public class cDialogue
		{
			public int id;

			public string dialogue_question;

			public string dialogue_answer;

			public string dialogue_tip;

			public bool isAnswerCorrect;

			public bool isWordsMatch(string voiceRecWords)
			{
				if (string.IsNullOrEmpty(dialogue_answer))
				{
					return true;
				}
				return dialogue_answer.Split(',').All((string ca) => voiceRecWords.Contains(ca));
			}
		}

		public int id;

		public string scenario_name;

		public string scenario_target;

		public List<cDialogue> dialogue;
	}

	public static int sceneID = 1;

	public static int scenarioID = 1;

	[Header("NPC")]
	public C_NPCSpeaker_Train m_txtNPCDialog;

	[Header("UI")]
	public GameObject objpanelStart;

	public GameObject objpanelStartTip;

	public Text m_txtSceneTarget;

	public AudioSource m_audio_AIspeak;

	public GameObject objPanelTip;

	public Text m_txtTipContent;

	public GameObject objPanelFinish;

	public Text endTxt;

	private int wts;

	private int zqs;

	private M_communicationScene m_sceneData;

	private I_VoiceCheckResultBase m_curTargetCheck;

	private Coroutine coroutine_WaitForCommunicationContinue;

	private bool isSpeeahFinished;

	private void Start()
	{
		objpanelStart.SetActive(value: false);
		objPanelTip.SetActive(value: false);
		objPanelFinish.SetActive(value: false);
		yieldStartGetAPI();
	}

	public void Again()
	{
		objpanelStart.SetActive(value: false);
		objPanelTip.SetActive(value: false);
		objPanelFinish.SetActive(value: false);
		StartCoroutine(StartSayMuBiao());
	}

	private void yieldStartGetAPI()
	{
		objpanelStartTip.SetActive(value: true);
		baidu_WordToVoiceUtility.J_GetWordAudio("语音测评开始,请您仔细聆听后面的对话目标,根据目标内容来完成之后的对话.现在我们来尝试一下", delegate(AudioClip audioclip)
		{
			m_audio_AIspeak.clip = audioclip;
			m_audio_AIspeak.Play();
		});
	}

	public void StartMubiao()
	{
		m_audio_AIspeak.Stop();
		objpanelStartTip.SetActive(value: false);
		StartCoroutine(StartSayMuBiao());
	}

	private IEnumerator StartSayMuBiao()
	{
		yield return yieldGetCommunications();
		zqs = 0;
		objpanelStart.SetActive(value: true);
		m_txtSceneTarget.supportRichText = true;
		string words = "请仔细聆听并记住以下关键信息:" + m_sceneData.scenario_target + "您记清楚了吗?";
		m_txtSceneTarget.text = "请仔细聆听并记住以下关键信息:" + m_sceneData.scenario_target + "您记<color=#00FF6B>清楚</color>了吗?";
		baidu_WordToVoiceUtility.J_GetWordAudio(words, delegate(AudioClip audioclip)
		{
			m_audio_AIspeak.clip = audioclip;
			m_audio_AIspeak.Play();
		});
	}

	public void J_SetCheckContent(I_VoiceCheckResultBase itargetCheck)
	{
		delayAction((itargetCheck.wordID == 0) ? 4 : 2, delegate
		{
			J_VoiceRecCtrl.Inst.StartRec();
			SetCnt(itargetCheck);
		});
	}

	private void SetCnt(I_VoiceCheckResultBase itargetCheck)
	{
		m_curTargetCheck = itargetCheck;
		J_VoiceRecCtrl.Inst.J_SetWordsRecResultReceiver(delegate(DataRequestResult_voiceData recWords)
		{
			if (!string.IsNullOrEmpty(recWords.file_txt))
			{
				if (m_curTargetCheck == null)
				{
					UnityEngine.Debug.LogWarning("--empty receiver");
				}
				else
				{
					m_curTargetCheck.OnResultCheck(recWords.file_txt, delegate(bool isMatch)
					{
						if (isMatch)
						{
							J_VoiceRecCtrl.Inst.StopRec();
							m_curTargetCheck.m_eventWhenCorrect.Invoke();
						}
						else
						{
							if (m_curTargetCheck.m_eventWhenWrong.GetPersistentEventCount() > 0)
							{
								J_VoiceRecCtrl.Inst.StopRec();
							}
							m_curTargetCheck.m_eventWhenWrong.Invoke();
						}
					});
				}
			}
		});
	}

	public void J_StartCommunication()
	{
		m_audio_AIspeak.Stop();
		objpanelStart.SetActive(value: false);
		StartCoroutine(yieldLoopCommunication());
	}

	private IEnumerator yieldLoopCommunication()
	{
		wts = m_sceneData.dialogue.Count;
		int i = 0;
		while (i < m_sceneData.dialogue.Count)
		{
			M_communicationScene.cDialogue dialogData = m_sceneData.dialogue[i];
			m_txtNPCDialog.J_Speak(dialogData.dialogue_question);
			UnityEngine.Debug.Log(dialogData.dialogue_answer);
			int errC = 0;
			isSpeeahFinished = false;
			yield return new WaitForSecondsRealtime((float)dialogData.dialogue_question.Length * 0.33f);
			J_VoiceRecCtrl.Inst.StartRec();
			J_VoiceRecCtrl.Inst.J_SetWordsRecResultReceiver(delegate(DataRequestResult_voiceData recWords)
			{
				if (string.IsNullOrEmpty(recWords.file_txt) || recWords.file_txt.Replace("。", "").Trim().Length <= 1)
				{
					baidu_WordToVoiceUtility.J_GetWordAudio("不好意思,没有听清楚,请再说一遍!", delegate(AudioClip audioclip)
					{
						m_audio_AIspeak.clip = audioclip;
						m_audio_AIspeak.Play();
					});
				}
				else
				{
					m_txtNPCDialog.J_StopSpeak();
					J_VoiceRecCtrl.Inst.StopRec();
					if (dialogData.isWordsMatch(recWords.file_txt))
					{
						dialogData.isAnswerCorrect = true;
						isSpeeahFinished = true;
						objPanelTip.SetActive(value: false);
						J_VoiceRecCtrl.Inst.J_SetWordsRecResultReceiver(null);
						zqs++;
					}
					else
					{
						dialogData.isAnswerCorrect = false;
						errC++;
						if (errC > 1)
						{
							m_txtTipContent.text = "还是不对哦!";
							baidu_WordToVoiceUtility.J_GetWordAudio("还是不对哦", delegate(AudioClip audioclip)
							{
								m_audio_AIspeak.clip = audioclip;
								m_audio_AIspeak.Play();
							});
							J_VoiceRecCtrl.Inst.J_SetWordsRecResultReceiver(null);
							coroutine_WaitForCommunicationContinue = StartCoroutine(yieldSetCommunicationContinue(2f));
						}
						else
						{
							objPanelTip.SetActive(value: true);
							m_txtTipContent.text = "你可以这样说:" + dialogData.dialogue_tip;
							baidu_WordToVoiceUtility.J_GetWordAudio(m_txtTipContent.text, delegate(AudioClip audioclip)
							{
								objPanelTip.SetActive(value: true);
								m_audio_AIspeak.clip = audioclip;
								m_audio_AIspeak.Play();
								delayAction((float)m_txtTipContent.text.Length * 0.33f, J_VoiceRecCtrl.Inst.StartRec);
							});
						}
					}
				}
			});
			yield return new WaitUntil(waitForSpeakFinish);
			yield return new WaitForSeconds(1f);
			int num = i + 1;
			i = num;
		}
		endTxt.text = string.Format("测评语句 ： {0}\n正确语句 ： {1}\n    正确率 ：{2} %", wts, zqs, ((float)zqs * 100f / (float)wts * 1f).ToString("F2"));
		objPanelFinish.SetActive(value: true);
	}

	private IEnumerator yieldSetCommunicationContinue(float fseconds)
	{
		yield return new WaitForSeconds(fseconds);
		isSpeeahFinished = true;
		objPanelTip.SetActive(value: false);
	}

	private bool waitForSpeakFinish()
	{
		return isSpeeahFinished;
	}

	private void delayAction(float delaytime, Action action)
	{
		StartCoroutine(yieldDelayaction(delaytime, action));
	}

	private IEnumerator yieldDelayaction(float delaytime, Action action)
	{
		yield return new WaitForSeconds(delaytime);
		action?.Invoke();
	}

	private IEnumerator yieldGetCommunications()
	{
		return (UrlUtils.baseUrl_es + UrlUtils.scenario + "/show?scenario=" + scenarioID).HttpGet(delegate(M_communicationScene p2)
		{
			UnityEngine.Debug.Log(p2.scenario_target);
			m_sceneData = p2;
		});
	}
}
public class TrainControl_Naming : MonoBehaviour
{
	public int m_TrainItemNum = 3;

	public AudioSource m_audioTipWhat;

	public AudioSource m_audioTipResult;

	public List<AudioClip> listAudiosCorrect;

	public List<AudioClip> listAudiosWRONG;

	public Transform m_templatePanzi;

	private Material meshpanzi;

	public Transform m_ItemContainer;

	private Animator itemshowAnimator;

	public List<UnityEngine.Object> m_listItems;

	public UnityEvent m_eventOnFinish;

	private int _curTrainCount;

	private bool isShowingResult;

	private List<UnityEngine.Object> tempRandomlistItems = new List<UnityEngine.Object>();

	private Item_TrainNameFruit objTargetData;

	private I_VoiceCheckResultBase m_curTargetCheck;

	private GameObject showedobjModel;

	private int ishowindex;

	private void Start()
	{
		m_listItems.ForEach(delegate(UnityEngine.Object i)
		{
			tempRandomlistItems.Add(i);
		});
		tempRandomlistItems.RandomList();
		m_templatePanzi.gameObject.SetActive(value: false);
		meshpanzi = m_templatePanzi.Find("panzi").GetComponent<MeshRenderer>().material;
		meshpanzi.SetColor("_EmissionColor", Color.white);
		m_audioTipResult.loop = false;
		m_audioTipResult.playOnAwake = false;
		itemshowAnimator = m_ItemContainer.GetComponent<Animator>();
		for (int num = m_ItemContainer.childCount - 1; num >= 0; num--)
		{
			UnityEngine.Object.Destroy(m_ItemContainer.GetChild(num).gameObject);
		}
	}

	public void J_StartPlay()
	{
		J_VoiceRecCtrl.Inst.J_SetWordsRecResultReceiver(delegate(DataRequestResult_voiceData recWords)
		{
			if (!string.IsNullOrEmpty(recWords.file_txt))
			{
				if (objTargetData == null)
				{
					UnityEngine.Debug.Log("--not ready,not started");
				}
				else if (isShowingResult)
				{
					UnityEngine.Debug.Log("--not ready,showing result");
				}
				else
				{
					J_VoiceRecCtrl.Inst.StopRec();
					_curTrainCount++;
					if (_curTrainCount >= m_TrainItemNum)
					{
						if (objTargetData.isWordsMatch(recWords.file_txt))
						{
							UnityEngine.Debug.Log("--match");
							ShowResponseResult(isCorrect: true, delegate
							{
								m_eventOnFinish.Invoke();
								showedobjModel?.SetActive(value: false);
							});
						}
						else
						{
							UnityEngine.Debug.Log("--wrong");
							ShowResponseResult(isCorrect: false, delegate
							{
								m_eventOnFinish.Invoke();
								showedobjModel?.SetActive(value: false);
							});
						}
					}
					else if (objTargetData.isWordsMatch(recWords.file_txt))
					{
						UnityEngine.Debug.Log("--match");
						ShowResponseResult(isCorrect: true, delegate
						{
							_showAContent();
						});
					}
					else
					{
						UnityEngine.Debug.Log("--wrong");
						ShowResponseResult(isCorrect: false, delegate
						{
							_showAContent();
						});
					}
				}
			}
		});
		m_templatePanzi.gameObject.SetActive(value: true);
		_showAContent();
	}

	public void J_SetCheckContent(I_VoiceCheckResultBase itargetCheck)
	{
		delayAction((itargetCheck.gameObject.name == "结束") ? 2 : 4, delegate
		{
			J_VoiceRecCtrl.Inst.StartRec();
			SetCnt(itargetCheck);
		});
	}

	private void SetCnt(I_VoiceCheckResultBase itargetCheck)
	{
		m_curTargetCheck = itargetCheck;
		J_VoiceRecCtrl.Inst.J_SetWordsRecResultReceiver(delegate(DataRequestResult_voiceData recWords)
		{
			if (!string.IsNullOrEmpty(recWords.file_txt))
			{
				if (m_curTargetCheck == null)
				{
					UnityEngine.Debug.LogWarning("--empty receiver");
				}
				else
				{
					m_curTargetCheck.OnResultCheck(recWords.file_txt, delegate(bool isMatch)
					{
						if (isMatch)
						{
							J_VoiceRecCtrl.Inst.StopRec();
							m_curTargetCheck.m_eventWhenCorrect.Invoke();
						}
						else
						{
							if (m_curTargetCheck.m_eventWhenWrong.GetPersistentEventCount() > 0)
							{
								J_VoiceRecCtrl.Inst.StopRec();
							}
							m_curTargetCheck.m_eventWhenWrong.Invoke();
						}
					});
				}
			}
		});
	}

	private void delayAction(float delaytime, Action action)
	{
		StartCoroutine(yieldDelayaction(delaytime, action));
	}

	private IEnumerator yieldDelayaction(float delaytime, Action action)
	{
		yield return new WaitForSeconds(delaytime);
		action?.Invoke();
	}

	private void _showAContent()
	{
		meshpanzi.SetColor("_EmissionColor", Color.white);
		if (showedobjModel != null)
		{
			UnityEngine.Object.Destroy(showedobjModel.gameObject);
		}
		if (ishowindex > tempRandomlistItems.Count - 1)
		{
			ishowindex = 0;
			tempRandomlistItems.RandomList();
		}
		showedobjModel = UnityEngine.Object.Instantiate(tempRandomlistItems[ishowindex]) as GameObject;
		ishowindex++;
		objTargetData = showedobjModel.GetComponent<Item_TrainNameFruit>();
		UnityEngine.Debug.Log(objTargetData.word);
		showedobjModel.transform.SetParent(m_ItemContainer.transform);
		showedobjModel.transform.localPosition = Vector3.zero;
		showedobjModel.transform.localEulerAngles = Vector3.zero;
		showedobjModel.transform.localScale = Vector3.one;
		showedobjModel.SetActive(value: true);
		if (itemshowAnimator != null)
		{
			itemshowAnimator.Play("showitem", 0);
		}
		m_audioTipWhat.Play();
		delayAction(2f, J_VoiceRecCtrl.Inst.StartRec);
	}

	private void ShowResponseResult(bool isCorrect, Action actionFinishAnim = null)
	{
		if (isCorrect)
		{
			StartCoroutine(yieldPlayResultAudio(isCorrect: true, actionFinishAnim));
		}
		else
		{
			StartCoroutine(yieldPlayResultAudio(isCorrect: false, actionFinishAnim));
		}
	}

	private IEnumerator yieldPlayResultAudio(bool isCorrect, Action actionFinishAnim = null)
	{
		isShowingResult = true;
		if (isCorrect)
		{
			meshpanzi.SetColor("_EmissionColor", Color.green);
			AudioClip audioClip = listAudiosCorrect[UnityEngine.Random.Range(0, listAudiosCorrect.Count)];
			m_audioTipResult.clip = audioClip;
			m_audioTipResult.Play();
			yield return new WaitForSeconds(audioClip.length);
		}
		else
		{
			meshpanzi.SetColor("_EmissionColor", Color.red);
			AudioClip audioClip2 = listAudiosWRONG[UnityEngine.Random.Range(0, listAudiosWRONG.Count)];
			m_audioTipResult.clip = audioClip2;
			m_audioTipResult.Play();
			yield return new WaitForSeconds(audioClip2.length);
			if (objTargetData != null && objTargetData.m_nameAudio != null)
			{
				yield return new WaitForSeconds(0.3f);
				m_audioTipResult.clip = objTargetData.m_nameAudio;
				m_audioTipResult.Play();
				yield return new WaitForSeconds(objTargetData.m_nameAudio.length);
			}
		}
		isShowingResult = false;
		actionFinishAnim?.Invoke();
	}

	private IEnumerator yieldSetPanziColor(bool istrue)
	{
		yield return null;
		if (istrue)
		{
			meshpanzi.SetColor("_EmissionColor", Color.green);
		}
		else
		{
			meshpanzi.SetColor("_EmissionColor", Color.red);
		}
	}

	public void J_ReloadScene()
	{
		SceneManager.LoadScene(SceneManager.GetActiveScene().name, LoadSceneMode.Single);
	}
}
public class TrainControl_Naming_Animal : MonoBehaviour
{
	public int m_TrainItemNum = 3;

	public AudioSource m_audioTipWhat;

	public AudioSource m_audioTipResult;

	public List<AudioClip> listAudiosCorrect;

	public List<AudioClip> listAudiosWRONG;

	public MeshRenderer meshpanzi;

	public Transform m_ItemContainer;

	private Animator itemshowAnimator;

	public List<UnityEngine.Object> m_listItems;

	public UnityEvent m_eventOnFinish;

	private int _curTrainCount;

	private bool isShowingResult;

	private List<UnityEngine.Object> tempRandomlistItems = new List<UnityEngine.Object>();

	private Item_TrainNameFruit objTargetData;

	private I_VoiceCheckResultBase m_curTargetCheck;

	private GameObject showedobjModel;

	private int ishowindex;

	private void Start()
	{
		AudioListener.volume = 1.2f;
		m_listItems.ForEach(delegate(UnityEngine.Object i)
		{
			tempRandomlistItems.Add(i);
		});
		tempRandomlistItems.RandomList();
		meshpanzi.material.SetColor("_EmissionColor", Color.white);
		m_audioTipResult.loop = false;
		m_audioTipResult.playOnAwake = false;
		itemshowAnimator = m_ItemContainer.GetComponent<Animator>();
	}

	public void J_StartPlay()
	{
		J_VoiceRecCtrl.Inst.J_SetWordsRecResultReceiver(delegate(DataRequestResult_voiceData recWords)
		{
			if (!string.IsNullOrEmpty(recWords.file_txt))
			{
				if (objTargetData == null)
				{
					UnityEngine.Debug.Log("--not ready,not started");
				}
				else if (isShowingResult)
				{
					UnityEngine.Debug.Log("--not ready,showing result");
				}
				else
				{
					J_VoiceRecCtrl.Inst.StopRec();
					_curTrainCount++;
					if (_curTrainCount >= m_TrainItemNum)
					{
						if (objTargetData.isWordsMatch(recWords.file_txt))
						{
							UnityEngine.Debug.Log("--match");
							ShowResponseResult(isCorrect: true, delegate
							{
								m_eventOnFinish.Invoke();
							});
						}
						else
						{
							UnityEngine.Debug.Log("--wrong");
							ShowResponseResult(isCorrect: false, delegate
							{
								m_eventOnFinish.Invoke();
							});
						}
					}
					else if (objTargetData.isWordsMatch(recWords.file_txt))
					{
						UnityEngine.Debug.Log("--match");
						ShowResponseResult(isCorrect: true, delegate
						{
							_showAContent();
						});
					}
					else
					{
						UnityEngine.Debug.Log("--wrong");
						ShowResponseResult(isCorrect: false, delegate
						{
							_showAContent();
						});
					}
				}
			}
		});
		_showAContent();
	}

	public void J_SetCheckContent(I_VoiceCheckResultBase itargetCheck)
	{
		delayAction((itargetCheck.gameObject.name == "结束") ? 2 : 4, delegate
		{
			J_VoiceRecCtrl.Inst.StartRec();
			SetCnt(itargetCheck);
		});
	}

	private void SetCnt(I_VoiceCheckResultBase itargetCheck)
	{
		m_curTargetCheck = itargetCheck;
		J_VoiceRecCtrl.Inst.J_SetWordsRecResultReceiver(delegate(DataRequestResult_voiceData recWords)
		{
			if (!string.IsNullOrEmpty(recWords.file_txt))
			{
				if (m_curTargetCheck == null)
				{
					UnityEngine.Debug.LogWarning("--empty receiver");
				}
				else
				{
					m_curTargetCheck.OnResultCheck(recWords.file_txt, delegate(bool isMatch)
					{
						if (isMatch)
						{
							J_VoiceRecCtrl.Inst.StopRec();
							m_curTargetCheck.m_eventWhenCorrect.Invoke();
						}
						else
						{
							if (m_curTargetCheck.m_eventWhenWrong.GetPersistentEventCount() > 0)
							{
								J_VoiceRecCtrl.Inst.StopRec();
							}
							m_curTargetCheck.m_eventWhenWrong.Invoke();
						}
					});
				}
			}
		});
	}

	private void _showAContent()
	{
		meshpanzi.material.SetColor("_EmissionColor", Color.white);
		if (showedobjModel != null)
		{
			UnityEngine.Object.Destroy(showedobjModel.gameObject);
		}
		if (ishowindex > tempRandomlistItems.Count - 1)
		{
			ishowindex = 0;
			tempRandomlistItems.RandomList();
		}
		showedobjModel = UnityEngine.Object.Instantiate(tempRandomlistItems[ishowindex]) as GameObject;
		ishowindex++;
		objTargetData = showedobjModel.GetComponent<Item_TrainNameFruit>();
		UnityEngine.Debug.Log(objTargetData.word);
		showedobjModel.transform.SetParent(m_ItemContainer.transform);
		showedobjModel.transform.localPosition = Vector3.zero;
		showedobjModel.transform.localEulerAngles = Vector3.zero;
		showedobjModel.transform.localScale = Vector3.one;
		showedobjModel.SetActive(value: true);
		if (itemshowAnimator != null)
		{
			itemshowAnimator.Play("showitem", 0);
		}
		m_audioTipWhat.Play();
		delayAction(2f, J_VoiceRecCtrl.Inst.StartRec);
	}

	private void ShowResponseResult(bool isCorrect, Action actionFinishAnim = null)
	{
		if (isCorrect)
		{
			StartCoroutine(yieldPlayResultAudio(isCorrect: true, actionFinishAnim));
		}
		else
		{
			StartCoroutine(yieldPlayResultAudio(isCorrect: false, actionFinishAnim));
		}
	}

	private IEnumerator yieldPlayResultAudio(bool isCorrect, Action actionFinishAnim = null)
	{
		isShowingResult = true;
		if (isCorrect)
		{
			meshpanzi.material.SetColor("_EmissionColor", Color.green);
			AudioClip audioClip = listAudiosCorrect[UnityEngine.Random.Range(0, listAudiosCorrect.Count)];
			m_audioTipResult.clip = audioClip;
			m_audioTipResult.Play();
			yield return new WaitForSeconds(audioClip.length);
		}
		else
		{
			meshpanzi.material.SetColor("_EmissionColor", Color.red);
			AudioClip audioClip2 = listAudiosWRONG[UnityEngine.Random.Range(0, listAudiosWRONG.Count)];
			m_audioTipResult.clip = audioClip2;
			m_audioTipResult.Play();
			yield return new WaitForSeconds(audioClip2.length);
			if (objTargetData != null && objTargetData.m_nameAudio != null)
			{
				yield return new WaitForSeconds(0.3f);
				m_audioTipResult.clip = objTargetData.m_nameAudio;
				m_audioTipResult.Play();
				yield return new WaitForSeconds(objTargetData.m_nameAudio.length);
			}
		}
		isShowingResult = false;
		actionFinishAnim?.Invoke();
	}

	private void delayAction(float delaytime, Action action)
	{
		StartCoroutine(yieldDelayaction(delaytime, action));
	}

	private IEnumerator yieldDelayaction(float delaytime, Action action)
	{
		yield return new WaitForSeconds(delaytime);
		action?.Invoke();
	}

	public void J_ReloadScene()
	{
		SceneManager.LoadScene(SceneManager.GetActiveScene().name, LoadSceneMode.Single);
	}
}
public class VRPlayerController : MonoBehaviour
{
	private string curSceneName = "";

	private float ftimer;

	private void Start()
	{
		Pvr_UnitySDKSensor.Instance.ResetUnitySDKSensor();
		curSceneName = SceneManager.GetActiveScene().name;
	}

	private void Update()
	{
		if (ftimer > 0f)
		{
			ftimer -= Time.deltaTime;
		}
		if (Controller.UPvr_GetKeyDown(Pvr_ControllerManager.controllerlink.mainHandID, Pvr_KeyCode.APP))
		{
			_tryCheckQuitApp();
		}
	}

	private void _tryCheckQuitApp()
	{
		if (ftimer > 0f)
		{
			UnityEngine.Debug.Log("--quit");
			Application.Quit();
		}
		else
		{
			ftimer = 0.3f;
		}
	}

	private void OnApplicationPause(bool pause)
	{
		Pvr_UnitySDKSensor.Instance.ResetUnitySDKSensor();
	}
}
internal static class SimilarWord
{
	public class TypeWord
	{
		public string name;

		public string url;

		public int od;

		public int fs;
	}

	private static Dictionary<string, string> XSY = new Dictionary<string, string>
	{
		{ "z", "zh" },
		{ "c", "ch" },
		{ "s", "sh" },
		{ "l", "n" },
		{ "f", "h" },
		{ "r", "l" },
		{ "an", "ang" },
		{ "en", "eng" },
		{ "in", "ing" },
		{ "ian", "iang" },
		{ "uan", "uang" }
	};

	public static Dictionary<string, List<TypeWord>> TYPEwords = new Dictionary<string, List<TypeWord>>();

	public static Dictionary<string, List<string>> SMwords = new Dictionary<string, List<string>>();

	public static void Init(MonoBehaviour ba)
	{
		ba.StartCoroutine((UrlUtils.baseUrl_es + UrlUtils.optimize).HttpGet(delegate(Dictionary<string, string> r)
		{
			SMwords = new Dictionary<string, List<string>>();
			foreach (KeyValuePair<string, string> item in r)
			{
				try
				{
					SMwords.Add(item.Key, item.Value.ToLower().Replace(" ", "").Split(',')
						.ToList());
				}
				catch
				{
				}
			}
		}));
		ba.StartCoroutine((UrlUtils.baseUrl_es + UrlUtils.libray).HttpGet(delegate(Dictionary<string, List<TypeWord>> r)
		{
			TYPEwords = r;
		}));
	}

	public static List<WrodObjectsManager.structWordObject> IsMatch(this string Say, WrodObjectsManager.structWordObject[] Anser)
	{
		List<WrodObjectsManager.structWordObject> list = new List<WrodObjectsManager.structWordObject>();
		foreach (WrodObjectsManager.structWordObject structWordObject in Anser)
		{
			if (Say.IsMatch(structWordObject.word))
			{
				list.Add(structWordObject);
			}
		}
		return list;
	}

	public static List<string> IsMatch(this string Say, List<string> Anser)
	{
		List<string> list = new List<string>();
		foreach (string item in Anser)
		{
			if (Say.IsMatch(item))
			{
				list.Add(item);
			}
		}
		return list;
	}

	public static bool IsMatch(this string Say, string Anser, out int fenshu)
	{
		fenshu = 0;
		if (string.IsNullOrEmpty(Anser) || string.IsNullOrEmpty(Say))
		{
			return false;
		}
		if (Say.Contains(Anser))
		{
			fenshu = 100;
			return true;
		}
		if (!SMwords.ContainsKey(Anser))
		{
			string text = Say.PY(replaceSpace: false);
			string text2 = Anser.PY(replaceSpace: false);
			fenshu = 60;
			foreach (KeyValuePair<string, string> item in XSY)
			{
				if (text.Replace(item.Key, item.Value) == text2)
				{
					return true;
				}
				if (text.Replace(item.Value, item.Key) == text2)
				{
					return true;
				}
			}
			return text == text2;
		}
		string py = Say.PY();
		fenshu = 80;
		return SMwords[Anser].Any((string ca) => py == ca);
	}

	public static bool IsMatch(this string Say, string Anser)
	{
		if (string.IsNullOrEmpty(Anser) || string.IsNullOrEmpty(Say))
		{
			return false;
		}
		if (Say.Contains(Anser))
		{
			return true;
		}
		if (!SMwords.ContainsKey(Anser))
		{
			string text = Say.PY(replaceSpace: false);
			string text2 = Anser.PY(replaceSpace: false);
			foreach (KeyValuePair<string, string> item in XSY)
			{
				if (text.Replace(item.Key, item.Value) == text2)
				{
					return true;
				}
				if (text.Replace(item.Value, item.Key) == text2)
				{
					return true;
				}
			}
			return text == text2;
		}
		string py = Say.PY();
		return SMwords[Anser].Any((string ca) => py == ca);
	}

	public static List<TypeWord> IsMatchType(this string Say, string type)
	{
		List<TypeWord> list = new List<TypeWord>();
		if (string.IsNullOrEmpty(Say) || string.IsNullOrEmpty(Say))
		{
			return list;
		}
		if (!TYPEwords.ContainsKey(type))
		{
			return list;
		}
		int num = Say.PYLen();
		string text = Say.PY();
		foreach (TypeWord item in TYPEwords[type])
		{
			if (Say.IsMatch(item.name, out var fenshu))
			{
				item.od = text.IndexOf(item.name.PY());
				item.fs = fenshu;
				list.Add(item);
			}
		}
		List<TypeWord> r2 = list.OrderBy((TypeWord ca) => ca.od).ToList();
		int i;
		for (i = r2.Count - 1; i > -1; i--)
		{
			if (r2.Any((TypeWord ca) => ca.name != r2[i].name && ca.name.Contains(r2[i].name)))
			{
				r2.RemoveAt(i);
			}
		}
		r2 = r2.OrderByDescending((TypeWord c2) => c2.fs).ToList();
		List<TypeWord> list2 = new List<TypeWord>();
		List<string> list3 = new List<string>();
		int num2 = 0;
		foreach (TypeWord item2 in r2)
		{
			if (!list3.Contains(item2.name))
			{
				list3.Add(item2.name);
				list2.Add(item2);
				num2 += item2.name.PYLen();
				if (num2 >= num)
				{
					break;
				}
			}
		}
		return list2;
	}

	public static string PY(this string s, bool replaceSpace = true)
	{
		if (string.IsNullOrEmpty(s))
		{
			return "";
		}
		if (replaceSpace)
		{
			return Pinyin.GetPinyin(s).Replace(" ", "").Trim()
				.ToLower();
		}
		return Pinyin.GetPinyin(s).Trim().ToLower();
	}

	public static int PYLen(this string s)
	{
		if (string.IsNullOrEmpty(s))
		{
			return 0;
		}
		try
		{
			return Pinyin.GetPinyin(s).Trim().Split(' ')
				.Length;
		}
		catch
		{
		}
		return 1;
	}
}
internal class SimilarWordTest : MonoBehaviour
{
	private void Start()
	{
		SimilarWord.Init(this);
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.A))
		{
			log("青菜".IsMatchType("蔬菜"));
			log("芹菜".IsMatchType("蔬菜"));
		}
	}

	private void log(List<SimilarWord.TypeWord> aa)
	{
		string text = "";
		foreach (SimilarWord.TypeWord item in aa)
		{
			text = text + item.name + ",";
		}
		UnityEngine.Debug.Log(text);
	}
}
public static class stc
{
	public static System.Random r = new System.Random(Environment.TickCount);

	public static string RandomWord(this int len)
	{
		string text = "";
		for (int i = 0; i < len; i++)
		{
			int num = r.Next(26) + 97;
			text += (char)num;
		}
		return text;
	}

	public static void Get<T>(this MonoBehaviour aa, string uri, Action<T> cb) where T : class
	{
		aa.StartCoroutine(uri.HttpGet2(cb));
	}

	public static IEnumerator HttpGet2<T>(this string uri, Action<T> cb) where T : class
	{
		UnityEngine.Debug.Log(uri);
		using UnityWebRequest webRequest = UnityWebRequest.Get(uri);
		yield return webRequest.SendWebRequest();
		if (webRequest.isHttpError || webRequest.isNetworkError)
		{
			UnityEngine.Debug.Log(webRequest.error);
			yield break;
		}
		if (typeof(T) == typeof(string))
		{
			cb(webRequest.downloadHandler.text as T);
			yield break;
		}
		T obj = null;
		try
		{
			obj = LitJson.JsonMapper.ToObject<T>(webRequest.downloadHandler.text);
		}
		catch (Exception ex)
		{
			UnityEngine.Debug.LogError(ex.Message);
		}
		cb(obj);
	}

	public static string ToMinSec(this float a)
	{
		int num = (int)(a / 60f);
		float num2 = a % 60f;
		return num + ":" + num2.ToString("00");
	}

	public static string ToMinSec(this double a)
	{
		int num = (int)(a / 60.0);
		double num2 = a % 60.0;
		return num + ":" + num2.ToString("00");
	}

	public static T Obj<T>(this string a)
	{
		return J_LitJson.JsonMapper.ToObject<T>(a);
	}

	public static string Join<T>(this IEnumerable<T> b, char symbol = ',', string baowei = "")
	{
		StringBuilder stringBuilder = new StringBuilder();
		string text = symbol.ToString();
		IEnumerator<T> enumerator = b.GetEnumerator();
		while (enumerator.MoveNext())
		{
			stringBuilder.Append(string.Concat(baowei, enumerator.Current, baowei, text));
		}
		return stringBuilder.ToString().Trim(symbol);
	}

	public static string Null(this string b, string c)
	{
		if (!string.IsNullOrEmpty(b))
		{
			return b;
		}
		return c;
	}

	public static IEnumerator HttpGet<T>(this string uri, Action<T> cb) where T : class
	{
		return uri.HttpGet(delegate(string txt)
		{
			LitJson.JsonData jsonData = LitJson.JsonMapper.ToObject(txt);
			if (jsonData["code"].ToString() == "200")
			{
				UnityEngine.Debug.Log(jsonData["data"].ToJson());
				T obj = LitJson.JsonMapper.ToObject<T>(jsonData["data"].ToJson());
				cb(obj);
			}
			else
			{
				UnityEngine.Debug.LogError("data error:" + jsonData["msg"].ToString());
			}
		});
	}

	public static IEnumerator HttpGet(this string uri, Action<string> cb)
	{
		using UnityWebRequest webRequest = UnityWebRequest.Get(uri);
		yield return webRequest.SendWebRequest();
		if (webRequest.isHttpError || webRequest.isNetworkError)
		{
			UnityEngine.Debug.LogError(webRequest.error);
			yield break;
		}
		try
		{
			UnityEngine.Debug.Log(webRequest.downloadHandler.text);
			cb(webRequest.downloadHandler.text);
		}
		catch (Exception ex)
		{
			UnityEngine.Debug.LogError("json format error:" + webRequest.downloadHandler.text);
			UnityEngine.Debug.LogError(ex.Message);
		}
	}

	public static void LoadWebAudio(this string url, MonoBehaviour mo, Action<AudioClip> cb)
	{
		AudioType atype = AudioType.WAV;
		if (Path.GetExtension(url) == ".mp3")
		{
			atype = AudioType.MPEG;
		}
		mo.StartCoroutine(_LoadWebAud(url, cb, atype));
	}

	private static IEnumerator _LoadWebAud(string url, Action<AudioClip> cb, AudioType atype = AudioType.WAV)
	{
		using UnityWebRequest uwr = UnityWebRequestMultimedia.GetAudioClip(url, atype);
		yield return uwr.SendWebRequest();
		if (uwr.isNetworkError)
		{
			UnityEngine.Debug.LogError(uwr.error);
			yield break;
		}
		AudioClip content = DownloadHandlerAudioClip.GetContent(uwr);
		cb(content);
	}

	public static void ClearChild(this Transform p1)
	{
		for (int i = 0; i < p1.childCount; i++)
		{
			UnityEngine.Object.Destroy(p1.GetChild(i).gameObject);
		}
	}

	public static void ClearChild(this Transform p1, Transform p2)
	{
		for (int i = 0; i < p1.childCount; i++)
		{
			if (!(p1.GetChild(i) == p2))
			{
				UnityEngine.Object.Destroy(p1.GetChild(i).gameObject);
			}
		}
	}

	public static void LoadWebTex(this string url, MonoBehaviour mo, Action<Texture2D> cb)
	{
		mo.StartCoroutine(_LoadWebTex(url, cb));
	}

	public static Sprite ToSprite(this Texture2D a)
	{
		return Sprite.Create(a, new Rect(0f, 0f, a.width, a.height), Vector2.zero);
	}

	private static IEnumerator _LoadWebTex(string url, Action<Texture2D> cb)
	{
		WWW www = new WWW(url);
		yield return www;
		if (www != null && string.IsNullOrEmpty(www.error))
		{
			cb(www.texture);
		}
	}

	public static void Wait(this MonoBehaviour a, float sec, Action cb)
	{
		a.StartCoroutine(_wait(sec, cb));
	}

	private static IEnumerator _wait(float sec, Action cb)
	{
		yield return new WaitForSecondsRealtime(sec);
		cb?.Invoke();
	}

	public static string FilterRecWord(this string s)
	{
		return new Regex("[a-zA-Z0-9\\s]+").Replace(s, "");
	}

	public static string Json(this object s)
	{
		return LitJson.JsonMapper.ToJson(s);
	}

	public static void SetOtherUICanvaState(this GameObject menu)
	{
		if (menu.GetComponent<AutoSetCvs>() == null)
		{
			menu.AddComponent<AutoSetCvs>().Change(menu, menu.activeSelf);
		}
	}
}
public class VoiceRec : MonoBehaviour
{
	private class AAa
	{
		public string file_url { get; set; }
	}

	public Text tex;

	private int Frequency = 16000;

	private int MicSecond = 60;

	public AudioSource au;

	private string _deviceName;

	private float stime;

	private void Update()
	{
		if (stime > 0f)
		{
			tex.text = (int)(Time.time - stime) + "s";
		}
	}

	public void StartRecordAudio()
	{
		au.Stop();
		au.loop = false;
		au.mute = true;
		au.clip = Microphone.Start(_deviceName, loop: false, MicSecond, Frequency);
		_ = DateTime.Now;
		while (Microphone.GetPosition(_deviceName) <= 0)
		{
		}
		au.Play();
		log("开始录音.....");
		stime = Time.time;
	}

	public void StopRecordAudio()
	{
		stime = 0f;
		log("结束录音.....");
		AudioLength();
		Microphone.End(_deviceName);
		au.Stop();
		byte[] array = SaveRecordData();
		log(array.Length.ToString());
		Upload(array);
	}

	public void AbortRecordAudio()
	{
		try
		{
			stime = 0f;
			Microphone.End(_deviceName);
			au.Stop();
		}
		catch
		{
		}
	}

	private void log(string a)
	{
		if ((bool)GameObject.Find("logText"))
		{
			GameObject.Find("logText").GetComponent<Text>().text += a;
		}
	}

	private void Upload(byte[] bytes)
	{
		StartCoroutine(VoiceRecUtility.yieldGetQinuiyunToken(delegate(string tk)
		{
			string file_url = LitJson.JsonMapper.ToObject<AAa>(VoiceRecUtility.HttpPostData(bytes, tk)).file_url;
			log(file_url);
			string text = "https://huaijiu.guavavr.com/wx/liuyan?uid=" + Keting.Uid + "&fid=" + Keting.curFile.Id + "&fn=" + WWW.EscapeURL(file_url);
			UnityEngine.Debug.Log(text);
			StartCoroutine(text.HttpGet2(delegate(Ares r)
			{
				Keting.Ins.LoadMsg2();
				if (r.suc)
				{
					tex.text = "录音完成\n已保存至录音列表";
					log("上传成功");
				}
				else
				{
					log(r.msg);
				}
			}));
		}));
	}

	public void PlayRecordAudio()
	{
		if (!Microphone.IsRecording(_deviceName) && !(au.clip == null))
		{
			au.mute = false;
			au.loop = false;
			au.Play();
			log("播放录音.....");
		}
	}

	public byte[] SaveRecordData()
	{
		if (Microphone.IsRecording(_deviceName))
		{
			Microphone.End(_deviceName);
		}
		if (au.clip.length < 0.5f)
		{
			log("--too shot");
			return null;
		}
		using MemoryStream memoryStream = CreateEmpty();
		ConvertAndWrite(memoryStream, au.clip);
		WriteHeader(memoryStream, au.clip);
		return memoryStream.ToArray();
	}

	private void ConvertAndWrite(MemoryStream fileStream, AudioClip clip)
	{
		float[] array = new float[clip.samples];
		clip.GetData(array, 0);
		short[] array2 = new short[array.Length];
		byte[] array3 = new byte[array.Length * 2];
		int num = 32767;
		for (int i = 0; i < array.Length; i++)
		{
			array2[i] = (short)(array[i] * (float)num);
			_ = new byte[2];
			BitConverter.GetBytes(array2[i]).CopyTo(array3, i * 2);
		}
		fileStream.Write(array3, 0, array3.Length);
	}

	private float AudioLength()
	{
		int position = Microphone.GetPosition(_deviceName);
		if (position > 0)
		{
			float[] array = new float[au.clip.samples * au.clip.channels];
			au.clip.GetData(array, 0);
			float[] array2 = new float[position * au.clip.channels];
			for (int i = 0; i < array2.Length; i++)
			{
				array2[i] = array[i];
			}
			au.clip = AudioClip.Create(au.clip.name, position, au.clip.channels, au.clip.frequency, stream: false);
			au.clip.SetData(array2, 0);
		}
		log("len:" + au.clip.length + ",");
		return au.clip.length;
	}

	private MemoryStream CreateEmpty()
	{
		MemoryStream memoryStream = new MemoryStream();
		byte value = 0;
		for (int i = 0; i < 44; i++)
		{
			memoryStream.WriteByte(value);
		}
		return memoryStream;
	}

	private void WriteHeader(MemoryStream stream, AudioClip clip)
	{
		int frequency = clip.frequency;
		int channels = clip.channels;
		int samples = clip.samples;
		stream.Seek(0L, SeekOrigin.Begin);
		byte[] bytes = Encoding.UTF8.GetBytes("RIFF");
		stream.Write(bytes, 0, 4);
		byte[] bytes2 = BitConverter.GetBytes(stream.Length - 8);
		stream.Write(bytes2, 0, 4);
		byte[] bytes3 = Encoding.UTF8.GetBytes("WAVE");
		stream.Write(bytes3, 0, 4);
		byte[] bytes4 = Encoding.UTF8.GetBytes("fmt ");
		stream.Write(bytes4, 0, 4);
		byte[] bytes5 = BitConverter.GetBytes(16);
		stream.Write(bytes5, 0, 4);
		byte[] bytes6 = BitConverter.GetBytes((ushort)1);
		stream.Write(bytes6, 0, 2);
		byte[] bytes7 = BitConverter.GetBytes(channels);
		stream.Write(bytes7, 0, 2);
		byte[] bytes8 = BitConverter.GetBytes(frequency);
		stream.Write(bytes8, 0, 4);
		byte[] bytes9 = BitConverter.GetBytes(frequency * channels * 2);
		stream.Write(bytes9, 0, 4);
		ushort value = (ushort)(channels * 2);
		stream.Write(BitConverter.GetBytes(value), 0, 2);
		byte[] bytes10 = BitConverter.GetBytes((ushort)16);
		stream.Write(bytes10, 0, 2);
		byte[] bytes11 = Encoding.UTF8.GetBytes("data");
		stream.Write(bytes11, 0, 4);
		byte[] bytes12 = BitConverter.GetBytes(samples * channels * 2);
		stream.Write(bytes12, 0, 4);
	}

	public byte[] GetClipData()
	{
		if (au.clip == null)
		{
			log("缺少音频资源！");
			return null;
		}
		float[] array = new float[au.clip.samples];
		au.clip.GetData(array, 0);
		byte[] array2 = new byte[array.Length * 2];
		int num = 32767;
		for (int i = 0; i < array.Length; i++)
		{
			byte[] bytes = BitConverter.GetBytes((short)(array[i] * (float)num));
			array2[i * 2] = bytes[0];
			array2[i * 2 + 1] = bytes[1];
		}
		if (array2 == null || array2.Length == 0)
		{
			log("获取音频数据失败！");
			return null;
		}
		return array2;
	}
}
public class DecalDestroyer : MonoBehaviour
{
	public float lifeTime = 5f;

	private IEnumerator Start()
	{
		yield return new WaitForSeconds(lifeTime);
		UnityEngine.Object.Destroy(base.gameObject);
	}
}
public class ExtinguishableFire : MonoBehaviour
{
	public ParticleSystem fireParticleSystem;

	public ParticleSystem smokeParticleSystem;

	protected bool m_isExtinguished;

	private const float m_FireStartingTime = 2f;

	private void Start()
	{
		m_isExtinguished = true;
		smokeParticleSystem.Stop();
		fireParticleSystem.Stop();
		StartCoroutine(StartingFire());
	}

	public void Extinguish()
	{
		if (!m_isExtinguished)
		{
			m_isExtinguished = true;
			StartCoroutine(Extinguishing());
		}
	}

	private IEnumerator Extinguishing()
	{
		fireParticleSystem.Stop();
		smokeParticleSystem.time = 0f;
		smokeParticleSystem.Play();
		for (float elapsedTime = 0f; elapsedTime < 2f; elapsedTime += Time.deltaTime)
		{
			float num = Mathf.Max(0f, 1f - elapsedTime / 2f);
			fireParticleSystem.transform.localScale = Vector3.one * num;
			yield return null;
		}
		yield return new WaitForSeconds(2f);
		smokeParticleSystem.Stop();
		fireParticleSystem.transform.localScale = Vector3.one;
		yield return new WaitForSeconds(4f);
		StartCoroutine(StartingFire());
	}

	private IEnumerator StartingFire()
	{
		smokeParticleSystem.Stop();
		fireParticleSystem.time = 0f;
		fireParticleSystem.Play();
		for (float elapsedTime = 0f; elapsedTime < 2f; elapsedTime += Time.deltaTime)
		{
			float num = Mathf.Min(1f, elapsedTime / 2f);
			fireParticleSystem.transform.localScale = Vector3.one * num;
			yield return null;
		}
		fireParticleSystem.transform.localScale = Vector3.one;
		m_isExtinguished = false;
	}
}
public class GunAim : MonoBehaviour
{
	public int borderLeft;

	public int borderRight;

	public int borderTop;

	public int borderBottom;

	private Camera parentCamera;

	private bool isOutOfBounds;

	private void Start()
	{
		parentCamera = GetComponentInParent<Camera>();
	}

	private void Update()
	{
		float x = Input.mousePosition.x;
		float y = Input.mousePosition.y;
		if (x <= (float)borderLeft || x >= (float)(Screen.width - borderRight) || y <= (float)borderBottom || y >= (float)(Screen.height - borderTop))
		{
			isOutOfBounds = true;
		}
		else
		{
			isOutOfBounds = false;
		}
		if (!isOutOfBounds)
		{
			base.transform.LookAt(parentCamera.ScreenToWorldPoint(new Vector3(x, y, 5f)));
		}
	}

	public bool GetIsOutOfBounds()
	{
		return isOutOfBounds;
	}
}
public class GunShoot : MonoBehaviour
{
	public float fireRate = 0.25f;

	public float weaponRange = 20f;

	public Transform gunEnd;

	public ParticleSystem muzzleFlash;

	public ParticleSystem cartridgeEjection;

	public GameObject metalHitEffect;

	public GameObject sandHitEffect;

	public GameObject stoneHitEffect;

	public GameObject waterLeakEffect;

	public GameObject waterLeakExtinguishEffect;

	public GameObject[] fleshHitEffects;

	public GameObject woodHitEffect;

	private float nextFire;

	private Animator anim;

	private GunAim gunAim;

	private void Start()
	{
		anim = GetComponent<Animator>();
		gunAim = GetComponentInParent<GunAim>();
	}

	private void Update()
	{
		if (Input.GetButtonDown("Fire1") && Time.time > nextFire && !gunAim.GetIsOutOfBounds())
		{
			nextFire = Time.time + fireRate;
			muzzleFlash.Play();
			cartridgeEjection.Play();
			anim.SetTrigger("Fire");
			if (Physics.Raycast(gunEnd.position, gunEnd.forward, out var hitInfo, weaponRange))
			{
				HandleHit(hitInfo);
			}
		}
	}

	private void HandleHit(RaycastHit hit)
	{
		if (hit.collider.sharedMaterial != null)
		{
			switch (hit.collider.sharedMaterial.name)
			{
			case "Metal":
				SpawnDecal(hit, metalHitEffect);
				break;
			case "Sand":
				SpawnDecal(hit, sandHitEffect);
				break;
			case "Stone":
				SpawnDecal(hit, stoneHitEffect);
				break;
			case "WaterFilled":
				SpawnDecal(hit, waterLeakEffect);
				SpawnDecal(hit, metalHitEffect);
				break;
			case "Wood":
				SpawnDecal(hit, woodHitEffect);
				break;
			case "Meat":
				SpawnDecal(hit, fleshHitEffects[UnityEngine.Random.Range(0, fleshHitEffects.Length)]);
				break;
			case "Character":
				SpawnDecal(hit, fleshHitEffects[UnityEngine.Random.Range(0, fleshHitEffects.Length)]);
				break;
			case "WaterFilledExtinguish":
				SpawnDecal(hit, waterLeakExtinguishEffect);
				SpawnDecal(hit, metalHitEffect);
				break;
			}
		}
	}

	private void SpawnDecal(RaycastHit hit, GameObject prefab)
	{
		UnityEngine.Object.Instantiate(prefab, hit.point, Quaternion.LookRotation(hit.normal)).transform.SetParent(hit.collider.transform);
	}
}
public class ParticleCollision : MonoBehaviour
{
	private List<ParticleCollisionEvent> m_CollisionEvents = new List<ParticleCollisionEvent>();

	private ParticleSystem m_ParticleSystem;

	private void Start()
	{
		m_ParticleSystem = GetComponent<ParticleSystem>();
	}

	private void OnParticleCollision(GameObject other)
	{
		int collisionEvents = m_ParticleSystem.GetCollisionEvents(other, m_CollisionEvents);
		for (int i = 0; i < collisionEvents; i++)
		{
			ExtinguishableFire component = m_CollisionEvents[i].colliderComponent.GetComponent<ExtinguishableFire>();
			if (component != null)
			{
				component.Extinguish();
			}
		}
	}
}
[Serializable]
public class ParticleExamples
{
	public string title;

	[TextArea]
	public string description;

	public bool isWeaponEffect;

	public GameObject particleSystemGO;

	public Vector3 particlePosition;

	public Vector3 particleRotation;
}
public class ParticleMenu : MonoBehaviour
{
	public ParticleExamples[] particleSystems;

	public GameObject gunGameObject;

	private int currentIndex;

	private GameObject currentGO;

	public Transform spawnLocation;

	public Text title;

	public Text description;

	public Text navigationDetails;

	private void Start()
	{
		Navigate(0);
		currentIndex = 0;
	}

	public void Navigate(int i)
	{
		currentIndex = (particleSystems.Length + currentIndex + i) % particleSystems.Length;
		if (currentGO != null)
		{
			UnityEngine.Object.Destroy(currentGO);
		}
		currentGO = UnityEngine.Object.Instantiate(particleSystems[currentIndex].particleSystemGO, spawnLocation.position + particleSystems[currentIndex].particlePosition, Quaternion.Euler(particleSystems[currentIndex].particleRotation));
		gunGameObject.SetActive(particleSystems[currentIndex].isWeaponEffect);
		title.text = particleSystems[currentIndex].title;
		description.text = particleSystems[currentIndex].description;
		navigationDetails.text = currentIndex + 1 + " out of " + particleSystems.Length.ToString();
	}
}
public class FowTest : MonoBehaviour
{
	public int[,] mapData;

	public FOWMap map;

	public int mapSize = 20;

	public int[] playerPos;

	public Texture tex => map.FogTexture;

	private void Start()
	{
		mapData = new int[mapSize, mapSize];
		for (int i = 0; i < mapSize; i++)
		{
			for (int j = 0; j < mapSize; j++)
			{
				mapData[i, j] = ((UnityEngine.Random.Range(0, 100) < 2) ? 1 : 0);
			}
		}
		for (int k = 0; k < 2; k++)
		{
			for (int l = 0; l < mapSize; l++)
			{
				for (int m = 0; m < mapSize; m++)
				{
					if (mapData[l, m] == 0)
					{
						if (FOWTool.InMap(l + 1, m, mapSize, mapSize) && mapData[l + 1, m] == 1)
						{
							mapData[l, m] = ((UnityEngine.Random.Range(0, 100) < 60) ? 1 : 0);
						}
						else if (FOWTool.InMap(l, m + 1, mapSize, mapSize) && mapData[l, m + 1] == 1)
						{
							mapData[l, m] = ((UnityEngine.Random.Range(0, 100) < 60) ? 1 : 0);
						}
					}
				}
			}
		}
		map = new FOWMap();
		map.InitMap(mapData, Shader.Find("ImageEffect/AverageBlur"));
		playerPos = new int[2]
		{
			mapSize / 2,
			mapSize / 2
		};
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.W))
		{
			playerPos[1]++;
		}
		if (Input.GetKeyDown(KeyCode.S))
		{
			playerPos[1]--;
		}
		if (Input.GetKeyDown(KeyCode.A))
		{
			playerPos[0]--;
		}
		if (Input.GetKeyDown(KeyCode.D))
		{
			playerPos[0]++;
		}
		map.FreshFog();
		map.ComputeFog(playerPos[0], playerPos[1], 10f);
	}

	private void OnDrawGizmos()
	{
		if (map == null)
		{
			return;
		}
		for (int i = 0; i < mapSize; i++)
		{
			for (int j = 0; j < mapSize; j++)
			{
				Gizmos.color = ((map.GetTile(i, j).type == 0) ? new Color(1f, 0.5f, 1f, 0.1f) : Color.red);
				Gizmos.DrawCube(new Vector3(i, 0f, j), Vector3.one * 0.8f);
				if (map[i, j].r != byte.MaxValue)
				{
					if (map[i, j].b == byte.MaxValue)
					{
						Gizmos.color = new Color(0f, 0f, 0f, 0.5f);
						Gizmos.DrawSphere(new Vector3(i, 0f, j), 0.7f);
					}
					else
					{
						Gizmos.color = Color.black;
						Gizmos.DrawSphere(new Vector3(i, 0f, j), 0.7f);
					}
				}
			}
		}
		Gizmos.color = Color.green;
		Gizmos.DrawSphere(new Vector3(playerPos[0], 0f, playerPos[1]), 0.5f);
	}
}
public class PlayerCtr : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
		base.transform.position += new Vector3(Input.GetAxis("Horizontal"), 0f, Input.GetAxis("Vertical")) * Time.deltaTime;
	}
}
public class RandomMap : MonoBehaviour
{
	public GameObject redCube;

	public int MapSize = 20;

	private void Start()
	{
		Ramdom();
	}

	public void Ramdom()
	{
		int[,] array = new int[MapSize, MapSize];
		for (int i = 0; i < MapSize; i++)
		{
			for (int j = 0; j < MapSize; j++)
			{
				array[i, j] = ((UnityEngine.Random.Range(0, 100) < 2) ? 1 : 0);
			}
		}
		for (int k = 0; k < 2; k++)
		{
			for (int l = 0; l < MapSize; l++)
			{
				for (int m = 0; m < MapSize; m++)
				{
					if (array[l, m] == 0)
					{
						if (FOWTool.InMap(l + 1, m, MapSize, MapSize) && array[l + 1, m] == 1)
						{
							array[l, m] = ((UnityEngine.Random.Range(0, 100) < 60) ? 1 : 0);
						}
						else if (FOWTool.InMap(l, m + 1, MapSize, MapSize) && array[l, m + 1] == 1)
						{
							array[l, m] = ((UnityEngine.Random.Range(0, 100) < 60) ? 1 : 0);
						}
					}
				}
			}
		}
		for (int n = 0; n < MapSize; n++)
		{
			for (int num = 0; num < MapSize; num++)
			{
				if (array[n, num] == 1)
				{
					UnityEngine.Object.Instantiate(redCube, new Vector3(n - 10, 0f, num - 10) + Vector3.one / 2f, Quaternion.identity);
				}
			}
		}
	}

	private void Update()
	{
	}
}
public class Introduction : MonoBehaviour
{
	private AudioSource audioSource;

	private WordToVoice_adhd wordToVoice;

	private Text text;

	private void Start()
	{
		audioSource = GetComponent<AudioSource>();
		audioSource.Play();
	}

	private void Update()
	{
	}
}
public static class CameraHelper
{
	public static Vector3 cameraLocalPos = Vector3.zero;
}
public class DoubleClickController : MonoBehaviour
{
	public bool isResetUnitySDKSensor = true;

	private float t;

	private float t1;

	private void Start()
	{
		Pvr_UnitySDKSensor.Instance.ResetUnitySDKSensor();
	}

	private void Update()
	{
		if (Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.APP))
		{
			t1 = Time.realtimeSinceStartup;
			if (t1 - t < 0.5f)
			{
				Application.Quit();
			}
			t = t1;
		}
		if (Controller.UPvr_GetKeyDown(0, Pvr_KeyCode.TRIGGER))
		{
			Controller.UPvr_SetMainHandNess(0);
		}
		if (Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.TRIGGER))
		{
			Controller.UPvr_SetMainHandNess(1);
		}
		if (Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.Right) && isResetUnitySDKSensor)
		{
			Pvr_UnitySDKSensor.Instance.ResetUnitySDKSensor();
		}
	}

	private void OnApplicationFocus(bool focus)
	{
		if (focus)
		{
			Pvr_UnitySDKSensor.Instance.ResetUnitySDKSensor();
		}
		else
		{
			Pvr_UnitySDKSensor.Instance.ResetUnitySDKSensor();
		}
	}
}
public class J_AndroidPermissionRequest
{
	public enum PERMISSION
	{
		unkonwnError = -10,
		GRANTED = 0,
		DENIED_NotAgain = -1,
		TryRequest = 1
	}

	private static AndroidJavaClass UnityPlayer;

	private static AndroidJavaObject currentActivity;

	private static AndroidJavaClass Toast;

	private static AndroidJavaObject context;

	public static PERMISSION J_RequestPermission(string permission)
	{
		try
		{
			return new AndroidJavaObject("com.Jason.UnityAndroidHelper.J_PermissionRequest").Call<int>("requestRunTimePermission", new object[1] { permission }) switch
			{
				0 => PERMISSION.GRANTED, 
				-1 => PERMISSION.DENIED_NotAgain, 
				1 => PERMISSION.TryRequest, 
				_ => PERMISSION.unkonwnError, 
			};
		}
		catch (Exception ex)
		{
			toastText(ex.Message);
			return PERMISSION.unkonwnError;
		}
	}

	public static void J_OpenAppSeeting()
	{
		try
		{
			new AndroidJavaObject("com.Jason.UnityAndroidHelper.J_PermissionRequest").Call("goToAppSetting");
		}
		catch (Exception ex)
		{
			toastText(ex.Message);
		}
	}

	public static void toastText(string sss)
	{
		UnityPlayer = new AndroidJavaClass("com.unity3d.player.UnityPlayer");
		currentActivity = UnityPlayer.GetStatic<AndroidJavaObject>("currentActivity");
		Toast = new AndroidJavaClass("android.widget.Toast");
		context = currentActivity.Call<AndroidJavaObject>("getApplicationContext", Array.Empty<object>());
		currentActivity.Call("runOnUiThread", (AndroidJavaRunnable)delegate
		{
			AndroidJavaObject androidJavaObject = new AndroidJavaObject("java.lang.String", sss);
			Toast.CallStatic<AndroidJavaObject>("makeText", new object[3]
			{
				context,
				androidJavaObject,
				Toast.GetStatic<int>("LENGTH_SHORT")
			}).Call("show");
		});
	}
}
public class J_CodeSecurity_phpAES
{
	private static string password = "IcgEp8JANMlfawfRB46djoy4CmjbFSpa";

	private static string ivStr = "Guavavr3295431aa";

	public static string EncryptString(string plainText)
	{
		byte[] bytes = Encoding.UTF8.GetBytes(ivStr);
		byte[] bytes2 = Encoding.UTF8.GetBytes(password);
		Aes aes = Aes.Create();
		aes.Mode = CipherMode.CBC;
		byte[] array = new byte[32];
		Array.Copy(bytes2, 0, array, 0, 32);
		aes.Key = array;
		aes.IV = bytes;
		aes.Padding = PaddingMode.PKCS7;
		ICryptoTransform cryptoTransform = aes.CreateEncryptor();
		byte[] bytes3 = Encoding.UTF8.GetBytes(plainText);
		byte[] array2 = cryptoTransform.TransformFinalBlock(bytes3, 0, bytes3.Length);
		return Convert.ToBase64String(array2, 0, array2.Length);
	}

	public static string DecryptString(string toD)
	{
		try
		{
			byte[] bytes = Encoding.UTF8.GetBytes(ivStr);
			byte[] bytes2 = Encoding.UTF8.GetBytes(password);
			Aes aes = Aes.Create();
			aes.Mode = CipherMode.CBC;
			byte[] array = new byte[32];
			Array.Copy(bytes2, 0, array, 0, 32);
			aes.Key = array;
			aes.IV = bytes;
			aes.Padding = PaddingMode.PKCS7;
			ICryptoTransform cryptoTransform = aes.CreateDecryptor();
			byte[] array2 = Convert.FromBase64String(toD);
			byte[] bytes3 = cryptoTransform.TransformFinalBlock(array2, 0, array2.Length);
			return Encoding.UTF8.GetString(bytes3);
		}
		catch (Exception ex)
		{
			UnityEngine.Debug.LogError(ex.Message);
			return null;
		}
	}
}
public static class LoadManager
{
	public static bool IsFirstEnterApp = true;

	public static bool IsLocalOperate = true;

	public static UserData userData;

	public static CourseDetail courseDetail;

	public static CourseData courseData;

	public static bool isLastCourse = false;

	public static int LevelID = 0;

	public static int StrengthID = 0;

	public static int Duration = 1800;

	public static int MaxLevelID = 3;

	public static DeviceCheck device;

	private static string deviceMac;

	public static string ELECTRIC_QUANTITY;

	public static string deviceCode;

	private static float fDownloadDelaySecond = 0.2f;

	private static float fDownloadSpeedTimerDelay = 1f;

	public static string deviceUniqueIdentifier
	{
		get
		{
			if (string.IsNullOrEmpty(deviceMac))
			{
				return "guavavr";
			}
			return deviceMac;
		}
		set
		{
			deviceMac = value;
		}
	}

	public static CourseDetail.Data course
	{
		get
		{
			if (courseDetail == null)
			{
				return null;
			}
			return courseDetail.data;
		}
	}

	public static void SubmitLevelRecord(int levelid, int strengthid, int duration, int score, string game_data)
	{
		if (!IsLocalOperate)
		{
			string url = UrlUtils.baseUrl_adhd + UrlUtils.levelChange + course.id;
			WWWForm wWWForm = new WWWForm();
			wWWForm.AddField("already_play_time", duration);
			wWWForm.AddField("point", score);
			wWWForm.AddField("level", levelid);
			wWWForm.AddField("strength", strengthid);
			wWWForm.AddField("game_data", game_data);
			UnityWebRequestHelper.Instance.Post(url, wWWForm, delegate
			{
			}, isToken: true);
		}
	}

	public static void SubmitEndRecord(bool isComplete, bool isLogout, int duration, int score, string game_data)
	{
		if (!IsLocalOperate)
		{
			_ = UrlUtils.baseUrl_adhd + UrlUtils.singleEnd + course.id;
			WWWForm wWWForm = new WWWForm();
			wWWForm.AddField("already_play_time", duration);
			wWWForm.AddField("point", score);
			wWWForm.AddField("game_data", game_data);
			wWWForm.AddField("end", isComplete ? 1 : 0);
		}
	}

	public static void UserLogout(Action action = null)
	{
		string url = UrlUtils.baseUrl_adhd + UrlUtils.userLogout;
		UnityWebRequestHelper.Instance.Get(url, delegate
		{
			userData = null;
			courseDetail = null;
			action?.Invoke();
		}, isToken: true);
	}

	public static string GetTimeStamp()
	{
		return Convert.ToInt64((DateTime.Now - new DateTime(1970, 1, 1, 0, 0, 0, 0)).TotalSeconds).ToString();
	}

	public static string TimeConversion(int time)
	{
		int num = time % 3600 / 60;
		int num2 = time % 3600 % 60;
		return $"{num:00}:{num2:00}";
	}

	public static byte[] ReadFileByte(string path)
	{
		if (File.Exists(UrlUtils.persistentDataPath + path))
		{
			return File.ReadAllBytes(UrlUtils.persistentDataPath + path);
		}
		return null;
	}

	public static string JsonRead(string name)
	{
		string text = "";
		text = Resources.Load<TextAsset>("Jsons/" + name).text;
		if (string.IsNullOrEmpty(text))
		{
			return null;
		}
		return text;
	}

	public static string CsvRead(string name)
	{
		string text = "";
		text = Resources.Load<TextAsset>("CSV/" + name).text;
		if (string.IsNullOrEmpty(text))
		{
			return null;
		}
		return text;
	}

	public static string ReadJson(string path)
	{
		if (File.Exists(UrlUtils.persistentDataPath + path))
		{
			StreamReader streamReader = new StreamReader(UrlUtils.persistentDataPath + path);
			string result = streamReader.ReadToEnd();
			streamReader.Close();
			return result;
		}
		return string.Empty;
	}

	public static void SaveJson(string path, string json)
	{
		if (!File.Exists(UrlUtils.persistentDataPath + path))
		{
			FileStream fileStream = File.Create(UrlUtils.persistentDataPath + path);
			fileStream.Close();
			fileStream.Dispose();
		}
		File.WriteAllText(UrlUtils.persistentDataPath + path, json);
	}

	public static void LoadAudios(string path, Action<AudioClip, byte[]> action)
	{
		Singleton<MiniMonoBehaviour>.Instance.StartCoroutine(LoadAudio(path, action));
	}

	public static IEnumerator LoadAudio(string path, Action<AudioClip, byte[]> action)
	{
		UnityWebRequest webRequest = UnityWebRequestMultimedia.GetAudioClip(path, AudioType.MPEG);
		yield return webRequest.SendWebRequest();
		if (!webRequest.isNetworkError)
		{
			AudioClip content = DownloadHandlerAudioClip.GetContent(webRequest);
			action?.Invoke(content, webRequest.downloadHandler.data);
		}
		else
		{
			J_AndroidPermissionRequest.toastText("音频下载失败: " + webRequest.error);
		}
	}

	public static void LoadTextures(string path, Action<Texture, byte[]> action)
	{
		Singleton<MiniMonoBehaviour>.Instance.StartCoroutine(LoadTexture(path, action));
	}

	private static IEnumerator LoadTexture(string path, Action<Texture, byte[]> action)
	{
		UnityWebRequest webRequest = UnityWebRequestTexture.GetTexture(path);
		yield return webRequest.SendWebRequest();
		if (!webRequest.isNetworkError)
		{
			Texture texture = ((DownloadHandlerTexture)webRequest.downloadHandler).texture;
			action?.Invoke(texture, webRequest.downloadHandler.data);
		}
		else
		{
			J_AndroidPermissionRequest.toastText("图片下载失败: " + webRequest.error);
		}
	}

	public static IEnumerator LoadFile(string path, Action<byte[]> action, Action<float, float> progress = null)
	{
		UnityWebRequest webRequest = UnityWebRequest.Get(path);
		webRequest.SendWebRequest();
		int ilenghth = 0;
		float _ftimer = 0f;
		float fdownloadspeed = 0f;
		while (!webRequest.isDone)
		{
			yield return new WaitForFixedUpdate();
			float num;
			_ftimer = (num = _ftimer + fDownloadDelaySecond);
			if (num > fDownloadSpeedTimerDelay)
			{
				_ftimer = 0f;
				fdownloadspeed = (float)(webRequest.downloadHandler.data.Length - ilenghth) * 1f / fDownloadSpeedTimerDelay / 1024f;
				ilenghth = webRequest.downloadHandler.data.Length;
			}
			progress?.Invoke(webRequest.downloadProgress, fdownloadspeed);
		}
		if (string.IsNullOrEmpty(webRequest.error))
		{
			if (webRequest.isDone)
			{
				action?.Invoke(webRequest.downloadHandler.data);
			}
		}
		else
		{
			action?.Invoke(null);
			J_AndroidPermissionRequest.toastText("文件下载失败: " + webRequest.error);
		}
	}

	public static void CreateFile(string path, string name, byte[] assetbundle)
	{
		CheckPath(path);
		FileStream fileStream = File.Create(path + "/" + name);
		fileStream.Write(assetbundle, 0, assetbundle.Length);
		fileStream.Close();
		fileStream.Dispose();
	}

	public static void DestroyChild(Transform parent)
	{
		foreach (Transform item in parent)
		{
			UnityEngine.Object.Destroy(item.gameObject);
		}
		Resources.UnloadUnusedAssets();
	}

	private static string GetSavePath(string path)
	{
		string[] array = path.Split('/');
		string text = string.Empty;
		if (array.Length == 1)
		{
			return UrlUtils.persistentDataPath;
		}
		for (int i = 0; i < array.Length - 1; i++)
		{
			text = ((i != array.Length - 2) ? (text + array[i] + "/") : (text + array[i]));
		}
		CheckPath(UrlUtils.persistentDataPath + text);
		return UrlUtils.persistentDataPath + text;
	}

	public static void CheckPath(string path)
	{
		if (!Directory.Exists(path))
		{
			Directory.CreateDirectory(path);
		}
	}

	public static string GetFileName(string path)
	{
		string[] array = path.Split('/');
		if (array.Length == 1)
		{
			return path;
		}
		return array[^1];
	}

	public static void DeleteFile(string path)
	{
		if (File.Exists(UrlUtils.persistentDataPath + path))
		{
			File.Delete(UrlUtils.persistentDataPath + path);
		}
	}

	public static void DeleteDir(string file)
	{
		try
		{
			new DirectoryInfo(file).Attributes = (FileAttributes)0;
			File.SetAttributes(file, FileAttributes.Normal);
			if (!Directory.Exists(file))
			{
				return;
			}
			string[] fileSystemEntries = Directory.GetFileSystemEntries(file);
			foreach (string text in fileSystemEntries)
			{
				if (File.Exists(text))
				{
					File.Delete(text);
					Console.WriteLine(text);
				}
				else
				{
					DeleteDir(text);
				}
			}
			Directory.Delete(file);
		}
		catch (Exception)
		{
		}
	}

	public static string GetDeviceCode()
	{
		return "__deviceUUID:" + GetDeviceUUID() + "__graphicsDeviceName:" + SystemInfo.graphicsDeviceName + "__graphicsDeviceVendor:" + SystemInfo.graphicsDeviceVendor + "__processorType:" + SystemInfo.processorType;
	}

	private static string GetDeviceUUID()
	{
		return new AndroidJavaClass("android.os.Build").CallStatic<string>("getString", new object[1] { "ro.serialno" });
	}
}
public static class MyMath
{
	public static Vector3 GetBetweenPoint(Vector3 start, Vector3 end, float percent = 0.5f)
	{
		Vector3 normalized = (end - start).normalized;
		float num = Vector3.Distance(start, end);
		return normalized * (num * percent) + start;
	}

	public static Vector3 GetBetweenPointByDis(Vector3 start, Vector3 end, float distance)
	{
		return (end - start).normalized * distance + start;
	}

	public static int RandomRange(int min, int max, int exclude)
	{
		UnityEngine.Random.InitState(Guid.NewGuid().GetHashCode());
		int num = UnityEngine.Random.Range(min, max);
		if (num == exclude)
		{
			return RandomRange(min, max, exclude);
		}
		return num;
	}

	public static float RandomRange(float min, float max, float exclude, float differ)
	{
		UnityEngine.Random.InitState(Guid.NewGuid().GetHashCode());
		float num = UnityEngine.Random.Range(min, max);
		if (Mathf.Abs(num - exclude) > differ)
		{
			return num;
		}
		return RandomRange(min, max, exclude, differ);
	}

	public static string Number_char(int Length, bool Sleep)
	{
		if (Sleep)
		{
			Thread.Sleep(3);
		}
		char[] array = new char[10] { '1', '2', '3', '4', '5', '6', '7', '8', '9', '0' };
		string text = "";
		int maxValue = array.Length;
		System.Random random = new System.Random((int)(~DateTime.Now.Ticks));
		for (int i = 0; i < Length; i++)
		{
			int num = random.Next(0, maxValue);
			text += array[num];
		}
		return text;
	}

	public static string Letter_char(int Length, bool Sleep)
	{
		if (Sleep)
		{
			Thread.Sleep(3);
		}
		char[] array = new char[26]
		{
			'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J',
			'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T',
			'U', 'V', 'W', 'X', 'Y', 'Z'
		};
		string text = "";
		int maxValue = array.Length;
		System.Random random = new System.Random((int)(~DateTime.Now.Ticks));
		for (int i = 0; i < Length; i++)
		{
			int num = random.Next(0, maxValue);
			text += array[num];
		}
		return text;
	}

	public static string Pattern_char(int Length, bool Sleep)
	{
		if (Sleep)
		{
			Thread.Sleep(3);
		}
		char[] array = new char[10] { '★', '✿', '◀', '☎', '●', '♣', '♦', '♬', '■', '♥' };
		string text = "";
		int maxValue = array.Length;
		System.Random random = new System.Random((int)(~DateTime.Now.Ticks));
		for (int i = 0; i < Length; i++)
		{
			int num = random.Next(0, maxValue);
			text += array[num];
		}
		return text;
	}

	public static string Chinese_char(int Length, bool Sleep)
	{
		if (Sleep)
		{
			Thread.Sleep(3);
		}
		char[] array = new char[10] { '你', '在', '用', '关', '直', '成', '数', '要', '总', '玩' };
		string text = "";
		int maxValue = array.Length;
		System.Random random = new System.Random((int)(~DateTime.Now.Ticks));
		for (int i = 0; i < Length; i++)
		{
			int num = random.Next(0, maxValue);
			text += array[num];
		}
		return text;
	}

	public static string Random_char(List<char> Pattern, int Length, bool Sleep)
	{
		if (Sleep)
		{
			Thread.Sleep(3);
		}
		string text = "";
		int count = Pattern.Count;
		System.Random random = new System.Random((int)(~DateTime.Now.Ticks));
		for (int i = 0; i < Length; i++)
		{
			int index = random.Next(0, count);
			text += Pattern[index];
		}
		return text;
	}

	public static float DotToAngle(Vector3 _from, Vector3 _to, Vector3 _up)
	{
		float num = Vector3.Angle(_from, _to);
		Vector3 lhs = Vector3.Cross(_from, _to);
		return num * Mathf.Sign(Vector3.Dot(lhs, _up));
	}

	public static int GetAverage(List<int> list)
	{
		int num = 0;
		for (int i = 0; i < list.Count; i++)
		{
			num += list[i];
		}
		return num / list.Count;
	}

	public static float GetAverage(List<float> list)
	{
		float num = 0f;
		for (int i = 0; i < list.Count; i++)
		{
			num += list[i];
		}
		return num / (float)list.Count;
	}

	public static int RandomGetDivisible(int divisor)
	{
		int num = UnityEngine.Random.Range(1, divisor + 1);
		if (divisor % num != 0)
		{
			return RandomGetDivisible(divisor);
		}
		return num;
	}
}
public static class ScenesHelper
{
	public static string MetaverseSceneName = "Yuanyuzhou";

	public static string WeiAiZhiCenterScene = "唯爱智-大厅";

	public static string CatchFishScene = "catchgame";

	public static string ElectricRingScene = "electricring";

	public static string ElectricClubScene = "electricclub";

	public static string LetterShotHandScene = "lettershothand";

	public static string FruitsScene = "fruitcut";

	public static string PickUpBallScene = "pickupball";

	public static string BombDisposalScene = "bombdisposal";

	public static string WordFormationScene = "wordformation";

	public static string AncientPoetryScene = "ancientpoetry";

	public static string PerfectFillScene = "perfectfill";

	public static string EyeTrainScene = "eyetrain";

	public static string Sports_GymCenterScene = "sports_gymcenter";

	public static string Sports_BadmitonScene = "sports_badminton";

	public static string Sports_GolfScene = "sports_golf";

	public static string Sports_HitGopherScene = "sports_hitgopher";

	public static string Sports_ShotScene = "sports_shot";

	public static string Travel_EntranceScene = "Travel_Entrance";

	public static string Travel__RoamScene = "Travel_Roam";

	public static string WeiAiXinCenterScene = "weiaixin-center";

	public static string YireeBedCenterScene = "谊瑞智能床";

	public static string ChineseBrushScene = "chinesebrush";

	public static void LoadScene(string sceneName)
	{
		ClearSceneData.LoadLevel(sceneName);
	}

	public static void J_QuitApp()
	{
		Application.Quit();
	}
}
public static class SimilarWord_Modify
{
	public class TypeWords
	{
		public int code;

		public string msg;

		public List<string> data;
	}

	public class TypeWord
	{
		public string name;

		public int od;
	}

	public static List<TypeWord> animalLibrary;

	private static Dictionary<string, string> XSY = new Dictionary<string, string>
	{
		{ "z", "zh" },
		{ "c", "ch" },
		{ "s", "sh" },
		{ "l", "n" },
		{ "f", "h" },
		{ "r", "l" },
		{ "an", "ang" },
		{ "en", "eng" },
		{ "in", "ing" },
		{ "ian", "iang" },
		{ "uan", "uang" }
	};

	public static void Init(TypeWords library)
	{
		animalLibrary = new List<TypeWord>();
		foreach (string datum in library.data)
		{
			TypeWord typeWord = new TypeWord();
			typeWord.name = datum;
			animalLibrary.Add(typeWord);
		}
	}

	public static List<string> IsMatch(this string Say, List<string> Anser, bool isContains = true)
	{
		List<string> list = new List<string>();
		foreach (string item in Anser)
		{
			if (Say.IsMatchs(item, isContains))
			{
				list.Add(item);
			}
		}
		return list;
	}

	public static bool IsMatchs(this string Say, string Anser, bool isContains = true)
	{
		if (string.IsNullOrEmpty(Anser) || string.IsNullOrEmpty(Say))
		{
			return false;
		}
		if (Say.Contains(Anser) && isContains)
		{
			return true;
		}
		string text = Say.PY_Modify();
		string text2 = Anser.PY_Modify();
		foreach (KeyValuePair<string, string> item in XSY)
		{
			if (text.Replace(item.Key, item.Value) == text2)
			{
				return true;
			}
			if (text.Replace(item.Value, item.Key) == text2)
			{
				return true;
			}
		}
		return text == text2;
	}

	public static List<TypeWord> IsMatch(this string Say, bool isContains = true)
	{
		List<TypeWord> list = new List<TypeWord>();
		if (string.IsNullOrEmpty(Say))
		{
			return list;
		}
		string text = Say.PY_Modify();
		foreach (TypeWord item in animalLibrary)
		{
			if (Say.IsMatchs(item.name, isContains))
			{
				item.od = text.IndexOf(item.name.PY_Modify());
				list.Add(item);
			}
		}
		List<TypeWord> r2 = list.OrderBy((TypeWord ca) => ca.od).ToList();
		int i;
		for (i = r2.Count - 1; i > -1; i--)
		{
			if (r2.Any((TypeWord ca) => ca.name != r2[i].name && ca.name.Contains(r2[i].name)))
			{
				r2.RemoveAt(i);
			}
		}
		return r2;
	}

	public static string PY_Modify(this string s, bool replaceSpace = true)
	{
		if (string.IsNullOrEmpty(s))
		{
			return "";
		}
		if (replaceSpace)
		{
			return Pinyin.GetPinyin(s).Replace(" ", "").Trim()
				.ToLower();
		}
		return Pinyin.GetPinyin(s).Trim().ToLower();
	}
}
public class Singleton<T> : MonoBehaviour where T : UnityEngine.Component
{
	protected static T instance;

	public static T Instance
	{
		get
		{
			if (instance == null)
			{
				instance = new GameObject().AddComponent<T>();
				instance.name = typeof(T).ToString();
			}
			return instance;
		}
	}
}
public class MiniMonoBehaviour : MonoBehaviour
{
}
public class ToBServiceHelper
{
	public static AndroidJavaObject javaPlayer;

	public static bool isBatteryed;

	public static void UPvr_ControlAPPManger(string url)
	{
		if (javaPlayer != null)
		{
			javaPlayer.Call("UPvr_ControlAPPManger", url);
		}
	}

	public static string GetElectric_Quantity()
	{
		if (javaPlayer == null)
		{
			return string.Empty;
		}
		return javaPlayer.Call<string>("GetElectric_Quantity", Array.Empty<object>());
	}

	public static string GetCHARGING_STATUS()
	{
		if (javaPlayer == null)
		{
			return string.Empty;
		}
		return javaPlayer.Call<string>("GetCHARGING_STATUS", Array.Empty<object>());
	}

	public static void OpenPackage()
	{
		if (javaPlayer != null)
		{
			javaPlayer.Call("OpenPackage");
		}
	}

	public static void OpenMiracast()
	{
		if (javaPlayer != null)
		{
			javaPlayer.Call("OpenMiracast");
		}
	}

	public static bool IsMiracastOn()
	{
		if (javaPlayer == null)
		{
			return false;
		}
		return javaPlayer.Call<bool>("IsMiracastOn", Array.Empty<object>());
	}

	public static void CloseMiracast()
	{
		if (javaPlayer != null)
		{
			javaPlayer.Call("CloseMiracast");
		}
	}

	public static void StartScan()
	{
		if (javaPlayer != null)
		{
			javaPlayer.Call("StartScan");
		}
	}

	public static void StopScan()
	{
		if (javaPlayer != null)
		{
			javaPlayer.Call("StopScan");
		}
	}

	public static void SetWDJsonCallback(string game, string jsonCallback)
	{
		if (javaPlayer != null)
		{
			javaPlayer.Call("SetWDJsonCallback", game, jsonCallback);
		}
	}

	public static bool ConnectWifiDisplay(string deviceName)
	{
		if (javaPlayer == null)
		{
			return false;
		}
		return javaPlayer.Call<bool>("ConnectWifiDisplay", new object[1] { deviceName });
	}

	public static void DisConnectWifiDisplay()
	{
		if (javaPlayer != null)
		{
			javaPlayer.Call("DisConnectWifiDisplay");
		}
	}
}
public class UnityWebRequestHelper
{
	public class WebRequestCert : CertificateHandler
	{
		protected override bool ValidateCertificate(byte[] certificateData)
		{
			return true;
		}
	}

	private static UnityWebRequestHelper instance;

	public static UnityWebRequestHelper Instance
	{
		get
		{
			if (instance == null)
			{
				instance = new UnityWebRequestHelper();
			}
			return instance;
		}
	}

	public void Get(string url, Action<RequestStatus, string> action, bool isToken = false)
	{
		UnityWebRequest unityWebRequest = UnityWebRequest.Get(url);
		unityWebRequest.SetRequestHeader("Authorization", J_CodeSecurity_phpAES.EncryptString("15159098526"));
		unityWebRequest.SetRequestHeader("Accept", "application/json");
		unityWebRequest.certificateHandler = new WebRequestCert();
		Singleton<MiniMonoBehaviour>.Instance.StartCoroutine(Request(unityWebRequest, action));
	}

	public void Post(string url, WWWForm form, Action<RequestStatus, string> action, bool isToken = false)
	{
		UnityWebRequest unityWebRequest = UnityWebRequest.Post(url, form);
		unityWebRequest.SetRequestHeader("Authorization", J_CodeSecurity_phpAES.EncryptString("15159098526"));
		unityWebRequest.SetRequestHeader("Accept", "application/json");
		unityWebRequest.certificateHandler = new WebRequestCert();
		Singleton<MiniMonoBehaviour>.Instance.StartCoroutine(Request(unityWebRequest, action));
	}

	public void Upload(string url, WWWForm form, Action<RequestStatus, string> action)
	{
		UnityWebRequest unityWebRequest = UnityWebRequest.Post(url, form);
		unityWebRequest.certificateHandler = new WebRequestCert();
		Singleton<MiniMonoBehaviour>.Instance.StartCoroutine(UploadRequest(unityWebRequest, action));
	}

	public void GetRequest(string url, Action<RequestStatus, string> action)
	{
		UnityWebRequest unityWebRequest = UnityWebRequest.Get(url);
		unityWebRequest.certificateHandler = new WebRequestCert();
		Singleton<MiniMonoBehaviour>.Instance.StartCoroutine(Request(unityWebRequest, action));
	}

	private IEnumerator Request(UnityWebRequest request, Action<RequestStatus, string> action)
	{
		yield return request.SendWebRequest();
		try
		{
			if (request.isHttpError || request.isNetworkError)
			{
				UnityEngine.Debug.Log(request.downloadHandler.text);
				UnityEngine.Debug.Log(request.error);
				action?.Invoke(RequestStatus.fail, request.error);
				yield break;
			}
			string text = request.downloadHandler.text;
			UnityEngine.Debug.Log(request.url + ": " + text);
			J_LitJson.JsonData jsonData = J_LitJson.JsonMapper.ToObject(text);
			int num = int.Parse(jsonData["code"].ToString());
			jsonData["msg"].ToString();
			if (num == 200)
			{
				action?.Invoke(RequestStatus.success, text);
			}
			else
			{
				action?.Invoke(RequestStatus.fail, text);
			}
		}
		catch (Exception)
		{
			throw;
		}
	}

	private IEnumerator UploadRequest(UnityWebRequest request, Action<RequestStatus, string> action)
	{
		yield return request.SendWebRequest();
		try
		{
			if (request.isHttpError || request.isNetworkError)
			{
				UnityEngine.Debug.Log(request.downloadHandler.text);
				UnityEngine.Debug.Log(request.error);
				action?.Invoke(RequestStatus.fail, request.error);
			}
			else
			{
				string text = request.downloadHandler.text;
				action?.Invoke(RequestStatus.success, text);
			}
		}
		catch (Exception)
		{
			throw;
		}
	}
}
public class UrlUtils
{
	public static string persistentDataPath = Application.persistentDataPath + "/";

	public static string baseUrl_adhd = "https://adhdw.guavavr.com/";

	public static string baseUrl_crci = "https://crci.guavavr.com/";

	public static string baseUrl_es = "https://es.guavavr.com/";

	public static string baseUrl_brush = "https://brush.guavavr.com/";

	public static string Qiniuyun_Upload = "https://upload-z2.qiniup.com";

	public static string Qiniuyun_Token = "api/v1/qiniu";

	public static string Aliyun_Token = "api/v1/aliyun";

	public static string voiceRec = "api/voice";

	public static string version = "api/v1/version/update";

	public static string recordCatchFish = "api/record/fish";

	public static string recordClub = "api/record/club";

	public static string recordRing = "api/record/ring";

	public static string recordGraph = "api/record/graph";

	public static string recordLetter = "api/record/letter";

	public static string recordNumber = "api/record/number";

	public static string recordFruit = "api/record/fruit";

	public static string recordPickUpFruit = "api/record/pick";

	public static string recordBombDisposal = "api/record/bomb";

	public static string end = "api/end";

	public static string progress = "api/progress";

	public static string userNameCheck = "api/v1/username";

	public static string userLogin = "api/v1/login";

	public static string userLogout = "api/v1/logout";

	public static string gameDuration = "api/duration";

	public static string speech = "api/v1/aip/speech";

	public static string course = "api/v1/game";

	public static string start = "api/v1/game/start/";

	public static string levelChange = "api/v1/game/record/";

	public static string singleEnd = "api/v1/game/end/";

	public static string bannerLogin = "api/v1/banner/login";

	public static string bannerInside = "api/v1/banner/inside";

	public static string feedbackQuestion = "api/v1/feedback/topic";

	public static string feedbackSubmit = "api/v1/feedback/submit";

	public static string scenario = "api/scenario";

	public static string voice = "api/voice";

	public static string optimize = "api/voice/optimize";

	public static string libray = "api/voice/libray";

	public static string moodThemeList = "api/mood/index";

	public static string moodsysList = "api/mood/sys";

	public static string moodContentsList = "api/mood/res";

	public static string measure = "api/measure";

	public static string artUrl = "api/v1/artwork";

	public static string artDeleteUrl = "api/v1/delete/artwork";

	public static string sealUrl = "api/v1/seal";

	public static string sealDeleteUrl = "api/v1/delete/seal";
}
public class WordToVoiceManager
{
	public class WordRecordDatas
	{
		public Dictionary<string, string> wordRecords;
	}

	public class VoiceData
	{
		public string id;

		public string file_text;

		public string file_key;

		public string file_url;

		public string file_name;

		public int file_size;

		public string mime_type;

		public int status;

		public string created_at;

		public string updated_at;
	}

	public static WordRecordDatas voiceDic;

	private static string voicePath = "VoiceFile/";

	public static void Init()
	{
		voiceDic = new WordRecordDatas();
		voiceDic.wordRecords = new Dictionary<string, string>();
		string text = LoadManager.ReadJson("WordToVoiceRecord.json");
		if (string.IsNullOrEmpty(text))
		{
			return;
		}
		WordRecordDatas wordRecordDatas = J_LitJson.JsonMapper.ToObject<WordRecordDatas>(text);
		if (wordRecordDatas.wordRecords == null)
		{
			return;
		}
		foreach (KeyValuePair<string, string> wordRecord in wordRecordDatas.wordRecords)
		{
			voiceDic.wordRecords.Add(wordRecord.Key, wordRecord.Value);
		}
	}

	public static void WordToVoice(string word, Action<AudioClip> action)
	{
		if (voiceDic == null)
		{
			return;
		}
		if (voiceDic.wordRecords.ContainsKey(word))
		{
			LoadManager.LoadAudios("file://" + UrlUtils.persistentDataPath + voiceDic.wordRecords[word], delegate(AudioClip audioClip, byte[] byteStream)
			{
				action?.Invoke(audioClip);
			});
			return;
		}
		string url = UrlUtils.baseUrl_adhd + UrlUtils.speech;
		WWWForm wWWForm = new WWWForm();
		wWWForm.AddField("text", word);
		UnityWebRequestHelper.Instance.Post(url, wWWForm, delegate(RequestStatus status, string result)
		{
			if (status == RequestStatus.success)
			{
				LoadManager.LoadAudios(J_LitJson.JsonMapper.ToObject<VoiceData>(J_LitJson.JsonMapper.ToObject(result)["data"].ToJson()).file_url, delegate(AudioClip audioClip, byte[] byteStream)
				{
					action?.Invoke(audioClip);
					string path = UrlUtils.persistentDataPath + voicePath;
					string text = LoadManager.GetTimeStamp() + ".mp3";
					LoadManager.CreateFile(path, text, byteStream);
					voiceDic.wordRecords.Add(word, voicePath + text);
					LoadManager.SaveJson("WordToVoiceRecord.json", J_LitJson.JsonMapper.ToJson(voiceDic));
				});
			}
		});
	}
}
public class BatteryTipController : MonoBehaviour
{
	public GameObject BatteryTipPanel;

	public GameObject firstTip;

	public Text firstTxt;

	public Button confirmFirstBtn;

	public GameObject secondTip;

	public Text secondTxt;

	public Button yesBtn;

	public Button noBtn;

	public GameObject lastTip;

	public Text lastTxt;

	public Button confirmLastBtn;

	public Text countdownTxt;

	private bool isCountdown;

	private float timer = 20f;

	private Action _continueAction;

	public bool CheckBattery(Action continueAction)
	{
		_continueAction = continueAction;
		string electric_Quantity = ToBServiceHelper.GetElectric_Quantity();
		if (string.IsNullOrEmpty(electric_Quantity))
		{
			_continueAction?.Invoke();
			return false;
		}
		float num = float.Parse(electric_Quantity.Replace("%", ""));
		if (ToBServiceHelper.GetCHARGING_STATUS().Equals("2"))
		{
			if (num < 3f)
			{
				BatteryTipPanel.SetActive(value: true);
				lastTip.SetActive(value: true);
				lastTxt.text = electric_Quantity;
				isCountdown = true;
				return true;
			}
			_continueAction?.Invoke();
			return false;
		}
		if (num <= 10f && num > 5f && !ToBServiceHelper.isBatteryed)
		{
			BatteryTipPanel.SetActive(value: true);
			firstTip.SetActive(value: true);
			firstTxt.text = electric_Quantity;
			ToBServiceHelper.isBatteryed = true;
			return true;
		}
		if (num <= 5f && num >= 3f)
		{
			BatteryTipPanel.SetActive(value: true);
			secondTip.SetActive(value: true);
			secondTxt.text = electric_Quantity;
			return true;
		}
		if (num < 3f)
		{
			BatteryTipPanel.SetActive(value: true);
			lastTip.SetActive(value: true);
			lastTxt.text = electric_Quantity;
			return true;
		}
		_continueAction?.Invoke();
		return false;
	}

	private void Start()
	{
		confirmFirstBtn.onClick.AddListener(ConfirmFirstBtnHander);
		yesBtn.onClick.AddListener(YesBtnHander);
		noBtn.onClick.AddListener(NoBtnHander);
		confirmLastBtn.onClick.AddListener(ConfirmLastBtnHander);
	}

	private void Update()
	{
		if (isCountdown)
		{
			timer -= Time.unscaledDeltaTime;
			countdownTxt.text = Mathf.Ceil(timer) + "s";
			if (timer <= 0f)
			{
				ScenesHelper.J_QuitApp();
			}
		}
	}

	private void ConfirmFirstBtnHander()
	{
		BatteryTipPanel.SetActive(value: false);
		firstTip.SetActive(value: false);
		_continueAction?.Invoke();
	}

	private void YesBtnHander()
	{
		if (ToBServiceHelper.GetCHARGING_STATUS().Equals("2"))
		{
			BatteryTipPanel.SetActive(value: false);
			secondTip.SetActive(value: false);
			_continueAction?.Invoke();
		}
	}

	private void NoBtnHander()
	{
		ScenesHelper.J_QuitApp();
	}

	private void ConfirmLastBtnHander()
	{
		ScenesHelper.J_QuitApp();
	}
}
public class C_HandMenuUICtrl : MonoBehaviour
{
	public GameObject m_objUI;

	public static bool IsPause;

	private void Awake()
	{
		setAtv(a: false);
	}

	private void OnEnable()
	{
	}

	private void Update()
	{
		if (Controller.UPvr_GetKeyDown(Pvr_ControllerManager.controllerlink.mainHandID, Pvr_KeyCode.APP) || Input.GetKeyDown(KeyCode.Escape))
		{
			setAtv(!m_objUI.activeSelf);
			if (SceneManager.GetActiveScene().name.Contains("言语_评测"))
			{
				GameObject.Find("Canvas").GetComponent<Pvr_UICanvas>().enabled = !m_objUI.activeSelf;
			}
		}
	}

	private void setAtv(bool a)
	{
		m_objUI.SetActive(a);
		m_objUI.SetOtherUICanvaState();
		IsPause = a;
	}

	public void J_ClickContinue()
	{
		setAtv(a: false);
	}

	public void J_ClickQuit()
	{
		ScenesHelper.LoadScene(ScenesHelper.WeiAiXinCenterScene);
	}
}
public class C_NPCSpeaker_Train : MonoBehaviour
{
	[Serializable]
	public class cAnimParmes
	{
		[Range(0f, 100f)]
		public float randomValue;

		public string triggerName;
	}

	public GameObject m_objTxtWord;

	public Text m_txtSpeakTxt;

	public AudioSource m_audioSpeak;

	public Animator m_animCtrl;

	public Vector2 m_Range_randomAnimTime = new Vector2(2f, 10f);

	public List<cAnimParmes> m_listAnimParams;

	private float frandomTime;

	private float fTimer;

	private void Start()
	{
		frandomTime = randomAnimTriggerTime();
		m_objTxtWord.SetActive(value: false);
	}

	private float randomAnimTriggerTime()
	{
		return UnityEngine.Random.Range(m_Range_randomAnimTime.x, m_Range_randomAnimTime.y);
	}

	public void J_Speak(string words)
	{
		if ((bool)m_objTxtWord)
		{
			m_objTxtWord.SetActive(value: true);
			m_txtSpeakTxt.text = words;
		}
		if (!string.IsNullOrEmpty(words))
		{
			baidu_WordToVoiceUtility.J_GetWordAudio(words, delegate(AudioClip audioclip)
			{
				StartCoroutine(yieldAnimSpeak(audioclip));
			});
		}
	}

	public void J_StopSpeak()
	{
		StopAllCoroutines();
		if ((bool)m_animCtrl)
		{
			m_animCtrl.SetBool("talk", value: false);
		}
		if (m_audioSpeak != null)
		{
			m_audioSpeak.Stop();
		}
		if ((bool)m_objTxtWord)
		{
			m_objTxtWord.SetActive(value: false);
		}
	}

	private IEnumerator yieldAnimSpeak(AudioClip audioclip)
	{
		if (m_audioSpeak != null)
		{
			m_audioSpeak.clip = audioclip;
			m_audioSpeak.Play();
		}
		if ((bool)m_animCtrl)
		{
			m_animCtrl.SetBool("talk", value: true);
		}
		yield return new WaitForSeconds(audioclip.length);
		if ((bool)m_animCtrl)
		{
			m_animCtrl.SetBool("talk", value: false);
		}
	}

	private void Update()
	{
		if (!((fTimer += Time.deltaTime) > frandomTime))
		{
			return;
		}
		fTimer = 0f;
		frandomTime = randomAnimTriggerTime();
		if (m_animCtrl != null)
		{
			string randomAnimTriggerName = getRandomAnimTriggerName();
			if (!string.IsNullOrEmpty(randomAnimTriggerName))
			{
				m_animCtrl.SetTrigger(randomAnimTriggerName);
			}
		}
	}

	private string getRandomAnimTriggerName()
	{
		float totalnum = 0f;
		m_listAnimParams.ForEach(delegate(cAnimParmes obj)
		{
			totalnum += obj.randomValue;
		});
		float num = UnityEngine.Random.Range(0f, totalnum);
		foreach (cAnimParmes listAnimParam in m_listAnimParams)
		{
			if (num < listAnimParam.randomValue)
			{
				return listAnimParam.triggerName;
			}
			num -= listAnimParam.randomValue;
		}
		return null;
	}
}
public class C_SpeechTrain_UIList : MonoBehaviour
{
	public class M_Data
	{
		public int id;

		public string scenario_name;

		public string scene_name;
	}

	public List<GameObject> templateButton;

	public GameObject selScene;

	public GameObject selQing;

	public List<GameObject> qingTemplateButton;

	private void Start()
	{
		if (templateButton == null)
		{
			return;
		}
		Transform btncontainer = templateButton[0].transform.parent;
		for (int num = btncontainer.childCount - 1; num >= 0; num--)
		{
			if (!templateButton.Contains(btncontainer.GetChild(num).gameObject))
			{
				UnityEngine.Object.Destroy(btncontainer.GetChild(num).gameObject);
			}
		}
		StartCoroutine((UrlUtils.baseUrl_es + UrlUtils.scenario + "/scene").HttpGet(delegate(M_Data[] data)
		{
			for (int i = 0; i < data.Length; i++)
			{
				M_Data tempdata = data[i];
				GameObject obj = UnityEngine.Object.Instantiate(templateButton[i % templateButton.Count]);
				obj.GetComponentInChildren<Text>().text = data[i].scene_name;
				obj.transform.SetParent(btncontainer);
				obj.transform.localPosition = Vector3.zero;
				obj.transform.localEulerAngles = Vector3.zero;
				obj.transform.localScale = Vector3.one;
				obj.SetActive(value: true);
				obj.GetComponent<Button>().onClick.AddListener(delegate
				{
					TrainControl_Communication.sceneID = tempdata.id;
					StartCoroutine((UrlUtils.baseUrl_es + UrlUtils.scenario + "/index?scene=" + tempdata.id).HttpGet(delegate(M_Data[] p2)
					{
						selScene.SetActive(value: false);
						selQing.SetActive(value: true);
						setQingbut(p2);
					}));
				});
			}
		}));
	}

	private void setQingbut(M_Data[] data)
	{
		Transform parent = qingTemplateButton[0].transform.parent;
		for (int num = parent.childCount - 1; num >= 0; num--)
		{
			if (!qingTemplateButton.Contains(parent.GetChild(num).gameObject))
			{
				UnityEngine.Object.Destroy(parent.GetChild(num).gameObject);
			}
		}
		for (int i = 0; i < data.Length; i++)
		{
			int index = i;
			M_Data tempdata = data[index];
			GameObject obj = UnityEngine.Object.Instantiate(qingTemplateButton[index % templateButton.Count]);
			obj.GetComponentInChildren<Text>().text = data[index].scenario_name;
			obj.transform.SetParent(parent);
			obj.transform.localPosition = Vector3.zero;
			obj.transform.localEulerAngles = Vector3.zero;
			obj.transform.localScale = Vector3.one;
			obj.SetActive(value: true);
			obj.GetComponent<Button>().onClick.AddListener(delegate
			{
				if (data[index].scenario_name == "糕点店约会")
				{
					Load.LoadScene2("recovery_dialogue_bread");
				}
				else if (data[index].scenario_name == "问路")
				{
					Load.LoadScene2("康复_对话_问路");
				}
				else if (data[index].scenario_name == "接电话")
				{
					Load.LoadScene2("康复_对话_接电话");
				}
				TrainControl_Communication.scenarioID = tempdata.id;
			});
		}
	}
}
public class C_StartSceneCtrl : MonoBehaviour
{
	private void Start()
	{
		if (SceneManager.GetActiveScene().name.Contains("MainStart"))
		{
			SimilarWord.Init(this);
		}
	}

	public void Quitapp()
	{
		Application.Quit();
	}
}
public class MultiSceneControl : MonoBehaviour
{
	public string sceness;

	private void Start()
	{
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.S))
		{
			SceneManager.LoadScene("面包店-20190621", LoadSceneMode.Single);
			SceneManager.LoadScene("康复_对话_面包店", LoadSceneMode.Additive);
			UnityEngine.Debug.Log(1);
			StartCoroutine(yieldloadsccs());
		}
	}

	private IEnumerator yieldloadsccs()
	{
		UnityEngine.Debug.Log(2);
		yield return null;
		UnityEngine.Debug.Log(3);
		yield return new WaitForSeconds(1f);
		UnityEngine.Debug.Log(4);
	}
}
public class SceneControl
{
	[Serializable]
	public enum eScene
	{
		StartSelection,
		测评,
		康复_命名_动物,
		康复_命名_水果
	}

	public static void J_LoadScene(eScene escene)
	{
		SceneManager.LoadScene((int)escene);
	}

	public static void J_LoadScene(string ssceneName)
	{
		SceneManager.LoadScene(ssceneName);
	}
}
public class CameraController : MonoBehaviour
{
	public Transform cameraTra;

	private void Awake()
	{
	}

	private void Start()
	{
		base.transform.position = base.transform.position - new Vector3(CameraHelper.cameraLocalPos.x, 0f, CameraHelper.cameraLocalPos.z);
	}

	private void Update()
	{
	}

	public void SaveCameraLocalPos()
	{
		CameraHelper.cameraLocalPos = cameraTra.localPosition;
	}

	private IEnumerator Wait()
	{
		yield return null;
		base.transform.position = base.transform.position - new Vector3(cameraTra.localPosition.x, 0f, cameraTra.localPosition.z);
	}
}
public class CountDown : MonoBehaviour
{
	public Text detailTxt;

	public Text countDownTxt;

	public Text enterTxt;

	public float countDownTimer = 3f;

	public Action action;

	private float timer;

	private bool isCountDown;

	private void Start()
	{
	}

	private void Update()
	{
		if (isCountDown)
		{
			timer -= Time.deltaTime;
			countDownTxt.text = Math.Ceiling(timer).ToString();
			if (timer <= 0f)
			{
				isCountDown = false;
				action?.Invoke();
				base.gameObject.SetActive(value: false);
			}
		}
	}

	private void OnEnable()
	{
		timer = countDownTimer;
		isCountDown = true;
	}
}
public class cSceneManager : MonoBehaviour
{
	private void Start()
	{
		Pvr_UnitySDKSensor.Instance.ResetUnitySDKSensor();
	}

	public void J_LoadScene(string sceneName)
	{
		Load.LoadScene2(sceneName);
	}

	public void J_QuitApp()
	{
		Application.Quit();
	}
}
public class CustomEvent : MonoBehaviour
{
	public UnityEvent Event;

	private void Start()
	{
	}

	private void Update()
	{
	}

	private void OnEnable()
	{
		Enable();
	}

	private void OnDisable()
	{
		Disable();
	}

	public void Enable()
	{
	}

	public void Disable()
	{
	}
}
public class BannerDatas
{
	public int code;

	public string msg;

	public List<BannerData> data;
}
public class BannerData
{
	public string id;

	public string scenehall;

	public string imgplace;

	public string imgurl;

	public string relativePath;
}
public class CourseData
{
	public class Data
	{
		public int all;

		public int now;

		public List<Games> games;
	}

	public class Games
	{
		public string id;

		public string order_day_id;

		public int play_time;

		public int already_play_time;

		public int point;

		public int level;

		public int strength;

		public string game_data;

		public int status;

		public Game game;
	}

	public class Game
	{
		public string id;

		public string game_code;

		public string game_name;

		public string game_scene_name;
	}

	public int code;

	public string msg;

	public Data data;
}
public class CourseDetail
{
	public class Data
	{
		public string id;

		public int play_time;

		public int already_play_time;

		public int point;

		public int level;

		public int strength;

		public string game_data;

		public int status;
	}

	public int code;

	public string msg;

	public Data data;
}
public class Device
{
	public class Data
	{
		public int id;

		public string device_code;

		public string device_number;

		public string last_use_time;

		public int status;

		public string status_text;

		public Organization organization;

		public User user;
	}

	public class Organization
	{
		public int id;

		public string organization_name;

		public string contact_name;

		public string contact_phone;

		public string contact_address;

		public int status;

		public string status_text;
	}

	public class User
	{
		public int id;

		public string truename;

		public string mobile;

		public int gender;

		public string birthday;

		public int education;

		public string last_login_time;

		public int status;

		public string status_text;

		public string gender_text;

		public string education_text;
	}

	public int code;

	public string msg;

	public Data data;
}
public class DeviceCheck
{
	public class Data
	{
		public int id;

		public string device_code;

		public string device_number;

		public string useful_life_time;

		public int status;

		public string status_text;

		public Organization organization;
	}

	public int code;

	public string msg;

	public Data data;
}
public class Organization
{
	public int id;

	public string organization_name;

	public string contact_name;

	public string contact_phone;

	public string contact_address;

	public int status;

	public string status_text;
}
public class DurationData
{
	public class Data
	{
		public int anti_addiction_time;

		public int unlimited;

		public int today_play_time;
	}

	public int code;

	public string msg;

	public Data data;
}
public class LogoData
{
	public string imgurl;

	public string relativePath;
}
public class MiracastData
{
	public bool canConnect;

	public string description;

	public string deviceAddress;

	public string deviceName;

	public bool isAvailable;

	public bool isRemembered;

	public string status;

	public int statusCode;
}
public class MiracastItem : MonoBehaviour
{
	public Text deviceNameTxt;

	public Text statusTxt;

	public Button deviceBtn;

	public GameObject select;

	private void Start()
	{
	}

	private void Update()
	{
	}
}
public enum RequestStatus
{
	success,
	fail
}
public class UserData
{
	public class Data
	{
		public string id;

		public string organization_id;

		public string username;

		public string nickname;

		public string email;

		public string mobile;

		public string avatar;

		public int gender;

		public string birthday;

		public string education;

		public string last_login_time;

		public string last_login_ip;

		public int status;

		public string created_at;

		public string updated_at;

		public string token;

		public string organization_name;

		public string organization_logo_url;

		public int course_many_time;
	}

	public int code;

	public string msg;

	public Data data;
}
public class UserNameData
{
	public class UserName
	{
		public string username;

		public string nickname;
	}

	public List<UserName> UserNames;
}
public class UserNameItem : MonoBehaviour
{
	public string username;

	public string truename;

	private void Start()
	{
	}

	private void Update()
	{
	}
}
public class KeyboardItem : MonoBehaviour, IPointerEnterHandler, IEventSystemHandler, IPointerExitHandler
{
	public Sprite normalSprite;

	public Sprite highlightSprite;

	private KeyboardsController keyboardsController;

	private Button keysBtn;

	private Image keysImage;

	private void Start()
	{
		keyboardsController = base.transform.parent.GetComponent<KeyboardsController>();
		keysBtn = GetComponent<Button>();
		keysImage = GetComponent<Image>();
		keysBtn.onClick.AddListener(KeysBtnHander);
	}

	private void Update()
	{
	}

	private void KeysBtnHander()
	{
		string text = base.transform.name.Replace("Keys_", "");
		if (text.Equals("Delete"))
		{
			keyboardsController.DeleteKey();
		}
		else if (text.Equals("Return"))
		{
			keyboardsController.ReturnKey();
		}
		else if (text.Equals("Confirm"))
		{
			keyboardsController.ConfirmKey();
		}
		else if (text.Equals("Clear"))
		{
			keyboardsController.ClearKey();
		}
		else
		{
			keyboardsController.InputKey(text);
		}
		Controller.UPvr_VibrateNeo2Controller(0.5f, 50, Pvr_ControllerManager.controllerlink.mainHandID);
	}

	public void OnPointerEnter(PointerEventData eventData)
	{
		if (!(highlightSprite == null))
		{
			keysImage.sprite = highlightSprite;
		}
	}

	public void OnPointerExit(PointerEventData eventData)
	{
		if (!(normalSprite == null))
		{
			keysImage.sprite = normalSprite;
		}
	}

	public void ResetKeysImage()
	{
		if (!(normalSprite == null))
		{
			keysImage.sprite = normalSprite;
		}
	}
}
public class KeyboardsController : MonoBehaviour
{
	public Action<string> inputAction;

	public Action deleteAction;

	public Action returnAction;

	public Action confirmAction;

	public Action clearAction;

	private void Start()
	{
	}

	private void Update()
	{
	}

	public void InputKey(string key)
	{
		inputAction?.Invoke(key);
	}

	public void DeleteKey()
	{
		deleteAction?.Invoke();
	}

	public void ReturnKey()
	{
		returnAction?.Invoke();
	}

	public void ConfirmKey()
	{
		confirmAction?.Invoke();
	}

	public void ClearKey()
	{
		clearAction?.Invoke();
	}
}
public class LoadingController : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
		base.transform.Rotate(Vector3.forward, 150f * Time.deltaTime);
	}
}
public class LocalController : MonoBehaviour
{
	public TextMeshProUGUI textMeshProUGUI;

	public TextMeshProUGUI levelTxt;

	public Image localImage;

	public Color normalColor = Color.white;

	public Color localColor = new Color(Color.white.r, Color.white.g, Color.white.b, 2f / 51f);

	private void OnEnable()
	{
		textMeshProUGUI.color = localColor;
		textMeshProUGUI.outlineColor = localColor;
		levelTxt.color = localColor;
		levelTxt.outlineColor = localColor;
		localImage.gameObject.SetActive(value: true);
	}

	private void OnDisable()
	{
		textMeshProUGUI.color = normalColor;
		textMeshProUGUI.outlineColor = normalColor;
		levelTxt.color = normalColor;
		levelTxt.outlineColor = normalColor;
		localImage.gameObject.SetActive(value: false);
	}

	private void Start()
	{
	}

	private void Update()
	{
	}
}
public class CourseItem : MonoBehaviour
{
	public Text IndexTxt;

	public Text GameNameTxt;

	public Text LevelTxt;

	public Text TrainTimeTxt;

	public Text State;

	public Image ImageState;

	public Image ImageState1;

	public Button CourseBtn;

	public CourseData.Games games;

	public bool isCanPlay;

	public string tipWord;

	private void Start()
	{
	}
}
public class DeviceLoginController : MonoBehaviour
{
	public PingNetwork pingNetwork;

	[Header("加载")]
	public GameObject LoadingPanel;

	[Header("启动界面")]
	public GameObject StartUpPanel;

	public Button courseBtn;

	public Button experienceBtn;

	public Button miracastBtn;

	public Button exitBtn;

	public Text deviceCodeTxt;

	public Text networkStateTxt;

	public Text versionTxt;

	public GameObject loadingImg;

	[Header("投屏界面")]
	public GameObject MiracastPanel;

	public Button checkMiracastBtn;

	public Transform contentMiracast;

	public GameObject templateMiracast;

	public Button disConnectBtn;

	public Button closeMiracastBtn;

	public GameObject nodeviceObj;

	[Header("登录")]
	public GameObject LoginPanel;

	public Button accountLoginBtn;

	public Transform accountContent;

	public GameObject accountTemplate;

	public GameObject moreAccountPanel;

	public Transform moreAccountContent;

	public Button moreBtn;

	public Button closeBtn;

	public Button returnBtn;

	[Header("账户")]
	public GameObject AccountPanel;

	public InputField accountInput;

	public KeyboardsController accountKeyboards;

	[Header("密码")]
	public GameObject PasswordPanel;

	public InputField passwordInput;

	public KeyboardsController passwordKeyboards;

	[Header("今日课程")]
	public GameObject CoursePanel;

	public Text userNameTxt;

	public Text courseTimeTxt;

	public GameObject courseTemplate;

	public Transform courseContent;

	public Text tipsTxt;

	public Button logOutBtn;

	public Sprite[] statusSprite;

	public Sprite[] startSprite;

	public Color[] statusColor;

	private string[] statusWord = new string[5] { "未开始", "未完成", "已完成", "继续", "开始" };

	private string[] tipsWord = new string[2] { "您当前正在进行", "您当前可以进行" };

	[Header("错误提示")]
	public GameObject ErrorPanel;

	public Text errorTxt;

	public Text deviceCodeTxt1;

	[Header("警告提示")]
	public GameObject TipPanel;

	public Text tipTxt;

	public CountDown countDownPanel;

	private UserNameData userNameData;

	private bool isInputAccount;

	private bool isNetworking;

	private string[] levelNames = new string[4] { "Easy", "Normal", "Hard", "Speical" };

	private MiracastItem curMiracastItem;

	private void OnApplicationFocus(bool focus)
	{
		if (focus && isNetworking)
		{
			PingNetwork();
		}
	}

	private void Start()
	{
		NetworkInterface[] allNetworkInterfaces = NetworkInterface.GetAllNetworkInterfaces();
		foreach (NetworkInterface networkInterface in allNetworkInterfaces)
		{
			if (networkInterface.Name.Equals("wlan0"))
			{
				LoadManager.deviceUniqueIdentifier = networkInterface.GetPhysicalAddress().ToString();
				break;
			}
		}
		PingNetwork();
		deviceCodeTxt.text = LoadManager.deviceUniqueIdentifier;
		deviceCodeTxt1.text = LoadManager.deviceUniqueIdentifier;
		versionTxt.text = "v" + Application.version;
		courseBtn.onClick.AddListener(CourseBtnHander);
		experienceBtn.onClick.AddListener(ExperienceBtnHander);
		miracastBtn.onClick.AddListener(MiracastBtnHander);
		exitBtn.onClick.AddListener(ExitBtnHander);
		checkMiracastBtn.onClick.AddListener(CheckMiracastBtnBtnHander);
		disConnectBtn.onClick.AddListener(DisConnectBtnHander);
		disConnectBtn.interactable = false;
		closeMiracastBtn.onClick.AddListener(CloseMiracastBtnHander);
		accountLoginBtn.onClick.AddListener(AccountLoginBtnHander);
		moreBtn.onClick.AddListener(MoreBtnHander);
		moreBtn.gameObject.SetActive(value: false);
		closeBtn.onClick.AddListener(CloseBtnHander);
		returnBtn.onClick.AddListener(ReturnBtnHander);
		logOutBtn.onClick.AddListener(LogOutBtnHander);
		accountKeyboards.inputAction = AccountInput;
		accountKeyboards.deleteAction = AccountDelete;
		accountKeyboards.returnAction = AccountReturn;
		accountKeyboards.confirmAction = AccountConfirm;
		accountKeyboards.clearAction = AccountClear;
		passwordKeyboards.inputAction = PasswordInput;
		passwordKeyboards.deleteAction = PasswordDelete;
		passwordKeyboards.returnAction = PasswordReturn;
		passwordKeyboards.confirmAction = PasswordConfirm;
		passwordKeyboards.clearAction = PasswordClear;
		StartUpPanel.SetActive(value: true);
		MiracastPanel.SetActive(value: false);
		LoginPanel.SetActive(value: false);
		AccountPanel.SetActive(value: false);
		PasswordPanel.SetActive(value: false);
		CoursePanel.SetActive(value: false);
		WordToVoiceManager.Init();
		if (LoadManager.courseDetail != null && LoadManager.userData != null)
		{
			StartUpPanel.SetActive(value: false);
			LoginSuccess();
		}
		if (LoadManager.IsFirstEnterApp)
		{
			CheckIsMiracastOn();
		}
		LoadManager.IsFirstEnterApp = false;
	}

	private void Update()
	{
	}

	private void CheckIsMiracastOn()
	{
		StartUpPanel.SetActive(value: false);
		MiracastPanel.SetActive(value: true);
		ToBServiceHelper.SetWDJsonCallback(base.gameObject.name, "OnSetWDJsonCallback");
		ToBServiceHelper.OpenMiracast();
		UnityEngine.Debug.Log("IsMiracastOn:" + ToBServiceHelper.IsMiracastOn());
		GetMiracastDevices();
	}

	private void GetMiracastDevices()
	{
		ToBServiceHelper.StartScan();
	}

	public void OnSetWDJsonCallback(string deviceJsons)
	{
		foreach (Transform item2 in contentMiracast)
		{
			UnityEngine.Object.Destroy(item2.gameObject);
		}
		List<MiracastData> list = J_LitJson.JsonMapper.ToObject<List<MiracastData>>(deviceJsons);
		if (list == null || list.Count == 0)
		{
			nodeviceObj.SetActive(value: true);
		}
		else
		{
			nodeviceObj.SetActive(value: false);
		}
		foreach (MiracastData item in list)
		{
			GameObject gameObject = UnityEngine.Object.Instantiate(templateMiracast, contentMiracast);
			gameObject.SetActive(value: true);
			MiracastItem miracastItem = gameObject.GetComponent<MiracastItem>();
			miracastItem.deviceNameTxt.text = item.deviceName;
			if (item.statusCode == 6)
			{
				miracastItem.statusTxt.text = "投屏中......";
				miracastItem.select.SetActive(value: true);
				curMiracastItem = miracastItem;
				disConnectBtn.interactable = true;
			}
			else if (item.statusCode == 2)
			{
				miracastItem.statusTxt.text = "连接中......";
				miracastItem.select.SetActive(value: true);
			}
			else
			{
				miracastItem.statusTxt.text = (item.isRemembered ? "未连接(使用过)" : "未连接");
			}
			miracastItem.deviceBtn.onClick.AddListener(delegate
			{
				if ((bool)curMiracastItem)
				{
					TipPanel.SetActive(value: true);
					tipTxt.text = "请先断开投屏，再连接";
				}
				else
				{
					if (ToBServiceHelper.ConnectWifiDisplay(item.deviceName))
					{
						miracastItem.statusTxt.text = "连接中......";
					}
					miracastItem.select.SetActive(value: true);
				}
			});
			if (!item.canConnect)
			{
				miracastItem.deviceBtn.interactable = false;
				miracastItem.statusTxt.text = "不可连接";
			}
		}
		foreach (Transform item3 in contentMiracast)
		{
			if (!item3.GetComponent<MiracastItem>().deviceBtn.interactable)
			{
				item3.SetAsLastSibling();
			}
		}
	}

	private void PingNetwork()
	{
		loadingImg.SetActive(value: true);
		pingNetwork.CheckNetStatus("www.baidu.com", delegate(bool netState)
		{
			if (netState)
			{
				string text = UrlUtils.baseUrl_adhd.Replace("https://", "");
				text = text.TrimEnd('/');
				pingNetwork.CheckNetStatus(text, delegate(bool state)
				{
					if (state)
					{
						isNetworking = true;
						networkStateTxt.text = "正常";
					}
					else
					{
						isNetworking = false;
						networkStateTxt.text = "dns地址异常";
					}
					loadingImg.SetActive(value: false);
				});
			}
			else
			{
				isNetworking = false;
				networkStateTxt.text = "未联网";
				loadingImg.SetActive(value: false);
			}
		});
	}

	private void InitLoginPage()
	{
		LoginPanel.SetActive(value: true);
		string text = LoadManager.ReadJson("UserNameData.json");
		if (!string.IsNullOrEmpty(text))
		{
			userNameData = J_LitJson.JsonMapper.ToObject<UserNameData>(text);
			userNameData.UserNames.Reverse();
			foreach (Transform item2 in accountContent)
			{
				UnityEngine.Object.Destroy(item2.gameObject);
			}
			for (int i = 0; i < userNameData.UserNames.Count; i++)
			{
				if (i >= 4)
				{
					break;
				}
				GameObject obj = UnityEngine.Object.Instantiate(accountTemplate, accountContent);
				obj.SetActive(value: true);
				UserNameItem item = obj.GetComponent<UserNameItem>();
				item.username = userNameData.UserNames[i].username;
				item.truename = userNameData.UserNames[i].nickname;
				obj.GetComponent<Button>().onClick.AddListener(delegate
				{
					string url = UrlUtils.baseUrl_adhd + UrlUtils.userNameCheck;
					WWWForm wWWForm = new WWWForm();
					wWWForm.AddField("username", item.username);
					UnityWebRequestHelper.Instance.Post(url, wWWForm, delegate(RequestStatus status, string result)
					{
						if (status == RequestStatus.success)
						{
							isInputAccount = false;
							LoginPanel.SetActive(value: false);
							PasswordPanel.SetActive(value: true);
							accountInput.text = item.username;
						}
						else
						{
							J_LitJson.JsonData jsonData = J_LitJson.JsonMapper.ToObject(result);
							int.Parse(jsonData["code"].ToString());
							string text2 = jsonData["msg"].ToString();
							TipPanel.SetActive(value: true);
							tipTxt.text = text2;
							userNameData.UserNames.Remove(userNameData.UserNames.Find((UserNameData.UserName x) => x.username == item.username));
							UnityEngine.Object.Destroy(obj);
						}
					});
				});
				obj.GetComponentInChildren<Text>().text = item.truename;
			}
			if (userNameData.UserNames.Count > 5)
			{
				moreBtn.gameObject.SetActive(value: true);
			}
			else
			{
				moreBtn.gameObject.SetActive(value: false);
			}
		}
		else
		{
			moreBtn.gameObject.SetActive(value: false);
			userNameData = new UserNameData();
			userNameData.UserNames = new List<UserNameData.UserName>();
		}
	}

	private void CheckMiracastBtnBtnHander()
	{
		GetMiracastDevices();
	}

	private void DisConnectBtnHander()
	{
		ToBServiceHelper.DisConnectWifiDisplay();
		curMiracastItem.statusTxt.text = "未连接(使用过)";
		curMiracastItem.select.SetActive(value: true);
		disConnectBtn.interactable = false;
		curMiracastItem = null;
	}

	private void CloseMiracastBtnHander()
	{
		StartUpPanel.SetActive(value: true);
		MiracastPanel.transform.DOScale(0f, 0.5f);
		MiracastPanel.transform.DOMove(miracastBtn.transform.position, 0.5f).OnComplete(delegate
		{
			MiracastPanel.SetActive(value: false);
		});
		ToBServiceHelper.StopScan();
	}

	private void CourseBtnHander()
	{
		LoginPanel.SetActive(value: true);
		StartUpPanel.SetActive(value: false);
		InitLoginPage();
	}

	private void ExperienceBtnHander()
	{
		LoadManager.IsLocalOperate = true;
		ScenesHelper.LoadScene(ScenesHelper.WeiAiZhiCenterScene);
	}

	private void MiracastBtnHander()
	{
		MiracastPanel.SetActive(value: true);
		MiracastPanel.transform.DOScale(1f, 0.5f);
		MiracastPanel.transform.DOLocalMove(Vector3.zero, 0.5f).OnComplete(delegate
		{
			StartUpPanel.SetActive(value: false);
		});
		GetMiracastDevices();
	}

	private void ExitBtnHander()
	{
		Application.Quit();
	}

	private void AccountLoginBtnHander()
	{
		isInputAccount = true;
		LoginPanel.SetActive(value: false);
		AccountPanel.SetActive(value: true);
	}

	private void MoreBtnHander()
	{
		if (userNameData.UserNames.Count > 4)
		{
			moreAccountPanel.SetActive(value: true);
			{
				foreach (UserNameData.UserName item in userNameData.UserNames)
				{
					GameObject obj = UnityEngine.Object.Instantiate(accountTemplate, moreAccountContent);
					obj.SetActive(value: true);
					UserNameItem userNameItem = obj.GetComponent<UserNameItem>();
					userNameItem.username = item.username;
					userNameItem.truename = item.nickname;
					obj.GetComponent<Button>().onClick.AddListener(delegate
					{
						string url = UrlUtils.baseUrl_adhd + UrlUtils.userNameCheck;
						WWWForm wWWForm = new WWWForm();
						wWWForm.AddField("username", userNameItem.username);
						UnityWebRequestHelper.Instance.Post(url, wWWForm, delegate(RequestStatus status, string result)
						{
							if (status == RequestStatus.success)
							{
								isInputAccount = false;
								LoadManager.DestroyChild(moreAccountContent);
								moreAccountPanel.SetActive(value: false);
								LoginPanel.SetActive(value: false);
								PasswordPanel.SetActive(value: true);
								accountInput.text = item.username;
							}
							else
							{
								J_LitJson.JsonData jsonData = J_LitJson.JsonMapper.ToObject(result);
								int.Parse(jsonData["code"].ToString());
								string text = jsonData["msg"].ToString();
								TipPanel.SetActive(value: true);
								tipTxt.text = text;
								userNameData.UserNames.Remove(userNameData.UserNames.Find((UserNameData.UserName x) => x.username == userNameItem.username));
								UnityEngine.Object.Destroy(obj);
							}
						});
					});
					obj.GetComponentInChildren<Text>().text = userNameItem.truename;
				}
				return;
			}
		}
		TipPanel.SetActive(value: true);
		tipTxt.text = "无更多用户";
	}

	private void CloseBtnHander()
	{
		LoadManager.DestroyChild(moreAccountContent);
		moreAccountPanel.SetActive(value: false);
	}

	private void ReturnBtnHander()
	{
		StartUpPanel.SetActive(value: true);
		LoginPanel.SetActive(value: false);
	}

	private void LogOutBtnHander()
	{
		CoursePanel.SetActive(value: false);
		LoginPanel.SetActive(value: true);
		LoadManager.UserLogout();
		foreach (Transform item in courseContent)
		{
			UnityEngine.Object.Destroy(item.gameObject);
		}
		PasswordClear();
	}

	private void AccountInput(string key)
	{
		accountInput.text += key;
	}

	private void AccountDelete()
	{
		if (!string.IsNullOrEmpty(accountInput.text))
		{
			accountInput.text = accountInput.text.Remove(accountInput.text.Length - 1, 1);
		}
	}

	private void AccountClear()
	{
		if (!string.IsNullOrEmpty(accountInput.text))
		{
			accountInput.text = string.Empty;
		}
	}

	private void AccountReturn()
	{
		accountInput.text = string.Empty;
		LoginPanel.SetActive(value: true);
		AccountPanel.SetActive(value: false);
	}

	private void AccountConfirm()
	{
		if (string.IsNullOrEmpty(accountInput.text))
		{
			TipPanel.SetActive(value: true);
			tipTxt.text = "用户名不能为空";
			return;
		}
		string url = UrlUtils.baseUrl_adhd + UrlUtils.userNameCheck;
		WWWForm wWWForm = new WWWForm();
		wWWForm.AddField("username", accountInput.text);
		UnityWebRequestHelper.Instance.Post(url, wWWForm, delegate(RequestStatus status, string result)
		{
			if (status == RequestStatus.success)
			{
				AccountPanel.SetActive(value: false);
				PasswordPanel.SetActive(value: true);
			}
			else
			{
				J_LitJson.JsonData jsonData = J_LitJson.JsonMapper.ToObject(result);
				int.Parse(jsonData["code"].ToString());
				string text = jsonData["msg"].ToString();
				TipPanel.SetActive(value: true);
				tipTxt.text = text;
			}
		});
	}

	private void PasswordInput(string key)
	{
		passwordInput.text += key;
	}

	private void PasswordDelete()
	{
		if (!string.IsNullOrEmpty(passwordInput.text))
		{
			passwordInput.text = passwordInput.text.Remove(passwordInput.text.Length - 1, 1);
		}
	}

	private void PasswordClear()
	{
		if (!string.IsNullOrEmpty(passwordInput.text))
		{
			passwordInput.text = string.Empty;
		}
	}

	private void PasswordReturn()
	{
		passwordInput.text = string.Empty;
		if (isInputAccount)
		{
			AccountPanel.SetActive(value: true);
		}
		else
		{
			LoginPanel.SetActive(value: true);
			AccountPanel.SetActive(value: false);
		}
		PasswordPanel.SetActive(value: false);
	}

	private void PasswordConfirm()
	{
		if (string.IsNullOrEmpty(passwordInput.text))
		{
			TipPanel.SetActive(value: true);
			tipTxt.text = "密码不能为空";
			return;
		}
		string url = UrlUtils.baseUrl_adhd + UrlUtils.userLogin;
		WWWForm wWWForm = new WWWForm();
		wWWForm.AddField("username", accountInput.text);
		wWWForm.AddField("password", J_CodeSecurity_phpAES.EncryptString(passwordInput.text));
		UnityWebRequestHelper.Instance.Post(url, wWWForm, delegate(RequestStatus status, string result)
		{
			if (status == RequestStatus.success)
			{
				UserData userData = J_LitJson.JsonMapper.ToObject<UserData>(result);
				LoadManager.userData = userData;
				PlayerPrefs.SetString("UserData", J_LitJson.JsonMapper.ToJson(userData));
				UserNameData.UserName userName = userNameData.UserNames.Find((UserNameData.UserName x) => x.username == userData.data.username);
				if (userName == null)
				{
					userName = new UserNameData.UserName
					{
						username = userData.data.username,
						nickname = userData.data.nickname
					};
					userNameData.UserNames.Add(userName);
				}
				else
				{
					userNameData.UserNames.Remove(userName);
					userNameData.UserNames.Add(userName);
				}
				string json = J_LitJson.JsonMapper.ToJson(userNameData);
				LoadManager.SaveJson("UserNameData.json", json);
				LoginSuccess();
			}
			else
			{
				J_LitJson.JsonData jsonData = J_LitJson.JsonMapper.ToObject(result);
				int.Parse(jsonData["code"].ToString());
				string text = jsonData["msg"].ToString();
				TipPanel.SetActive(value: true);
				tipTxt.text = text;
			}
		});
	}

	private void LoginSuccess()
	{
		string url = UrlUtils.baseUrl_adhd + UrlUtils.course;
		UnityWebRequestHelper.Instance.Get(url, delegate(RequestStatus courseStatus, string courseResult)
		{
			if (courseStatus == RequestStatus.success)
			{
				CourseData courseData = (LoadManager.courseData = J_LitJson.JsonMapper.ToObject<CourseData>(courseResult));
				if (courseData.data != null && courseData.data.games != null && courseData.data.games.Count != 0)
				{
					PasswordPanel.SetActive(value: false);
					ShowCoursePanel(courseData);
				}
				else
				{
					TipPanel.SetActive(value: true);
					tipTxt.text = "今天没课程";
				}
			}
			else
			{
				string text = J_LitJson.JsonMapper.ToObject(courseResult)["msg"].ToString();
				TipPanel.SetActive(value: true);
				tipTxt.text = text;
			}
		}, isToken: true);
	}

	private void ShowCoursePanel(CourseData courseData)
	{
		CoursePanel.SetActive(value: true);
		userNameTxt.text = LoadManager.userData.data.nickname + "(" + LoadManager.userData.data.organization_name + ")";
		courseTimeTxt.text = courseData.data.now + "/" + courseData.data.all;
		tipsTxt.text = string.Empty;
		for (int i = 0; i < courseData.data.games.Count; i++)
		{
			GameObject gameObject = UnityEngine.Object.Instantiate(courseTemplate, courseContent);
			gameObject.SetActive(value: true);
			CourseItem course = gameObject.GetComponent<CourseItem>();
			course.games = courseData.data.games[i];
			course.IndexTxt.text = "训练" + (i + 1);
			course.GameNameTxt.text = course.games.game.game_name;
			course.LevelTxt.text = levelNames[course.games.level] + "-" + (course.games.strength + 1);
			course.TrainTimeTxt.text = LoadManager.TimeConversion(course.games.play_time - course.games.already_play_time);
			course.ImageState.sprite = statusSprite[course.games.status];
			course.State.text = statusWord[course.games.status];
			course.State.color = statusColor[course.games.status];
			course.ImageState1.sprite = startSprite[2];
			InitPlayData(courseData, course);
			course.CourseBtn.onClick.AddListener(delegate
			{
				if (course.isCanPlay)
				{
					StartGame(course.games.game.game_scene_name, course.games.id);
				}
				else
				{
					TipPanel.SetActive(value: true);
					tipTxt.text = course.tipWord;
				}
			});
		}
	}

	private void StartGame(string sceneName, string id)
	{
		string url = UrlUtils.baseUrl_adhd + UrlUtils.start + id;
		UnityWebRequestHelper.Instance.Get(url, delegate(RequestStatus status, string result)
		{
			if (status == RequestStatus.success)
			{
				LoadManager.courseDetail = J_LitJson.JsonMapper.ToObject<CourseDetail>(result);
				LoadManager.IsLocalOperate = false;
				SetIsLastCourse(id);
				ScenesHelper.LoadScene(sceneName);
			}
			else
			{
				string text = J_LitJson.JsonMapper.ToObject(result)["msg"].ToString();
				TipPanel.SetActive(value: true);
				tipTxt.text = text;
			}
		}, isToken: true);
	}

	private void SetIsLastCourse(string id)
	{
		CourseData.Games games = LoadManager.courseData.data.games.Find((CourseData.Games x) => x.id == id);
		if (games != null && LoadManager.courseData.data.games.IndexOf(games) == LoadManager.courseData.data.games.Count - 1)
		{
			LoadManager.isLastCourse = true;
		}
	}

	private void InitPlayData(CourseData courseData, CourseItem course)
	{
		if (course.games.status == 3)
		{
			tipsTxt.text = tipsWord[0] + course.IndexTxt.text + "...";
			course.ImageState1.sprite = startSprite[1];
			course.isCanPlay = true;
			return;
		}
		if (course.games.status == 1)
		{
			course.isCanPlay = false;
			course.tipWord = "训练未完成";
			return;
		}
		if (course.games.status == 2)
		{
			course.isCanPlay = false;
			course.tipWord = "训练已完成";
			return;
		}
		if (courseData.data.games.Find((CourseData.Games c) => c.status == 3) != null)
		{
			course.isCanPlay = false;
			course.tipWord = "训练未开始";
			return;
		}
		for (int i = 0; i < courseData.data.games.Count; i++)
		{
			if (courseData.data.games[i].status == 0)
			{
				if (courseData.data.games[i].id.Equals(course.games.id))
				{
					tipsTxt.text = tipsWord[1] + course.IndexTxt.text + "...";
					course.ImageState.sprite = statusSprite[3];
					course.State.text = statusWord[4];
					course.State.color = statusColor[3];
					course.ImageState1.sprite = startSprite[0];
					course.isCanPlay = true;
				}
				break;
			}
		}
		if (!course.isCanPlay)
		{
			course.tipWord = "要从左往右依次训练哦!";
		}
	}

	private bool IsCanPlay(CourseData courseData, CourseData.Games games)
	{
		if (games.status == 3)
		{
			return true;
		}
		if (games.status == 1)
		{
			TipPanel.SetActive(value: true);
			tipTxt.text = "训练未完成";
			return false;
		}
		if (games.status == 2)
		{
			TipPanel.SetActive(value: true);
			tipTxt.text = "训练已完成";
			return false;
		}
		if (courseData.data.games.Find((CourseData.Games c) => c.status == 3) != null)
		{
			TipPanel.SetActive(value: true);
			tipTxt.text = "训练未开始";
			return false;
		}
		for (int i = 0; i < courseData.data.games.Count; i++)
		{
			if (courseData.data.games[i].status == 0)
			{
				if (!courseData.data.games[i].id.Equals(games.id))
				{
					break;
				}
				return true;
			}
		}
		TipPanel.SetActive(value: true);
		tipTxt.text = "要从左往右依次训练哦!";
		return false;
	}

	private void DelayConnect(float time, string deviceName, Action<string> action)
	{
		StartCoroutine(Wait(time, deviceName, action));
	}

	private IEnumerator Wait(float time, string deviceName, Action<string> action)
	{
		yield return new WaitForSeconds(time);
		action?.Invoke(deviceName);
	}
}
public class GameCenterController : MonoBehaviour
{
	public Transform contentTra;

	public Button lastBtn;

	public Button nextBtn;

	public Text curPageTxt;

	public Text allPageTxt;

	public Button fishBtn;

	public Button ringBtn;

	public Button clubBtn;

	public Button fruitBtn;

	public Button pickUpFruitBtn;

	public Button bombBtn;

	public Button letterBtn;

	public Button wordFormationBtn;

	public Button ancientPoetryBtn;

	public Button perfectFillBtn;

	public Button eyeTrainBtn;

	public Button exitBtn;

	private bool isScoll;

	private float height;

	private int curPage;

	private int allPage;

	private void Start()
	{
		Pvr_UnitySDKSensor.Instance.ResetUnitySDKSensor();
		lastBtn.onClick.AddListener(LastBtnHander);
		nextBtn.onClick.AddListener(NextBtnHander);
		fishBtn.onClick.AddListener(FishBtnHander);
		ringBtn.onClick.AddListener(RingBtnHander);
		clubBtn.onClick.AddListener(ClubBtnHander);
		fruitBtn.onClick.AddListener(FruitBtnHander);
		pickUpFruitBtn.onClick.AddListener(PickUpFruitBtnHander);
		bombBtn.onClick.AddListener(BombBtnHander);
		letterBtn.onClick.AddListener(LetterBtnHander);
		wordFormationBtn.onClick.AddListener(WordFormationBtnHander);
		ancientPoetryBtn.onClick.AddListener(AncientPoetryBtnBtnHander);
		perfectFillBtn.onClick.AddListener(PerfectFillBtnHander);
		eyeTrainBtn.onClick.AddListener(EyeTrainBtnHander);
		exitBtn.onClick.AddListener(ExitBtnHander);
		curPage = 1;
		int num = 0;
		foreach (Transform item in contentTra)
		{
			if (item.gameObject.activeSelf)
			{
				num++;
			}
		}
		allPage = (num - 1) / 8 + 1;
		curPageTxt.text = curPage.ToString();
		allPageTxt.text = "/" + allPage;
		lastBtn.interactable = false;
		if (allPage == 1)
		{
			nextBtn.interactable = false;
		}
	}

	private void LastBtnHander()
	{
		if (!isScoll)
		{
			isScoll = true;
			height -= 406f;
			curPage--;
			curPageTxt.text = curPage.ToString();
			contentTra.DOLocalMoveY(height, 0.25f).OnComplete(delegate
			{
				isScoll = false;
			});
			if (!nextBtn.interactable)
			{
				nextBtn.interactable = true;
			}
			if (curPage == 1)
			{
				lastBtn.interactable = false;
			}
		}
	}

	private void NextBtnHander()
	{
		if (!isScoll)
		{
			isScoll = true;
			height += 406f;
			curPage++;
			curPageTxt.text = curPage.ToString();
			contentTra.DOLocalMoveY(height, 0.25f).OnComplete(delegate
			{
				isScoll = false;
			});
			if (!lastBtn.interactable)
			{
				lastBtn.interactable = true;
			}
			if (curPage == allPage)
			{
				nextBtn.interactable = false;
			}
		}
	}

	private void FishBtnHander()
	{
		Load.LoadScene2(ScenesHelper.CatchFishScene);
	}

	private void RingBtnHander()
	{
		Load.LoadScene2(ScenesHelper.ElectricRingScene);
	}

	private void ClubBtnHander()
	{
		Load.LoadScene2(ScenesHelper.ElectricClubScene);
	}

	private void FruitBtnHander()
	{
		Load.LoadScene2(ScenesHelper.FruitsScene);
	}

	private void PickUpFruitBtnHander()
	{
		Load.LoadScene2(ScenesHelper.PickUpBallScene);
	}

	private void BombBtnHander()
	{
		Load.LoadScene2(ScenesHelper.BombDisposalScene);
	}

	private void LetterBtnHander()
	{
		Load.LoadScene2(ScenesHelper.LetterShotHandScene);
	}

	private void WordFormationBtnHander()
	{
		Load.LoadScene2(ScenesHelper.WordFormationScene);
	}

	private void AncientPoetryBtnBtnHander()
	{
		Load.LoadScene2(ScenesHelper.AncientPoetryScene);
	}

	private void PerfectFillBtnHander()
	{
		Load.LoadScene2(ScenesHelper.PerfectFillScene);
	}

	private void EyeTrainBtnHander()
	{
		Load.LoadScene2(ScenesHelper.EyeTrainScene);
	}

	private void ExitBtnHander()
	{
		ScenesHelper.LoadScene(ScenesHelper.MetaverseSceneName);
	}

	private void Update()
	{
	}
}
public class LoginController : MonoBehaviour
{
	public Text versionTxt;

	public Button courseBtn;

	public Button experienceBtn;

	public Button exitBtn;

	private void Start()
	{
		courseBtn.onClick.AddListener(CourseBtnHander);
		experienceBtn.onClick.AddListener(ExperienceBtnHander);
		exitBtn.onClick.AddListener(ExitBtnHander);
	}

	private void Update()
	{
	}

	private void CourseBtnHander()
	{
	}

	private void ExperienceBtnHander()
	{
	}

	private void ExitBtnHander()
	{
	}
}
[Serializable]
public class M_TestTable
{
	[Serializable]
	public class cPart01
	{
		[Serializable]
		public class cPart02
		{
			[Serializable]
			public class cPart03
			{
				public int cid;

				public string words;

				public int score;

				public int voice_file_id;
			}

			public int cid;

			public string name;

			public List<cPart03> data;
		}

		public int cid;

		public string name;

		public List<cPart02> data;
	}

	public string tablename;

	public List<cPart01> data;
}
public class ScenarioDialogueItem
{
	public int id { get; set; }

	public int scenario_id { get; set; }

	public string dialogue_question { get; set; }

	public string dialogue_answer { get; set; }

	public string dialogue_tip { get; set; }

	public int sort { get; set; }
}
public class ScenarioRoot
{
	public int id { get; set; }

	public string scenario_name { get; set; }

	public string scenario_target { get; set; }

	public List<ScenarioDialogueItem> dialogue { get; set; }
}
public class M_DoctorAccount
{
	public string id;

	public string account;

	public string username;

	public string psw;
}
public class M_MemoryWords
{
	public List<string> m_listRecognizedWords = new List<string>();
}
public class M_NumsLinkAction
{
	public class NumsInfo
	{
		public string num;

		public float time;

		public ENumsState state;
	}

	public enum ENumsState
	{
		Wrong,
		Right
	}

	public List<NumsInfo> nums = new List<NumsInfo>();

	public DateTime startTime;

	public DateTime endTime;

	public ETestState state;

	public float usedsecond;

	public int Count => nums.Count;

	public M_NumsLinkAction()
	{
		startTime = DateTime.Now;
	}

	public void Finish(ETestState estate, float fusedsecond = 0f)
	{
		state = estate;
		endTime = DateTime.Now;
		usedsecond = fusedsecond;
	}
}
public class M_ViewListenWords
{
	public class wordInfo
	{
		public string word;

		public float time;
	}

	public List<wordInfo> words = new List<wordInfo>();

	public DateTime startTime;

	public DateTime endTime;

	public ETestState state;

	public int Count => words.Count;

	public M_ViewListenWords()
	{
		startTime = DateTime.Now;
	}

	public void Finish(ETestState estate)
	{
		state = estate;
		endTime = DateTime.Now;
	}

	public void Upload(Action callback = null)
	{
		endTime = DateTime.Now;
	}
}
public class M_VLWTime
{
	public class cVLWTime
	{
		public float firstTimeCount = 300f;

		public float SecondTimeCount = 1200f;

		public float maxWordLostTime = 15f;

		public float picShowDelay = 0.3f;

		public float audioShowDelay = 0.5f;

		public float wordHideDelay = 1.3f;

		public float nextWordDelay = 0.3f;
	}

	private static cVLWTime _inst;

	public static cVLWTime Inst
	{
		get
		{
			if (_inst == null)
			{
				if (Application.platform == RuntimePlatform.WindowsEditor || Application.platform == RuntimePlatform.WindowsPlayer)
				{
					string path = string.Concat(Directory.GetParent(Application.dataPath), "/Datas/Configs/vlwTimes");
					try
					{
						_inst = J_LitJson.JsonMapper.ToObject<cVLWTime>(File.ReadAllText(path));
						UnityEngine.Debug.Log("g" + _inst.picShowDelay);
					}
					catch (Exception ex)
					{
						UnityEngine.Debug.Log(ex.Message);
						_inst = new cVLWTime();
					}
				}
				else
				{
					_inst = new cVLWTime();
				}
			}
			return _inst;
		}
	}
}
public class ObjectPool<T>
{
	private List<ObjectPoolContainer<T>> list;

	private Dictionary<T, ObjectPoolContainer<T>> lookup;

	private Func<T> factoryFunc;

	private int lastIndex;

	public int Count => list.Count;

	public int CountUsedItems => lookup.Count;

	public ObjectPool(Func<T> factoryFunc, int initialSize)
	{
		this.factoryFunc = factoryFunc;
		list = new List<ObjectPoolContainer<T>>(initialSize);
		lookup = new Dictionary<T, ObjectPoolContainer<T>>(initialSize);
		Warm(initialSize);
	}

	private void Warm(int capacity)
	{
		for (int i = 0; i < capacity; i++)
		{
			CreateContainer();
		}
	}

	private ObjectPoolContainer<T> CreateContainer()
	{
		ObjectPoolContainer<T> objectPoolContainer = new ObjectPoolContainer<T>();
		objectPoolContainer.Item = factoryFunc();
		list.Add(objectPoolContainer);
		return objectPoolContainer;
	}

	public T GetItem()
	{
		ObjectPoolContainer<T> objectPoolContainer = null;
		for (int i = 0; i < list.Count; i++)
		{
			lastIndex++;
			if (lastIndex > list.Count - 1)
			{
				lastIndex = 0;
			}
			if (!list[lastIndex].Used)
			{
				objectPoolContainer = list[lastIndex];
				break;
			}
		}
		if (objectPoolContainer == null)
		{
			objectPoolContainer = CreateContainer();
		}
		objectPoolContainer.Consume();
		lookup.Add(objectPoolContainer.Item, objectPoolContainer);
		return objectPoolContainer.Item;
	}

	public void ReleaseItem(object item)
	{
		ReleaseItem((T)item);
	}

	public void ReleaseItem(T item)
	{
		if (lookup.ContainsKey(item))
		{
			lookup[item].Release();
			lookup.Remove(item);
		}
	}
}
public class ObjectPoolContainer<T>
{
	public T Item { get; set; }

	public bool Used { get; private set; }

	public void Consume()
	{
		Used = true;
	}

	public void Release()
	{
		Used = false;
	}
}
public class PvrTipController : MonoBehaviour
{
	public float Head_Hand_Dis = 0.3f;

	public Transform HeadTra;

	public Transform controller;

	public Transform HandTool;

	private bool lastControllerStatus;

	private bool lastHandToolStatus;

	private bool isHidedHandTool;

	private bool isResetHandTool = true;

	private void Start()
	{
	}

	private void Update()
	{
		if (HandTool == null)
		{
			return;
		}
		if (Vector3.Distance(HeadTra.position, controller.position) < 0.3f)
		{
			if (!isHidedHandTool)
			{
				SetHandTraHide();
			}
		}
		else if (!isResetHandTool)
		{
			ResetHandTraShow();
		}
	}

	private void SetHandTraHide()
	{
		isHidedHandTool = true;
		isResetHandTool = false;
		lastControllerStatus = controller.gameObject.activeSelf;
		lastHandToolStatus = HandTool.gameObject.activeSelf;
		HandTool.gameObject.SetActive(value: false);
		controller.gameObject.SetActive(value: true);
	}

	private void ResetHandTraShow()
	{
		isHidedHandTool = false;
		isResetHandTool = true;
		HandTool.gameObject.SetActive(lastHandToolStatus);
		controller.gameObject.SetActive(lastControllerStatus);
	}
}
public class baidu_WordToVoiceUtility
{
	private static string _audiosSaveDir;

	private static string token = "";

	private static string client_ID = "R6ABR1tDCEx4FkUQPvHIRgRg";

	private static string client_Secret = "5YhhzXFNlTAwRCKGGbjsSou3P0bmbXS0";

	private static string baiduAPI = "https://tsn.baidu.com/text2audio";

	private static string getTokenAPIPath = "https://openapi.baidu.com/oauth/2.0/token";

	private static string grant_Type = "client_credentials";

	private static string audiosSaveDir
	{
		get
		{
			if (string.IsNullOrEmpty(_audiosSaveDir))
			{
				_audiosSaveDir = Application.persistentDataPath + "/wordAudiosCache";
				if (!Directory.Exists(_audiosSaveDir))
				{
					Directory.CreateDirectory(_audiosSaveDir);
				}
			}
			return _audiosSaveDir;
		}
	}

	public static void J_GetWordAudio(string words, Action<AudioClip> callback, int per = 0)
	{
		Singleton<MiniMonoBehaviour>.Instance.StartCoroutine(_getWordAudio(words, delegate(AudioClip audioclip)
		{
			if (callback != null)
			{
				callback(audioclip);
			}
		}, per));
	}

	private static IEnumerator _getWordAudio(string words, Action<AudioClip> callback, int per = 0)
	{
		string text = audiosSaveDir + $"/{words.GetHashCode()}.mp3";
		if (File.Exists(text))
		{
			yield return loadLocalAudio("file://" + text, callback);
			yield break;
		}
		bool flag = false;
		token = PlayerPrefs.GetString("baidu_token");
		if (string.IsNullOrEmpty(token))
		{
			flag = true;
		}
		else if ((DateTime.Now - DateTime.FromFileTime(long.Parse(PlayerPrefs.GetString("baidu_token_DateTime")))).Days > 25)
		{
			flag = true;
		}
		if (flag)
		{
			UnityEngine.Debug.Log("--重新获取token");
			yield return _GetToken();
		}
		yield return _GetAudioString(words, callback, per);
	}

	private static IEnumerator _GetToken()
	{
		UnityEngine.Debug.Log("--开始获取token");
		WWWForm wWWForm = new WWWForm();
		wWWForm.AddField("grant_type", grant_Type);
		wWWForm.AddField("client_id", client_ID);
		wWWForm.AddField("client_secret", client_Secret);
		using UnityWebRequest getTW = UnityWebRequest.Post(getTokenAPIPath, wWWForm);
		yield return getTW.SendWebRequest();
		if (!getTW.isHttpError && !getTW.isNetworkError && getTW.isDone && string.IsNullOrEmpty(getTW.error))
		{
			token = LitJson.JsonMapper.ToObject(getTW.downloadHandler.text)["access_token"].ToString();
			PlayerPrefs.SetString("baidu_token", token);
			PlayerPrefs.SetString("baidu_token_DateTime", DateTime.Now.ToFileTime().ToString());
			UnityEngine.Debug.Log("获取百度用户令牌 初始化完成");
		}
		else
		{
			UnityEngine.Debug.LogError("error:" + getTW.error);
		}
	}

	private static IEnumerator _GetAudioString(string strwords, Action<AudioClip> callback, int per = 0)
	{
		WWWForm wWWForm = new WWWForm();
		wWWForm.AddField("tex", strwords);
		wWWForm.AddField("tok", token);
		wWWForm.AddField("cuid", SystemInfo.deviceUniqueIdentifier);
		wWWForm.AddField("ctp", 1);
		wWWForm.AddField("per", per);
		wWWForm.AddField("aue", 3);
		wWWForm.AddField("lan", "zh");
		wWWForm.AddField("spd", "5");
		using UnityWebRequest webRequest = UnityWebRequest.Post(baiduAPI, wWWForm);
		webRequest.downloadHandler = new DownloadHandlerAudioClip(baiduAPI, AudioType.MPEG);
		yield return webRequest.SendWebRequest();
		if (!webRequest.isHttpError && !webRequest.isNetworkError && webRequest.isDone && string.IsNullOrEmpty(webRequest.error))
		{
			File.WriteAllBytes(audiosSaveDir + $"/{strwords.GetHashCode()}.mp3", webRequest.downloadHandler.data);
			callback?.Invoke(DownloadHandlerAudioClip.GetContent(webRequest));
		}
		else
		{
			UnityEngine.Debug.LogError("error:" + webRequest.error);
		}
	}

	private static IEnumerator loadLocalAudio(string path, Action<AudioClip> callback)
	{
		using UnityWebRequest webRequest = UnityWebRequest.Get(path);
		webRequest.downloadHandler = new DownloadHandlerAudioClip(path, AudioType.MPEG);
		yield return webRequest.SendWebRequest();
		if (!webRequest.isHttpError && !webRequest.isNetworkError && webRequest.isDone && string.IsNullOrEmpty(webRequest.error))
		{
			callback?.Invoke(DownloadHandlerAudioClip.GetContent(webRequest));
		}
		else
		{
			UnityEngine.Debug.LogError("error:" + webRequest.error);
		}
	}
}
[RequireComponent(typeof(Image))]
public class ImageAlphaHitThresholdModify : MonoBehaviour
{
	private Image image;

	public float m_alphaHitTestMinimumThreshold = 0.5f;

	private void Start()
	{
		image = GetComponent<Image>();
		if (image != null)
		{
			image.alphaHitTestMinimumThreshold = m_alphaHitTestMinimumThreshold;
		}
	}
}
public static class J_Utility
{
	public static void RandomList<T>(this List<T> list)
	{
		new List<T>(list.Count);
		for (int i = 0; i < list.Count; i++)
		{
			int index = UnityEngine.Random.Range(i, list.Count);
			T value = list[i];
			list[i] = list[index];
			list[index] = value;
		}
	}

	public static void RandomArray<T>(this T[] array)
	{
		for (int i = 0; i < array.Length; i++)
		{
			int num = UnityEngine.Random.Range(i, array.Length);
			T val = array[i];
			array[i] = array[num];
			array[num] = val;
		}
	}

	public static double getLevenshteinDistance(string str1, string str2)
	{
		char[] array = str1.ToCharArray();
		char[] array2 = str2.ToCharArray();
		int[] array3 = new int[str1.Length + 1];
		int[] array4 = new int[array3.Length];
		array3[0] = 0;
		for (int i = 1; i < array3.Length; i++)
		{
			array3[i] = i;
		}
		for (int j = 0; j < array2.Length; j++)
		{
			array4[0] = j + 1;
			for (int k = 0; k < array.Length; k++)
			{
				int num;
				if (array2[j] == array[k])
				{
					num = array3[k];
				}
				else
				{
					int a = array3[k] + 1;
					int b = array3[k + 1] + 1;
					num = Mathf.Min(a, b);
					num = Mathf.Min(num, array4[k] + 1);
				}
				array4[k + 1] = num;
			}
			array4.CopyTo(array3, 0);
		}
		return (double)array4[^1] / (double)Mathf.Max(str1.Length, str2.Length);
	}

	public static decimal GetSimilarityWith(string sourceString, string str)
	{
		decimal num = 2m;
		decimal num2 = 1m;
		decimal num3 = 1m;
		char[] array = sourceString.ToCharArray();
		char[] array2 = str.ToCharArray();
		int num4 = array.Intersect(array2).Count();
		int num5 = array.Length - num4;
		int num6 = array2.Length - num4;
		return num * (decimal)num4 / (num * (decimal)num4 + num2 * (decimal)num6 + num3 * (decimal)num5);
	}
}
public class public_DelayTimeAction : MonoBehaviour
{
	public float fDelayTime = 1f;

	public UnityEvent eventDelayAction;

	public void J_StartClock()
	{
		StartCoroutine(yieldAction());
	}

	private IEnumerator yieldAction()
	{
		yield return new WaitForSeconds(fDelayTime);
		eventDelayAction.Invoke();
	}
}
public class public_DelayTimeActionOnEnable : MonoBehaviour
{
	public float fDelayTime = 1f;

	public UnityEvent eventDelayAction;

	private void OnEnable()
	{
		if (!(base.gameObject.name == "-------引导Manager----------") || fDelayTime != 0.2f)
		{
			StartCoroutine(yieldAction());
		}
	}

	private IEnumerator yieldAction()
	{
		yield return new WaitForSeconds(fDelayTime);
		eventDelayAction.Invoke();
	}
}
public class public_MonoEvent : MonoBehaviour
{
	public UnityEvent eventAwake;

	public UnityEvent eventStart;

	public UnityEvent eventOnEnable;

	public UnityEvent eventOnDisable;

	public UnityEvent eventOnMouseUpAsButton;

	public UnityEvent eventOnMouseDown;

	private void Awake()
	{
		eventAwake.Invoke();
	}

	private void Start()
	{
		eventStart.Invoke();
	}

	private void OnEnable()
	{
		eventOnEnable.Invoke();
	}

	private void OnDisable()
	{
		eventOnDisable.Invoke();
	}

	public void OnMouseUpAsButton()
	{
		eventOnMouseUpAsButton.Invoke();
	}

	public void OnMouseDown()
	{
		eventOnMouseDown.Invoke();
	}
}
public class public_TriggerActionWithCondition : MonoBehaviour
{
	public bool shouldTrigger = true;

	[Header("ShouldTrigger = True 时")]
	public UnityEvent eventTriggerAction;

	[Header("ShouldTrigger = False 时")]
	public UnityEvent eventTriggerAction_ConditionNotMatch;

	public void J_SetTriggerEnable(bool isEnable)
	{
		shouldTrigger = isEnable;
	}

	public void J_TriggerAction()
	{
		if (shouldTrigger)
		{
			eventTriggerAction.Invoke();
		}
		else
		{
			eventTriggerAction_ConditionNotMatch.Invoke();
		}
	}
}
public class AliyunVoice : MonoBehaviour
{
	public Action<string> RecStateChangeAction;

	public Action<string> RecCallbackAction;

	public Action<float> VolumnCallbackAction;

	private AndroidJavaClass ajc;

	private AndroidJavaObject ajo;

	private List<float> volumns = new List<float>();

	private bool isInit;

	private void Start()
	{
		init();
	}

	public void init()
	{
		try
		{
			ajc = new AndroidJavaClass("com.Guava.ADHD.AliyunVoice");
			ajc.CallStatic("start");
			ajo = ajc.GetStatic<AndroidJavaObject>("instance");
			if (ajo == null)
			{
				return;
			}
			string url = UrlUtils.baseUrl_adhd + UrlUtils.Aliyun_Token;
			UnityWebRequestHelper.Instance.Get(url, delegate(RequestStatus status, string result)
			{
				string text = J_LitJson.JsonMapper.ToObject(result)["data"].ToString();
				string text2 = ajo.Call<string>("Init", new object[6]
				{
					"3CvZr9CLdQCBSaZ0",
					text,
					base.gameObject.name,
					"OnRecStateChange",
					"OnRecCallback",
					"OnVolumnCallback"
				});
				if (text2 == "0")
				{
					UnityEngine.Debug.LogError("success!!!!!!");
					isInit = true;
				}
				else
				{
					UnityEngine.Debug.LogError("fiel:" + text2);
				}
			}, isToken: true);
		}
		catch (Exception ex)
		{
			UnityEngine.Debug.LogError(ex.Message + ex.InnerException?.Message);
		}
	}

	public bool StartRec()
	{
		if (!isInit)
		{
			UnityEngine.Debug.LogError("please init!!!");
			return false;
		}
		int num = ajo.Call<int>("Start", Array.Empty<object>());
		if (num == 0)
		{
			return true;
		}
		UnityEngine.Debug.LogError("start record fail：" + num);
		return false;
	}

	public byte[] StopRec_old()
	{
		byte[] array = ajo.Call<byte[]>("Stop", Array.Empty<object>());
		if (array != null)
		{
			return array;
		}
		UnityEngine.Debug.LogError("结束录音失败：" + array);
		return null;
	}

	public void StopRec()
	{
		int num = ajo.Call<int>("Stop", Array.Empty<object>());
		if (num != 0)
		{
			UnityEngine.Debug.LogError("end record fail：" + num);
		}
	}

	private void OnDestroy()
	{
		if (ajo != null)
		{
			ajo.Call("Destory");
		}
	}

	public void OnRecStateChange(string msg)
	{
		RecStateChangeAction?.Invoke(msg);
	}

	public void OnRecCallback(string msg)
	{
		RecCallbackAction?.Invoke(msg);
	}

	public void OnVolumnCallback(string val)
	{
		VolumnCallbackAction?.Invoke(float.Parse(val));
	}

	private static IEnumerator HttpGet(string uri, Action<string> cb)
	{
		new WWWForm();
		using UnityWebRequest webRequest = UnityWebRequest.Get(uri);
		yield return webRequest.SendWebRequest();
		if (webRequest.isHttpError || webRequest.isNetworkError)
		{
			UnityEngine.Debug.LogError(webRequest.error);
			yield break;
		}
		try
		{
			cb(webRequest.downloadHandler.text);
		}
		catch (Exception ex)
		{
			UnityEngine.Debug.LogError("json format error:" + webRequest.downloadHandler.text);
			UnityEngine.Debug.LogError(ex.Message);
		}
	}
}
public class ArrowShake : MonoBehaviour
{
	public float degreesPerSecond = 15f;

	public float amplitude = 0.5f;

	public float frequency = 1f;

	public Vector3 posOffset;

	private Vector3 tempPos;

	private void OnEnable()
	{
		posOffset = base.transform.position;
	}

	private void Start()
	{
	}

	private void Update()
	{
		base.transform.Rotate(new Vector3(0f, Time.deltaTime * degreesPerSecond, 0f), Space.World);
		tempPos = posOffset;
		tempPos.y += Mathf.Sin(Time.fixedTime * (float)Math.PI * frequency) * amplitude;
		base.transform.position = tempPos;
	}
}
public class AutoClose : MonoBehaviour
{
	public float closeTime = 1f;

	private bool IsShow;

	private float timer;

	private void Start()
	{
	}

	private void Update()
	{
		if (IsShow)
		{
			timer -= Time.deltaTime;
			if (timer <= 0f)
			{
				IsShow = false;
				base.gameObject.SetActive(value: false);
			}
		}
	}

	private void OnEnable()
	{
		timer = closeTime;
		IsShow = true;
	}
}
public class BallMotion_A2B : MonoBehaviour
{
	public Transform pFrom;

	public Transform pTo;

	public float m_fPassTime = 2f;

	public float m_fGravity = -5f;

	private float fPassTime;

	private float fGravity;

	private Vector3 speed;

	private float dpassedTime;

	public Action m_actionOnReachPoint;

	private bool isStartMove;

	private void Start()
	{
	}

	public void StartThrow()
	{
		Vector3 vFrom = (pFrom ? pFrom.position : base.transform.position);
		J_StartMoveFromTo(vFrom, pTo.position);
	}

	private void FixedUpdate()
	{
		if (!isStartMove)
		{
			return;
		}
		Vector3 vector = speed * Time.deltaTime + new Vector3(0f, fGravity * (dpassedTime += Time.deltaTime), 0f) * Time.deltaTime;
		base.transform.position += vector;
		if (dpassedTime >= fPassTime)
		{
			J_StopMove();
			if (m_actionOnReachPoint != null)
			{
				m_actionOnReachPoint();
			}
		}
	}

	public void J_StartMoveFromTo(Vector3 vFrom, Vector3 vTo)
	{
		fPassTime = m_fPassTime;
		fGravity = m_fGravity;
		base.transform.position = vFrom;
		speed = new Vector3((vTo.x - vFrom.x) / fPassTime, (vTo.y - vFrom.y) / fPassTime - 0.5f * fGravity * fPassTime, (vTo.z - vFrom.z) / fPassTime);
		isStartMove = true;
		dpassedTime = 0f;
	}

	public void J_StopMove()
	{
		isStartMove = false;
	}
}
public class BannerController : MonoBehaviour
{
	public Material leftone;

	public Material lefttwo;

	public Material rightone;

	public Material righttwo;

	public RawImage logo_RawImage;

	private string path = "Banner";

	private BannerDatas bannerDatas;

	private void Start()
	{
		string empty = string.Empty;
		string baseUrl_adhd = UrlUtils.baseUrl_adhd;
		LoadManager.CheckPath(UrlUtils.persistentDataPath + path);
		if (LoadManager.IsLocalOperate)
		{
			empty = LoadManager.ReadJson(path + "/LoginBannerDatas.json");
			if (string.IsNullOrEmpty(empty))
			{
				bannerDatas = InitDatas(empty);
			}
			else
			{
				bannerDatas = J_LitJson.JsonMapper.ToObject<BannerDatas>(empty);
			}
			baseUrl_adhd += UrlUtils.bannerLogin;
			UnityWebRequestHelper.Instance.Get(baseUrl_adhd, delegate(RequestStatus status, string result)
			{
				if (status == RequestStatus.success)
				{
					LoadTextures(result);
				}
			});
			if ((bool)logo_RawImage)
			{
				logo_RawImage.gameObject.SetActive(value: false);
			}
			return;
		}
		empty = LoadManager.ReadJson(path + "/InsideBannerDatas.json");
		if (string.IsNullOrEmpty(empty))
		{
			bannerDatas = InitDatas(empty);
		}
		else
		{
			bannerDatas = J_LitJson.JsonMapper.ToObject<BannerDatas>(empty);
		}
		baseUrl_adhd += UrlUtils.bannerInside;
		UnityWebRequestHelper.Instance.Get(baseUrl_adhd, delegate(RequestStatus status, string result)
		{
			if (status == RequestStatus.success)
			{
				LoadTextures(result);
			}
		}, isToken: true);
		if ((bool)logo_RawImage && LoadManager.userData != null && !string.IsNullOrEmpty(LoadManager.userData.data.organization_logo_url))
		{
			LoadLogo();
		}
		else if ((bool)logo_RawImage)
		{
			logo_RawImage.gameObject.SetActive(value: false);
		}
	}

	private void LoadLogo()
	{
		string text = LoadManager.ReadJson(path + "/LogoData.json");
		LogoData logoData = ((!string.IsNullOrEmpty(text)) ? J_LitJson.JsonMapper.ToObject<LogoData>(text) : InitData(text));
		if (string.IsNullOrEmpty(logoData.imgurl))
		{
			LoadLogoTexture(logoData);
		}
		else if (!logoData.imgurl.Equals(LoadManager.userData.data.organization_logo_url))
		{
			LoadManager.DeleteFile(logoData.relativePath);
			LoadLogoTexture(logoData);
		}
		else
		{
			LoadManager.LoadTextures("file://" + UrlUtils.persistentDataPath + logoData.relativePath, delegate(Texture texture, byte[] bytes)
			{
				SetLogoTexture(texture);
			});
		}
		LoadManager.SaveJson(path + "/LogoData.json", J_LitJson.JsonMapper.ToJson(logoData));
	}

	private void LoadLogoTexture(LogoData data)
	{
		string fileName = LoadManager.GetFileName(LoadManager.userData.data.organization_logo_url);
		data.imgurl = LoadManager.userData.data.organization_logo_url;
		data.relativePath = path + "/" + fileName;
		LoadManager.LoadTextures(LoadManager.userData.data.organization_logo_url, delegate(Texture texture, byte[] bytes)
		{
			SetLogoTexture(texture);
			LoadManager.CreateFile(UrlUtils.persistentDataPath + "/" + path, fileName, bytes);
		});
	}

	private void SetLogoTexture(Texture texture)
	{
		RectTransform component = logo_RawImage.GetComponent<RectTransform>();
		float y = component.sizeDelta.x * (float)texture.height / (float)texture.width;
		UnityEngine.Debug.Log(component.sizeDelta.x + " " + texture.width + " " + texture.height);
		Vector2 sizeDelta = new Vector2(component.sizeDelta.x, y);
		component.sizeDelta = sizeDelta;
		logo_RawImage.texture = texture;
	}

	private static BannerDatas InitDatas(string json)
	{
		BannerDatas bannerDatas = J_LitJson.JsonMapper.ToObject<BannerDatas>(json);
		if (bannerDatas == null)
		{
			bannerDatas = new BannerDatas();
			bannerDatas.data = new List<BannerData>();
		}
		return bannerDatas;
	}

	private static LogoData InitData(string json)
	{
		LogoData logoData = J_LitJson.JsonMapper.ToObject<LogoData>(json);
		if (logoData == null)
		{
			logoData = new LogoData();
		}
		return logoData;
	}

	private void LoadTextures(string result)
	{
		foreach (BannerData datum in J_LitJson.JsonMapper.ToObject<BannerDatas>(result).data)
		{
			if (datum.imgplace.Equals("leftone"))
			{
				LoadTexture(bannerDatas, datum, leftone, "leftone");
			}
			else if (datum.imgplace.Equals("lefttwo"))
			{
				LoadTexture(bannerDatas, datum, lefttwo, "lefttwo");
			}
			else if (datum.imgplace.Equals("rightone"))
			{
				LoadTexture(bannerDatas, datum, rightone, "rightone");
			}
			else
			{
				LoadTexture(bannerDatas, datum, righttwo, "righttwo");
			}
		}
		if (LoadManager.IsLocalOperate)
		{
			LoadManager.SaveJson(path + "/LoginBannerDatas.json", J_LitJson.JsonMapper.ToJson(bannerDatas));
		}
		else
		{
			LoadManager.SaveJson(path + "/InsideBannerDatas.json", J_LitJson.JsonMapper.ToJson(bannerDatas));
		}
	}

	private void LoadTexture(BannerDatas datas, BannerData item, Material place, string imgplace)
	{
		if (datas.data.Count > 0)
		{
			BannerData bannerData = datas.data.Find((BannerData x) => x.imgplace.Equals(imgplace));
			if (bannerData == null)
			{
				CreateData(datas, item, place);
				return;
			}
			if (bannerData.imgurl.Equals(item.imgurl))
			{
				LoadManager.LoadTextures("file://" + UrlUtils.persistentDataPath + bannerData.relativePath, delegate(Texture texture, byte[] bytes)
				{
					place.SetTexture("_MainTex", texture);
				});
				return;
			}
			LoadManager.DeleteFile(bannerData.relativePath);
			datas.data.Remove(bannerData);
			CreateData(datas, item, place);
			UnityEngine.Debug.Log(imgplace);
		}
		else
		{
			CreateData(datas, item, place);
		}
	}

	private void CreateData(BannerDatas datas, BannerData item, Material place)
	{
		datas.data.Add(item);
		string fileName = LoadManager.GetFileName(item.imgurl);
		item.relativePath = path + "/" + fileName;
		LoadManager.LoadTextures(item.imgurl, delegate(Texture texture, byte[] bytes)
		{
			place.SetTexture("_MainTex", texture);
			LoadManager.CreateFile(UrlUtils.persistentDataPath + "/" + path, fileName, bytes);
		});
	}

	private void Update()
	{
	}
}
public class BatteryController : MonoBehaviour
{
	public Image batteryImg;

	public Text batteryTxt;

	private float battery;

	private float timer = 5f;

	private void Start()
	{
		ShowBattery(ToBServiceHelper.GetElectric_Quantity());
	}

	private void Update()
	{
		timer -= Time.deltaTime;
		if (timer <= 0f)
		{
			timer = 5f;
			ShowBattery(ToBServiceHelper.GetElectric_Quantity());
		}
	}

	private void OnDestroy()
	{
		VolumePowerBrightness.UPvr_StopBatteryReceiver();
	}

	public void UPvr_SetBattery(string s)
	{
		LoadManager.ELECTRIC_QUANTITY = float.Parse(s) * 100f + "%";
		ShowBattery(LoadManager.ELECTRIC_QUANTITY);
	}

	public bool setBattery(string s)
	{
		LoadManager.ELECTRIC_QUANTITY = s + "%";
		ShowBattery(LoadManager.ELECTRIC_QUANTITY);
		return true;
	}

	private void ShowBattery(string s)
	{
		if (string.IsNullOrEmpty(s))
		{
			return;
		}
		batteryTxt.text = s;
		battery = float.Parse(s.Replace("%", ""));
		if (battery > 20f)
		{
			if (batteryImg.color != Color.green)
			{
				batteryImg.color = Color.green;
			}
		}
		else if (batteryImg.color != Color.red)
		{
			batteryImg.color = Color.red;
		}
	}
}
public class BindTobServiceController : MonoBehaviour
{
	private void Start()
	{
		Init();
	}

	private void Update()
	{
	}

	private void Init()
	{
		AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
		ToBServiceHelper.javaPlayer = new AndroidJavaObject("com.guava.miracast.UnityToMiracast");
		if (ToBServiceHelper.javaPlayer == null)
		{
			UnityEngine.Debug.Log("jianzhao javaPlayer is null!!");
		}
		ToBServiceHelper.javaPlayer.Call("Init", @static);
		ToBServiceHelper.javaPlayer.Call("BindTobService");
	}
}
public class ButtonEffect : MonoBehaviour, IPointerEnterHandler, IEventSystemHandler, IPointerExitHandler, IPointerDownHandler
{
	private Transform hightlighted;

	private Transform pressed;

	private bool isEnter;

	public void OnPointerDown(PointerEventData eventData)
	{
		hightlighted.DOScale(Vector3.one, 0.25f);
		pressed.gameObject.SetActive(value: true);
	}

	public void OnPointerUp(PointerEventData eventData)
	{
		isEnter = false;
		pressed.gameObject.SetActive(value: false);
	}

	public void OnPointerEnter(PointerEventData eventData)
	{
		if (!isEnter)
		{
			hightlighted.gameObject.SetActive(value: true);
			hightlighted.DOScale(new Vector3(1.1f, 1.2f, 1f), 0.25f);
			isEnter = true;
		}
	}

	public void OnPointerExit(PointerEventData eventData)
	{
		isEnter = false;
		hightlighted.gameObject.SetActive(value: false);
		hightlighted.DOScale(Vector3.one, 0.25f);
	}

	private void Start()
	{
		isEnter = false;
		hightlighted = base.transform.Find("hightlighted");
		pressed = hightlighted.Find("pressed");
		hightlighted.gameObject.SetActive(value: false);
		pressed.gameObject.SetActive(value: false);
		hightlighted.localScale = Vector3.one;
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		isEnter = false;
		hightlighted.gameObject.SetActive(value: false);
		pressed.gameObject.SetActive(value: false);
	}
}
public class ChinarWeb : MonoBehaviour
{
	[DllImport("winInet.dll")]
	private static extern bool InternetGetConnectedState(ref int dwFlag, int dwReserved);

	private void Start()
	{
	}

	private void Update()
	{
	}

	private static bool IsConnectedInternet()
	{
		int dwFlag = 0;
		if (!InternetGetConnectedState(ref dwFlag, 0))
		{
			PrintR("当前没有联网，请您先联网后再进行操作！");
			if ((dwFlag & 0x14) == 0)
			{
				return false;
			}
			UnityEngine.Debug.LogWarning("本地系统处于脱机模式。");
			return false;
		}
		if (((uint)dwFlag & (true ? 1u : 0u)) != 0)
		{
			Print("调制解调器上网。");
			return true;
		}
		if (((uint)dwFlag & 2u) != 0)
		{
			Print("网卡上网。");
			return true;
		}
		if (((uint)dwFlag & 4u) != 0)
		{
			Print("代理服务器上网。");
			return true;
		}
		if (((uint)dwFlag & 0x40u) != 0)
		{
			Print("虽然可以联网，但可能链接也可能不连接。");
			return true;
		}
		return false;
	}

	public static void Print(string str)
	{
		UnityEngine.Debug.Log($"<b><color=lime><size={12}>{str}</size></color></b>");
	}

	public static void PrintR(string str)
	{
		UnityEngine.Debug.Log($"<b><color=red><size={12}>{str}</size></color></b>");
	}

	public static bool ChinarPing(string url)
	{
		bool result = true;
		System.Net.NetworkInformation.Ping ping = new System.Net.NetworkInformation.Ping();
		try
		{
			PingReply pingReply = ping.Send(url);
			if (pingReply != null && pingReply.Status != 0)
			{
				result = false;
			}
			if (pingReply != null)
			{
				MonoBehaviour.print("Ping 网址：<" + url + ">------状态：" + pingReply.Status);
			}
		}
		catch
		{
			result = false;
		}
		return result;
	}
}
public class ClearSceneData : MonoBehaviour
{
	private UnityEngine.AsyncOperation async;

	private static string nextSceneName;

	private void Awake()
	{
		UnityEngine.Object[] array = Resources.FindObjectsOfTypeAll<Material>();
		UnityEngine.Object[] array2 = array;
		for (int i = 0; i < array2.Length; i++)
		{
			array2[i] = null;
		}
		array = Resources.FindObjectsOfTypeAll<Texture>();
		UnityEngine.Object[] array3 = array;
		for (int j = 0; j < array3.Length; j++)
		{
			array3[j] = null;
		}
		Resources.UnloadUnusedAssets();
		GC.Collect();
		GC.WaitForPendingFinalizers();
		GC.Collect();
	}

	private void Start()
	{
		StartCoroutine("AsyncLoadScene", nextSceneName);
	}

	public static void LoadLevel(string _nextSceneName)
	{
		nextSceneName = _nextSceneName;
		SceneManager.LoadScene("ClearScene");
	}

	private IEnumerator AsyncLoadScene(string sceneName)
	{
		async = SceneManager.LoadSceneAsync(sceneName);
		yield return async;
	}

	private void OnDestroy()
	{
		async = null;
	}
}
public class ConnectAnimation : MonoBehaviour
{
	private Text connectTxt;

	private float timer = 0.25f;

	private int num;

	private void Start()
	{
		connectTxt = GetComponent<Text>();
	}

	private void Update()
	{
		if (base.gameObject.activeSelf)
		{
			timer -= Time.deltaTime;
			if (timer <= 0f)
			{
				timer = 0.25f;
				num++;
				SetNum(num);
			}
		}
	}

	private void SetNum(int n)
	{
		if (n % 4 == 0)
		{
			connectTxt.text = "";
		}
		else if (n % 4 == 1)
		{
			connectTxt.text = ".";
		}
		else if (n % 4 == 2)
		{
			connectTxt.text = "..";
		}
		else if (n % 4 == 3)
		{
			connectTxt.text = "...";
		}
	}
}
public class CountDownBtn : MonoBehaviour
{
	public float countDown = 3f;

	private Button btn;

	private Text text;

	private string lastTxt;

	private bool isShow;

	private float timer;

	private void Awake()
	{
		btn = GetComponent<Button>();
		text = GetComponentInChildren<Text>();
		lastTxt = text.text;
	}

	private void Update()
	{
		if (isShow)
		{
			timer -= 0.02f;
			text.text = "(" + Math.Ceiling(timer) + ")" + lastTxt;
			if (timer <= 0f)
			{
				text.text = lastTxt;
				isShow = false;
				btn.interactable = true;
			}
		}
	}

	private void OnEnable()
	{
		timer = countDown;
		isShow = true;
		btn.interactable = false;
	}
}
public class GetPathProcess : MonoBehaviour
{
	private Spline m_spline;

	private void Start()
	{
	}

	private void Update()
	{
	}

	public void CalcuteLoaction()
	{
	}

	public void SetSpline(Spline spline)
	{
		m_spline = spline;
	}

	public float GetProjectionSample(Vector3 pointToProject)
	{
		if (m_spline == null)
		{
			return 0f;
		}
		pointToProject = m_spline.transform.InverseTransformPoint(pointToProject);
		CurveSample curveSample = default(CurveSample);
		float num = float.MaxValue;
		float num2 = 0f;
		float num3 = 0f;
		float length = m_spline.Length;
		for (int i = 0; i < m_spline.curves.Count; i++)
		{
			CubicBezierCurve cubicBezierCurve = m_spline.curves[i];
			CurveSample projectionSample = cubicBezierCurve.GetProjectionSample(pointToProject);
			float magnitude = (projectionSample.location - pointToProject).magnitude;
			if (magnitude < num)
			{
				num = magnitude;
				curveSample = projectionSample;
				num2 += num3;
			}
			num3 = cubicBezierCurve.Length;
		}
		num2 += curveSample.distanceInCurve;
		if (length == 0f)
		{
			return 0f;
		}
		return num2 / length;
	}
}
public class MicroPhoneManager : MonoBehaviour
{
	private bool micConnected;

	private int minFreq;

	private int maxFreq;

	public AudioClip RecordedClip;

	public AudioSource audioSource;

	private string fileName;

	private byte[] data;

	private string _strrecordSaveDir;

	private bool isRecording;

	public string m_strRecordSavedir
	{
		get
		{
			if (string.IsNullOrEmpty(_strrecordSaveDir))
			{
				_strrecordSaveDir = Application.persistentDataPath + "/RecordAudios";
				if (!Directory.Exists(m_strRecordSavedir))
				{
					Directory.CreateDirectory(m_strRecordSavedir);
				}
			}
			return _strrecordSaveDir;
		}
	}

	public bool IsRecording => isRecording;

	public byte[] GetRecordVoiceFileDatas(string audioName)
	{
		if (File.Exists(m_strRecordSavedir + "/" + audioName + ".wav"))
		{
			return File.ReadAllBytes(m_strRecordSavedir + "/" + audioName + ".wav");
		}
		return null;
	}

	private void Start()
	{
		if (Microphone.devices.Length == 0)
		{
			UnityEngine.Debug.Log("缺少麦克风设备！");
			return;
		}
		UnityEngine.Debug.Log("设备名称为：" + Microphone.devices[0].ToString() + "请点击Start开始录音！");
		micConnected = true;
		Microphone.GetDeviceCaps(null, out minFreq, out maxFreq);
		if (minFreq == 0 && maxFreq == 0)
		{
			maxFreq = 44100;
		}
	}

	public bool BeginRecord()
	{
		if (micConnected)
		{
			if (!Microphone.IsRecording(null))
			{
				isRecording = true;
				RecordedClip = Microphone.Start(null, loop: false, 60, maxFreq);
				UnityEngine.Debug.Log("开始录音！");
				return true;
			}
			UnityEngine.Debug.Log("正在录音中，请勿重复点击Start！");
			return false;
		}
		UnityEngine.Debug.Log("请确认麦克风设备是否已连接！");
		return false;
	}

	public void StopRecord(string audioName)
	{
		isRecording = false;
		data = GetRealAudio(ref RecordedClip);
		Microphone.End(null);
		UnityEngine.Debug.Log("录音结束！");
		SaveRecord(audioName);
	}

	public void Player()
	{
		if (!Microphone.IsRecording(null))
		{
			audioSource.clip = RecordedClip;
			audioSource.Play();
			UnityEngine.Debug.Log("正在播放录音！");
		}
		else
		{
			UnityEngine.Debug.Log("正在录音中，请先停止录音！");
		}
	}

	public void SaveRecord(string audioName)
	{
		if (!Microphone.IsRecording(null))
		{
			using (FileStream fileStream = CreateEmpty(m_strRecordSavedir + "/" + audioName + ".wav"))
			{
				fileStream.Write(data, 0, data.Length);
				WriteHeader(fileStream, RecordedClip);
				return;
			}
		}
		UnityEngine.Debug.Log("正在录音中，请先停止录音！");
	}

	public byte[] GetRealAudio(ref AudioClip recordedClip)
	{
		int num = Microphone.GetPosition(null);
		if (num <= 0 || num > recordedClip.samples)
		{
			num = recordedClip.samples;
		}
		float[] array = new float[num * recordedClip.channels];
		recordedClip.GetData(array, 0);
		recordedClip = AudioClip.Create(recordedClip.name, num, recordedClip.channels, recordedClip.frequency, stream: false);
		recordedClip.SetData(array, 0);
		int num2 = 32767;
		byte[] array2 = new byte[array.Length * 2];
		for (int i = 0; i < array.Length; i++)
		{
			byte[] bytes = BitConverter.GetBytes((short)(array[i] * (float)num2));
			array2[i * 2] = bytes[0];
			array2[i * 2 + 1] = bytes[1];
		}
		UnityEngine.Debug.Log("position=" + num + "  outData.leng=" + array2.Length);
		return array2;
	}

	public static void WriteHeader(FileStream stream, AudioClip clip)
	{
		int frequency = clip.frequency;
		int channels = clip.channels;
		int samples = clip.samples;
		stream.Seek(0L, SeekOrigin.Begin);
		byte[] bytes = Encoding.UTF8.GetBytes("RIFF");
		stream.Write(bytes, 0, 4);
		byte[] bytes2 = BitConverter.GetBytes(stream.Length - 8);
		stream.Write(bytes2, 0, 4);
		byte[] bytes3 = Encoding.UTF8.GetBytes("WAVE");
		stream.Write(bytes3, 0, 4);
		byte[] bytes4 = Encoding.UTF8.GetBytes("fmt ");
		stream.Write(bytes4, 0, 4);
		byte[] bytes5 = BitConverter.GetBytes(16);
		stream.Write(bytes5, 0, 4);
		byte[] bytes6 = BitConverter.GetBytes((ushort)1);
		stream.Write(bytes6, 0, 2);
		byte[] bytes7 = BitConverter.GetBytes(channels);
		stream.Write(bytes7, 0, 2);
		byte[] bytes8 = BitConverter.GetBytes(frequency);
		stream.Write(bytes8, 0, 4);
		byte[] bytes9 = BitConverter.GetBytes(frequency * channels * 2);
		stream.Write(bytes9, 0, 4);
		ushort value = (ushort)(channels * 2);
		stream.Write(BitConverter.GetBytes(value), 0, 2);
		byte[] bytes10 = BitConverter.GetBytes((ushort)16);
		stream.Write(bytes10, 0, 2);
		byte[] bytes11 = Encoding.UTF8.GetBytes("data");
		stream.Write(bytes11, 0, 4);
		byte[] bytes12 = BitConverter.GetBytes(samples * channels * 2);
		stream.Write(bytes12, 0, 4);
	}

	public float[] J_GetMaxVolume(int dataLENGTH)
	{
		return GetMaxVolume(dataLENGTH);
	}

	private float[] GetMaxVolume(int dataLENGTH)
	{
		if (RecordedClip == null)
		{
			return null;
		}
		float[] result = new float[dataLENGTH];
		int num = Microphone.GetPosition(null) - dataLENGTH + 1;
		if (num < 0)
		{
			return result;
		}
		RecordedClip.GetData(result, num);
		return result;
	}

	private FileStream CreateEmpty(string filepath)
	{
		FileStream fileStream = new FileStream(filepath, FileMode.Create);
		byte value = 0;
		for (int i = 0; i < 44; i++)
		{
			fileStream.WriteByte(value);
		}
		return fileStream;
	}
}
public class PicoVR_ControllerDemoSimulator : MonoBehaviour
{
}
public class PingNetwork : MonoBehaviour
{
	private Action<bool> action;

	private void Start()
	{
	}

	private void Update()
	{
	}

	public void CheckNetStatus(string ServerIP, Action<bool> callBack)
	{
		action = callBack;
		StartCoroutine(CheckNetStatus(ServerIP));
	}

	private IEnumerator CheckNetStatus(string ServerIP)
	{
		UnityEngine.Ping ping = new UnityEngine.Ping(ServerIP);
		int nTime = 0;
		while (!ping.isDone)
		{
			yield return new WaitForSeconds(0.1f);
			if (nTime > 50)
			{
				UnityEngine.Debug.Log("连接失败 : " + ping.time);
				action?.Invoke(obj: false);
				yield break;
			}
			nTime++;
		}
		if (ping.isDone)
		{
			yield return ping.time;
			action?.Invoke(obj: true);
			UnityEngine.Debug.Log("连接成功");
		}
	}
}
public class RigidbodyMove : MonoBehaviour
{
	public Rigidbody attatchRigibody;

	public float scale = 1f;

	public float fdurea = 0.025f;

	protected const float MaxVelocityChange = 10f;

	protected const float VelocityMagic = 600f;

	protected const float AngularVelocityMagic = 250f;

	protected const float MaxAngularVelocityChange = 20f;

	private void Start()
	{
	}

	private void FixedUpdate()
	{
		SetRigidbodyVelocity(attatchRigibody, attatchRigibody.position, base.transform.position, fdurea);
		SetRigidbodyAngularVelocity(attatchRigibody, attatchRigibody.rotation, base.transform.rotation, fdurea);
	}

	private void SetRigidbodyVelocity(Rigidbody rigidbody, Vector3 from, Vector3 to, float duration)
	{
		Vector3 vector = to - from;
		if (Mathf.Approximately(vector.sqrMagnitude, 0f))
		{
			rigidbody.velocity = Vector3.zero;
		}
		else
		{
			rigidbody.velocity = vector / duration;
		}
	}

	private void SetRigidbodyAngularVelocity(Rigidbody rigidbody, Quaternion from, Quaternion to, float duration, bool overrideMaxAngularVelocity = true)
	{
		(to * Quaternion.Inverse(from)).ToAngleAxis(out var angle, out var axis);
		while (angle > 180f)
		{
			angle -= 360f;
		}
		if (Mathf.Approximately(angle, 0f) || float.IsNaN(axis.x) || float.IsNaN(axis.y) || float.IsNaN(axis.z))
		{
			rigidbody.angularVelocity = Vector3.zero;
			return;
		}
		angle *= (float)Math.PI / 180f / duration;
		if (overrideMaxAngularVelocity && rigidbody.maxAngularVelocity < angle)
		{
			rigidbody.maxAngularVelocity = angle;
		}
		rigidbody.angularVelocity = axis * angle;
	}
}
public class RigidbodyOffsetMove : MonoBehaviour
{
	public Rigidbody attatchRigibody;

	public Transform childTra;

	public float scale = 1f;

	public float fdurea = 0.025f;

	private Vector3 offsetPos;

	private bool isFollow;

	private float fduration02;

	public float fmaxdiss = 0.25f;

	public float fmaxdiss_ftime = 0.5f;

	private Vector3 vtargtttpos;

	private float voriposZ;

	private void Start()
	{
		voriposZ = attatchRigibody.position.z;
	}

	private void FixedUpdate()
	{
		if (isFollow)
		{
			Vector3 vector = base.transform.position - offsetPos - attatchRigibody.position;
			vtargtttpos = ((vector.magnitude > fmaxdiss) ? (attatchRigibody.position + vector.normalized * fmaxdiss) : (base.transform.position - offsetPos));
			SetRigidbodyVelocity(attatchRigibody, attatchRigibody.position, vtargtttpos, fdurea);
			SetRigidbodyAngularVelocity(attatchRigibody, attatchRigibody.rotation, childTra.rotation, fdurea);
		}
	}

	public void StartFollow(Vector3 offset)
	{
		isFollow = true;
		offsetPos = offset;
		childTra.rotation = attatchRigibody.transform.rotation;
	}

	public void StopFollow()
	{
		isFollow = false;
		attatchRigibody.velocity = Vector3.zero;
		attatchRigibody.Sleep();
	}

	private void SetRigidbodyVelocity(Rigidbody rigidbody, Vector3 from, Vector3 to, float duration)
	{
		Vector3 vector = to - from;
		if (Mathf.Approximately(vector.sqrMagnitude, 0f))
		{
			rigidbody.velocity = Vector3.zero;
		}
		else
		{
			rigidbody.velocity = vector / duration;
		}
	}

	private void SetRigidbodyAngularVelocity(Rigidbody rigidbody, Quaternion from, Quaternion to, float duration, bool overrideMaxAngularVelocity = true)
	{
		(to * Quaternion.Inverse(from)).ToAngleAxis(out var angle, out var axis);
		while (angle > 180f)
		{
			angle -= 360f;
		}
		if (Mathf.Approximately(angle, 0f) || float.IsNaN(axis.x) || float.IsNaN(axis.y) || float.IsNaN(axis.z))
		{
			rigidbody.angularVelocity = Vector3.zero;
			return;
		}
		angle *= (float)Math.PI / 180f / duration;
		if (overrideMaxAngularVelocity && rigidbody.maxAngularVelocity < angle)
		{
			rigidbody.maxAngularVelocity = angle;
		}
		rigidbody.angularVelocity = axis * angle;
	}
}
public class RotateSelf : MonoBehaviour
{
	public float speed = 30f;

	private void Start()
	{
	}

	private void Update()
	{
		base.transform.Rotate(base.transform.up, speed * Time.deltaTime);
	}
}
public class ScanController : MonoBehaviour
{
	public GameObject scanPanel;

	public RawImage viewImage_left;

	public Button returnBtn;

	private int width;

	private int height;

	private RenderTexture cameraTex_left;

	private bool cameraPreview;

	private BarcodeReader barcodeReader;

	private Color32[] data;

	private bool IsScanning;

	private float interval = 0.5f;

	private Action<bool, string> callback;

	private void Start()
	{
		returnBtn.onClick.AddListener(delegate
		{
			CloseScan();
		});
	}

	private void Update()
	{
		if (IsScanning)
		{
			interval += Time.deltaTime;
			if (interval >= 0.1f)
			{
				interval = 0f;
				DrawTexture();
				ScanQRCode();
			}
		}
	}

	private void OnDestory()
	{
		if (cameraPreview)
		{
			cameraPreview = false;
			BoundarySystem.UPvr_StopCameraFrame();
		}
	}

	public void OpenScan(Action<bool, string> action)
	{
		callback = action;
		if (!BoundarySystem.UPvr_BoundaryGetConfigured())
		{
			CloseScan();
			callback?.Invoke(arg1: false, "请打开设备安全距离开关");
			return;
		}
		scanPanel.SetActive(value: true);
		barcodeReader = new BarcodeReader
		{
			AutoRotate = false,
			TryHarder = false
		};
		StartCoroutine(InitScan());
	}

	private IEnumerator InitScan()
	{
		yield return null;
		CreateTexture();
		IsScanning = true;
	}

	public void CloseScan()
	{
		scanPanel.SetActive(value: false);
		IsScanning = false;
		if (cameraTex_left != null)
		{
			cameraTex_left.Release();
		}
		cameraTex_left = null;
		if (cameraPreview)
		{
			cameraPreview = false;
			BoundarySystem.UPvr_StopCameraFrame();
		}
	}

	private void CreateTexture()
	{
		width = 600;
		height = 600;
		BoundarySystem.UPvr_BoundarySetCameraImageRect(width, height);
		cameraTex_left = new RenderTexture(width, height, 24, RenderTextureFormat.Default);
		cameraTex_left.Create();
		viewImage_left.texture = cameraTex_left;
	}

	private void DrawTexture()
	{
		if (!cameraPreview)
		{
			cameraPreview = true;
			BoundarySystem.UPvr_StartCameraFrame();
		}
		BoundarySystem.UPvr_BoundaryGetSeeThroughData(0, cameraTex_left);
	}

	private Texture2D TextureToTexture2D(Texture texture)
	{
		Texture2D texture2D = new Texture2D(texture.width, texture.height, TextureFormat.RGBA32, mipChain: false);
		RenderTexture active = RenderTexture.active;
		RenderTexture temporary = RenderTexture.GetTemporary(texture.width, texture.height, 32);
		Graphics.Blit(texture, temporary);
		RenderTexture.active = temporary;
		texture2D.ReadPixels(new Rect(0f, 0f, temporary.width, temporary.height), 0, 0);
		texture2D.Apply();
		RenderTexture.active = active;
		RenderTexture.ReleaseTemporary(temporary);
		return texture2D;
	}

	private void ScanQRCode()
	{
		try
		{
			Texture2D texture2D = TextureToTexture2D(cameraTex_left);
			data = texture2D.GetPixels32();
			Result result = barcodeReader.Decode(data, cameraTex_left.width, cameraTex_left.height);
			data = null;
			UnityEngine.Object.Destroy(texture2D);
			if (result != null)
			{
				UnityEngine.Debug.Log(result.Text);
				CloseScan();
				callback?.Invoke(arg1: true, result.Text);
			}
		}
		catch (Exception ex)
		{
			UnityEngine.Debug.LogError(ex.Message);
			CloseScan();
			callback?.Invoke(arg1: false, ex.Message);
			throw;
		}
	}
}
public class simpleRotX : MonoBehaviour
{
	public float rotSpeed = 80f;

	public DirctionType dirctionType;

	public AxisType axisType = AxisType.AxisY;

	public WorldType worldType;

	private Vector3 axis;

	private void Start()
	{
		if (dirctionType == DirctionType.Clockwise)
		{
			if (axisType == AxisType.AxisX)
			{
				axis = Vector3.right;
			}
			else if (axisType == AxisType.AxisY)
			{
				axis = Vector3.down;
			}
			else
			{
				axis = Vector3.back;
			}
		}
		else if (axisType == AxisType.AxisX)
		{
			axis = Vector3.left;
		}
		else if (axisType == AxisType.AxisY)
		{
			axis = Vector3.up;
		}
		else
		{
			axis = Vector3.forward;
		}
	}

	private void Update()
	{
		if (worldType == WorldType.Local)
		{
			base.transform.Rotate(axis, rotSpeed * Time.deltaTime);
		}
		else
		{
			base.transform.Rotate(axis, rotSpeed * Time.deltaTime, Space.World);
		}
	}
}
public enum DirctionType
{
	Clockwise,
	AntiClockwise
}
public enum WorldType
{
	Local,
	World
}
public enum AxisType
{
	AxisX,
	AxisY,
	AxisZ
}
public class spline_simpleBoxMove : MonoBehaviour
{
	public Transform moveOriObj;

	public Transform ori;

	public Transform des;

	private float z;

	[Range(0.1f, 60f)]
	public float DurationInSecond = 2f;

	private void Start()
	{
		z = base.transform.position.z;
	}

	private void Update()
	{
		float num = Mathf.PingPong(Time.time / DurationInSecond, Vector3.Distance(ori.position, des.position));
		moveOriObj.transform.position = ori.position + (des.position - ori.position).normalized * num;
	}
}
public class SyncShow : MonoBehaviour
{
	public GameObject[] syncList;

	private void Start()
	{
	}

	private void Update()
	{
	}

	private void OnEnable()
	{
		if (syncList != null)
		{
			GameObject[] array = syncList;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].SetActive(value: true);
			}
		}
	}

	private void OnDisable()
	{
		if (syncList != null)
		{
			GameObject[] array = syncList;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].SetActive(value: false);
			}
		}
	}
}
public class WordToVoice_adhd : MonoBehaviour
{
	public delegate void CallBack(string name);

	public delegate string ds();

	[TextArea(0, 6)]
	public string strwords;

	public AudioSource audioSource;

	private string token = "";

	private string grant_Type = "client_credentials";

	private string client_ID = "f1Y0tCGFlvgMt7jdSVwrZllV";

	private string client_Secret = "Iwsb039GD7aSLN4vFvxjxWK9AZuLSNsp";

	private string baiduAPI = "http://tsn.baidu.com/text2audio";

	private string getTokenAPIPath = "https://openapi.baidu.com/oauth/2.0/token";

	private byte[] clipByte;

	public static string audioToString;

	private void Awake()
	{
	}

	private IEnumerator GetToken(string url)
	{
		bool flag = false;
		token = PlayerPrefs.GetString("baidu_token");
		if (string.IsNullOrEmpty(token))
		{
			flag = true;
		}
		else if ((DateTime.Now - DateTime.FromFileTime(long.Parse(PlayerPrefs.GetString("baidu_token_DateTime")))).Days > 25)
		{
			flag = true;
		}
		if (flag)
		{
			WWWForm wWWForm = new WWWForm();
			wWWForm.AddField("grant_type", grant_Type);
			wWWForm.AddField("client_id", client_ID);
			wWWForm.AddField("client_secret", client_Secret);
			using UnityWebRequest getTW = UnityWebRequest.Post(url, wWWForm);
			yield return getTW.SendWebRequest();
			if (getTW.isDone)
			{
				if (getTW.error == null)
				{
					token = J_LitJson.JsonMapper.ToObject(getTW.downloadHandler.text)["access_token"].ToString();
					PlayerPrefs.SetString("baidu_token", token);
					PlayerPrefs.SetString("baidu_token_DateTime", DateTime.Now.ToFileTime().ToString());
					UnityEngine.Debug.Log(token);
					UnityEngine.Debug.Log("获取百度用户令牌 初始化完成");
				}
				else
				{
					UnityEngine.Debug.Log("error:" + getTW.error);
				}
			}
		}
		yield return null;
	}

	public void PlayAudio(string world, Action action = null)
	{
		strwords = world;
		WordToVoiceManager.WordToVoice(strwords, delegate(AudioClip clip)
		{
			audioSource.clip = clip;
			audioSource.Play();
			DelayHander(clip.length, delegate
			{
				action?.Invoke();
			});
		});
	}

	public void PlayAudio(AudioClip clip)
	{
		audioSource.clip = clip;
		audioSource.Play();
	}

	private void DelayHander(float time, Action action)
	{
		if (base.gameObject.activeInHierarchy)
		{
			StartCoroutine(Wait(time, action));
		}
	}

	private IEnumerator Wait(float time, Action action)
	{
		yield return new WaitForSeconds(time);
		action?.Invoke();
	}

	private IEnumerator GetAudioString()
	{
		WWWForm wWWForm = new WWWForm();
		wWWForm.AddField("tex", strwords);
		wWWForm.AddField("tok", token);
		wWWForm.AddField("cuid", "11");
		wWWForm.AddField("ctp", 1);
		wWWForm.AddField("aue", 3);
		wWWForm.AddField("lan", "zh");
		using UnityWebRequest getASW = UnityWebRequest.Post(baiduAPI, wWWForm);
		yield return getASW.SendWebRequest();
		if (getASW.isDone)
		{
			File.WriteAllBytes(UrlUtils.persistentDataPath + "/1.mp3", getASW.downloadHandler.data);
			Singleton<MiniMonoBehaviour>.Instance.StartCoroutine(LoadManager.LoadAudio("file://" + UrlUtils.persistentDataPath + "/1.mp3", delegate(AudioClip audioClip, byte[] byteStream)
			{
				audioSource.clip = audioClip;
				audioSource.Play();
			}));
		}
	}
}
public class V_testResultTable : MonoBehaviour
{
	[Serializable]
	public class V_TestTable
	{
		[Serializable]
		public class cPart01
		{
			[Serializable]
			public class cPart02
			{
				[Serializable]
				public class cPart03
				{
					public Text score;
				}

				public Text score;

				public List<cPart03> data;
			}

			public Text score;

			public List<cPart02> data;
		}

		public Text score;

		public List<cPart01> data;
	}

	public V_TestTable resultTable;

	public void J_PassValue(M_TestTable tableData)
	{
		int num = 0;
		int num2 = 0;
		for (int i = 0; i < tableData.data.Count; i++)
		{
			int num3 = 0;
			for (int j = 0; j < tableData.data[i].data.Count; j++)
			{
				int num4 = 0;
				for (int k = 0; k < tableData.data[i].data[j].data.Count; k++)
				{
					num2++;
					M_TestTable.cPart01.cPart02.cPart03 cPart = tableData.data[i].data[j].data[k];
					V_TestTable.cPart01.cPart02.cPart03 cPart2 = resultTable.data[i].data[j].data[k];
					num4 += cPart.score;
					cPart2.score.text = $"{cPart.score}/1";
				}
				num3 += num4;
				resultTable.data[i].data[j].score.text = $"{num4}/{tableData.data[i].data[j].data.Count}";
			}
			num += num3;
			resultTable.data[i].score.text = $"{num3}/{tableData.data[i].data.Count}";
		}
		resultTable.score.text = $"{num}/{num2}";
	}
}
public class I_PicSelectPointerAction : MonoBehaviour, IPointerEnterHandler, IEventSystemHandler, IPointerExitHandler, IPointerClickHandler
{
	public float fMaxHoverTime = 3f;

	public Image m_imgFill;

	public UnityEvent m_OnClick;

	private bool bCanTrigger = true;

	private void Start()
	{
		m_imgFill.gameObject.SetActive(value: false);
	}

	public void OnPointerClick(PointerEventData eventData)
	{
		if (bCanTrigger)
		{
			bCanTrigger = false;
			m_OnClick.Invoke();
		}
	}

	public void OnPointerEnter(PointerEventData eventData)
	{
	}

	public void OnPointerExit(PointerEventData eventData)
	{
	}
}
public class I_VoiceCheckResult_Naming : I_VoiceCheckResultBase
{
	public string words;

	public List<string> wordsSmillar;

	protected override bool isWordsMatch(string voiceRecWords)
	{
		if (!voiceRecWords.IsMatch(words))
		{
			return voiceRecWords.IsMatch(wordsSmillar).Count > 0;
		}
		return true;
	}
}
public class I_VoiceCheckResult_NumCounting : I_VoiceCheckResultBase
{
	private void Start()
	{
	}

	protected override bool isWordsMatch(string voiceRecWords)
	{
		return voiceRecWords.Contains("一二三四五六七八九十");
	}
}
public class I_VoiceCheckResult_Repeat : I_VoiceCheckResultBase
{
	public string words;

	protected override bool isWordsMatch(string voiceRecWords)
	{
		if (voiceRecWords.Contains(words))
		{
			return true;
		}
		return false;
	}
}
public class I_VoiceCheckResultBase : MonoBehaviour
{
	public int wordID;

	public UnityEvent m_eventWhenCorrect;

	public UnityEvent m_eventWhenWrong;

	public void OnResultCheck(string voiceRecWords, Action<bool> matchCallback = null)
	{
		if (isWordsMatch(voiceRecWords))
		{
			UnityEngine.Debug.Log("--match ");
			matchCallback?.Invoke(obj: true);
		}
		else
		{
			UnityEngine.Debug.Log("--not match");
			matchCallback?.Invoke(obj: false);
		}
	}

	protected virtual bool isWordsMatch(string voiceRecWords)
	{
		return true;
	}
}
public class WrodObjectsManager : MonoBehaviour
{
	[Serializable]
	public class structWordObject
	{
		public string word;

		public GameObject wordObject;
	}

	public static int m_iCurTestIndex;

	public AliyunVoice aliyunVoice;

	public bool m_bJumpOverPlayWords;

	public static WrodObjectsManager Inst;

	public M_ViewListenWords m_trainResult;

	[Header("Audios")]
	public AudioSource m_AudioEndT;

	public AudioSource m_AudioWord;

	public AudioClip[] m_listWordsAudios;

	[Header("Result Panel")]
	public GameObject m_objResultPanel;

	public Text m_txtCorrect;

	public Text m_txtRepeatWords;

	public Text m_txtMiss;

	public Text m_txtMissWords;

	[Header("Words")]
	public float fStartDelay = 2f;

	public structWordObject[] m_listWords;

	public GameObject[] m_listWordPics;

	private List<string> listCorrectWords;

	private GameObject prewordpic;

	private bool m_bInRecording;

	private float lastime;

	public UnityEvent eventOnFinished;

	private void Awake()
	{
		Inst = this;
		UnityEngine.Debug.Log(M_VLWTime.Inst.picShowDelay);
	}

	private void Start()
	{
		aliyunVoice.RecStateChangeAction = OnRecStateChange;
		aliyunVoice.RecCallbackAction = OnRecCallback;
		aliyunVoice.VolumnCallbackAction = OnVolumnCallback;
		m_trainResult = new M_ViewListenWords();
		structWordObject[] listWords = m_listWords;
		for (int i = 0; i < listWords.Length; i++)
		{
			listWords[i].wordObject.SetActive(value: false);
		}
		GameObject[] listWordPics = m_listWordPics;
		for (int i = 0; i < listWordPics.Length; i++)
		{
			listWordPics[i].SetActive(value: false);
		}
		m_objResultPanel.SetActive(value: false);
		m_listWords.Select((structWordObject obj) => obj.word).ToList();
		UnityEngine.Debug.Log(1);
		StopAllCoroutines();
		StartCoroutine(yieldPlayWords());
	}

	private void OnDestory()
	{
		aliyunVoice.StopRec();
		StopAllCoroutines();
	}

	private void OnDisable()
	{
		StopAllCoroutines();
	}

	private IEnumerator yieldPlayWords()
	{
		if (!m_bJumpOverPlayWords)
		{
			UnityEngine.Debug.Log("--开始播报");
			yield return new WaitForSeconds(0.5f);
			structWordObject[] listWords = m_listWords;
			foreach (structWordObject obj in listWords)
			{
				obj.wordObject.SetActive(value: true);
				obj.wordObject.GetComponent<Animator>().Update(0f);
				yield return new WaitForSeconds(M_VLWTime.Inst.picShowDelay);
				GameObject wordpic = m_listWordPics.Where((GameObject tempobj) => tempobj.name == obj.word).First();
				wordpic.SetActive(value: true);
				yield return new WaitForSeconds(M_VLWTime.Inst.audioShowDelay);
				AudioClip clip = m_listWordsAudios.Where((AudioClip tempobj) => tempobj.name == obj.word).First();
				m_AudioWord.PlayOneShot(clip);
				yield return new WaitForSeconds(M_VLWTime.Inst.wordHideDelay);
				obj.wordObject.SetActive(value: false);
				wordpic.SetActive(value: false);
				yield return new WaitForSeconds(M_VLWTime.Inst.nextWordDelay);
			}
			yield return new WaitForSeconds(1f);
		}
		listCorrectWords = new List<string>();
		if (!m_bJumpOverPlayWords)
		{
			UnityEngine.Debug.Log("--请开始复读");
			m_AudioEndT.Play();
			yield return new WaitForSeconds(m_AudioEndT.clip.length);
		}
		m_bInRecording = true;
		lastime = Time.time;
		aliyunVoice.StartRec();
	}

	private void OnRecStateChange(string msg)
	{
	}

	public void OnRecCallback(string strWords)
	{
		UnityEngine.Debug.Log("识别到：" + strWords);
		foreach (structWordObject obj in strWords.IsMatch(m_listWords))
		{
			if (!listCorrectWords.Contains(obj.word))
			{
				listCorrectWords.Add(obj.word);
				m_trainResult.words.Add(new M_ViewListenWords.wordInfo
				{
					word = obj.word
				});
				obj.wordObject.SetActive(value: true);
				obj.wordObject.GetComponent<Animator>().Update(0f);
				if (prewordpic != null)
				{
					prewordpic.SetActive(value: false);
				}
				prewordpic = m_listWordPics.FirstOrDefault((GameObject ca) => ca.name == obj.word);
				prewordpic.SetActive(value: true);
				if (listCorrectWords.Count == m_listWords.Length)
				{
					m_trainResult.Finish(ETestState.Succeed);
					EndTest();
				}
				lastime = Time.time;
			}
		}
	}

	public void OnVolumnCallback(float val)
	{
	}

	private void Update()
	{
		if (m_bInRecording && Time.time - lastime > M_VLWTime.Inst.maxWordLostTime)
		{
			m_trainResult.Finish(ETestState.Failed);
			EndTest();
		}
	}

	private void EndTest()
	{
		eventOnFinished.Invoke();
		m_bInRecording = false;
		structWordObject[] listWords = m_listWords;
		for (int i = 0; i < listWords.Length; i++)
		{
			listWords[i].wordObject.SetActive(value: false);
		}
		m_objResultPanel.SetActive(value: true);
		m_txtCorrect.text = "准确：" + listCorrectWords.Count + "个";
		string text = "";
		int count = listCorrectWords.Count;
		for (int j = 0; j < count; j++)
		{
			text += listCorrectWords[j];
			if (j < count - 1)
			{
				text += "、";
			}
		}
		m_txtRepeatWords.text = text;
		m_txtMiss.text = "剩余：" + (m_listWords.Length - listCorrectWords.Count) + "个";
		string text2 = "";
		int num = m_listWords.Length;
		for (int k = 0; k < num; k++)
		{
			string word = m_listWords[k].word;
			if (!listCorrectWords.Contains(word))
			{
				text2 += word;
				if (k < num - 1)
				{
					text2 += "、";
				}
			}
		}
		m_txtMissWords.text = text2;
	}
}
public abstract class BaiduAudioRecBase : MonoBehaviour
{
	public string offlineBsgFile = "assets://baidu_speech_grammar.bsg";

	private AndroidJavaClass ajc;

	private AndroidJavaObject ajo;

	protected bool recStart;

	public abstract void OnReceivedRecResult(M_BaiduAudioRecResult recResult);

	private void Init()
	{
		_requestAudioPerssion();
		ajc = new AndroidJavaClass("com.Guava.VRMedicalRecure.BaiduVoice");
		ajc.CallStatic("start");
		ajo = ajc.GetStatic<AndroidJavaObject>("instance");
		ajo.Call("Init", offlineBsgFile, base.gameObject.name, "OnRecStateChange", "OnRecCallback");
		UnityEngine.Debug.Log("--init");
	}

	private void _requestAudioPerssion()
	{
		(new string[1])[0] = "android.permission.RECORD_AUDIO";
	}

	public void StartVoiceRec(int timeoutMili = 3000)
	{
		if (ajc == null)
		{
			Init();
		}
		recStart = true;
		string text = "{\"accept-audio-data\":false,\"disable-punctuation\":false,\"accept-audio-volume\":true,\"vad\":\"dnn\",\"vad.endpoint-timeout\":" + timeoutMili + ",\"pid\":1537,\"decoder\":2}";
		ajo.Call("start", text);
		UnityEngine.Debug.Log("--try start baidu voice rec");
	}

	public void StopVoiceRec()
	{
		recStart = false;
		if (ajo != null)
		{
			ajo.Call("stop");
		}
		UnityEngine.Debug.Log("--try stop baidu voice rec");
	}

	protected virtual void OnRecStateChange(string msg)
	{
		if (!(msg == "start"))
		{
			if (msg == "stop")
			{
				UnityEngine.Debug.Log("-- baidu voice rec stopped");
				if (recStart)
				{
					StartVoiceRec();
				}
			}
			else
			{
				UnityEngine.Debug.LogError("--unkonw state:" + msg);
			}
		}
		else
		{
			UnityEngine.Debug.Log("--baidu voice rec started");
		}
	}

	protected virtual void OnRecCallback(string msg)
	{
		M_BaiduAudioRecResult recResult = J_LitJson.JsonMapper.ToObject<M_BaiduAudioRecResult>(msg);
		OnReceivedRecResult(recResult);
	}

	private void OnDestroy()
	{
		StopVoiceRec();
	}
}
public class BaiduWordToVoiceBase : MonoBehaviour
{
	private static BaiduWordToVoiceBase _inst;

	private static string token = "";

	public static BaiduWordToVoiceBase Inst
	{
		get
		{
			if (_inst == null)
			{
				_inst = new GameObject("BaiduWordToVoiceBase").AddComponent<BaiduWordToVoiceBase>();
			}
			return _inst;
		}
	}

	public static string m_Token => token;

	public static void J_GetAudio(string strwords, Action<AudioClip> onCallback, int fspeed = 3)
	{
		bool flag = false;
		if (string.IsNullOrEmpty(token))
		{
			token = PlayerPrefs.GetString("baidu_token");
			if (string.IsNullOrEmpty(token))
			{
				flag = true;
			}
			else if ((DateTime.Now - DateTime.FromFileTime(long.Parse(PlayerPrefs.GetString("baidu_token_DateTime")))).Days > 25)
			{
				flag = true;
			}
		}
		if (flag)
		{
			Inst.StartCoroutine(GetToken(delegate
			{
				Inst.StartCoroutine(GetStringAudio(strwords, onCallback, fspeed));
			}));
		}
		else
		{
			Inst.StartCoroutine(GetStringAudio(strwords, onCallback, fspeed));
		}
	}

	private static IEnumerator GetToken(Action onCallback)
	{
		WWWForm wWWForm = new WWWForm();
		wWWForm.AddField("grant_type", "client_credentials");
		wWWForm.AddField("client_id", "6B9HuKm2xSssYVwCcGBHYV7r");
		wWWForm.AddField("client_secret", "RDUye6TkYQ4CLYEEfpdT0mY1YfAFQcoI");
		using (UnityWebRequest getTW = UnityWebRequest.Post("https://openapi.baidu.com/oauth/2.0/token", wWWForm))
		{
			yield return getTW.SendWebRequest();
			if (getTW.isDone)
			{
				if (string.IsNullOrEmpty(getTW.error))
				{
					token = J_LitJson.JsonMapper.ToObject(getTW.downloadHandler.text)["access_token"].ToString();
					PlayerPrefs.SetString("baidu_token", token);
					PlayerPrefs.SetString("baidu_token_DateTime", DateTime.Now.ToFileTime().ToString());
					UnityEngine.Debug.Log("获取百度用户令牌 初始化完成");
					onCallback?.Invoke();
				}
				else
				{
					UnityEngine.Debug.LogError("error:" + getTW.error);
				}
			}
		}
		yield return null;
	}

	private static IEnumerator GetStringAudio(string strwords, Action<AudioClip> onCallback, int fspeed = 3)
	{
		WWWForm wWWForm = new WWWForm();
		wWWForm.AddField("tex", strwords);
		wWWForm.AddField("tok", token);
		wWWForm.AddField("cuid", "11");
		wWWForm.AddField("ctp", 1);
		wWWForm.AddField("spd", fspeed);
		wWWForm.AddField("aue", 6);
		wWWForm.AddField("lan", "zh");
		UnityEngine.Debug.Log(token);
		using UnityWebRequest getASW = UnityWebRequest.Post("https://tsn.baidu.com/text2audio", wWWForm);
		yield return getASW.SendWebRequest();
		if (string.IsNullOrEmpty(getASW.error))
		{
			onCallback?.Invoke(WavUtility.ToAudioClip(getASW.downloadHandler.data));
			yield break;
		}
		onCallback?.Invoke(null);
		UnityEngine.Debug.LogError("error:" + getASW.error);
	}
}
public class J_AutoPlayStringToAudio : MonoBehaviour
{
	public AudioSource audioSource;

	[TextArea(3, 6)]
	public string m_strContent;

	private void OnEnable()
	{
		if (string.IsNullOrEmpty(m_strContent))
		{
			return;
		}
		if (audioSource == null)
		{
			audioSource = base.gameObject.AddComponent<AudioSource>();
			audioSource.playOnAwake = false;
			audioSource.loop = false;
		}
		BaiduWordToVoiceBase.J_GetAudio(m_strContent, delegate(AudioClip audioclip)
		{
			if (audioclip != null)
			{
				audioSource.clip = audioclip;
				audioSource.Play();
			}
		}, 5);
	}
}
public class J_BaiduAudioSDK : BaiduAudioRecBase
{
	public override void OnReceivedRecResult(M_BaiduAudioRecResult recResult)
	{
		UnityEngine.Debug.Log(recResult.error);
	}
}
public class M_BaiduAudioRecResult
{
	public class M_recOriginResult
	{
		public class M_RecResultWord
		{
			public string[] word;
		}

		public long corpus_no;

		public int err_no;

		public int error;

		public int sub_error;

		public M_RecResultWord result;

		public string sn;

		public string desc;
	}

	public int error;

	public int sub_error;

	public string[] results_recognition;

	public M_recOriginResult origin_result;

	public string best_result;

	public string result_type;

	public string desc;
}
public class J_AppHelper : MonoBehaviour
{
	public static void InstallAPK(string path)
	{
		try
		{
			AndroidJavaClass androidJavaClass = new AndroidJavaClass("android.content.Intent");
			string @static = androidJavaClass.GetStatic<string>("ACTION_VIEW");
			int static2 = androidJavaClass.GetStatic<int>("FLAG_ACTIVITY_NEW_TASK");
			int static3 = androidJavaClass.GetStatic<int>("FLAG_GRANT_READ_URI_PERMISSION");
			AndroidJavaObject androidJavaObject = new AndroidJavaObject("android.content.Intent", @static);
			AndroidJavaObject static4 = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
			androidJavaObject.Call<AndroidJavaObject>("setFlags", new object[1] { static2 });
			androidJavaObject.Call<AndroidJavaObject>("addFlags", new object[1] { static3 });
			AndroidJavaObject androidJavaObject2 = new AndroidJavaObject("java.io.File", path);
			AndroidJavaObject androidJavaObject3 = new AndroidJavaClass("android.support.v4.content.FileProvider").CallStatic<AndroidJavaObject>("getUriForFile", new object[3] { static4, "com.Guava.ADHD.fileprovider", androidJavaObject2 });
			androidJavaObject.Call<AndroidJavaObject>("setDataAndType", new object[2] { androidJavaObject3, "application/vnd.android.package-archive" });
			static4.Call("startActivity", androidJavaObject);
		}
		catch (Exception ex)
		{
			UnityEngine.Debug.LogError(ex.Message + " -- " + ex.StackTrace);
		}
	}

	public static IEnumerator yieldWriteFile(byte[] bs, string outpath, Action<float> actionProgress = null, Action finshCallback = null)
	{
		int segWriteSize = 5242880;
		byte[] array = new byte[segWriteSize];
		int segsize = array.Length;
		int copied2 = 0;
		FileStream fswrite = File.OpenWrite(outpath);
		if (segsize < bs.Length)
		{
			while (copied2 + segsize <= bs.Length)
			{
				array = new byte[segWriteSize];
				for (int i = 0; i < segWriteSize; i++)
				{
					int num = copied2 + i;
					array[i] = bs[num];
				}
				copied2 += segWriteSize;
				fswrite.Write(array, 0, array.Length);
				fswrite.Flush();
				yield return null;
			}
			int num2 = bs.Length - copied2;
			array = new byte[num2];
			for (int j = 0; j < num2; j++)
			{
				int num3 = copied2 + j;
				array[j] = bs[num3];
			}
			copied2 += num2;
			fswrite.Write(array, 0, num2);
			fswrite.Flush();
			yield return null;
			float obj = (float)copied2 * 1f / (float)bs.Length;
			actionProgress?.Invoke(obj);
		}
		else
		{
			fswrite.Write(bs, 0, bs.Length);
			fswrite.Flush();
		}
		fswrite.Close();
		fswrite.Dispose();
		finshCallback?.Invoke();
	}
}
public class J_UpgradeCheckManager : MonoBehaviour
{
	public class APIDataCallback
	{
		public class cData
		{
			public string id;

			public string version_num;

			public string package_url;

			public string version_info;

			public string version_type;

			public int is_force_update;
		}

		public int code;

		public string msg;

		public cData data;
	}

	public string m_NextSceneName;

	public Text m_TextNewversionNote;

	public Text m_TextNote;

	public Image m_ImageProgress;

	public Text m_progressTxt;

	public GameObject panelComfirmNewVersion;

	public Button m_btnStartUpgrade;

	public Button m_btnUpgradeNextTime;

	public PingNetwork pingNetwork;

	public Text networkStateTxt;

	private string strAPPFolder;

	private APIDataCallback apiDataCallback;

	private float fDownloadDelaySecond = 0.2f;

	private float fDownloadSpeedTimerDelay = 1f;

	private string strAPKSaveFolder => Application.persistentDataPath + "/tempdownload";

	private void Awake()
	{
		panelComfirmNewVersion.SetActive(value: false);
		m_TextNewversionNote.text = null;
		m_btnStartUpgrade.onClick.AddListener(delegate
		{
			panelComfirmNewVersion.gameObject.SetActive(value: false);
			J_StartUpgrade();
		});
		m_btnUpgradeNextTime.onClick.AddListener(delegate
		{
			panelComfirmNewVersion.gameObject.SetActive(value: false);
			J_LoadNextLevel();
		});
		StartCoroutine(yieldCheckVersions());
		PingNetwork();
	}

	private void PingNetwork()
	{
		pingNetwork.CheckNetStatus("www.baidu.com", delegate(bool netState)
		{
			if (netState)
			{
				string text = UrlUtils.baseUrl_es.Replace("https://", "");
				text = text.TrimEnd('/');
				pingNetwork.CheckNetStatus(text, delegate(bool state)
				{
					if (state)
					{
						networkStateTxt.text = "正常";
					}
					else
					{
						networkStateTxt.text = "dns地址异常";
						J_LoadNextLevel();
					}
				});
			}
			else
			{
				networkStateTxt.text = "未联网";
			}
		});
	}

	private IEnumerator yieldCheckVersions()
	{
		if (Application.internetReachability == NetworkReachability.NotReachable)
		{
			setNoteText("无法连接网络，正在进入系统，请稍后...");
			yield return new WaitForSeconds(2f);
			J_LoadNextLevel();
			yield break;
		}
		setNoteText("版本检查中...");
		yield return new WaitForEndOfFrame();
		string curVersion = Application.version;
		UnityEngine.Debug.Log("--cur version:" + curVersion);
		string text = UrlUtils.baseUrl_es + UrlUtils.version;
		using UnityWebRequest www = UnityWebRequest.Get(text + "?version=" + curVersion + "&type=adhd");
		www.certificateHandler = new AcceptAllCertificatesSignedWithASpecificPublicKey();
		yield return www.SendWebRequest();
		setNoteText("版本比对中...");
		if (string.IsNullOrEmpty(www.error))
		{
			string text2 = www.downloadHandler.text;
			UnityEngine.Debug.Log("--succeed:" + text2);
			apiDataCallback = J_LitJson.JsonMapper.ToObject<APIDataCallback>(text2);
			if (apiDataCallback.code == 200)
			{
				m_TextNewversionNote.text = apiDataCallback.data.version_num + "\n" + apiDataCallback.data.version_info;
				if (curVersion == apiDataCallback.data.version_num)
				{
					setNoteText("检查完成，正在进入系统，请稍后...");
					J_LoadNextLevel();
				}
				else if (apiDataCallback.data.is_force_update == 1)
				{
					setNoteText("发现新版本，请完成更新后进入系统");
					panelComfirmNewVersion.SetActive(value: true);
					m_btnStartUpgrade.gameObject.SetActive(value: true);
					m_btnUpgradeNextTime.gameObject.SetActive(value: false);
				}
				else
				{
					setNoteText("发现新版本，请选择是否现在更新");
					panelComfirmNewVersion.SetActive(value: true);
					m_btnStartUpgrade.gameObject.SetActive(value: true);
					m_btnUpgradeNextTime.gameObject.SetActive(value: true);
				}
			}
			else
			{
				setNoteText("检查完成，正在进入系统，请稍后...");
				yield return new WaitForSeconds(2f);
				J_LoadNextLevel();
			}
		}
		else
		{
			UnityEngine.Debug.LogError(www.error);
			setNoteText("服务器连接出错，请联系管理员！" + www.error);
		}
	}

	public void J_StartUpgrade()
	{
		StartCoroutine(yieldDownloadNewVersion(apiDataCallback.data));
	}

	public void J_LoadNextLevel()
	{
		if (Directory.Exists(strAPKSaveFolder))
		{
			Directory.Delete(strAPKSaveFolder, recursive: true);
		}
		SceneManager.LoadScene(m_NextSceneName);
	}

	private IEnumerator yieldDownloadNewVersion(APIDataCallback.cData newversionData)
	{
		setNoteText("系统正在自动更新中，请保持头盔屏幕常亮...");
		if (!Directory.Exists(strAPKSaveFolder))
		{
			Directory.CreateDirectory(strAPKSaveFolder);
		}
		string filepath = strAPKSaveFolder + "/" + newversionData.version_num.GetHashCode() + ".apk";
		UnityEngine.Debug.Log("--filepath:" + filepath);
		bool flag = true;
		if (File.Exists(filepath))
		{
			UnityEngine.Debug.LogWarning("--exist apk");
			setNoteText("本地apk已存在，正在检测文件有效性");
			if (PlayerPrefs.GetInt("apksavecomplete") == 1)
			{
				setNoteText("正在尝试启动本地安装文件");
				flag = false;
				try
				{
					ToBServiceHelper.UPvr_ControlAPPManger(filepath);
				}
				catch (Exception ex)
				{
					setNoteText(ex.Message);
				}
			}
		}
		if (!flag)
		{
			yield break;
		}
		PlayerPrefs.SetInt("apksavecomplete", 0);
		using UnityWebRequest www = UnityWebRequest.Get(newversionData.package_url);
		www.downloadHandler = new DownloadHandlerFile(filepath);
		www.certificateHandler = new AcceptAllCertificatesSignedWithASpecificPublicKey();
		www.SendWebRequest();
		while (!www.downloadHandler.isDone)
		{
			setNoteText("系统更新中，请保持头盔屏幕常亮...");
			float downloadProgress = www.downloadProgress;
			setProgress(downloadProgress);
			yield return new WaitForSeconds(fDownloadDelaySecond);
		}
		yield return null;
		setProgress(0.98f);
		setNoteText("正在写入文件，请不要进行任何操作");
		while (!File.Exists(filepath))
		{
			yield return new WaitForFixedUpdate();
		}
		setNoteText("开始执行安装");
		yield return null;
		PlayerPrefs.SetInt("apksavecomplete", 1);
		ToBServiceHelper.UPvr_ControlAPPManger(filepath);
	}

	private void setNoteText(string strnote)
	{
		m_TextNote.text = strnote;
	}

	private void setProgress(float fprogress)
	{
		m_ImageProgress.fillAmount = fprogress;
		m_progressTxt.text = (int)(fprogress * 100f) + "%";
	}

	public void J_QuitApp()
	{
		Application.Quit();
	}
}
public class BypassCertificate : CertificateHandler
{
	protected override bool ValidateCertificate(byte[] certificateData)
	{
		return true;
	}
}
internal class AcceptAllCertificatesSignedWithASpecificPublicKey : CertificateHandler
{
	protected override bool ValidateCertificate(byte[] certificateData)
	{
		return true;
	}
}
public class J_AStar_Node : MonoBehaviour
{
	public bool m_canMove = true;

	public List<J_AStar_Node> m_aroundNodes;

	[HideInInspector]
	public float fDisToTarget;
}
public class J_AStar_WayTracker : MonoBehaviour
{
	private J_AStar_Node[] m_listAllNodes;

	private Vector3 _endPointPos;

	private J_AStar_Node endNode;

	private List<Vector3> _listPaths = new List<Vector3>();

	private List<J_AStar_Node> _open = new List<J_AStar_Node>();

	private List<J_AStar_Node> _close = new List<J_AStar_Node>();

	public List<Vector3> J_FindPath(Vector3 startPoint, Vector3 endPoint)
	{
		if (m_listAllNodes == null)
		{
			m_listAllNodes = GetComponentsInChildren<J_AStar_Node>();
		}
		if (_endPointPos != endPoint || endNode == null)
		{
			_endPointPos = endPoint;
			endNode = findNeareastNode(endPoint);
		}
		_listPaths.Clear();
		_listPaths.Add(startPoint);
		if (endNode != null)
		{
			foreach (J_AStar_Node item in _FindPath(findNeareastNode(startPoint), endNode))
			{
				_listPaths.Add(item.transform.position);
			}
		}
		_listPaths.Add(endPoint);
		return _listPaths;
	}

	private J_AStar_Node findNeareastNode(Vector3 vPoint)
	{
		float num = 100000000f;
		J_AStar_Node result = null;
		J_AStar_Node[] listAllNodes = m_listAllNodes;
		foreach (J_AStar_Node j_AStar_Node in listAllNodes)
		{
			float num2 = Vector3.Distance(vPoint, j_AStar_Node.transform.position);
			if (num2 < num)
			{
				num = num2;
				result = j_AStar_Node;
			}
		}
		return result;
	}

	public List<Vector3> J_FindPath(J_AStar_Node startPoint, J_AStar_Node endPoint)
	{
		_listPaths.Clear();
		foreach (J_AStar_Node item in _FindPath(startPoint, endPoint))
		{
			_listPaths.Add(item.transform.position);
		}
		return _listPaths;
	}

	private List<J_AStar_Node> _FindPath(J_AStar_Node startPoint, J_AStar_Node endPoint)
	{
		_open.Clear();
		_close.Clear();
		J_AStar_Node j_AStar_Node = startPoint;
		int num = 1000;
		while (endPoint != j_AStar_Node && --num > 0)
		{
			List<J_AStar_Node> aroundNodes = j_AStar_Node.m_aroundNodes;
			for (int i = 0; i < aroundNodes.Count; i++)
			{
				J_AStar_Node j_AStar_Node2 = aroundNodes[i];
				if (j_AStar_Node2 == null || j_AStar_Node2 == j_AStar_Node || _close.Contains(j_AStar_Node2) || !j_AStar_Node2.m_canMove)
				{
					continue;
				}
				float fDisToTarget = Vector3.Distance(j_AStar_Node2.transform.position, endPoint.transform.position);
				if (!_open.Contains(j_AStar_Node2))
				{
					j_AStar_Node2.fDisToTarget = fDisToTarget;
					_open.Add(j_AStar_Node2);
					continue;
				}
				foreach (J_AStar_Node item in _open)
				{
					if (item == j_AStar_Node2 && item.fDisToTarget > j_AStar_Node2.fDisToTarget)
					{
						break;
					}
				}
			}
			_close.Add(j_AStar_Node);
			if (_open.Count == 0)
			{
				UnityEngine.Debug.Log("Failed Finding Path");
				break;
			}
			float num2 = 100000000f;
			J_AStar_Node j_AStar_Node3 = null;
			foreach (J_AStar_Node item2 in _open)
			{
				if (item2.fDisToTarget < num2)
				{
					num2 = item2.fDisToTarget;
					j_AStar_Node3 = item2;
				}
			}
			if (j_AStar_Node3 != null)
			{
				j_AStar_Node = j_AStar_Node3;
				_open.Remove(j_AStar_Node3);
			}
		}
		_close.Add(endPoint);
		return _close;
	}

	private void OnDrawGizmos()
	{
		if (_close != null && _close.Count > 1)
		{
			_ = _close.Count;
			Gizmos.color = Color.yellow;
			Vector3 from = _close[0].transform.position;
			for (int i = 0; i < _close.Count - 1; i++)
			{
				Vector3 position = _close[(i + 1) % _close.Count].transform.position;
				Gizmos.DrawLine(from, position);
				from = position;
			}
		}
	}
}
public class J_MapEnterance : MonoBehaviour
{
	public class gateC
	{
		public Vector3 vGatePos;

		public Transform transGateCamStayPos;
	}

	public static J_MapEnterance Inst;

	public string m_MapName;

	public J_AStar_WayTracker m_MapPathsTrackerContainer;

	public Transform m_gatesContainer;

	public static string m_fromMapName;

	public static string m_targetMapName;

	private static MapEnteranceData _mapDatas;

	private List<string> listDoors = new List<string>();

	private Dictionary<string, gateC> m_dicAllGates = new Dictionary<string, gateC>();

	public static MapEnteranceData m_mapDatas
	{
		get
		{
			if (_mapDatas == null)
			{
				_mapDatas = Resources.Load<MapEnteranceData>("Map Enterance Data");
				_mapDatas.Init();
			}
			return _mapDatas;
		}
	}

	private void Awake()
	{
		Inst = this;
		foreach (Transform item in m_gatesContainer)
		{
			if (m_dicAllGates.ContainsKey(item.name))
			{
				UnityEngine.Debug.LogError("--gate name dupulicated");
				continue;
			}
			gateC gateC = new gateC();
			gateC.vGatePos = item.position;
			gateC.transGateCamStayPos = item.Find("CamStayPos");
			if (gateC.transGateCamStayPos == null)
			{
				UnityEngine.Debug.LogWarning("门" + item.name + "没有CamStayPos");
			}
			m_dicAllGates.Add(item.name, gateC);
		}
		J_WaveVR_CurveRayTeleport.actionOnTeleport = (Action)Delegate.Combine(J_WaveVR_CurveRayTeleport.actionOnTeleport, new Action(J_RefreshMapRoute));
	}

	private void OnDestroy()
	{
		J_WaveVR_CurveRayTeleport.actionOnTeleport = (Action)Delegate.Remove(J_WaveVR_CurveRayTeleport.actionOnTeleport, new Action(J_RefreshMapRoute));
	}

	private void Start()
	{
		if (!string.IsNullOrEmpty(m_fromMapName) && m_dicAllGates.ContainsKey(m_fromMapName))
		{
			Transform transGateCamStayPos = m_dicAllGates[m_fromMapName].transGateCamStayPos;
			if (transGateCamStayPos != null)
			{
				WaveVRHead.Inst.ForceSetHeadToTarget(transGateCamStayPos.transform.position, transGateCamStayPos.transform.eulerAngles);
			}
		}
		if (!string.IsNullOrEmpty(m_targetMapName))
		{
			FindPathToMap(WaveVRHead.Inst.headCam.position, m_targetMapName);
		}
	}

	public void J_RefreshMapRoute()
	{
		if (!string.IsNullOrEmpty(m_targetMapName))
		{
			FindPathToMap(WaveVRHead.Inst.headCam.position, m_targetMapName);
		}
	}

	public void FindPathToMap(Vector3 startPos, string toMap)
	{
		startPos.y = base.transform.position.y;
		if (m_mapDatas.tryFindDoorPath(m_MapName, toMap, ref listDoors))
		{
			string text = listDoors[0];
			if (!m_dicAllGates.ContainsKey(text))
			{
				UnityEngine.Debug.LogError("--gate transform not exit:" + text);
			}
			else
			{
				PathLineController.Inst.J_SetShowLine(m_MapPathsTrackerContainer.J_FindPath(startPos, m_dicAllGates[text].vGatePos));
			}
		}
		else
		{
			PathLineController.Inst.J_SetShowLine(null);
		}
	}

	public void J_LoadScene(string sceneName)
	{
		m_fromMapName = m_MapName;
		Load.LoadScene2(sceneName.ToLower());
	}
}
[CreateAssetMenu(menuName = "地图出入口数据")]
public class MapEnteranceData : ScriptableObject
{
	[Serializable]
	public class mapInfo
	{
		public string mapName;

		public List<string> m_gates;
	}

	public List<mapInfo> m_mapsInfo;

	public Dictionary<string, mapInfo> m_dicMapInfos;

	public void Init()
	{
		if (m_dicMapInfos == null)
		{
			m_dicMapInfos = new Dictionary<string, mapInfo>();
		}
		foreach (mapInfo item in m_mapsInfo)
		{
			if (m_dicMapInfos.ContainsKey(item.mapName))
			{
				UnityEngine.Debug.LogError("--map name dupulicated");
			}
			else
			{
				m_dicMapInfos.Add(item.mapName, item);
			}
		}
		foreach (mapInfo item2 in m_mapsInfo)
		{
			foreach (string gate in item2.m_gates)
			{
				if (!m_dicMapInfos.ContainsKey(gate))
				{
					UnityEngine.Debug.LogError("该入口没有对应的地图:" + gate + " from " + item2.mapName);
				}
			}
		}
	}

	public bool tryFindDoorPath(string fromMapName, string targetMapName, ref List<string> listDoors)
	{
		listDoors.Clear();
		if (string.Equals(fromMapName, targetMapName))
		{
			UnityEngine.Debug.LogWarning("--已在当前地图");
			return false;
		}
		if (!m_dicMapInfos.ContainsKey(fromMapName))
		{
			UnityEngine.Debug.LogWarning("--当前地图不存在，请检查" + fromMapName);
			return false;
		}
		if (!m_dicMapInfos.ContainsKey(targetMapName))
		{
			UnityEngine.Debug.LogWarning("--目标地图不存在，请检查" + targetMapName);
			return false;
		}
		mapInfo mapInfo = m_dicMapInfos[fromMapName];
		foreach (string gate in mapInfo.m_gates)
		{
			if (string.Equals(gate, targetMapName))
			{
				listDoors.Add(gate);
			}
			else if (findGate(mapInfo.mapName, gate, targetMapName, ref listDoors))
			{
				listDoors.Add(gate);
				break;
			}
		}
		if (listDoors.Count != 0)
		{
			listDoors.Reverse();
			return true;
		}
		return false;
	}

	private bool findGate(string fromMap, string gateName, string targetMapName, ref List<string> listDoors)
	{
		if (string.Equals(gateName, targetMapName))
		{
			return true;
		}
		mapInfo mapInfo = m_dicMapInfos[gateName];
		foreach (string gate in mapInfo.m_gates)
		{
			if (!string.Equals(gate, fromMap) && findGate(mapInfo.mapName, gate, targetMapName, ref listDoors))
			{
				listDoors.Add(gate);
				return true;
			}
		}
		return false;
	}
}
public class PathLineController : MonoBehaviour
{
	public static PathLineController Inst;

	public LineRenderer m_renderLine;

	private void Awake()
	{
		Inst = this;
		m_renderLine.positionCount = 0;
	}

	private void Start()
	{
	}

	private void Update()
	{
		m_renderLine.material.mainTextureOffset -= new Vector2(1f, 0f) * Time.deltaTime;
	}

	public void J_SetShowLine(List<Vector3> vPathPoints)
	{
		_showLine(vPathPoints);
	}

	private void _showLine(List<Vector3> vPathPoints)
	{
		if (vPathPoints != null && vPathPoints.Count > 0)
		{
			Vector3[] array = new Vector3[vPathPoints.Count];
			vPathPoints.CopyTo(array);
			m_renderLine.positionCount = array.Length;
			m_renderLine.SetPositions(array);
		}
		else
		{
			m_renderLine.positionCount = 0;
		}
	}
}
public class J_VoiceRecCtrl : MonoBehaviour
{
	public class VoiceResult
	{
		public Header header;

		public string name;

		public Payload payload;
	}

	public class Header
	{
		public string name;
	}

	public class Payload
	{
		public string result;
	}

	public static J_VoiceRecCtrl Inst;

	public MicrophoneRecordCtrl m_microphoneRecordCtrl;

	public GameObject m_objShengBo;

	public RectTransform tempContainer_Bo;

	public GameObject m_objTxtResult;

	public Text m_txtRecResult;

	public Text djs;

	private float fVanishTimer;

	public float m_fVanishTime = 2f;

	private const int VOLUME_DATA_LENGTH = 64;

	public Action<DataRequestResult_voiceData> actionOnVoiceResultRec;

	private float[] Volume;

	private int frameC;

	private float endTime;

	public float daojishi;

	private float stime;

	private bool callNewResult;

	private bool isGettingVoiceResult;

	private AndroidJavaClass ajc;

	private AndroidJavaObject ajo;

	private string recogedWordsAll = "";

	private string recogedWords = "";

	private bool isInit;

	private Queue<float> sblist = new Queue<float>();

	private void Start()
	{
		init();
		for (int i = 0; i < tempContainer_Bo.childCount; i++)
		{
			tempContainer_Bo.GetChild(i).localScale = new Vector3(1f, 0.1f, 1f);
		}
		base.transform.Find("GameObject/Canvas").Translate(new Vector3(0f, 0.15f, 0f));
	}

	public void J_SetWordsRecResultReceiver(Action<DataRequestResult_voiceData> _actionOnVoiceResultRec)
	{
		actionOnVoiceResultRec = _actionOnVoiceResultRec;
	}

	private void Awake()
	{
		Inst = this;
		m_objShengBo.SetActive(value: false);
		m_objTxtResult.SetActive(value: false);
		djs.gameObject.SetActive(value: false);
	}

	private void Update()
	{
		if (stime > 0f && daojishi > 0f)
		{
			djs.text = "剩余(" + (daojishi - (Time.time - stime)).ToString("F1") + ")秒";
		}
		if (stime > 0f && daojishi > 0f && Time.time - stime >= daojishi)
		{
			daojishi = 0f;
			string text = m_txtRecResult.text;
			StopRec();
			actionOnVoiceResultRec?.Invoke(new DataRequestResult_voiceData
			{
				file_txt = (string.IsNullOrEmpty(text) ? "未说话" : text)
			});
		}
		if (stime > 0f && callNewResult && recogedWords != "")
		{
			callNewResult = false;
			actionOnVoiceResultRec?.Invoke(new DataRequestResult_voiceData
			{
				file_txt = ((daojishi == 0f) ? recogedWords : m_txtRecResult.text)
			});
			recogedWords = "";
		}
		_SetShengboP();
	}

	private float getminvalue()
	{
		float num = float.MaxValue;
		if (Volume != null)
		{
			float[] volume = Volume;
			foreach (float num2 in volume)
			{
				if (num2 < num)
				{
					num = num2;
				}
			}
		}
		return num;
	}

	private void _SetShengboP()
	{
		if (!(stime > 0f))
		{
			return;
		}
		frameC++;
		if (frameC % 5 == 0)
		{
			float[] array = sblist.ToArray();
			for (int i = 0; i < array.Length && i < tempContainer_Bo.childCount; i++)
			{
				float y = Math.Min(Math.Max(array[i] + 80f, 0.1f) / 45f, 1f);
				tempContainer_Bo.GetChild(i).localScale = new Vector3(1f, y, 1f);
			}
		}
	}

	public void StartRec()
	{
		m_txtRecResult.text = "";
		recogedWordsAll = "";
		stime = Time.time;
		AudioListener.volume = 0.5f;
		m_objShengBo.SetActive(value: true);
		m_objTxtResult.SetActive(value: true);
		if (daojishi > 0f)
		{
			djs.gameObject.SetActive(value: true);
		}
		else
		{
			djs.gameObject.SetActive(value: false);
		}
		ks();
	}

	public void StopRec(bool hideResult = false)
	{
		recogedWordsAll = "";
		stime = 0f;
		AudioListener.volume = 1f;
		daojishi = 0f;
		if ((bool)m_objShengBo)
		{
			m_objShengBo.SetActive(value: false);
		}
		if (hideResult && (bool)m_objTxtResult)
		{
			m_objTxtResult.SetActive(value: false);
		}
		js();
		if ((bool)djs)
		{
			djs.gameObject.SetActive(value: false);
		}
	}

	public void init(bool stPlay = false)
	{
		try
		{
			if (isInit)
			{
				if (stPlay)
				{
					ks();
				}
				return;
			}
			ajc = new AndroidJavaClass("cn.Guava.CRCI.AliyunVoice");
			ajc.CallStatic("start");
			ajo = ajc.GetStatic<AndroidJavaObject>("instance");
			if (ajo == null)
			{
				return;
			}
			StartCoroutine(HttpGet(UrlUtils.baseUrl_es + "api/aliyun", delegate(string tk)
			{
				string value = new Regex("\"data\":\"(\\w+)\"").Match(tk).Groups[1].Value;
				string text = ajo.Call<string>("Init", new object[6]
				{
					"3CvZr9CLdQCBSaZ0",
					value,
					base.gameObject.name,
					"OnRecStateChange",
					"OnRecCallback",
					"OnVolumnCallback"
				});
				if (text == "0")
				{
					isInit = true;
					if (stPlay)
					{
						ks();
					}
					log("aliyun Init success");
				}
				else
				{
					log("aliyun 初始化失败:" + text);
				}
			}));
		}
		catch (Exception ex)
		{
			log("init error:" + ex.Message);
		}
	}

	private void log(string s)
	{
	}

	private void log2(string s)
	{
	}

	public void ks()
	{
		if (!isInit)
		{
			init(stPlay: true);
		}
		else if (ajo != null)
		{
			int num = ajo.Call<int>("Start", Array.Empty<object>());
			log2("aliyun Start:" + num);
		}
	}

	public void js()
	{
		if (ajo != null)
		{
			int num = ajo.Call<int>("Stop", Array.Empty<object>());
			log2("aliyun End:" + num);
		}
	}

	private void OnDisable()
	{
		js();
	}

	private void OnDestroy()
	{
		js();
		ajo.Call("Destory");
	}

	public void OnRecStateChange(string msg)
	{
		log("aliyun OnRecStateChange:" + msg);
	}

	public void OnVolumnCallback(string val)
	{
		sblist.Enqueue(float.Parse(val));
		if (sblist.Count > 64)
		{
			sblist.Dequeue();
		}
	}

	public void OnRecCallback(string msg)
	{
		log(msg);
		VoiceResult voiceResult = LitJson.JsonMapper.ToObject<VoiceResult>(msg);
		if (voiceResult == null || voiceResult.payload == null || string.IsNullOrEmpty(voiceResult.payload.result))
		{
			return;
		}
		string text = voiceResult.payload.result.FilterRecWord();
		if ((bool)m_txtRecResult)
		{
			m_txtRecResult.text = recogedWordsAll + text;
		}
		if (voiceResult.header != null && voiceResult.header.name != null && voiceResult.header.name.Contains("SentenceEnd"))
		{
			recogedWordsAll += text;
			if (stime > 0f)
			{
				callNewResult = true;
				recogedWords = text;
			}
		}
	}

	private IEnumerator HttpGet(string uri, Action<string> cb)
	{
		new WWWForm();
		using UnityWebRequest webRequest = UnityWebRequest.Get(uri);
		yield return webRequest.SendWebRequest();
		if (webRequest.isHttpError || webRequest.isNetworkError)
		{
			log("HttpGet:" + webRequest.error);
			yield break;
		}
		try
		{
			cb(webRequest.downloadHandler.text);
		}
		catch (Exception ex)
		{
			log("json format error:" + webRequest.downloadHandler.text);
			log(ex.Message);
		}
	}
}
public class WebRequestCert : CertificateHandler
{
	protected override bool ValidateCertificate(byte[] certificateData)
	{
		return true;
	}
}
[DisallowMultipleComponent]
public class J_InteractableOutline : MonoBehaviour, IPointerEnterHandler, IEventSystemHandler, IPointerExitHandler
{
	[Serializable]
	private class ListVector3
	{
		public List<Vector3> data;
	}

	private static HashSet<Mesh> registeredMeshes = new HashSet<Mesh>();

	[SerializeField]
	private Color outlineColor = Color.green;

	[SerializeField]
	[Range(0f, 10f)]
	private float outlineWidth = 6f;

	[Header("Optional")]
	[SerializeField]
	[Tooltip("Precompute enabled: Per-vertex calculations are performed in the editor and serialized with the object. Precompute disabled: Per-vertex calculations are performed at runtime in Awake(). This may cause a pause for large meshes.")]
	private bool precomputeOutline = true;

	[SerializeField]
	[HideInInspector]
	private List<Mesh> bakeKeys = new List<Mesh>();

	[SerializeField]
	[HideInInspector]
	private List<ListVector3> bakeValues = new List<ListVector3>();

	private Renderer[] renderers;

	private Material outlineMaskMaterial;

	private Material outlineFillMaterial;

	private bool needsUpdate;

	private bool m_isOutlineCaseEnable = true;

	public Color OutlineColor
	{
		get
		{
			return outlineColor;
		}
		set
		{
			outlineColor = value;
			needsUpdate = true;
		}
	}

	public float OutlineWidth
	{
		get
		{
			return outlineWidth;
		}
		set
		{
			outlineWidth = value;
			needsUpdate = true;
		}
	}

	private void Awake()
	{
		renderers = GetComponentsInChildren<Renderer>();
		outlineMaskMaterial = UnityEngine.Object.Instantiate(Resources.Load<Material>("Materials/OutlineMask"));
		outlineFillMaterial = UnityEngine.Object.Instantiate(Resources.Load<Material>("Materials/OutlineFill"));
		outlineMaskMaterial.name = "OutlineMask (Instance)";
		outlineFillMaterial.name = "OutlineFill (Instance)";
		LoadSmoothNormals();
		needsUpdate = true;
		UpdateMaterialProperties();
	}

	private void OnEnable()
	{
	}

	private void OnValidate()
	{
		needsUpdate = true;
		if ((!precomputeOutline && bakeKeys.Count != 0) || bakeKeys.Count != bakeValues.Count)
		{
			bakeKeys.Clear();
			bakeValues.Clear();
		}
		if (precomputeOutline && bakeKeys.Count == 0)
		{
			Bake();
		}
	}

	private void OnDestroy()
	{
		UnityEngine.Object.Destroy(outlineMaskMaterial);
		UnityEngine.Object.Destroy(outlineFillMaterial);
	}

	private void Bake()
	{
		HashSet<Mesh> hashSet = new HashSet<Mesh>();
		MeshFilter[] componentsInChildren = GetComponentsInChildren<MeshFilter>();
		foreach (MeshFilter meshFilter in componentsInChildren)
		{
			if (hashSet.Add(meshFilter.sharedMesh))
			{
				List<Vector3> data = SmoothNormals(meshFilter.sharedMesh);
				bakeKeys.Add(meshFilter.sharedMesh);
				bakeValues.Add(new ListVector3
				{
					data = data
				});
			}
		}
	}

	private void LoadSmoothNormals()
	{
		MeshFilter[] componentsInChildren = GetComponentsInChildren<MeshFilter>();
		foreach (MeshFilter meshFilter in componentsInChildren)
		{
			if (registeredMeshes.Add(meshFilter.sharedMesh))
			{
				int num = bakeKeys.IndexOf(meshFilter.sharedMesh);
				List<Vector3> uvs = ((num >= 0) ? bakeValues[num].data : SmoothNormals(meshFilter.sharedMesh));
				meshFilter.sharedMesh.SetUVs(3, uvs);
			}
		}
		SkinnedMeshRenderer[] componentsInChildren2 = GetComponentsInChildren<SkinnedMeshRenderer>();
		foreach (SkinnedMeshRenderer skinnedMeshRenderer in componentsInChildren2)
		{
			if (registeredMeshes.Add(skinnedMeshRenderer.sharedMesh))
			{
				skinnedMeshRenderer.sharedMesh.uv4 = new Vector2[skinnedMeshRenderer.sharedMesh.vertexCount];
			}
		}
	}

	private List<Vector3> SmoothNormals(Mesh mesh)
	{
		IEnumerable<IGrouping<Vector3, KeyValuePair<Vector3, int>>> enumerable = from pair in mesh.vertices.Select((Vector3 vertex, int index) => new KeyValuePair<Vector3, int>(vertex, index))
			group pair by pair.Key;
		List<Vector3> list = new List<Vector3>(mesh.normals);
		foreach (IGrouping<Vector3, KeyValuePair<Vector3, int>> item in enumerable)
		{
			if (item.Count() == 1)
			{
				continue;
			}
			Vector3 zero = Vector3.zero;
			foreach (KeyValuePair<Vector3, int> item2 in item)
			{
				zero += mesh.normals[item2.Value];
			}
			zero.Normalize();
			foreach (KeyValuePair<Vector3, int> item3 in item)
			{
				list[item3.Value] = zero;
			}
		}
		return list;
	}

	private void UpdateMaterialProperties()
	{
		outlineFillMaterial.SetColor("_OutlineColor", outlineColor);
		outlineMaskMaterial.SetFloat("_ZTest", 8f);
		outlineFillMaterial.SetFloat("_ZTest", 8f);
		outlineFillMaterial.SetFloat("_OutlineWidth", outlineWidth);
	}

	public void OnPointerEnter(PointerEventData eventData)
	{
		if (m_isOutlineCaseEnable)
		{
			UnityEngine.Debug.LogWarning(1);
			Renderer[] array = renderers;
			foreach (Renderer obj in array)
			{
				List<Material> list = obj.sharedMaterials.ToList();
				list.Add(outlineMaskMaterial);
				list.Add(outlineFillMaterial);
				obj.materials = list.ToArray();
			}
		}
	}

	public void OnPointerExit(PointerEventData eventData)
	{
		if (m_isOutlineCaseEnable)
		{
			UnityEngine.Debug.LogWarning(2);
			_removeMat();
		}
	}

	private void _removeMat()
	{
		Renderer[] array = renderers;
		foreach (Renderer obj in array)
		{
			List<Material> list = obj.sharedMaterials.ToList();
			list.Remove(outlineMaskMaterial);
			list.Remove(outlineFillMaterial);
			obj.materials = list.ToArray();
		}
	}

	public void J_SetOutlineCastEnable(bool isEnable)
	{
		m_isOutlineCaseEnable = isEnable;
		if (!m_isOutlineCaseEnable)
		{
			_removeMat();
		}
	}
}
[DisallowMultipleComponent]
public class Outline : MonoBehaviour
{
	public enum Mode
	{
		OutlineAll,
		OutlineVisible,
		OutlineHidden,
		OutlineAndSilhouette,
		SilhouetteOnly
	}

	[Serializable]
	private class ListVector3
	{
		public List<Vector3> data;
	}

	private static HashSet<Mesh> registeredMeshes = new HashSet<Mesh>();

	[SerializeField]
	private Mode outlineMode;

	[SerializeField]
	private Color outlineColor = Color.white;

	[SerializeField]
	[Range(0f, 10f)]
	private float outlineWidth = 2f;

	[Header("Optional")]
	[SerializeField]
	[Tooltip("Precompute enabled: Per-vertex calculations are performed in the editor and serialized with the object. Precompute disabled: Per-vertex calculations are performed at runtime in Awake(). This may cause a pause for large meshes.")]
	private bool precomputeOutline;

	[SerializeField]
	[HideInInspector]
	private List<Mesh> bakeKeys = new List<Mesh>();

	[SerializeField]
	[HideInInspector]
	private List<ListVector3> bakeValues = new List<ListVector3>();

	private Renderer[] renderers;

	private Material outlineMaskMaterial;

	private Material outlineFillMaterial;

	private bool needsUpdate;

	public Mode OutlineMode
	{
		get
		{
			return outlineMode;
		}
		set
		{
			outlineMode = value;
			needsUpdate = true;
		}
	}

	public Color OutlineColor
	{
		get
		{
			return outlineColor;
		}
		set
		{
			outlineColor = value;
			needsUpdate = true;
		}
	}

	public float OutlineWidth
	{
		get
		{
			return outlineWidth;
		}
		set
		{
			outlineWidth = value;
			needsUpdate = true;
		}
	}

	private void Awake()
	{
		renderers = GetComponentsInChildren<Renderer>();
		outlineMaskMaterial = UnityEngine.Object.Instantiate(Resources.Load<Material>("Materials/OutlineMask"));
		outlineFillMaterial = UnityEngine.Object.Instantiate(Resources.Load<Material>("Materials/OutlineFill"));
		outlineMaskMaterial.name = "OutlineMask (Instance)";
		outlineFillMaterial.name = "OutlineFill (Instance)";
		LoadSmoothNormals();
		needsUpdate = true;
	}

	private void OnEnable()
	{
		Renderer[] array = renderers;
		foreach (Renderer obj in array)
		{
			List<Material> list = obj.sharedMaterials.ToList();
			list.Add(outlineMaskMaterial);
			list.Add(outlineFillMaterial);
			obj.materials = list.ToArray();
		}
	}

	private void OnValidate()
	{
		needsUpdate = true;
		if ((!precomputeOutline && bakeKeys.Count != 0) || bakeKeys.Count != bakeValues.Count)
		{
			bakeKeys.Clear();
			bakeValues.Clear();
		}
		if (precomputeOutline && bakeKeys.Count == 0)
		{
			Bake();
		}
	}

	private void Update()
	{
		if (needsUpdate)
		{
			needsUpdate = false;
			UpdateMaterialProperties();
		}
	}

	private void OnDisable()
	{
		Renderer[] array = renderers;
		foreach (Renderer obj in array)
		{
			List<Material> list = obj.sharedMaterials.ToList();
			list.Remove(outlineMaskMaterial);
			list.Remove(outlineFillMaterial);
			obj.materials = list.ToArray();
		}
	}

	private void OnDestroy()
	{
		UnityEngine.Object.Destroy(outlineMaskMaterial);
		UnityEngine.Object.Destroy(outlineFillMaterial);
	}

	private void Bake()
	{
		HashSet<Mesh> hashSet = new HashSet<Mesh>();
		MeshFilter[] componentsInChildren = GetComponentsInChildren<MeshFilter>();
		foreach (MeshFilter meshFilter in componentsInChildren)
		{
			if (hashSet.Add(meshFilter.sharedMesh))
			{
				List<Vector3> data = SmoothNormals(meshFilter.sharedMesh);
				bakeKeys.Add(meshFilter.sharedMesh);
				bakeValues.Add(new ListVector3
				{
					data = data
				});
			}
		}
	}

	private void LoadSmoothNormals()
	{
		MeshFilter[] componentsInChildren = GetComponentsInChildren<MeshFilter>();
		foreach (MeshFilter meshFilter in componentsInChildren)
		{
			if (registeredMeshes.Add(meshFilter.sharedMesh))
			{
				int num = bakeKeys.IndexOf(meshFilter.sharedMesh);
				List<Vector3> uvs = ((num >= 0) ? bakeValues[num].data : SmoothNormals(meshFilter.sharedMesh));
				meshFilter.sharedMesh.SetUVs(3, uvs);
			}
		}
		SkinnedMeshRenderer[] componentsInChildren2 = GetComponentsInChildren<SkinnedMeshRenderer>();
		foreach (SkinnedMeshRenderer skinnedMeshRenderer in componentsInChildren2)
		{
			if (registeredMeshes.Add(skinnedMeshRenderer.sharedMesh))
			{
				skinnedMeshRenderer.sharedMesh.uv4 = new Vector2[skinnedMeshRenderer.sharedMesh.vertexCount];
			}
		}
	}

	private List<Vector3> SmoothNormals(Mesh mesh)
	{
		IEnumerable<IGrouping<Vector3, KeyValuePair<Vector3, int>>> enumerable = from pair in mesh.vertices.Select((Vector3 vertex, int index) => new KeyValuePair<Vector3, int>(vertex, index))
			group pair by pair.Key;
		List<Vector3> list = new List<Vector3>(mesh.normals);
		foreach (IGrouping<Vector3, KeyValuePair<Vector3, int>> item in enumerable)
		{
			if (item.Count() == 1)
			{
				continue;
			}
			Vector3 zero = Vector3.zero;
			foreach (KeyValuePair<Vector3, int> item2 in item)
			{
				zero += mesh.normals[item2.Value];
			}
			zero.Normalize();
			foreach (KeyValuePair<Vector3, int> item3 in item)
			{
				list[item3.Value] = zero;
			}
		}
		return list;
	}

	private void UpdateMaterialProperties()
	{
		outlineFillMaterial.SetColor("_OutlineColor", outlineColor);
		switch (outlineMode)
		{
		case Mode.OutlineAll:
			outlineMaskMaterial.SetFloat("_ZTest", 8f);
			outlineFillMaterial.SetFloat("_ZTest", 8f);
			outlineFillMaterial.SetFloat("_OutlineWidth", outlineWidth);
			break;
		case Mode.OutlineVisible:
			outlineMaskMaterial.SetFloat("_ZTest", 8f);
			outlineFillMaterial.SetFloat("_ZTest", 4f);
			outlineFillMaterial.SetFloat("_OutlineWidth", outlineWidth);
			break;
		case Mode.OutlineHidden:
			outlineMaskMaterial.SetFloat("_ZTest", 8f);
			outlineFillMaterial.SetFloat("_ZTest", 5f);
			outlineFillMaterial.SetFloat("_OutlineWidth", outlineWidth);
			break;
		case Mode.OutlineAndSilhouette:
			outlineMaskMaterial.SetFloat("_ZTest", 4f);
			outlineFillMaterial.SetFloat("_ZTest", 8f);
			outlineFillMaterial.SetFloat("_OutlineWidth", outlineWidth);
			break;
		case Mode.SilhouetteOnly:
			outlineMaskMaterial.SetFloat("_ZTest", 4f);
			outlineFillMaterial.SetFloat("_ZTest", 5f);
			outlineFillMaterial.SetFloat("_OutlineWidth", 0f);
			break;
		}
	}
}
public class _loopPlayTexture : MonoBehaviour
{
	public Renderer render;

	public List<Texture> listTextures;

	public float _delayTime = 0.2f;

	private float ftimer;

	private int icurindex;

	private void Update()
	{
		if (!((ftimer += Time.deltaTime) > _delayTime))
		{
			return;
		}
		ftimer = 0f;
		if (icurindex >= 0 && icurindex < listTextures.Count)
		{
			if (listTextures[icurindex] != null)
			{
				render.material.mainTexture = listTextures[icurindex];
			}
			if (++icurindex > listTextures.Count - 1)
			{
				icurindex = 0;
			}
		}
	}
}
public class AchievementSample : MonoBehaviour
{
	public Text dataOutput;

	public InputField getDefinitionsByNameInputField;

	public InputField getProgressByNameInputField;

	public InputField unLockInputField;

	public InputField addCountInputField;

	public InputField addFieldsInputField;

	private void Start()
	{
		AchievementCore.RegisterNetwork();
	}

	private void OnDestroy()
	{
		AchievementCore.UnRegisterNetwork();
	}

	private void OnApplicationPause(bool pause)
	{
		if (!pause)
		{
			printOutputLine("Achievement Init");
			achievementInit();
		}
	}

	private void Update()
	{
		Request.RunCallbacks();
	}

	public void AsyncInitialize()
	{
		dataOutput.text = "> ";
		printOutputLine("AsyncInitialize");
		achievementInit();
	}

	public void GetDefinitionsByName()
	{
		dataOutput.text = "> ";
		printOutputLine("GetDefinitionsByName");
		string text = getDefinitionsByNameInputField.text;
		if (text != "")
		{
			string[] achievementNames = text.Split(',');
			getAchievementDefinition(achievementNames);
			getDefinitionsByNameInputField.text = "";
		}
		else
		{
			printOutputLine("Invalid Command");
		}
	}

	public void GetProgressByName()
	{
		dataOutput.text = "> ";
		printOutputLine("GetProgressByName");
		string text = getProgressByNameInputField.text;
		if (text != "")
		{
			string[] achievementNames = text.Split(',');
			getAchievementProgress(achievementNames);
			getProgressByNameInputField.text = "";
		}
		else
		{
			printOutputLine("Invalid Command");
		}
	}

	public void GetAllDefinitions()
	{
		dataOutput.text = "> ";
		printOutputLine("GetAllDefinitions");
		getAchievementAllDefinition();
	}

	public void GetAllProgress()
	{
		dataOutput.text = "> ";
		printOutputLine("GetAllProgress");
		getAchievementAllProgress();
	}

	public void UnLock()
	{
		dataOutput.text = "> ";
		printOutputLine("UnLock");
		string text = unLockInputField.text;
		if (text != "")
		{
			unlockAchievement(text);
			unLockInputField.text = "";
		}
		else
		{
			printOutputLine("Invalid Command");
		}
	}

	public void AddCount()
	{
		dataOutput.text = "> ";
		printOutputLine("AddCount");
		string text = addCountInputField.text;
		if (text != "")
		{
			string[] array = text.Split(',');
			if (array.Length > 1)
			{
				try
				{
					Convert.ToInt64(array[1]);
				}
				catch (Exception)
				{
					printOutputLine("Invalid Command");
					throw;
				}
				addCountAchievement(array[0], array[1]);
				addCountInputField.text = "";
			}
			else
			{
				printOutputLine("Invalid Command");
			}
		}
		else
		{
			printOutputLine("Invalid Command");
		}
	}

	public void AddFields()
	{
		dataOutput.text = "> ";
		printOutputLine("AddFields");
		string text = addFieldsInputField.text;
		if (text != "")
		{
			string[] array = text.Split(',');
			if (array.Length > 1)
			{
				addFieldsAchievement(array[0], array[1]);
				addFieldsInputField.text = "";
			}
			else
			{
				printOutputLine("Invalid Command");
			}
		}
		else
		{
			printOutputLine("Invalid Command");
		}
	}

	private void achievementInit()
	{
		Achievements.Init().OnComplete(initAchievementCallback);
	}

	private void getAchievementAllDefinition()
	{
		Achievements.GetAllDefinitions().OnComplete(achievementAllDefinitionCallback);
	}

	private void getAchievementAllProgress()
	{
		Achievements.GetAllProgress().OnComplete(achievementAllProgressCallback);
	}

	private void addFieldsAchievement(string achievementName, string fields)
	{
		Achievements.AddFields(achievementName, fields).OnComplete(achievementFieldsCallback);
	}

	private void addCountAchievement(string achievementName, string count)
	{
		Achievements.AddCount(achievementName, Convert.ToInt64(count)).OnComplete(achievementCountCallback);
	}

	private void unlockAchievement(string achievementName)
	{
		Achievements.Unlock(achievementName).OnComplete(achievementUnlockCallback);
	}

	private void getAchievementProgress(string[] achievementNames)
	{
		Achievements.GetProgressByName(achievementNames).OnComplete(achievementProgressCallback);
	}

	private void getAchievementDefinition(string[] achievementNames)
	{
		Achievements.GetDefinitionsByName(achievementNames).OnComplete(achievementDefinitionCallback);
	}

	private void printOutputLine(string newLine)
	{
		dataOutput.text = "> " + newLine + Environment.NewLine + dataOutput.text;
	}

	private void achievementAllDefinitionCallback(Pvr_Message<Pvr_AchievementDefinitionList> msg)
	{
		if (!msg.IsError)
		{
			printOutputLine("Received achievement definitions success");
			Pvr_AchievementDefinitionList achievementDefinitions = msg.GetAchievementDefinitions();
			if (achievementDefinitions.HasNextPage)
			{
				Achievements.GetNextAchievementDefinitionListPage(achievementDefinitions).OnComplete(achievementAllDefinitionCallback);
			}
			{
				foreach (Pvr_AchievementDefinition item in achievementDefinitions)
				{
					printOutputLine("Bitfield Name: " + item.Name.ToString());
					switch (item.Type)
					{
					case AchievementType.Simple:
						printOutputLine("Achievement Type: Simple");
						break;
					case AchievementType.Bitfield:
						printOutputLine("Achievement Type: Bitfield");
						printOutputLine("Bitfield Length: " + item.BitfieldLength);
						printOutputLine("Target: " + item.Target);
						break;
					case AchievementType.Count:
						printOutputLine("Achievement Type: Count");
						printOutputLine("Target: " + item.Target);
						break;
					default:
						printOutputLine("Achievement Type: Unknown");
						break;
					}
					printOutputLine("Bitfield Title: " + item.Title.ToString());
					printOutputLine("Bitfield Description: " + item.Description.ToString());
					printOutputLine("Bitfield UnlockedDescription: " + item.UnlockedDescription.ToString());
					printOutputLine("Bitfield UnlockedIcon: " + item.UnlockedIcon.ToString());
					printOutputLine("Bitfield LockedIcon: " + item.LockedIcon.ToString());
					printOutputLine("Bitfield IsSecrect: " + item.IsSecrect);
				}
				return;
			}
		}
		printOutputLine("Received achievement definitions error");
		Error error = msg.GetError();
		printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
	}

	private void achievementAllProgressCallback(Pvr_Message<Pvr_AchievementProgressList> msg)
	{
		if (!msg.IsError)
		{
			printOutputLine("Received achievement progress success");
			Pvr_AchievementProgressList achievementProgressList = msg.GetAchievementProgressList();
			if (achievementProgressList.HasNextPage)
			{
				Achievements.GetNextAchievementProgressListPage(achievementProgressList).OnComplete(achievementAllProgressCallback);
			}
			{
				foreach (Pvr_AchievementProgress item in achievementProgressList)
				{
					printOutputLine("Current Name: " + item.Name.ToString());
					if (item.IsUnlocked)
					{
						printOutputLine("Achievement Unlocked");
					}
					else
					{
						printOutputLine("Achievement Locked");
					}
					printOutputLine("Current Bitfield: " + item.Bitfield.ToString());
					printOutputLine("Current Count: " + item.Count);
					printOutputLine("Current UnlockTime: " + item.UnlockTime.ToString());
				}
				return;
			}
		}
		printOutputLine("Received achievement progress error");
		Error error = msg.GetError();
		printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
	}

	private void achievementFieldsCallback(Pvr_Message msg)
	{
		if (!msg.IsError)
		{
			printOutputLine("Achievement fields added.");
			return;
		}
		printOutputLine("Received achievement fields add error");
		Error error = msg.GetError();
		printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
	}

	private void achievementCountCallback(Pvr_Message msg)
	{
		if (!msg.IsError)
		{
			printOutputLine("Achievement count added.");
			return;
		}
		printOutputLine("Received achievement count add error");
		Error error = msg.GetError();
		printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
	}

	private void achievementUnlockCallback(Pvr_Message msg)
	{
		if (!msg.IsError)
		{
			printOutputLine("Achievement unlocked");
			return;
		}
		printOutputLine("Received achievement unlock error");
		Error error = msg.GetError();
		printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
	}

	private void achievementProgressCallback(Pvr_Message<Pvr_AchievementProgressList> msg)
	{
		if (!msg.IsError)
		{
			printOutputLine("Received achievement progress success");
			{
				foreach (Pvr_AchievementProgress achievementProgress in msg.GetAchievementProgressList())
				{
					if (achievementProgress.IsUnlocked)
					{
						printOutputLine("Achievement Unlocked");
					}
					else
					{
						printOutputLine("Achievement Locked");
					}
					printOutputLine("Current Bitfield: " + achievementProgress.Bitfield.ToString());
					printOutputLine("Current Count: " + achievementProgress.Count);
				}
				return;
			}
		}
		printOutputLine("Received achievement progress error");
		Error error = msg.GetError();
		printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
	}

	private void achievementDefinitionCallback(Pvr_Message<Pvr_AchievementDefinitionList> msg)
	{
		if (!msg.IsError)
		{
			printOutputLine("Received achievement definitions success");
			{
				foreach (Pvr_AchievementDefinition achievementDefinition in msg.GetAchievementDefinitions())
				{
					switch (achievementDefinition.Type)
					{
					case AchievementType.Simple:
						printOutputLine("Achievement Type: Simple");
						break;
					case AchievementType.Bitfield:
						printOutputLine("Achievement Type: Bitfield");
						printOutputLine("Bitfield Length: " + achievementDefinition.BitfieldLength);
						printOutputLine("Target: " + achievementDefinition.Target);
						break;
					case AchievementType.Count:
						printOutputLine("Achievement Type: Count");
						printOutputLine("Target: " + achievementDefinition.Target);
						break;
					default:
						printOutputLine("Achievement Type: Unknown");
						break;
					}
				}
				return;
			}
		}
		printOutputLine("Received achievement definitions error");
		Error error = msg.GetError();
		printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
	}

	private void initAchievementCallback(Pvr_Message msg)
	{
		if (!msg.IsError)
		{
			printOutputLine("Received init success");
			return;
		}
		printOutputLine("Received init error");
		Error error = msg.GetError();
		printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
	}

	private void LoginCallback(string LoginInfo)
	{
		UnityEngine.Debug.Log("Received loginCallback:" + LoginInfo);
		printOutputLine("Received loginCallback: " + LoginInfo);
	}
}
public class Pvr_Controller : MonoBehaviour
{
	public enum UserHandNess
	{
		Right,
		Left
	}

	public enum GazeType
	{
		Never,
		DuringMotion,
		Always
	}

	public enum ControllerAxis
	{
		Controller,
		Wrist,
		Elbow,
		Shoulder
	}

	public GameObject controller0;

	public GameObject controller1;

	private static UserHandNess handness;

	public ControllerAxis Axis;

	public GazeType Gazetype;

	[Range(0f, 0.2f)]
	public float ElbowHeight;

	[Range(0f, 0.2f)]
	public float ElbowDepth;

	[Range(0f, 30f)]
	public float PointerTiltAngle = 15f;

	private float mouseX;

	private float mouseY;

	private float mouseZ;

	private Vector3[] inputDirection = new Vector3[2];

	public static Vector3 pointerPosition { get; set; }

	public static Quaternion pointerRotation { get; set; }

	public static Vector3 elbowPosition { get; set; }

	public static Quaternion elbowRotation { get; set; }

	public static Vector3 wristPosition { get; set; }

	public static Quaternion wristRotation { get; set; }

	public static Vector3 shoulderPosition { get; set; }

	public static Quaternion shoulderRotation { get; set; }

	public static Vector3 originOffsetL { get; set; }

	public static Vector3 originOffsetR { get; set; }

	private void Awake()
	{
		Pvr_ControllerManager.PvrServiceStartSuccessEvent += ServiceStartSuccess;
		Pvr_ControllerManager.SetControllerAbilityEvent += CheckControllerState;
		Pvr_ControllerManager.ChangeMainControllerCallBackEvent += MainControllerChanged;
		Pvr_ControllerManager.ChangeHandNessCallBackEvent += HandnessChanged;
	}

	private void Start()
	{
		handness = Controller.UPvr_GetHandNess();
		if (handness == (UserHandNess)(-1))
		{
			handness = UserHandNess.Right;
		}
	}

	private void OnDestroy()
	{
		Pvr_ControllerManager.PvrServiceStartSuccessEvent -= ServiceStartSuccess;
		Pvr_ControllerManager.SetControllerAbilityEvent -= CheckControllerState;
		Pvr_ControllerManager.ChangeMainControllerCallBackEvent -= MainControllerChanged;
		Pvr_ControllerManager.ChangeHandNessCallBackEvent -= HandnessChanged;
	}

	private void MainControllerChanged(string index)
	{
		RefreshHandness();
	}

	private void HandnessChanged(string index)
	{
		RefreshHandness();
	}

	private void ServiceStartSuccess()
	{
		RefreshHandness();
	}

	private void RefreshHandness()
	{
		handness = Controller.UPvr_GetHandNess();
		if (Controller.UPvr_GetMainHandNess() == 1)
		{
			ChangeHandNess();
		}
	}

	private void OnApplicationPause(bool pause)
	{
		if (!pause)
		{
			if (controller0 != null)
			{
				controller0.transform.localScale = Vector3.zero;
			}
			if (controller1 != null)
			{
				controller1.transform.localScale = Vector3.zero;
			}
		}
		Invoke("ShowController", 0.1f * Time.timeScale);
	}

	private void ShowController()
	{
		if (controller0 != null)
		{
			controller0.transform.localScale = Vector3.one;
		}
		if (controller1 != null)
		{
			controller1.transform.localScale = Vector3.one;
		}
	}

	private void CheckControllerState(string data)
	{
		bool num = Convert.ToBoolean(Convert.ToInt16(data.Substring(4, 1)));
		short num2 = Convert.ToInt16(data.Substring(0, 1));
		if (num && num2 == 1)
		{
			RefreshHandness();
		}
	}

	private void Update()
	{
		if (Pvr_UnitySDKManager.SDK.ControllerOnlyrot)
		{
			DoUpdateControler0();
			DoUpdateControler1();
			UpdateControlloerRay();
			return;
		}
		if (Controller.UPvr_GetPreferenceDevice() == 1)
		{
			DoUpdateControler0();
			DoUpdateControler1();
			UpdateControlloerRay();
			return;
		}
		if (controller0 != null)
		{
			controller0.transform.localRotation = Controller.UPvr_GetControllerQUA(0);
			controller0.transform.localPosition = Controller.UPvr_GetControllerPOS(0) + Controller.UPvr_GetControllerQUA(0) * originOffsetL;
			UpdateControlloerRay(update0: true, update1: false);
		}
		if (controller1 != null)
		{
			controller1.transform.localRotation = Controller.UPvr_GetControllerQUA(1);
			controller1.transform.localPosition = Controller.UPvr_GetControllerPOS(1) + Controller.UPvr_GetControllerQUA(1) * originOffsetR;
			UpdateControlloerRay(update0: false);
		}
	}

	public static void ChangeHandNess()
	{
		handness = ((handness == UserHandNess.Right) ? UserHandNess.Left : UserHandNess.Right);
	}

	private void DoUpdateControler0()
	{
		SetArmParaToSo((int)handness, (int)Gazetype, ElbowHeight, ElbowDepth, PointerTiltAngle);
		CalcArmModelfromSo(0);
		UpdateControllerDataSO(0);
	}

	private void DoUpdateControler1()
	{
		int hand = ((handness != UserHandNess.Left) ? 1 : 0);
		SetArmParaToSo(hand, (int)Gazetype, ElbowHeight, ElbowDepth, PointerTiltAngle);
		CalcArmModelfromSo(1);
		UpdateControllerDataSO(1);
	}

	private void UpdateControlloerRay(bool update0 = true, bool update1 = true)
	{
		if (Pvr_ControllerManager.Instance.LengthAdaptiveRay)
		{
			if (update0 && controller0 != null)
			{
				controller0.GetComponent<Pvr_ControllerModuleInit>().UpdateRay();
			}
			if (update1 && controller1 != null)
			{
				controller1.GetComponent<Pvr_ControllerModuleInit>().UpdateRay();
			}
		}
	}

	private Quaternion UpdateSimulatedFrameParams()
	{
		if (Input.GetKey(KeyCode.LeftShift))
		{
			mouseX += Input.GetAxis("Mouse X") * 5f;
			if (mouseX <= -180f)
			{
				mouseX += 360f;
			}
			else if (mouseX > 180f)
			{
				mouseX -= 360f;
			}
			mouseY -= Input.GetAxis("Mouse Y") * 2.4f;
			mouseY = Mathf.Clamp(mouseY, -80f, 80f);
		}
		else if (Input.GetKey(KeyCode.RightShift))
		{
			mouseZ += Input.GetAxis("Mouse X") * 5f;
			mouseZ = Mathf.Clamp(mouseZ, -80f, 80f);
		}
		return Quaternion.Euler(mouseY, mouseX, mouseZ);
	}

	private void SetArmParaToSo(int hand, int gazeType, float elbowHeight, float elbowDepth, float pointerTiltAngle)
	{
		Controller.UPvr_SetArmModelParameters(hand, gazeType, elbowHeight, elbowDepth, pointerTiltAngle);
	}

	private void CalcArmModelfromSo(int hand)
	{
		float[] array = new float[4];
		float[] array2 = new float[4];
		float[] array3 = new float[3];
		Quaternion quaternion = default(Quaternion);
		quaternion = Controller.UPvr_GetControllerQUA(hand);
		Vector3 vector = Controller.UPvr_GetAngularVelocity(hand);
		array2[0] = quaternion.x;
		array2[1] = quaternion.y;
		array2[2] = quaternion.z;
		array2[3] = quaternion.w;
		array3[0] = vector.x;
		array3[1] = vector.y;
		array3[2] = vector.z;
		if (Gazetype == GazeType.DuringMotion)
		{
			Vector3 b = Pvr_UnitySDKSensor.Instance.HeadPose.Orientation * Vector3.forward;
			b.y = 0f;
			b.Normalize();
			float t = Mathf.Clamp((vector.magnitude - 0.2f) / 45f, 0f, 0.1f);
			inputDirection[hand] = Vector3.Slerp(inputDirection[hand], b, t);
			if (Controller.UPvr_GetKeyLongPressed(hand, Pvr_KeyCode.HOME))
			{
				inputDirection[hand] = default(Vector3);
			}
			Quaternion quaternion2 = Quaternion.FromToRotation(Vector3.forward, inputDirection[hand]);
			array[0] = quaternion2.x;
			array[1] = quaternion2.y;
			array[2] = quaternion2.z;
			array[3] = quaternion2.w;
		}
		else
		{
			array[0] = Pvr_UnitySDKSensor.Instance.HeadPose.Orientation.x;
			array[1] = Pvr_UnitySDKSensor.Instance.HeadPose.Orientation.y;
			array[2] = Pvr_UnitySDKSensor.Instance.HeadPose.Orientation.z;
			array[3] = Pvr_UnitySDKSensor.Instance.HeadPose.Orientation.w;
		}
		Controller.UPvr_CalcArmModelParameters(array, array2, array3);
	}

	public void UpdateControllerDataSO(int hand)
	{
		float[] array = new float[4];
		float[] array2 = new float[3];
		Vector3 vector;
		Quaternion localRotation;
		switch (Axis)
		{
		case ControllerAxis.Controller:
			Controller.UPvr_GetPointerPose(array, array2);
			pointerPosition = new Vector3(array2[0], array2[1], array2[2]);
			pointerRotation = new Quaternion(array[0], array[1], array[2], array[3]);
			vector = pointerPosition;
			localRotation = pointerRotation;
			break;
		case ControllerAxis.Wrist:
			Controller.UPvr_GetWristPose(array, array2);
			wristPosition = new Vector3(array2[0], array2[1], array2[2]);
			wristRotation = new Quaternion(array[0], array[1], array[2], array[3]);
			vector = wristPosition;
			localRotation = wristRotation;
			break;
		case ControllerAxis.Elbow:
			Controller.UPvr_GetElbowPose(array, array2);
			elbowPosition = new Vector3(array2[0], array2[1], array2[2]);
			elbowRotation = new Quaternion(array[0], array[1], array[2], array[3]);
			vector = elbowPosition;
			localRotation = elbowRotation;
			break;
		case ControllerAxis.Shoulder:
			Controller.UPvr_GetShoulderPose(array, array2);
			shoulderPosition = new Vector3(array2[0], array2[1], array2[2]);
			shoulderRotation = new Quaternion(array[0], array[1], array[2], array[3]);
			vector = shoulderPosition;
			localRotation = shoulderRotation;
			break;
		default:
			throw new Exception("Invalid FromJoint.");
		}
		if (hand == 0)
		{
			if (controller0 != null)
			{
				if (!Pvr_UnitySDKManager.SDK.HmdOnlyrot)
				{
					controller0.transform.localPosition = vector + Pvr_UnitySDKSensor.Instance.HeadPose.Position;
				}
				else if (Pvr_UnitySDKManager.SDK.TrackingOrigin == TrackingOrigin.FloorLevel)
				{
					controller0.transform.localPosition = vector + Pvr_UnitySDKSensor.Instance.HeadPose.Position;
				}
				else
				{
					controller0.transform.localPosition = vector;
				}
				controller0.transform.localRotation = localRotation;
			}
		}
		else if (controller1 != null)
		{
			if (!Pvr_UnitySDKManager.SDK.HmdOnlyrot)
			{
				controller1.transform.localPosition = vector + Pvr_UnitySDKSensor.Instance.HeadPose.Position;
			}
			else if (Pvr_UnitySDKManager.SDK.TrackingOrigin == TrackingOrigin.FloorLevel)
			{
				controller1.transform.localPosition = vector + Pvr_UnitySDKSensor.Instance.HeadPose.Position;
			}
			else
			{
				controller1.transform.localPosition = vector;
			}
			controller1.transform.localRotation = localRotation;
		}
	}
}
public class Pvr_ControllerDemo : MonoBehaviour
{
	public GameObject HeadSetController;

	public GameObject controller0;

	public GameObject controller1;

	public GameObject cube;

	private Ray ray;

	private GameObject currentController;

	private Transform lastHit;

	private Transform currentHit;

	[SerializeField]
	private Material normat;

	[SerializeField]
	private Material gazemat;

	[SerializeField]
	private Material clickmat;

	private bool noClick;

	private GameObject referenceObj;

	public float rayDefaultLength = 4f;

	private bool isHasController;

	private bool headcontrolmode;

	private RaycastHit hit;

	private GameObject rayLine;

	private GameObject dot;

	private Transform dragObj;

	private float disX;

	private float disY;

	private float disZ;

	private void Start()
	{
		ray = default(Ray);
		hit = default(RaycastHit);
		if (Pvr_UnitySDKManager.SDK.isHasController)
		{
			Pvr_ControllerManager.PvrServiceStartSuccessEvent += ServiceStartSuccess;
			Pvr_ControllerManager.SetControllerStateChangedEvent += ControllerStateListener;
			Pvr_ControllerManager.ControllerStatusChangeEvent += CheckControllerStateForGoblin;
			isHasController = true;
		}
		referenceObj = new GameObject("ReferenceObj");
	}

	private void OnDestroy()
	{
		if (isHasController)
		{
			Pvr_ControllerManager.PvrServiceStartSuccessEvent -= ServiceStartSuccess;
			Pvr_ControllerManager.SetControllerStateChangedEvent -= ControllerStateListener;
			Pvr_ControllerManager.ControllerStatusChangeEvent -= CheckControllerStateForGoblin;
		}
	}

	private void Update()
	{
		if (HeadSetController.activeSelf)
		{
			HeadSetController.transform.parent.localRotation = Quaternion.Euler(Pvr_UnitySDKSensor.Instance.HeadPose.Orientation.eulerAngles.x, Pvr_UnitySDKSensor.Instance.HeadPose.Orientation.eulerAngles.y, 0f);
			HeadSetController.transform.parent.localPosition = Pvr_UnitySDKSensor.Instance.HeadPose.Position;
			ray.direction = HeadSetController.transform.position - HeadSetController.transform.parent.parent.Find("Head").position;
			ray.origin = HeadSetController.transform.parent.parent.Find("Head").position;
			if (Physics.Raycast(ray, out hit))
			{
				if (HeadSetController.name == "SightPointer")
				{
					HeadSetController.transform.localScale = new Vector3(0.09f, 0.09f, 0.09f);
				}
				currentHit = hit.transform;
				if (currentHit != null && lastHit != null && currentHit != lastHit && (bool)lastHit.GetComponent<Pvr_UIGraphicRaycaster>() && lastHit.transform.gameObject.activeInHierarchy && lastHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled)
				{
					lastHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled = false;
				}
				if (currentHit != null && lastHit != null && currentHit == lastHit && (bool)currentHit.GetComponent<Pvr_UIGraphicRaycaster>() && !currentHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled)
				{
					currentHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled = true;
				}
				if (1 << hit.transform.gameObject.layer == LayerMask.GetMask("Water") && !noClick)
				{
					hit.transform.GetComponent<Renderer>().material = gazemat;
				}
				lastHit = hit.transform;
				if (Pvr_ControllerManager.Instance.LengthAdaptiveRay)
				{
					HeadSetController.transform.position = hit.point;
					HeadSetController.transform.position -= (hit.point - HeadSetController.transform.parent.parent.Find("Head").position).normalized * 0.02f;
					float num = 0.008f * hit.distance / 4f;
					Mathf.Clamp(num, 0.002f, 0.008f);
					HeadSetController.transform.localScale = new Vector3(num, num, 1f);
				}
			}
			else
			{
				if (HeadSetController.name == "SightPointer")
				{
					HeadSetController.transform.localScale = Vector3.zero;
				}
				if (lastHit != null && 1 << lastHit.transform.gameObject.layer == LayerMask.GetMask("Water"))
				{
					lastHit.transform.GetComponent<Renderer>().material = normat;
				}
				currentHit = null;
				noClick = false;
				if (Pvr_ControllerManager.Instance.LengthAdaptiveRay)
				{
					HeadSetController.transform.position = HeadSetController.transform.parent.parent.Find("Head").position + ray.direction.normalized * (0.5f + rayDefaultLength);
					HeadSetController.transform.localScale = new Vector3(0.008f, 0.008f, 1f);
				}
			}
			if ((Input.GetKeyDown(KeyCode.JoystickButton0) || Input.GetMouseButtonDown(0)) && lastHit != null && 1 << lastHit.transform.gameObject.layer == LayerMask.GetMask("Water") && currentHit != null)
			{
				lastHit.transform.GetComponent<Renderer>().material = clickmat;
				noClick = true;
			}
			return;
		}
		if (currentController != null)
		{
			ray.direction = currentController.transform.forward - currentController.transform.up * 0.25f;
			ray.origin = currentController.transform.Find("start").position;
			if (Physics.Raycast(ray, out hit))
			{
				currentHit = hit.transform;
				if (currentHit != null && lastHit != null && currentHit != lastHit && (bool)lastHit.GetComponent<Pvr_UIGraphicRaycaster>() && lastHit.transform.gameObject.activeInHierarchy && lastHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled)
				{
					lastHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled = false;
				}
				if (currentHit != null && lastHit != null && currentHit == lastHit && (bool)currentHit.GetComponent<Pvr_UIGraphicRaycaster>() && !currentHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled)
				{
					currentHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled = true;
				}
				if (1 << hit.transform.gameObject.layer == LayerMask.GetMask("Water"))
				{
					if (!noClick)
					{
						hit.transform.GetComponent<Renderer>().material = gazemat;
					}
					if (Controller.UPvr_GetKeyDown(0, Pvr_KeyCode.TOUCHPAD) || Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.TOUCHPAD) || Input.GetMouseButtonDown(0))
					{
						referenceObj.transform.position = hit.point;
						disX = hit.transform.position.x - referenceObj.transform.position.x;
						disY = hit.transform.position.y - referenceObj.transform.position.y;
						dragObj = hit.transform;
					}
					if ((Controller.UPvr_GetKey(0, Pvr_KeyCode.TOUCHPAD) || Controller.UPvr_GetKey(1, Pvr_KeyCode.TOUCHPAD) || Input.GetMouseButton(0)) && hit.transform == dragObj.transform)
					{
						referenceObj.transform.position = new Vector3(hit.point.x, hit.point.y, hit.transform.position.z);
						dragObj.position = new Vector3(referenceObj.transform.position.x + disX, referenceObj.transform.position.y + disY, hit.transform.position.z);
					}
				}
				lastHit = hit.transform;
				currentController.transform.Find("dot").position = hit.point;
				if (Pvr_ControllerManager.Instance.LengthAdaptiveRay)
				{
					float num2 = 0.178f * currentController.transform.Find("dot").localPosition.z / 3.3f;
					Mathf.Clamp(num2, 0.05f, 0.178f);
					currentController.transform.Find("dot").localScale = new Vector3(num2, num2, 1f);
				}
			}
			else
			{
				if (lastHit != null && 1 << lastHit.transform.gameObject.layer == LayerMask.GetMask("Water"))
				{
					lastHit.transform.GetComponent<Renderer>().material = normat;
				}
				currentHit = null;
				noClick = false;
				if (Pvr_ControllerManager.Instance.LengthAdaptiveRay)
				{
					currentController.transform.Find("dot").localScale = new Vector3(0.178f, 0.178f, 1f);
				}
			}
		}
		if ((Controller.UPvr_GetKeyDown(0, Pvr_KeyCode.TOUCHPAD) || Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.TOUCHPAD) || Input.GetMouseButtonDown(0)) && lastHit != null && 1 << lastHit.transform.gameObject.layer == LayerMask.GetMask("Water") && currentHit != null)
		{
			lastHit.transform.GetComponent<Renderer>().material = clickmat;
			noClick = true;
		}
	}

	private void ServiceStartSuccess()
	{
		if (Controller.UPvr_GetControllerState(0) == ControllerState.Connected || Controller.UPvr_GetControllerState(1) == ControllerState.Connected)
		{
			HeadSetController.SetActive(value: false);
		}
		else
		{
			HeadSetController.SetActive(value: true);
		}
		if (Controller.UPvr_GetMainHandNess() == 0)
		{
			currentController = controller0;
		}
		if (Controller.UPvr_GetMainHandNess() == 1)
		{
			currentController = controller1;
		}
	}

	private void ControllerStateListener(string data)
	{
		if (Controller.UPvr_GetControllerState(0) == ControllerState.Connected || Controller.UPvr_GetControllerState(1) == ControllerState.Connected)
		{
			HeadSetController.SetActive(value: false);
		}
		else
		{
			HeadSetController.SetActive(value: true);
		}
		if (Controller.UPvr_GetMainHandNess() == 0)
		{
			currentController = controller0;
		}
		if (Controller.UPvr_GetMainHandNess() == 1)
		{
			currentController = controller1;
		}
	}

	private void CheckControllerStateForGoblin(string state)
	{
		HeadSetController.SetActive(Convert.ToInt16(state) != 1);
	}

	public void SwitchControlMode()
	{
	}
}
public class Pvr_ControllerEventsExamples : MonoBehaviour
{
	private void Start()
	{
		if (!(GetComponent<Pvr_UIPointer>() == null))
		{
			GetComponent<Pvr_UIPointer>().UIPointerElementEnter += UIPointerElementEnter;
			GetComponent<Pvr_UIPointer>().UIPointerElementExit += UIPointerElementExit;
			GetComponent<Pvr_UIPointer>().UIPointerElementClick += UIPointerElementClick;
			GetComponent<Pvr_UIPointer>().UIPointerElementDragStart += UIPointerElementDragStart;
			GetComponent<Pvr_UIPointer>().UIPointerElementDragEnd += UIPointerElementDragEnd;
		}
	}

	private void UIPointerElementEnter(object sender, UIPointerEventArgs e)
	{
		PLOG.I("UI Pointer entered" + e.currentTarget.name);
	}

	private void UIPointerElementExit(object sender, UIPointerEventArgs e)
	{
		PLOG.I("UI Pointer exited" + e.currentTarget.name);
	}

	private void UIPointerElementClick(object sender, UIPointerEventArgs e)
	{
		PLOG.I("UI Pointer clicked" + e.currentTarget.name);
	}

	private void UIPointerElementDragStart(object sender, UIPointerEventArgs e)
	{
		PLOG.I("UI Pointer started dragging" + e.currentTarget.name);
	}

	private void UIPointerElementDragEnd(object sender, UIPointerEventArgs e)
	{
		PLOG.I("UI Pointer stopped dragging" + e.currentTarget.name);
	}
}
public class Pvr_ControllerInit : MonoBehaviour
{
	private ControllerVariety Variety;

	private bool isCustomModel;

	[SerializeField]
	private GameObject goblin;

	[SerializeField]
	private GameObject g2;

	[SerializeField]
	private GameObject neo2L;

	[SerializeField]
	private GameObject neo2R;

	[SerializeField]
	private GameObject neo3L;

	[SerializeField]
	private GameObject neo3R;

	[SerializeField]
	private Material standardMat;

	[SerializeField]
	private Material unlitMat;

	private int controllerType = -1;

	[HideInInspector]
	public bool loadModelSuccess;

	private int systemOrUnity;

	private LitJson.JsonData curControllerData;

	private string modelName = "";

	private string texFormat = "";

	private string prePath = "";

	private string modelFilePath = "/system/media/PvrRes/controller/";

	private const string goblinTexbasePath = "Controller/controller1/controller1";

	private const string g2TexbasePath = "Controller/controller3/controller3";

	private const string neo2TexbasePath = "Controller/controller4/controller4";

	private const string neo3TexbasePath = "Controller/controller5/controller5";

	private void Awake()
	{
		Render.UPvr_GetIntConfig(15, ref systemOrUnity);
		Variety = base.transform.GetComponentInParent<Pvr_ControllerModuleInit>().Variety;
		isCustomModel = base.transform.GetComponentInParent<Pvr_ControllerModuleInit>().IsCustomModel;
		if (!isCustomModel)
		{
			Pvr_ControllerManager.PvrServiceStartSuccessEvent += ServiceStartSuccess;
			Pvr_ControllerManager.SetControllerAbilityEvent += CheckControllerStateOfAbility;
			Pvr_ControllerManager.ControllerStatusChangeEvent += CheckControllerStateForGoblin;
		}
	}

	private void OnDestroy()
	{
		Pvr_ControllerManager.PvrServiceStartSuccessEvent -= ServiceStartSuccess;
		Pvr_ControllerManager.SetControllerAbilityEvent -= CheckControllerStateOfAbility;
		Pvr_ControllerManager.ControllerStatusChangeEvent -= CheckControllerStateForGoblin;
	}

	private void OnApplicationPause(bool pause)
	{
		if (pause)
		{
			DestroyLocalController();
		}
	}

	private void ServiceStartSuccess()
	{
		int num = Controller.UPvr_GetDeviceType();
		if (controllerType != num && num != 0)
		{
			controllerType = num;
		}
		LoadResFromJson();
		if (Pvr_ControllerManager.controllerlink.neoserviceStarted)
		{
			if (Variety == ControllerVariety.Controller0)
			{
				if (Pvr_ControllerManager.controllerlink.controller0Connected)
				{
					StartCoroutine(RefreshController(0));
				}
				else
				{
					DestroyLocalController();
				}
			}
			if (Variety == ControllerVariety.Controller1)
			{
				if (Pvr_ControllerManager.controllerlink.controller1Connected)
				{
					StartCoroutine(RefreshController(1));
				}
				else
				{
					DestroyLocalController();
				}
			}
		}
		if (Pvr_ControllerManager.controllerlink.goblinserviceStarted && Variety == ControllerVariety.Controller0)
		{
			if (Pvr_ControllerManager.controllerlink.controller0Connected)
			{
				StartCoroutine(RefreshController(0));
			}
			else
			{
				DestroyLocalController();
			}
		}
	}

	private void LoadResFromJson()
	{
		string text = Pvr_UnitySDKAPI.System.UPvr_GetObjectOrArray("config.controller", 7);
		if (text != null)
		{
			LitJson.JsonData jsonData = LitJson.JsonMapper.ToObject(text);
			if (controllerType >= 0 && jsonData.Count >= controllerType)
			{
				curControllerData = jsonData[controllerType - 1];
				modelFilePath = (string)curControllerData["base_path"];
				modelName = (string)curControllerData["model_name"] + "_sys";
			}
		}
		else
		{
			PLOG.E("PvrLog LoadJsonFromSystem Error");
		}
	}

	private void CheckControllerStateForGoblin(string state)
	{
		int num = Controller.UPvr_GetDeviceType();
		if (Variety != 0)
		{
			return;
		}
		if (Convert.ToInt16(state) == 1)
		{
			if (controllerType != num)
			{
				DestroySysController();
				controllerType = num;
			}
			StartCoroutine(RefreshController(0));
		}
		else
		{
			DestroyLocalController();
		}
	}

	private void CheckControllerStateOfAbility(string data)
	{
		bool num = Convert.ToBoolean(Convert.ToInt16(data.Substring(4, 1)));
		short num2 = Convert.ToInt16(data.Substring(0, 1));
		int num3 = Controller.UPvr_GetDeviceType();
		if (num)
		{
			controllerType = num3;
			switch (num2)
			{
			case 0:
				if (Variety == ControllerVariety.Controller0)
				{
					StartCoroutine(RefreshController(0));
				}
				break;
			case 1:
				if (Variety == ControllerVariety.Controller1)
				{
					StartCoroutine(RefreshController(1));
				}
				break;
			}
			return;
		}
		switch (num2)
		{
		case 0:
			if (Variety == ControllerVariety.Controller0)
			{
				DestroyLocalController();
			}
			break;
		case 1:
			if (Variety == ControllerVariety.Controller1)
			{
				DestroyLocalController();
			}
			break;
		}
	}

	private void DestroyLocalController()
	{
		foreach (Transform item in base.transform)
		{
			UnityEngine.Object.Destroy(item.gameObject);
			loadModelSuccess = false;
		}
	}

	private void DestroySysController()
	{
		foreach (Transform item in base.transform)
		{
			if (item.name == modelName)
			{
				UnityEngine.Object.Destroy(item.gameObject);
				loadModelSuccess = false;
			}
		}
	}

	private IEnumerator RefreshController(int id)
	{
		yield return null;
		yield return null;
		if (Controller.UPvr_GetControllerState(id) != ControllerState.Connected)
		{
			yield break;
		}
		if (systemOrUnity == 0)
		{
			LoadControllerFromPrefab();
			if (!loadModelSuccess)
			{
				LoadControllerFromSystem(id);
			}
		}
		else
		{
			bool flag = false;
			foreach (Transform item in base.transform)
			{
				if (item.name == modelName)
				{
					flag = true;
				}
			}
			if (!flag)
			{
				LoadControllerFromSystem(id);
				if (!loadModelSuccess)
				{
					LoadControllerFromPrefab();
				}
			}
			else
			{
				base.transform.Find(modelName).gameObject.SetActive(value: true);
			}
		}
		Pvr_ToolTips.RefreshTips();
		PLOG.I("PvrLog Controller Refresh Success");
	}

	private void LoadControllerFromPrefab()
	{
		switch (controllerType)
		{
		case 1:
		{
			Pvr_ControllerVisual pvr_ControllerVisual3 = UnityEngine.Object.Instantiate(goblin, base.transform, worldPositionStays: false).AddComponent<Pvr_ControllerVisual>();
			pvr_ControllerVisual3.currentDevice = ControllerDevice.Goblin;
			LoadTexture(pvr_ControllerVisual3, "Controller/controller1/controller1", fromRes: true);
			loadModelSuccess = true;
			break;
		}
		case 3:
		{
			Pvr_ControllerVisual pvr_ControllerVisual2 = UnityEngine.Object.Instantiate(g2, base.transform, worldPositionStays: false).AddComponent<Pvr_ControllerVisual>();
			pvr_ControllerVisual2.currentDevice = ControllerDevice.G2;
			LoadTexture(pvr_ControllerVisual2, "Controller/controller3/controller3", fromRes: true);
			loadModelSuccess = true;
			break;
		}
		case 4:
		{
			Pvr_ControllerVisual pvr_ControllerVisual4 = UnityEngine.Object.Instantiate((Variety == ControllerVariety.Controller0) ? neo2L : neo2R, base.transform, worldPositionStays: false).AddComponent<Pvr_ControllerVisual>();
			pvr_ControllerVisual4.currentDevice = ControllerDevice.Neo2;
			LoadTexture(pvr_ControllerVisual4, "Controller/controller4/controller4", fromRes: true);
			loadModelSuccess = true;
			break;
		}
		case 5:
		{
			Pvr_ControllerVisual pvr_ControllerVisual = UnityEngine.Object.Instantiate((Variety == ControllerVariety.Controller0) ? neo3L : neo3R, base.transform, worldPositionStays: false).AddComponent<Pvr_ControllerVisual>();
			pvr_ControllerVisual.currentDevice = ControllerDevice.Neo3;
			LoadTexture(pvr_ControllerVisual, "Controller/controller5/controller5", fromRes: true);
			loadModelSuccess = true;
			break;
		}
		default:
			loadModelSuccess = false;
			break;
		}
	}

	private void LoadControllerFromSystem(int id)
	{
		string text = controllerType.ToString() + id + ".obj";
		string text2 = modelFilePath + text;
		if (!File.Exists(text2))
		{
			PLOG.I("PvrLog Obj File does not exist==" + text2);
			return;
		}
		GameObject gameObject = new GameObject();
		gameObject.name = modelName;
		gameObject.AddComponent<MeshFilter>().mesh = Pvr_ObjImporter.Instance.ImportFile(text2);
		gameObject.transform.SetParent(base.transform);
		gameObject.transform.localPosition = Vector3.zero;
		gameObject.AddComponent<MeshRenderer>().material = (((int)curControllerData["material_type"] == 0) ? standardMat : unlitMat);
		loadModelSuccess = true;
		Pvr_ControllerVisual pvr_ControllerVisual = gameObject.AddComponent<Pvr_ControllerVisual>();
		switch (controllerType)
		{
		case 1:
			pvr_ControllerVisual.currentDevice = ControllerDevice.Goblin;
			break;
		case 3:
			pvr_ControllerVisual.currentDevice = ControllerDevice.G2;
			break;
		case 4:
			pvr_ControllerVisual.currentDevice = ControllerDevice.Neo2;
			break;
		case 5:
			pvr_ControllerVisual.currentDevice = ControllerDevice.Neo3;
			break;
		default:
			pvr_ControllerVisual.currentDevice = ControllerDevice.NewController;
			break;
		}
		pvr_ControllerVisual.variety = Variety;
		LoadTexture(pvr_ControllerVisual, controllerType.ToString() + id, fromRes: false);
		gameObject.transform.localRotation = Quaternion.Euler(new Vector3(0f, 180f, 0f));
		gameObject.transform.localScale = new Vector3(-0.01f, 0.01f, 0.01f);
	}

	private void LoadTexture(Pvr_ControllerVisual visual, string controllerName, bool fromRes)
	{
		if (fromRes)
		{
			texFormat = "";
			prePath = controllerName;
		}
		else
		{
			texFormat = "." + (string)curControllerData["tex_format"];
			prePath = modelFilePath + controllerName;
		}
		string filepath = prePath + "_idle" + texFormat;
		visual.m_idle = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_app" + texFormat;
		visual.m_app = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_home" + texFormat;
		visual.m_home = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_touch" + texFormat;
		visual.m_touchpad = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_volume_down" + texFormat;
		visual.m_volDn = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_volume_up" + texFormat;
		visual.m_volUp = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_trigger" + texFormat;
		visual.m_trigger = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_a" + texFormat;
		visual.m_a = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_b" + texFormat;
		visual.m_b = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_x" + texFormat;
		visual.m_x = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_y" + texFormat;
		visual.m_y = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_grip" + texFormat;
		visual.m_grip = LoadOneTexture(filepath, fromRes);
	}

	private Texture2D LoadOneTexture(string filepath, bool fromRes)
	{
		if (fromRes)
		{
			return Resources.Load<Texture2D>(filepath);
		}
		int width = (int)curControllerData["tex_width"];
		int height = (int)curControllerData["tex_height"];
		Texture2D texture2D = new Texture2D(width, height);
		texture2D.LoadImage(ReadPNG(filepath));
		return texture2D;
	}

	private byte[] ReadPNG(string path)
	{
		FileStream fileStream = new FileStream(path, FileMode.Open, FileAccess.Read);
		fileStream.Seek(0L, SeekOrigin.Begin);
		byte[] array = new byte[fileStream.Length];
		fileStream.Read(array, 0, (int)fileStream.Length);
		fileStream.Close();
		fileStream.Dispose();
		fileStream = null;
		return array;
	}
}
public class Pvr_ControllerLink
{
	public AndroidJavaClass javaHummingbirdClass;

	public AndroidJavaClass javaPico2ReceiverClass;

	public AndroidJavaClass javaserviceClass;

	public AndroidJavaClass javavractivityclass;

	public AndroidJavaClass javaCVClass;

	public AndroidJavaObject activity;

	public string gameobjname = "";

	public bool picoDevice;

	public string hummingBirdMac;

	public int hummingBirdRSSI;

	public bool goblinserviceStarted;

	public bool neoserviceStarted;

	public bool controller0Connected;

	public bool controller1Connected;

	public int mainHandID;

	public Pvr_Controller.UserHandNess handness;

	public int controllerType;

	public ControllerHand Controller0;

	public ControllerHand Controller1;

	public int platFormType = -1;

	public int trackingmode = -1;

	public int systemProp = -1;

	public int enablehand6dofbyhead = -1;

	public bool switchHomeKey = true;

	private const float SWITCH_METER = 1000f;

	private int iPhoneHMDModeEnabled;

	private float[] hbPoseData = new float[4];

	private float[] sensorData = new float[28];

	private int[] keyData = new int[134];

	private int[] neo3TouchValue = new int[15];

	private float[] fixedState = new float[7] { 0f, 0f, 0f, 1f, 0f, 0f, 0f };

	private float[] neoposeData = new float[7] { 0f, 0f, 0f, 1f, 0f, 0f, 0f };

	private int[] goblinKeyArray = new int[47];

	private int[] neoKeyArray = new int[67];

	private int[] neotriggerV = new int[9];

	private float[] velocity = new float[3];

	private float[] angularVelocity = new float[3];

	private float[] angularAcce = new float[3];

	private float[] acceData = new float[3];

	private float[] predictData = new float[7];

	public Pvr_ControllerLink(string name)
	{
		gameobjname = name;
		hummingBirdMac = "";
		hummingBirdRSSI = 0;
		UnityEngine.Debug.Log("PvrLog Controller GameObject:" + gameobjname);
		StartHummingBirdService();
		Controller0 = new ControllerHand();
		Controller0.Position = new Vector3(0f, Pvr_UnitySDKSensor.Instance.HeadPose.Position.y, 0f) + new Vector3(-0.1f, -0.3f, 0.3f);
		Controller1 = new ControllerHand();
		Controller1.Position = new Vector3(0f, Pvr_UnitySDKSensor.Instance.HeadPose.Position.y, 0f) + new Vector3(0.1f, -0.3f, 0.3f);
	}

	private void StartHummingBirdService()
	{
		try
		{
			AndroidJavaClass androidJavaClass = new AndroidJavaClass("com.unity3d.player.UnityPlayer");
			activity = androidJavaClass.GetStatic<AndroidJavaObject>("currentActivity");
			javaHummingbirdClass = new AndroidJavaClass("com.picovr.picovrlib.hummingbirdclient.HbClientActivity");
			javaCVClass = new AndroidJavaClass("com.picovr.picovrlib.cvcontrollerclient.ControllerClient");
			javavractivityclass = new AndroidJavaClass("com.psmart.vrlib.VrActivity");
			javaserviceClass = new AndroidJavaClass("com.picovr.picovrlib.hummingbirdclient.UnityClient");
			Pvr_UnitySDKAPI.System.Pvr_SetInitActivity(activity.GetRawObject(), javaHummingbirdClass.GetRawClass());
			Render.UPvr_GetIntConfig(4, ref platFormType);
			UnityEngine.Debug.Log("PvrLog platform" + platFormType);
			Render.UPvr_GetIntConfig(5, ref trackingmode);
			UnityEngine.Debug.Log("PvrLog trackingmode" + trackingmode);
			systemProp = GetSysproc();
			UnityEngine.Debug.Log("PvrLog systemProp" + systemProp);
			Render.UPvr_GetIntConfig(7, ref enablehand6dofbyhead);
			UnityEngine.Debug.Log("PvrLog enablehand6dofbyhead" + enablehand6dofbyhead);
			if (trackingmode == 0 || trackingmode == 1 || ((trackingmode == 3 || trackingmode == 5 || trackingmode == 6) && (systemProp == 1 || systemProp == 3)))
			{
				picoDevice = platFormType != 0;
				javaPico2ReceiverClass = new AndroidJavaClass("com.picovr.picovrlib.hummingbirdclient.HbClientReceiver");
				Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaPico2ReceiverClass, "startReceiver", activity, gameobjname);
				Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "setPlatformType", platFormType);
			}
			else
			{
				picoDevice = true;
				SetGameObjectToJar(gameobjname);
			}
			Render.UPvr_GetIntConfig(16, ref iPhoneHMDModeEnabled);
			if (iPhoneHMDModeEnabled == 1)
			{
				BindService();
			}
			else if (IsServiceExisted())
			{
				BindService();
			}
		}
		catch (AndroidJavaException ex)
		{
			PLOG.E("ConnectToAndriod--catch" + ex.Message);
		}
	}

	public bool IsServiceExisted()
	{
		bool result = false;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaserviceClass, "isServiceExisted", activity, trackingmode);
		UnityEngine.Debug.Log("PvrLog ServiceExisted ?" + result);
		return result;
	}

	public void SetGameObjectToJar(string name)
	{
		UnityEngine.Debug.Log("PvrLog SetGameObjectToJar " + name);
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "setGameObjectCallback", name);
	}

	public void BindService()
	{
		UnityEngine.Debug.Log("PvrLog Bind Service");
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaserviceClass, "bindService", activity, trackingmode);
	}

	public void UnBindService()
	{
		UnityEngine.Debug.Log("PvrLog UnBind Service");
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaserviceClass, "unbindService", activity, trackingmode);
	}

	public void StopReceiver()
	{
		UnityEngine.Debug.Log("PvrLog StopReceiver");
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaPico2ReceiverClass, "stopReceiver", activity);
	}

	public void StartReceiver()
	{
		UnityEngine.Debug.Log("PvrLog StartReceiver");
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaPico2ReceiverClass, "startReceiver", activity, gameobjname);
	}

	public int getHandness()
	{
		int result = -1;
		if (iPhoneHMDModeEnabled == 0)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javavractivityclass, "getPvrHandness", activity);
		}
		else
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getHbHandednessInSP");
		}
		PLOG.I("PvrLog GetHandness =" + result);
		return result;
	}

	public void setHandness(int hand)
	{
		PLOG.I("PvrLog SetHandness =" + hand);
		if (iPhoneHMDModeEnabled == 1)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "setHbHandednessInSP", hand);
		}
	}

	public void StartScan()
	{
		PLOG.I("PvrLog ScanHBController");
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "scanHbDevice", true);
	}

	public void StopScan()
	{
		PLOG.I("PvrLog StopScanHBController");
		if (iPhoneHMDModeEnabled == 0)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "scanHbDevice", false);
		}
	}

	public int GetSysproc()
	{
		int result = -1;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaserviceClass, "getSysproc");
		PLOG.I("PvrLog GetSysproc" + result);
		return result;
	}

	public void ResetController(int num)
	{
		UnityEngine.Debug.Log("PvrLog ResetController" + num);
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "resetControllerSensorState", num);
		}
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "resetHbSensorState");
		}
	}

	public void ConnectBLE()
	{
		UnityEngine.Debug.Log("PvrLog ConnectHBController" + hummingBirdMac);
		if (hummingBirdMac != "")
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "connectHbController", hummingBirdMac);
		}
	}

	public void DisConnectBLE()
	{
		UnityEngine.Debug.Log("PvrLog DisConnectHBController");
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "disconnectHbController");
	}

	public bool StartUpgrade()
	{
		UnityEngine.Debug.Log("PvrLog StartUpgradeHBController");
		bool result = false;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "startUpgrade");
		return result;
	}

	public void setBinPath(string path, bool isasset)
	{
		UnityEngine.Debug.Log("PvrLog setBinPath" + path + isasset);
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "setBinPath", path, isasset);
	}

	public string GetBLEImageType()
	{
		string result = "";
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getBLEImageType");
		}
		UnityEngine.Debug.Log("PvrLog GetBLEImageType" + result);
		return result;
	}

	public long GetBLEVersion()
	{
		long result = 0L;
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getBLEVersion");
		}
		UnityEngine.Debug.Log("PvrLog GetBLEVersion" + result);
		return result;
	}

	public string GetFileImageType()
	{
		string result = "";
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getFileImageType");
		}
		UnityEngine.Debug.Log("PvrLog GetFileImageType" + result);
		return result;
	}

	public long GetFileVersion()
	{
		long result = 0L;
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getFileVersion");
		}
		UnityEngine.Debug.Log("PvrLog GetFileVersion" + result);
		return result;
	}

	public int GetControllerConnectionState(int num)
	{
		int result = -1;
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getControllerConnectionState", num);
		}
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getHbConnectionState");
		}
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog GetControllerState:" + num + "state:" + result);
		}
		return result;
	}

	public void RebackToLauncher()
	{
		UnityEngine.Debug.Log("PvrLog RebackToLauncher");
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "startLauncher");
		}
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "startLauncher");
		}
	}

	public void TurnUpVolume()
	{
		UnityEngine.Debug.Log("PvrLog TurnUpVolume");
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "turnUpVolume", activity);
		}
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "turnUpVolume", activity);
		}
	}

	public void TurnDownVolume()
	{
		UnityEngine.Debug.Log("PvrLog TurnDownVolume");
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "turnDownVolume", activity);
		}
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "turnDownVolume", activity);
		}
	}

	public float[] GetHBControllerPoseData()
	{
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref hbPoseData, javaHummingbirdClass, "getHBSensorPose");
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog HBControllerData" + hbPoseData[0] + "," + hbPoseData[1] + "," + hbPoseData[2] + "," + hbPoseData[3]);
		}
		return hbPoseData;
	}

	public float[] GetControllerSensorData()
	{
		if (enablehand6dofbyhead == 1)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref sensorData, javaCVClass, "getControllerDataInfoBySharmem", Pvr_UnitySDKManager.SDK.headData);
		}
		else
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref sensorData, javaCVClass, "getControllerDataInfoBySharmem");
		}
		return sensorData;
	}

	public int[] GetControllerKeyData()
	{
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref keyData, javaCVClass, "getDoubleControllerKeyEventUnityExtBySharmem");
		return keyData;
	}

	public int[] GetNeo3TouchData(int hand)
	{
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref neo3TouchValue, javaCVClass, "getControllerTouchEvent", hand);
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog Neo3Touch hand:" + hand + "-" + neo3TouchValue[0] + neo3TouchValue[1] + neo3TouchValue[2] + neo3TouchValue[3] + neo3TouchValue[4] + "," + neo3TouchValue[5] + neo3TouchValue[6] + neo3TouchValue[7] + neo3TouchValue[8] + neo3TouchValue[9] + "," + neo3TouchValue[10] + neo3TouchValue[11] + neo3TouchValue[12] + neo3TouchValue[13] + neo3TouchValue[14]);
		}
		return neo3TouchValue;
	}

	public int GetNeo3GripValue(int hand)
	{
		int result = 0;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getControllerGripValue", hand);
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog Neo3GripValue:" + result);
		}
		return result;
	}

	public float[] GetControllerFixedSensorState(int hand)
	{
		if (trackingmode == 2 || trackingmode == 3)
		{
			return fixedState;
		}
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref fixedState, javaCVClass, "getControllerFixedSensorState", hand);
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog GetControllerFixedSensorState " + hand + "Rotation:" + fixedState[0] + "," + fixedState[1] + "," + fixedState[2] + "," + fixedState[3] + "Position:" + fixedState[4] + "," + fixedState[5] + "," + fixedState[6]);
		}
		return fixedState;
	}

	public float[] GetCvControllerPoseData(int hand)
	{
		if (enablehand6dofbyhead == 1)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref neoposeData, javaCVClass, "getControllerSensorState", hand, Pvr_UnitySDKManager.SDK.headData);
		}
		else
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref neoposeData, javaCVClass, "getControllerSensorState", hand);
		}
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog CVControllerData :" + neoposeData[0] + "," + neoposeData[1] + "," + neoposeData[2] + "," + neoposeData[3] + "," + neoposeData[4] + "," + neoposeData[5] + "," + neoposeData[6]);
		}
		return neoposeData;
	}

	public int[] GetHBControllerKeyData()
	{
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref goblinKeyArray, javaHummingbirdClass, "getHBKeyEventUnityExt");
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog HBControllerKey" + goblinKeyArray[0] + goblinKeyArray[1] + goblinKeyArray[2] + goblinKeyArray[3] + goblinKeyArray[4] + "," + goblinKeyArray[5] + goblinKeyArray[6] + goblinKeyArray[7] + goblinKeyArray[8] + goblinKeyArray[9] + "," + goblinKeyArray[10] + goblinKeyArray[11] + goblinKeyArray[12] + goblinKeyArray[13] + goblinKeyArray[14] + "," + goblinKeyArray[15] + goblinKeyArray[16] + goblinKeyArray[17] + goblinKeyArray[18] + goblinKeyArray[19] + "," + goblinKeyArray[20] + goblinKeyArray[21] + goblinKeyArray[22] + goblinKeyArray[23] + goblinKeyArray[24] + "," + goblinKeyArray[25] + goblinKeyArray[26] + goblinKeyArray[27] + goblinKeyArray[28] + goblinKeyArray[29] + "," + goblinKeyArray[30] + goblinKeyArray[31] + goblinKeyArray[32] + goblinKeyArray[33] + goblinKeyArray[34] + "," + goblinKeyArray[35] + goblinKeyArray[36] + goblinKeyArray[37] + goblinKeyArray[38] + goblinKeyArray[39] + "," + goblinKeyArray[40] + goblinKeyArray[41] + goblinKeyArray[42] + goblinKeyArray[43] + goblinKeyArray[44] + "," + goblinKeyArray[45] + goblinKeyArray[46]);
		}
		return goblinKeyArray;
	}

	public int GetHBKeyValue()
	{
		int result = -1;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getTriggerKeyEvent");
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog GoblinControllerTriggerKey:" + result);
		}
		return result;
	}

	public int[] GetCvControllerKeyData(int hand)
	{
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref neoKeyArray, javaCVClass, "getControllerKeyEventUnityExt", hand);
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog CVControllerKey hand:" + hand + "-" + neoKeyArray[0] + neoKeyArray[1] + neoKeyArray[2] + neoKeyArray[3] + neoKeyArray[4] + "," + neoKeyArray[5] + neoKeyArray[6] + neoKeyArray[7] + neoKeyArray[8] + neoKeyArray[9] + "," + neoKeyArray[10] + neoKeyArray[11] + neoKeyArray[12] + neoKeyArray[13] + neoKeyArray[14] + "," + neoKeyArray[15] + neoKeyArray[16] + neoKeyArray[17] + neoKeyArray[18] + neoKeyArray[19] + "," + neoKeyArray[20] + neoKeyArray[21] + neoKeyArray[22] + neoKeyArray[23] + neoKeyArray[24] + "," + neoKeyArray[25] + neoKeyArray[26] + neoKeyArray[27] + neoKeyArray[28] + neoKeyArray[29] + "," + neoKeyArray[30] + neoKeyArray[31] + neoKeyArray[32] + neoKeyArray[33] + neoKeyArray[34] + "," + neoKeyArray[35] + neoKeyArray[36] + neoKeyArray[37] + neoKeyArray[38] + neoKeyArray[39] + "," + neoKeyArray[40] + neoKeyArray[41] + neoKeyArray[42] + neoKeyArray[43] + neoKeyArray[44] + "," + neoKeyArray[45] + neoKeyArray[46] + neoKeyArray[47] + neoKeyArray[48] + neoKeyArray[49] + "," + neoKeyArray[50] + neoKeyArray[51] + neoKeyArray[52] + neoKeyArray[53] + neoKeyArray[54] + "," + neoKeyArray[55] + neoKeyArray[56] + neoKeyArray[57] + neoKeyArray[58] + neoKeyArray[59] + "," + neoKeyArray[60] + neoKeyArray[61] + neoKeyArray[62] + neoKeyArray[63] + neoKeyArray[64] + "," + neoKeyArray[65] + neoKeyArray[66]);
		}
		return neoKeyArray;
	}

	public int GetCVTriggerValue(int hand)
	{
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref neotriggerV, javaCVClass, "getControllerKeyEvent", hand);
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog CVTriggerValue " + neotriggerV[7]);
		}
		return neotriggerV[7];
	}

	public void AutoConnectHbController(int scanTimeMs)
	{
		PLOG.I("PvrLog AutoConnectHbController" + scanTimeMs);
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "autoConnectHbController", scanTimeMs, gameobjname);
	}

	public void StartControllerThread(int headSensorState, int handSensorState)
	{
		if (BoundarySystem.UPvr_IsBoundaryEnable())
		{
			headSensorState = 1;
			handSensorState = 1;
		}
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "startControllerThread", headSensorState, handSensorState);
		UnityEngine.Debug.Log("PvrLog StartControllerThread" + headSensorState + handSensorState);
	}

	public void StopControllerThread(int headSensorState, int handSensorState)
	{
		if (BoundarySystem.UPvr_IsBoundaryEnable())
		{
			headSensorState = 1;
			handSensorState = 1;
		}
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "stopControllerThread", headSensorState, handSensorState);
		UnityEngine.Debug.Log("PvrLog StopControllerThread" + headSensorState + handSensorState);
	}

	public void SetUnityVersionToJar(string version)
	{
		if (trackingmode == 4 || trackingmode == 5 || trackingmode == 6)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "setUnityVersion", version);
		}
		UnityEngine.Debug.Log("PvrLog SetUnityVersionToJar" + version);
	}

	public Vector3 GetVelocity(int num)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref velocity, javaCVClass, "getControllerLinearVelocity", num);
		}
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog Velocity" + velocity[0] / 1000f + "," + velocity[1] / 1000f + "," + velocity[2] / 1000f);
		}
		return new Vector3(velocity[0] / 1000f, velocity[1] / 1000f, (0f - velocity[2]) / 1000f);
	}

	public Vector3 GetAngularVelocity(int num)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref angularVelocity, javaCVClass, "getControllerAngularVelocity", num);
		}
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref angularVelocity, javaHummingbirdClass, "getHbAngularVelocity");
		}
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog Gyro:" + angularVelocity[0] + "," + angularVelocity[1] + "," + angularVelocity[2]);
		}
		if (!float.IsNaN(angularVelocity[0]) && !float.IsNaN(angularVelocity[1]) && !float.IsNaN(angularVelocity[2]))
		{
			if (neoserviceStarted)
			{
				return new Vector3(0f - angularVelocity[0], 0f - angularVelocity[1], angularVelocity[2]);
			}
			if (goblinserviceStarted)
			{
				return new Vector3(0f - angularVelocity[0], 0f - angularVelocity[1], 0f - angularVelocity[2]);
			}
		}
		return new Vector3(0f, 0f, 0f);
	}

	public Vector3 GetAngularAcceleration(int num)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref angularAcce, javaCVClass, "getControllerAngularAcceleration", num);
		}
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog angularAcce:" + angularAcce[0] + "," + angularAcce[1] + "," + angularAcce[2]);
		}
		if (!float.IsNaN(angularAcce[0]) && !float.IsNaN(angularAcce[1]) && !float.IsNaN(angularAcce[2]))
		{
			return new Vector3(0f - angularAcce[0], 0f - angularAcce[1], angularAcce[2]);
		}
		return new Vector3(0f, 0f, 0f);
	}

	public Vector3 GetAcceleration(int num)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref acceData, javaCVClass, "getControllerAcceleration", num);
		}
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref acceData, javaHummingbirdClass, "getHbAcceleration");
		}
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog Acce:" + acceData[0] / 1000f + acceData[1] / 1000f + acceData[2] / 1000f);
		}
		if (!float.IsNaN(acceData[0]) && !float.IsNaN(acceData[1]) && !float.IsNaN(acceData[2]))
		{
			return new Vector3(acceData[0] / 1000f, acceData[1] / 1000f, (0f - acceData[2]) / 1000f);
		}
		return new Vector3(0f, 0f, 0f);
	}

	public string GetConnectedDeviceMac()
	{
		string result = "";
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getConnectedDeviceMac");
		}
		PLOG.I("PvrLog ConnectedDeviceMac:" + result);
		return result;
	}

	public void VibrateNeo2Controller(float strength, int time, int hand)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "vibrateCV2ControllerStrength", strength, time, hand);
		}
		PLOG.I("PvrLog VibrateNeo2Controller:" + strength + time + hand);
	}

	public void VibrateController(float strength, int time, int hand)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "vibrateCV2ControllerStrength", strength, time, hand);
		}
		PLOG.I("PvrLog VibrateController:" + strength + time + hand);
	}

	public int GetMainControllerIndex()
	{
		int result = 0;
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getMainControllerIndex");
		}
		PLOG.I("PvrLog GetMainControllerIndex:" + result);
		return result;
	}

	public void SetMainController(int index)
	{
		PLOG.I("PvrLog SetMainController:" + index);
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "setMainController", index);
		}
	}

	public void ResetHeadSensorForController()
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "resetHeadSensorForController");
		}
		PLOG.I("PvrLog ResetHeadSensorForController:");
	}

	public void GetDeviceVersion(int deviceType)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "getDeviceVersion", deviceType);
		}
		PLOG.I("PvrLog GetDeviceVersion:" + deviceType);
	}

	public void GetControllerSnCode(int controllerSerialNum)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "getControllerSnCode", controllerSerialNum);
		}
		PLOG.I("PvrLog GetControllerSnCode:" + controllerSerialNum);
	}

	public void SetControllerUnbind(int controllerSerialNum)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "setControllerUnbind", controllerSerialNum);
		}
		PLOG.I("PvrLog SetControllerUnbind:" + controllerSerialNum);
	}

	public void SetStationRestart()
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "setStationRestart");
		}
		PLOG.I("PvrLog SetStationRestart");
	}

	public void StartStationOtaUpdate()
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "startStationOtaUpdate");
		}
		PLOG.I("PvrLog StartStationOtaUpdate");
	}

	public void StartControllerOtaUpdate(int mode, int controllerSerialNum)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "startControllerOtaUpdate", mode, controllerSerialNum);
		}
		PLOG.I("PvrLog StartControllerOtaUpdate" + mode + controllerSerialNum);
	}

	public void EnterPairMode(int controllerSerialNum)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "enterPairMode", controllerSerialNum);
		}
		PLOG.I("PvrLog EnterPairMode" + controllerSerialNum);
	}

	public void SetControllerShutdown(int controllerSerialNum)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "setControllerShutdown", controllerSerialNum);
		}
		PLOG.I("PvrLog SetControllerShutdown" + controllerSerialNum);
	}

	public int GetStationPairState()
	{
		int result = -1;
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getStationPairState");
		}
		PLOG.I("PvrLog StationPairState" + result);
		return result;
	}

	public int GetStationOtaUpdateProgress()
	{
		int result = -1;
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getStationOtaUpdateProgress");
		}
		PLOG.I("PvrLog StationOtaUpdateProgress" + result);
		return result;
	}

	public int GetControllerOtaUpdateProgress()
	{
		int result = -1;
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getControllerOtaUpdateProgress");
		}
		PLOG.I("PvrLog ControllerOtaUpdateProgress" + result);
		return result;
	}

	public void GetControllerVersionAndSN(int controllerSerialNum)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "getControllerVersionAndSN", controllerSerialNum);
		}
		PLOG.I("PvrLog GetControllerVersionAndSN" + controllerSerialNum);
	}

	public void GetControllerUniqueID()
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "getControllerUniqueID");
		}
		PLOG.I("PvrLog GetControllerUniqueID");
	}

	public void InterruptStationPairMode()
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "interruptStationPairMode");
		}
		PLOG.I("PvrLog InterruptStationPairMode");
	}

	public int GetControllerAbility(int controllerSerialNum)
	{
		int result = -1;
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getControllerAbility", controllerSerialNum);
		}
		PLOG.I("PvrLog ControllerAbility:" + result);
		return result;
	}

	public void SwitchHomeKey(bool state)
	{
		PLOG.I("PvrLog SwitchHomeKey:" + state);
		switchHomeKey = state;
	}

	public void SetBootReconnect()
	{
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "setBootReconnect");
		PLOG.I("PvrLog SetBootReconnect");
	}

	public int GetTemperature()
	{
		int result = -1;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getTemperature");
		PLOG.I("PvrLog Temperature:" + result);
		return result;
	}

	public int GetDeviceType()
	{
		int result = -1;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getDeviceType");
		PLOG.I("PvrLog DeviceType:" + result);
		return result;
	}

	public int GetControllerType()
	{
		int result = -1;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getControllerType");
		return result;
	}

	public string GetHummingBird2SN()
	{
		string result = "";
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getHummingBird2SN");
		PLOG.I("PvrLog HummingBird2SN:" + result);
		return result;
	}

	public string GetControllerVersion()
	{
		string result = "";
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getControllerVersion");
		PLOG.I("PvrLog ControllerVersion:" + result);
		return result;
	}

	public bool IsEnbleTrigger()
	{
		bool result = false;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "isEnbleTrigger");
		PLOG.I("PvrLog IsEnbleTrigger:" + result);
		return result;
	}

	public void StartCV2PairingMode(int devicetype)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "startCV2PairingMode", devicetype);
		}
		PLOG.I("PvrLog StartCV2PairingMode:" + devicetype);
	}

	public void StopCV2PairingMode(int devicetype)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "stopCV2PairingMode", devicetype);
		}
		PLOG.I("PvrLog StopCV2PairingMode:" + devicetype);
	}

	public int GetControllerBindingState(int id)
	{
		int result = -1;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getControllerBindingState", id);
		PLOG.I("PvrLog getControllerBindingState:" + result);
		return result;
	}

	public void setIsEnbleHomeKey(bool state)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "setIsEnbleHomeKey", state);
		}
		PLOG.I("PvrLog setIsEnbleHomeKey:" + state);
	}

	public int getControllerSensorStatus(int id)
	{
		int result = -1;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getControllerSensorStatus", id);
		PLOG.I("PvrLog getControllerSensorStatus:" + result);
		return result;
	}

	public float[] GetControllerPredictSensorData(int controllerID, float predictTime)
	{
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "SetHeadDataAndPreTime", Pvr_UnitySDKManager.SDK.headData, predictTime);
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref predictData, javaCVClass, "getControllerSensorStateWithHeadDataAndPreTime", controllerID);
		return predictData;
	}
}
public class Pvr_ControllerManager : MonoBehaviour
{
	public delegate void PvrServiceStartSuccess();

	public delegate void PvrControllerStateChanged(string data);

	public delegate void ChangeMainControllerCallBack(string index);

	public delegate void ChangeHandNessCallBack(string index);

	public delegate void SetHbServiceBindState();

	public delegate void ControllerThreadStartedCallback();

	public delegate void SetControllerServiceBindState();

	public delegate void ControllerStatusChange(string isconnect);

	public delegate void SetControllerAbility(string data);

	public delegate void SetControllerStateChanged(string data);

	public delegate void SetHbControllerMac(string mac);

	public delegate void ControllerDeviceVersionCallback(string data);

	public delegate void ControllerSnCodeCallback(string data);

	public delegate void ControllerUnbindCallback(string status);

	public delegate void ControllerStationStatusCallback(string status);

	public delegate void ControllerStationBusyCallback(string status);

	public delegate void ControllerOtaStartCodeCallback(string data);

	public delegate void ControllerDeviceVersionAndSNCallback(string data);

	public delegate void ControllerUniqueIDCallback(string data);

	public delegate void ControllerCombinedKeyUnbindCallback(string data);

	private static Pvr_ControllerManager instance;

	public static Pvr_ControllerLink controllerlink;

	private float cTime = 1f;

	private bool stopConnect;

	public Text toast;

	private bool controllerServicestate;

	private float disConnectTime;

	public bool LengthAdaptiveRay;

	private float[] sensorData = new float[28];

	private int[] keyData = new int[134];

	private float[] g2SensorData = new float[4];

	private int[] g2KeyData = new int[47];

	private int keyOffset;

	private int rotControllerMode = 1;

	public static Pvr_ControllerManager Instance
	{
		get
		{
			if (instance == null)
			{
				instance = UnityEngine.Object.FindObjectOfType<Pvr_ControllerManager>();
			}
			if (instance == null)
			{
				GameObject obj = new GameObject("GameObject");
				instance = obj.AddComponent<Pvr_ControllerManager>();
				obj.transform.localPosition = Vector3.zero;
			}
			return instance;
		}
	}

	public static event PvrServiceStartSuccess PvrServiceStartSuccessEvent;

	public static event PvrControllerStateChanged PvrControllerStateChangedEvent;

	public static event ChangeMainControllerCallBack ChangeMainControllerCallBackEvent;

	public static event ChangeHandNessCallBack ChangeHandNessCallBackEvent;

	public static event SetHbServiceBindState SetHbServiceBindStateEvent;

	public static event ControllerThreadStartedCallback ControllerThreadStartedCallbackEvent;

	public static event SetControllerServiceBindState SetControllerServiceBindStateEvent;

	public static event ControllerStatusChange ControllerStatusChangeEvent;

	public static event SetControllerAbility SetControllerAbilityEvent;

	public static event SetControllerStateChanged SetControllerStateChangedEvent;

	public static event SetHbControllerMac SetHbControllerMacEvent;

	public static event ControllerDeviceVersionCallback ControllerDeviceVersionCallbackEvent;

	public static event ControllerSnCodeCallback ControllerSnCodeCallbackEvent;

	public static event ControllerUnbindCallback ControllerUnbindCallbackEvent;

	public static event ControllerStationStatusCallback ControllerStationStatusCallbackEvent;

	public static event ControllerStationBusyCallback ControllerStationBusyCallbackEvent;

	public static event ControllerOtaStartCodeCallback ControllerOtaStartCodeCallbackEvent;

	public static event ControllerDeviceVersionAndSNCallback ControllerDeviceVersionAndSNCallbackEvent;

	public static event ControllerUniqueIDCallback ControllerUniqueIDCallbackEvent;

	public static event ControllerCombinedKeyUnbindCallback ControllerCombinedKeyUnbindCallbackEvent;

	private void Awake()
	{
		if (instance == null)
		{
			instance = this;
		}
		if (instance != this)
		{
			PLOG.E("instance object should be a singleton.");
			return;
		}
		if (controllerlink == null)
		{
			controllerlink = new Pvr_ControllerLink(base.gameObject.name);
			return;
		}
		controllerlink.SetGameObjectToJar(base.gameObject.name);
		BindService();
	}

	private void Start()
	{
		if (controllerlink.trackingmode < 2)
		{
			Invoke("CheckControllerService", 10f);
		}
		Render.UPvr_GetIntConfig(23, ref rotControllerMode);
	}

	private void Update()
	{
		if (controllerlink.neoserviceStarted)
		{
			sensorData = controllerlink.GetControllerSensorData();
			keyData = controllerlink.GetControllerKeyData();
			if (controllerlink.controller0Connected)
			{
				if (Pvr_UnitySDKManager.SDK.ShowVideoSeethrough)
				{
					sensorData[2] = 0f - sensorData[2];
					sensorData[3] = 0f - sensorData[3];
					controllerlink.Controller0.Rotation.Set(sensorData[0], sensorData[1], sensorData[2], sensorData[3]);
					if (rotControllerMode == 0)
					{
						controllerlink.Controller0.Rotation *= Quaternion.Euler(34f, 0f, 0f);
					}
					controllerlink.Controller0.Position.Set(sensorData[4] / 1000f, sensorData[5] / 1000f, (0f - sensorData[6]) / 1000f);
				}
				else
				{
					controllerlink.Controller0.Rotation.Set(sensorData[7], sensorData[8], sensorData[9], sensorData[10]);
					if (rotControllerMode == 0)
					{
						controllerlink.Controller0.Rotation *= Quaternion.Euler(34f, 0f, 0f);
					}
					controllerlink.Controller0.Position.Set(sensorData[11] / 1000f, sensorData[12] / 1000f, (0f - sensorData[13]) / 1000f);
				}
				if (!controllerlink.Controller0.isShowBoundary)
				{
					if (controllerlink.getControllerSensorStatus(0) == 0)
					{
						Sensor.UPvr_SetReinPosition(sensorData[0], sensorData[1], sensorData[2], sensorData[3], sensorData[4], sensorData[5], sensorData[6], 0, valid: false, 0);
					}
					else
					{
						controllerlink.Controller0.isShowBoundary = true;
						Sensor.UPvr_SetReinPosition(sensorData[0], sensorData[1], sensorData[2], sensorData[3], sensorData[4], sensorData[5], sensorData[6], 0, valid: true, Convert.ToInt32(Convert.ToString(keyData[35]) + Convert.ToString(keyData[15]) + "00", 2));
					}
				}
				else
				{
					Sensor.UPvr_SetReinPosition(sensorData[0], sensorData[1], sensorData[2], sensorData[3], sensorData[4], sensorData[5], sensorData[6], 0, valid: true, Convert.ToInt32(Convert.ToString(keyData[35]) + Convert.ToString(keyData[15]) + "00", 2));
				}
				TransformData(controllerlink.Controller0, 0, keyData);
			}
			else
			{
				Sensor.UPvr_SetReinPosition(sensorData[0], sensorData[1], sensorData[2], sensorData[3], sensorData[4], sensorData[5], sensorData[6], 0, valid: false, 0);
			}
			if (controllerlink.controller1Connected)
			{
				if (Pvr_UnitySDKManager.SDK.ShowVideoSeethrough)
				{
					sensorData[16] = 0f - sensorData[16];
					sensorData[17] = 0f - sensorData[17];
					controllerlink.Controller1.Rotation.Set(sensorData[14], sensorData[15], sensorData[16], sensorData[17]);
					if (rotControllerMode == 0)
					{
						controllerlink.Controller1.Rotation *= Quaternion.Euler(34f, 0f, 0f);
					}
					controllerlink.Controller1.Position.Set(sensorData[18] / 1000f, sensorData[19] / 1000f, (0f - sensorData[20]) / 1000f);
				}
				else
				{
					controllerlink.Controller1.Rotation.Set(sensorData[21], sensorData[22], sensorData[23], sensorData[24]);
					if (rotControllerMode == 0)
					{
						controllerlink.Controller1.Rotation *= Quaternion.Euler(34f, 0f, 0f);
					}
					controllerlink.Controller1.Position.Set(sensorData[25] / 1000f, sensorData[26] / 1000f, (0f - sensorData[27]) / 1000f);
				}
				if (!controllerlink.Controller1.isShowBoundary)
				{
					if (controllerlink.getControllerSensorStatus(1) == 0)
					{
						Sensor.UPvr_SetReinPosition(sensorData[14], sensorData[15], sensorData[16], sensorData[17], sensorData[18], sensorData[19], sensorData[20], 1, valid: false, 0);
					}
					else
					{
						controllerlink.Controller1.isShowBoundary = true;
						Sensor.UPvr_SetReinPosition(sensorData[14], sensorData[15], sensorData[16], sensorData[17], sensorData[18], sensorData[19], sensorData[20], 1, valid: true, Convert.ToInt32(Convert.ToString(keyData[102]) + Convert.ToString(keyData[82]) + "00", 2));
					}
				}
				else
				{
					Sensor.UPvr_SetReinPosition(sensorData[14], sensorData[15], sensorData[16], sensorData[17], sensorData[18], sensorData[19], sensorData[20], 1, valid: true, Convert.ToInt32(Convert.ToString(keyData[102]) + Convert.ToString(keyData[82]) + "00", 2));
				}
				TransformData(controllerlink.Controller1, 1, keyData);
			}
			else
			{
				Sensor.UPvr_SetReinPosition(sensorData[14], sensorData[15], sensorData[16], sensorData[17], sensorData[18], sensorData[19], sensorData[20], 1, valid: false, 0);
			}
		}
		if (controllerlink.goblinserviceStarted && controllerlink.controller0Connected)
		{
			g2SensorData = controllerlink.GetHBControllerPoseData();
			controllerlink.Controller0.Rotation.Set(g2SensorData[0], g2SensorData[1], g2SensorData[2], g2SensorData[3]);
			g2KeyData = controllerlink.GetHBControllerKeyData();
			TransformData(controllerlink.Controller0, 0, g2KeyData);
		}
		SetSystemKey();
	}

	private void OnApplicationPause(bool pause)
	{
		int headSensorState = ((!Pvr_UnitySDKManager.SDK.HmdOnlyrot) ? 1 : 0);
		int handSensorState = ((!Pvr_UnitySDKManager.SDK.ControllerOnlyrot) ? 1 : 0);
		if (pause)
		{
			if (controllerlink.neoserviceStarted)
			{
				controllerlink.SetGameObjectToJar("");
				controllerlink.StopControllerThread(headSensorState, handSensorState);
			}
			if (controllerlink.goblinserviceStarted)
			{
				controllerlink.StopReceiver();
			}
			return;
		}
		controllerlink.Controller0 = new ControllerHand();
		controllerlink.Controller1 = new ControllerHand();
		if (controllerlink.neoserviceStarted)
		{
			controllerlink.SetGameObjectToJar(base.gameObject.name);
			controllerlink.SetUnityVersionToJar("2.8.11.5");
			controllerlink.StartControllerThread(headSensorState, handSensorState);
		}
		if (controllerlink.goblinserviceStarted)
		{
			controllerlink.StartReceiver();
			controllerlink.controller0Connected = GetControllerConnectionState(0) == 1;
			controllerlink.controllerType = controllerlink.GetControllerType();
			controllerlink.handness = (Pvr_Controller.UserHandNess)controllerlink.getHandness();
			if (Pvr_ControllerManager.PvrServiceStartSuccessEvent != null)
			{
				Pvr_ControllerManager.PvrServiceStartSuccessEvent();
			}
		}
	}

	private void OnDestroy()
	{
		controllerlink.UnBindService();
		Sensor.UPvr_SetReinPosition(0f, 0f, 0f, 1f, 0f, 0f, 0f, 0, valid: false, 0);
		Sensor.UPvr_SetReinPosition(0f, 0f, 0f, 1f, 0f, 0f, 0f, 1, valid: false, 0);
	}

	private void OnApplicationQuit()
	{
		int headSensorState = ((!Pvr_UnitySDKManager.SDK.HmdOnlyrot) ? 1 : 0);
		int handSensorState = ((!Pvr_UnitySDKManager.SDK.ControllerOnlyrot) ? 1 : 0);
		if (controllerlink.neoserviceStarted)
		{
			controllerlink.SetGameObjectToJar("");
			controllerlink.StopControllerThread(headSensorState, handSensorState);
		}
	}

	public Vector3 GetAngularVelocity(int num)
	{
		if (controllerlink != null)
		{
			return controllerlink.GetAngularVelocity(num);
		}
		return new Vector3(0f, 0f, 0f);
	}

	public Vector3 GetAcceleration(int num)
	{
		if (controllerlink != null)
		{
			return controllerlink.GetAcceleration(num);
		}
		return new Vector3(0f, 0f, 0f);
	}

	public void BindService()
	{
		if (controllerlink != null)
		{
			controllerlink.BindService();
		}
	}

	public void StartScan()
	{
		if (controllerlink != null)
		{
			controllerlink.StartScan();
		}
	}

	public void StopScan()
	{
		if (controllerlink != null)
		{
			controllerlink.StopScan();
		}
	}

	public void ResetController(int num)
	{
		if (controllerlink != null)
		{
			controllerlink.ResetController(num);
		}
	}

	public static int GetControllerConnectionState(int num)
	{
		return controllerlink.GetControllerConnectionState(num);
	}

	public void ConnectBLE()
	{
		if (controllerlink != null)
		{
			controllerlink.ConnectBLE();
		}
	}

	public void DisConnectBLE()
	{
		if (controllerlink != null)
		{
			controllerlink.DisConnectBLE();
		}
	}

	public void SetBinPath(string path, bool isAsset)
	{
		if (controllerlink != null)
		{
			controllerlink.setBinPath(path, isAsset);
		}
	}

	public void StartUpgrade()
	{
		if (controllerlink != null)
		{
			controllerlink.StartUpgrade();
		}
	}

	public static string GetBLEImageType()
	{
		return controllerlink.GetBLEImageType();
	}

	public static long GetBLEVersion()
	{
		return controllerlink.GetBLEVersion();
	}

	public static string GetFileImageType()
	{
		return controllerlink.GetFileImageType();
	}

	public static long GetFileVersion()
	{
		return controllerlink.GetFileVersion();
	}

	public static void AutoConnectHbController(int scans)
	{
		if (controllerlink != null)
		{
			controllerlink.AutoConnectHbController(scans);
		}
	}

	public static string GetConnectedDeviceMac()
	{
		string result = "";
		if (controllerlink != null)
		{
			result = controllerlink.GetConnectedDeviceMac();
		}
		return result;
	}

	public void setHbControllerMac(string mac)
	{
		PLOG.I("PvrLog HBMacRSSI" + mac);
		controllerlink.hummingBirdMac = mac.Substring(0, 17);
		controllerlink.hummingBirdRSSI = Convert.ToInt16(mac.Remove(0, 18));
		if (Pvr_ControllerManager.SetHbControllerMacEvent != null)
		{
			Pvr_ControllerManager.SetHbControllerMacEvent(mac.Substring(0, 17));
		}
	}

	public int GetControllerRSSI()
	{
		return controllerlink.hummingBirdRSSI;
	}

	public void setHbServiceBindState(string state)
	{
		PLOG.I("PvrLog HBBindCallBack" + state);
		controllerServicestate = true;
		if (Convert.ToInt16(state) == 0)
		{
			Invoke("BindService", 0.5f);
			controllerlink.goblinserviceStarted = false;
		}
		else if (Convert.ToInt16(state) == 1)
		{
			controllerlink.goblinserviceStarted = true;
			controllerlink.controller0Connected = GetControllerConnectionState(0) == 1;
			controllerlink.controllerType = controllerlink.GetControllerType();
			controllerlink.handness = (Pvr_Controller.UserHandNess)controllerlink.getHandness();
			if (Pvr_ControllerManager.SetHbServiceBindStateEvent != null)
			{
				Pvr_ControllerManager.SetHbServiceBindStateEvent();
			}
			if (Pvr_ControllerManager.PvrServiceStartSuccessEvent != null)
			{
				Pvr_ControllerManager.PvrServiceStartSuccessEvent();
			}
		}
	}

	public void setControllerServiceBindState(string state)
	{
		PLOG.I("PvrLog CVBindCallBack" + state);
		if (Convert.ToInt16(state) == 0)
		{
			Invoke("BindService", 0.5f);
			controllerlink.neoserviceStarted = false;
		}
		else if (Convert.ToInt16(state) == 1)
		{
			controllerlink.SetUnityVersionToJar("2.8.11.5");
			controllerlink.neoserviceStarted = true;
			int headSensorState = ((!Pvr_UnitySDKManager.SDK.HmdOnlyrot) ? 1 : 0);
			int handSensorState = ((!Pvr_UnitySDKManager.SDK.ControllerOnlyrot) ? 1 : 0);
			controllerlink.StartControllerThread(headSensorState, handSensorState);
			if (Pvr_ControllerManager.SetControllerServiceBindStateEvent != null)
			{
				Pvr_ControllerManager.SetControllerServiceBindStateEvent();
			}
		}
	}

	public void setHbControllerConnectState(string isconnect)
	{
		PLOG.I("PvrLog HBControllerConnect" + isconnect);
		controllerlink.controller0Connected = Convert.ToInt16(isconnect) == 1;
		if (!controllerlink.controller0Connected)
		{
			controllerlink.Controller0 = new ControllerHand();
		}
		else
		{
			ResetController(0);
			controllerlink.controllerType = controllerlink.GetControllerType();
			controllerlink.handness = (Pvr_Controller.UserHandNess)controllerlink.getHandness();
		}
		stopConnect = false;
		if (Pvr_ControllerManager.ControllerStatusChangeEvent != null)
		{
			Pvr_ControllerManager.ControllerStatusChangeEvent(isconnect);
		}
		if (Pvr_ControllerManager.PvrControllerStateChangedEvent != null)
		{
			Pvr_ControllerManager.PvrControllerStateChangedEvent(isconnect);
		}
	}

	public void setControllerStateChanged(string state)
	{
		PLOG.I("PvrLog CVControllerStateChanged" + state);
		int num = Convert.ToInt16(state.Substring(0, 1));
		if (num == 0)
		{
			controllerlink.controller0Connected = Convert.ToBoolean(Convert.ToInt16(state.Substring(2, 1)));
			if (!controllerlink.controller0Connected)
			{
				controllerlink.Controller0 = new ControllerHand();
				controllerlink.Controller0.Position = new Vector3(0f, Pvr_UnitySDKSensor.Instance.HeadPose.Position.y, 0f) + new Vector3(-0.1f, -0.3f, 0.3f);
			}
		}
		else
		{
			controllerlink.controller1Connected = Convert.ToBoolean(Convert.ToInt16(state.Substring(2, 1)));
			if (!controllerlink.controller1Connected)
			{
				controllerlink.Controller1 = new ControllerHand();
				controllerlink.Controller1.Position = new Vector3(0f, Pvr_UnitySDKSensor.Instance.HeadPose.Position.y, 0f) + new Vector3(0.1f, -0.3f, 0.3f);
			}
		}
		if (Convert.ToBoolean(Convert.ToInt16(state.Substring(2, 1))))
		{
			controllerlink.controllerType = controllerlink.GetControllerType();
			controllerlink.ResetController(num);
		}
		controllerlink.handness = (Pvr_Controller.UserHandNess)controllerlink.getHandness();
		controllerlink.mainHandID = controllerlink.GetMainControllerIndex();
		if (Pvr_ControllerManager.SetControllerStateChangedEvent != null)
		{
			Pvr_ControllerManager.SetControllerStateChangedEvent(state);
		}
		if (Pvr_ControllerManager.PvrControllerStateChangedEvent != null)
		{
			Pvr_ControllerManager.PvrControllerStateChangedEvent(state);
		}
	}

	public void setControllerAbility(string data)
	{
		PLOG.I("PvrLog setControllerAbility" + data);
		if (Pvr_ControllerManager.SetControllerAbilityEvent != null)
		{
			Pvr_ControllerManager.SetControllerAbilityEvent(data);
		}
	}

	public void controllerThreadStartedCallback()
	{
		PLOG.I("PvrLog ThreadStartSuccess");
		GetCVControllerState();
		if (Pvr_ControllerManager.ControllerThreadStartedCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerThreadStartedCallbackEvent();
		}
		if (Pvr_ControllerManager.PvrServiceStartSuccessEvent != null)
		{
			Pvr_ControllerManager.PvrServiceStartSuccessEvent();
		}
	}

	public void controllerDeviceVersionCallback(string data)
	{
		PLOG.I("PvrLog VersionCallBack" + data);
		if (Pvr_ControllerManager.ControllerDeviceVersionCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerDeviceVersionCallbackEvent(data);
		}
	}

	public void controllerSnCodeCallback(string data)
	{
		PLOG.I("PvrLog SNCodeCallBack" + data);
		if (Pvr_ControllerManager.ControllerSnCodeCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerSnCodeCallbackEvent(data);
		}
	}

	public void controllerUnbindCallback(string status)
	{
		PLOG.I("PvrLog ControllerUnBindCallBack" + status);
		if (Pvr_ControllerManager.ControllerUnbindCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerUnbindCallbackEvent(status);
		}
	}

	public void controllerStationStatusCallback(string status)
	{
		PLOG.I("PvrLog StationStatusCallBack" + status);
		if (Pvr_ControllerManager.ControllerStationStatusCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerStationStatusCallbackEvent(status);
		}
	}

	public void controllerStationBusyCallback(string status)
	{
		PLOG.I("PvrLog StationBusyCallBack" + status);
		if (Pvr_ControllerManager.ControllerStationBusyCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerStationBusyCallbackEvent(status);
		}
	}

	public void controllerOTAStartCodeCallback(string data)
	{
		PLOG.I("PvrLog OTAUpdateCallBack" + data);
		if (Pvr_ControllerManager.ControllerOtaStartCodeCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerOtaStartCodeCallbackEvent(data);
		}
	}

	public void controllerDeviceVersionAndSNCallback(string data)
	{
		PLOG.I("PvrLog DeviceVersionAndSNCallback" + data);
		if (Pvr_ControllerManager.ControllerDeviceVersionAndSNCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerDeviceVersionAndSNCallbackEvent(data);
		}
	}

	public void controllerUniqueIDCallback(string data)
	{
		PLOG.I("PvrLog controllerUniqueIDCallback" + data);
		if (Pvr_ControllerManager.ControllerUniqueIDCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerUniqueIDCallbackEvent(data);
		}
	}

	public void controllerCombinedKeyUnbindCallback(string controllerSerialNum)
	{
		if (Pvr_ControllerManager.ControllerCombinedKeyUnbindCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerCombinedKeyUnbindCallbackEvent(controllerSerialNum);
		}
	}

	public void setupdateFailed()
	{
	}

	public void setupdateSuccess()
	{
	}

	public void setupdateProgress(string progress)
	{
	}

	public void setHbAutoConnectState(string state)
	{
		PLOG.I("PvrLog HBAutoConnectState" + state);
		controllerServicestate = true;
		if (Convert.ToInt16(state) == 0 && GetControllerConnectionState(0) == 0)
		{
			ShowToast(2);
		}
		if (Convert.ToInt16(state) == 2)
		{
			ShowToast(3);
		}
	}

	public void callbackControllerServiceState(string state)
	{
		PLOG.I("PvrLog HBServiceState" + state);
		controllerServicestate = true;
		if (Convert.ToInt16(state) == 0)
		{
			ShowToast(0);
		}
		if (Convert.ToInt16(state) == 1)
		{
			BindService();
		}
		if (Convert.ToInt16(state) == 2)
		{
			ShowToast(1);
		}
	}

	public void changeMainControllerCallback(string index)
	{
		PLOG.I("PvrLog MainControllerCallBack" + index);
		controllerlink.mainHandID = Convert.ToInt16(index);
		if (Pvr_ControllerManager.ChangeMainControllerCallBackEvent != null)
		{
			Pvr_ControllerManager.ChangeMainControllerCallBackEvent(index);
		}
	}

	public void changeHandnessCallback(string index)
	{
		PLOG.I("PvrLog changeHandnessCallback" + index);
		controllerlink.handness = (Pvr_Controller.UserHandNess)Convert.ToInt16(index);
		if (Pvr_ControllerManager.ChangeHandNessCallBackEvent != null)
		{
			Pvr_ControllerManager.ChangeHandNessCallBackEvent(index);
		}
	}

	private void ShowToast(int type)
	{
		if (toast != null)
		{
			switch (type)
			{
			case 0:
				toast.text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("servicetip0");
				Invoke("HideToast", 5f);
				break;
			case 1:
				toast.text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("servicetip1");
				Invoke("HideToast", 5f);
				break;
			case 2:
				toast.text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("servicetip2");
				AutoConnectHbController(6000);
				Invoke("HideToast", 5f);
				break;
			case 3:
				toast.text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("servicetip3");
				AutoConnectHbController(6000);
				Invoke("HideToast", 5f);
				break;
			case 4:
				toast.text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("servicetip4");
				Invoke("HideToast", 10f);
				break;
			}
		}
	}

	private void HideToast()
	{
		if (toast != null)
		{
			toast.text = "";
		}
	}

	private void CheckControllerService()
	{
		if (!controllerServicestate)
		{
			ShowToast(4);
		}
	}

	private void GetCVControllerState()
	{
		int controllerConnectionState = GetControllerConnectionState(0);
		int controllerConnectionState2 = GetControllerConnectionState(1);
		PLOG.I("PvrLog CVconnect" + controllerConnectionState + controllerConnectionState2);
		if (controllerConnectionState == -1 && controllerConnectionState2 == -1)
		{
			Invoke("GetCVControllerState", 0.02f);
		}
		if (controllerConnectionState != -1 && controllerConnectionState2 != -1)
		{
			controllerlink.controller0Connected = controllerConnectionState == 1;
			controllerlink.controller1Connected = controllerConnectionState2 == 1;
			if (!controllerlink.controller0Connected && controllerlink.controller1Connected && controllerlink.GetMainControllerIndex() == 0)
			{
				Controller.UPvr_SetMainHandNess(1);
			}
			if (controllerlink.controller0Connected || controllerlink.controller1Connected)
			{
				controllerlink.controllerType = controllerlink.GetControllerType();
			}
			controllerlink.mainHandID = controllerlink.GetMainControllerIndex();
			controllerlink.handness = (Pvr_Controller.UserHandNess)controllerlink.getHandness();
		}
	}

	private void SetSystemKey()
	{
		if (controllerlink.switchHomeKey && (Controller.UPvr_GetKeyLongPressed(0, Pvr_KeyCode.HOME) || Controller.UPvr_GetKeyLongPressed(1, Pvr_KeyCode.HOME)))
		{
			if (Pvr_UnitySDKManager.SDK.HmdOnlyrot)
			{
				Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 0);
			}
			else if (controllerlink.trackingmode == 0 || controllerlink.trackingmode == 1)
			{
				Pvr_UnitySDKSensor.Instance.ResetUnitySDKSensor();
			}
			else
			{
				Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 1);
			}
			if (Pvr_UnitySDKManager.SDK.ControllerOnlyrot || (controllerlink.controller0Connected && Controller.UPvr_GetControllerPOS(0).Equals(Vector3.zero)) || (controllerlink.controller1Connected && Controller.UPvr_GetControllerPOS(1).Equals(Vector3.zero)))
			{
				if (Controller.UPvr_GetKeyLongPressed(0, Pvr_KeyCode.HOME))
				{
					ResetController(0);
				}
				if (Controller.UPvr_GetKeyLongPressed(1, Pvr_KeyCode.HOME))
				{
					ResetController(1);
				}
			}
		}
		if (controllerlink.picoDevice)
		{
			if (controllerlink.switchHomeKey && (Controller.UPvr_GetKeyClick(0, Pvr_KeyCode.HOME) || (Controller.UPvr_GetKeyClick(1, Pvr_KeyCode.HOME) && !stopConnect)))
			{
				controllerlink.RebackToLauncher();
			}
			if (Controller.UPvr_GetKeyClick(0, Pvr_KeyCode.VOLUMEUP) || Controller.UPvr_GetKeyClick(1, Pvr_KeyCode.VOLUMEUP))
			{
				controllerlink.TurnUpVolume();
			}
			if (Controller.UPvr_GetKeyClick(0, Pvr_KeyCode.VOLUMEDOWN) || Controller.UPvr_GetKeyClick(1, Pvr_KeyCode.VOLUMEDOWN))
			{
				controllerlink.TurnDownVolume();
			}
			if (!Controller.UPvr_GetKey(0, Pvr_KeyCode.VOLUMEUP) && !Controller.UPvr_GetKey(0, Pvr_KeyCode.VOLUMEDOWN) && !Controller.UPvr_GetKey(1, Pvr_KeyCode.VOLUMEUP) && !Controller.UPvr_GetKey(1, Pvr_KeyCode.VOLUMEDOWN))
			{
				cTime = 1f;
			}
			if (Controller.UPvr_GetKey(0, Pvr_KeyCode.VOLUMEUP) || Controller.UPvr_GetKey(1, Pvr_KeyCode.VOLUMEUP))
			{
				cTime -= Time.deltaTime;
				if (cTime <= 0f)
				{
					cTime = 0.2f;
					controllerlink.TurnUpVolume();
				}
			}
			if (!Controller.UPvr_GetKey(0, Pvr_KeyCode.HOME) && !Controller.UPvr_GetKey(1, Pvr_KeyCode.HOME) && (Controller.UPvr_GetKey(0, Pvr_KeyCode.VOLUMEDOWN) || Controller.UPvr_GetKey(1, Pvr_KeyCode.VOLUMEDOWN)))
			{
				cTime -= Time.deltaTime;
				if (cTime <= 0f)
				{
					cTime = 0.2f;
					controllerlink.TurnDownVolume();
				}
			}
		}
		if (controllerlink.goblinserviceStarted && Controller.UPvr_GetKey(0, Pvr_KeyCode.HOME) && Controller.UPvr_GetKey(0, Pvr_KeyCode.VOLUMEDOWN) && !stopConnect)
		{
			disConnectTime += Time.deltaTime;
			if ((double)disConnectTime > 1.0)
			{
				DisConnectBLE();
				controllerlink.hummingBirdMac = "";
				stopConnect = true;
				disConnectTime = 0f;
			}
		}
	}

	private void TransformData(ControllerHand hand, int handId, int[] data)
	{
		keyOffset = ((handId == 1) ? 67 : 0);
		hand.TouchPadPosition.x = data[keyOffset];
		hand.TouchPadPosition.y = data[5 + keyOffset];
		TransSingleKey(hand.Home, 10 + keyOffset, data);
		TransSingleKey(hand.App, 15 + keyOffset, data);
		TransSingleKey(hand.Touch, 20 + keyOffset, data);
		TransSingleKey(hand.VolumeUp, 25 + keyOffset, data);
		TransSingleKey(hand.VolumeDown, 30 + keyOffset, data);
		TransSingleKey(hand.Trigger, 35 + keyOffset, data);
		if (controllerlink.goblinserviceStarted && !controllerlink.neoserviceStarted)
		{
			hand.TriggerNum = controllerlink.GetHBKeyValue();
		}
		if (!controllerlink.goblinserviceStarted && controllerlink.neoserviceStarted)
		{
			hand.TriggerNum = controllerlink.GetCVTriggerValue(handId);
		}
		hand.Battery = data[40 + keyOffset];
		if (data.Length == 47)
		{
			hand.SwipeDirection = (SwipeDirection)data[45];
			hand.TouchPadClick = (TouchPadClick)data[46];
		}
		else
		{
			switch (handId)
			{
			case 0:
				TransSingleKey(hand.X, 45 + keyOffset, data);
				TransSingleKey(hand.Y, 50 + keyOffset, data);
				TransSingleKey(hand.Left, 60 + keyOffset, data);
				break;
			case 1:
				TransSingleKey(hand.A, 45 + keyOffset, data);
				TransSingleKey(hand.B, 50 + keyOffset, data);
				TransSingleKey(hand.Right, 55 + keyOffset, data);
				break;
			}
			hand.SwipeDirection = (SwipeDirection)data[65 + keyOffset];
			hand.TouchPadClick = (TouchPadClick)data[66 + keyOffset];
		}
		hand.GripValue = controllerlink.GetNeo3GripValue(handId);
		TransformTouchData(hand, handId, controllerlink.GetNeo3TouchData(handId));
	}

	private void TransSingleKey(PvrControllerKey key, int beginIndex, int[] data)
	{
		key.State = Convert.ToBoolean(data[beginIndex]);
		key.PressedDown = Convert.ToBoolean(data[beginIndex + 1]);
		key.PressedUp = Convert.ToBoolean(data[beginIndex + 2]);
		key.LongPressed = Convert.ToBoolean(data[beginIndex + 3]);
		key.Click = Convert.ToBoolean(data[beginIndex + 4]);
	}

	private void TransformTouchData(ControllerHand hand, int handId, int[] data)
	{
		switch (handId)
		{
		case 0:
			TransSingleTouchValue(hand.X, 0, data);
			TransSingleTouchValue(hand.Y, 3, data);
			break;
		case 1:
			TransSingleTouchValue(hand.A, 0, data);
			TransSingleTouchValue(hand.B, 3, data);
			break;
		}
		TransSingleTouchValue(hand.Touch, 6, data);
		TransSingleTouchValue(hand.Trigger, 9, data);
		TransSingleTouchValue(hand.Thumbrest, 12, data);
	}

	private void TransSingleTouchValue(PvrControllerKey key, int beginIndex, int[] data)
	{
		key.Touch = Convert.ToBoolean(data[beginIndex]);
		key.TouchDown = Convert.ToBoolean(data[beginIndex + 1]);
		key.TouchUp = Convert.ToBoolean(data[beginIndex + 2]);
	}
}
public class Pvr_ControllerModuleInit : MonoBehaviour
{
	public ControllerVariety Variety;

	public bool IsCustomModel;

	[SerializeField]
	private GameObject dot;

	[SerializeField]
	private GameObject rayLine;

	[SerializeField]
	private GameObject controller;

	private bool moduleState = true;

	private Ray ray;

	private RaycastHit hit;

	[SerializeField]
	public float rayDefaultLength = 10f;

	public static float rayLen = 10f;

	private void Awake()
	{
		Pvr_ControllerManager.PvrServiceStartSuccessEvent += ServiceStartSuccess;
		Pvr_ControllerManager.PvrControllerStateChangedEvent += ControllerStateChanged;
		Pvr_ControllerManager.ChangeMainControllerCallBackEvent += MainControllerIDChanged;
		ray = default(Ray);
		hit = default(RaycastHit);
		if (Pvr_ControllerManager.Instance.LengthAdaptiveRay)
		{
			rayLine = base.transform.GetComponentInChildren<LineRenderer>(includeInactive: true).gameObject;
			rayLine.GetComponent<LineRenderer>().startWidth = 0.003f;
			rayLine.GetComponent<LineRenderer>().endWidth = 0.0015f;
		}
		dot.transform.localPosition = Vector3.zero;
	}

	private void OnDestroy()
	{
		Pvr_ControllerManager.PvrServiceStartSuccessEvent -= ServiceStartSuccess;
		Pvr_ControllerManager.PvrControllerStateChangedEvent -= ControllerStateChanged;
		Pvr_ControllerManager.ChangeMainControllerCallBackEvent -= MainControllerIDChanged;
	}

	private void ServiceStartSuccess()
	{
		RefreshRay();
	}

	private void ControllerStateChanged(string data)
	{
		if (Pvr_ControllerManager.controllerlink.controller0Connected || Pvr_ControllerManager.controllerlink.controller1Connected)
		{
			moduleState = true;
			controller.transform.localScale = Vector3.one;
		}
		RefreshRay();
	}

	private void MainControllerIDChanged(string data)
	{
		RefreshRay();
	}

	private void RefreshRay()
	{
		if (Variety == ControllerVariety.Controller0)
		{
			StartCoroutine(ShowOrHideRay(0));
		}
		if (Variety == ControllerVariety.Controller1)
		{
			StartCoroutine(ShowOrHideRay(1));
		}
	}

	private IEnumerator ShowOrHideRay(int id)
	{
		yield return null;
		yield return null;
		if (moduleState)
		{
			bool active = Controller.UPvr_GetMainHandNess() == id && Controller.UPvr_GetControllerState(id) == ControllerState.Connected;
			dot.SetActive(active);
			rayLine.SetActive(active);
		}
	}

	public void ForceHideOrShow(bool state)
	{
		dot.SetActive(state);
		rayLine.SetActive(state);
		controller.transform.localScale = (state ? Vector3.one : Vector3.zero);
		moduleState = state;
	}

	public bool GetModuleState()
	{
		return moduleState;
	}

	public void UpdateRay()
	{
		if (!Pvr_ControllerManager.Instance.LengthAdaptiveRay)
		{
			return;
		}
		bool flag = false;
		flag = ((Pvr_ControllerManager.controllerlink.controller0Connected || Pvr_ControllerManager.controllerlink.controller1Connected) ? true : false);
		if (flag && rayLine != null && rayLine.gameObject.activeSelf)
		{
			int num = Controller.UPvr_GetDeviceType();
			ray.direction = base.transform.forward;
			if (num == 1)
			{
				ray.origin = base.transform.TransformPoint(0f, 0f, 0.058f);
			}
			else
			{
				ray.origin = base.transform.TransformPoint(0f, 0.009f, 0.055f);
			}
			if (Physics.Raycast(ray, out hit, rayLen, -1025))
			{
				dot.transform.position = hit.point;
			}
			else
			{
				dot.transform.position = ray.origin + ray.direction.normalized * rayDefaultLength;
			}
			if (num == 1)
			{
				rayLine.GetComponent<LineRenderer>().SetPosition(0, base.transform.TransformPoint(0f, 0f, 0.058f));
			}
			else
			{
				rayLine.GetComponent<LineRenderer>().SetPosition(0, base.transform.TransformPoint(0f, 0.009f, 0.055f));
			}
			rayLine.GetComponent<LineRenderer>().SetPosition(1, dot.transform.position);
		}
	}
}
public class Pvr_ControllerPower : MonoBehaviour
{
	[SerializeField]
	private Sprite power1;

	[SerializeField]
	private Sprite power2;

	[SerializeField]
	private Sprite power3;

	[SerializeField]
	private Sprite power4;

	[SerializeField]
	private Sprite power5;

	[HideInInspector]
	public ControllerVariety variety;

	[HideInInspector]
	public ControllerDevice currentDevice;

	private Image powerImage;

	private int powerValue;

	private float power;

	private void Start()
	{
		powerImage = base.transform.GetComponent<Image>();
		powerValue = -1;
		variety = base.transform.GetComponentInParent<Pvr_ControllerModuleInit>().Variety;
		currentDevice = base.transform.GetComponentInParent<Pvr_ControllerVisual>().currentDevice;
	}

	private void Update()
	{
		RefreshPower((variety != 0) ? 1 : 0);
	}

	private void RefreshPower(int hand)
	{
		if (powerValue != Controller.UPvr_GetControllerPower(hand))
		{
			switch (Controller.UPvr_GetControllerPower(hand))
			{
			case 1:
				powerImage.sprite = power1;
				powerImage.color = Color.red;
				break;
			case 2:
				powerImage.sprite = power2;
				powerImage.color = Color.white;
				break;
			case 3:
				powerImage.sprite = power3;
				powerImage.color = Color.white;
				break;
			case 4:
				powerImage.sprite = power4;
				powerImage.color = Color.white;
				break;
			case 5:
				powerImage.sprite = power5;
				powerImage.color = Color.white;
				break;
			default:
				powerImage.sprite = power1;
				powerImage.color = Color.white;
				break;
			}
			powerValue = Controller.UPvr_GetControllerPower(hand);
		}
	}
}
public class Pvr_ControllerVisual : MonoBehaviour
{
	public ControllerDevice currentDevice;

	public Texture2D m_idle;

	public Texture2D m_app;

	public Texture2D m_home;

	public Texture2D m_touchpad;

	public Texture2D m_volUp;

	public Texture2D m_volDn;

	public Texture2D m_trigger;

	public Texture2D m_a;

	public Texture2D m_b;

	public Texture2D m_x;

	public Texture2D m_y;

	public Texture2D m_grip;

	private Renderer controllerRenderMat;

	[HideInInspector]
	public ControllerVariety variety;

	private void Awake()
	{
		controllerRenderMat = GetComponent<Renderer>();
	}

	private void Start()
	{
		variety = base.transform.GetComponentInParent<Pvr_ControllerModuleInit>().Variety;
	}

	private void Update()
	{
		ChangeKeyEffects((variety != 0) ? 1 : 0);
	}

	private void ChangeKeyEffects(int hand)
	{
		if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.TOUCHPAD))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_touchpad);
		}
		else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.APP))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_app);
		}
		else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.HOME))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_home);
		}
		else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.VOLUMEUP))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_volUp);
		}
		else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.VOLUMEDOWN))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_volDn);
		}
		else if (Controller.UPvr_GetControllerTriggerValue(hand) > 0 || Controller.UPvr_GetKey(hand, Pvr_KeyCode.TRIGGER))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_trigger);
		}
		else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.X))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_x);
		}
		else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.Y))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_y);
		}
		else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.A))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_a);
		}
		else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.B))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_b);
		}
		else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.Left) || Controller.UPvr_GetKey(hand, Pvr_KeyCode.Right))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_grip);
		}
		else if (controllerRenderMat.material.GetTexture("_MainTex") != m_idle)
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_idle);
		}
	}
}
public class Pvr_ToolTips : MonoBehaviour
{
	public enum TipBtn
	{
		app,
		touchpad,
		home,
		volup,
		voldown,
		trigger,
		grip
	}

	private ControllerDevice currentDevice;

	private float tipsAlpha;

	public static Pvr_ToolTips tooltips;

	public void ChangeTipsText(TipBtn tip, string key)
	{
		switch (tip)
		{
		case TipBtn.app:
			base.transform.Find("apptip/btn/Text").GetComponent<Text>().text = key;
			break;
		case TipBtn.touchpad:
			base.transform.Find("touchtip/btn/Text").GetComponent<Text>().text = key;
			break;
		case TipBtn.home:
			base.transform.Find("hometip/btn/Text").GetComponent<Text>().text = key;
			break;
		case TipBtn.volup:
			base.transform.Find("volup/btn/Text").GetComponent<Text>().text = key;
			break;
		case TipBtn.voldown:
			base.transform.Find("voldown/btn/Text").GetComponent<Text>().text = key;
			break;
		case TipBtn.trigger:
			base.transform.Find("triggertip/btn/Text").GetComponent<Text>().text = key;
			break;
		case TipBtn.grip:
			base.transform.Find("grip/btn/Text").GetComponent<Text>().text = key;
			break;
		}
	}

	private void Awake()
	{
		tooltips = base.transform.GetComponent<Pvr_ToolTips>();
	}

	private void Update()
	{
		switch (currentDevice)
		{
		case ControllerDevice.Goblin:
		case ControllerDevice.G2:
			tipsAlpha = (330f - base.transform.parent.parent.parent.localRotation.eulerAngles.x) / 45f;
			if (base.transform.parent.parent.parent.localRotation.eulerAngles.x >= 270f && base.transform.parent.parent.parent.localRotation.eulerAngles.x <= 330f)
			{
				tipsAlpha = Mathf.Max(0f, tipsAlpha);
				tipsAlpha = ((tipsAlpha > 1f) ? 1f : tipsAlpha);
			}
			else
			{
				tipsAlpha = 0f;
			}
			GetComponent<CanvasGroup>().alpha = tipsAlpha;
			break;
		case ControllerDevice.Neo2:
		case ControllerDevice.Neo3:
			tipsAlpha = (330f - base.transform.parent.parent.parent.localRotation.eulerAngles.x) / 45f;
			if (base.transform.parent.parent.parent.localRotation.eulerAngles.x >= 270f && base.transform.parent.parent.parent.localRotation.eulerAngles.x <= 330f)
			{
				tipsAlpha = Mathf.Max(0f, tipsAlpha);
				tipsAlpha = ((tipsAlpha > 1f) ? 1f : tipsAlpha);
			}
			else
			{
				tipsAlpha = 0f;
			}
			GetComponent<CanvasGroup>().alpha = tipsAlpha;
			break;
		case ControllerDevice.Neo:
			break;
		}
	}

	private void LoadTextFromJson()
	{
		currentDevice = base.transform.GetComponentInParent<Pvr_ControllerVisual>().currentDevice;
		base.transform.Find("apptip/btn/Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("apptip");
		base.transform.Find("touchtip/btn/Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("touchtip");
		base.transform.Find("hometip/btn/Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("hometip");
		Transform transform = base.transform.Find("volup/btn/Text");
		if (transform != null)
		{
			transform.GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("voluptip");
		}
		Transform transform2 = base.transform.Find("voldown/btn/Text");
		if (transform2 != null)
		{
			transform2.GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("voldowntip");
		}
		Transform transform3 = base.transform.Find("triggertip/btn/Text");
		if (transform3 != null)
		{
			transform3.GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("triggertip");
		}
		Transform transform4 = base.transform.Find("grip/btn/Text");
		if (transform4 != null)
		{
			transform4.GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("griptip");
		}
	}

	public static void RefreshTips()
	{
		if (tooltips != null)
		{
			tooltips.LoadTextFromJson();
		}
	}
}
public class Pvr_TouchPadScroll : MonoBehaviour
{
	private ScrollRect scrollRect;

	private bool isHoving;

	private int mainHand;

	private SwipeDirection direction;

	private Vector2 currPos;

	private Vector2 tarPos;

	private float lerpSpeed = 10f;

	private Transform tranViewport;

	private float ignoreDis = 3f;

	private Vector2 lastTouchDownPos;

	private Vector2 lastTouchUpPos;

	private bool isTouching;

	private bool isClosed = true;

	private Vector2 vecOrigin = Vector2.zero;

	private Vector2 vecOriginNeo2 = new Vector2(128f, 128f);

	private void Awake()
	{
		scrollRect = base.gameObject.GetComponent<ScrollRect>();
		tranViewport = base.transform.Find("Viewport");
	}

	private void Update()
	{
		Process();
		UpdateTargetPos();
		UpdatePos();
	}

	private bool IsControllerConnect()
	{
		mainHand = Controller.UPvr_GetMainHandNess();
		if (mainHand == 0 && Pvr_ControllerManager.controllerlink.controller0Connected)
		{
			return true;
		}
		if (mainHand == 1 && Pvr_ControllerManager.controllerlink.controller1Connected)
		{
			return true;
		}
		return false;
	}

	private void UpdateTargetPos()
	{
		if (Controller.UPvr_GetKey(0, Pvr_KeyCode.TOUCHPAD) || Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.TOUCHPAD))
		{
			ResetParameter();
		}
		else if (isHoving)
		{
			if (Pvr_ControllerManager.controllerlink.GetControllerType() == 3)
			{
				ComputeTouchPos();
			}
			else
			{
				ComputeRockerPos();
			}
			if ((currPos - tarPos).sqrMagnitude <= 10f)
			{
				isClosed = true;
			}
		}
	}

	private void ComputeTouchPos()
	{
		mainHand = Controller.UPvr_GetMainHandNess();
		currPos = scrollRect.content.localPosition;
		Vector2 vector = vecOrigin;
		if (mainHand == 0 && Pvr_ControllerManager.controllerlink.controller0Connected)
		{
			vector = Controller.UPvr_GetTouchPadPosition(mainHand);
		}
		if (mainHand == 1 && Pvr_ControllerManager.controllerlink.controller1Connected)
		{
			vector = Controller.UPvr_GetTouchPadPosition(mainHand);
		}
		if ((vector - vecOrigin).sqrMagnitude >= 1f)
		{
			if (!isTouching)
			{
				lastTouchDownPos = vector;
				isTouching = true;
			}
			lastTouchUpPos.x = vector.x;
			if (Mathf.Abs(lastTouchUpPos.x - lastTouchDownPos.x) > ignoreDis)
			{
				Vector2 vector2 = new Vector2((lastTouchUpPos.x - lastTouchDownPos.x) * 10f, 0f);
				lastTouchDownPos.x = lastTouchUpPos.x;
				if (isClosed)
				{
					tarPos = currPos + vector2;
					isClosed = false;
				}
				else
				{
					tarPos += vector2;
				}
			}
		}
		else
		{
			lastTouchDownPos = vecOrigin;
			lastTouchUpPos = vecOrigin;
			isTouching = false;
			if ((double)scrollRect.horizontalScrollbar.value >= 0.999 || (double)scrollRect.horizontalScrollbar.value <= 0.0001)
			{
				isClosed = true;
			}
		}
	}

	private void ComputeRockerPos()
	{
		mainHand = Controller.UPvr_GetMainHandNess();
		currPos = scrollRect.content.localPosition;
		Vector2 vector = vecOriginNeo2;
		if (mainHand == 0 && Pvr_ControllerManager.controllerlink.controller0Connected)
		{
			vector = Controller.UPvr_GetTouchPadPosition(mainHand);
		}
		if (mainHand == 1 && Pvr_ControllerManager.controllerlink.controller1Connected)
		{
			vector = Controller.UPvr_GetTouchPadPosition(mainHand);
		}
		if (VerifyNeo2TouchValid(vector) && (vector - vecOriginNeo2).sqrMagnitude >= 1f)
		{
			if (!isTouching)
			{
				lastTouchDownPos = vector;
				isTouching = true;
			}
			lastTouchUpPos.x = vector.x;
			if (Mathf.Abs(lastTouchUpPos.x - lastTouchDownPos.x) > ignoreDis)
			{
				Vector2 vector2 = new Vector2((lastTouchUpPos.x - lastTouchDownPos.x) * 10f, 0f);
				lastTouchDownPos.x = lastTouchUpPos.x;
				if (isClosed)
				{
					tarPos = currPos + vector2;
					isClosed = false;
				}
				else
				{
					tarPos += vector2;
				}
			}
		}
		else
		{
			lastTouchDownPos = vecOriginNeo2;
			lastTouchUpPos = vecOriginNeo2;
			isTouching = false;
			if ((double)scrollRect.horizontalScrollbar.value >= 0.999 || (double)scrollRect.horizontalScrollbar.value <= 0.0001)
			{
				isClosed = true;
			}
		}
	}

	private bool VerifyNeo2TouchValid(Vector2 nowTouchPos)
	{
		if (nowTouchPos.x > vecOriginNeo2.x && nowTouchPos.x > lastTouchDownPos.x)
		{
			return true;
		}
		if (nowTouchPos.x < vecOriginNeo2.x && nowTouchPos.x < lastTouchDownPos.x)
		{
			return true;
		}
		return false;
	}

	private void UpdatePos()
	{
		if (Controller.UPvr_GetKey(0, Pvr_KeyCode.TOUCHPAD) || Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.TOUCHPAD))
		{
			ResetParameter();
		}
		else if (!isClosed && IsControllerConnect())
		{
			if ((double)scrollRect.horizontalScrollbar.value >= 0.9999 && tarPos.x <= currPos.x)
			{
				isClosed = true;
				return;
			}
			if ((double)scrollRect.horizontalScrollbar.value <= 0.0001 && tarPos.x >= currPos.x)
			{
				isClosed = true;
				return;
			}
			currPos.x = Mathf.Lerp(currPos.x, tarPos.x, lerpSpeed * Time.deltaTime);
			currPos.y = Mathf.Lerp(currPos.y, tarPos.y, lerpSpeed * Time.deltaTime);
			scrollRect.content.localPosition = currPos;
		}
	}

	private void ResetParameter()
	{
		currPos = scrollRect.content.localPosition;
		tarPos = scrollRect.content.localPosition;
		isClosed = true;
	}

	private void Process()
	{
		for (int i = 0; i < Pvr_InputModule.pointers.Count; i++)
		{
			Pvr_UIPointer pvr_UIPointer = Pvr_InputModule.pointers[i];
			if (pvr_UIPointer.gameObject.activeInHierarchy && pvr_UIPointer.enabled)
			{
				isHoving = IsHovering(pvr_UIPointer);
			}
		}
	}

	private bool IsHovering(Pvr_UIPointer pointer)
	{
		if (!IsControllerConnect())
		{
			return false;
		}
		foreach (GameObject item in pointer.pointerEventData.hovered)
		{
			if (FindTree(item.transform))
			{
				mainHand = Controller.UPvr_GetMainHandNess();
				if (mainHand == 0 && Pvr_ControllerManager.controllerlink.controller0Connected)
				{
					return true;
				}
				if (mainHand == 1 && Pvr_ControllerManager.controllerlink.controller1Connected)
				{
					return true;
				}
			}
		}
		return false;
	}

	private bool FindTree(Transform tran)
	{
		if (tran == base.transform || tran == tranViewport)
		{
			return true;
		}
		if (tran.IsChildOf(tranViewport))
		{
			return true;
		}
		return false;
	}
}
public class Pvr_TouchVisual : MonoBehaviour
{
	[HideInInspector]
	public ControllerDevice currentDevice;

	[HideInInspector]
	public ControllerVariety variety;

	private MeshRenderer touchRenderer;

	private void Start()
	{
		variety = base.transform.GetComponentInParent<Pvr_ControllerModuleInit>().Variety;
		currentDevice = GetComponentInParent<Pvr_ControllerVisual>().currentDevice;
		touchRenderer = GetComponent<MeshRenderer>();
	}

	private void Update()
	{
		ChangeEffects((variety != 0) ? 1 : 0);
	}

	private void ChangeEffects(int hand)
	{
		ControllerDevice controllerDevice = currentDevice;
		if (controllerDevice == ControllerDevice.G2)
		{
			if (Controller.UPvr_IsTouching(0))
			{
				touchRenderer.enabled = true;
				base.transform.localPosition = new Vector3(1.3f - Controller.UPvr_GetTouchPadPosition(hand).x * 0.01f, 1.6f, -1.7f - Controller.UPvr_GetTouchPadPosition(hand).y * 0.01f);
			}
			else
			{
				touchRenderer.enabled = false;
			}
		}
	}
}
public class DemoController : MonoBehaviour
{
	public delegate void showLoadingEventHandler();

	private Callback callback;

	private GameObject msg;

	private Pvr_UnitySDKManager picoVrManager;

	private string currentOrderID;

	public GameObject loading;

	public GameObject BG;

	public GameObject InputPanel;

	public static showLoadingEventHandler showLoading;

	private void Awake()
	{
		UnityEngine.Debug.Log(loading.name);
		UnityEngine.Debug.Log(BG.name);
		showLoading = (showLoadingEventHandler)Delegate.Combine(showLoading, new showLoadingEventHandler(StopLoading));
		InputManager.doEnter = (InputManager.doEnterEventHandler)Delegate.Combine(InputManager.doEnter, new InputManager.doEnterEventHandler(DoPayByCode));
		currentOrderID = "";
	}

	private void Start()
	{
		msg = GameObject.Find("MassageInfo");
		InitDelegate();
		callback = new Callback();
		picoVrManager = GameObject.Find("Pvr_UnitySDK").GetComponent<Pvr_UnitySDKManager>();
		InputPanel.SetActive(value: false);
	}

	private void Update()
	{
		if (picoVrManager != null && (Input.GetKeyDown(KeyCode.Y) || Input.GetKeyDown(KeyCode.Joystick1Button2)))
		{
			UnityEngine.Debug.Log("update");
			Pvr_UnitySDKSensor.Instance.ResetUnitySDKSensor();
		}
		if (Input.GetKeyDown(KeyCode.Joystick1Button1) || Input.GetKeyDown(KeyCode.Escape))
		{
			if (InputPanel.activeInHierarchy)
			{
				InputPanel.SetActive(value: false);
			}
			else
			{
				Application.Quit();
			}
		}
	}

	private void InitDelegate()
	{
		foreach (string item in new ArrayList { "Login", "GetUserAPI", "PayOne", "PayCode", "QueryOrder" })
		{
			GameObject btnObj = GameObject.Find(item);
			btnObj.GetComponent<Button>().onClick.AddListener(delegate
			{
				OnClick(btnObj);
			});
		}
	}

	private void OnClick(GameObject btnObj)
	{
		switch (btnObj.name)
		{
		case "Login":
			StartLoading();
			LoginSDK.Login();
			break;
		case "PayOne":
			CommonDic.getInstance().setParameters("subject", "game");
			CommonDic.getInstance().setParameters("body", "gamePay");
			CommonDic.getInstance().setParameters("order_id", getRamdomTestOrderID());
			CommonDic.getInstance().setParameters("total", "1");
			CommonDic.getInstance().setParameters("goods_tag", "game");
			CommonDic.getInstance().setParameters("notify_url", "www.picovr.com");
			CommonDic.getInstance().setParameters("pay_code", "");
			StartLoading();
			PicoPaymentSDK.Pay(CommonDic.getInstance().PayOrderString());
			break;
		case "PayCode":
			InputPanel.SetActive(value: true);
			break;
		case "QueryOrder":
			StartLoading();
			PicoPaymentSDK.QueryOrder(currentOrderID);
			break;
		case "GetUserAPI":
			StartLoading();
			LoginSDK.GetUserAPI();
			break;
		}
	}

	public string getRamdomTestOrderID()
	{
		currentOrderID = (UnityEngine.Random.value * 65535f).ToString();
		return currentOrderID;
	}

	private void StartLoading()
	{
		loading.SetActive(value: true);
		BG.SetActive(value: true);
	}

	public void StopLoading()
	{
		if ((bool)loading && (bool)BG)
		{
			loading.SetActive(value: false);
			BG.SetActive(value: false);
		}
		else
		{
			UnityEngine.Debug.LogError("用户自定义，非演示demo");
		}
	}

	public void DoPayByCode()
	{
		CommonDic.getInstance().setParameters("subject", "game");
		CommonDic.getInstance().setParameters("body", "gamePay");
		CommonDic.getInstance().setParameters("order_id", getRamdomTestOrderID());
		CommonDic.getInstance().setParameters("total", "0");
		CommonDic.getInstance().setParameters("goods_tag", "game");
		CommonDic.getInstance().setParameters("notify_url", "www.picovr.com");
		CommonDic.getInstance().setParameters("pay_code", GameObject.Find("CodeText").GetComponent<Text>().text);
		UnityEngine.Debug.Log("商品码支付" + GameObject.Find("CodeText").GetComponent<Text>().text);
		StartLoading();
		GameObject.Find("CodeText").GetComponent<Text>().text = "";
		InputPanel.SetActive(value: false);
		PicoPaymentSDK.Pay(CommonDic.getInstance().PayOrderString());
	}

	private bool VerifyLocalToken()
	{
		if (CommonDic.getInstance().access_token.Equals(""))
		{
			GameObject.Find("MassageInfo").GetComponent<Text>().text = "{code:exception,msg:请先登录}";
			currentOrderID = "";
			StopLoading();
			return false;
		}
		return true;
	}
}
public class LoadingRatation : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
		base.gameObject.transform.Rotate(new Vector3(0f, 0f, -4f));
	}
}
public class InputManager : MonoBehaviour
{
	public delegate void doEnterEventHandler();

	public static doEnterEventHandler doEnter;

	private StringBuilder sb = new StringBuilder();

	private ArrayList btnsName = new ArrayList();

	private GameObject enter;

	private void Awake()
	{
		InitKeyBoard();
	}

	private void Start()
	{
	}

	private void Update()
	{
	}

	private void InitKeyBoard()
	{
		btnsName.Add("1");
		btnsName.Add("2");
		btnsName.Add("3");
		btnsName.Add("4");
		btnsName.Add("5");
		btnsName.Add("6");
		btnsName.Add("7");
		btnsName.Add("8");
		btnsName.Add("9");
		btnsName.Add("0");
		btnsName.Add("Q");
		btnsName.Add("W");
		btnsName.Add("E");
		btnsName.Add("R");
		btnsName.Add("T");
		btnsName.Add("Y");
		btnsName.Add("U");
		btnsName.Add("I");
		btnsName.Add("O");
		btnsName.Add("P");
		btnsName.Add("A");
		btnsName.Add("S");
		btnsName.Add("D");
		btnsName.Add("F");
		btnsName.Add("G");
		btnsName.Add("H");
		btnsName.Add("J");
		btnsName.Add("K");
		btnsName.Add("L");
		btnsName.Add("Z");
		btnsName.Add("X");
		btnsName.Add("C");
		btnsName.Add("V");
		btnsName.Add("B");
		btnsName.Add("N");
		btnsName.Add("M");
		btnsName.Add("Clear");
		btnsName.Add("Capslock");
		btnsName.Add("Enter");
		foreach (string item in btnsName)
		{
			GameObject btnObj = GameObject.Find(item);
			btnObj.GetComponent<Button>().onClick.AddListener(delegate
			{
				OnClick(btnObj);
			});
		}
		enter = GameObject.Find("Enter");
		enter.SetActive(sb.Length > 0);
	}

	private void OnClick(GameObject btnObj)
	{
		if (btnObj.name.Equals("Capslock"))
		{
			if (GameObject.Find("Q").transform.GetChild(0).GetComponent<Text>().text.Equals("Q"))
			{
				DoCapslock(IsUpper: true);
			}
			else
			{
				DoCapslock(IsUpper: false);
			}
		}
		else if (btnObj.name.Equals("Clear"))
		{
			GameObject.Find("CodeText").GetComponent<Text>().text = "";
			ClearBuffer();
		}
		else if (btnObj.name.Equals("Enter"))
		{
			ClearBuffer();
			doEnter();
		}
		else
		{
			EnterChar(btnObj.transform.GetChild(0).GetComponent<Text>().text);
		}
	}

	private void EnterChar(string s)
	{
		sb.Append(s);
		GameObject.Find("CodeText").GetComponent<Text>().text = sb.ToString();
		enter.SetActive(sb.Length > 0);
	}

	private void DoCapslock(bool IsUpper)
	{
		if (IsUpper)
		{
			foreach (string item in btnsName)
			{
				Text component = GameObject.Find(item).transform.GetChild(0).GetComponent<Text>();
				component.text = component.text.ToLower();
			}
			return;
		}
		foreach (string item2 in btnsName)
		{
			Text component2 = GameObject.Find(item2).transform.GetChild(0).GetComponent<Text>();
			component2.text = component2.text.ToUpper();
		}
	}

	private void ClearBuffer()
	{
		sb.Remove(0, sb.Length);
		enter.SetActive(sb.Length > 0);
	}
}
public class Callback : MonoBehaviour
{
	private static string IS_SUCCESS = "isSuccess";

	private static string MSG = "msg";

	private static string CODE = "code";

	public void LoginCallback(string LoginInfo)
	{
		LitJson.JsonData jsonData = LitJson.JsonMapper.ToObject(LoginInfo);
		SetMassage(LoginInfo);
		DemoController.showLoading();
		if (jsonData[IS_SUCCESS] != null)
		{
			CommonDic.getInstance().isSuccess = jsonData[IS_SUCCESS].ToString();
		}
		if (jsonData[MSG] != null)
		{
			CommonDic.getInstance().loginMsg = jsonData[MSG].ToString();
		}
		UnityEngine.Debug.Log("调用login回调:" + LoginInfo);
	}

	public void QueryOrPayCallback(string queryOrPayInfo)
	{
		LitJson.JsonData jsonData = LitJson.JsonMapper.ToObject(queryOrPayInfo);
		if (jsonData[CODE] != null)
		{
			CommonDic.getInstance().code = jsonData["code"].ToString();
		}
		if (jsonData[MSG] != null)
		{
			CommonDic.getInstance().msg = jsonData["msg"].ToString();
		}
		if (jsonData != null)
		{
			CommonDic.getInstance().order_info = jsonData[1].ToString();
		}
		SetMassage(queryOrPayInfo);
		DemoController.showLoading();
		UnityEngine.Debug.Log("调用pay回调:" + queryOrPayInfo);
	}

	public void UserInfoCallback(string userInfo)
	{
		CommonDic.getInstance().user_info = userInfo;
		SetMassage(userInfo);
		DemoController.showLoading();
		UnityEngine.Debug.Log("调用userInfo回调:" + userInfo);
	}

	public void SetMassage(string massage)
	{
		if (!GetCurrentGameObject().Equals(null))
		{
			GetCurrentGameObject().GetComponent<Text>().text = massage;
		}
		else
		{
			UnityEngine.Debug.LogError("无接收该Message的控件");
		}
	}

	public GameObject GetCurrentGameObject()
	{
		return GameObject.Find("MassageInfo");
	}

	public void ActivityForResultCallback(string activity)
	{
		PicoPaymentSDK.jo.Call("authCallback", activity);
	}
}
public class CommonDic
{
	private static CommonDic dic;

	private static Dictionary<string, string> mydic;

	private string _app_ID;

	private string _app_Key;

	private string _user_token;

	private string _access_token = "";

	private string _open_id;

	private string _refresh_token;

	private string _expires_in;

	private string _user_info;

	private string _subject;

	private string _body;

	private string _order_id;

	private string _total;

	private string _goods_tag;

	private string _notify_url;

	private string _trade_type;

	private string _pay_code = "";

	private string _order_info;

	private string _code;

	private string _msg = "null";

	private string _merchant_ID;

	private string _payKey;

	private string _isSuucess;

	private string _loginMsg;

	public string subject
	{
		get
		{
			return _subject;
		}
		set
		{
			_subject = value;
		}
	}

	public string body
	{
		get
		{
			return _body;
		}
		set
		{
			_body = value;
		}
	}

	public string order_id
	{
		get
		{
			return _order_id;
		}
		set
		{
			_order_id = value;
		}
	}

	public string total
	{
		get
		{
			return _total;
		}
		set
		{
			_total = value;
		}
	}

	public string goods_tag
	{
		get
		{
			return _goods_tag;
		}
		set
		{
			_goods_tag = value;
		}
	}

	public string notify_url
	{
		get
		{
			return _notify_url;
		}
		set
		{
			_notify_url = value;
		}
	}

	public string pay_code
	{
		get
		{
			return _pay_code;
		}
		set
		{
			_pay_code = value;
		}
	}

	public string trade_type
	{
		get
		{
			return _trade_type;
		}
		set
		{
			_trade_type = value;
		}
	}

	public string user_token
	{
		get
		{
			return _user_token;
		}
		set
		{
			_user_token = value;
		}
	}

	public string access_token
	{
		get
		{
			return _access_token;
		}
		set
		{
			_access_token = value;
		}
	}

	public string open_id
	{
		get
		{
			return _open_id;
		}
		set
		{
			_open_id = value;
		}
	}

	public string refresh_token
	{
		get
		{
			return _refresh_token;
		}
		set
		{
			_refresh_token = value;
		}
	}

	public string expires_in
	{
		get
		{
			return _expires_in;
		}
		set
		{
			_expires_in = value;
		}
	}

	public string isSuccess
	{
		get
		{
			return _isSuucess;
		}
		set
		{
			_isSuucess = value;
		}
	}

	public string loginMsg
	{
		get
		{
			return _loginMsg;
		}
		set
		{
			_loginMsg = value;
		}
	}

	public string user_info
	{
		get
		{
			return _user_info;
		}
		set
		{
			_user_info = value;
		}
	}

	public string order_info
	{
		get
		{
			return _order_info;
		}
		set
		{
			_order_info = value;
		}
	}

	public string code
	{
		get
		{
			return _code;
		}
		set
		{
			_code = value;
		}
	}

	public string msg
	{
		get
		{
			return _msg;
		}
		set
		{
			_msg = value;
		}
	}

	public string app_ID
	{
		get
		{
			return _app_ID;
		}
		set
		{
			_app_ID = value;
		}
	}

	public string app_Key
	{
		get
		{
			return _app_Key;
		}
		set
		{
			_app_Key = value;
		}
	}

	public string merchant_ID
	{
		get
		{
			return _merchant_ID;
		}
		set
		{
			_merchant_ID = value;
		}
	}

	public string paykey
	{
		get
		{
			return _payKey;
		}
		set
		{
			_payKey = value;
		}
	}

	public static CommonDic getInstance()
	{
		if (dic == null)
		{
			dic = new CommonDic();
		}
		if (mydic == null)
		{
			mydic = new Dictionary<string, string>();
			InitDicData(mydic);
		}
		return dic;
	}

	public Dictionary<string, string> getDic()
	{
		return mydic;
	}

	public void setParameters(string name, string value)
	{
		if (name.Equals("subject"))
		{
			subject = value;
		}
		if (name.Equals("body"))
		{
			body = value;
		}
		if (name.Equals("order_id"))
		{
			order_id = value;
		}
		if (name.Equals("total"))
		{
			total = value;
		}
		if (name.Equals("goods_tag"))
		{
			goods_tag = value;
		}
		if (name.Equals("notify_url"))
		{
			notify_url = value;
		}
		if (name.Equals("trade_type"))
		{
			trade_type = value;
		}
		if (name.Equals("pay_code"))
		{
			pay_code = value;
		}
	}

	public string PayOrderString()
	{
		return LitJson.JsonMapper.ToJson(getInstance());
	}

	public static void InitDicData(Dictionary<string, string> mydic)
	{
		mydic.Add("00000", "网络异常");
		mydic.Add("10000", "登录成功");
		mydic.Add("10001", "用户未登陆");
		mydic.Add("10002", "请输入正确金额");
		mydic.Add("10003", "登陆过期，请重新登陆");
		mydic.Add("11000", "商户验证成功");
		mydic.Add("11001", "商户验证失败");
		mydic.Add("11002", "用户验证参数错误或请求过期");
		mydic.Add("11003", "商户未验证");
		mydic.Add("12000", "支付成功");
		mydic.Add("12001", "支付失败");
		mydic.Add("12003", "P币不足");
		mydic.Add("12004", "余额可用");
		mydic.Add("13000", "生成订单");
		mydic.Add("13001", "获取数据失败");
		mydic.Add("13002", "生成订单失败");
		mydic.Add("14000", "查询订单成功");
		mydic.Add("14001", "订单不存在/有误");
		mydic.Add("14002", "用户取消支付操作");
		mydic.Add("15000", "未输入商品信息");
		mydic.Add("15001", "未输入预付ID");
		mydic.Add("15002", "请输入Pico支付订单号或商户订单号");
		mydic.Add("NOAUTH", "商户无此接口权限");
		mydic.Add("SYSTEMERROR", "系统错误");
		mydic.Add("APP_ID_NOT_EXIST", "APP_ID不存在");
		mydic.Add("MCHID_NOT_EXIST", "MCHID不存在");
		mydic.Add("APP_ID_MCHID_NOT_MATCH", "app_id和mch_id不匹配ID");
		mydic.Add("LACK_PARAMS", "缺少参数");
		mydic.Add("SIGNERROR", "签名错误");
		mydic.Add("NO_DATA", "没有查询到数据");
	}
}
public class LoginSDK
{
	public static void Login()
	{
		PicoPaymentSDK.Login();
	}

	public static void GetUserAPI()
	{
		PicoPaymentSDK.GetUserAPI();
	}
}
public class PicoPaymentSDK
{
	private static AndroidJavaObject _jo = new AndroidJavaObject("com.pico.loginpaysdk.UnityInterface");

	public static AndroidJavaObject jo
	{
		get
		{
			return _jo;
		}
		set
		{
			_jo = value;
		}
	}

	public static void Login()
	{
		AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
		jo.Call("init", @static);
		jo.Call("authSSO");
	}

	public static void Pay(string payOrderJson)
	{
		AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
		jo.Call("init", @static);
		jo.Call("pay", payOrderJson);
	}

	public static void QueryOrder(string orderId)
	{
		AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
		jo.Call("init", @static);
		jo.Call("queryOrder", orderId);
	}

	public static void GetUserAPI()
	{
		AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
		jo.Call("init", @static);
		jo.Call("getUserAPI");
	}
}
public class Pvr_ToBService : MonoBehaviour
{
	public Text deviceInfoText;

	private void Awake()
	{
		InitToBService();
	}

	private void Start()
	{
		BindToBService();
	}

	private void OnDestory()
	{
		UnBindToBService();
	}

	private void InitToBService()
	{
		ToBService.UPvr_InitToBService();
		ToBService.UPvr_SetUnityObjectName(base.name);
	}

	private void BindToBService()
	{
		ToBService.UPvr_BindToBService();
	}

	private void UnBindToBService()
	{
		ToBService.UPvr_UnBindToBService();
	}

	private void BoolCallback(string value)
	{
		if (ToBService.BoolCallback != null)
		{
			ToBService.BoolCallback(bool.Parse(value));
		}
		ToBService.BoolCallback = null;
	}

	private void IntCallback(string value)
	{
		if (ToBService.IntCallback != null)
		{
			ToBService.IntCallback(int.Parse(value));
		}
		ToBService.IntCallback = null;
	}

	private void LongCallback(string value)
	{
		if (ToBService.LongCallback != null)
		{
			ToBService.LongCallback(int.Parse(value));
		}
		ToBService.LongCallback = null;
	}

	private void StringCallback(string value)
	{
		if (ToBService.StringCallback != null)
		{
			ToBService.StringCallback(value);
		}
		ToBService.StringCallback = null;
	}

	public void StateGetDeviceInfo()
	{
		string text = ToBService.UPvr_StateGetDeviceInfo(PBS_SystemInfoEnum.PUI_VERSION);
		deviceInfoText.text = "PUI_VERSION:" + text;
	}

	public void ControlSetDeviceAction()
	{
		ToBService.UPvr_ControlSetDeviceAction(PBS_DeviceControlEnum.DEVICE_CONTROL_SHUTDOWN, ControlSetDeviceActionCallBack);
	}

	private void ControlSetDeviceActionCallBack(int value)
	{
		UnityEngine.Debug.Log("ControlSetDeviceActionCallBack : " + value);
	}

	public void AppManager()
	{
		ToBService.UPvr_ControlAPPManger(PBS_PackageControlEnum.PACKAGE_SILENCE_UNINSTALL, "com.pico.ipd.test", AppManagerCallBack);
	}

	private void AppManagerCallBack(int value)
	{
		UnityEngine.Debug.Log("AppManagerCallBack : " + value);
	}
}
public class PLOG : MonoBehaviour
{
	public static int logLevel;

	public static void getConfigTraceLevel()
	{
		Render.UPvr_GetIntConfig(6, ref logLevel);
	}

	public static void D(string msg)
	{
		if (logLevel > 2)
		{
			UnityEngine.Debug.Log(msg);
		}
	}

	public static void I(string msg)
	{
		if (logLevel > 1)
		{
			UnityEngine.Debug.Log(msg);
		}
	}

	public static void W(string msg)
	{
		if (logLevel > 0)
		{
			UnityEngine.Debug.LogWarning(msg);
		}
	}

	public static void E(string msg)
	{
		UnityEngine.Debug.LogError(msg);
	}
}
public class PicoDevice : MonoBehaviour
{
	public enum DeviceType
	{
		HMD,
		LeftController,
		RightController
	}

	public DeviceType deviceType;

	private Vector3 devicePos;

	private Quaternion deviceRot;

	private void Awake()
	{
		if (deviceType == DeviceType.HMD)
		{
			base.gameObject.AddComponent<Camera>();
			GameObject obj = new GameObject();
			obj.name = "LeftEye";
			obj.transform.parent = base.transform;
			obj.AddComponent<Pvr_UnitySDKEye>().eyeSide = Eye.LeftEye;
			GameObject obj2 = new GameObject();
			obj2.name = "RightEye";
			obj2.transform.parent = base.transform;
			obj2.AddComponent<Pvr_UnitySDKEye>().eyeSide = Eye.RightEye;
			GameObject obj3 = new GameObject();
			obj3.name = "BothEye";
			obj3.transform.parent = base.transform;
			obj3.AddComponent<Pvr_UnitySDKEye>().eyeSide = Eye.BothEye;
			base.gameObject.AddComponent<Pvr_UnitySDKEyeManager>();
		}
	}

	private void Update()
	{
		switch (deviceType)
		{
		case DeviceType.HMD:
			devicePos = Pvr_UnitySDKSensor.Instance.HeadPose.Position;
			deviceRot = Pvr_UnitySDKSensor.Instance.HeadPose.Orientation;
			break;
		case DeviceType.LeftController:
			devicePos = Pvr_ControllerManager.controllerlink.Controller0.Position;
			deviceRot = Pvr_ControllerManager.controllerlink.Controller0.Rotation;
			break;
		case DeviceType.RightController:
			devicePos = Pvr_ControllerManager.controllerlink.Controller1.Position;
			deviceRot = Pvr_ControllerManager.controllerlink.Controller1.Rotation;
			break;
		}
		base.transform.localPosition = devicePos;
		base.transform.localRotation = deviceRot;
	}
}
public class CPicoSDKSettingAsset : ScriptableObject
{
	public bool IgnoreSDKSetting;

	public bool DontshowBuildWaring;

	public bool AppIDChecked;
}
[Serializable]
public class Pvr_UnitySDKProjectSetting : ScriptableObject
{
	public RenderTextureAntiAliasing rtAntiAlising;

	public RenderTextureDepth rtBitDepth;

	public RenderTextureFormat rtFormat;

	public bool usedefaultRenderTexture;

	public Vector2 customRTSize;

	public bool usedefaultfps;

	public int customfps;

	public bool usesinglepass;

	public bool usecontentprotect;

	public static Pvr_UnitySDKProjectSetting GetProjectConfig()
	{
		return Resources.Load<Pvr_UnitySDKProjectSetting>("ProjectSetting");
	}
}
public sealed class Pvr_UnitySDKPlatformSetting : ScriptableObject
{
	public enum simulationType
	{
		Null,
		Invalid,
		Valid
	}

	[SerializeField]
	private bool entitlementchecksimulation;

	[SerializeField]
	private bool startTimeEntitlementCheck;

	[SerializeField]
	public string appID;

	public List<string> deviceSN = new List<string>();

	private static Pvr_UnitySDKPlatformSetting instance;

	public static bool Entitlementchecksimulation
	{
		get
		{
			return Instance.entitlementchecksimulation;
		}
		set
		{
			if (Instance.entitlementchecksimulation != value)
			{
				Instance.entitlementchecksimulation = value;
			}
		}
	}

	public static bool StartTimeEntitlementCheck
	{
		get
		{
			return Instance.startTimeEntitlementCheck;
		}
		set
		{
			if (Instance.startTimeEntitlementCheck != value)
			{
				Instance.startTimeEntitlementCheck = value;
			}
		}
	}

	public static Pvr_UnitySDKPlatformSetting Instance
	{
		get
		{
			if (instance == null)
			{
				instance = Resources.Load<Pvr_UnitySDKPlatformSetting>("PlatformSettings");
			}
			return instance;
		}
		set
		{
			instance = value;
		}
	}
}
public class Pvr_UnitySDKManager : MonoBehaviour
{
	public delegate void EntitlementCheckResult(int ReturnValue);

	public static PlatForm platform;

	private static Pvr_UnitySDKManager sdk;

	[HideInInspector]
	public float EyesAspect = 1f;

	[HideInInspector]
	public int posStatus;

	[HideInInspector]
	public bool ismirroring;

	[HideInInspector]
	public Vector3 resetBasePos;

	[HideInInspector]
	public int trackingmode = -1;

	[HideInInspector]
	public int systemprop = -1;

	[HideInInspector]
	public bool systemFPS;

	[HideInInspector]
	public float[] headData = new float[7];

	[SerializeField]
	private bool rotfoldout;

	[SerializeField]
	private bool hmdOnlyrot;

	[SerializeField]
	private bool controllerOnlyrot;

	[SerializeField]
	private TrackingOrigin trackingOrigin;

	public bool ResetTrackerOnLoad;

	[HideInInspector]
	public Vector3 leftEyeOffset;

	[HideInInspector]
	public Vector3 rightEyeOffset;

	[HideInInspector]
	public Rect leftEyeRect;

	[HideInInspector]
	public Rect rightEyeRect;

	[HideInInspector]
	public Matrix4x4 leftEyeView;

	[HideInInspector]
	public Matrix4x4 rightEyeView;

	[HideInInspector]
	public Pvr_UnitySDKEditor pvr_UnitySDKEditor;

	[SerializeField]
	private bool vrModeEnabled = true;

	[HideInInspector]
	public Material Eyematerial;

	[HideInInspector]
	public Material Middlematerial;

	[HideInInspector]
	public bool newPicovrTriggered;

	[SerializeField]
	private bool showFPS;

	[HideInInspector]
	public Vector3 neckOffset = new Vector3(0f, 0.075f, 0.0805f);

	[SerializeField]
	private bool pVRNeck = true;

	[HideInInspector]
	public bool UseCustomNeckPara;

	[HideInInspector]
	public bool onResume;

	[HideInInspector]
	public bool isEnterVRMode;

	public bool isHasController;

	public Pvr_UnitySDKConfigProfile pvr_UnitySDKConfig;

	private GameObject calltoast;

	private GameObject msgtoast;

	private GameObject lowhmdBatterytoast;

	private GameObject lowphoneBatterytoast;

	private GameObject LowPhoneHealthtoast;

	private GameObject LowcontrollerBatterytoast;

	private bool lowControllerpowerstate;

	private float controllerpowershowtime;

	private bool UseToast = true;

	private int iPhoneHMDModeEnabled;

	private GameObject G3LiteTips;

	[SerializeField]
	private bool monoscopic;

	private bool mIsAndroid7;

	public static Func<bool> eventEnterVRMode;

	[HideInInspector]
	public bool ShowVideoSeethrough;

	public int SystemDebugFFRLevel = -1;

	public int SystemFFRLevel = -1;

	public int AppCheckResult = 100;

	public SystemDisplayFrequency displayFrequency;

	public Action<float> DisplayRefreshRateChanged;

	public Action longPressHomeKeyAction;

	public static Pvr_UnitySDKManager SDK
	{
		get
		{
			if (sdk == null)
			{
				sdk = UnityEngine.Object.FindObjectOfType<Pvr_UnitySDKManager>();
			}
			return sdk;
		}
	}

	public bool Rotfoldout
	{
		get
		{
			return rotfoldout;
		}
		set
		{
			if (value != rotfoldout)
			{
				rotfoldout = value;
			}
		}
	}

	public bool HmdOnlyrot
	{
		get
		{
			return hmdOnlyrot;
		}
		set
		{
			if (value != hmdOnlyrot)
			{
				hmdOnlyrot = value;
			}
		}
	}

	public bool ControllerOnlyrot
	{
		get
		{
			return controllerOnlyrot;
		}
		set
		{
			if (value != controllerOnlyrot)
			{
				controllerOnlyrot = value;
			}
		}
	}

	public TrackingOrigin TrackingOrigin
	{
		get
		{
			return trackingOrigin;
		}
		set
		{
			if (value != trackingOrigin)
			{
				trackingOrigin = value;
				Sensor.UPvr_SetTrackingOriginType(value);
			}
		}
	}

	[HideInInspector]
	public bool VRModeEnabled
	{
		get
		{
			return vrModeEnabled;
		}
		set
		{
			if (value != vrModeEnabled)
			{
				vrModeEnabled = value;
			}
		}
	}

	[HideInInspector]
	public bool picovrTriggered { get; set; }

	public bool ShowFPS
	{
		get
		{
			return showFPS;
		}
		set
		{
			if (value != showFPS)
			{
				showFPS = value;
			}
		}
	}

	public bool PVRNeck
	{
		get
		{
			return pVRNeck;
		}
		set
		{
			if (value != pVRNeck)
			{
				pVRNeck = value;
			}
		}
	}

	[HideInInspector]
	public bool Monoscopic
	{
		get
		{
			return monoscopic;
		}
		set
		{
			if (value != monoscopic)
			{
				monoscopic = value;
				Render.UPvr_SetMonoMode(monoscopic);
			}
		}
	}

	public static event EntitlementCheckResult EntitlementCheckResultEvent;

	public void ChangeDefaultCustomRtSize(int w, int h)
	{
		Pvr_UnitySDKProjectSetting.GetProjectConfig().customRTSize = new Vector2(w, h);
	}

	public Vector3 EyeOffset(Eye eye)
	{
		if (eye != 0)
		{
			return rightEyeOffset;
		}
		return leftEyeOffset;
	}

	public Rect EyeRect(Eye eye)
	{
		if (eye != 0)
		{
			return rightEyeRect;
		}
		return leftEyeRect;
	}

	private bool SDKManagerInit()
	{
		if (SDKManagerInitConfigProfile())
		{
			mIsAndroid7 = SystemInfo.operatingSystem.Contains("Android OS 7.");
			PLOG.I("Android 7 = " + mIsAndroid7);
			if (SDKManagerInitCoreAbility())
			{
				return true;
			}
			return false;
		}
		return false;
	}

	private bool SDKManagerInitCoreAbility()
	{
		Sensor.UPvr_SetTrackingOriginType(trackingOrigin);
		Render.UPvr_SetMonoMode(monoscopic);
		if (Pvr_UnitySDKRender.Instance == null)
		{
			PLOG.I("pvr_UnitySDKRender init failed");
		}
		if (Pvr_UnitySDKSensor.Instance == null)
		{
			PLOG.I("pvr_UnitySDKSensor init failed");
		}
		Pvr_UnitySDKAPI.System.UPvr_StartHomeKeyReceiver(base.gameObject.name);
		return true;
	}

	public void smsReceivedCallback(string msg)
	{
		PLOG.I("PvrLog MSG" + msg);
		LitJson.JsonData jsonData = LitJson.JsonMapper.ToObject(msg);
		string text = "";
		if (msg.Contains("messageSender"))
		{
			text = (string)jsonData["messageSender"];
		}
		string text2 = "";
		if (msg.Contains("messageAdr"))
		{
			text2 = (string)jsonData["messageAdr"];
			if (text2.Substring(0, 3) == "+82")
			{
				text2 = "0" + text2.Remove(0, 3);
				text2 = TransformNumber(text2);
			}
			else if (text2.Substring(0, 1) != "+")
			{
				text2 = TransformNumber(text2);
			}
		}
		if (UseToast)
		{
			msgtoast.transform.Find("number").GetComponent<Text>().text = text2;
			msgtoast.transform.Find("name").GetComponent<Text>().text = text;
			if (text.Length == 0)
			{
				msgtoast.transform.Find("number").transform.localPosition = new Vector3(0f, 0f, 0f);
			}
			else
			{
				msgtoast.transform.Find("number").transform.localPosition = new Vector3(60f, 0f, 0f);
			}
			StartCoroutine(ToastManager(2, state: true, 0f));
			StartCoroutine(ToastManager(2, state: false, 5f));
		}
	}

	public void phoneStateCallback(string state)
	{
		PLOG.I("PvrLog phone" + state);
		LitJson.JsonData jsonData = LitJson.JsonMapper.ToObject(state);
		string text = "";
		if (state.Contains("phoneNumber"))
		{
			text = (string)jsonData["phoneNumber"];
			if (text.Substring(0, 3) == "+82")
			{
				text = "0" + text.Remove(0, 3);
				text = TransformNumber(text);
			}
			else if (text.Substring(0, 1) != "+")
			{
				text = TransformNumber(text);
			}
		}
		string text2 = "";
		if (state.Contains("contactName"))
		{
			text2 = (string)jsonData["contactName"];
		}
		if (UseToast)
		{
			calltoast.transform.Find("number").GetComponent<Text>().text = text;
			calltoast.transform.Find("name").GetComponent<Text>().text = text2;
			if (text2.Length == 0)
			{
				calltoast.transform.Find("number").transform.localPosition = new Vector3(0f, 0f, 0f);
			}
			else
			{
				calltoast.transform.Find("number").transform.localPosition = new Vector3(60f, 0f, 0f);
			}
			StartCoroutine(ToastManager(1, state: true, 0f));
			StartCoroutine(ToastManager(1, state: false, 5f));
		}
	}

	public void phoneBatteryStateCallback(string state)
	{
		PLOG.I("PvrLog phoneBatteryState" + state);
		LitJson.JsonData jsonData = LitJson.JsonMapper.ToObject(state);
		string value = "";
		if (state.Contains("phoneBatteryLevel"))
		{
			value = (string)jsonData["phoneBatteryLevel"];
		}
		string value2 = "";
		if (state.Contains("phoneBatteryHealth"))
		{
			value2 = (string)jsonData["phoneBatteryHealth"];
		}
		if (!UseToast)
		{
			return;
		}
		if (Convert.ToInt16(value) <= 5)
		{
			if (!lowhmdBatterytoast.activeSelf)
			{
				StartCoroutine(ToastManager(4, state: true, 0f));
				StartCoroutine(ToastManager(4, state: false, 3f));
			}
			else
			{
				StartCoroutine(ToastManager(4, state: true, 5f));
				StartCoroutine(ToastManager(4, state: false, 8f));
			}
		}
		if (Convert.ToInt16(value2) == 3)
		{
			StartCoroutine(ToastManager(5, state: true, 0f));
			StartCoroutine(ToastManager(5, state: false, 5f));
		}
	}

	public void hmdLowBatteryCallback(string level)
	{
		PLOG.I("PvrLog hmdLowBatteryCallback" + level);
		if (UseToast)
		{
			if (!lowphoneBatterytoast.activeSelf)
			{
				StartCoroutine(ToastManager(3, state: true, 0f));
				StartCoroutine(ToastManager(3, state: false, 3f));
			}
			else
			{
				StartCoroutine(ToastManager(3, state: true, 5f));
				StartCoroutine(ToastManager(3, state: false, 8f));
			}
		}
	}

	private string TransformNumber(string number)
	{
		if (number.Length == 11)
		{
			string text = number.Substring(0, 3);
			string text2 = number.Substring(3, 4);
			string text3 = number.Substring(7, 4);
			number = text + "-" + text2 + "-" + text3;
		}
		else if (number.Length == 10)
		{
			if (number.Substring(1, 1) == "1")
			{
				string text4 = number.Substring(0, 3);
				string text5 = number.Substring(3, 3);
				string text6 = number.Substring(6, 4);
				number = text4 + "-" + text5 + "-" + text6;
			}
			else
			{
				string text7 = number.Substring(0, 2);
				string text8 = number.Substring(2, 4);
				string text9 = number.Substring(6, 4);
				number = text7 + "-" + text8 + "-" + text9;
			}
		}
		else if (number.Length == 9)
		{
			if (number.Substring(1, 1) == "2")
			{
				string text10 = number.Substring(0, 2);
				string text11 = number.Substring(2, 3);
				string text12 = number.Substring(5, 4);
				number = text10 + "-" + text11 + "-" + text12;
			}
			else
			{
				number = "+82" + number.Remove(0, 1);
			}
		}
		return number;
	}

	public void onHmdOrientationReseted()
	{
	}

	private IEnumerator ToastManager(int type, bool state, float time)
	{
		yield return new WaitForSeconds(time);
		switch (type)
		{
		case 1:
			calltoast.SetActive(state);
			break;
		case 2:
			msgtoast.SetActive(state);
			break;
		case 3:
			lowhmdBatterytoast.SetActive(state);
			break;
		case 4:
			lowphoneBatterytoast.SetActive(state);
			break;
		case 5:
			LowPhoneHealthtoast.SetActive(state);
			break;
		case 6:
			LowcontrollerBatterytoast.SetActive(state);
			break;
		}
	}

	private void CheckControllerStateForG2(string state)
	{
		if (iPhoneHMDModeEnabled == 1 && Convert.ToBoolean(Convert.ToInt16(state)) && Controller.UPvr_GetControllerPower(0) == 0 && Pvr_ControllerManager.controllerlink.Controller0.Rotation.eulerAngles != Vector3.zero)
		{
			StartCoroutine(ToastManager(6, state: true, 0f));
			StartCoroutine(ToastManager(6, state: false, 3f));
		}
	}

	public void notificationCallback(string data)
	{
		LitJson.JsonData jsonData = LitJson.JsonMapper.ToObject(data);
		if (G3LiteTips == null)
		{
			G3LiteTips = UnityEngine.Object.Instantiate(Resources.Load("Prefabs/G3LiteTips") as GameObject, base.transform.Find("Head"), worldPositionStays: false);
		}
		LitJson.JsonData jsonData2 = LitJson.JsonMapper.ToObject(jsonData["str"].ToString());
		switch ((int)jsonData["type"])
		{
		case 0:
			SetProperty(0, jsonData2, "Sms");
			break;
		case 1:
			SetProperty(1, jsonData2, "Call");
			break;
		case 2:
			SetProperty(2, jsonData2, "Warnning");
			break;
		case 3:
			SetProperty(3, jsonData2, "Warnning");
			break;
		case 4:
			SetProperty(4, jsonData2, "Warnning");
			break;
		case 5:
		{
			Transform transform = G3LiteTips.transform.Find("Onlyimage");
			SetBaseProperty(transform, jsonData2["General"], "");
			SetImageProperty(transform, jsonData2["General"], "");
			transform.gameObject.SetActive(value: true);
			StartCoroutine(G3TipsManager(transform.gameObject, (int)jsonData2["General"]["time"]));
			break;
		}
		case -1:
			break;
		}
	}

	private Sprite LoadSprite(Vector2 size, string filepath)
	{
		int width = (int)size.x;
		int height = (int)size.y;
		Texture2D texture2D = new Texture2D(width, height);
		texture2D.LoadImage(ReadTex(filepath));
		return Sprite.Create(texture2D, new Rect(0f, 0f, texture2D.width, texture2D.height), new Vector2(0.5f, 0.5f));
	}

	private byte[] ReadTex(string path)
	{
		if (path == "")
		{
			return new byte[0];
		}
		FileStream fileStream = new FileStream(path, FileMode.Open, FileAccess.Read);
		fileStream.Seek(0L, SeekOrigin.Begin);
		byte[] array = new byte[fileStream.Length];
		fileStream.Read(array, 0, (int)fileStream.Length);
		fileStream.Close();
		fileStream.Dispose();
		fileStream = null;
		return array;
	}

	private void SetProperty(int type, LitJson.JsonData data, string value)
	{
		Transform trans = G3LiteTips.transform.Find(value);
		SetBaseProperty(trans, data, "");
		SetImageProperty(trans, data, "");
		trans.gameObject.SetActive(value: true);
		StartCoroutine(G3TipsManager(trans.gameObject, (int)data["time"]));
		Transform transform = trans.transform.Find("icon");
		SetBaseProperty(transform, data, "icon_");
		SetImageProperty(transform, data, "icon_");
		Transform transform2 = trans.transform.Find("title");
		SetBaseProperty(transform2, data, "title_");
		SetTextProperty(transform2, data, "title_");
		if (type != 1)
		{
			Transform transform3 = trans.transform.Find("details");
			SetBaseProperty(transform3, data, "details_");
			SetTextProperty(transform3, data, "details_");
			Transform transform4 = trans.transform.Find("image1");
			SetBaseProperty(transform4, data, "image1_");
			SetImageProperty(transform4, data, "image1_");
		}
		if (type == 0 || type == 1)
		{
			Transform transform5 = trans.transform.Find("explain");
			SetBaseProperty(transform5, data, "explain_");
			SetTextProperty(transform5, data, "explain_");
			Transform transform6 = trans.transform.Find("source");
			SetBaseProperty(transform6, data, "source_");
			SetTextProperty(transform6, data, "source_");
		}
		if (type == 0)
		{
			Transform transform7 = trans.transform.Find("time");
			SetBaseProperty(transform7, data, "system_time_");
			SetTextProperty(transform7, data, "system_time_");
		}
		Transform transform8 = trans.transform.Find("Button");
		SetBaseProperty(transform8, data, "button_");
		SetImageProperty(transform8, data, "button_");
		transform8.GetComponent<Button>().onClick.AddListener(delegate
		{
			StartCoroutine(G3TipsManager(trans.gameObject, 0f));
		});
		Transform transform9 = transform8.transform.Find("Text");
		SetBaseProperty(transform9, data, "button_text_");
		SetTextProperty(transform9, data, "button_text_");
	}

	private void SetBaseProperty(Transform trans, LitJson.JsonData data, string value)
	{
		string prop_name = value + "pos";
		string prop_name2 = value + "angles";
		string prop_name3 = value + "size";
		string prop_name4 = value + "scale";
		trans.GetComponent<RectTransform>().anchoredPosition3D = new Vector3(JsonToFloat(data[prop_name][0]), JsonToFloat(data[prop_name][1]), JsonToFloat(data[prop_name][2]));
		trans.GetComponent<RectTransform>().eulerAngles = new Vector3(JsonToFloat(data[prop_name2][0]), JsonToFloat(data[prop_name2][1]), JsonToFloat(data[prop_name2][2]));
		trans.GetComponent<RectTransform>().sizeDelta = new Vector2(JsonToFloat(data[prop_name3][0]), JsonToFloat(data[prop_name3][1]));
		trans.GetComponent<RectTransform>().localScale = new Vector3(JsonToFloat(data[prop_name4][0]), JsonToFloat(data[prop_name4][1]), JsonToFloat(data[prop_name4][2]));
	}

	private void SetImageProperty(Transform image, LitJson.JsonData data, string value)
	{
		string prop_name = value + "sprite";
		string prop_name2 = value + "color";
		string prop_name3 = value + "size";
		image.GetComponent<Image>().sprite = LoadSprite(new Vector2(JsonToFloat(data[prop_name3][0]), JsonToFloat(data[prop_name3][1])), (string)data[prop_name]);
		image.GetComponent<Image>().color = new Color(JsonToFloat(data[prop_name2][0]), JsonToFloat(data[prop_name2][1]), JsonToFloat(data[prop_name2][2]), JsonToFloat(data[prop_name2][3]));
	}

	private void SetTextProperty(Transform text, LitJson.JsonData data, string value)
	{
		string prop_name = value + "color";
		string prop_name2 = value + "font_size";
		string prop_name3 = value + "font_style";
		string prop_name4 = value + "text";
		text.GetComponent<Text>().text = (string)data[prop_name4];
		text.GetComponent<Text>().color = new Color(JsonToFloat(data[prop_name][0]), JsonToFloat(data[prop_name][1]), JsonToFloat(data[prop_name][2]), JsonToFloat(data[prop_name][3]));
		text.GetComponent<Text>().fontSize = (int)data[prop_name2];
		text.GetComponent<Text>().fontStyle = (FontStyle)(int)data[prop_name3];
	}

	private IEnumerator G3TipsManager(GameObject tip, float time)
	{
		yield return new WaitForSeconds(time);
		tip.SetActive(value: false);
	}

	private float JsonToFloat(LitJson.JsonData data)
	{
		return Convert.ToSingle((string)data);
	}

	private bool SDKManagerInitFPS()
	{
		Transform[] componentsInChildren = GetComponentsInChildren<Transform>(includeInactive: true);
		GameObject gameObject = null;
		Transform[] array = componentsInChildren;
		foreach (Transform transform in array)
		{
			if (transform.gameObject.name == "FPS")
			{
				gameObject = transform.gameObject;
			}
		}
		if (gameObject != null)
		{
			if (systemFPS)
			{
				gameObject.SetActive(value: true);
				return true;
			}
			int res = 0;
			Render.UPvr_GetIntConfig(10, ref res);
			if (Convert.ToBoolean(res))
			{
				gameObject.SetActive(value: true);
				return true;
			}
			if (ShowFPS)
			{
				gameObject.SetActive(value: true);
				return true;
			}
			return false;
		}
		return false;
	}

	private bool SDKManagerInitConfigProfile()
	{
		pvr_UnitySDKConfig = Pvr_UnitySDKConfigProfile.Default;
		return true;
	}

	private bool SDKManagerInitEditor()
	{
		if (pvr_UnitySDKEditor == null)
		{
			pvr_UnitySDKEditor = base.gameObject.AddComponent<Pvr_UnitySDKEditor>();
		}
		else
		{
			pvr_UnitySDKEditor = null;
			pvr_UnitySDKEditor = base.gameObject.AddComponent<Pvr_UnitySDKEditor>();
		}
		return true;
	}

	private bool SDKManagerInitPara()
	{
		return true;
	}

	public void SDKManagerLongHomeKey()
	{
		if (Pvr_UnitySDKSensor.Instance == null)
		{
			return;
		}
		if (isHasController)
		{
			if (Controller.UPvr_GetControllerState(0) == ControllerState.Connected || Controller.UPvr_GetControllerState(1) == ControllerState.Connected)
			{
				Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(0, 1);
			}
			else
			{
				Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 1);
			}
		}
		else
		{
			Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 1);
		}
	}

	private void setLongHomeKey()
	{
		if (sdk.HmdOnlyrot)
		{
			if (Pvr_UnitySDKSensor.Instance != null)
			{
				PLOG.I(Pvr_UnitySDKSensor.Instance.ResetUnitySDKSensor() ? "Long Home Key to Reset Sensor Success!" : "Long Home Key to Reset Sensor Failed!");
			}
			return;
		}
		if (trackingmode == 4 || trackingmode == 5 || trackingmode == 6)
		{
			Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 1);
		}
		else
		{
			if (trackingmode == 2 || trackingmode == 3)
			{
				if (isHasController && (Controller.UPvr_GetControllerState(0) == ControllerState.Connected || Controller.UPvr_GetControllerState(1) == ControllerState.Connected))
				{
					Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(0, 1);
				}
				else
				{
					Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 1);
				}
			}
			if (trackingmode == 0 || trackingmode == 1)
			{
				Pvr_UnitySDKSensor.Instance.ResetUnitySDKSensor();
			}
		}
		if (longPressHomeKeyAction != null)
		{
			longPressHomeKeyAction();
		}
	}

	public void verifyAPPCallback(string code)
	{
		UnityEngine.Debug.Log("PvrLog verifyAPPCallback" + code);
		AppCheckResult = Convert.ToInt32(code);
		if (Pvr_UnitySDKManager.EntitlementCheckResultEvent != null)
		{
			Pvr_UnitySDKManager.EntitlementCheckResultEvent(AppCheckResult);
		}
	}

	public void IpdRefreshCallBack(string ipd)
	{
		UnityEngine.Debug.Log("PvrLog IpdRefreshCallBack");
		Pvr_UnitySDKEye[] eyes = Pvr_UnitySDKEyeManager.Instance.Eyes;
		for (int i = 0; i < eyes.Length; i++)
		{
			eyes[i].RefreshCameraPosition(Convert.ToSingle(ipd));
		}
	}

	public void DisplayRefreshRateCallBack(string rate)
	{
		UnityEngine.Debug.Log("PvrLog DisplayRefreshRateCallBack" + rate);
		if (DisplayRefreshRateChanged != null)
		{
			DisplayRefreshRateChanged(Convert.ToSingle(rate));
		}
	}

	private void Awake()
	{
		UnityEngine.Debug.Log("DISFT Unity Version:" + Application.unityVersion);
		UnityEngine.Debug.Log("DISFT Customize NeckOffset:" + neckOffset);
		UnityEngine.Debug.Log("DISFT MSAA :" + Pvr_UnitySDKProjectSetting.GetProjectConfig().rtAntiAlising);
		if (GraphicsSettings.renderPipelineAsset != null)
		{
			UnityEngine.Debug.Log("DISFT LWRP = Enable");
		}
		UnityEngine.Debug.Log("DISFT Content Proctect :" + Pvr_UnitySDKProjectSetting.GetProjectConfig().usecontentprotect);
		int res = 0;
		LoadIsMirroringValue();
		if (!ismirroring)
		{
			Render.UPvr_GetIntConfig(18, ref res);
			if (res == 1)
			{
				UnityEngine.Debug.Log("DISFT ScreenOrientation.Portrait = Enable");
				Screen.orientation = ScreenOrientation.Portrait;
			}
		}
		else
		{
			Render.UPvr_GetIntConfig(19, ref res);
			Screen.orientation = ((res == 0) ? ScreenOrientation.Portrait : ScreenOrientation.LandscapeLeft);
		}
		new AndroidJavaClass("com.psmart.vrlib.VrActivity");
		new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
		Pvr_ControllerManager pvr_ControllerManager = UnityEngine.Object.FindObjectOfType<Pvr_ControllerManager>();
		isHasController = pvr_ControllerManager != null;
		PLOG.getConfigTraceLevel();
		Render.UPvr_GetIntConfig(5, ref trackingmode);
		Application.targetFrameRate = 61;
		int res2 = 0;
		Render.UPvr_GetIntConfig(3, ref res2);
		if (res2 == 0)
		{
			SDK.HmdOnlyrot = true;
		}
		int res3 = -1;
		Render.UPvr_GetIntConfig(9, ref res3);
		float res4 = 0f;
		Render.UPvr_GetFloatConfig(6, ref res4);
		Application.targetFrameRate = ((res3 > 0) ? res3 : ((int)res4));
		if (!Pvr_UnitySDKProjectSetting.GetProjectConfig().usedefaultfps)
		{
			if ((float)Pvr_UnitySDKProjectSetting.GetProjectConfig().customfps <= res4)
			{
				Application.targetFrameRate = Pvr_UnitySDKProjectSetting.GetProjectConfig().customfps;
			}
			else
			{
				Application.targetFrameRate = (int)res4;
			}
		}
		UnityEngine.Debug.Log("DISFT Customize FPS :" + Application.targetFrameRate);
		if (!UseCustomNeckPara)
		{
			float res5 = 0f;
			float res6 = 0f;
			float res7 = 0f;
			int configsenum = 4;
			int configsenum2 = 5;
			Render.UPvr_GetFloatConfig(3, ref res5);
			Render.UPvr_GetFloatConfig(configsenum, ref res6);
			Render.UPvr_GetFloatConfig(configsenum2, ref res7);
			if (res5 != 0f || res6 != 0f || res7 != 0f)
			{
				neckOffset = new Vector3(res5, res6, res7);
			}
		}
		Render.UPvr_GetIntConfig(16, ref iPhoneHMDModeEnabled);
		Pvr_ControllerManager.ControllerStatusChangeEvent += CheckControllerStateForG2;
		InitUI();
		RefreshTextByLanguage();
	}

	private IEnumerator Start()
	{
		if (SDKManagerInit())
		{
			PLOG.I("SDK Init success.");
		}
		else
		{
			PLOG.E("SDK Init Failed.");
			Application.Quit();
		}
		if (Pvr_UnitySDKRender.Instance != null)
		{
			Pvr_UnitySDKRender.Instance.ReInit();
		}
		SDKManagerInitFPS();
		if (Pvr_UnitySDKPlatformSetting.StartTimeEntitlementCheck)
		{
			if (PlatformSettings.UPvr_IsCurrentDeviceValid() != Pvr_UnitySDKPlatformSetting.simulationType.Valid)
			{
				UnityEngine.Debug.Log("DISFT Entitlement Check Simulation DO NOT PASS");
				string appID = Pvr_UnitySDKPlatformSetting.Instance.appID;
				UnityEngine.Debug.Log("DISFT Start-time Entitlement Check Enable");
				PLOG.I("DISFT Start-time Entitlement Check APPID :" + appID);
				PlatformSettings.UPvr_AppEntitlementCheckExtra(appID);
			}
			else
			{
				UnityEngine.Debug.Log("DISFT Entitlement Check Simulation PASS");
			}
		}
		yield return StartCoroutine(InitRenderThreadRoutine());
	}

	private IEnumerator InitRenderThreadRoutine()
	{
		PLOG.I("InitRenderThreadRoutine begin");
		int i = 0;
		while (i < 2)
		{
			yield return null;
			int num = i + 1;
			i = num;
		}
		UnityEngine.Debug.Log("InitRenderThreadRoutine after a wait");
		if (Pvr_UnitySDKRender.Instance != null)
		{
			Pvr_UnitySDKRender.Instance.IssueRenderThread();
		}
		else
		{
			UnityEngine.Debug.Log("InitRenderThreadRoutine pvr_UnitySDKRender == null");
		}
		UnityEngine.Debug.Log("InitRenderThreadRoutine end");
	}

	private void Update()
	{
		if (isHasController && iPhoneHMDModeEnabled == 1 && Controller.UPvr_GetControllerPower(0) == 0 && Pvr_ControllerManager.controllerlink.controller0Connected && Pvr_ControllerManager.controllerlink.Controller0.Rotation.eulerAngles != Vector3.zero)
		{
			if (!lowControllerpowerstate)
			{
				StartCoroutine(ToastManager(6, state: true, 0f));
				StartCoroutine(ToastManager(6, state: false, 3f));
				lowControllerpowerstate = true;
			}
			controllerpowershowtime += Time.deltaTime;
			if (controllerpowershowtime >= 3600f)
			{
				lowControllerpowerstate = false;
				controllerpowershowtime = 0f;
			}
		}
		if (Input.touchCount == 1 && Input.touches[0].phase == TouchPhase.Began)
		{
			newPicovrTriggered = true;
		}
		if (Input.GetKeyDown(KeyCode.JoystickButton0))
		{
			newPicovrTriggered = true;
		}
		if (Pvr_UnitySDKSensor.Instance != null)
		{
			Pvr_UnitySDKSensor.Instance.SensorUpdate();
		}
		picovrTriggered = newPicovrTriggered;
		newPicovrTriggered = false;
	}

	private void OnDestroy()
	{
		if (sdk == this)
		{
			sdk = null;
		}
		RenderTexture.active = null;
		Resources.UnloadUnusedAssets();
		GC.Collect();
		Pvr_ControllerManager.ControllerStatusChangeEvent -= CheckControllerStateForG2;
	}

	private void OnEnable()
	{
		if (sdk == null)
		{
			sdk = this;
		}
		else if (sdk != this)
		{
			sdk = this;
		}
	}

	private void OnDisable()
	{
		StopAllCoroutines();
	}

	private void OnPause()
	{
		Pvr_UnitySDKAPI.System.UPvr_StopHomeKeyReceiver();
		LeaveVRMode();
		if (Pvr_UnitySDKSensor.Instance != null)
		{
			Pvr_UnitySDKSensor.Instance.StopUnitySDKSensor();
		}
	}

	private void OnApplicationPause(bool pause)
	{
		bool flag = pause;
		UnityEngine.Debug.Log("OnApplicationPause-------------------------" + (flag ? "true" : "false"));
		if (Pvr_UnitySDKAPI.System.UPvr_IsPicoActivity() && !Pvr_UnitySDKRender.Instance.isShellMode)
		{
			bool flag2 = Pvr_UnitySDKAPI.System.UPvr_GetMainActivityPauseStatus();
			UnityEngine.Debug.Log("OnApplicationPause-------------------------Activity Pause State:" + flag2);
			pause = flag2;
		}
		if (flag == pause)
		{
			if (pause)
			{
				onResume = false;
				OnPause();
			}
			else
			{
				onResume = true;
				GL.InvalidateState();
				StartCoroutine(OnResume());
			}
		}
		else if (pause)
		{
			UnityEngine.Debug.Log("OnApplicationPause-------------------------Activity pause Unity resume");
			GL.InvalidateState();
			StartCoroutine(OnResume());
			onResume = false;
			OnPause();
		}
		else
		{
			UnityEngine.Debug.Log("OnApplicationPause-------------------------Activity resume Unity pause");
			OnPause();
			onResume = true;
			GL.InvalidateState();
			StartCoroutine(OnResume());
		}
	}

	public void EnterVRMode()
	{
		Pvr_UnitySDKPluginEvent.Issue(RenderEventType.Resume);
		isEnterVRMode = true;
		if (eventEnterVRMode != null)
		{
			eventEnterVRMode();
		}
	}

	public void LeaveVRMode()
	{
		Pvr_UnitySDKPluginEvent.Issue(RenderEventType.Pause);
		isEnterVRMode = false;
	}

	public void SixDofForceQuit()
	{
		Application.Quit();
	}

	private void InitUI()
	{
		if (iPhoneHMDModeEnabled == 1)
		{
			Transform transform = UnityEngine.Object.Instantiate(Resources.Load("Prefabs/flamingo2Tips") as GameObject, base.transform.Find("Head"), worldPositionStays: false).transform;
			calltoast = transform.Find("Call").gameObject;
			msgtoast = transform.Find("Msg").gameObject;
			lowhmdBatterytoast = transform.Find("LowHmdBattery").gameObject;
			lowphoneBatterytoast = transform.Find("LowPhoneBattery").gameObject;
			LowPhoneHealthtoast = transform.Find("LowPhoneHealth").gameObject;
			LowcontrollerBatterytoast = transform.Find("LowControllerBattery").gameObject;
		}
	}

	private void RefreshTextByLanguage()
	{
		if (msgtoast != null)
		{
			msgtoast.transform.Find("Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("msgtoast0");
			msgtoast.transform.Find("string").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("msgtoast1");
			calltoast.transform.Find("Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("calltoast0");
			calltoast.transform.Find("Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("calltoast1");
			lowhmdBatterytoast.transform.Find("Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("lowhmdBatterytoast");
			lowphoneBatterytoast.transform.Find("Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("lowphoneBatterytoast");
			LowPhoneHealthtoast.transform.Find("Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("LowPhoneHealthtoast");
			LowcontrollerBatterytoast.transform.Find("Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("LowcontrollerBatterytoast");
		}
	}

	private void LoadIsMirroringValue()
	{
		AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
		AndroidJavaObject androidJavaObject = @static.Call<AndroidJavaObject>("getPackageManager", Array.Empty<object>());
		string text = @static.Call<string>("getPackageName", Array.Empty<object>());
		AndroidJavaObject androidJavaObject2 = androidJavaObject.Call<AndroidJavaObject>("getApplicationInfo", new object[2] { text, 128 }).Get<AndroidJavaObject>("metaData");
		ismirroring = Convert.ToBoolean(androidJavaObject2.Call<int>("getInt", new object[2] { "bypass_presentation", 0 }));
	}

	private IEnumerator OnResume()
	{
		switch (displayFrequency)
		{
		case SystemDisplayFrequency.Default:
			Render.UPvr_SetDisplayFrequency(-1f);
			break;
		case SystemDisplayFrequency.RefreshRate72:
			Render.UPvr_SetDisplayFrequency(72f);
			break;
		case SystemDisplayFrequency.RefreshRate90:
			Render.UPvr_SetDisplayFrequency(90f);
			break;
		default:
			throw new ArgumentOutOfRangeException();
		}
		int ability6dof = 0;
		Render.UPvr_GetIntConfig(3, ref ability6dof);
		RefreshTextByLanguage();
		if (Pvr_UnitySDKSensor.Instance != null)
		{
			Pvr_UnitySDKSensor.Instance.StartUnitySDKSensor();
			int res = -1;
			Render.UPvr_GetIntConfig(8, ref res);
			if (res != 1)
			{
				int res2 = -1;
				Render.UPvr_GetIntConfig(11, ref res2);
				if (res2 != 8)
				{
					Pvr_UnitySDKSensor.Instance.ResetUnitySDKSensor();
				}
			}
		}
		if (Pvr_UnitySDKAPI.System.UPvr_IsPicoActivity())
		{
			PLOG.I("onresume set monoPresentation success ?-------------" + Pvr_UnitySDKAPI.System.UPvr_SetMonoPresentation());
			PLOG.I("onresume presentation existed ?-------------" + Pvr_UnitySDKAPI.System.UPvr_IsPresentationExisted());
		}
		for (int j = 0; j < Pvr_UnitySDKEyeManager.Instance.Eyes.Length; j++)
		{
			Pvr_UnitySDKEyeManager.Instance.Eyes[j].RefreshCameraPosition(Pvr_UnitySDKAPI.System.UPvr_GetIPD());
		}
		int waitNum = 15;
		Render.UPvr_GetIntConfig(20, ref waitNum);
		int resetNum = 10;
		Render.UPvr_GetIntConfig(21, ref resetNum);
		for (int i = 0; i < waitNum; i++)
		{
			if (i == resetNum && ResetTrackerOnLoad && ability6dof == 1)
			{
				UnityEngine.Debug.Log("Reset Tracker OnLoad");
				Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 1);
			}
			yield return null;
		}
		EnterVRMode();
		Pvr_UnitySDKAPI.System.UPvr_StartHomeKeyReceiver(base.gameObject.name);
		Pvr_UnitySDKEye.setLevel = false;
		if (longPressHomeKeyAction != null)
		{
			longPressHomeKeyAction();
		}
		if (Render.UPvr_GetIntSysProc("pvrsist.foveation.level", ref SystemDebugFFRLevel))
		{
			Render.SetFoveatedRenderingLevel((EFoveationLevel)SystemDebugFFRLevel);
			UnityEngine.Debug.Log("DISFT OnResume Get System Debug ffr level is : " + SystemDebugFFRLevel);
		}
		else
		{
			UnityEngine.Debug.Log("DISFT OnResume Get System Debug ffr level Error,ffr level is : " + SystemDebugFFRLevel);
		}
		if (SystemDebugFFRLevel == -1)
		{
			Render.UPvr_GetIntConfig(22, ref SystemFFRLevel);
			if (SystemFFRLevel != -1 && SystemFFRLevel >= (int)Pvr_UnitySDKEyeManager.Instance.FoveationLevel)
			{
				Render.SetFoveatedRenderingLevel((EFoveationLevel)SystemFFRLevel);
				UnityEngine.Debug.Log("DISFT OnResume Get System ffr level is : " + SystemFFRLevel);
			}
		}
	}
}
public class QuitGame : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.Escape))
		{
			Application.Quit();
		}
	}
}
public class Pvr_UnityEyeMask : MonoBehaviour
{
	private class EyeMaskData
	{
		public Eye eyeSide;

		public Camera camera;

		public CommandBuffer cmdBuf;
	}

	private Shader eyeMaskShader;

	private Material eyeMaskMaterial;

	private Mesh eyeMaskMeshLeft;

	private Mesh eyeMaskMeshRight;

	private Mesh eyeMaskMeshBoth;

	private float zDir = -1f;

	private Color eyeMaskColor = Color.black;

	private List<EyeMaskData> cameraDataList = new List<EyeMaskData>();

	private void Awake()
	{
		UnityEngine.Debug.Log("DISFT EyeMask = Enable");
		if (SystemInfo.graphicsDeviceType == GraphicsDeviceType.OpenGLES3 || SystemInfo.graphicsDeviceType == GraphicsDeviceType.OpenGLES2)
		{
			zDir = -1f;
		}
		else if (SystemInfo.usesReversedZBuffer)
		{
			zDir = 1f;
		}
		else
		{
			zDir = 0f;
		}
	}

	private void OnEnable()
	{
		if (eyeMaskShader == null)
		{
			eyeMaskShader = Shader.Find("Pvr_UnitySDK/Pvr_EyeMask");
		}
		if (eyeMaskMaterial == null && eyeMaskShader != null)
		{
			eyeMaskMaterial = new Material(eyeMaskShader);
			eyeMaskMaterial.SetColor("_Color", eyeMaskColor);
		}
		if (eyeMaskMaterial == null)
		{
			base.enabled = false;
			UnityEngine.Debug.LogWarning("EyeMask materil is null or EyeMask shader not found!");
		}
		else
		{
			PrepareCameras();
			Camera.onPreRender = (Camera.CameraCallback)Delegate.Combine(Camera.onPreRender, new Camera.CameraCallback(OnCustomPreRender));
			CreateCommandBuffer();
		}
	}

	private void OnDisable()
	{
		Camera.onPreRender = (Camera.CameraCallback)Delegate.Remove(Camera.onPreRender, new Camera.CameraCallback(OnCustomPreRender));
		foreach (EyeMaskData cameraData in cameraDataList)
		{
			if (cameraData.camera != null && cameraData.cmdBuf != null)
			{
				RemoveCameraCommandBuffer(cameraData);
			}
		}
		CleanEyeMask();
	}

	private void CreateCommandBuffer()
	{
		if (VerifyCommadBuffer())
		{
			return;
		}
		if (eyeMaskMeshLeft == null || eyeMaskMeshRight == null)
		{
			eyeMaskMeshLeft = GetStencilMesh(Eye.LeftEye);
			eyeMaskMeshRight = GetStencilMesh(Eye.RightEye);
			if (eyeMaskMeshLeft == null || eyeMaskMeshRight == null)
			{
				UnityEngine.Debug.LogWarning("Stencil Mesh is not exist, disable EyeMask.");
				base.enabled = false;
				return;
			}
		}
		foreach (EyeMaskData cameraData in cameraDataList)
		{
			if (cameraData.eyeSide == Eye.LeftEye)
			{
				CommandBuffer commandBuffer = new CommandBuffer();
				commandBuffer.name = "EyeMaskLeft";
				commandBuffer.DrawMesh(eyeMaskMeshLeft, Matrix4x4.identity, eyeMaskMaterial, 0, 0);
				cameraData.cmdBuf = commandBuffer;
			}
			else if (cameraData.eyeSide == Eye.RightEye)
			{
				CommandBuffer commandBuffer2 = new CommandBuffer();
				commandBuffer2.name = "EyeMaskRight";
				commandBuffer2.DrawMesh(eyeMaskMeshRight, Matrix4x4.identity, eyeMaskMaterial, 0, 0);
				cameraData.cmdBuf = commandBuffer2;
			}
			else if (cameraData.eyeSide == Eye.BothEye)
			{
				if (eyeMaskMeshBoth == null)
				{
					eyeMaskMeshBoth = GetStencilMeshBoth(eyeMaskMeshLeft, eyeMaskMeshRight);
					float value = Mathf.Max(Mathf.Abs(eyeMaskMeshLeft.bounds.max.x), Mathf.Abs(eyeMaskMeshRight.bounds.min.x));
					eyeMaskMaterial.SetFloat("_MeshOffsetX", value);
				}
				CommandBuffer commandBuffer3 = new CommandBuffer();
				commandBuffer3.name = "EyeMaskBoth";
				commandBuffer3.DrawMesh(eyeMaskMeshBoth, Matrix4x4.identity, eyeMaskMaterial, 0, 1);
				cameraData.cmdBuf = commandBuffer3;
			}
		}
	}

	private void OnCustomPreRender(Camera cam)
	{
		if (!VerifyCommadBuffer())
		{
			UnityEngine.Debug.LogWarning("Verify CommandBuffer failed!");
			return;
		}
		foreach (EyeMaskData cameraData in cameraDataList)
		{
			if (!(cameraData.camera != cam))
			{
				RemoveCameraCommandBuffer(cameraData);
				AddCameraCommandBuffer(cameraData);
			}
		}
	}

	private Mesh GetStencilMesh(Eye eyeSide)
	{
		int vertexCount = 0;
		int triangleCount = 0;
		IntPtr vertexDataPtr = IntPtr.Zero;
		IntPtr indexDataPtr = IntPtr.Zero;
		Render.UPvr_GetStencilMesh((int)eyeSide, ref vertexCount, ref triangleCount, ref vertexDataPtr, ref indexDataPtr);
		if (vertexCount <= 0 || triangleCount <= 0 || vertexDataPtr == IntPtr.Zero || indexDataPtr == IntPtr.Zero)
		{
			return null;
		}
		Vector3[] array = new Vector3[vertexCount];
		int[] array2 = new int[triangleCount * 3];
		float[] array3 = new float[vertexCount * 3];
		int[] array4 = new int[triangleCount * 3];
		Marshal.Copy(vertexDataPtr, array3, 0, vertexCount * 3);
		Marshal.Copy(indexDataPtr, array4, 0, triangleCount * 3);
		for (int i = 0; i < vertexCount; i++)
		{
			array[i] = new Vector3(array3[3 * i], array3[3 * i + 1], zDir);
		}
		for (int j = 0; j < triangleCount; j++)
		{
			array2[3 * j] = array4[3 * j + 2];
			array2[3 * j + 1] = array4[3 * j + 1];
			array2[3 * j + 2] = array4[3 * j];
		}
		Mesh mesh = new Mesh();
		mesh.name = "EyeMaskMesh";
		mesh.vertices = array;
		mesh.SetIndices(array2, MeshTopology.Triangles, 0);
		return mesh;
	}

	private Mesh GetStencilMeshBoth(Mesh leftMesh, Mesh rightMesh)
	{
		float num = Mathf.Max(Mathf.Abs(leftMesh.bounds.max.x), Mathf.Abs(rightMesh.bounds.min.x));
		Mesh mesh = new Mesh();
		mesh.name = "EyeMaskBoth";
		CombineInstance combineInstance = default(CombineInstance);
		combineInstance.mesh = leftMesh;
		Matrix4x4 identity = Matrix4x4.identity;
		identity.SetTRS(Vector3.left * num, Quaternion.identity, Vector3.one);
		combineInstance.transform = identity;
		CombineInstance combineInstance2 = default(CombineInstance);
		combineInstance2.mesh = rightMesh;
		Matrix4x4 identity2 = Matrix4x4.identity;
		identity2.SetTRS(Vector3.right * num, Quaternion.identity, Vector3.one);
		combineInstance2.transform = identity2;
		CombineInstance[] combine = new CombineInstance[2] { combineInstance, combineInstance2 };
		mesh.CombineMeshes(combine);
		return mesh;
	}

	private bool VerifyCommadBuffer()
	{
		if (cameraDataList == null || cameraDataList.Count <= 0)
		{
			return false;
		}
		foreach (EyeMaskData cameraData in cameraDataList)
		{
			if (cameraData == null || cameraData.cmdBuf == null)
			{
				return false;
			}
		}
		return true;
	}

	private void PrepareCameras()
	{
		cameraDataList.Clear();
		if (Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.SinglePass)
		{
			if (Pvr_UnitySDKEyeManager.Instance.BothEyeCamera == null)
			{
				UnityEngine.Debug.LogWarning("BothEye Camera is null!");
				return;
			}
			EyeMaskData eyeMaskData = new EyeMaskData();
			eyeMaskData.eyeSide = Eye.BothEye;
			eyeMaskData.camera = Pvr_UnitySDKEyeManager.Instance.BothEyeCamera;
			cameraDataList.Add(eyeMaskData);
		}
		else if (Pvr_UnitySDKEyeManager.Instance.LeftEyeCamera == null || Pvr_UnitySDKEyeManager.Instance.RightEyeCamera == null)
		{
			UnityEngine.Debug.LogWarning("LeftEye or RightEye Camera is null!");
		}
		else
		{
			EyeMaskData eyeMaskData2 = new EyeMaskData();
			eyeMaskData2.eyeSide = Eye.LeftEye;
			eyeMaskData2.camera = Pvr_UnitySDKEyeManager.Instance.LeftEyeCamera;
			eyeMaskData2.cmdBuf = null;
			cameraDataList.Add(eyeMaskData2);
			EyeMaskData eyeMaskData3 = new EyeMaskData();
			eyeMaskData3.eyeSide = Eye.RightEye;
			eyeMaskData3.camera = Pvr_UnitySDKEyeManager.Instance.RightEyeCamera;
			eyeMaskData3.cmdBuf = null;
			cameraDataList.Add(eyeMaskData3);
		}
	}

	private void AddCameraCommandBuffer(EyeMaskData data)
	{
		data.camera.AddCommandBuffer(CameraEvent.BeforeForwardOpaque, data.cmdBuf);
	}

	private void RemoveCameraCommandBuffer(EyeMaskData data)
	{
		data.camera.RemoveCommandBuffer(CameraEvent.BeforeForwardOpaque, data.cmdBuf);
	}

	private void CleanEyeMask()
	{
		cameraDataList.Clear();
		eyeMaskMeshLeft = null;
		eyeMaskMeshRight = null;
		eyeMaskMeshBoth = null;
		eyeMaskShader = null;
		eyeMaskMaterial = null;
	}
}
[RequireComponent(typeof(Camera))]
public class Pvr_UnitySDKEye : MonoBehaviour
{
	public static List<Pvr_UnitySDKEye> Instances = new List<Pvr_UnitySDKEye>();

	public Eye eyeSide;

	private int eyeCameraOriginCullingMask;

	private CameraClearFlags eyeCameraOriginClearFlag;

	private Color eyeCameraOriginBackgroundColor;

	private int lastBoundaryState;

	private Matrix4x4 realProj = Matrix4x4.identity;

	private const int bufferSize = 3;

	private int IDIndex;

	private RenderEventType eventType;

	private int previousId;

	public static bool setLevel = false;

	private Material mat_Vignette;

	public Camera eyecamera { get; private set; }

	private void Awake()
	{
		Instances.Add(this);
		eyecamera = GetComponent<Camera>();
	}

	private void Start()
	{
		Setup(eyeSide);
		SetupUpdate();
		if (eyecamera != null)
		{
			eyeCameraOriginCullingMask = eyecamera.cullingMask;
			eyeCameraOriginClearFlag = eyecamera.clearFlags;
			eyeCameraOriginBackgroundColor = eyecamera.backgroundColor;
		}
	}

	private void Update()
	{
		if (!(eyecamera != null) || !eyecamera.enabled)
		{
			return;
		}
		int num = BoundarySystem.UPvr_GetSeeThroughState();
		if (num == lastBoundaryState)
		{
			return;
		}
		switch (num)
		{
		case 2:
			eyeCameraOriginCullingMask = eyecamera.cullingMask;
			eyeCameraOriginClearFlag = eyecamera.clearFlags;
			eyeCameraOriginBackgroundColor = eyecamera.backgroundColor;
			eyecamera.cullingMask = 0;
			eyecamera.clearFlags = CameraClearFlags.Color;
			eyecamera.backgroundColor = Color.black;
			break;
		case 1:
			if (lastBoundaryState == 2)
			{
				if (eyecamera.cullingMask == 0)
				{
					eyecamera.cullingMask = eyeCameraOriginCullingMask;
				}
				if (eyecamera.clearFlags == CameraClearFlags.Color)
				{
					eyecamera.clearFlags = eyeCameraOriginClearFlag;
				}
				if (eyecamera.backgroundColor == Color.black)
				{
					eyecamera.backgroundColor = eyeCameraOriginBackgroundColor;
				}
			}
			break;
		default:
			if (lastBoundaryState == 2 || lastBoundaryState == 1)
			{
				if (eyecamera.cullingMask == 0)
				{
					eyecamera.cullingMask = eyeCameraOriginCullingMask;
				}
				if (eyecamera.clearFlags == CameraClearFlags.Color)
				{
					eyecamera.clearFlags = eyeCameraOriginClearFlag;
				}
				if (eyecamera.backgroundColor == Color.black)
				{
					eyecamera.backgroundColor = eyeCameraOriginBackgroundColor;
				}
			}
			break;
		}
		lastBoundaryState = num;
	}

	private void OnEnable()
	{
		if (GraphicsSettings.renderPipelineAsset != null)
		{
			RenderPipeline.beginCameraRendering += MyPreRender;
		}
	}

	private void OnDisable()
	{
		if (GraphicsSettings.renderPipelineAsset != null)
		{
			RenderPipeline.beginCameraRendering -= MyPreRender;
		}
	}

	private void OnDestroy()
	{
		Instances.Remove(this);
	}

	public void MyPreRender(Camera camera)
	{
		if (!(camera.gameObject != base.gameObject))
		{
			OnPreRender();
		}
	}

	public void MyPreRender(ScriptableRenderContext context, Camera camera)
	{
		if (!(camera.gameObject != base.gameObject))
		{
			OnPreRender();
		}
	}

	public void MyPostRender(ScriptableRenderContext context, Camera camera)
	{
		if (!(camera.gameObject != base.gameObject))
		{
			OnPostRender();
		}
	}

	private void OnPreRender()
	{
		if (!eyecamera.enabled)
		{
			return;
		}
		if (Pvr_UnitySDKRender.Instance.StereoRendering != null)
		{
			if (Pvr_UnitySDKRender.Instance.isSwitchSDK)
			{
				return;
			}
			Pvr_UnitySDKRender.Instance.StereoRendering.OnSDKPreRender();
		}
		SetFFRParameter();
		Pvr_UnitySDKPluginEvent.Issue(RenderEventType.BeginEye);
	}

	private void OnPostRender()
	{
		if (!eyecamera.enabled)
		{
			return;
		}
		Pvr_UnitySDKAPI.System.UPvr_UnityEventData(Pvr_UnitySDKAPI.System.UPvr_GetEyeBufferData(Pvr_UnitySDKRender.Instance.eyeTextureIds[IDIndex]));
		Pvr_UnitySDKPluginEvent.Issue(eventType);
		if (Pvr_UnitySDKRender.Instance.StereoRendering != null)
		{
			if (Pvr_UnitySDKRender.Instance.isSwitchSDK)
			{
				return;
			}
			Pvr_UnitySDKRender.Instance.StereoRendering.OnSDKPostRender();
		}
		Pvr_UnitySDKPluginEvent.Issue(RenderEventType.EndEye);
	}

	public void EyeRender()
	{
		SetupUpdate();
		if (Pvr_UnitySDKRender.Instance.eyeTextures[IDIndex] != null)
		{
			Pvr_UnitySDKRender.Instance.eyeTextures[IDIndex].DiscardContents();
			eyecamera.targetTexture = Pvr_UnitySDKRender.Instance.eyeTextures[IDIndex];
		}
	}

	private void Setup(Eye eyeSide)
	{
		eyecamera = GetComponent<Camera>();
		switch (eyeSide)
		{
		case Eye.LeftEye:
		case Eye.RightEye:
			base.transform.localPosition = Pvr_UnitySDKManager.SDK.EyeOffset(eyeSide);
			break;
		case Eye.BothEye:
			base.transform.localPosition = Vector3.zero;
			break;
		}
		eyecamera.aspect = Pvr_UnitySDKManager.SDK.EyesAspect;
		eyecamera.rect = new Rect(0f, 0f, 1f, 1f);
		if (Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.MultiPass)
		{
			eventType = ((eyeSide == Eye.LeftEye) ? RenderEventType.LeftEyeEndFrame : RenderEventType.RightEyeEndFrame);
		}
		else
		{
			eventType = RenderEventType.BothEyeEndFrame;
		}
	}

	private void SetupUpdate()
	{
		if (eyeSide == Eye.LeftEye || eyeSide == Eye.RightEye)
		{
			eyecamera.enabled = !Pvr_UnitySDKManager.SDK.Monoscopic && Pvr_UnitySDKRender.Instance.StereoRenderPath != StereoRenderingPathPico.SinglePass;
		}
		else if (eyeSide == Eye.BothEye)
		{
			eyecamera.enabled = Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.SinglePass;
		}
		eyecamera.fieldOfView = Pvr_UnitySDKRender.Instance.EyeVFoV;
		eyecamera.aspect = Pvr_UnitySDKManager.SDK.EyesAspect;
		if (eyeSide == Eye.LeftEye || eyeSide == Eye.RightEye)
		{
			IDIndex = Pvr_UnitySDKRender.Instance.currEyeTextureIdx + (int)eyeSide * 3;
		}
		else if (eyeSide == Eye.BothEye)
		{
			IDIndex = Pvr_UnitySDKRender.Instance.currEyeTextureIdx;
			Pvr_UnitySDKRender.Instance.isSwitchSDK = Pvr_UnitySDKRender.Instance.lastEyeTextureIdx == Pvr_UnitySDKRender.Instance.currEyeTextureIdx;
			Pvr_UnitySDKRender.Instance.lastEyeTextureIdx = Pvr_UnitySDKRender.Instance.currEyeTextureIdx;
		}
	}

	public void RefreshCameraPosition(float ipd)
	{
		Pvr_UnitySDKManager.SDK.leftEyeOffset = new Vector3((0f - ipd) / 2f, 0f, 0f);
		Pvr_UnitySDKManager.SDK.rightEyeOffset = new Vector3(ipd / 2f, 0f, 0f);
		if (eyeSide == Eye.LeftEye || eyeSide == Eye.RightEye)
		{
			base.transform.localPosition = Pvr_UnitySDKManager.SDK.EyeOffset(eyeSide);
		}
		else if (eyeSide == Eye.BothEye)
		{
			eyecamera.stereoSeparation = ipd;
		}
	}

	private void DrawVignetteLine()
	{
		if (null == mat_Vignette)
		{
			mat_Vignette = new Material(Shader.Find("Diffuse"));
			if (null == mat_Vignette)
			{
				return;
			}
		}
		GL.PushMatrix();
		mat_Vignette.SetPass(0);
		GL.LoadOrtho();
		vignette();
		GL.PopMatrix();
	}

	private void vignette()
	{
		GL.Begin(7);
		GL.Color(Color.black);
		GL.Vertex3(0f, 1f, 0f);
		GL.Vertex3(1f, 1f, 0f);
		GL.Vertex3(1f, 0.995f, 0f);
		GL.Vertex3(0f, 0.995f, 0f);
		GL.Vertex3(0f, 0f, 0f);
		GL.Vertex3(0f, 0.005f, 0f);
		GL.Vertex3(1f, 0.005f, 0f);
		GL.Vertex3(1f, 0f, 0f);
		GL.Vertex(new Vector3(0f, 1f, 0f));
		GL.Vertex(new Vector3(0.005f, 1f, 0f));
		GL.Vertex(new Vector3(0.005f, 0f, 0f));
		GL.Vertex(new Vector3(0f, 0f, 0f));
		GL.Vertex(new Vector3(0.995f, 1f, 0f));
		GL.Vertex(new Vector3(1f, 1f, 0f));
		GL.Vertex(new Vector3(1f, 0f, 0f));
		GL.Vertex(new Vector3(0.995f, 0f, 0f));
		GL.End();
	}

	private void SetFFRParameter()
	{
		Vector3 vector = Vector3.zero;
		if (Pvr_UnitySDKManager.SDK.isEnterVRMode && Pvr_UnitySDKEyeManager.supportEyeTracking && Pvr_UnitySDKEyeManager.Instance.EyeTracking)
		{
			vector = Pvr_UnitySDKAPI.System.UPvr_getEyeTrackingPos();
		}
		int textureId = Pvr_UnitySDKRender.Instance.eyeTextureIds[IDIndex];
		Render.UPvr_SetFoveationResource(textureId, previousId, vector.x, vector.y);
		previousId = textureId;
	}
}
public class Pvr_UnitySDKEyeManager : MonoBehaviour
{
	private static Pvr_UnitySDKEyeManager instance;

	private Pvr_UnitySDKEye[] eyes;

	[HideInInspector]
	public Camera LeftEyeCamera;

	[HideInInspector]
	public Camera RightEyeCamera;

	[HideInInspector]
	public Camera MonoEyeCamera;

	[HideInInspector]
	public Camera BothEyeCamera;

	private int MonoEyeTextureID;

	private readonly int WaitSplashScreenFrames = 3;

	private int frameNum;

	[SerializeField]
	[HideInInspector]
	private bool foveatedRendering;

	[SerializeField]
	[HideInInspector]
	private EFoveationLevel foveationLevel;

	private int eyeTextureId;

	private RenderEventType eventType = RenderEventType.LeftEyeEndFrame;

	private Pvr_UnitySDKEyeOverlay compositeLayer;

	private int overlayLayerDepth = 1;

	private int underlayLayerDepth;

	private bool isHeadLocked;

	private int layerFlags;

	[HideInInspector]
	public bool EyeTracking;

	[HideInInspector]
	public Vector3 eyePoint;

	private EyeTrackingData eyePoseData;

	[HideInInspector]
	public static bool supportEyeTracking;

	[Tooltip("If true, specific color gradient when switching scenes.")]
	public bool screenFade;

	[Tooltip("Define the duration of screen fade.")]
	public float fadeTime = 5f;

	[Tooltip("Define the color of screen fade.")]
	public Color fadeColor = new Color(0f, 0f, 0f, 1f);

	public int renderQueue = 5000;

	private MeshRenderer fadeMeshRenderer;

	private MeshFilter fadeMeshFilter;

	private Material fadeMaterial;

	private float elapsedTime;

	private bool isFading;

	private float currentAlpha;

	private float nowFadeAlpha;

	public static Pvr_UnitySDKEyeManager Instance
	{
		get
		{
			if (instance == null)
			{
				PLOG.E("Pvr_UnitySDKEyeManager instance is not init yet...");
			}
			return instance;
		}
	}

	public Pvr_UnitySDKEye[] Eyes
	{
		get
		{
			if (eyes == null)
			{
				eyes = Pvr_UnitySDKEye.Instances.ToArray();
			}
			return eyes;
		}
	}

	[HideInInspector]
	public bool FoveatedRendering
	{
		get
		{
			return foveatedRendering;
		}
		set
		{
			if (value == foveatedRendering)
			{
				return;
			}
			foveatedRendering = value;
			if (Application.isPlaying)
			{
				Render.UPvr_EnableFoveation(enable: true);
				if (!foveatedRendering)
				{
					Render.SetFoveatedRenderingLevel((EFoveationLevel)(-1));
				}
			}
		}
	}

	[HideInInspector]
	public EFoveationLevel FoveationLevel
	{
		get
		{
			return foveationLevel;
		}
		set
		{
			if (value != foveationLevel)
			{
				foveationLevel = value;
			}
		}
	}

	private void SetCameraEnableEditor()
	{
		MonoEyeCamera.enabled = !Pvr_UnitySDKManager.SDK.VRModeEnabled || Pvr_UnitySDKManager.SDK.Monoscopic;
		for (int i = 0; i < Eyes.Length; i++)
		{
			if (Eyes[i].eyeSide == Eye.LeftEye || Eyes[i].eyeSide == Eye.RightEye)
			{
				Eyes[i].eyecamera.enabled = Pvr_UnitySDKManager.SDK.VRModeEnabled;
			}
			else if (Eyes[i].eyeSide == Eye.BothEye)
			{
				Eyes[i].eyecamera.enabled = false;
			}
		}
	}

	private void SetCamerasEnableByStereoRendering()
	{
		MonoEyeCamera.enabled = Pvr_UnitySDKManager.SDK.Monoscopic && Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.MultiPass;
	}

	private void SetupMonoCamera()
	{
		base.transform.localPosition = Vector3.zero;
		MonoEyeCamera.aspect = Pvr_UnitySDKManager.SDK.EyesAspect;
		MonoEyeCamera.rect = new Rect(0f, 0f, 1f, 1f);
	}

	private void SetupUpdate()
	{
		MonoEyeCamera.fieldOfView = Pvr_UnitySDKRender.Instance.EyeVFoV;
		MonoEyeCamera.aspect = Pvr_UnitySDKManager.SDK.EyesAspect;
		MonoEyeTextureID = Pvr_UnitySDKRender.Instance.currEyeTextureIdx;
	}

	private void MonoEyeRender()
	{
		SetupUpdate();
		if (Pvr_UnitySDKRender.Instance.eyeTextures[MonoEyeTextureID] != null)
		{
			Pvr_UnitySDKRender.Instance.eyeTextures[MonoEyeTextureID].DiscardContents();
			MonoEyeCamera.targetTexture = Pvr_UnitySDKRender.Instance.eyeTextures[MonoEyeTextureID];
		}
	}

	private void Awake()
	{
		if (MonoEyeCamera == null)
		{
			MonoEyeCamera = GetComponent<Camera>();
		}
		if (LeftEyeCamera == null)
		{
			LeftEyeCamera = base.gameObject.transform.Find("LeftEye").GetComponent<Camera>();
		}
		if (RightEyeCamera == null)
		{
			RightEyeCamera = base.gameObject.transform.Find("RightEye").GetComponent<Camera>();
		}
		if (BothEyeCamera == null)
		{
			BothEyeCamera = base.gameObject.transform.Find("BothEye").GetComponent<Camera>();
		}
		if (BothEyeCamera != null)
		{
			BothEyeCamera.transform.GetComponent<Pvr_UnitySDKEye>().eyeSide = Eye.BothEye;
		}
		CreateFadeMesh();
		SetCurrentAlpha(0f);
		Render.UPvr_EnableFoveation(enable: true);
		if (foveatedRendering)
		{
			Render.SetFoveatedRenderingLevel(foveationLevel);
		}
		else
		{
			Render.SetFoveatedRenderingLevel((EFoveationLevel)(-1));
		}
		Pvr_UnitySDKManager.eventEnterVRMode = (Func<bool>)Delegate.Combine(Pvr_UnitySDKManager.eventEnterVRMode, new Func<bool>(SetEyeTrackingMode));
	}

	private void OnEnable()
	{
		if (instance == null)
		{
			instance = this;
		}
		else if (instance != this)
		{
			instance = this;
		}
		if (Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.SinglePass)
		{
			Pvr_UnitySDKRender.Instance.StereoRendering.InitEye(BothEyeCamera);
		}
		foreach (Pvr_UnitySDKEyeOverlay instance in Pvr_UnitySDKEyeOverlay.Instances)
		{
			instance.RefreshCamera();
			if (instance.overlayType == Pvr_UnitySDKEyeOverlay.OverlayType.Overlay)
			{
				if (instance.overlayShape == Pvr_UnitySDKEyeOverlay.OverlayShape.Cylinder)
				{
					UnityEngine.Debug.Log("DISFT Cylinder OverLay = Enable");
				}
				if (instance.overlayShape == Pvr_UnitySDKEyeOverlay.OverlayShape.Equirect)
				{
					UnityEngine.Debug.Log("DISFT 360 OverLay= Enable");
				}
				if (instance.overlayShape == Pvr_UnitySDKEyeOverlay.OverlayShape.Quad)
				{
					UnityEngine.Debug.Log("DISFT 2D OverLay= Enable");
				}
			}
			if (instance.overlayType == Pvr_UnitySDKEyeOverlay.OverlayType.Underlay)
			{
				UnityEngine.Debug.Log("DISFT UnderLay= Enable");
			}
		}
		GfxDeviceAdvanceFrameGLES();
		StartCoroutine("EndOfFrame");
		if (screenFade)
		{
			StartCoroutine(ScreenFade(1f, 0f));
		}
	}

	private void Start()
	{
		SetCamerasEnableByStereoRendering();
		SetupMonoCamera();
	}

	private void Update()
	{
		if (Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.SinglePass)
		{
			for (int i = 0; i < Eyes.Length; i++)
			{
				if (Eyes[i].isActiveAndEnabled && Eyes[i].eyeSide == Eye.BothEye)
				{
					Eyes[i].EyeRender();
				}
			}
		}
		if (Pvr_UnitySDKRender.Instance.StereoRenderPath != 0)
		{
			return;
		}
		if (!Pvr_UnitySDKManager.SDK.Monoscopic)
		{
			for (int j = 0; j < Eyes.Length; j++)
			{
				if (Eyes[j].isActiveAndEnabled && Eyes[j].eyeSide != Eye.BothEye)
				{
					Eyes[j].EyeRender();
				}
			}
		}
		else
		{
			MonoEyeRender();
		}
	}

	private void OnPause()
	{
		Pvr_UnitySDKManager.eventEnterVRMode = (Func<bool>)Delegate.Remove(Pvr_UnitySDKManager.eventEnterVRMode, new Func<bool>(SetEyeTrackingMode));
	}

	public void MyPostRender(ScriptableRenderContext context, Camera camera)
	{
		if (!(camera.gameObject != base.gameObject))
		{
			OnPostRender();
		}
	}

	private void OnDisable()
	{
		StopAllCoroutines();
	}

	private void OnDestroy()
	{
		DestoryFadeMesh();
	}

	private void OnPostRender()
	{
		long data = Pvr_UnitySDKAPI.System.UPvr_GetEyeBufferData(Pvr_UnitySDKRender.Instance.eyeTextureIds[Pvr_UnitySDKRender.Instance.currEyeTextureIdx]);
		Pvr_UnitySDKAPI.System.UPvr_UnityEventData(data);
		Pvr_UnitySDKPluginEvent.Issue(RenderEventType.LeftEyeEndFrame);
		Pvr_UnitySDKAPI.System.UPvr_UnityEventData(data);
		Pvr_UnitySDKPluginEvent.Issue(RenderEventType.RightEyeEndFrame);
	}

	private IEnumerator EndOfFrame()
	{
		while (true)
		{
			yield return new WaitForEndOfFrame();
			if (!Pvr_UnitySDKManager.SDK.isEnterVRMode)
			{
				GL.Clear(clearDepth: false, clearColor: true, Color.black);
			}
			if (Pvr_UnitySDKRender.Instance.isFirstStartup && frameNum == WaitSplashScreenFrames)
			{
				Pvr_UnitySDKAPI.System.UPvr_RemovePlatformLogo();
				if (Pvr_UnitySDKManager.SDK.ResetTrackerOnLoad)
				{
					UnityEngine.Debug.Log("Reset Tracker OnLoad");
					Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 1);
				}
				Pvr_UnitySDKAPI.System.UPvr_StartVRModel();
				Pvr_UnitySDKRender.Instance.isFirstStartup = false;
			}
			else if (Pvr_UnitySDKRender.Instance.isFirstStartup && frameNum < WaitSplashScreenFrames)
			{
				PLOG.I("frameNum:" + frameNum);
				frameNum++;
			}
			if (GraphicsSettings.renderPipelineAsset != null)
			{
				for (int i = 0; i < Eyes.Length; i++)
				{
					if (!Eyes[i].isActiveAndEnabled || !Eyes[i].eyecamera.enabled)
					{
						continue;
					}
					switch (Eyes[i].eyeSide)
					{
					case Eye.LeftEye:
						eyeTextureId = Pvr_UnitySDKRender.Instance.eyeTextureIds[Pvr_UnitySDKRender.Instance.currEyeTextureIdx];
						eventType = RenderEventType.LeftEyeEndFrame;
						break;
					case Eye.RightEye:
						if (!Pvr_UnitySDKManager.SDK.Monoscopic)
						{
							eyeTextureId = Pvr_UnitySDKRender.Instance.eyeTextureIds[Pvr_UnitySDKRender.Instance.currEyeTextureIdx + 3];
						}
						else
						{
							eyeTextureId = Pvr_UnitySDKRender.Instance.eyeTextureIds[Pvr_UnitySDKRender.Instance.currEyeTextureIdx];
						}
						eventType = RenderEventType.RightEyeEndFrame;
						break;
					case Eye.BothEye:
						eyeTextureId = Pvr_UnitySDKRender.Instance.eyeTextureIds[Pvr_UnitySDKRender.Instance.currEyeTextureIdx];
						eventType = RenderEventType.BothEyeEndFrame;
						break;
					}
					Pvr_UnitySDKAPI.System.UPvr_UnityEventData(Pvr_UnitySDKAPI.System.UPvr_GetEyeBufferData(eyeTextureId));
					Pvr_UnitySDKPluginEvent.Issue(eventType);
					Pvr_UnitySDKPluginEvent.Issue(RenderEventType.EndEye);
				}
			}
			int num = BoundarySystem.UPvr_GetSeeThroughState();
			if (Pvr_UnitySDKEyeOverlay.Instances.Count > 0 && num != 2)
			{
				overlayLayerDepth = 1;
				underlayLayerDepth = 0;
				Pvr_UnitySDKEyeOverlay.Instances.Sort();
				for (int j = 0; j < Pvr_UnitySDKEyeOverlay.Instances.Count; j++)
				{
					compositeLayer = Pvr_UnitySDKEyeOverlay.Instances[j];
					if (!compositeLayer.isActiveAndEnabled || (compositeLayer.layerTextures[0] == null && compositeLayer.layerTextures[1] == null && !compositeLayer.isExternalAndroidSurface) || (compositeLayer.layerTransform != null && !compositeLayer.layerTransform.gameObject.activeSelf))
					{
						continue;
					}
					layerFlags = 0;
					if (compositeLayer.overlayShape == Pvr_UnitySDKEyeOverlay.OverlayShape.Quad || compositeLayer.overlayShape == Pvr_UnitySDKEyeOverlay.OverlayShape.Cylinder)
					{
						if (compositeLayer.overlayType == Pvr_UnitySDKEyeOverlay.OverlayType.Overlay)
						{
							isHeadLocked = false;
							if (compositeLayer.layerTransform != null && compositeLayer.layerTransform.parent == base.transform)
							{
								isHeadLocked = true;
							}
							if (compositeLayer.isExternalAndroidSurface)
							{
								layerFlags |= 1;
								CreateExternalSurface(compositeLayer, overlayLayerDepth);
							}
							Render.UPvr_SetOverlayModelViewMatrix((int)compositeLayer.overlayType, (int)compositeLayer.overlayShape, compositeLayer.layerTextureIds[0], 0, overlayLayerDepth, isHeadLocked, layerFlags, compositeLayer.MVMatrixs[0], compositeLayer.ModelScales[0], compositeLayer.ModelRotations[0], compositeLayer.ModelTranslations[0], compositeLayer.CameraRotations[0], compositeLayer.CameraTranslations[0], compositeLayer.GetLayerColorScale(), compositeLayer.GetLayerColorOffset());
							Render.UPvr_SetOverlayModelViewMatrix((int)compositeLayer.overlayType, (int)compositeLayer.overlayShape, compositeLayer.layerTextureIds[1], 1, overlayLayerDepth, isHeadLocked, layerFlags, compositeLayer.MVMatrixs[1], compositeLayer.ModelScales[1], compositeLayer.ModelRotations[1], compositeLayer.ModelTranslations[1], compositeLayer.CameraRotations[1], compositeLayer.CameraTranslations[1], compositeLayer.GetLayerColorScale(), compositeLayer.GetLayerColorOffset());
							overlayLayerDepth++;
						}
						else if (compositeLayer.overlayType == Pvr_UnitySDKEyeOverlay.OverlayType.Underlay)
						{
							if (compositeLayer.isExternalAndroidSurface)
							{
								layerFlags |= 1;
								CreateExternalSurface(compositeLayer, underlayLayerDepth);
							}
							Render.UPvr_SetOverlayModelViewMatrix((int)compositeLayer.overlayType, (int)compositeLayer.overlayShape, compositeLayer.layerTextureIds[0], 0, underlayLayerDepth, isHeadLocked: false, layerFlags, compositeLayer.MVMatrixs[0], compositeLayer.ModelScales[0], compositeLayer.ModelRotations[0], compositeLayer.ModelTranslations[0], compositeLayer.CameraRotations[0], compositeLayer.CameraTranslations[0], compositeLayer.GetLayerColorScale(), compositeLayer.GetLayerColorOffset());
							Render.UPvr_SetOverlayModelViewMatrix((int)compositeLayer.overlayType, (int)compositeLayer.overlayShape, compositeLayer.layerTextureIds[1], 1, underlayLayerDepth, isHeadLocked: false, layerFlags, compositeLayer.MVMatrixs[1], compositeLayer.ModelScales[1], compositeLayer.ModelRotations[1], compositeLayer.ModelTranslations[1], compositeLayer.CameraRotations[1], compositeLayer.CameraTranslations[1], compositeLayer.GetLayerColorScale(), compositeLayer.GetLayerColorOffset());
							underlayLayerDepth++;
						}
					}
					else if (compositeLayer.overlayShape == Pvr_UnitySDKEyeOverlay.OverlayShape.Equirect)
					{
						if (compositeLayer.isExternalAndroidSurface)
						{
							layerFlags |= 1;
							CreateExternalSurface(compositeLayer, 0);
						}
						Render.UPvr_SetupLayerData(0, 0, compositeLayer.layerTextureIds[0], (int)compositeLayer.overlayShape, layerFlags, compositeLayer.GetLayerColorScale(), compositeLayer.GetLayerColorOffset());
						Render.UPvr_SetupLayerData(0, 1, compositeLayer.layerTextureIds[1], (int)compositeLayer.overlayShape, layerFlags, compositeLayer.GetLayerColorScale(), compositeLayer.GetLayerColorOffset());
					}
				}
			}
			Pvr_UnitySDKAPI.System.UPvr_UnityEventData(Pvr_UnitySDKAPI.System.UPvr_GetEyeBufferData(0));
			Pvr_UnitySDKPluginEvent.Issue(RenderEventType.TimeWarp);
			Pvr_UnitySDKRender.Instance.currEyeTextureIdx = Pvr_UnitySDKRender.Instance.nextEyeTextureIdx;
			Pvr_UnitySDKRender.Instance.nextEyeTextureIdx = (Pvr_UnitySDKRender.Instance.nextEyeTextureIdx + 1) % 3;
		}
	}

	private void CreateExternalSurface(Pvr_UnitySDKEyeOverlay overlayInstance, int layerDepth)
	{
		if (overlayInstance.externalAndroidSurfaceObject == IntPtr.Zero)
		{
			overlayInstance.externalAndroidSurfaceObject = Render.UPvr_CreateLayerAndroidSurface((int)overlayInstance.overlayType, layerDepth);
			UnityEngine.Debug.LogFormat("CreateExternalSurface: Overlay Type:{0}, LayerDepth:{1}, SurfaceObject:{2}", overlayInstance.overlayType, layerDepth, overlayInstance.externalAndroidSurfaceObject);
			if (overlayInstance.externalAndroidSurfaceObject != IntPtr.Zero && overlayInstance.externalAndroidSurfaceObjectCreated != null)
			{
				overlayInstance.externalAndroidSurfaceObjectCreated();
			}
		}
	}

	public bool SetEyeTrackingMode()
	{
		supportEyeTracking = (Pvr_UnitySDKAPI.System.UPvr_GetTrackingMode() & 4) != 0;
		bool result = false;
		if (EyeTracking && supportEyeTracking)
		{
			result = Pvr_UnitySDKAPI.System.UPvr_setTrackingMode(6);
		}
		UnityEngine.Debug.Log("SetEyeTrackingMode EyeTracking " + EyeTracking + " supportEyeTracking " + supportEyeTracking + " result " + result);
		return result;
	}

	public Vector3 GetEyeTrackingPos()
	{
		if (!Instance.EyeTracking)
		{
			return Vector3.zero;
		}
		bool flag = Pvr_UnitySDKAPI.System.UPvr_getEyeTrackingData(ref eyePoseData);
		if (!flag)
		{
			PLOG.E("UPvr_getEyeTrackingData failed " + flag);
			return Vector3.zero;
		}
		EyeDeviceInfo deviceInfo = GetDeviceInfo();
		Vector3 zero = Vector3.zero;
		zero.x = 0.5f * (deviceInfo.targetFrustumLeft.right - deviceInfo.targetFrustumLeft.left);
		zero.y = 0.5f * (deviceInfo.targetFrustumLeft.top - deviceInfo.targetFrustumLeft.bottom);
		zero.z = deviceInfo.targetFrustumLeft.near;
		Vector3 foveatedGazeDirection = eyePoseData.foveatedGazeDirection;
		float num = Vector3.Dot(foveatedGazeDirection, Vector3.forward);
		if (num > float.Epsilon)
		{
			eyePoint = foveatedGazeDirection * (zero.z / num);
			eyePoint.x /= zero.x;
			eyePoint.y /= zero.y;
		}
		return eyePoint;
	}

	private EyeDeviceInfo GetDeviceInfo()
	{
		float num = Mathf.Tan(Pvr_UnitySDKRender.Instance.EyeVFoV / 2f * ((float)Math.PI / 180f));
		float num2 = Mathf.Tan(Pvr_UnitySDKRender.Instance.EyeHFoV / 2f * ((float)Math.PI / 180f));
		EyeDeviceInfo result = default(EyeDeviceInfo);
		result.targetFrustumLeft.left = 0f - LeftEyeCamera.nearClipPlane * num2;
		result.targetFrustumLeft.right = LeftEyeCamera.nearClipPlane * num2;
		result.targetFrustumLeft.top = LeftEyeCamera.nearClipPlane * num;
		result.targetFrustumLeft.bottom = 0f - LeftEyeCamera.nearClipPlane * num;
		result.targetFrustumLeft.near = LeftEyeCamera.nearClipPlane;
		result.targetFrustumLeft.far = LeftEyeCamera.farClipPlane;
		result.targetFrustumRight.left = 0f - RightEyeCamera.nearClipPlane * num2;
		result.targetFrustumRight.right = RightEyeCamera.nearClipPlane * num2;
		result.targetFrustumRight.top = RightEyeCamera.nearClipPlane * num;
		result.targetFrustumRight.bottom = 0f - RightEyeCamera.nearClipPlane * num;
		result.targetFrustumRight.near = RightEyeCamera.nearClipPlane;
		result.targetFrustumRight.far = RightEyeCamera.farClipPlane;
		return result;
	}

	private void CreateFadeMesh()
	{
		fadeMaterial = new Material(Shader.Find("Pvr_UnitySDK/Fade"));
		fadeMeshFilter = base.gameObject.AddComponent<MeshFilter>();
		fadeMeshRenderer = base.gameObject.AddComponent<MeshRenderer>();
		Mesh mesh = new Mesh();
		fadeMeshFilter.mesh = mesh;
		Vector3[] array = new Vector3[4];
		float num = 2f;
		float num2 = 2f;
		float z = 1f;
		array[0] = new Vector3(0f - num, 0f - num2, z);
		array[1] = new Vector3(num, 0f - num2, z);
		array[2] = new Vector3(0f - num, num2, z);
		array[3] = new Vector3(num, num2, z);
		mesh.vertices = array;
		mesh.triangles = new int[6] { 0, 2, 1, 2, 3, 1 };
		mesh.normals = new Vector3[4]
		{
			-Vector3.forward,
			-Vector3.forward,
			-Vector3.forward,
			-Vector3.forward
		};
		mesh.uv = new Vector2[4]
		{
			new Vector2(0f, 0f),
			new Vector2(1f, 0f),
			new Vector2(0f, 1f),
			new Vector2(1f, 1f)
		};
	}

	private void DestoryFadeMesh()
	{
		if (fadeMeshRenderer != null)
		{
			UnityEngine.Object.Destroy(fadeMeshRenderer);
		}
		if (fadeMaterial != null)
		{
			UnityEngine.Object.Destroy(fadeMaterial);
		}
		if (fadeMeshFilter != null)
		{
			UnityEngine.Object.Destroy(fadeMeshFilter);
		}
	}

	public void SetCurrentAlpha(float alpha)
	{
		currentAlpha = alpha;
		SetMaterialAlpha();
	}

	private IEnumerator ScreenFade(float startAlpha, float endAlpha)
	{
		float elapsedTime = 0f;
		while (elapsedTime < fadeTime)
		{
			elapsedTime += Time.deltaTime;
			nowFadeAlpha = Mathf.Lerp(startAlpha, endAlpha, Mathf.Clamp01(elapsedTime / fadeTime));
			SetMaterialAlpha();
			yield return new WaitForEndOfFrame();
		}
	}

	private void SetMaterialAlpha()
	{
		Color color = fadeColor;
		color.a = Mathf.Max(currentAlpha, nowFadeAlpha);
		isFading = color.a > 0f;
		if (fadeMaterial != null)
		{
			fadeMaterial.color = color;
			fadeMaterial.renderQueue = renderQueue;
			fadeMeshRenderer.material = fadeMaterial;
			fadeMeshRenderer.enabled = isFading;
		}
	}

	public bool GfxDeviceAdvanceFrameGLES()
	{
		return false;
	}
}
public class Pvr_UnitySDKEyeOverlay : MonoBehaviour, IComparable<Pvr_UnitySDKEyeOverlay>
{
	public delegate void ExternalAndroidSurfaceObjectCreated();

	public enum OverlayShape
	{
		Quad,
		Cylinder,
		Equirect
	}

	public enum OverlayType
	{
		Overlay,
		Underlay
	}

	public enum OverlayTexFilterMode
	{
		NotCare,
		Nearest,
		Linear,
		Nearest_Mipmap_Nearest,
		Linear_Mipmap_Nearest,
		Nearest_Mipmap_Linear,
		Linear_Mipmap_Linear
	}

	public static List<Pvr_UnitySDKEyeOverlay> Instances = new List<Pvr_UnitySDKEyeOverlay>();

	public int layerIndex;

	public OverlayType overlayType;

	public OverlayShape overlayShape;

	public Transform layerTransform;

	public Texture[] layerTextures = new Texture[2];

	public int[] layerTextureIds = new int[2];

	public Matrix4x4[] MVMatrixs = new Matrix4x4[2];

	public Vector3[] ModelScales = new Vector3[2];

	public Quaternion[] ModelRotations = new Quaternion[2];

	public Vector3[] ModelTranslations = new Vector3[2];

	public Quaternion[] CameraRotations = new Quaternion[2];

	public Vector3[] CameraTranslations = new Vector3[2];

	public Camera[] layerEyeCamera = new Camera[2];

	public bool overrideColorScaleAndOffset;

	public Vector4 colorScale = Vector4.one;

	public Vector4 colorOffset = Vector4.zero;

	private Vector4 overlayLayerColorScaleDefault = Vector4.one;

	private Vector4 overlayLayerColorOffsetDefault = Vector4.zero;

	public bool isExternalAndroidSurface;

	public IntPtr externalAndroidSurfaceObject = IntPtr.Zero;

	public ExternalAndroidSurfaceObjectCreated externalAndroidSurfaceObjectCreated;

	public int CompareTo(Pvr_UnitySDKEyeOverlay other)
	{
		return layerIndex.CompareTo(other.layerIndex);
	}

	private void Awake()
	{
		Instances.Add(this);
		if (Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.SinglePass)
		{
			layerEyeCamera[0] = Pvr_UnitySDKEyeManager.Instance.BothEyeCamera;
			layerEyeCamera[1] = Pvr_UnitySDKEyeManager.Instance.BothEyeCamera;
		}
		else if (Pvr_UnitySDKManager.SDK.Monoscopic)
		{
			layerEyeCamera[0] = Pvr_UnitySDKEyeManager.Instance.MonoEyeCamera;
			layerEyeCamera[1] = Pvr_UnitySDKEyeManager.Instance.MonoEyeCamera;
		}
		else
		{
			layerEyeCamera[0] = Pvr_UnitySDKEyeManager.Instance.LeftEyeCamera;
			layerEyeCamera[1] = Pvr_UnitySDKEyeManager.Instance.RightEyeCamera;
		}
		layerTransform = GetComponent<Transform>();
		if (layerTransform != null)
		{
			MeshRenderer component = layerTransform.GetComponent<MeshRenderer>();
			if (component != null)
			{
				component.enabled = false;
			}
		}
		InitializeBuffer();
	}

	private void LateUpdate()
	{
		UpdateCoords();
	}

	private void OnDestroy()
	{
		Instances.Remove(this);
	}

	public void RefreshCamera()
	{
		if (Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.SinglePass)
		{
			layerEyeCamera[0] = Pvr_UnitySDKEyeManager.Instance.BothEyeCamera;
			layerEyeCamera[1] = Pvr_UnitySDKEyeManager.Instance.BothEyeCamera;
		}
		else if (Pvr_UnitySDKManager.SDK.Monoscopic)
		{
			layerEyeCamera[0] = Pvr_UnitySDKEyeManager.Instance.MonoEyeCamera;
			layerEyeCamera[1] = Pvr_UnitySDKEyeManager.Instance.MonoEyeCamera;
		}
		else
		{
			layerEyeCamera[0] = Pvr_UnitySDKEyeManager.Instance.LeftEyeCamera;
			layerEyeCamera[1] = Pvr_UnitySDKEyeManager.Instance.RightEyeCamera;
		}
	}

	private void InitializeBuffer()
	{
		OverlayShape overlayShape = this.overlayShape;
		if ((uint)overlayShape > 2u)
		{
			return;
		}
		for (int i = 0; i < layerTextureIds.Length; i++)
		{
			if (layerTextures[i] != null)
			{
				layerTextureIds[i] = layerTextures[i].GetNativeTexturePtr().ToInt32();
			}
			else
			{
				UnityEngine.Debug.LogWarning($"{(Eye)i} Texture is null!");
			}
		}
	}

	private void UpdateCoords()
	{
		if (layerTransform == null || !layerTransform.gameObject.activeSelf || layerEyeCamera[0] == null || layerEyeCamera[1] == null)
		{
			return;
		}
		for (int i = 0; i < MVMatrixs.Length; i++)
		{
			if (Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.SinglePass)
			{
				Matrix4x4[] stereoWorldToCameraMat = Pvr_UnitySDKSinglePass.GetStereoWorldToCameraMat();
				MVMatrixs[i] = stereoWorldToCameraMat[i] * layerTransform.localToWorldMatrix;
			}
			else
			{
				MVMatrixs[i] = layerEyeCamera[i].worldToCameraMatrix * layerTransform.localToWorldMatrix;
			}
			ModelScales[i] = layerTransform.localScale;
			ModelRotations[i] = layerTransform.rotation;
			ModelTranslations[i] = layerTransform.position;
			CameraRotations[i] = layerEyeCamera[i].transform.rotation;
			CameraTranslations[i] = layerEyeCamera[i].transform.position;
		}
	}

	public void SetTexture(Texture texture)
	{
		for (int i = 0; i < layerTextures.Length; i++)
		{
			layerTextures[i] = texture;
		}
		InitializeBuffer();
	}

	public void SetLayerColorScaleAndOffset(Vector4 scale, Vector4 offset)
	{
		colorScale = scale;
		colorOffset = offset;
	}

	public Vector4 GetLayerColorScale()
	{
		if (!overrideColorScaleAndOffset)
		{
			return overlayLayerColorScaleDefault;
		}
		return colorScale;
	}

	public Vector4 GetLayerColorOffset()
	{
		if (!overrideColorScaleAndOffset)
		{
			return overlayLayerColorOffsetDefault;
		}
		return colorOffset;
	}
}
public class Pvr_UnitySDKRender
{
	private static Pvr_UnitySDKRender instance;

	public AndroidJavaObject activity;

	public static AndroidJavaClass javaVrActivityClass;

	public static AndroidJavaClass javaSysActivityClass;

	public static AndroidJavaClass javaserviceClass;

	public static AndroidJavaClass javaVrActivityLongReceiver;

	public static AndroidJavaClass javaVrActivityClientClass;

	private bool canConnecttoActivity;

	private bool isInitrenderThread = true;

	private string model;

	private Vector2 prefinger1 = new Vector2(0f, 0f);

	private Vector2 prefinger2 = new Vector2(0f, 0f);

	public int eyeTextureCount = 6;

	public RenderTexture[] eyeTextures;

	public int[] eyeTextureIds;

	public int currEyeTextureIdx;

	public int nextEyeTextureIdx = 1;

	public int lastEyeTextureIdx;

	public bool isSwitchSDK;

	public int RenderviewNumber;

	public bool isFirstStartup = true;

	public bool isShellMode;

	private StereoRenderingPathPico stereoRenderPath;

	private float rtScaleFactor = 1f;

	private float eyeVFov = 90f;

	private float eyeHFov = 90f;

	public static Pvr_UnitySDKRender Instance
	{
		get
		{
			if (instance == null)
			{
				instance = new Pvr_UnitySDKRender();
			}
			return instance;
		}
		set
		{
			instance = value;
		}
	}

	public StereoRenderingPathPico StereoRenderPath => stereoRenderPath;

	public SDKStereoRendering StereoRendering { get; private set; }

	public float RtScaleFactor
	{
		get
		{
			return rtScaleFactor;
		}
		set
		{
			if (value != rtScaleFactor)
			{
				rtScaleFactor = value;
				ReCreateEyeBuffer();
			}
		}
	}

	public float EyeVFoV
	{
		get
		{
			return eyeVFov;
		}
		set
		{
			if (value != eyeVFov)
			{
				eyeVFov = value;
			}
		}
	}

	public float EyeHFoV
	{
		get
		{
			return eyeHFov;
		}
		set
		{
			if (value != eyeHFov)
			{
				eyeHFov = value;
			}
		}
	}

	public Pvr_UnitySDKRender()
	{
		if (!canConnecttoActivity)
		{
			ConnectToAndriod();
			PLOG.I("PvrLog Init Render Ability Success!");
			isInitrenderThread = false;
		}
		Init();
	}

	public void ConnectToAndriod()
	{
		try
		{
			UnityEngine.Debug.Log("PvrLog SDK Version :  " + Pvr_UnitySDKAPI.System.UPvr_GetSDKVersion().ToString() + "  Unity Script Version :" + Pvr_UnitySDKAPI.System.UPvr_GetUnitySDKVersion().ToString());
			AndroidJavaClass androidJavaClass = new AndroidJavaClass("com.unity3d.player.UnityPlayer");
			activity = androidJavaClass.GetStatic<AndroidJavaObject>("currentActivity");
			javaVrActivityClass = new AndroidJavaClass("com.psmart.vrlib.VrActivity");
			javaserviceClass = new AndroidJavaClass("com.picovr.picovrlib.hummingbirdclient.UnityClient");
			javaVrActivityLongReceiver = new AndroidJavaClass("com.psmart.vrlib.HomeKeyReceiver");
			javaSysActivityClass = new AndroidJavaClass("com.psmart.aosoperation.SysActivity");
			javaVrActivityClientClass = new AndroidJavaClass("com.psmart.vrlib.PvrClient");
			Pvr_UnitySDKAPI.System.Pvr_SetInitActivity(activity.GetRawObject(), javaVrActivityClass.GetRawClass());
			model = javaVrActivityClass.CallStatic<string>("Pvr_GetBuildModel", Array.Empty<object>());
			double[] result = new double[5];
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaVrActivityClass, "getDPIParameters", activity);
			int res = -1;
			Render.UPvr_GetIntConfig(4, ref res);
			string result2 = "";
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result2, javaserviceClass, "getSysproc", "persist.pvr.debug.appfps");
			if (result2 != "")
			{
				Pvr_UnitySDKManager.SDK.systemFPS = Convert.ToBoolean(Convert.ToInt16(result2));
			}
			if (res == 0)
			{
				Render.UPvr_ChangeScreenParameters(model, (int)result[0], (int)result[1], result[2], result[3], result[4]);
				Screen.sleepTimeout = -1;
			}
			if (Pvr_UnitySDKAPI.System.UPvr_IsPicoActivity())
			{
				UnityEngine.Debug.Log("ConnectToAndriod set monoPresentation success ?-------------" + Pvr_UnitySDKAPI.System.UPvr_SetMonoPresentation());
				UnityEngine.Debug.Log("ConnectToAndriod presentation existed ?-------------" + Pvr_UnitySDKAPI.System.UPvr_IsPresentationExisted());
			}
			isShellMode = GetIsShellMode();
			UnityEngine.Debug.Log("ConnectToAndriod isShellMode ?-------------" + isShellMode);
		}
		catch (AndroidJavaException ex)
		{
			PLOG.E("ConnectToAndriod--catch" + ex.Message);
		}
		canConnecttoActivity = true;
	}

	public void Init()
	{
		if (InitRenderAbility())
		{
			UnityEngine.Debug.Log("PvrLog Init Render Ability Success!");
			isInitrenderThread = false;
		}
		else
		{
			UnityEngine.Debug.Log("PvrLog Init Render Ability Failed!");
		}
	}

	private bool InitRenderAbility()
	{
		if (UpdateRenderParaFrame() && CreateEyeBuffer())
		{
			float num = Pvr_UnitySDKAPI.System.UPvr_GetIPD();
			Pvr_UnitySDKManager.SDK.leftEyeOffset = new Vector3((0f - num) / 2f, 0f, 0f);
			Pvr_UnitySDKManager.SDK.rightEyeOffset = new Vector3(num / 2f, 0f, 0f);
			return true;
		}
		return false;
	}

	private bool UpdateRenderParaFrame()
	{
		EyeVFoV = GetEyeVFOV();
		EyeHFoV = GetEyeHFOV();
		Pvr_UnitySDKManager.SDK.EyesAspect = EyeHFoV / EyeVFoV;
		return true;
	}

	private bool CreateEyeBuffer()
	{
		Vector2 eyeBufferResolution = GetEyeBufferResolution();
		if (isFirstStartup)
		{
			InitSinglePass();
			Pvr_UnitySDKAPI.System.UPvr_SetSinglePassDepthBufferWidthHeight((int)eyeBufferResolution.x, (int)eyeBufferResolution.y);
		}
		eyeTextures = new RenderTexture[eyeTextureCount];
		eyeTextureIds = new int[eyeTextureCount];
		for (int i = 0; i < eyeTextureCount; i++)
		{
			if (null == eyeTextures[i])
			{
				try
				{
					ConfigureEyeBuffer(i, eyeBufferResolution);
				}
				catch (Exception ex)
				{
					PLOG.E("ConfigureEyeBuffer ERROR " + ex.Message);
					throw;
				}
			}
			if (!eyeTextures[i].IsCreated())
			{
				eyeTextures[i].Create();
				eyeTextureIds[i] = eyeTextures[i].GetNativeTexturePtr().ToInt32();
			}
			eyeTextureIds[i] = eyeTextures[i].GetNativeTexturePtr().ToInt32();
		}
		return true;
	}

	private void InitSinglePass()
	{
		bool flag = true;
		if (GraphicsSettings.renderPipelineAsset != null)
		{
			flag = false;
			if (!BoundarySystem.UPvr_EnableLWRP(enable: true))
			{
				UnityEngine.Debug.Log("UPvr_EnableLWRP return false");
			}
			Vector2 eyeBufferResolution = GetEyeBufferResolution();
			if (!BoundarySystem.UPvr_SetViewportSize((int)eyeBufferResolution.x, (int)eyeBufferResolution.y))
			{
				UnityEngine.Debug.Log("UPvr_SetViewportSize return false");
			}
		}
		if (Pvr_UnitySDKProjectSetting.GetProjectConfig().usesinglepass)
		{
			bool flag2 = false;
			if (flag)
			{
				flag2 = Pvr_UnitySDKAPI.System.UPvr_EnableSinglePass(enable: true);
			}
			if (flag2)
			{
				StereoRendering = new Pvr_UnitySDKSinglePass();
				stereoRenderPath = StereoRenderingPathPico.SinglePass;
				eyeTextureCount = 3;
			}
			UnityEngine.Debug.Log("EnableSinglePass supportSinglePass " + flag + " result " + flag2);
		}
	}

	public float GetEyeVFOV()
	{
		float res = 102f;
		try
		{
			Render.UPvr_GetFloatConfig(1, ref res);
			if (res <= 0f)
			{
				res = 102f;
			}
		}
		catch (Exception ex)
		{
			PLOG.E("GetEyeVFOV ERROR! " + ex.Message);
			throw;
		}
		return res;
	}

	public float GetEyeHFOV()
	{
		float res = 102f;
		try
		{
			Render.UPvr_GetFloatConfig(2, ref res);
			if (res <= 0f)
			{
				res = 102f;
			}
		}
		catch (Exception ex)
		{
			PLOG.E("GetEyeHFOV ERROR! " + ex.Message);
			throw;
		}
		return res;
	}

	private void ConfigureEyeBuffer(int eyeTextureIndex, Vector2 resolution)
	{
		int width = (int)resolution.x;
		int height = (int)resolution.y;
		eyeTextures[eyeTextureIndex] = new RenderTexture(width, height, (int)Pvr_UnitySDKProjectSetting.GetProjectConfig().rtBitDepth, Pvr_UnitySDKProjectSetting.GetProjectConfig().rtFormat);
		if (StereoRenderPath == StereoRenderingPathPico.MultiPass)
		{
			eyeTextures[eyeTextureIndex].anisoLevel = 0;
			eyeTextures[eyeTextureIndex].antiAliasing = Mathf.Max(QualitySettings.antiAliasing, (int)Pvr_UnitySDKProjectSetting.GetProjectConfig().rtAntiAlising);
			UnityEngine.Debug.Log("MultiPass ConfigureEyeBuffer eyeTextureIndex " + eyeTextureIndex);
		}
		else if (StereoRenderPath == StereoRenderingPathPico.SinglePass)
		{
			eyeTextures[eyeTextureIndex].useMipMap = false;
			eyeTextures[eyeTextureIndex].wrapMode = TextureWrapMode.Clamp;
			eyeTextures[eyeTextureIndex].filterMode = FilterMode.Bilinear;
			eyeTextures[eyeTextureIndex].anisoLevel = 1;
			eyeTextures[eyeTextureIndex].dimension = TextureDimension.Tex2DArray;
			eyeTextures[eyeTextureIndex].volumeDepth = 2;
			UnityEngine.Debug.Log("SinglePass ConfigureEyeBuffer eyeTextureIndex " + eyeTextureIndex);
		}
		eyeTextures[eyeTextureIndex].Create();
		if (eyeTextures[eyeTextureIndex].IsCreated())
		{
			eyeTextureIds[eyeTextureIndex] = eyeTextures[eyeTextureIndex].GetNativeTexturePtr().ToInt32();
			UnityEngine.Debug.Log("eyeTextureIndex : " + eyeTextureIndex);
		}
	}

	public bool ReCreateEyeBuffer()
	{
		if (!Pvr_UnitySDKProjectSetting.GetProjectConfig().usedefaultRenderTexture)
		{
			for (int i = 0; i < eyeTextureCount; i++)
			{
				if (eyeTextures[i] != null)
				{
					eyeTextures[i].Release();
				}
			}
			Array.Clear(eyeTextures, 0, eyeTextures.Length);
			return CreateEyeBuffer();
		}
		return false;
	}

	public void ReInit()
	{
		if (canConnecttoActivity && isInitrenderThread)
		{
			Init();
		}
	}

	public void IssueRenderThread()
	{
		if (canConnecttoActivity && !isInitrenderThread)
		{
			switch (QualitySettings.activeColorSpace)
			{
			case ColorSpace.Gamma:
				Render.UPvr_SetColorspaceType(0);
				break;
			case ColorSpace.Linear:
				Render.UPvr_SetColorspaceType(1);
				break;
			}
			Pvr_UnitySDKPluginEvent.Issue(RenderEventType.InitRenderThread);
			isInitrenderThread = true;
			if (StereoRendering != null)
			{
				StereoRendering.OnSDKRenderInited();
			}
			UnityEngine.Debug.Log("PvrLog IssueRenderThread end");
		}
		else
		{
			PLOG.I("PvrLog IssueRenderThread  canConnecttoActivity = " + canConnecttoActivity);
		}
	}

	private void AutoAdpatForPico1s()
	{
		Vector2 position = Input.touches[0].position;
		Vector2 position2 = Input.touches[1].position;
		if (Vector2.Distance(prefinger1, position) > 2f && Vector2.Distance(prefinger2, position2) > 2f)
		{
			float midH = (Input.touches[0].position.x + Input.touches[1].position.x) / (float)Screen.width - 1f;
			float midV = (Input.touches[0].position.y + Input.touches[1].position.y) / (float)Screen.height - 1f;
			Render.UPvr_SetRatio(midH, midV);
		}
		prefinger1 = position;
		prefinger2 = position2;
	}

	public Vector2 GetEyeBufferResolution()
	{
		int res = 1024;
		int res2 = 1024;
		if (Pvr_UnitySDKProjectSetting.GetProjectConfig().usedefaultRenderTexture)
		{
			try
			{
				Render.UPvr_GetIntConfig(0, ref res);
				Render.UPvr_GetIntConfig(1, ref res2);
			}
			catch (Exception ex)
			{
				PLOG.E("GetEyeBufferResolution ERROR! " + ex.Message);
				throw;
			}
		}
		else
		{
			res = (int)(Pvr_UnitySDKProjectSetting.GetProjectConfig().customRTSize.x * RtScaleFactor);
			res2 = (int)(Pvr_UnitySDKProjectSetting.GetProjectConfig().customRTSize.y * RtScaleFactor);
		}
		Vector2 vector = new Vector2(res, res2);
		UnityEngine.Debug.Log(string.Concat("DISFT Customize RenderTexture:", vector, ", scaleFactor: ", RtScaleFactor));
		return vector;
	}

	public bool GetUsePredictedMatrix()
	{
		return true;
	}

	public bool GetIsShellMode()
	{
		if (activity == null)
		{
			return false;
		}
		using (AndroidJavaObject androidJavaObject = activity.Call<AndroidJavaObject>("getPackageManager", Array.Empty<object>()).Call<AndroidJavaObject>("getApplicationInfo", new object[2]
		{
			activity.Call<string>("getPackageName", Array.Empty<object>()),
			128
		}))
		{
			AndroidJavaObject androidJavaObject2 = androidJavaObject.Get<AndroidJavaObject>("metaData");
			if (androidJavaObject2 != null)
			{
				if (androidJavaObject2.Call<int>("getInt", new object[1] { "shell_mode" }) == 1)
				{
					return true;
				}
				return false;
			}
		}
		return false;
	}
}
public class Pvr_UnitySDKSinglePass : SDKStereoRendering
{
	private static Camera bothCamera;

	private Matrix4x4[] unity_StereoMatrixP = new Matrix4x4[2];

	private Matrix4x4[] unity_StereoMatrixInvP = new Matrix4x4[2];

	private static Matrix4x4[] unity_StereoWorldToCamera = new Matrix4x4[2];

	private Matrix4x4[] unity_StereoCameraToWorld = new Matrix4x4[2];

	private Matrix4x4[] unity_StereoMatrixVP = new Matrix4x4[2];

	private Vector3[] eyesOffset = new Vector3[2];

	private static Matrix4x4[] eyesOffsetMatrix = new Matrix4x4[2];

	private CommandBuffer commandBufferBeforeForwardOpaque;

	private CommandBuffer commandBufferBeforeSkybox;

	private CommandBuffer commandBufferAfterSkybox;

	public override void InitEye(Camera eye)
	{
		bothCamera = eye;
		bothCamera.stereoSeparation = 0.0625f;
		bothCamera.stereoConvergence = 0f;
		bothCamera.allowHDR = false;
		bothCamera.allowDynamicResolution = false;
		SetEyesPosition();
		SetEyeProjection();
		Pvr_UnitySDKSensor.EyeFovChanged = (Action)Delegate.Combine(Pvr_UnitySDKSensor.EyeFovChanged, new Action(SetEyeProjection));
		UnityEngine.Debug.Log("SinglePass Init success! CameraName = " + eye.transform.name + " eye.eyeSide " + eye.GetComponent<Pvr_UnitySDKEye>().eyeSide);
	}

	public override void OnSDKRenderInited()
	{
		OnSDKRenderInited_SinglePass();
	}

	public override void OnSDKPreRender()
	{
		SinglePassPreRender();
	}

	public override void OnSDKPostRender()
	{
		SwitchKeywordAndDeviceView(enable: false);
	}

	public void OnSDKRenderInited_SinglePass()
	{
		Shader.SetGlobalVectorArray("unity_StereoScaleOffset", new Vector4[2]
		{
			new Vector4(1f, 1f, 0f, 0f),
			new Vector4(1f, 1f, 0.5f, 0f)
		});
		SetAntiAliasing();
		UnityEngine.Debug.Log("OnSDKRenderInited_SinglePass");
	}

	private void SetAntiAliasing()
	{
		int num = Mathf.Max(QualitySettings.antiAliasing, (int)Pvr_UnitySDKProjectSetting.GetProjectConfig().rtAntiAlising);
		Pvr_UnitySDKAPI.System.UPvr_SetAntiAliasing(num);
		UnityEngine.Debug.Log("SetAntiAliasing  antiAliasing = " + num);
	}

	public void SetEyesPosition()
	{
		float res = 0.0625f;
		int configsenum = 0;
		if (Render.UPvr_GetFloatConfig(configsenum, ref res) != 0)
		{
			PLOG.E("Cannot get ipd");
			res = 0.0625f;
		}
		bothCamera.stereoSeparation = res;
		Vector3 vector = new Vector3((0f - res) / 2f, 0f, 0f);
		Vector3 vector2 = new Vector3(res / 2f, 0f, 0f);
		Vector3 vector3 = (vector + vector2) / 2f;
		bothCamera.transform.localPosition = vector3;
		bothCamera.transform.localRotation = Quaternion.identity;
		Vector3 vector4 = vector - vector3;
		Vector3 vector5 = vector2 - vector3;
		eyesOffset[0] = vector4;
		eyesOffset[1] = vector5;
		eyesOffsetMatrix[0] = Matrix4x4.TRS(vector4, Quaternion.identity, Vector3.one);
		eyesOffsetMatrix[1] = Matrix4x4.TRS(vector5, Quaternion.identity, Vector3.one);
	}

	public void SetEyeProjection()
	{
		Matrix4x4 projection = GetProjection(bothCamera.nearClipPlane, bothCamera.farClipPlane);
		Matrix4x4 projection2 = GetProjection(bothCamera.nearClipPlane, bothCamera.farClipPlane);
		SetStereoProjectionMatrix(projection, projection2);
	}

	private static Matrix4x4 GetProjection(float near, float far)
	{
		if (near < 0.01f)
		{
			near = 0.01f;
		}
		if (far < 0.02f)
		{
			far = 0.02f;
		}
		_ = Matrix4x4.identity;
		return MakeProjection(near, far);
	}

	public static Matrix4x4 MakeProjection(float n, float f)
	{
		Vector2 eyeBufferResolution = Pvr_UnitySDKRender.Instance.GetEyeBufferResolution();
		float num = Mathf.Tan(Pvr_UnitySDKRender.Instance.EyeVFoV / 2f * ((float)Math.PI / 180f));
		float num2 = 1f / num;
		Matrix4x4 zero = Matrix4x4.zero;
		zero[0, 0] = num2 / (eyeBufferResolution.x / eyeBufferResolution.y);
		zero[1, 1] = num2;
		zero[2, 2] = (0f - (f + n)) / (f - n);
		zero[2, 3] = -2f * f * n / (f - n);
		zero[3, 2] = -1f;
		return zero;
	}

	public void SetStereoProjectionMatrix(Matrix4x4 left, Matrix4x4 right)
	{
		unity_StereoMatrixP[0] = left;
		unity_StereoMatrixInvP[0] = left.inverse;
		unity_StereoMatrixP[1] = right;
		unity_StereoMatrixInvP[1] = right.inverse;
	}

	private void SwitchKeywordAndDeviceView(bool enable)
	{
		if (enable)
		{
			Shader.EnableKeyword("STEREO_MULTIVIEW_ON");
			Shader.EnableKeyword("UNITY_SINGLE_PASS_STEREO");
			XRSettings.showDeviceView = false;
		}
		else
		{
			XRSettings.showDeviceView = true;
			Shader.DisableKeyword("UNITY_SINGLE_PASS_STEREO");
			Shader.DisableKeyword("STEREO_MULTIVIEW_ON");
		}
	}

	public static Matrix4x4[] GetStereoWorldToCameraMat()
	{
		Matrix4x4 worldToCameraMatrix = bothCamera.worldToCameraMatrix;
		unity_StereoWorldToCamera[0] = eyesOffsetMatrix[0].inverse * worldToCameraMatrix;
		unity_StereoWorldToCamera[1] = eyesOffsetMatrix[1].inverse * worldToCameraMatrix;
		return unity_StereoWorldToCamera;
	}

	public void SinglePassPreRender()
	{
		SwitchKeywordAndDeviceView(enable: true);
		Shader.SetGlobalMatrixArray("unity_StereoCameraProjection", unity_StereoMatrixP);
		Shader.SetGlobalMatrixArray("unity_StereoCameraInvProjection", unity_StereoMatrixInvP);
		Shader.SetGlobalMatrixArray("unity_StereoMatrixP", unity_StereoMatrixP);
		Matrix4x4 worldToCameraMatrix = bothCamera.worldToCameraMatrix;
		Matrix4x4 cameraToWorldMatrix = bothCamera.cameraToWorldMatrix;
		unity_StereoCameraToWorld[0] = cameraToWorldMatrix * eyesOffsetMatrix[0];
		unity_StereoCameraToWorld[1] = cameraToWorldMatrix * eyesOffsetMatrix[1];
		Shader.SetGlobalMatrixArray("unity_StereoCameraToWorld", unity_StereoCameraToWorld);
		unity_StereoWorldToCamera[0] = eyesOffsetMatrix[0].inverse * worldToCameraMatrix;
		unity_StereoWorldToCamera[1] = eyesOffsetMatrix[1].inverse * worldToCameraMatrix;
		Shader.SetGlobalMatrixArray("unity_StereoWorldToCamera", unity_StereoWorldToCamera);
		Vector4[] values = new Vector4[2]
		{
			bothCamera.transform.position + eyesOffset[0],
			bothCamera.transform.position + eyesOffset[1]
		};
		Shader.SetGlobalVectorArray("unity_StereoWorldSpaceCameraPos", values);
		Shader.SetGlobalMatrixArray("unity_StereoMatrixV", unity_StereoWorldToCamera);
		Shader.SetGlobalMatrixArray("unity_StereoMatrixInvV", unity_StereoCameraToWorld);
		unity_StereoMatrixVP[0] = unity_StereoMatrixP[0] * unity_StereoWorldToCamera[0];
		unity_StereoMatrixVP[1] = unity_StereoMatrixP[1] * unity_StereoWorldToCamera[1];
		Shader.SetGlobalMatrixArray("unity_StereoMatrixVP", unity_StereoMatrixVP);
		SetRenderTextureWithDepth();
		SetCommandBuffers();
	}

	private void SetCommandBuffers()
	{
		if (commandBufferBeforeForwardOpaque == null)
		{
			commandBufferBeforeForwardOpaque = new CommandBuffer();
			Pvr_UnitySDKPluginEvent.SetSinglePassBeforeForwardOpaque(commandBufferBeforeForwardOpaque);
			commandBufferBeforeForwardOpaque.ClearRenderTarget(clearDepth: true, clearColor: true, bothCamera.backgroundColor);
			commandBufferBeforeForwardOpaque.name = "SinglePassPrepare";
		}
		bothCamera.RemoveCommandBuffer(CameraEvent.BeforeForwardOpaque, commandBufferBeforeForwardOpaque);
		bothCamera.AddCommandBuffer(CameraEvent.BeforeForwardOpaque, commandBufferBeforeForwardOpaque);
		if (commandBufferAfterSkybox == null)
		{
			commandBufferAfterSkybox = new CommandBuffer();
		}
		bothCamera.RemoveCommandBuffer(CameraEvent.AfterSkybox, commandBufferAfterSkybox);
		commandBufferAfterSkybox.Clear();
		commandBufferAfterSkybox.SetGlobalMatrixArray("unity_StereoMatrixVP", unity_StereoMatrixVP);
		commandBufferAfterSkybox.name = "SinglePassAfterSkyBox";
		bothCamera.AddCommandBuffer(CameraEvent.AfterSkybox, commandBufferAfterSkybox);
		if (commandBufferBeforeSkybox == null)
		{
			commandBufferBeforeSkybox = new CommandBuffer();
		}
		Matrix4x4 transpose = (Matrix4x4.LookAt(Vector3.zero, bothCamera.transform.forward, bothCamera.transform.up) * Matrix4x4.Scale(new Vector3(1f, 1f, -1f))).transpose;
		Matrix4x4 matrix4x = unity_StereoMatrixP[0];
		Matrix4x4 matrix4x2 = unity_StereoMatrixP[1];
		matrix4x.m22 = -1f;
		matrix4x2.m22 = -1f;
		Matrix4x4[] values = new Matrix4x4[2]
		{
			matrix4x * transpose,
			matrix4x2 * transpose
		};
		bothCamera.RemoveCommandBuffer(CameraEvent.BeforeSkybox, commandBufferBeforeSkybox);
		commandBufferBeforeSkybox.Clear();
		commandBufferBeforeSkybox.SetGlobalMatrixArray("unity_StereoMatrixVP", values);
		commandBufferBeforeSkybox.name = "SinglePassAfterSkybox";
		bothCamera.AddCommandBuffer(CameraEvent.BeforeSkybox, commandBufferBeforeSkybox);
	}

	private void SetRenderTextureWithDepth()
	{
		Pvr_UnitySDKAPI.System.UPvr_SetCurrentRenderTexture((uint)Pvr_UnitySDKRender.Instance.eyeTextureIds[Pvr_UnitySDKRender.Instance.currEyeTextureIdx]);
	}
}
public abstract class SDKStereoRendering
{
	public abstract void InitEye(Camera eye);

	public abstract void OnSDKRenderInited();

	public abstract void OnSDKPreRender();

	public abstract void OnSDKPostRender();
}
public class HighlightAtGaze : MonoBehaviour
{
	public Color HighlightColor = Color.red;

	public float AnimationTime = 0.1f;

	private Renderer myRenderer;

	private Color originalColor;

	private Color targetColor;

	private EyeTrackingGazeRay gazeRay;

	private void Start()
	{
		myRenderer = GetComponent<Renderer>();
		originalColor = myRenderer.material.color;
		targetColor = originalColor;
	}

	private void Update()
	{
		Pvr_UnitySDKAPI.System.UPvr_getEyeTrackingGazeRay(ref gazeRay);
		if (Physics.Raycast(new Ray(gazeRay.Origin, gazeRay.Direction), out var hitInfo))
		{
			if (hitInfo.transform.name == base.transform.name)
			{
				if (targetColor != HighlightColor)
				{
					targetColor = HighlightColor;
				}
			}
			else if (targetColor != originalColor)
			{
				targetColor = originalColor;
			}
		}
		else if (targetColor != originalColor)
		{
			targetColor = originalColor;
		}
		myRenderer.material.color = Color.Lerp(myRenderer.material.color, targetColor, Time.deltaTime * (1f / AnimationTime));
	}
}
public class RayVisualizer : MonoBehaviour
{
	private LineRenderer _line;

	private EyeTrackingGazeRay gazeRay;

	private void Start()
	{
		_line = base.gameObject.GetComponent<LineRenderer>();
		_line.startWidth = 0.002f;
		_line.endWidth = 0.002f;
	}

	private void Update()
	{
		Matrix4x4 matrix = Pvr_UnitySDKSensor.Instance.HeadPose.Matrix;
		Pvr_UnitySDKAPI.System.UPvr_getEyeTrackingGazeRay(ref gazeRay);
		_line.SetPosition(0, matrix.MultiplyPoint(new Vector3(0f, -0.05f, 0.2f)));
		_line.SetPosition(1, gazeRay.Origin + gazeRay.Direction * 20f);
	}
}
public class GetSeeThroughImage : MonoBehaviour
{
	public RawImage viewImage_left;

	public RawImage viewImage_right;

	private int width;

	private int height;

	private RenderTexture cameraTex_left;

	private RenderTexture cameraTex_right;

	private bool cameraPreview;

	private void Start()
	{
		CreateTexture();
	}

	private void Update()
	{
		if (Input.GetKey(KeyCode.JoystickButton0))
		{
			DrawTexture();
		}
	}

	private void OnDestory()
	{
		if (cameraPreview)
		{
			cameraPreview = false;
			BoundarySystem.UPvr_StopCameraFrame();
		}
	}

	private void CreateTexture()
	{
		width = 600;
		height = 600;
		BoundarySystem.UPvr_BoundarySetCameraImageRect(width, height);
		cameraTex_left = new RenderTexture(width, height, 24, RenderTextureFormat.Default);
		cameraTex_right = new RenderTexture(width, height, 24, RenderTextureFormat.Default);
		cameraTex_left.Create();
		cameraTex_right.Create();
		viewImage_left.texture = cameraTex_left;
		viewImage_right.texture = cameraTex_right;
	}

	private void DrawTexture()
	{
		if (!cameraPreview)
		{
			cameraPreview = true;
			BoundarySystem.UPvr_StartCameraFrame();
		}
		BoundarySystem.UPvr_BoundaryGetSeeThroughData(0, cameraTex_left);
		BoundarySystem.UPvr_BoundaryGetSeeThroughData(1, cameraTex_right);
	}
}
public class OverlayExternalSurfaceDemo : MonoBehaviour
{
	public string movieName;

	public Pvr_UnitySDKEyeOverlay.OverlayType overlayType;

	public Pvr_UnitySDKEyeOverlay.OverlayShape overlayShape;

	private Pvr_UnitySDKEyeOverlay overlay;

	private const string TAG = "[ExternalSurface]>>>>>>";

	private void Awake()
	{
		overlay = GetComponent<Pvr_UnitySDKEyeOverlay>();
		if (overlay == null)
		{
			UnityEngine.Debug.LogError("[ExternalSurface]>>>>>>Overlay is null!");
			overlay = base.gameObject.AddComponent<Pvr_UnitySDKEyeOverlay>();
		}
		overlay.overlayType = overlayType;
		overlay.overlayShape = overlayShape;
		overlay.isExternalAndroidSurface = true;
	}

	private void Start()
	{
		if (!string.IsNullOrEmpty(movieName))
		{
			StartPlay(Application.streamingAssetsPath + "/" + movieName, null);
		}
	}

	private void StartPlay(string moviePath, string licenceUrl)
	{
		if (moviePath != string.Empty)
		{
			if (overlay.isExternalAndroidSurface)
			{
				Pvr_UnitySDKEyeOverlay.ExternalAndroidSurfaceObjectCreated externalAndroidSurfaceObjectCreated = delegate
				{
					UnityEngine.Debug.Log("[ExternalSurface]>>>>>>SurfaceObject created callback is Invoke().");
				};
				if (overlay.externalAndroidSurfaceObject == IntPtr.Zero)
				{
					UnityEngine.Debug.Log("[ExternalSurface]>>>>>>Register surfaceObject crreated callback");
					overlay.externalAndroidSurfaceObjectCreated = externalAndroidSurfaceObjectCreated;
				}
				else
				{
					UnityEngine.Debug.Log("[ExternalSurface]>>>>>>SurfaceObject is already created! Invoke callback");
					externalAndroidSurfaceObjectCreated();
				}
			}
		}
		else
		{
			UnityEngine.Debug.LogError("[ExternalSurface]>>>>>>Movie path is null!");
		}
	}
}
public class MoveCylinder : MonoBehaviour
{
	private Vector3 startingPosition;

	private Quaternion startingRotation;

	private void Start()
	{
		startingPosition = base.transform.localPosition;
		startingRotation = base.transform.rotation;
	}

	public void Reset()
	{
		base.transform.localPosition = startingPosition;
		base.transform.rotation = startingRotation;
	}
}
[RequireComponent(typeof(Collider))]
public class MoveSphere : MonoBehaviour
{
	private Vector3 startingPosition;

	private void Start()
	{
		startingPosition = base.transform.localPosition;
		SetGazedAt(gazedAt: false);
		base.gameObject.GetComponent<Rigidbody>().AddForce(Vector3.right * 120f);
	}

	private void OnTriggerEnter(Collider other)
	{
	}

	public void SetGazedAt(bool gazedAt)
	{
		GetComponent<Renderer>().material.color = (gazedAt ? Color.yellow : Color.blue);
	}

	public void Reset()
	{
		base.transform.localPosition = startingPosition;
		SetGazedAt(gazedAt: false);
		base.gameObject.GetComponent<Rigidbody>().Sleep();
		base.gameObject.GetComponent<Rigidbody>().AddForce(Vector3.right * 120f);
	}

	public void TeleportRandomly()
	{
		Vector3 onUnitSphere = UnityEngine.Random.onUnitSphere;
		onUnitSphere.y = Mathf.Clamp(onUnitSphere.y, 0.5f, 1f);
		float num = 2f * UnityEngine.Random.value + 1.5f;
		base.transform.localPosition = onUnitSphere * num;
	}
}
public class Resetbutton : MonoBehaviour
{
	public void DemoResetTracking()
	{
		if (Pvr_UnitySDKSensor.Instance != null)
		{
			Pvr_UnitySDKSensor.Instance.ResetUnitySDKSensor();
		}
	}
}
public class UserEntitlementCheck : MonoBehaviour
{
	private void OnEnable()
	{
		Pvr_UnitySDKManager.EntitlementCheckResultEvent += HandelEntitlementCheckResult;
	}

	private void OnDisable()
	{
		Pvr_UnitySDKManager.EntitlementCheckResultEvent -= HandelEntitlementCheckResult;
	}

	private void HandelEntitlementCheckResult(int resultCode)
	{
		UnityEngine.Debug.Log("The User Entitlement Check Result is :" + resultCode);
		switch (resultCode)
		{
		case 0:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: success");
			break;
		case -1:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: invalid params");
			break;
		case -2:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: service not exist");
			break;
		case -3:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: bind failed");
			break;
		case -4:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: exception");
			break;
		case -5:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: timeout");
			break;
		case 10:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: missing package name");
			break;
		case 11:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: missing appid");
			break;
		case 13:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: appid and package name not match");
			break;
		case 20:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: not login");
			break;
		case 21:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: not pay");
			break;
		case 31:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: invalid sn");
			break;
		default:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: unknown");
			break;
		}
	}
}
public class Pvr_SQPLoader : MonoBehaviour
{
	private struct SceneInfo
	{
		public List<string> scenes;

		public long version;

		public SceneInfo(List<string> sceneList, long currentSceneEpochVersion)
		{
			scenes = sceneList;
			version = currentSceneEpochVersion;
		}
	}

	public const string RESOURCE_BUNDLE_NAME = "asset_resources";

	public const string EXTERNAL_STORAGE_PATH = "/sdcard/Android/data";

	public const string SCENE_LOAD_DATA_NAME = "SceneLoadData.txt";

	private const string SQP_INDEX_NAME = "PvrSQPIndex";

	private const string CACHE_SCENES_PATH = "cache/scenes";

	private UnityEngine.AsyncOperation loadSceneOperation;

	private string scenePath = "";

	private string sceneLoadDataPath = "";

	private List<AssetBundle> loadedAssetBundles = new List<AssetBundle>();

	private SceneInfo currentSceneInfo;

	private void Awake()
	{
		UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
	}

	private void Start()
	{
		string path = Path.Combine("/sdcard/Android/data", Application.identifier);
		scenePath = Path.Combine(path, "cache/scenes");
		sceneLoadDataPath = Path.Combine(scenePath, "SceneLoadData.txt");
		currentSceneInfo = GetSceneInfo();
		if (currentSceneInfo.version != 0L && !string.IsNullOrEmpty(currentSceneInfo.scenes[0]))
		{
			LoadScene(currentSceneInfo);
		}
	}

	public void Update()
	{
	}

	private SceneInfo GetSceneInfo()
	{
		SceneInfo result = default(SceneInfo);
		try
		{
			StreamReader streamReader = new StreamReader(sceneLoadDataPath);
			result.version = Convert.ToInt64(streamReader.ReadLine());
			List<string> list = new List<string>();
			while (!streamReader.EndOfStream)
			{
				list.Add(streamReader.ReadLine());
			}
			result.scenes = list;
		}
		catch
		{
		}
		return result;
	}

	private void LoadScene(SceneInfo sceneInfo)
	{
		AssetBundle assetBundle = null;
		string[] files = Directory.GetFiles(scenePath, "*_*");
		string text = "scene_" + sceneInfo.scenes[0].ToLower();
		try
		{
			string[] array = files;
			for (int i = 0; i < array.Length; i++)
			{
				AssetBundle assetBundle2 = AssetBundle.LoadFromFile(array[i]);
				if (assetBundle2 != null)
				{
					UnityEngine.Debug.Log(("[PVRSceneLoader] Loading file bundle: " + assetBundle2.name == null) ? "null" : assetBundle2.name);
					loadedAssetBundles.Add(assetBundle2);
				}
				else
				{
					UnityEngine.Debug.LogError("[PVRSceneLoader] Loading file bundle failed");
				}
				if (assetBundle2.name == text)
				{
					assetBundle = assetBundle2;
				}
				_ = assetBundle2.name == "asset_resources";
			}
		}
		catch (Exception)
		{
			return;
		}
		if (assetBundle != null)
		{
			string fileNameWithoutExtension = Path.GetFileNameWithoutExtension(assetBundle.GetAllScenePaths()[0]);
			loadSceneOperation = SceneManager.LoadSceneAsync(fileNameWithoutExtension);
			loadSceneOperation.completed += LoadSceneOperation_completed;
		}
	}

	private void LoadSceneOperation_completed(UnityEngine.AsyncOperation obj)
	{
		StartCoroutine(onCheckNewSceneCoroutine());
	}

	private IEnumerator onCheckNewSceneCoroutine()
	{
		while (GetSceneInfo().version == currentSceneInfo.version)
		{
			yield return new WaitForSeconds(0f);
		}
		UnityEngine.Debug.Log("Scene change detected.");
		foreach (AssetBundle loadedAssetBundle in loadedAssetBundles)
		{
			if (loadedAssetBundle != null)
			{
				loadedAssetBundle.Unload(unloadAllLoadedObjects: true);
			}
		}
		loadedAssetBundles.Clear();
		int sceneCount = SceneManager.sceneCount;
		for (int i = 0; i < sceneCount; i++)
		{
			SceneManager.UnloadSceneAsync(SceneManager.GetSceneAt(i));
		}
		GameObject[] array = Resources.FindObjectsOfTypeAll(typeof(GameObject)) as GameObject[];
		for (int j = 0; j < array.Length; j++)
		{
			UnityEngine.Object.Destroy(array[j]);
		}
		SceneManager.LoadSceneAsync("PvrSQPIndex");
	}
}
public class Pvr_UnitySDKHeadTrack : MonoBehaviour
{
	[Tooltip("If true, head tracking will affect the rotation of each Pvr_UnitySDK's cameras.")]
	public bool trackRotation = true;

	[Tooltip("If true, head tracking will affect the position of each Pvr_UnitySDK's cameras.")]
	public bool trackPosition = true;

	public Transform target;

	private bool updated;

	private bool dataClock;

	public Ray Gaze
	{
		get
		{
			UpdateHead();
			return new Ray(base.transform.position, base.transform.forward);
		}
	}

	private void Update()
	{
		updated = false;
		UpdateHead();
	}

	private void UpdateHead()
	{
		if (updated)
		{
			return;
		}
		updated = true;
		if (Pvr_UnitySDKManager.SDK == null)
		{
			return;
		}
		if (trackRotation)
		{
			Quaternion orientation = Pvr_UnitySDKSensor.Instance.HeadPose.Orientation;
			if (target == null)
			{
				base.transform.localRotation = orientation;
			}
			else
			{
				base.transform.rotation = orientation * target.rotation;
			}
		}
		else
		{
			Quaternion orientation2 = Pvr_UnitySDKSensor.Instance.HeadPose.Orientation;
			if (target == null)
			{
				base.transform.localRotation = Quaternion.identity;
			}
			else
			{
				base.transform.rotation = orientation2 * target.rotation;
			}
		}
		if (trackPosition)
		{
			Vector3 position = Pvr_UnitySDKSensor.Instance.HeadPose.Position;
			if (target == null)
			{
				base.transform.localPosition = position;
			}
			else
			{
				base.transform.position = target.position + target.rotation * position;
			}
		}
	}
}
public class Pvr_UnitySDKPose
{
	protected static readonly Matrix4x4 flipZ = Matrix4x4.Scale(new Vector3(1f, 1f, -1f));

	public Matrix4x4 RightHandedMatrix => flipZ * Matrix * flipZ;

	public Vector3 Position { get; protected set; }

	public Quaternion Orientation { get; protected set; }

	public Matrix4x4 Matrix { get; protected set; }

	public Pvr_UnitySDKPose(Matrix4x4 matrix)
	{
		Set(matrix);
	}

	public Pvr_UnitySDKPose(Vector3 position, Quaternion orientation)
	{
		Set(position, orientation);
	}

	public void Set(Vector3 position, Quaternion orientation)
	{
		Position = position;
		Orientation = orientation;
		Matrix = Matrix4x4.TRS(position, orientation, Vector3.one);
	}

	protected void Set(Matrix4x4 matrix)
	{
		Matrix = matrix;
		Position = matrix.GetColumn(3);
		Orientation = Quaternion.LookRotation(matrix.GetColumn(2), matrix.GetColumn(1));
	}

	private Quaternion NormalizeQuaternion(ref Quaternion q)
	{
		float num = 0f;
		for (int i = 0; i < 4; i++)
		{
			num += q[i] * q[i];
		}
		float num2 = 1f / Mathf.Sqrt(num);
		for (int j = 0; j < 4; j++)
		{
			q[j] *= num2;
		}
		return q;
	}
}
public class Pvr_UnitySDKSensor
{
	public delegate void Enter3DofModel();

	public delegate void Exit3DofModel();

	private static Pvr_UnitySDKSensor instance;

	private bool SensorStart;

	private bool SensorInit;

	private Quaternion UnityQuaternion = Quaternion.identity;

	private Vector3 UnityPosition = Vector3.zero;

	private Sensorindex sensorIndex;

	private bool dofClock;

	public static Action EyeFovChanged;

	public Pvr_UnitySDKPose HeadPose;

	private float vfov = 102f;

	private float hfov = 102f;

	private float w;

	private float x;

	private float y;

	private float z;

	private float px;

	private float py;

	private float pz;

	public static Pvr_UnitySDKSensor Instance
	{
		get
		{
			if (instance == null)
			{
				instance = new Pvr_UnitySDKSensor();
			}
			return instance;
		}
		set
		{
			instance = value;
		}
	}

	public static event Enter3DofModel Enter3DofModelEvent;

	public static event Exit3DofModel Exit3DofModelEvent;

	public Pvr_UnitySDKSensor()
	{
		Init();
	}

	public void Init()
	{
		InitUnitySDK6DofSensor();
		SensorInit = InitUnitySDKSensor();
		SensorStart = StartUnitySDKSensor();
		HeadPose = new Pvr_UnitySDKPose(Vector3.zero, Quaternion.identity);
	}

	public void SensorUpdate()
	{
		if (GetUnitySDKSensorState())
		{
			HeadPose.Set(UnityPosition, UnityQuaternion);
		}
	}

	public bool InitUnitySDKSensor()
	{
		bool result = false;
		try
		{
			if (Sensor.UPvr_Init((int)sensorIndex) == 0)
			{
				result = true;
			}
		}
		catch (Exception ex)
		{
			PLOG.E("InitUnitySDKSensor ERROR! " + ex.Message);
			throw;
		}
		return result;
	}

	public bool InitUnitySDK6DofSensor()
	{
		bool result = false;
		try
		{
			int res = 0;
			Render.UPvr_GetIntConfig(3, ref res);
			if (res == 1)
			{
				if (Sensor.UPvr_Enable6DofModule(!Pvr_UnitySDKManager.SDK.HmdOnlyrot) == 0 && !Pvr_UnitySDKManager.SDK.HmdOnlyrot)
				{
					result = true;
					Pvr_UnitySDKManager.SDK.PVRNeck = false;
				}
			}
			else
			{
				UnityEngine.Debug.LogWarning("This platform does not support 6 Dof !");
			}
		}
		catch (Exception ex)
		{
			PLOG.E("InitUnity6DofSDKSensor ERROR! " + ex.Message);
			throw;
		}
		return result;
	}

	public bool StartUnitySDKSensor()
	{
		bool result = false;
		try
		{
			if (Sensor.UPvr_StartSensor((int)sensorIndex) == 0)
			{
				result = true;
			}
		}
		catch (Exception ex)
		{
			PLOG.E("StartUnitySDKSensor ERROR! " + ex.Message);
			throw;
		}
		return result;
	}

	public bool StopUnitySDKSensor()
	{
		bool result = false;
		try
		{
			if (Sensor.UPvr_StopSensor((int)sensorIndex) == 0)
			{
				result = true;
			}
		}
		catch (Exception ex)
		{
			PLOG.E("StopUnitySDKSensor ERROR! " + ex.Message);
			throw;
		}
		return result;
	}

	public bool ResetUnitySDKSensor()
	{
		bool result = false;
		try
		{
			if (Sensor.UPvr_ResetSensor((int)sensorIndex) == 0)
			{
				result = true;
				PLOG.E("ResetUnitySDKSensor OK! ");
			}
		}
		catch (Exception ex)
		{
			PLOG.E("ResetUnitySDKSensor ERROR! " + ex.Message);
			throw;
		}
		return result;
	}

	public bool OptionalResetUnitySDKSensor(int resetRot, int resetPos)
	{
		bool result = false;
		try
		{
			if (Sensor.UPvr_OptionalResetSensor((int)sensorIndex, resetRot, resetPos) == 0)
			{
				result = true;
				UnityEngine.Debug.Log("PvrLog OptionalResetUnitySDKSensor OK!" + resetRot + resetPos);
			}
		}
		catch (Exception ex)
		{
			UnityEngine.Debug.LogError("OptionalResetUnitySDKSensor ERROR! " + ex.Message);
			throw;
		}
		return result;
	}

	public bool GetUnitySDKSensorState()
	{
		bool result = false;
		if (SensorInit && SensorStart)
		{
			try
			{
				int num = -1;
				if (Pvr_UnitySDKManager.SDK.ShowVideoSeethrough)
				{
					Pvr_BoundarySystem.Instance.CameraFramePtr = Pvr_BoundaryAPI.UPvr_GetCameraData_Ext();
					num = Pvr_BoundaryAPI.UPvr_GetMainSensorStateExt(ref x, ref y, ref z, ref w, ref px, ref py, ref pz, ref vfov, ref hfov, ref Pvr_UnitySDKRender.Instance.RenderviewNumber);
				}
				else
				{
					num = Sensor.UPvr_GetMainSensorState(ref x, ref y, ref z, ref w, ref px, ref py, ref pz, ref vfov, ref hfov, ref Pvr_UnitySDKRender.Instance.RenderviewNumber);
				}
				Pvr_UnitySDKManager.SDK.posStatus = Sensor.UPvr_Get6DofSensorQualityStatus();
				if (num == 0)
				{
					if (!Convert.ToBoolean(Pvr_UnitySDKManager.SDK.posStatus & 2))
					{
						if (!dofClock)
						{
							if (Pvr_UnitySDKSensor.Enter3DofModelEvent != null)
							{
								Pvr_UnitySDKSensor.Enter3DofModelEvent();
							}
							dofClock = true;
						}
					}
					else if (dofClock)
					{
						if (Pvr_UnitySDKSensor.Exit3DofModelEvent != null)
						{
							Pvr_UnitySDKSensor.Exit3DofModelEvent();
						}
						dofClock = false;
					}
					RefreshHeadData(x, y, z, w, px, py, pz);
					UnityQuaternion.Set(x, y, 0f - z, 0f - w);
					if (Pvr_UnitySDKRender.Instance.EyeVFoV != vfov)
					{
						Pvr_UnitySDKRender.Instance.EyeVFoV = vfov;
						if (EyeFovChanged != null)
						{
							EyeFovChanged();
						}
					}
					Pvr_UnitySDKRender.Instance.EyeHFoV = hfov;
					Pvr_UnitySDKManager.SDK.EyesAspect = hfov / vfov;
					result = true;
					if (Pvr_UnitySDKManager.SDK.HmdOnlyrot)
					{
						if (Pvr_UnitySDKManager.SDK.PVRNeck)
						{
							if (Pvr_UnitySDKManager.SDK.TrackingOrigin == TrackingOrigin.FloorLevel)
							{
								UnityPosition.Set(0f, py, 0f);
								UnityPosition += UnityQuaternion * Pvr_UnitySDKManager.SDK.neckOffset - Pvr_UnitySDKManager.SDK.neckOffset.y * Vector3.up;
							}
							else
							{
								UnityPosition = UnityQuaternion * Pvr_UnitySDKManager.SDK.neckOffset - Pvr_UnitySDKManager.SDK.neckOffset.y * Vector3.up;
							}
						}
					}
					else
					{
						UnityPosition.Set(px, py, 0f - pz);
					}
					if (PLOG.logLevel > 2)
					{
						PLOG.D("posStatus=" + Pvr_UnitySDKManager.SDK.posStatus);
						PLOG.D("PvrLog 6DoFHeadRotation:" + x + "," + y + "," + (0f - z) + "," + (0f - w) + ",Position:" + px + "," + py + "," + (0f - pz) + ",eulerAngles:" + UnityQuaternion.eulerAngles);
					}
				}
				if (num == -1)
				{
					PLOG.I("PvrLog Sensor update --- GetUnitySDKSensorState  -1 ");
				}
			}
			catch (Exception ex)
			{
				PLOG.E("GetUnitySDKSensorState ERROR! " + ex.Message);
				throw;
			}
		}
		return result;
	}

	public bool GetUnitySDKPSensorState()
	{
		bool result = false;
		try
		{
			if (Sensor.UPvr_ResetSensor((int)sensorIndex) == 0)
			{
				result = true;
			}
		}
		catch (Exception ex)
		{
			PLOG.E("GetUnitySDKPSensorState ERROR! " + ex.Message);
			throw;
		}
		return result;
	}

	private void RefreshHeadData(float x, float y, float z, float w, float px, float py, float pz)
	{
		Pvr_UnitySDKManager.SDK.headData[0] = x;
		Pvr_UnitySDKManager.SDK.headData[1] = y;
		Pvr_UnitySDKManager.SDK.headData[2] = z;
		Pvr_UnitySDKManager.SDK.headData[3] = w;
		Pvr_UnitySDKManager.SDK.headData[4] = px;
		Pvr_UnitySDKManager.SDK.headData[5] = py;
		Pvr_UnitySDKManager.SDK.headData[6] = pz;
	}
}
public class CLoadingAsset : ScriptableObject
{
	public int SplashScreenType;

	public List<Texture2D> splashImage = new List<Texture2D>();

	public Texture2D Inside_background;

	public bool UseSplashText;

	public string DefaultText;

	public string ChineseText;

	public string EnglishText;

	public string JapaneseText;

	public string KoreanText;

	public string FontSize;

	public Color FontColor;

	public string TextHeight;

	public bool UseCarousel;

	public int SplashTextAlignment;
}
[Serializable]
public class Pvr_UnitySDKConfigProfile
{
	public struct Lenses
	{
		public float separation;

		public float offset;

		public float distance;

		public int alignment;

		public const int AlignTop = -1;

		public const int AlignCenter = 0;

		public const int AlignBottom = 1;
	}

	public struct MaxFOV
	{
		public float upper;

		public float lower;

		public float inner;

		public float outer;
	}

	public struct Distortion
	{
		public float k1;

		public float k2;

		public float k3;

		public float k4;

		public float k5;

		public float k6;

		public float distort(float r)
		{
			return 0f;
		}

		public float distort(float r, float dist)
		{
			float num = r * dist * 1000f;
			return (k1 * Mathf.Pow(num, 5f) + k2 * Mathf.Pow(num, 4f) + k3 * Mathf.Pow(num, 3f) + k4 * Mathf.Pow(num, 2f) + k5 * num + k6) / 1000f / dist;
		}

		public float diatortInv(float radious)
		{
			return 0f;
		}
	}

	public struct Device
	{
		public Lenses devLenses;

		public MaxFOV devMaxFov;

		public Distortion devDistortion;

		public Distortion devDistortionInv;
	}

	public static readonly Device SimulateDevice = new Device
	{
		devLenses = 
		{
			separation = 0.062f,
			offset = 0f,
			distance = 0.0403196f,
			alignment = 0
		},
		devMaxFov = 
		{
			upper = 40f,
			lower = 40f,
			inner = 40f,
			outer = 40f
		},
		devDistortion = 
		{
			k1 = 2.333E-06f,
			k2 = -0.000126f,
			k3 = 0.002978f,
			k4 = -0.02615f,
			k5 = 1.089f,
			k6 = -0.0337f
		},
		devDistortionInv = 
		{
			k1 = 1.342E-08f,
			k2 = 1.665E-06f,
			k3 = -0.0002797f,
			k4 = 0.001166f,
			k5 = 0.9945f,
			k6 = 0.004805f
		}
	};

	public Device device;

	public static readonly Pvr_UnitySDKConfigProfile Default = new Pvr_UnitySDKConfigProfile
	{
		device = SimulateDevice
	};

	public Pvr_UnitySDKConfigProfile Clone()
	{
		return new Pvr_UnitySDKConfigProfile
		{
			device = device
		};
	}

	public static Pvr_UnitySDKConfigProfile GetPicoProfile()
	{
		return new Pvr_UnitySDKConfigProfile
		{
			device = SimulateDevice
		};
	}

	public float[] GetLeftEyeVisibleTanAngles(float width, float height)
	{
		float val = (float)Math.Tan((double)(0f - device.devMaxFov.outer) * Math.PI / 180.0);
		float val2 = (float)Math.Tan((double)device.devMaxFov.upper * Math.PI / 180.0);
		float val3 = (float)Math.Tan((double)device.devMaxFov.inner * Math.PI / 180.0);
		float val4 = (float)Math.Tan((double)(0f - device.devMaxFov.lower) * Math.PI / 180.0);
		float num = width / 4f;
		float num2 = height / 2f;
		float num3 = device.devLenses.separation / 2f - num;
		float num4 = 0f;
		float distance = device.devLenses.distance;
		float val5 = device.devDistortion.distort((num3 - num) / distance, device.devLenses.distance);
		float val6 = device.devDistortion.distort((num4 + num2) / distance, device.devLenses.distance);
		float val7 = device.devDistortion.distort((num3 + num) / distance, device.devLenses.distance);
		float val8 = device.devDistortion.distort((num4 - num) / distance, device.devLenses.distance);
		float num5 = Math.Max(val, val5);
		float num6 = Math.Min(val2, val6);
		float num7 = Math.Min(val3, val7);
		float num8 = Math.Max(val4, val8);
		return new float[4] { num5, num6, num7, num8 };
	}

	public float[] GetLeftEyeNoLensTanAngles(float width, float height)
	{
		float val = device.devDistortionInv.distort((float)Math.Tan((double)(0f - device.devMaxFov.outer) * Math.PI / 180.0), device.devLenses.distance);
		float val2 = device.devDistortionInv.distort((float)Math.Tan((double)device.devMaxFov.upper * Math.PI / 180.0), device.devLenses.distance);
		float val3 = device.devDistortionInv.distort((float)Math.Tan((double)device.devMaxFov.inner * Math.PI / 180.0), device.devLenses.distance);
		float val4 = device.devDistortionInv.distort((float)Math.Tan((double)(0f - device.devMaxFov.lower) * Math.PI / 180.0), device.devLenses.distance);
		float num = width / 4f;
		float num2 = height / 2f;
		float num3 = device.devLenses.separation / 2f - num;
		float num4 = 0f;
		float distance = device.devLenses.distance;
		float val5 = (num3 - num) / distance;
		float val6 = (num4 + num2) / distance;
		float val7 = (num3 + num) / distance;
		float val8 = (num4 - num) / distance;
		float num5 = Math.Min(val, val5);
		float num6 = Math.Min(val2, val6);
		float num7 = Math.Min(val3, val7);
		float num8 = Math.Max(val4, val8);
		return new float[4] { num5, num6, num7, num8 };
	}

	public Rect GetLeftEyeVisibleScreenRect(float[] undistortedFrustum, float width, float height)
	{
		float distance = device.devLenses.distance;
		float num = (width - device.devLenses.separation) / 2f;
		float num2 = height / 2f;
		float num3 = (undistortedFrustum[0] * distance + num) / width;
		float num4 = (undistortedFrustum[1] * distance + num2) / height;
		float num5 = (undistortedFrustum[2] * distance + num) / width;
		float num6 = (undistortedFrustum[3] * distance + num2) / height;
		return new Rect(num3, num6, num5 - num3, num4 - num6);
	}
}
[RequireComponent(typeof(Text))]
public class Pvr_UnitySDKFPS : MonoBehaviour
{
	public Text fpsText;

	private float updateInterval = 0.5f;

	private float accum;

	private int frames;

	private float timeLeft;

	private string strFps;

	private void Update()
	{
		if (fpsText != null)
		{
			ShowFps();
		}
	}

	private void ShowFps()
	{
		timeLeft -= Time.unscaledDeltaTime;
		accum += Time.unscaledDeltaTime;
		frames++;
		if ((double)timeLeft <= 0.0)
		{
			float num = (float)frames / accum;
			strFps = $"FPS: {num:f0}";
			fpsText.text = strFps;
			timeLeft += updateInterval;
			accum = 0f;
			frames = 0;
		}
	}
}
public class Pvr_GazeFuse : MonoBehaviour
{
	public GameObject gazeGameObject;

	private Image image;

	private void Start()
	{
		image = GetComponent<Image>();
	}

	private void Update()
	{
		if (gazeGameObject == null || Pvr_GazeInputModule.gazeGameObject == gazeGameObject)
		{
			FuseAmountChanged(Pvr_GazeInputModule.gazeFraction);
		}
	}

	private void FuseAmountChanged(float fuseAmount)
	{
		if (image != null)
		{
			image.fillAmount = fuseAmount;
		}
	}
}
public class Pvr_GazeInputModule : PointerInputModule
{
	public enum Mode
	{
		Click,
		Gaze
	}

	public Mode mode;

	[Header("Click Settings")]
	public string ClickInputName = "Submit";

	[Header("Gaze Settings")]
	public float GazeTimeInSeconds = 2f;

	public RaycastResult CurrentRaycast;

	private PointerEventData pointerEventData;

	private GameObject currentLookAtHandler;

	private float currentLookAtHandlerClickTime;

	public static float gazeFraction { get; private set; }

	public static GameObject gazeGameObject { get; private set; }

	public override void Process()
	{
		HandleLook();
		HandleSelection();
	}

	private void HandleLook()
	{
		if (pointerEventData == null)
		{
			pointerEventData = new PointerEventData(base.eventSystem);
		}
		pointerEventData.position = new Vector2(Screen.width / 2, Screen.height / 2);
		pointerEventData.delta = Vector2.zero;
		List<RaycastResult> list = new List<RaycastResult>();
		base.eventSystem.RaycastAll(pointerEventData, list);
		RaycastResult currentRaycast = (pointerEventData.pointerCurrentRaycast = BaseInputModule.FindFirstRaycast(list));
		CurrentRaycast = currentRaycast;
		ProcessMove(pointerEventData);
	}

	private void HandleSelection()
	{
		gazeFraction = 0f;
		if (pointerEventData.pointerEnter != null)
		{
			GameObject eventHandler = ExecuteEvents.GetEventHandler<IPointerClickHandler>(pointerEventData.pointerEnter);
			if (currentLookAtHandler != eventHandler)
			{
				gazeGameObject = (currentLookAtHandler = eventHandler);
				currentLookAtHandlerClickTime = Time.realtimeSinceStartup + GazeTimeInSeconds;
			}
			if (mode == Mode.Gaze && currentLookAtHandler != null)
			{
				gazeFraction = Mathf.Clamp01(1f - (currentLookAtHandlerClickTime - Time.realtimeSinceStartup) / GazeTimeInSeconds);
			}
			if ((currentLookAtHandler != null && mode == Mode.Gaze && Time.realtimeSinceStartup > currentLookAtHandlerClickTime) || (mode == Mode.Click && Input.GetButtonDown(ClickInputName)))
			{
				_ = EventSystem.current.currentSelectedGameObject != null;
				EventSystem.current.SetSelectedGameObject(currentLookAtHandler);
				gazeFraction = 0f;
				ExecuteEvents.ExecuteHierarchy(currentLookAtHandler, pointerEventData, ExecuteEvents.pointerClickHandler);
				currentLookAtHandlerClickTime = float.MaxValue;
				ExecuteEvents.ExecuteHierarchy(EventSystem.current.currentSelectedGameObject, pointerEventData, ExecuteEvents.deselectHandler);
			}
		}
		else
		{
			gazeGameObject = (currentLookAtHandler = null);
		}
	}
}
[RequireComponent(typeof(Pvr_GazeInputModule))]
public class Pvr_GazeInputModuleCrosshair : MonoBehaviour
{
	public static bool DisplayCrosshair = true;

	[Tooltip("Crosshair GameObject attached to your VR Camera")]
	public Transform Crosshair;

	private Pvr_GazeInputModule gazeInputModule;

	private Vector3 CrosshairOriginalScale;

	private float CrosshairOriginalDistance;

	private void Awake()
	{
		gazeInputModule = GetComponent<Pvr_GazeInputModule>();
	}

	private void Start()
	{
		CrosshairOriginalScale = Crosshair.localScale;
		CrosshairOriginalDistance = Crosshair.localPosition.z;
		Crosshair.gameObject.SetActive(value: false);
	}

	private void Update()
	{
		Crosshair.gameObject.SetActive(DisplayCrosshair);
		if (DisplayCrosshair)
		{
			float crossHairAtDistance = CrosshairOriginalDistance;
			if (gazeInputModule.CurrentRaycast.isValid)
			{
				crossHairAtDistance = gazeInputModule.CurrentRaycast.distance * 0.8f - 0.5f;
			}
			SetCrossHairAtDistance(crossHairAtDistance);
		}
	}

	private void SetCrossHairAtDistance(float dist)
	{
		Vector3 localPosition = Crosshair.localPosition;
		Crosshair.localPosition = new Vector3(localPosition.x, localPosition.y, dist);
		Crosshair.localScale = CrosshairOriginalScale * dist;
	}
}
public enum RenderEventType
{
	InitRenderThread = 1024,
	Pause,
	Resume,
	LeftEyeEndFrame,
	RightEyeEndFrame,
	TimeWarp,
	ResetVrModeParms,
	ShutdownRenderThread,
	BeginEye,
	EndEye,
	BoundaryRenderLeft,
	BoundaryRenderRight,
	BothEyeEndFrame,
	CameraFrameLeft,
	CameraFrameRight,
	StartCameraFrame,
	StopCameraFrame
}
public static class Pvr_UnitySDKPluginEvent
{
	private delegate void RenderEventDelegate(int eventId);

	private const uint IS_DATA_FLAG = 2147483648u;

	private const uint DATA_POS_MASK = 1073741824u;

	private const int DATA_POS_SHIFT = 30;

	private const uint EVENT_TYPE_MASK = 1056899072u;

	private const int EVENT_TYPE_SHIFT = 17;

	private const uint PAYLOAD_MASK = 65535u;

	private const int PAYLOAD_SHIFT = 16;

	private static RenderEventDelegate SetSinglePassBeforeForwardOpaqueHandle = SetSinglePassBeforeForwardOpaque;

	private static IntPtr SetSinglePassBeforeForwardOpaquePtr = Marshal.GetFunctionPointerForDelegate(SetSinglePassBeforeForwardOpaqueHandle);

	public static void Issue(RenderEventType eventType)
	{
		GL.IssuePluginEvent(Pvr_UnitySDKAPI.System.GetRenderEventFunc(), (int)eventType);
	}

	private static int EncodeType(int eventType)
	{
		return eventType & 0x7FFFFFFF;
	}

	private static int EncodeData(int eventId, int eventData, int pos)
	{
		return int.MinValue | ((pos << 30) & 0x40000000) | ((eventId << 17) & 0x3EFF0000) | ((eventData >>> pos * 16) & 0xFFFF);
	}

	private static int DecodeData(int eventData)
	{
		uint num = (uint)(eventData & 0x40000000) >> 30;
		return (eventData & 0xFFFF) << (int)(16 * num);
	}

	[MonoPInvokeCallback(typeof(RenderEventDelegate))]
	private static void SetSinglePassBeforeForwardOpaque(int eventId)
	{
		Pvr_UnitySDKAPI.System.UPvr_SinglePassBeforeForwardOpaque();
	}

	public static void SetSinglePassBeforeForwardOpaque(CommandBuffer cmd)
	{
		cmd.IssuePluginEvent(SetSinglePassBeforeForwardOpaquePtr, 0);
	}
}
public class Pvr_UnitySDKSightInputModule : BaseInputModule
{
	[Tooltip("Optional object to place at raycast intersections as a 3D cursor. Be sure it is on a layer that raycasts will ignore.")]
	public GameObject cursor;

	public int trigger;

	[HideInInspector]
	public float clickTime = 0.1f;

	[HideInInspector]
	public Vector2 hotspot = new Vector2(0.5f, 0.5f);

	private PointerEventData pointerData;

	public override bool ShouldActivateModule()
	{
		if (!base.ShouldActivateModule())
		{
			return false;
		}
		return Pvr_UnitySDKManager.SDK.VRModeEnabled;
	}

	public override void DeactivateModule()
	{
		base.DeactivateModule();
		if (pointerData != null)
		{
			HandlePendingClick();
			HandlePointerExitAndEnter(pointerData, null);
			pointerData = null;
		}
		base.eventSystem.SetSelectedGameObject(null, GetBaseEventData());
		if (cursor != null)
		{
			cursor.SetActive(value: false);
		}
	}

	public override bool IsPointerOverGameObject(int pointerId)
	{
		if (pointerData != null)
		{
			return pointerData.pointerEnter != null;
		}
		return false;
	}

	public override void Process()
	{
		CastRayFromGaze();
		UpdateCurrentObject();
		PlaceCursor();
		HandlePendingClick();
		HandleTrigger();
	}

	private void CastRayFromGaze()
	{
		if (pointerData == null)
		{
			pointerData = new PointerEventData(base.eventSystem);
		}
		pointerData.Reset();
		pointerData.position = new Vector2(hotspot.x * (float)Screen.width, hotspot.y * (float)Screen.height);
		base.eventSystem.RaycastAll(pointerData, m_RaycastResultCache);
		pointerData.pointerCurrentRaycast = BaseInputModule.FindFirstRaycast(m_RaycastResultCache);
		m_RaycastResultCache.Clear();
	}

	private void UpdateCurrentObject()
	{
		GameObject gameObject = pointerData.pointerCurrentRaycast.gameObject;
		HandlePointerExitAndEnter(pointerData, gameObject);
		if (ExecuteEvents.GetEventHandler<ISelectHandler>(gameObject) == base.eventSystem.currentSelectedGameObject)
		{
			ExecuteEvents.Execute(base.eventSystem.currentSelectedGameObject, GetBaseEventData(), ExecuteEvents.updateSelectedHandler);
		}
		else
		{
			base.eventSystem.SetSelectedGameObject(null, pointerData);
		}
	}

	private void PlaceCursor()
	{
		if (!(cursor == null))
		{
			GameObject gameObject = pointerData.pointerCurrentRaycast.gameObject;
			cursor.SetActive(gameObject != null);
			if (cursor.activeInHierarchy)
			{
				Camera enterEventCamera = pointerData.enterEventCamera;
				float num = pointerData.pointerCurrentRaycast.distance + enterEventCamera.nearClipPlane - 0.1f;
				cursor.transform.position = enterEventCamera.transform.position + enterEventCamera.transform.forward * num;
			}
		}
	}

	private void HandlePendingClick()
	{
		if (pointerData.eligibleForClick && (Pvr_UnitySDKManager.SDK.picovrTriggered || !(Time.unscaledTime - pointerData.clickTime < clickTime)))
		{
			ExecuteEvents.Execute(pointerData.pointerPress, pointerData, ExecuteEvents.pointerUpHandler);
			ExecuteEvents.Execute(pointerData.pointerPress, pointerData, ExecuteEvents.pointerClickHandler);
			pointerData.pointerPress = null;
			pointerData.rawPointerPress = null;
			pointerData.eligibleForClick = false;
			pointerData.clickCount = 0;
		}
	}

	private void HandleTrigger()
	{
		if (Pvr_UnitySDKManager.SDK.picovrTriggered)
		{
			GameObject gameObject = pointerData.pointerCurrentRaycast.gameObject;
			if (!(gameObject == null) && !(ExecuteEvents.GetEventHandler<IPointerClickHandler>(gameObject) == null))
			{
				pointerData.pointerPress = ExecuteEvents.GetEventHandler<IPointerClickHandler>(gameObject);
				pointerData.pressPosition = pointerData.position;
				pointerData.pointerPressRaycast = pointerData.pointerCurrentRaycast;
				pointerData.pointerPress = ExecuteEvents.ExecuteHierarchy(gameObject, pointerData, ExecuteEvents.pointerDownHandler) ?? ExecuteEvents.GetEventHandler<IPointerClickHandler>(gameObject);
				pointerData.rawPointerPress = gameObject;
				pointerData.eligibleForClick = true;
				pointerData.clickCount = 1;
				pointerData.clickTime = Time.unscaledTime;
			}
		}
	}
}
public class Pvr_ObjImporter
{
	private static Pvr_ObjImporter _instance;

	private List<int> triangles;

	private List<Vector3> vertices;

	private List<Vector2> uv;

	private List<Vector3> normals;

	private List<PvrVector3Int> faceData;

	private List<int> intArray;

	private const int MIN_POW_10 = -16;

	private const int MAX_POW_10 = 16;

	private const int NUM_POWS_10 = 33;

	private static readonly float[] pow10 = GenerateLookupTable();

	public static Pvr_ObjImporter Instance => _instance ?? (_instance = new Pvr_ObjImporter());

	public Mesh ImportFile(string filePath)
	{
		triangles = new List<int>();
		vertices = new List<Vector3>();
		uv = new List<Vector2>();
		normals = new List<Vector3>();
		faceData = new List<PvrVector3Int>();
		intArray = new List<int>();
		LoadMeshData(filePath);
		Vector3[] array = new Vector3[faceData.Count];
		Vector2[] array2 = new Vector2[faceData.Count];
		Vector3[] array3 = new Vector3[faceData.Count];
		for (int i = 0; i < faceData.Count; i++)
		{
			array[i] = vertices[faceData[i].x - 1];
			if (faceData[i].y >= 1)
			{
				array2[i] = uv[faceData[i].y - 1];
			}
			if (faceData[i].z >= 1)
			{
				array3[i] = normals[faceData[i].z - 1];
			}
		}
		Mesh mesh = new Mesh();
		mesh.vertices = array;
		mesh.uv = array2;
		mesh.normals = array3;
		mesh.triangles = triangles.ToArray();
		mesh.RecalculateBounds();
		return mesh;
	}

	private void LoadMeshData(string fileName)
	{
		StringBuilder stringBuilder = new StringBuilder();
		string text = File.ReadAllText(fileName);
		int num = 0;
		string text2 = null;
		int num2 = 0;
		StringBuilder sbInt = new StringBuilder();
		for (int i = 0; i < text.Length; i++)
		{
			if (text[i] != '\n')
			{
				continue;
			}
			stringBuilder.Remove(0, stringBuilder.Length);
			stringBuilder.Append(text, num + 1, i - num);
			num = i;
			if (stringBuilder[0] == 'o' && stringBuilder[1] == ' ')
			{
				sbInt.Remove(0, sbInt.Length);
				for (int j = 2; j < stringBuilder.Length; j++)
				{
					text2 += stringBuilder[j];
				}
			}
			else if (stringBuilder[0] == 'v' && stringBuilder[1] == ' ')
			{
				int start = 2;
				vertices.Add(new Vector3(GetFloat(stringBuilder, ref start, ref sbInt), GetFloat(stringBuilder, ref start, ref sbInt), GetFloat(stringBuilder, ref start, ref sbInt)));
			}
			else if (stringBuilder[0] == 'v' && stringBuilder[1] == 't' && stringBuilder[2] == ' ')
			{
				int start2 = 3;
				uv.Add(new Vector2(GetFloat(stringBuilder, ref start2, ref sbInt), GetFloat(stringBuilder, ref start2, ref sbInt)));
			}
			else if (stringBuilder[0] == 'v' && stringBuilder[1] == 'n' && stringBuilder[2] == ' ')
			{
				int start3 = 3;
				normals.Add(new Vector3(GetFloat(stringBuilder, ref start3, ref sbInt), GetFloat(stringBuilder, ref start3, ref sbInt), GetFloat(stringBuilder, ref start3, ref sbInt)));
			}
			else if (stringBuilder[0] == 'f' && stringBuilder[1] == ' ')
			{
				int start4 = 2;
				int num3 = 1;
				intArray.Clear();
				int num4 = 0;
				while (start4 < stringBuilder.Length && char.IsDigit(stringBuilder[start4]))
				{
					faceData.Add(new PvrVector3Int(GetInt(stringBuilder, ref start4, ref sbInt), GetInt(stringBuilder, ref start4, ref sbInt), GetInt(stringBuilder, ref start4, ref sbInt)));
					num3++;
					intArray.Add(num2);
					num2++;
				}
				num4 += num3;
				for (num3 = 1; num3 + 2 < num4; num3++)
				{
					triangles.Add(intArray[0]);
					triangles.Add(intArray[num3]);
					triangles.Add(intArray[num3 + 1]);
				}
			}
		}
	}

	private float GetFloat(StringBuilder sb, ref int start, ref StringBuilder sbFloat)
	{
		sbFloat.Remove(0, sbFloat.Length);
		while (start < sb.Length && (char.IsDigit(sb[start]) || sb[start] == '-' || sb[start] == '.'))
		{
			sbFloat.Append(sb[start]);
			start++;
		}
		start++;
		return ParseFloat(sbFloat);
	}

	private int GetInt(StringBuilder sb, ref int start, ref StringBuilder sbInt)
	{
		sbInt.Remove(0, sbInt.Length);
		while (start < sb.Length && char.IsDigit(sb[start]))
		{
			sbInt.Append(sb[start]);
			start++;
		}
		start++;
		return IntParseFast(sbInt);
	}

	private static float[] GenerateLookupTable()
	{
		float[] array = new float[320];
		for (int i = 0; i < array.Length; i++)
		{
			array[i] = (float)(i / 33) * Mathf.Pow(10f, i % 33 + -16);
		}
		return array;
	}

	private float ParseFloat(StringBuilder value)
	{
		float num = 0f;
		bool flag = false;
		int length = value.Length;
		int num2 = value.Length;
		for (int num3 = length - 1; num3 >= 0; num3--)
		{
			if (value[num3] == '.')
			{
				num2 = num3;
				break;
			}
		}
		int num4 = 16 + num2;
		for (int i = 0; i < num2; i++)
		{
			if (i != num2 && value[i] != '-')
			{
				num += pow10[(value[i] - 48) * 33 + num4 - i - 1];
			}
			else if (value[i] == '-')
			{
				flag = true;
			}
		}
		for (int j = num2 + 1; j < length; j++)
		{
			if (j != num2)
			{
				num += pow10[(value[j] - 48) * 33 + num4 - j];
			}
		}
		if (flag)
		{
			num = 0f - num;
		}
		return num;
	}

	private int IntParseFast(StringBuilder value)
	{
		int num = 0;
		for (int i = 0; i < value.Length; i++)
		{
			num = 10 * num + (value[i] - 48);
		}
		return num;
	}
}
public sealed class PvrVector3Int
{
	public int x { get; set; }

	public int y { get; set; }

	public int z { get; set; }

	public PvrVector3Int()
	{
	}

	public PvrVector3Int(int x, int y, int z)
	{
		this.x = x;
		this.y = y;
		this.z = z;
	}
}
public class Pvr_EnumFlags : PropertyAttribute
{
}
public enum ConfirmBtn
{
	App = 1,
	TouchPad = 2,
	Trigger = 4
}
public class Pvr_InputModule : PointerInputModule
{
	public static List<Pvr_UIPointer> pointers = new List<Pvr_UIPointer>();

	[Pvr_EnumFlags]
	public ConfirmBtn confirmBtn = ConfirmBtn.TouchPad;

	private List<RaycastResult> rayCasts = new List<RaycastResult>();

	private RaycastResult rayCastResult;

	public virtual void Initialise()
	{
		pointers.Clear();
	}

	public static void AddPoint(Pvr_UIPointer point)
	{
		if (!pointers.Contains(point))
		{
			pointers.Add(point);
		}
	}

	public static void RemovePoint(Pvr_UIPointer point)
	{
		if (pointers.Contains(point))
		{
			pointers.Remove(point);
		}
	}

	public override void Process()
	{
		if (Pvr_UnitySDKManager.SDK.isHasController)
		{
			if ((confirmBtn & ConfirmBtn.App) == ConfirmBtn.App)
			{
				Pvr_UIPointer.AppBtnValue = Controller.UPvr_GetKey(Pvr_ControllerManager.controllerlink.mainHandID, Pvr_KeyCode.APP);
			}
			if ((confirmBtn & ConfirmBtn.TouchPad) == ConfirmBtn.TouchPad)
			{
				Pvr_UIPointer.TouchBtnValue = Controller.UPvr_GetKey(Pvr_ControllerManager.controllerlink.mainHandID, Pvr_KeyCode.TOUCHPAD);
			}
			if ((confirmBtn & ConfirmBtn.Trigger) == ConfirmBtn.Trigger)
			{
				Pvr_UIPointer.TriggerBtnValue = Controller.UPvr_GetKey(Pvr_ControllerManager.controllerlink.mainHandID, Pvr_KeyCode.TRIGGER);
			}
		}
		for (int i = 0; i < pointers.Count; i++)
		{
			Pvr_UIPointer pvr_UIPointer = pointers[i];
			if (pvr_UIPointer.gameObject.activeInHierarchy && pvr_UIPointer.enabled)
			{
				List<RaycastResult> results = new List<RaycastResult>();
				if (pvr_UIPointer.PointerActive())
				{
					results = CheckRaycasts(pvr_UIPointer);
				}
				Hover(pvr_UIPointer, results);
				Click(pvr_UIPointer, results);
				Drag(pvr_UIPointer, results);
			}
		}
	}

	protected virtual List<RaycastResult> CheckRaycasts(Pvr_UIPointer pointer)
	{
		rayCastResult.worldPosition = pointer.GetOriginPosition();
		rayCastResult.worldNormal = pointer.GetOriginForward();
		pointer.pointerEventData.pointerCurrentRaycast = rayCastResult;
		base.eventSystem.RaycastAll(pointer.pointerEventData, rayCasts);
		return rayCasts;
	}

	protected virtual bool CheckTransformTree(Transform target, Transform source)
	{
		if (target == null)
		{
			return false;
		}
		if (target.Equals(source))
		{
			return true;
		}
		return CheckTransformTree(target.transform.parent, source);
	}

	protected virtual bool NoValidCollision(Pvr_UIPointer pointer, List<RaycastResult> results)
	{
		if (results.Count != 0)
		{
			return !CheckTransformTree(results[0].gameObject.transform, pointer.pointerEventData.pointerEnter.transform);
		}
		return true;
	}

	protected virtual bool IsHovering(Pvr_UIPointer pointer)
	{
		foreach (GameObject item in pointer.pointerEventData.hovered)
		{
			if ((bool)pointer.pointerEventData.pointerEnter && (bool)item && CheckTransformTree(item.transform, pointer.pointerEventData.pointerEnter.transform))
			{
				return true;
			}
		}
		return false;
	}

	protected virtual bool ValidElement(GameObject obj)
	{
		Pvr_UICanvas componentInParent = obj.GetComponentInParent<Pvr_UICanvas>();
		if (!componentInParent || !componentInParent.enabled)
		{
			return false;
		}
		return true;
	}

	protected virtual void CheckPointerHoverClick(Pvr_UIPointer pointer, List<RaycastResult> results)
	{
		if (pointer.hoverDurationTimer > 0f)
		{
			pointer.hoverDurationTimer -= Time.deltaTime;
		}
		if (pointer.canClickOnHover && pointer.hoverDurationTimer <= 0f)
		{
			pointer.canClickOnHover = false;
			ClickOnDown(pointer, results, forceClick: true);
		}
	}

	protected virtual void Hover(Pvr_UIPointer pointer, List<RaycastResult> results)
	{
		if ((bool)pointer.pointerEventData.pointerEnter)
		{
			CheckPointerHoverClick(pointer, results);
			if (!ValidElement(pointer.pointerEventData.pointerEnter))
			{
				pointer.pointerEventData.pointerEnter = null;
				return;
			}
			if (NoValidCollision(pointer, results))
			{
				ExecuteEvents.ExecuteHierarchy(pointer.pointerEventData.pointerEnter, pointer.pointerEventData, ExecuteEvents.pointerExitHandler);
				pointer.pointerEventData.hovered.Remove(pointer.pointerEventData.pointerEnter);
				pointer.pointerEventData.pointerEnter = null;
			}
			if (results.Count <= 0 || !(pointer.pointerEventData.pointerEnter != results[0].gameObject))
			{
				return;
			}
			{
				foreach (RaycastResult result in results)
				{
					if (!ValidElement(result.gameObject))
					{
						continue;
					}
					GameObject gameObject = ExecuteEvents.ExecuteHierarchy(result.gameObject, pointer.pointerEventData, ExecuteEvents.pointerEnterHandler);
					if (gameObject != null)
					{
						Selectable component = gameObject.GetComponent<Selectable>();
						if ((bool)component)
						{
							Navigation navigation = default(Navigation);
							navigation.mode = Navigation.Mode.None;
							component.navigation = navigation;
						}
						pointer.pointerEventData.hovered.Remove(pointer.pointerEventData.pointerEnter);
						pointer.OnUIPointerElementEnter(pointer.SetUIPointerEvent(result, gameObject, pointer.hoveringElement));
						pointer.hoveringElement = gameObject;
						pointer.pointerEventData.pointerCurrentRaycast = result;
						pointer.pointerEventData.pointerEnter = gameObject;
						pointer.pointerEventData.hovered.Add(pointer.pointerEventData.pointerEnter);
						break;
					}
					if (result.gameObject != pointer.hoveringElement)
					{
						pointer.OnUIPointerElementEnter(pointer.SetUIPointerEvent(result, result.gameObject, pointer.hoveringElement));
					}
					pointer.hoveringElement = result.gameObject;
				}
				return;
			}
		}
		foreach (RaycastResult result2 in results)
		{
			if (!ValidElement(result2.gameObject))
			{
				continue;
			}
			GameObject gameObject2 = ExecuteEvents.ExecuteHierarchy(result2.gameObject, pointer.pointerEventData, ExecuteEvents.pointerEnterHandler);
			if (gameObject2 != null)
			{
				Selectable component2 = gameObject2.GetComponent<Selectable>();
				if ((bool)component2)
				{
					Navigation navigation2 = default(Navigation);
					navigation2.mode = Navigation.Mode.None;
					component2.navigation = navigation2;
				}
				pointer.OnUIPointerElementEnter(pointer.SetUIPointerEvent(result2, gameObject2, pointer.hoveringElement));
				pointer.hoveringElement = gameObject2;
				pointer.pointerEventData.pointerCurrentRaycast = result2;
				pointer.pointerEventData.pointerEnter = gameObject2;
				pointer.pointerEventData.hovered.Add(pointer.pointerEventData.pointerEnter);
				break;
			}
			if (result2.gameObject != pointer.hoveringElement)
			{
				pointer.OnUIPointerElementEnter(pointer.SetUIPointerEvent(result2, result2.gameObject, pointer.hoveringElement));
			}
			pointer.hoveringElement = result2.gameObject;
		}
		if ((bool)pointer.hoveringElement && results.Count == 0)
		{
			pointer.OnUIPointerElementExit(pointer.SetUIPointerEvent(default(RaycastResult), null, pointer.hoveringElement));
			pointer.hoveringElement = null;
		}
	}

	protected virtual void Click(Pvr_UIPointer pointer, List<RaycastResult> results)
	{
		switch (pointer.clickMethod)
		{
		case Pvr_UIPointer.ClickMethods.ClickOnButtonUp:
			ClickOnUp(pointer, results);
			break;
		case Pvr_UIPointer.ClickMethods.ClickOnButtonDown:
			ClickOnDown(pointer, results);
			break;
		}
	}

	protected virtual void ClickOnUp(Pvr_UIPointer pointer, List<RaycastResult> results)
	{
		pointer.pointerEventData.eligibleForClick = pointer.ValidClick(checkLastClick: false);
		if (!AttemptClick(pointer))
		{
			IsEligibleClick(pointer, results);
		}
	}

	protected virtual void ClickOnDown(Pvr_UIPointer pointer, List<RaycastResult> results, bool forceClick = false)
	{
		pointer.pointerEventData.eligibleForClick = forceClick || pointer.ValidClick(checkLastClick: true);
		if (IsEligibleClick(pointer, results))
		{
			pointer.pointerEventData.eligibleForClick = false;
			AttemptClick(pointer);
		}
	}

	protected virtual bool IsEligibleClick(Pvr_UIPointer pointer, List<RaycastResult> results)
	{
		if (pointer.pointerEventData.eligibleForClick)
		{
			foreach (RaycastResult result in results)
			{
				if (ValidElement(result.gameObject))
				{
					GameObject gameObject = ExecuteEvents.ExecuteHierarchy(result.gameObject, pointer.pointerEventData, ExecuteEvents.pointerDownHandler);
					if (gameObject != null)
					{
						pointer.pointerEventData.pressPosition = pointer.pointerEventData.position;
						pointer.pointerEventData.pointerPressRaycast = result;
						pointer.pointerEventData.pointerPress = gameObject;
						return true;
					}
				}
			}
		}
		return false;
	}

	protected virtual bool AttemptClick(Pvr_UIPointer pointer)
	{
		if ((bool)pointer.pointerEventData.pointerPress)
		{
			if (!ValidElement(pointer.pointerEventData.pointerPress))
			{
				pointer.pointerEventData.pointerPress = null;
				return true;
			}
			if (pointer.pointerEventData.eligibleForClick)
			{
				if (!IsHovering(pointer))
				{
					ExecuteEvents.ExecuteHierarchy(pointer.pointerEventData.pointerPress, pointer.pointerEventData, ExecuteEvents.pointerUpHandler);
					pointer.pointerEventData.pointerPress = null;
				}
			}
			else
			{
				pointer.OnUIPointerElementClick(pointer.SetUIPointerEvent(pointer.pointerEventData.pointerPressRaycast, pointer.pointerEventData.pointerPress));
				ExecuteEvents.ExecuteHierarchy(pointer.pointerEventData.pointerPress, pointer.pointerEventData, ExecuteEvents.pointerClickHandler);
				ExecuteEvents.ExecuteHierarchy(pointer.pointerEventData.pointerPress, pointer.pointerEventData, ExecuteEvents.pointerUpHandler);
				pointer.pointerEventData.pointerPress = null;
			}
			return true;
		}
		return false;
	}

	protected virtual void Drag(Pvr_UIPointer pointer, List<RaycastResult> results)
	{
		pointer.pointerEventData.dragging = pointer.IsSelectionButtonPressed() && pointer.pointerEventData.delta != Vector2.zero;
		if ((bool)pointer.pointerEventData.pointerDrag)
		{
			if (!ValidElement(pointer.pointerEventData.pointerDrag))
			{
				pointer.pointerEventData.pointerDrag = null;
				return;
			}
			if (pointer.pointerEventData.dragging)
			{
				if (IsHovering(pointer))
				{
					ExecuteEvents.ExecuteHierarchy(pointer.pointerEventData.pointerDrag, pointer.pointerEventData, ExecuteEvents.dragHandler);
				}
				return;
			}
			ExecuteEvents.ExecuteHierarchy(pointer.pointerEventData.pointerDrag, pointer.pointerEventData, ExecuteEvents.dragHandler);
			ExecuteEvents.ExecuteHierarchy(pointer.pointerEventData.pointerDrag, pointer.pointerEventData, ExecuteEvents.endDragHandler);
			foreach (RaycastResult result in results)
			{
				ExecuteEvents.ExecuteHierarchy(result.gameObject, pointer.pointerEventData, ExecuteEvents.dropHandler);
			}
			pointer.pointerEventData.pointerDrag = null;
		}
		else
		{
			if (!pointer.pointerEventData.dragging)
			{
				return;
			}
			foreach (RaycastResult result2 in results)
			{
				if (ValidElement(result2.gameObject))
				{
					ExecuteEvents.ExecuteHierarchy(result2.gameObject, pointer.pointerEventData, ExecuteEvents.initializePotentialDrag);
					ExecuteEvents.ExecuteHierarchy(result2.gameObject, pointer.pointerEventData, ExecuteEvents.beginDragHandler);
					GameObject gameObject = ExecuteEvents.ExecuteHierarchy(result2.gameObject, pointer.pointerEventData, ExecuteEvents.dragHandler);
					if (gameObject != null)
					{
						pointer.pointerEventData.pointerDrag = gameObject;
						break;
					}
				}
			}
		}
	}
}
public class Pvr_UICanvas : MonoBehaviour
{
	public bool clickOnPointerCollision;

	public float autoActivateWithinDistance;

	protected BoxCollider canvasBoxCollider;

	protected Rigidbody canvasRigidBody;

	protected Coroutine draggablePanelCreation;

	protected const string CANVAS_DRAGGABLE_PANEL = "UICANVAS_DRAGGABLE_PANEL";

	protected virtual void OnEnable()
	{
		SetupCanvas();
	}

	protected virtual void OnDisable()
	{
		RemoveCanvas();
	}

	protected virtual void OnDestroy()
	{
		RemoveCanvas();
	}

	protected virtual void SetupCanvas()
	{
		Canvas component = GetComponent<Canvas>();
		if ((bool)component && component.renderMode == RenderMode.WorldSpace)
		{
			RectTransform component2 = component.GetComponent<RectTransform>();
			Vector2 sizeDelta = component2.sizeDelta;
			GraphicRaycaster component3 = component.gameObject.GetComponent<GraphicRaycaster>();
			Pvr_UIGraphicRaycaster pvr_UIGraphicRaycaster = component.gameObject.GetComponent<Pvr_UIGraphicRaycaster>();
			if (!pvr_UIGraphicRaycaster)
			{
				pvr_UIGraphicRaycaster = component.gameObject.AddComponent<Pvr_UIGraphicRaycaster>();
			}
			if ((bool)component3 && component3.enabled)
			{
				pvr_UIGraphicRaycaster.ignoreReversedGraphics = component3.ignoreReversedGraphics;
				pvr_UIGraphicRaycaster.blockingObjects = component3.blockingObjects;
				component3.enabled = false;
			}
			if (!component.gameObject.GetComponent<BoxCollider>())
			{
				float z = 0.1f / component2.localScale.z;
				canvasBoxCollider = component.gameObject.AddComponent<BoxCollider>();
				canvasBoxCollider.size = new Vector3(sizeDelta.x, sizeDelta.y, z);
				canvasBoxCollider.isTrigger = true;
			}
			if (!component.gameObject.GetComponent<Rigidbody>())
			{
				canvasRigidBody = component.gameObject.AddComponent<Rigidbody>();
				canvasRigidBody.isKinematic = true;
			}
			draggablePanelCreation = StartCoroutine(CreateDraggablePanel(component, sizeDelta));
		}
	}

	protected virtual IEnumerator CreateDraggablePanel(Canvas canvas, Vector2 canvasSize)
	{
		if ((bool)canvas && !canvas.transform.Find("UICANVAS_DRAGGABLE_PANEL"))
		{
			yield return null;
			GameObject obj = new GameObject("UICANVAS_DRAGGABLE_PANEL", typeof(RectTransform));
			obj.AddComponent<LayoutElement>().ignoreLayout = true;
			obj.AddComponent<Image>().color = Color.clear;
			obj.AddComponent<EventTrigger>();
			obj.transform.SetParent(canvas.transform);
			obj.GetComponent<RectTransform>().sizeDelta = canvasSize;
			obj.transform.localPosition = Vector3.zero;
			obj.transform.localRotation = Quaternion.identity;
			obj.transform.localScale = Vector3.one;
			obj.transform.SetAsFirstSibling();
		}
	}

	protected virtual void RemoveCanvas()
	{
		Canvas component = GetComponent<Canvas>();
		if ((bool)component)
		{
			GraphicRaycaster component2 = component.gameObject.GetComponent<GraphicRaycaster>();
			Pvr_UIGraphicRaycaster component3 = component.gameObject.GetComponent<Pvr_UIGraphicRaycaster>();
			if ((bool)component3)
			{
				UnityEngine.Object.Destroy(component3);
			}
			if ((bool)component2 && !component2.enabled)
			{
				component2.enabled = true;
			}
			if ((bool)canvasBoxCollider)
			{
				UnityEngine.Object.Destroy(canvasBoxCollider);
			}
			if ((bool)canvasRigidBody)
			{
				UnityEngine.Object.Destroy(canvasRigidBody);
			}
			StopCoroutine(draggablePanelCreation);
			Transform transform = component.transform.Find("UICANVAS_DRAGGABLE_PANEL");
			if ((bool)transform)
			{
				UnityEngine.Object.Destroy(transform.gameObject);
			}
		}
	}
}
public struct UIDraggableItemEventArgs
{
	public GameObject target;
}
public delegate void UIDraggableItemEventHandler(object sender, UIDraggableItemEventArgs e);
public class Pvr_UIDraggableItem : MonoBehaviour, IBeginDragHandler, IEventSystemHandler, IDragHandler, IEndDragHandler
{
	public bool restrictToDropZone;

	public bool restrictToOriginalCanvas;

	public float moveOffset = 0.1f;

	[HideInInspector]
	public GameObject validDropZone;

	protected RectTransform dragTransform;

	protected Vector3 startPosition;

	protected Quaternion startRotation;

	protected GameObject startDropZone;

	protected Transform startParent;

	protected Canvas startCanvas;

	protected CanvasGroup canvasGroup;

	protected Pvr_InputModule currentInputmodule;

	public event UIDraggableItemEventHandler DraggableItemDropped;

	public event UIDraggableItemEventHandler DraggableItemReset;

	public virtual void OnDraggableItemDropped(UIDraggableItemEventArgs e)
	{
		if (this.DraggableItemDropped != null)
		{
			this.DraggableItemDropped(this, e);
		}
	}

	public virtual void OnDraggableItemReset(UIDraggableItemEventArgs e)
	{
		if (this.DraggableItemReset != null)
		{
			this.DraggableItemReset(this, e);
		}
	}

	public void OnBeginDrag(PointerEventData eventData)
	{
		startPosition = base.transform.position;
		startRotation = base.transform.rotation;
		startParent = base.transform.parent;
		startCanvas = GetComponentInParent<Canvas>();
		canvasGroup.blocksRaycasts = false;
		if (restrictToDropZone)
		{
			startDropZone = GetComponentInParent<Pvr_UIDropZone>().gameObject;
			validDropZone = startDropZone;
		}
		SetDragPosition(eventData);
		Pvr_UIPointer pointer = GetPointer();
		if (pointer != null)
		{
			pointer.OnUIPointerElementDragStart(pointer.SetUIPointerEvent(pointer.pointerEventData.pointerPressRaycast, base.gameObject));
		}
	}

	public void OnDrag(PointerEventData eventData)
	{
		SetDragPosition(eventData);
	}

	public void OnEndDrag(PointerEventData eventData)
	{
		canvasGroup.blocksRaycasts = true;
		dragTransform = null;
		base.transform.position += base.transform.forward * moveOffset;
		bool flag = true;
		if (restrictToDropZone)
		{
			if (validDropZone != null && validDropZone != startDropZone)
			{
				base.transform.SetParent(validDropZone.transform);
			}
			else
			{
				ResetElement();
				flag = false;
			}
		}
		Canvas canvas = ((eventData.pointerEnter != null) ? eventData.pointerEnter.GetComponentInParent<Canvas>() : null);
		if (restrictToOriginalCanvas && canvas != null && canvas != startCanvas)
		{
			ResetElement();
			flag = false;
		}
		if (canvas == null)
		{
			ResetElement();
			flag = false;
		}
		if (flag)
		{
			Pvr_UIPointer pointer = GetPointer();
			if (pointer != null)
			{
				pointer.OnUIPointerElementDragEnd(pointer.SetUIPointerEvent(pointer.pointerEventData.pointerPressRaycast, base.gameObject));
			}
			OnDraggableItemDropped(SetEventPayload(validDropZone));
		}
		validDropZone = null;
		startParent = null;
		startCanvas = null;
	}

	protected virtual void OnEnable()
	{
		canvasGroup = GetComponent<CanvasGroup>();
		if (restrictToDropZone && GetComponentInParent<Pvr_UIDropZone>() == null)
		{
			base.enabled = false;
		}
		currentInputmodule = UnityEngine.Object.FindObjectOfType<Pvr_InputModule>();
	}

	protected virtual Pvr_UIPointer GetPointer()
	{
		foreach (Pvr_UIPointer pointer in Pvr_InputModule.pointers)
		{
			if (pointer.gameObject.activeInHierarchy && (bool)pointer)
			{
				return pointer;
			}
		}
		return null;
	}

	protected virtual void SetDragPosition(PointerEventData eventData)
	{
		if (eventData.pointerEnter != null && eventData.pointerEnter.transform as RectTransform != null)
		{
			dragTransform = eventData.pointerEnter.transform as RectTransform;
		}
		if (dragTransform != null && RectTransformUtility.ScreenPointToWorldPointInRectangle(dragTransform, eventData.position, eventData.pressEventCamera, out var worldPoint))
		{
			base.transform.position = worldPoint - base.transform.forward * moveOffset;
			base.transform.rotation = dragTransform.rotation;
		}
	}

	protected virtual void ResetElement()
	{
		base.transform.position = startPosition;
		base.transform.rotation = startRotation;
		base.transform.SetParent(startParent);
		OnDraggableItemReset(SetEventPayload(startParent.gameObject));
	}

	protected virtual UIDraggableItemEventArgs SetEventPayload(GameObject target)
	{
		UIDraggableItemEventArgs result = default(UIDraggableItemEventArgs);
		result.target = target;
		return result;
	}
}
public class Pvr_UIDropZone : MonoBehaviour, IPointerEnterHandler, IEventSystemHandler, IPointerExitHandler
{
	protected Pvr_UIDraggableItem droppableItem;

	public void OnPointerEnter(PointerEventData eventData)
	{
		if ((bool)eventData.pointerDrag)
		{
			Pvr_UIDraggableItem component = eventData.pointerDrag.GetComponent<Pvr_UIDraggableItem>();
			if ((bool)component && component.restrictToDropZone)
			{
				component.validDropZone = base.gameObject;
				droppableItem = component;
			}
		}
	}

	public void OnPointerExit(PointerEventData eventData)
	{
		if ((bool)droppableItem)
		{
			droppableItem.validDropZone = null;
		}
		droppableItem = null;
	}
}
public class Pvr_UIGraphicRaycaster : GraphicRaycaster
{
	protected Canvas currentCanvas;

	protected Vector2 lastKnownPosition;

	protected const float UI_CONTROL_OFFSET = 1E-05f;

	[NonSerialized]
	private static List<RaycastResult> s_RaycastResults = new List<RaycastResult>();

	protected virtual Canvas canvas
	{
		get
		{
			if (currentCanvas != null)
			{
				return currentCanvas;
			}
			currentCanvas = base.gameObject.GetComponent<Canvas>();
			return currentCanvas;
		}
	}

	public override void Raycast(PointerEventData eventData, List<RaycastResult> resultAppendList)
	{
		if (!(canvas == null))
		{
			Raycast(ray: new Ray(eventData.pointerCurrentRaycast.worldPosition, eventData.pointerCurrentRaycast.worldNormal), canvas: canvas, eventCamera: eventCamera, results: ref s_RaycastResults);
			SetNearestRaycast(ref eventData, ref resultAppendList, ref s_RaycastResults);
			s_RaycastResults.Clear();
		}
	}

	protected virtual void SetNearestRaycast(ref PointerEventData eventData, ref List<RaycastResult> resultAppendList, ref List<RaycastResult> raycastResults)
	{
		RaycastResult? raycastResult = null;
		for (int i = 0; i < raycastResults.Count; i++)
		{
			RaycastResult raycastResult2 = raycastResults[i];
			raycastResult2.index = resultAppendList.Count;
			if (!raycastResult.HasValue || raycastResult2.distance < raycastResult.Value.distance)
			{
				raycastResult = raycastResult2;
			}
			resultAppendList.Add(raycastResult2);
		}
		if (raycastResult.HasValue)
		{
			eventData.position = raycastResult.Value.screenPosition;
			eventData.delta = eventData.position - lastKnownPosition;
			lastKnownPosition = eventData.position;
			eventData.pointerCurrentRaycast = raycastResult.Value;
		}
	}

	protected virtual float GetHitDistance(Ray ray)
	{
		float result = float.MaxValue;
		if (canvas.renderMode != 0 && base.blockingObjects != 0)
		{
			float num = Vector3.Distance(ray.origin, canvas.transform.position);
			if (base.blockingObjects == BlockingObjects.ThreeD || base.blockingObjects == BlockingObjects.All)
			{
				Physics.Raycast(ray, out var hitInfo, num);
				if ((bool)hitInfo.collider)
				{
					result = hitInfo.distance;
				}
			}
			if (base.blockingObjects == BlockingObjects.TwoD || base.blockingObjects == BlockingObjects.All)
			{
				RaycastHit2D raycastHit2D = Physics2D.Raycast(ray.origin, ray.direction, num);
				if (raycastHit2D.collider != null)
				{
					result = raycastHit2D.fraction * num;
				}
			}
		}
		return result;
	}

	protected virtual void Raycast(Canvas canvas, Camera eventCamera, Ray ray, ref List<RaycastResult> results)
	{
		float hitDistance = GetHitDistance(ray);
		IList<Graphic> graphicsForCanvas = GraphicRegistry.GetGraphicsForCanvas(canvas);
		for (int i = 0; i < graphicsForCanvas.Count; i++)
		{
			Graphic graphic = graphicsForCanvas[i];
			if (graphic.depth == -1 || !graphic.raycastTarget)
			{
				continue;
			}
			Transform transform = graphic.transform;
			Vector3 forward = transform.forward;
			float num = Vector3.Dot(forward, transform.position - ray.origin) / Vector3.Dot(forward, ray.direction);
			if (!(num < 0f) && !(num - 1E-05f > hitDistance))
			{
				Vector3 point = ray.GetPoint(num);
				Vector2 vector = eventCamera.WorldToScreenPoint(point);
				if (RectTransformUtility.RectangleContainsScreenPoint(graphic.rectTransform, vector, eventCamera) && graphic.Raycast(vector, eventCamera))
				{
					RaycastResult raycastResult = default(RaycastResult);
					raycastResult.gameObject = graphic.gameObject;
					raycastResult.module = this;
					raycastResult.distance = num;
					raycastResult.screenPosition = vector;
					raycastResult.worldPosition = point;
					raycastResult.depth = graphic.depth;
					raycastResult.sortingLayer = canvas.sortingLayerID;
					raycastResult.sortingOrder = canvas.sortingOrder;
					RaycastResult item = raycastResult;
					results.Add(item);
				}
			}
		}
		results.Sort((RaycastResult g1, RaycastResult g2) => g2.depth.CompareTo(g1.depth));
	}
}
public struct UIPointerEventArgs
{
	public bool isActive;

	public GameObject currentTarget;

	public GameObject previousTarget;

	public RaycastResult raycastResult;
}
public delegate void UIPointerEventHandler(object sender, UIPointerEventArgs e);
public class Pvr_UIPointer : MonoBehaviour
{
	public enum ClickMethods
	{
		ClickOnButtonUp,
		ClickOnButtonDown
	}

	public ClickMethods clickMethod;

	[HideInInspector]
	public bool collisionClick;

	[HideInInspector]
	public bool pressToDrag;

	[HideInInspector]
	public GameObject autoActivatingCanvas;

	[HideInInspector]
	public PointerEventData pointerEventData;

	[HideInInspector]
	public GameObject hoveringElement;

	[HideInInspector]
	public float hoverDurationTimer;

	[HideInInspector]
	public bool canClickOnHover;

	public Transform pointerOriginTransform;

	protected bool pointerClicked;

	protected bool beamEnabledState;

	protected bool lastPointerPressState;

	protected bool lastPointerClickState;

	protected GameObject currentTarget;

	protected EventSystem cachedEventSystem;

	protected Pvr_InputModule cachedVRInputModule;

	protected Transform originalPointerOriginTransform;

	public static bool TouchBtnValue;

	public static bool AppBtnValue;

	public static bool TriggerBtnValue;

	public event UIPointerEventHandler UIPointerElementEnter;

	public event UIPointerEventHandler UIPointerElementExit;

	public event UIPointerEventHandler UIPointerElementClick;

	public event UIPointerEventHandler UIPointerElementDragStart;

	public event UIPointerEventHandler UIPointerElementDragEnd;

	public virtual bool PointerActive()
	{
		return true;
	}

	public virtual bool IsSelectionButtonPressed()
	{
		if (!Input.GetMouseButton(0) && !Input.GetKey(KeyCode.JoystickButton0) && !TouchBtnValue && !AppBtnValue)
		{
			return TriggerBtnValue;
		}
		return true;
	}

	public virtual Vector3 GetOriginPosition()
	{
		if (!pointerOriginTransform)
		{
			return base.transform.position;
		}
		return pointerOriginTransform.position;
	}

	public virtual Vector3 GetOriginForward()
	{
		if (!pointerOriginTransform)
		{
			return base.transform.forward;
		}
		return pointerOriginTransform.forward;
	}

	public virtual bool ValidClick(bool checkLastClick, bool lastClickState = false)
	{
		bool result = (collisionClick ? collisionClick : IsSelectionButtonPressed());
		if (!checkLastClick)
		{
			return result;
		}
		return result;
	}

	protected virtual void ResetHoverTimer()
	{
		hoverDurationTimer = 0f;
		canClickOnHover = false;
	}

	public virtual void OnUIPointerElementEnter(UIPointerEventArgs e)
	{
		if (e.currentTarget != currentTarget)
		{
			ResetHoverTimer();
		}
		currentTarget = e.currentTarget;
		if (this.UIPointerElementEnter != null)
		{
			this.UIPointerElementEnter(this, e);
		}
	}

	public virtual void OnUIPointerElementExit(UIPointerEventArgs e)
	{
		if (e.previousTarget == currentTarget)
		{
			ResetHoverTimer();
		}
		if (this.UIPointerElementExit != null)
		{
			this.UIPointerElementExit(this, e);
		}
	}

	public virtual void OnUIPointerElementClick(UIPointerEventArgs e)
	{
		if (e.currentTarget == currentTarget)
		{
			ResetHoverTimer();
		}
		if (this.UIPointerElementClick != null)
		{
			this.UIPointerElementClick(this, e);
		}
	}

	public virtual void OnUIPointerElementDragStart(UIPointerEventArgs e)
	{
		if (this.UIPointerElementDragStart != null)
		{
			this.UIPointerElementDragStart(this, e);
		}
	}

	public virtual void OnUIPointerElementDragEnd(UIPointerEventArgs e)
	{
		if (this.UIPointerElementDragEnd != null)
		{
			this.UIPointerElementDragEnd(this, e);
		}
	}

	public virtual UIPointerEventArgs SetUIPointerEvent(RaycastResult currentRaycastResult, GameObject currentTarget, GameObject lastTarget = null)
	{
		UIPointerEventArgs result = default(UIPointerEventArgs);
		result.isActive = PointerActive();
		result.currentTarget = currentTarget;
		result.previousTarget = lastTarget;
		result.raycastResult = currentRaycastResult;
		return result;
	}

	protected virtual void Awake()
	{
		originalPointerOriginTransform = pointerOriginTransform;
	}

	protected virtual void OnEnable()
	{
		pointerOriginTransform = originalPointerOriginTransform;
		ConfigureEventSystem();
		pointerClicked = false;
		lastPointerPressState = false;
		lastPointerClickState = false;
		beamEnabledState = false;
	}

	protected virtual void OnDisable()
	{
		Pvr_InputModule.RemovePoint(this);
	}

	protected virtual void ConfigureEventSystem()
	{
		if (!cachedEventSystem)
		{
			cachedEventSystem = UnityEngine.Object.FindObjectOfType<EventSystem>();
		}
		if (!cachedVRInputModule)
		{
			cachedVRInputModule = cachedEventSystem.GetComponent<Pvr_InputModule>();
		}
		if ((bool)cachedEventSystem && (bool)cachedVRInputModule && pointerEventData == null)
		{
			pointerEventData = new PointerEventData(cachedEventSystem);
		}
		Pvr_InputModule.AddPoint(this);
	}
}
[ExecuteInEditMode]
public class Pvr_UnitySDKEditor : MonoBehaviour
{
	private bool vrModeEnabled = true;

	private float mouseX;

	private float mouseY;

	private float mouseZ;

	private float neckModelScale;

	private bool autoUntiltHead;

	private static readonly Vector3 neckOffset = new Vector3(0f, 0.075f, 0.0805f);

	[HideInInspector]
	public Matrix4x4 headView;

	[HideInInspector]
	public Matrix4x4 leftEyeUndistortedProj;

	[HideInInspector]
	public Matrix4x4 rightEyeUndistortedProj;

	[HideInInspector]
	public Matrix4x4 leftEyeProj;

	[HideInInspector]
	public Matrix4x4 rightEyeProj;

	private const float TOUCH_TIME_LIMIT = 0.2f;

	private float touchStartTime;

	public Matrix4x4 UndistortedProjection(Eye eye)
	{
		if (eye != 0)
		{
			return rightEyeUndistortedProj;
		}
		return leftEyeUndistortedProj;
	}

	public Matrix4x4 Projection(Eye eye)
	{
		if (eye != 0)
		{
			return rightEyeProj;
		}
		return leftEyeProj;
	}

	private void Awake()
	{
		InitEyePara();
		InitEditorSensorPara();
	}

	private void Update()
	{
		SimulateInput();
		Pvr_UnitySDKManager.SDK.picovrTriggered = Pvr_UnitySDKManager.SDK.newPicovrTriggered;
		Pvr_UnitySDKManager.SDK.newPicovrTriggered = false;
	}

	public void InitEyePara()
	{
		ComputeEyesFromProfile();
		InitForEye(ref Pvr_UnitySDKManager.SDK.Eyematerial, ref Pvr_UnitySDKManager.SDK.Middlematerial);
		if (Pvr_UnitySDKRender.Instance == null)
		{
			PLOG.I("pvr_UnitySDKRender init failed");
		}
		if (Pvr_UnitySDKSensor.Instance == null)
		{
			PLOG.I("pvr_UnitySDKSensor init failed");
		}
		FovAdjust();
	}

	private void InitEditorSensorPara()
	{
		Pvr_UnitySDKManager.SDK.picovrTriggered = Pvr_UnitySDKManager.SDK.newPicovrTriggered;
		Pvr_UnitySDKManager.SDK.newPicovrTriggered = false;
	}

	public static Matrix4x4 MakeProjection(float l, float t, float r, float b, float n, float f)
	{
		Matrix4x4 zero = Matrix4x4.zero;
		zero[0, 0] = 2f * n / (r - l);
		zero[1, 1] = 2f * n / (t - b);
		zero[0, 2] = (r + l) / (r - l);
		zero[1, 2] = (t + b) / (t - b);
		zero[2, 2] = (n + f) / (n - f);
		zero[2, 3] = 2f * n * f / (n - f);
		zero[3, 2] = -1f;
		return zero;
	}

	public bool UpdateStatesensor()
	{
		UpdateSimulatedSensor();
		return true;
	}

	public void ComputeEyesFromProfile()
	{
		Vector2 vector = new Vector2(0.11f, 0.062f);
		Pvr_UnitySDKManager.SDK.leftEyeView = Matrix4x4.identity;
		Pvr_UnitySDKManager.SDK.leftEyeView[0, 3] = (0f - Pvr_UnitySDKManager.SDK.pvr_UnitySDKConfig.device.devLenses.separation) / 2f;
		float[] leftEyeVisibleTanAngles = Pvr_UnitySDKManager.SDK.pvr_UnitySDKConfig.GetLeftEyeVisibleTanAngles(vector.x, vector.y);
		leftEyeProj = MakeProjection(leftEyeVisibleTanAngles[0], leftEyeVisibleTanAngles[1], leftEyeVisibleTanAngles[2], leftEyeVisibleTanAngles[3], 1f, 1000f);
		leftEyeVisibleTanAngles = Pvr_UnitySDKManager.SDK.pvr_UnitySDKConfig.GetLeftEyeNoLensTanAngles(vector.x, vector.y);
		leftEyeUndistortedProj = MakeProjection(leftEyeVisibleTanAngles[0], leftEyeVisibleTanAngles[1], leftEyeVisibleTanAngles[2], leftEyeVisibleTanAngles[3], 1f, 1000f);
		Pvr_UnitySDKManager.SDK.leftEyeRect = Pvr_UnitySDKManager.SDK.pvr_UnitySDKConfig.GetLeftEyeVisibleScreenRect(leftEyeVisibleTanAngles, vector.x, vector.y);
		Pvr_UnitySDKManager.SDK.rightEyeView = Pvr_UnitySDKManager.SDK.leftEyeView;
		Pvr_UnitySDKManager.SDK.rightEyeView[0, 3] *= -1f;
		rightEyeProj = leftEyeProj;
		rightEyeProj[0, 2] *= -1f;
		rightEyeUndistortedProj = leftEyeUndistortedProj;
		rightEyeUndistortedProj[0, 2] *= -1f;
		Rect leftEyeRect = new Rect(0f, 0f, 0.5f, 1f);
		Rect rightEyeRect = new Rect(0.5f, 0f, 0.5f, 1f);
		Pvr_UnitySDKManager.SDK.leftEyeRect = leftEyeRect;
		Pvr_UnitySDKManager.SDK.rightEyeRect = rightEyeRect;
		Pvr_UnitySDKManager.SDK.leftEyeOffset = new Vector3((0f - Pvr_UnitySDKManager.SDK.pvr_UnitySDKConfig.device.devLenses.separation) / 2f, 0f, 0f);
		Pvr_UnitySDKManager.SDK.rightEyeOffset = new Vector3(Pvr_UnitySDKManager.SDK.pvr_UnitySDKConfig.device.devLenses.separation / 2f, 0f, 0f);
	}

	public bool ResetUnitySDKSensor()
	{
		mouseX = (mouseY = (mouseZ = 0f));
		return true;
	}

	private void SimulateInput()
	{
		if (Input.GetMouseButtonDown(0) && (Input.GetKey(KeyCode.LeftAlt) || Input.GetKey(KeyCode.RightAlt)))
		{
			EnableVEmodel();
		}
		if (Input.GetMouseButtonDown(0))
		{
			touchStartTime = Time.time;
		}
		else if (Input.GetMouseButtonUp(0))
		{
			if (Time.time - touchStartTime <= 0.2f)
			{
				Pvr_UnitySDKManager.SDK.newPicovrTriggered = true;
			}
			touchStartTime = 0f;
		}
		UpdateSimulatedSensor();
	}

	private void FovAdjust()
	{
		Pvr_UnitySDKRender.Instance.EyeVFoV = 2f * Pvr_UnitySDKManager.SDK.pvr_UnitySDKConfig.device.devMaxFov.upper;
	}

	private Rect RectAdjust(Rect eyeRect)
	{
		Rect result = new Rect(0f, 0f, 0.5f, 1f);
		result.width *= 2f * eyeRect.width;
		result.x = eyeRect.x + 2f * result.x * eyeRect.width;
		result.height *= eyeRect.height;
		result.y = eyeRect.y + result.y * eyeRect.height;
		return result;
	}

	private void UpdateSimulatedSensor()
	{
		bool flag = false;
		if (Input.GetKey(KeyCode.LeftAlt) || Input.GetKey(KeyCode.RightAlt))
		{
			mouseX += Input.GetAxis("Mouse X") * 5f;
			if (mouseX <= -180f)
			{
				mouseX += 360f;
			}
			else if (mouseX > 180f)
			{
				mouseX -= 360f;
			}
			mouseY -= Input.GetAxis("Mouse Y") * 2.4f;
			mouseY = Mathf.Clamp(mouseY, -91f, 91f);
		}
		else if (Input.GetKey(KeyCode.LeftControl) || Input.GetKey(KeyCode.RightControl))
		{
			flag = true;
			mouseZ += Input.GetAxis("Mouse X") * 5f;
			mouseZ = Mathf.Clamp(mouseZ, -91f, 91f);
		}
		if (!flag && autoUntiltHead)
		{
			mouseZ = Mathf.Lerp(mouseZ, 0f, Time.deltaTime / (Time.deltaTime + 0.1f));
		}
		Quaternion quaternion = Quaternion.Euler(mouseY, mouseX, mouseZ);
		Matrix4x4 matrix = Matrix4x4.TRS((quaternion * neckOffset - neckOffset.y * Vector3.up) * neckModelScale, quaternion, Vector3.one);
		Pvr_UnitySDKSensor.Instance.HeadPose = new Pvr_UnitySDKPose(matrix);
	}

	private void InitForEye(ref Material mat, ref Material mat1)
	{
		Shader shader = Shader.Find("Pvr_UnitySDK/Undistortion");
		Shader shader2 = Shader.Find("Pvr_UnitySDK/FillColor");
		if (shader == null || shader2 == null)
		{
			PLOG.E("Ths Shader Missing ！");
			return;
		}
		mat = new Material(shader);
		mat1 = new Material(shader2);
	}

	private void EnableVEmodel()
	{
		vrModeEnabled = !vrModeEnabled;
		Pvr_UnitySDKManager.SDK.VRModeEnabled = vrModeEnabled;
	}
}
public class Pvr_VolumePowerBrightness : MonoBehaviour
{
	private bool VolEnable;

	private bool BattEnable;

	public Text showResult;

	public Text setVolumnum;

	public Text setBrightnum;

	public string MusicPath;

	private void Awake()
	{
		InitBatteryVolClass();
		string startreceivre = base.gameObject.name;
		StartBatteryReceiver(startreceivre);
		StartAudioReceiver(startreceivre);
	}

	private void OnDisable()
	{
		if (VolEnable)
		{
			StopAudioReceiver();
		}
		if (BattEnable)
		{
			StopBatteryReceiver();
		}
	}

	public void GetMaxVolumeNumber()
	{
		int num = 0;
		num = VolumePowerBrightness.UPvr_GetMaxVolumeNumber();
		showResult.text = "Maximum volume: " + num;
	}

	public void GetCurrentVolumeNumber()
	{
		int num = 0;
		num = VolumePowerBrightness.UPvr_GetCurrentVolumeNumber();
		showResult.text = "Current volume：" + num;
	}

	public void VolumeUp()
	{
		if (!VolumePowerBrightness.UPvr_VolumeUp())
		{
			PLOG.E("VolumeUp Error");
		}
	}

	public void VolumeDown()
	{
		if (!VolumePowerBrightness.UPvr_VolumeDown())
		{
			PLOG.E("VolumeDown Error");
		}
	}

	public void SetVolumeNum()
	{
		int volume = new System.Random().Next(0, 15);
		setVolumnum.text = "Random number：" + volume;
		if (!VolumePowerBrightness.UPvr_SetVolumeNum(volume))
		{
			PLOG.E("SetVolumeNum Error");
		}
	}

	public void SetBrightness()
	{
		int brightness = new System.Random().Next(0, 255);
		setBrightnum.text = "Random number：" + brightness;
		if (!VolumePowerBrightness.UPvr_SetCommonBrightness(brightness))
		{
			PLOG.E("SetBrightness Error");
		}
	}

	public void GetCurrentBrightness()
	{
		int num = 0;
		num = VolumePowerBrightness.UPvr_GetCommonBrightness();
		showResult.text = "Current brightness：" + num;
	}

	public bool setAudio(string s)
	{
		PLOG.I(s.ToString());
		return true;
	}

	public bool setBattery(string s)
	{
		PLOG.I(s.ToString());
		return true;
	}

	private bool InitBatteryVolClass()
	{
		return VolumePowerBrightness.UPvr_InitBatteryVolClass();
	}

	private bool StartBatteryReceiver(string startreceivre)
	{
		BattEnable = VolumePowerBrightness.UPvr_StartBatteryReceiver(startreceivre);
		return BattEnable;
	}

	private bool StopBatteryReceiver()
	{
		return VolumePowerBrightness.UPvr_StopBatteryReceiver();
	}

	private bool StartAudioReceiver(string startreceivre)
	{
		VolEnable = VolumePowerBrightness.UPvr_StartAudioReceiver(startreceivre);
		return VolEnable;
	}

	private bool StopAudioReceiver()
	{
		return VolumePowerBrightness.UPvr_StopAudioReceiver();
	}
}
public class GymnasiumController : MonoBehaviour
{
	public Transform contentTra;

	public Button lastBtn;

	public Button nextBtn;

	public Text curPageTxt;

	public Text allPageTxt;

	public Button badmintonBtn;

	public Button golfBtn;

	public Button hitGopherBtn;

	public Button shotBtn;

	public Button exitBtn;

	private bool isScoll;

	private float height;

	private int curPage;

	private int allPage;

	private void Start()
	{
		Pvr_UnitySDKSensor.Instance.ResetUnitySDKSensor();
		lastBtn.onClick.AddListener(LastBtnHander);
		nextBtn.onClick.AddListener(NextBtnHander);
		badmintonBtn.onClick.AddListener(BadmintonBtnHander);
		golfBtn.onClick.AddListener(GolfBtnHander);
		hitGopherBtn.onClick.AddListener(HitGopherBtnHander);
		shotBtn.onClick.AddListener(ShotBtnHander);
		exitBtn.onClick.AddListener(ExitBtnHander);
		curPage = 1;
		int num = 0;
		foreach (Transform item in contentTra)
		{
			if (item.gameObject.activeSelf)
			{
				num++;
			}
		}
		allPage = (num - 1) / 8 + 1;
		curPageTxt.text = curPage.ToString();
		allPageTxt.text = "/" + allPage;
		lastBtn.interactable = false;
		if (allPage == 1)
		{
			nextBtn.interactable = false;
		}
	}

	private void LastBtnHander()
	{
		if (!isScoll)
		{
			isScoll = true;
			height -= 406f;
			curPage--;
			curPageTxt.text = curPage.ToString();
			contentTra.DOLocalMoveY(height, 0.25f).OnComplete(delegate
			{
				isScoll = false;
			});
			if (!nextBtn.interactable)
			{
				nextBtn.interactable = true;
			}
			if (curPage == 1)
			{
				lastBtn.interactable = false;
			}
		}
	}

	private void NextBtnHander()
	{
		if (!isScoll)
		{
			isScoll = true;
			height += 406f;
			curPage++;
			curPageTxt.text = curPage.ToString();
			contentTra.DOLocalMoveY(height, 0.25f).OnComplete(delegate
			{
				isScoll = false;
			});
			if (!lastBtn.interactable)
			{
				lastBtn.interactable = true;
			}
			if (curPage == allPage)
			{
				nextBtn.interactable = false;
			}
		}
	}

	private void BadmintonBtnHander()
	{
		Load.LoadScene2(ScenesHelper.Sports_BadmitonScene);
	}

	private void GolfBtnHander()
	{
		Load.LoadScene2(ScenesHelper.Sports_GolfScene);
	}

	private void HitGopherBtnHander()
	{
		Load.LoadScene2(ScenesHelper.Sports_HitGopherScene);
	}

	private void ShotBtnHander()
	{
		Load.LoadScene2(ScenesHelper.Sports_ShotScene);
	}

	private void ExitBtnHander()
	{
		ScenesHelper.LoadScene(ScenesHelper.MetaverseSceneName);
	}
}
public class af_bulletHoleSelfDestroy : MonoBehaviour
{
	private Material tempmat;

	private void Start()
	{
		tempmat = GetComponent<MeshRenderer>().material;
		tempmat.mainTextureOffset = new Vector2(0.33f * (float)UnityEngine.Random.Range(0, 2), 0.33f * (float)UnityEngine.Random.Range(0, 2));
		StartCoroutine(yieldDestroySelf());
	}

	private IEnumerator yieldDestroySelf()
	{
		yield return new WaitForSeconds(1f);
		Color tempColor = tempmat.color;
		while (tempColor.a > 0f)
		{
			yield return new WaitForFixedUpdate();
			tempColor.a -= 1f * Time.deltaTime;
			tempmat.color = tempColor;
		}
		UnityEngine.Object.Destroy(base.gameObject);
	}
}
public class af_GameManager : MonoBehaviour
{
	public static af_GameManager Inst;

	public int m_iScore;

	public int m_iSeconds = 60;

	[SerializeField]
	private float ftimer;

	public aimFire_GunCtrl m_Gun;

	public GameObject m_objATarget;

	public Transform[] listStartPos;

	private Vector3 vMoveDir = new Vector3(-1f, 0f, 0f);

	public float fEndDis = 29f;

	private float fDealySecond = 1f;

	[Header("UI")]
	public GameObject UI_GameStart;

	public Text m_txtClockTimer;

	public Text m_txtScore;

	private GameObject tempTargetsContainer;

	public UnityEngine.Object m_objHitParticle;

	private Coroutine coroutineTimeCountDown;

	private void Start()
	{
		Inst = this;
		UI_GameStart.gameObject.SetActive(value: true);
		m_objATarget.gameObject.SetActive(value: false);
		m_Gun.gameObject.SetActive(value: false);
	}

	public void J_AddScore(int iScore)
	{
		m_iScore += iScore;
		m_txtScore.text = string.Concat(m_iScore);
	}

	private void Update()
	{
		if (Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.APP))
		{
			ScenesHelper.LoadScene(ScenesHelper.Sports_GymCenterScene);
		}
	}

	public void J_StartBornTargets()
	{
		m_Gun.gameObject.SetActive(value: true);
		UI_GameStart.gameObject.SetActive(value: false);
		tempTargetsContainer = new GameObject("tempTargetsContainer");
		m_iScore = 0;
		m_txtScore.text = string.Concat(m_iScore);
		ftimer = m_iSeconds;
		StartCoroutine(yieldTimeCountDown());
		StartCoroutine(yieldBornTargets());
	}

	private IEnumerator yieldBornTargets()
	{
		while (ftimer > 0f)
		{
			fDealySecond = 1f - 0.003f * (float)m_iScore;
			if (fDealySecond < 0.2f)
			{
				fDealySecond = 0.2f;
			}
			yield return new WaitForSeconds(fDealySecond);
			BornOneTarget();
		}
	}

	private void onGameOver()
	{
		m_Gun.gameObject.SetActive(value: false);
		UI_GameStart.gameObject.SetActive(value: true);
		UnityEngine.Object.Destroy(tempTargetsContainer.gameObject);
		StopAllCoroutines();
	}

	public void BornOneTarget()
	{
		GameObject obj = UnityEngine.Object.Instantiate(m_objATarget);
		obj.gameObject.SetActive(value: true);
		obj.transform.SetParent(tempTargetsContainer.transform);
		obj.name = "标靶";
		Vector3 position = listStartPos[UnityEngine.Random.Range(0, listStartPos.Length)].position;
		obj.transform.position = position;
		aimFire_Target component = obj.GetComponent<aimFire_Target>();
		component.vStratPos = position;
		component.vMoveDir = vMoveDir * UnityEngine.Random.Range(1f, 4f);
		component.vEndDis = fEndDis;
		component.J_StartMove();
	}

	private IEnumerator yieldTimeCountDown()
	{
		while (ftimer > 0f)
		{
			int num = (int)ftimer / 60;
			m_txtClockTimer.text = num.ToString("00") + ":" + ((int)ftimer - num * 60).ToString("00");
			ftimer -= 1f;
			yield return new WaitForSeconds(1f);
		}
		m_txtClockTimer.text = "00:00";
		onGameOver();
	}
}
public class aimFire_GunCtrl : MonoBehaviour
{
	public ParentConstraint parentConstraint;

	public Transform m_gunStartPos;

	public ParticleSystem m_psFire;

	public UnityEngine.Object m_objBulletHole;

	public AudioSource m_audioFire;

	private bool ist;

	private void Start()
	{
	}

	private void OnEnable()
	{
		if ((bool)WaveVRHead.Inst)
		{
			SetToHand(WaveVRHead.Inst.m_rightHand);
		}
	}

	private void OnDisable()
	{
		WaveVRHead.Inst.SetHnadlerVisiable(isShow: true);
	}

	private void SetToHand(GameObject obj)
	{
		ist = true;
		WaveVRHead.Inst.SetHnadlerVisiable(isShow: false);
		for (int num = parentConstraint.sourceCount - 1; num >= 0; num--)
		{
			parentConstraint.RemoveSource(num);
		}
		parentConstraint.AddSource(new ConstraintSource
		{
			sourceTransform = obj.transform,
			weight = 1f
		});
	}

	private void Update()
	{
		if (Pvr.IsMainKeyUp())
		{
			Fire();
		}
	}

	public void Fire()
	{
		m_audioFire.Play();
		m_psFire.Play();
		if (Physics.Linecast(m_gunStartPos.transform.position, m_gunStartPos.transform.position + m_gunStartPos.transform.forward * 50f, out var hitInfo))
		{
			if (hitInfo.transform.name == "标靶")
			{
				hitInfo.transform.GetComponent<aimFire_Target>().J_GetHit(hitInfo.point);
				return;
			}
			GameObject obj = UnityEngine.Object.Instantiate(m_objBulletHole) as GameObject;
			obj.transform.localScale = Vector3.one * 0.1f;
			obj.transform.position = hitInfo.point + hitInfo.normal * 0.01f;
			obj.transform.forward = -hitInfo.normal;
			obj.transform.Rotate(Vector3.forward, UnityEngine.Random.Range(0f, 360f), Space.Self);
		}
	}
}
public class aimFire_Target : MonoBehaviour
{
	public Animation m_animCtrl;

	public bool m_bisScoreTarget;

	public float vEndDis;

	public Vector3 vStratPos;

	public Vector3 vMoveDir;

	public GameObject canvasHit;

	public Text m_txtHitScore;

	private Vector3 vmoveDis = Vector3.zero;

	private Material tempmat;

	private void Start()
	{
		canvasHit.SetActive(value: false);
	}

	public void J_StartMove()
	{
		m_bisScoreTarget = true;
		StartCoroutine(yieldMove());
	}

	private IEnumerator yieldMove()
	{
		while (m_bisScoreTarget)
		{
			vmoveDis += vMoveDir * Time.deltaTime;
			base.transform.position = vStratPos + vmoveDis;
			if (vmoveDis.magnitude > vEndDis)
			{
				reachEndPos();
			}
			yield return new WaitForFixedUpdate();
		}
	}

	private void reachEndPos()
	{
		m_bisScoreTarget = false;
		StopAllCoroutines();
		UnityEngine.Object.Destroy(base.gameObject);
	}

	public void J_GetHit(Vector3 vHitPoint)
	{
		m_bisScoreTarget = false;
		GetComponent<Collider>().enabled = false;
		int num = (int)((0.5f - Vector3.Distance(base.transform.position, vHitPoint)) / 0.5f * 10f);
		if (num <= 0)
		{
			num = 1;
		}
		af_GameManager.Inst.J_AddScore(num);
		canvasHit.SetActive(value: true);
		m_txtHitScore.text = string.Concat(num);
		StartCoroutine(yieldDestroySelf());
	}

	private IEnumerator yieldDestroySelf()
	{
		m_animCtrl.Play();
		yield return new WaitForSeconds(1f);
		canvasHit.SetActive(value: false);
		yield return new WaitForSeconds(1f);
		UnityEngine.Object.Destroy(base.gameObject);
	}
}
public class gunRayHit : MonoBehaviour
{
	public GameObject hitpoint;

	private void Start()
	{
	}

	private void Update()
	{
		if (Physics.Linecast(base.transform.position, base.transform.position + base.transform.forward * 50f, out var hitInfo))
		{
			hitpoint.SetActive(value: true);
			hitpoint.transform.position = hitInfo.point;
		}
		else
		{
			hitpoint.SetActive(value: false);
		}
	}
}
public class GameManagerGOLF : MonoBehaviour
{
	[Header("球")]
	public Rigidbody m_ball;

	public Transform m_tempball;

	public Transform backupBallsContainer;

	public AudioSource m_audioBallHit;

	[Header("地毯")]
	public GameObject m_GroundMiddle;

	public GameObject m_GroundBottom;

	public GameObject m_ballHole;

	public ParticleSystem psBallIn;

	public AudioSource m_audioBallIn;

	[Header("球杆")]
	public GameObject m_objGlof;

	public VelocityEstimator m_handKickerVE;

	public Pvr_ControllerModuleInit rightHand;

	[Header("再来一球")]
	public GameObject m_canvaBallAgain;

	public Image imgCircleStay;

	public OnTriggerEvent triggerEvent_nextBall;

	public float m_fStayTime = 2f;

	private bool bIsGlofStayAgainBall;

	private float fstaytime;

	[Header("UI")]
	public int m_iScore;

	public Text m_txtBallDistance;

	public Text m_txtLevelChangeTip;

	private Vector3 originalPos_Ball;

	private bool bHasHit;

	private bool bballInitiallizing;

	private bool bBallStopped;

	private float fIncreaseDis = 0.2f;

	private float m_fPassTime = 2f;

	private float m_fGravity = -1f;

	private float fPassTime;

	private float fGravity;

	private Vector3 speed;

	private Vector3 Gravity;

	private float dpassedTime;

	private void Start()
	{
		m_tempball.gameObject.SetActive(value: false);
		originalPos_Ball = m_ball.transform.position;
		m_ball.GetComponent<OnTriggerEvent>().m_actionsOnTriggerEnter.AddListener(delegate(Collider other)
		{
			if (!bballInitiallizing && !bHasHit)
			{
				bHasHit = true;
				m_audioBallHit.Play();
				m_canvaBallAgain.SetActive(value: false);
				triggerEvent_nextBall.gameObject.SetActive(value: false);
				Vector3 velocityEstimate = m_handKickerVE.GetVelocityEstimate();
				m_ball.AddForceAtPosition(velocityEstimate, other.ClosestPoint(m_ball.transform.position), ForceMode.Impulse);
				bBallStopped = true;
				m_canvaBallAgain.SetActive(value: true);
				triggerEvent_nextBall.gameObject.SetActive(value: true);
			}
		});
		triggerEvent_nextBall.m_actionsOnTriggerEnter.AddListener(delegate(Collider other)
		{
			if (other.transform.IsChildOf(m_objGlof.transform))
			{
				bIsGlofStayAgainBall = true;
				fstaytime = 0f;
			}
		});
		triggerEvent_nextBall.m_actionsOnTriggerExit.AddListener(delegate(Collider other)
		{
			if (other.transform.IsChildOf(m_objGlof.transform))
			{
				bIsGlofStayAgainBall = false;
				imgCircleStay.fillAmount = 0f;
			}
		});
		imgCircleStay.fillAmount = 0f;
		StartCoroutine(yieldSetHand());
		rightHand.ForceHideOrShow(state: false);
	}

	private void OnApplicationPause(bool pause)
	{
		if (!pause)
		{
			StartCoroutine(yieldSetHand());
		}
	}

	private IEnumerator yieldSetHand()
	{
		yield return null;
		ParentConstraint component = m_objGlof.GetComponent<ParentConstraint>();
		for (int num = component.sourceCount - 1; num >= 0; num--)
		{
			component.RemoveSource(num);
		}
		component.AddSource(new ConstraintSource
		{
			sourceTransform = rightHand.transform,
			weight = 1f
		});
		component.constraintActive = true;
	}

	private void Update()
	{
		if (Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.APP))
		{
			ScenesHelper.LoadScene(ScenesHelper.Sports_GymCenterScene);
		}
		if (!bHasHit)
		{
			return;
		}
		if (Vector3.Distance(m_ballHole.transform.position, m_ball.transform.position) < 0.09f)
		{
			UnityEngine.Debug.Log("ball in");
			BallIn();
			return;
		}
		CheckBallStopped();
		if (bIsGlofStayAgainBall && fstaytime < m_fStayTime)
		{
			if ((fstaytime += Time.deltaTime) < m_fStayTime)
			{
				imgCircleStay.fillAmount = fstaytime / m_fStayTime;
				return;
			}
			bIsGlofStayAgainBall = false;
			imgCircleStay.fillAmount = 0f;
			TakeNextBall();
		}
	}

	public void J_LevelUP()
	{
		m_iScore++;
		m_txtLevelChangeTip.color = Color.green;
		m_txtLevelChangeTip.text = "LEVEL UP";
		StartCoroutine(yieldLevelDistanceChange((float)(m_iScore + 1) * fIncreaseDis));
	}

	private IEnumerator yieldLevelDistanceChange(float fDistance)
	{
		m_GroundMiddle.transform.DOScaleY(fDistance * 2f, 2f);
		float endValue = m_GroundMiddle.transform.position.z + fDistance;
		m_GroundBottom.transform.DOMoveZ(endValue, 2f);
		yield return new WaitForSeconds(2f);
		RefreshBalls();
		TakeNextBall();
		m_txtBallDistance.text = fDistance + 0.6f + "m";
		m_txtLevelChangeTip.text = "";
	}

	public void J_LevelDown()
	{
		if (--m_iScore < 0)
		{
			m_iScore = 0;
		}
		m_txtLevelChangeTip.color = Color.red;
		m_txtLevelChangeTip.text = "LEVEL DOWN";
		StartCoroutine(yieldLevelDistanceChange((float)(m_iScore + 1) * fIncreaseDis));
	}

	private void CheckBallStopped()
	{
		if (m_ball.velocity.magnitude != 0f)
		{
			bBallStopped = false;
		}
		if (!bBallStopped && m_ball.velocity.magnitude == 0f)
		{
			bBallStopped = true;
			UnityEngine.Debug.Log("ball stopped");
			if (GetUnusedBall() == null)
			{
				J_LevelDown();
			}
			else
			{
				TakeNextBall();
			}
		}
	}

	private void BallIn()
	{
		psBallIn.Play();
		m_audioBallIn.Play();
		m_ball.gameObject.SetActive(value: false);
		bHasHit = false;
		bIsGlofStayAgainBall = false;
		J_LevelUP();
	}

	private Transform GetUnusedBall()
	{
		foreach (Transform item in backupBallsContainer)
		{
			if (item.gameObject.activeInHierarchy)
			{
				return item;
			}
		}
		return null;
	}

	private void RefreshBalls()
	{
		foreach (Transform item in backupBallsContainer)
		{
			item.gameObject.SetActive(value: true);
		}
	}

	private void TakeNextBall()
	{
		m_canvaBallAgain.SetActive(value: false);
		triggerEvent_nextBall.gameObject.SetActive(value: false);
		bHasHit = false;
		Transform unusedBall = GetUnusedBall();
		unusedBall.gameObject.SetActive(value: false);
		if (unusedBall == null)
		{
			UnityEngine.Debug.LogError("ball empty");
			return;
		}
		bballInitiallizing = true;
		m_tempball.gameObject.SetActive(value: true);
		StartMoveFromTo(m_tempball, unusedBall.transform.position, originalPos_Ball, delegate
		{
			UnityEngine.Debug.Log("ball ready");
			m_tempball.gameObject.SetActive(value: false);
			m_ball.isKinematic = true;
			m_ball.gameObject.SetActive(value: false);
			m_ball.transform.position = originalPos_Ball;
			m_ball.gameObject.SetActive(value: true);
			bballInitiallizing = false;
			m_ball.isKinematic = false;
		});
	}

	private void StartMoveFromTo(Transform ball, Vector3 vFrom, Vector3 vTo, Action callbackReachEndPoint = null)
	{
		fPassTime = m_fPassTime;
		fGravity = m_fGravity;
		ball.transform.position = vFrom;
		speed = new Vector3((vTo.x - vFrom.x) / fPassTime, (vTo.y - vFrom.y) / fPassTime - 0.5f * fGravity * fPassTime, (vTo.z - vFrom.z) / fPassTime);
		Gravity = Vector3.zero;
		dpassedTime = 0f;
		StartCoroutine(MoveBall(ball, callbackReachEndPoint));
	}

	private IEnumerator MoveBall(Transform ball, Action callbackReachEndPoint = null)
	{
		while (dpassedTime < fPassTime)
		{
			Vector3 vector = speed * Time.deltaTime + new Vector3(0f, fGravity * (dpassedTime += Time.deltaTime), 0f) * Time.deltaTime;
			ball.transform.position += vector;
			yield return new WaitForFixedUpdate();
		}
		if (callbackReachEndPoint != null)
		{
			callbackReachEndPoint();
			callbackReachEndPoint = null;
		}
	}
}
public class GameManagerHitMouse : MonoBehaviour
{
	public static GameManagerHitMouse Inst;

	public int m_iScore;

	public Vector2 fJumpTimeDelay = new Vector2(1f, 9f);

	public ParentConstraint m_Hammer;

	public singleMouseJump[] listMouses;

	public GameObject UI_GameStart;

	public Pvr_ControllerModuleInit rightHand;

	[SerializeField]
	private float ftimer = 60f;

	public Text m_txtClockTimer;

	public Text m_txtScore;

	public Text m_txtFaceTip;

	public AudioSource m_AudioMouseHit;

	public AudioSource m_AudioBoombHit;

	public Pvr_UICanvas cvs;

	private Coroutine coroutineTimeCountDown;

	private void Start()
	{
		Inst = this;
		m_Hammer.gameObject.SetActive(value: false);
		m_txtScore.text = "";
		m_txtFaceTip.text = "";
	}

	private void Update()
	{
		if (Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.APP))
		{
			ScenesHelper.LoadScene(ScenesHelper.Sports_GymCenterScene);
		}
	}

	private void OnApplicationPause(bool pause)
	{
		if (!pause)
		{
			StartCoroutine(yieldSetHand());
		}
	}

	private IEnumerator yieldSetHand()
	{
		yield return null;
		for (int num = m_Hammer.sourceCount - 1; num >= 0; num--)
		{
			m_Hammer.RemoveSource(num);
		}
		m_Hammer.AddSource(new ConstraintSource
		{
			sourceTransform = rightHand.transform,
			weight = 1f
		});
	}

	public void J_StartGame()
	{
		rightHand.ForceHideOrShow(state: false);
		StartCoroutine(yieldSetHand());
		UI_GameStart.gameObject.SetActive(value: false);
		ftimer = 60f;
		m_Hammer.gameObject.SetActive(value: true);
		StartCoroutine(yieldTimeCountDown());
		singleMouseJump[] array = listMouses;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].StartJump(fJumpTimeDelay);
		}
	}

	public void J_AddScore()
	{
		m_AudioMouseHit.Play();
		m_iScore++;
		m_txtScore.text = string.Concat(m_iScore);
		m_txtFaceTip.color = Color.green;
		m_txtFaceTip.text = "(*^▽^*)";
	}

	public void J_DeleScore()
	{
		m_AudioBoombHit.Play();
		m_iScore -= 5;
		if (m_iScore < 0)
		{
			m_iScore = 0;
		}
		m_txtScore.text = string.Concat(m_iScore);
		m_txtFaceTip.color = Color.red;
		m_txtFaceTip.text = "o(╥\ufe4f╥)o";
	}

	private IEnumerator yieldTimeCountDown()
	{
		while (ftimer > 0f)
		{
			int num = (int)ftimer / 60;
			m_txtClockTimer.text = num.ToString("00") + ":" + ((int)ftimer - num * 60).ToString("00");
			ftimer -= 1f;
			yield return new WaitForSeconds(1f);
		}
		m_txtClockTimer.text = "00:00";
		onGameOver();
	}

	private void OnDisable()
	{
		rightHand.ForceHideOrShow(state: true);
	}

	private void onGameOver()
	{
		UI_GameStart.gameObject.SetActive(value: true);
		m_Hammer.gameObject.SetActive(value: false);
		rightHand.ForceHideOrShow(state: true);
		singleMouseJump[] array = listMouses;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].StopJump();
		}
	}
}
public class singleMouseJump : MonoBehaviour
{
	public GameObject objMouse;

	public ParticleSystem hitps_mouse;

	public GameObject objBoom;

	public ParticleSystem hitps_boom;

	private Collider coll;

	private void Start()
	{
		coll = GetComponent<Collider>();
		objMouse.SetActive(value: false);
		objBoom.SetActive(value: false);
	}

	private void OnCollisionEnter(UnityEngine.Collision collision)
	{
		if (collision.gameObject.name == "锤子")
		{
			if (objBoom.activeInHierarchy)
			{
				UnityEngine.Debug.Log(2);
				hitps_boom.Play();
				GameManagerHitMouse.Inst.J_DeleScore();
			}
			else if (objMouse.activeInHierarchy)
			{
				UnityEngine.Debug.Log(1);
				hitps_mouse.Play();
				GameManagerHitMouse.Inst.J_AddScore();
			}
			coll.enabled = false;
			objMouse.SetActive(value: false);
			objBoom.SetActive(value: false);
		}
	}

	public void StartJump(Vector2 vjumpTimeDelay)
	{
		StartCoroutine(yieldMouseJump(vjumpTimeDelay));
	}

	private IEnumerator yieldMouseJump(Vector2 vjumpTimeDelay)
	{
		while (true)
		{
			yield return new WaitForSeconds(UnityEngine.Random.Range(vjumpTimeDelay.x, vjumpTimeDelay.y));
			if (UnityEngine.Random.Range(0f, 10f) < 9f)
			{
				objMouse.SetActive(value: true);
				objBoom.SetActive(value: false);
			}
			else
			{
				objMouse.SetActive(value: false);
				objBoom.SetActive(value: true);
			}
			coll.enabled = true;
			yield return new WaitForSeconds(2f);
			coll.enabled = false;
			objMouse.SetActive(value: false);
			objBoom.SetActive(value: false);
		}
	}

	public void StopJump()
	{
		StopAllCoroutines();
		coll.enabled = false;
		objMouse.SetActive(value: false);
		objBoom.SetActive(value: false);
	}
}
public class YMQ_BallCtrl : MonoBehaviour
{
	public Rigidbody m_rigidbody;

	private void Start()
	{
	}

	private void Update()
	{
	}

	private void OnCollisionEnter(UnityEngine.Collision collision)
	{
		UnityEngine.Debug.Log("--ball hit:" + collision.gameObject.name);
		if ((bool)collision.gameObject.GetComponent<YMQ_Racket>())
		{
			if (base.transform.position.z < 0f)
			{
				YMQ_GameManager.Inst.J_PlayBack();
			}
		}
		else
		{
			FallToGround();
		}
	}

	public void ResetBall()
	{
		m_rigidbody.useGravity = false;
		m_rigidbody.constraints = RigidbodyConstraints.FreezeAll;
	}

	public void FallToGround()
	{
		m_rigidbody.useGravity = true;
		m_rigidbody.constraints = RigidbodyConstraints.None;
		YMQ_GameManager.Inst.J_ResetGameBall();
	}
}
public class YMQ_GameManager : MonoBehaviour
{
	public static YMQ_GameManager Inst;

	public bool m_bHasStart;

	[Header("player")]
	public ParentConstraint m_mainRacket;

	public YMQ_Racket m_playerRacket;

	public VelocityEstimator m_racketVE;

	public GameObject m_PlayerPoint;

	public AudioSource audioHit_Player;

	public AudioSource audioHit_PlayerMiss;

	public GameObject rightHand;

	public Pvr_ControllerModuleInit pvr_ControllerModuleInit;

	[Header("COM")]
	public YMQ_Racket m_ComRacket;

	public GameObject m_Computer;

	public GameObject m_Robot;

	public Transform m_RobotHand;

	public float fHandAngle = -104f;

	public AudioSource audioHit_Com;

	[Header("ball")]
	public GameObject m_ball;

	private __.BallMotion_A2B m_ballMotionCtrl;

	private Rigidbody ballRigibody;

	private bool bIsToDir = true;

	[Header("Score")]
	public int m_iCurScore;

	public Text m_txtScore;

	public Text m_txtHighestScore;

	private int fHighestScore;

	private void Awake()
	{
		Inst = this;
	}

	private void Start()
	{
		fHighestScore = PlayerPrefs.GetInt("HighestScore_ymq");
		m_txtHighestScore.text = string.Concat(fHighestScore);
		m_ballMotionCtrl = m_ball.GetComponent<__.BallMotion_A2B>();
		ballRigibody = m_ball.GetComponent<Rigidbody>();
		m_ball.GetComponent<__.OnColliderEvent>().m_actionsOnCollisionEnter.AddListener(delegate(UnityEngine.Collision collision)
		{
			UnityEngine.Debug.Log("--ball hit:" + collision.gameObject.name);
			if (collision.gameObject == m_playerRacket.gameObject)
			{
				if (!bIsToDir)
				{
					Inst.J_PlayBack();
				}
			}
			else
			{
				FallToGround();
			}
		});
		StartCoroutine(yieldSetHand());
		pvr_ControllerModuleInit.ForceHideOrShow(state: false);
	}

	private void OnApplicationPause(bool pause)
	{
		if (!pause)
		{
			StartCoroutine(yieldSetHand());
		}
	}

	private IEnumerator yieldSetHand()
	{
		yield return null;
		for (int num = m_mainRacket.sourceCount - 1; num >= 0; num--)
		{
			m_mainRacket.RemoveSource(num);
		}
		m_mainRacket.AddSource(new ConstraintSource
		{
			sourceTransform = rightHand.transform,
			weight = 1f
		});
		yield return new WaitForSeconds(1f);
		m_racketVE.BeginEstimatingVelocity();
	}

	public void FallToGround()
	{
		ballRigibody.useGravity = true;
		ballRigibody.constraints = RigidbodyConstraints.None;
		Inst.J_ResetGameBall();
	}

	public void J_ResetGameBall()
	{
		J_AddScore(isAdd: false);
		m_bHasStart = false;
		m_ballMotionCtrl.StopMove();
	}

	private void Update()
	{
		if (Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.APP))
		{
			ScenesHelper.LoadScene(ScenesHelper.Sports_GymCenterScene);
		}
		if (m_bHasStart)
		{
			return;
		}
		Vector3 velocityEstimate = m_racketVE.GetVelocityEstimate();
		if (velocityEstimate.magnitude > m_playerRacket.m_forceMinStart && velocityEstimate.z > velocityEstimate.y && velocityEstimate.z > velocityEstimate.x)
		{
			m_bHasStart = true;
			bIsToDir = true;
			audioHit_Player.Play();
			ballRigibody.useGravity = false;
			ballRigibody.constraints = RigidbodyConstraints.FreezeAll;
			m_ballMotionCtrl.StartMoveFromTo(m_racketVE.transform.position, m_Computer.transform.position, delegate
			{
				ComRacketPlayBack(m_Computer.transform.position);
			});
			CallComputerRobot(m_Computer.transform.position, m_ballMotionCtrl.m_fPassTime);
		}
	}

	public void J_PlayBack()
	{
		bIsToDir = true;
		Vector3 velocityEstimate = m_racketVE.GetVelocityEstimate();
		float forceMinForce = m_playerRacket.m_forceMinForce;
		float forceXLimit = m_playerRacket.m_forceXLimit;
		float ballXShiftLimit = m_playerRacket.m_ballXShiftLimit;
		float forceYLimit = m_playerRacket.m_forceYLimit;
		Vector2 ballGravityLimit = m_playerRacket.m_ballGravityLimit;
		Vector2 forceMaxLimit = m_playerRacket.m_forceMaxLimit;
		Vector2 ballTimeSpeedLimit = m_playerRacket.m_ballTimeSpeedLimit;
		if (velocityEstimate.z > 0f && velocityEstimate.magnitude > forceMinForce)
		{
			audioHit_Player.Play();
			float x = Mathf.Clamp(velocityEstimate.x, 0f - forceXLimit, forceXLimit) / forceXLimit * ballXShiftLimit;
			Vector3 targetPoint = m_Computer.transform.position + new Vector3(x, 0f, 0f);
			float gravity = (Mathf.Clamp(velocityEstimate.y, 0f - forceYLimit, forceYLimit) + forceYLimit) / (2f * forceYLimit) * (ballGravityLimit.y - ballGravityLimit.x) + ballGravityLimit.x;
			float num = (Mathf.Clamp(velocityEstimate.magnitude, forceMaxLimit.x, forceMaxLimit.y) - forceMaxLimit.x) / (forceMaxLimit.y - forceMaxLimit.x) * (ballTimeSpeedLimit.y - ballTimeSpeedLimit.x) + ballTimeSpeedLimit.x;
			m_ballMotionCtrl.StartMoveFromTo(m_ballMotionCtrl.transform.position, targetPoint, num, gravity, delegate
			{
				ComRacketPlayBack(targetPoint);
			});
			CallComputerRobot(targetPoint, num);
			J_AddScore(isAdd: true);
		}
		else
		{
			audioHit_PlayerMiss.Play();
			UnityEngine.Debug.Log("--miss ball");
			m_ballMotionCtrl.StartMoveFromTo(m_ballMotionCtrl.transform.position, Vector3.zero, delegate
			{
				J_AddScore(isAdd: false);
			});
		}
	}

	private void CallComputerRobot(Vector3 vTargetPos, float fTotalTime)
	{
		StartCoroutine(_yieldComputerRobotMotion(vTargetPos, fTotalTime));
	}

	private IEnumerator _yieldComputerRobotMotion(Vector3 vTargetPos, float fTotalTime)
	{
		float num = 0.5f;
		float fHandMoveBackTime = 0.3f;
		float fHandMoveForwardTime = num - fHandMoveBackTime;
		float angleM = 40f;
		float fMoveTime2 = fTotalTime - num;
		Vector3 vspeed = (vTargetPos - m_Robot.transform.position) / fMoveTime2;
		float _fUsedTime3 = 0f;
		while (true)
		{
			float num2;
			_fUsedTime3 = (num2 = _fUsedTime3 + Time.deltaTime);
			if (!(num2 < fMoveTime2))
			{
				break;
			}
			yield return new WaitForFixedUpdate();
			m_Robot.transform.position += vspeed * Time.deltaTime;
		}
		m_Robot.transform.position = vTargetPos;
		_fUsedTime3 = 0f;
		fMoveTime2 = angleM / fHandMoveBackTime;
		float currentAngle2 = fHandAngle;
		m_RobotHand.transform.localEulerAngles = new Vector3(currentAngle2, 0f, 0f);
		while (true)
		{
			float num2;
			_fUsedTime3 = (num2 = _fUsedTime3 + Time.deltaTime);
			if (!(num2 < fHandMoveBackTime))
			{
				break;
			}
			yield return new WaitForFixedUpdate();
			Transform obj = m_RobotHand.transform;
			currentAngle2 = (num2 = currentAngle2 - fMoveTime2 * Time.deltaTime);
			obj.localEulerAngles = new Vector3(num2, 0f, 0f);
		}
		currentAngle2 = angleM / fHandMoveForwardTime;
		fMoveTime2 = 0f;
		_fUsedTime3 = fHandAngle - angleM;
		while (true)
		{
			float num2;
			fMoveTime2 = (num2 = fMoveTime2 + Time.deltaTime);
			if (!(num2 < fHandMoveForwardTime))
			{
				break;
			}
			yield return new WaitForFixedUpdate();
			Transform obj2 = m_RobotHand.transform;
			_fUsedTime3 = (num2 = _fUsedTime3 + currentAngle2 * Time.deltaTime);
			obj2.localEulerAngles = new Vector3(num2, 0f, 0f);
		}
		m_RobotHand.transform.localEulerAngles = new Vector3(fHandAngle, 0f, 0f);
	}

	private void ComRacketPlayBack(Vector3 fromPos)
	{
		bIsToDir = false;
		audioHit_Com.Play();
		float num = 35f;
		float ballXShiftLimit = m_ComRacket.m_ballXShiftLimit;
		Vector2 ballGravityLimit = m_ComRacket.m_ballGravityLimit;
		Vector2 ballTimeSpeedLimit = m_ComRacket.m_ballTimeSpeedLimit;
		float num2 = (float)m_iCurScore * 1f / num;
		float num3 = num2 * ballXShiftLimit;
		float x = UnityEngine.Random.Range(0f - num3, num3);
		Vector3 vTo = m_PlayerPoint.transform.position + new Vector3(x, 0f, 0f);
		float max = num2 * (ballGravityLimit.y - ballGravityLimit.x) + ballGravityLimit.x;
		float min = ballTimeSpeedLimit.y - num2 * (ballTimeSpeedLimit.y - ballTimeSpeedLimit.x);
		m_ballMotionCtrl.StartMoveFromTo(fromPos, vTo, UnityEngine.Random.Range(min, ballTimeSpeedLimit.y), UnityEngine.Random.Range(ballGravityLimit.x, max));
	}

	public void J_AddScore(bool isAdd)
	{
		if (isAdd)
		{
			m_iCurScore++;
			if (m_iCurScore > fHighestScore)
			{
				fHighestScore = m_iCurScore;
				m_txtHighestScore.text = string.Concat(fHighestScore);
				PlayerPrefs.SetInt("HighestScore_ymq", fHighestScore);
			}
		}
		else
		{
			m_iCurScore = 0;
		}
		m_txtScore.text = "Score：" + m_iCurScore;
	}
}
public class YMQ_LoginController : MonoBehaviour
{
	public Button playBtn;

	public Button exitBtn;

	private void Start()
	{
		playBtn.onClick.AddListener(PlayBtnHander);
		exitBtn.onClick.AddListener(ExitBtnHander);
	}

	private void PlayBtnHander()
	{
		SceneManager.LoadScene("LT_LT_Sports Games");
	}

	private void ExitBtnHander()
	{
		Application.Quit();
	}

	private void Update()
	{
	}
}
public class YMQ_Racket : MonoBehaviour
{
	[Header("ball")]
	public float m_ballXShiftLimit = 1.5f;

	public Vector2 m_ballGravityLimit = new Vector2(-3f, -9f);

	public Vector2 m_ballTimeSpeedLimit = new Vector2(0.6f, 2f);

	[Header("Racket Force")]
	public float m_forceMinStart = 8f;

	public float m_forceMinForce = 3f;

	public float m_forceXLimit = 6f;

	public float m_forceYLimit = 3f;

	public Vector2 m_forceMaxLimit = new Vector2(1f, 20f);
}
public class ParentedObjectStressTestMain : MonoBehaviour
{
	public GameObject Object;

	public Vector3 NumObjects;

	public Vector3 Spacing;

	public void Start()
	{
		for (int i = 0; i < (int)NumObjects.x; i++)
		{
			for (int j = 0; j < (int)NumObjects.y; j++)
			{
				for (int k = 0; k < (int)NumObjects.z; k++)
				{
					UnityEngine.Object.Instantiate(Object).transform.position = new Vector3(2f * ((float)i / (NumObjects.x - 1f) - 0.5f) * NumObjects.x * Spacing.x, 2f * ((float)j / (NumObjects.y - 1f) - 0.5f) * NumObjects.y * Spacing.y, 2f * ((float)k / (NumObjects.z - 1f) - 0.5f) * NumObjects.z * Spacing.z);
				}
			}
		}
	}
}
public class JellyfishUFOCamera : MonoBehaviour
{
	public Transform Target;

	private Vector3Spring m_spring;

	private void Start()
	{
		if (!(Target == null))
		{
			m_spring.Reset(Target.transform.position);
		}
	}

	private void FixedUpdate()
	{
		if (!(Target == null))
		{
			m_spring.TrackExponential(Target.transform.position, 0.5f, Time.fixedDeltaTime);
			Vector3 normalized = (m_spring.Value - base.transform.position).normalized;
			base.transform.rotation = Quaternion.LookRotation(normalized);
		}
	}
}
public class LengthStiffnessComparison : MonoBehaviour
{
	public float Run = 11f;

	public float Tilt = 15f;

	public float Period = 3f;

	public float Rest = 3f;

	public Transform BonesA;

	public Transform BonesB;

	private float m_timer;

	private void Start()
	{
		m_timer = 0f;
	}

	private void FixedUpdate()
	{
		BoingBones[] components = BonesA.GetComponents<BoingBones>();
		BoingBones[] components2 = BonesB.GetComponents<BoingBones>();
		Transform[] array = new Transform[2] { BonesA.transform, BonesB.transform };
		IEnumerable<BoingBones> enumerable = components.Concat(components2);
		float fixedDeltaTime = Time.fixedDeltaTime;
		float num = 0.5f * Run;
		m_timer += fixedDeltaTime;
		Transform[] array2;
		if (m_timer > Period + Rest)
		{
			m_timer = Mathf.Repeat(m_timer, Period + Rest);
			array2 = array;
			foreach (Transform obj in array2)
			{
				Vector3 position = obj.position;
				position.z = 0f - num;
				obj.position = position;
			}
			foreach (BoingBones item in enumerable)
			{
				item.Reboot();
			}
		}
		float num2 = Mathf.Min(1f, m_timer * MathUtil.InvSafe(Period));
		float num3 = 1f - Mathf.Pow(1f - num2, 6f);
		array2 = array;
		foreach (Transform obj2 in array2)
		{
			Vector3 position2 = obj2.position;
			position2.z = Mathf.Lerp(0f - num, num, num3);
			obj2.position = position2;
			obj2.rotation = Quaternion.AngleAxis(Tilt * (1f - num3), Vector3.right);
		}
	}
}
public class PoseStiffnessComparison : MonoBehaviour
{
	public float Run = 11f;

	public float Tilt = 15f;

	public float Period = 3f;

	public float Rest = 3f;

	public Transform BonesA;

	public Transform BonesB;

	private float m_yA;

	private float m_yB;

	private float m_timer;

	private void Start()
	{
		m_timer = 0f;
		m_yA = BonesA.position.y;
		m_yB = BonesB.position.y;
	}

	private void FixedUpdate()
	{
		BoingBones[] components = BonesA.GetComponents<BoingBones>();
		BoingBones[] components2 = BonesB.GetComponents<BoingBones>();
		Transform[] source = new Transform[2] { BonesA.transform, BonesB.transform };
		float[] source2 = new float[2] { m_yA, m_yB };
		IEnumerable<BoingBones> enumerable = components.Concat(components2);
		float fixedDeltaTime = Time.fixedDeltaTime;
		float num = 0.5f * Run;
		m_timer += fixedDeltaTime;
		if (m_timer > Period + Rest)
		{
			m_timer = Mathf.Repeat(m_timer, Period + Rest);
			for (int i = 0; i < 2; i++)
			{
				Transform obj = source.ElementAt(i);
				float y = source2.ElementAt(i);
				Vector3 position = obj.position;
				position.y = y;
				position.z = 0f - num;
				obj.position = position;
			}
			foreach (BoingBones item in enumerable)
			{
				item.Reboot();
			}
		}
		float num2 = Mathf.Min(1f, m_timer * MathUtil.InvSafe(Period));
		float num3 = 1f - Mathf.Pow(1f - num2, 1.5f);
		for (int j = 0; j < 2; j++)
		{
			Transform obj2 = source.ElementAt(j);
			float num4 = source2.ElementAt(j);
			Vector3 position2 = obj2.position;
			position2.y = num4 + 2f * Mathf.Sin((float)Math.PI * 4f * num3);
			position2.z = Mathf.Lerp(0f - num, num, num3);
			obj2.position = position2;
		}
	}
}
public class SquashAndStretchComparison : MonoBehaviour
{
	public float Run = 11f;

	public float Period = 3f;

	public float Rest = 3f;

	public Transform BonesA;

	public Transform BonesB;

	private float m_timer;

	private void Start()
	{
		m_timer = 0f;
	}

	private void FixedUpdate()
	{
		BoingBones[] components = BonesA.GetComponents<BoingBones>();
		BoingBones[] components2 = BonesB.GetComponents<BoingBones>();
		Transform[] array = new Transform[2] { BonesA.transform, BonesB.transform };
		IEnumerable<BoingBones> enumerable = components.Concat(components2);
		float fixedDeltaTime = Time.fixedDeltaTime;
		float num = 0.5f * Run;
		m_timer += fixedDeltaTime;
		Transform[] array2;
		if (m_timer > Period + Rest)
		{
			m_timer = Mathf.Repeat(m_timer, Period + Rest);
			array2 = array;
			foreach (Transform obj in array2)
			{
				Vector3 position = obj.position;
				position.z = 0f - num;
				obj.position = position;
			}
			foreach (BoingBones item in enumerable)
			{
				item.Reboot();
			}
		}
		float num2 = Mathf.Min(1f, m_timer * MathUtil.InvSafe(Period));
		float t = 1f - Mathf.Pow(1f - num2, 6f);
		array2 = array;
		foreach (Transform obj2 in array2)
		{
			Vector3 position2 = obj2.position;
			position2.z = Mathf.Lerp(0f - num, num, t);
			obj2.position = position2;
		}
	}
}
public class ColliderSpinner : MonoBehaviour
{
	public Transform Target;

	private Vector3 m_targetOffset;

	private Vector3Spring m_spring;

	private void Start()
	{
		m_targetOffset = ((Target != null) ? (base.transform.position - Target.position) : Vector3.zero);
		m_spring.Reset(base.transform.position);
	}

	private void FixedUpdate()
	{
		Vector3 targetValue = Target.position + m_targetOffset;
		base.transform.position = m_spring.TrackExponential(targetValue, 0.02f, Time.fixedDeltaTime);
	}
}
public class UFOCamera : MonoBehaviour
{
	public Transform Target;

	private Vector3 m_targetOffset;

	private Vector3Spring m_spring;

	private void Start()
	{
		if (!(Target == null))
		{
			m_targetOffset = base.transform.position - Target.position;
			m_spring.Reset(base.transform.position);
		}
	}

	private void FixedUpdate()
	{
		if (!(Target == null))
		{
			Vector3 targetValue = Target.position + m_targetOffset;
			base.transform.position = m_spring.TrackExponential(targetValue, 0.02f, Time.fixedDeltaTime);
		}
	}
}
public class UFOEffector : MonoBehaviour
{
	private float m_radius;

	private float m_moveDistance;

	private float m_rotateAngle;

	public void Start()
	{
		BoingEffector component = GetComponent<BoingEffector>();
		m_radius = component.Radius;
		m_moveDistance = component.MoveDistance;
		m_rotateAngle = component.RotationAngle;
	}

	public void FixedUpdate()
	{
		BoingEffector component = GetComponent<BoingEffector>();
		component.Radius = m_radius * (1f + 0.2f * Mathf.Sin(11f * Time.time) * Mathf.Sin(7f * Time.time + 1.54f));
		component.MoveDistance = m_moveDistance * (1f + 0.2f * Mathf.Sin(9.3f * Time.time + 5.19f) * Mathf.Sin(7.3f * Time.time + 4.73f));
		component.RotationAngle = m_rotateAngle * (1f + 0.2f * Mathf.Sin(7.9f * Time.time + 2.97f) * Mathf.Sin(8.3f * Time.time + 0.93f));
		base.transform.localPosition = Vector3.right * 0.25f * Mathf.Sin(5.23f * Time.time + 9.87f) + Vector3.forward * 0.25f * Mathf.Sin(4.93f * Time.time + 7.39f);
	}
}
public class CollectibleCoin : MonoBehaviour
{
	public float RespawnTime;

	private bool m_taken;

	private Vector3 m_respawnPosition;

	private float m_respawnTimerStartTime;

	public void Update()
	{
		BoingBehavior component = GetComponent<BoingBehavior>();
		if (m_taken)
		{
			if (Time.time - m_respawnTimerStartTime < RespawnTime)
			{
				return;
			}
			base.transform.position = m_respawnPosition + 0.4f * Vector3.down;
			if (component != null)
			{
				component.Reboot();
			}
			base.transform.position = m_respawnPosition;
			m_taken = false;
		}
		GameObject obj = GameObject.Find("Character");
		GameObject gameObject = GameObject.Find("Coin Icon");
		GameObject gameObject2 = GameObject.Find("Coin Counter");
		if (!((obj.transform.position - base.transform.position).sqrMagnitude > 0.4f))
		{
			m_respawnPosition = base.transform.position;
			if (component != null)
			{
				Vector3Spring positionSpring = component.PositionSpring;
				positionSpring.Reset(base.transform.position, new Vector3(100f, 0f, 0f));
				component.PositionSpring = positionSpring;
			}
			base.transform.position = gameObject.transform.position + new Vector3(-2f, 0.5f, 0f);
			TextMesh component2 = gameObject2.GetComponent<TextMesh>();
			component2.text = (Convert.ToInt32(component2.text) + 1).ToString();
			m_respawnTimerStartTime = Time.time;
			m_taken = true;
		}
	}
}
public class PlatformerCollectiblesMain : MonoBehaviour
{
	public GameObject Coin;

	public float CoinGridCount = 5f;

	public float CoinGridSize = 7f;

	public void Start()
	{
		for (int i = 0; (float)i < CoinGridCount; i++)
		{
			float x = -0.5f * CoinGridSize + CoinGridSize * (float)i / (CoinGridCount - 1f);
			for (int j = 0; (float)j < CoinGridCount; j++)
			{
				float z = -0.5f * CoinGridSize + CoinGridSize * (float)j / (CoinGridCount - 1f);
				UnityEngine.Object.Instantiate(Coin).transform.position = new Vector3(x, 0.2f, z);
			}
		}
	}
}
public class ImplosionExplosionMain : MonoBehaviour
{
	public BoingReactorField ReactorField;

	public GameObject Diamond;

	public int NumDiamonds;

	private static readonly int kNumInstancedBushesPerDrawCall = 1000;

	private Matrix4x4[][] m_aaInstancedDiamondMatrix;

	private MaterialPropertyBlock m_diamondMaterialProps;

	public void Start()
	{
		m_aaInstancedDiamondMatrix = new Matrix4x4[(NumDiamonds + kNumInstancedBushesPerDrawCall - 1) / kNumInstancedBushesPerDrawCall][];
		for (int i = 0; i < m_aaInstancedDiamondMatrix.Length; i++)
		{
			m_aaInstancedDiamondMatrix[i] = new Matrix4x4[kNumInstancedBushesPerDrawCall];
		}
		for (int j = 0; j < NumDiamonds; j++)
		{
			float num = UnityEngine.Random.Range(0.1f, 0.4f);
			Vector3 pos = new Vector3(UnityEngine.Random.Range(-3.5f, 3.5f), UnityEngine.Random.Range(0.5f, 7f), UnityEngine.Random.Range(-3.5f, 3.5f));
			Quaternion q = Quaternion.Euler(UnityEngine.Random.Range(0f, 360f), UnityEngine.Random.Range(0f, 360f), UnityEngine.Random.Range(0f, 360f));
			m_aaInstancedDiamondMatrix[j / kNumInstancedBushesPerDrawCall][j % kNumInstancedBushesPerDrawCall].SetTRS(pos, q, num * Vector3.one);
		}
	}

	public void Update()
	{
		Mesh sharedMesh = Diamond.GetComponent<MeshFilter>().sharedMesh;
		Material sharedMaterial = Diamond.GetComponent<MeshRenderer>().sharedMaterial;
		if (m_diamondMaterialProps == null)
		{
			m_diamondMaterialProps = new MaterialPropertyBlock();
		}
		if (ReactorField.UpdateShaderConstants(m_diamondMaterialProps))
		{
			Matrix4x4[][] aaInstancedDiamondMatrix = m_aaInstancedDiamondMatrix;
			foreach (Matrix4x4[] array in aaInstancedDiamondMatrix)
			{
				Graphics.DrawMeshInstanced(sharedMesh, 0, sharedMaterial, array, array.Length, m_diamondMaterialProps);
			}
		}
	}
}
public class OrbitCamera : MonoBehaviour
{
	private static readonly float kOrbitSpeed = 0.01f;

	private float m_phase;

	public void Start()
	{
	}

	public void Update()
	{
		m_phase += kOrbitSpeed * MathUtil.TwoPi * Time.deltaTime;
		base.transform.position = new Vector3(-4f * Mathf.Cos(m_phase), 6f, 4f * Mathf.Sin(m_phase));
		base.transform.rotation = Quaternion.LookRotation((new Vector3(0f, 3f, 0f) - base.transform.position).normalized);
	}
}
public class ScaleSpring : MonoBehaviour
{
	private static readonly float kInterval = 2f;

	private static readonly float kSmallScale = 0.6f;

	private static readonly float kLargeScale = 2f;

	private static readonly float kMoveDistance = 30f;

	private Vector3Spring m_spring;

	private float m_targetScale;

	private float m_lastTickTime;

	public void Tick()
	{
		m_targetScale = ((m_targetScale == kSmallScale) ? kLargeScale : kSmallScale);
		m_lastTickTime = Time.time;
		GetComponent<BoingEffector>().MoveDistance = kMoveDistance * ((m_targetScale == kSmallScale) ? (-1f) : 1f);
	}

	public void Start()
	{
		Tick();
		m_spring.Reset(m_targetScale * Vector3.one);
	}

	public void FixedUpdate()
	{
		if (Time.time - m_lastTickTime > kInterval)
		{
			Tick();
		}
		m_spring.TrackHalfLife(m_targetScale * Vector3.one, 6f, 0.05f, Time.fixedDeltaTime);
		base.transform.localScale = m_spring.Value;
		GetComponent<BoingEffector>().MoveDistance *= Mathf.Min(0.99f, 35f * Time.fixedDeltaTime);
	}
}
public class LiquidMain : MonoBehaviour
{
	public Material PlaneMaterial;

	public BoingReactorField ReactorField;

	public GameObject Effector;

	private static readonly float kPlaneMeshCellSize = 0.25f;

	private static readonly int kNumInstancedPlaneCellPerDrawCall = 1000;

	private static readonly int kNumMovingEffectors = 5;

	private static readonly float kMovingEffectorPhaseSpeed = 0.5f;

	private static int kNumPlaneCells;

	private static readonly int kPlaneMeshResolution = 64;

	private Mesh m_planeMesh;

	private Matrix4x4[][] m_aaInstancedPlaneCellMatrix;

	private GameObject[] m_aMovingEffector;

	private float[] m_aMovingEffectorPhase;

	private void ResetEffector(GameObject obj)
	{
		obj.transform.position = new Vector3(UnityEngine.Random.Range(-0.3f, 0.3f), -100f, UnityEngine.Random.Range(-0.3f, 0.3f)) * kPlaneMeshCellSize * kPlaneMeshResolution;
	}

	public void Start()
	{
		m_planeMesh = new Mesh();
		m_planeMesh.vertices = new Vector3[4]
		{
			new Vector3(-0.5f, 0f, -0.5f) * kPlaneMeshCellSize,
			new Vector3(-0.5f, 0f, 0.5f) * kPlaneMeshCellSize,
			new Vector3(0.5f, 0f, 0.5f) * kPlaneMeshCellSize,
			new Vector3(0.5f, 0f, -0.5f) * kPlaneMeshCellSize
		};
		m_planeMesh.normals = new Vector3[4]
		{
			new Vector3(0f, 1f, 0f),
			new Vector3(0f, 1f, 0f),
			new Vector3(0f, 1f, 0f),
			new Vector3(0f, 1f, 0f)
		};
		m_planeMesh.SetIndices(new int[6] { 0, 1, 2, 0, 2, 3 }, MeshTopology.Triangles, 0);
		kNumPlaneCells = kPlaneMeshResolution * kPlaneMeshResolution;
		m_aaInstancedPlaneCellMatrix = new Matrix4x4[(kNumPlaneCells + kNumInstancedPlaneCellPerDrawCall - 1) / kNumInstancedPlaneCellPerDrawCall][];
		for (int i = 0; i < m_aaInstancedPlaneCellMatrix.Length; i++)
		{
			m_aaInstancedPlaneCellMatrix[i] = new Matrix4x4[kNumInstancedPlaneCellPerDrawCall];
		}
		Vector3 vector = new Vector3(-0.5f, 0f, -0.5f) * kPlaneMeshCellSize * kPlaneMeshResolution;
		for (int j = 0; j < kPlaneMeshResolution; j++)
		{
			for (int k = 0; k < kPlaneMeshResolution; k++)
			{
				int num = j * kPlaneMeshResolution + k;
				Matrix4x4 matrix4x = Matrix4x4.TRS(new Vector3(k, 0f, j) * kPlaneMeshCellSize + vector, Quaternion.identity, Vector3.one);
				m_aaInstancedPlaneCellMatrix[num / kNumInstancedPlaneCellPerDrawCall][num % kNumInstancedPlaneCellPerDrawCall] = matrix4x;
			}
		}
		m_aMovingEffector = new GameObject[kNumMovingEffectors];
		m_aMovingEffectorPhase = new float[kNumMovingEffectors];
		BoingEffector[] array = new BoingEffector[kNumMovingEffectors];
		for (int l = 0; l < kNumMovingEffectors; l++)
		{
			GameObject gameObject = UnityEngine.Object.Instantiate(Effector);
			m_aMovingEffector[l] = gameObject;
			ResetEffector(gameObject);
			m_aMovingEffectorPhase[l] = 0f - MathUtil.HalfPi + (float)l / (float)kNumMovingEffectors * MathUtil.Pi;
			array[l] = gameObject.GetComponent<BoingEffector>();
		}
		ReactorField.Effectors = array;
	}

	public void Update()
	{
		ReactorField.UpdateShaderConstants(PlaneMaterial);
		int num = kNumPlaneCells;
		for (int i = 0; i < m_aaInstancedPlaneCellMatrix.Length; i++)
		{
			Matrix4x4[] matrices = m_aaInstancedPlaneCellMatrix[i];
			Graphics.DrawMeshInstanced(m_planeMesh, 0, PlaneMaterial, matrices, Mathf.Min(num, kNumInstancedPlaneCellPerDrawCall));
			num -= kNumInstancedPlaneCellPerDrawCall;
		}
		for (int j = 0; j < kNumMovingEffectors; j++)
		{
			GameObject gameObject = m_aMovingEffector[j];
			float num2 = m_aMovingEffectorPhase[j];
			num2 += MathUtil.TwoPi * kMovingEffectorPhaseSpeed * Time.deltaTime;
			float num3 = num2;
			num2 = Mathf.Repeat(num2 + MathUtil.HalfPi, MathUtil.Pi) - MathUtil.HalfPi;
			m_aMovingEffectorPhase[j] = num2;
			if (num2 < num3 - 0.01f)
			{
				ResetEffector(gameObject);
			}
			Vector3 position = gameObject.transform.position;
			position.y = Mathf.Tan(Mathf.Clamp(num2, 0f - MathUtil.HalfPi + 0.2f, MathUtil.HalfPi - 0.2f)) + 3.5f;
			gameObject.transform.position = position;
		}
	}
}
public class CurveBall : MonoBehaviour
{
	public float Interval = 2f;

	private float m_speedX;

	private float m_speedZ;

	private float m_timer;

	public void Reset()
	{
		float f = UnityEngine.Random.Range(0f, MathUtil.TwoPi);
		float num = Mathf.Cos(f);
		float num2 = Mathf.Sin(f);
		m_speedX = 40f * num;
		m_speedZ = 40f * num2;
		m_timer = 0f;
		Vector3 position = base.transform.position;
		position.x = -10f * num;
		position.z = -10f * num2;
		base.transform.position = position;
	}

	public void Start()
	{
		Reset();
	}

	public void Update()
	{
		float deltaTime = Time.deltaTime;
		if (m_timer > Interval)
		{
			Reset();
		}
		Vector3 position = base.transform.position;
		position.x += m_speedX * deltaTime;
		position.z += m_speedZ * deltaTime;
		base.transform.position = position;
		m_timer += deltaTime;
	}
}
public class BushFieldReactorFieldMain : MonoBehaviour
{
	public GameObject Bush;

	public GameObject Blossom;

	public GameObject Sphere;

	public BoingReactorField ReactorField;

	public int NumBushes;

	public Vector2 BushScaleRange;

	public int NumBlossoms;

	public Vector2 BlossomScaleRange;

	public Vector2 FieldBounds;

	public int NumSpheresPerCircle;

	public int NumCircles;

	public float MaxCircleRadius;

	public float CircleSpeed;

	private List<BoingEffector> m_aSphere;

	private float m_basePhase;

	private static readonly int kNumInstancedBushesPerDrawCall = 1000;

	private Matrix4x4[][] m_aaInstancedBushMatrix;

	private MaterialPropertyBlock m_bushMaterialProps;

	public void Start()
	{
		UnityEngine.Random.InitState(0);
		if (Bush.GetComponent<BoingReactorFieldGPUSampler>() == null)
		{
			for (int i = 0; i < NumBushes; i++)
			{
				GameObject obj = UnityEngine.Object.Instantiate(Bush);
				float num = UnityEngine.Random.Range(BushScaleRange.x, BushScaleRange.y);
				obj.transform.position = new Vector3(UnityEngine.Random.Range(-0.5f * FieldBounds.x, 0.5f * FieldBounds.x), 0.2f * num, UnityEngine.Random.Range(-0.5f * FieldBounds.y, 0.5f * FieldBounds.y));
				obj.transform.rotation = Quaternion.Euler(0f, UnityEngine.Random.Range(0f, 360f), 0f);
				obj.transform.localScale = num * Vector3.one;
				BoingReactorFieldCPUSampler component = obj.GetComponent<BoingReactorFieldCPUSampler>();
				if (component != null)
				{
					component.ReactorField = ReactorField;
				}
				BoingReactorFieldGPUSampler component2 = obj.GetComponent<BoingReactorFieldGPUSampler>();
				if (component2 != null)
				{
					component2.ReactorField = ReactorField;
				}
			}
		}
		else
		{
			m_aaInstancedBushMatrix = new Matrix4x4[(NumBushes + kNumInstancedBushesPerDrawCall - 1) / kNumInstancedBushesPerDrawCall][];
			for (int j = 0; j < m_aaInstancedBushMatrix.Length; j++)
			{
				m_aaInstancedBushMatrix[j] = new Matrix4x4[kNumInstancedBushesPerDrawCall];
			}
			for (int k = 0; k < NumBushes; k++)
			{
				float num2 = UnityEngine.Random.Range(BushScaleRange.x, BushScaleRange.y);
				Vector3 pos = new Vector3(UnityEngine.Random.Range(-0.5f * FieldBounds.x, 0.5f * FieldBounds.x), 0.2f * num2, UnityEngine.Random.Range(-0.5f * FieldBounds.y, 0.5f * FieldBounds.y));
				Quaternion q = Quaternion.Euler(0f, UnityEngine.Random.Range(0f, 360f), 0f);
				m_aaInstancedBushMatrix[k / kNumInstancedBushesPerDrawCall][k % kNumInstancedBushesPerDrawCall].SetTRS(pos, q, num2 * Vector3.one);
			}
		}
		for (int l = 0; l < NumBlossoms; l++)
		{
			GameObject obj2 = UnityEngine.Object.Instantiate(Blossom);
			float num3 = UnityEngine.Random.Range(BlossomScaleRange.x, BlossomScaleRange.y);
			obj2.transform.position = new Vector3(UnityEngine.Random.Range(-0.5f * FieldBounds.x, 0.5f * FieldBounds.y), 0.2f * num3, UnityEngine.Random.Range(-0.5f * FieldBounds.y, 0.5f * FieldBounds.y));
			obj2.transform.rotation = Quaternion.Euler(0f, UnityEngine.Random.Range(0f, 360f), 0f);
			obj2.transform.localScale = num3 * Vector3.one;
			obj2.GetComponent<BoingReactorFieldCPUSampler>().ReactorField = ReactorField;
		}
		m_aSphere = new List<BoingEffector>(NumSpheresPerCircle * NumCircles);
		for (int m = 0; m < NumCircles; m++)
		{
			for (int n = 0; n < NumSpheresPerCircle; n++)
			{
				GameObject gameObject = UnityEngine.Object.Instantiate(Sphere);
				m_aSphere.Add(gameObject.GetComponent<BoingEffector>());
			}
		}
		BoingReactorField component3 = ReactorField.GetComponent<BoingReactorField>();
		component3.Effectors = ((component3.Effectors != null) ? component3.Effectors.Concat(m_aSphere.ToArray()).ToArray() : m_aSphere.ToArray());
		m_basePhase = 0f;
	}

	public void Update()
	{
		int num = 0;
		for (int i = 0; i < NumCircles; i++)
		{
			float num2 = MaxCircleRadius / (float)(i + 1);
			for (int j = 0; j < NumSpheresPerCircle; j++)
			{
				float num3 = m_basePhase + (float)j / (float)NumSpheresPerCircle * 2f * (float)Math.PI;
				num3 *= ((i % 2 == 0) ? 1f : (-1f));
				m_aSphere[num].transform.position = new Vector3(num2 * Mathf.Cos(num3), 0.2f, num2 * Mathf.Sin(num3));
				num++;
			}
		}
		m_basePhase -= CircleSpeed / MaxCircleRadius * Time.deltaTime;
		if (m_aaInstancedBushMatrix == null)
		{
			return;
		}
		Mesh sharedMesh = Bush.GetComponent<MeshFilter>().sharedMesh;
		Material sharedMaterial = Bush.GetComponent<MeshRenderer>().sharedMaterial;
		if (m_bushMaterialProps == null)
		{
			m_bushMaterialProps = new MaterialPropertyBlock();
		}
		if (ReactorField.UpdateShaderConstants(m_bushMaterialProps))
		{
			Matrix4x4[][] aaInstancedBushMatrix = m_aaInstancedBushMatrix;
			foreach (Matrix4x4[] array in aaInstancedBushMatrix)
			{
				Graphics.DrawMeshInstanced(sharedMesh, 0, sharedMaterial, array, array.Length, m_bushMaterialProps);
			}
		}
	}
}
public class BushFieldReactorMain : MonoBehaviour
{
	public GameObject Bush;

	public GameObject Blossom;

	public GameObject Sphere;

	public int NumBushes;

	public Vector2 BushScaleRange;

	public int NumBlossoms;

	public Vector2 BlossomScaleRange;

	public Vector2 FieldBounds;

	public int NumSpheresPerCircle;

	public int NumCircles;

	public float MaxCircleRadius;

	public float CircleSpeed;

	private List<GameObject> m_aSphere;

	private float m_basePhase;

	public void Start()
	{
		UnityEngine.Random.InitState(0);
		for (int i = 0; i < NumBushes; i++)
		{
			GameObject obj = UnityEngine.Object.Instantiate(Bush);
			float num = UnityEngine.Random.Range(BushScaleRange.x, BushScaleRange.y);
			obj.transform.position = new Vector3(UnityEngine.Random.Range(-0.5f * FieldBounds.x, 0.5f * FieldBounds.x), 0.2f * num, UnityEngine.Random.Range(-0.5f * FieldBounds.y, 0.5f * FieldBounds.y));
			obj.transform.rotation = Quaternion.Euler(0f, UnityEngine.Random.Range(0f, 360f), 0f);
			obj.transform.localScale = num * Vector3.one;
			BoingBehavior component = obj.GetComponent<BoingBehavior>();
			if (component != null)
			{
				component.Reboot();
			}
		}
		for (int j = 0; j < NumBlossoms; j++)
		{
			GameObject obj2 = UnityEngine.Object.Instantiate(Blossom);
			float num2 = UnityEngine.Random.Range(BlossomScaleRange.x, BlossomScaleRange.y);
			obj2.transform.position = new Vector3(UnityEngine.Random.Range(-0.5f * FieldBounds.x, 0.5f * FieldBounds.y), 0.2f * num2, UnityEngine.Random.Range(-0.5f * FieldBounds.y, 0.5f * FieldBounds.y));
			obj2.transform.rotation = Quaternion.Euler(0f, UnityEngine.Random.Range(0f, 360f), 0f);
			obj2.transform.localScale = num2 * Vector3.one;
			BoingBehavior component2 = obj2.GetComponent<BoingBehavior>();
			if (component2 != null)
			{
				component2.Reboot();
			}
		}
		m_aSphere = new List<GameObject>(NumSpheresPerCircle * NumCircles);
		for (int k = 0; k < NumCircles; k++)
		{
			for (int l = 0; l < NumSpheresPerCircle; l++)
			{
				m_aSphere.Add(UnityEngine.Object.Instantiate(Sphere));
			}
		}
		m_basePhase = 0f;
	}

	public void Update()
	{
		int num = 0;
		for (int i = 0; i < NumCircles; i++)
		{
			float num2 = MaxCircleRadius / (float)(i + 1);
			for (int j = 0; j < NumSpheresPerCircle; j++)
			{
				float num3 = m_basePhase + (float)j / (float)NumSpheresPerCircle * 2f * (float)Math.PI;
				num3 *= ((i % 2 == 0) ? 1f : (-1f));
				m_aSphere[num].transform.position = new Vector3(num2 * Mathf.Cos(num3), 0.2f, num2 * Mathf.Sin(num3));
				num++;
			}
		}
		m_basePhase -= CircleSpeed / MaxCircleRadius * Time.deltaTime;
	}
}
public class MousePositionDrag : MonoBehaviour
{
	private bool m_currFrameHasFocus;

	private bool m_prevFrameHasFocus;

	private Vector3 m_prevMousePosition;

	private void Start()
	{
		m_currFrameHasFocus = false;
		m_prevFrameHasFocus = false;
	}

	private void Update()
	{
		m_currFrameHasFocus = Application.isFocused;
		bool prevFrameHasFocus = m_prevFrameHasFocus;
		m_prevFrameHasFocus = m_currFrameHasFocus;
		if (prevFrameHasFocus || m_currFrameHasFocus)
		{
			Vector3 mousePosition = Input.mousePosition;
			Vector3 prevMousePosition = m_prevMousePosition;
			Vector3 vector = mousePosition - prevMousePosition;
			m_prevMousePosition = mousePosition;
			if (prevFrameHasFocus && Input.GetMouseButton(0))
			{
				base.transform.position += 0.02f * vector;
			}
		}
	}
}
public class MouseRotationDrag : MonoBehaviour
{
	private bool m_currFrameHasFocus;

	private bool m_prevFrameHasFocus;

	private Vector3 m_prevMousePosition;

	private Vector3 m_euler;

	private void Start()
	{
		m_currFrameHasFocus = false;
		m_prevFrameHasFocus = false;
	}

	private void Update()
	{
		m_currFrameHasFocus = Application.isFocused;
		bool prevFrameHasFocus = m_prevFrameHasFocus;
		m_prevFrameHasFocus = m_currFrameHasFocus;
		if (prevFrameHasFocus || m_currFrameHasFocus)
		{
			Vector3 mousePosition = Input.mousePosition;
			Vector3 prevMousePosition = m_prevMousePosition;
			Vector3 vector = mousePosition - prevMousePosition;
			m_prevMousePosition = mousePosition;
			if (!prevFrameHasFocus)
			{
				m_euler = base.transform.rotation.eulerAngles;
			}
			else if (Input.GetMouseButton(0))
			{
				m_euler.x += vector.y;
				m_euler.y += vector.x;
				base.transform.rotation = Quaternion.Euler(m_euler);
			}
		}
	}
}
public class Oscillator : MonoBehaviour
{
	public enum WaveTypeEnum
	{
		Sine,
		Square,
		Triangle
	}

	public WaveTypeEnum WaveType;

	private Vector3 m_initCenter;

	public bool UseCenter;

	public Vector3 Center;

	public Vector3 Radius;

	public Vector3 Frequency;

	public Vector3 Phase;

	public void Init(Vector3 center, Vector3 radius, Vector3 frequency, Vector3 startPhase)
	{
		Center = center;
		Radius = radius;
		Frequency = frequency;
		Phase = startPhase;
	}

	private float SampleWave(float phase)
	{
		switch (WaveType)
		{
		case WaveTypeEnum.Sine:
			return Mathf.Sin(phase);
		case WaveTypeEnum.Square:
			phase = Mathf.Repeat(phase, (float)Math.PI * 2f);
			if (!(phase < (float)Math.PI))
			{
				return -1f;
			}
			return 1f;
		case WaveTypeEnum.Triangle:
			phase = Mathf.Repeat(phase, (float)Math.PI * 2f);
			if (phase < (float)Math.PI / 2f)
			{
				return phase / ((float)Math.PI / 2f);
			}
			if (phase < (float)Math.PI)
			{
				return 1f - (phase - (float)Math.PI / 2f) / ((float)Math.PI / 2f);
			}
			if (phase < 4.712389f)
			{
				return ((float)Math.PI - phase) / ((float)Math.PI / 2f);
			}
			return (phase - 4.712389f) / ((float)Math.PI / 2f) - 1f;
		default:
			return 0f;
		}
	}

	public void OnEnable()
	{
		m_initCenter = base.transform.position;
	}

	public void Update()
	{
		Phase += Frequency * 2f * (float)Math.PI * Time.deltaTime;
		Vector3 position = (UseCenter ? Center : m_initCenter);
		position.x += Radius.x * SampleWave(Phase.x);
		position.y += Radius.y * SampleWave(Phase.y);
		position.z += Radius.z * SampleWave(Phase.z);
		base.transform.position = position;
	}
}
public class RotationStepper : MonoBehaviour
{
	public enum ModeEnum
	{
		Fixed,
		Random
	}

	public ModeEnum Mode;

	[ConditionalField("Mode", ModeEnum.Fixed, null, null, null, null, null)]
	public float Angle = 25f;

	public float Frequency;

	private float m_phase;

	public void OnEnable()
	{
		m_phase = 0f;
		UnityEngine.Random.InitState(0);
	}

	public void Update()
	{
		m_phase += Frequency * Time.deltaTime;
		switch (Mode)
		{
		default:
			return;
		case ModeEnum.Fixed:
			base.transform.rotation = Quaternion.Euler(0f, 0f, (Mathf.Repeat(m_phase, 2f) < 1f) ? (-25f) : 25f);
			return;
		case ModeEnum.Random:
			break;
		}
		while (m_phase >= 1f)
		{
			UnityEngine.Random.InitState(Time.frameCount);
			base.transform.rotation = UnityEngine.Random.rotationUniform;
			m_phase -= 1f;
		}
	}
}
public class Spinner : MonoBehaviour
{
	public float Speed;

	private float m_angle;

	public void OnEnable()
	{
		m_angle = UnityEngine.Random.Range(0f, 360f);
	}

	public void Update()
	{
		m_angle += Speed * 360f * Time.deltaTime;
		base.transform.rotation = Quaternion.Euler(0f, 0f - m_angle, 0f);
	}
}
public class WASD : MonoBehaviour
{
	public float Speed = 1f;

	public Vector3 m_velocity;

	public Vector3 Velocity => m_velocity;

	public void Update()
	{
		Vector3 zero = Vector3.zero;
		if (Input.GetKey(KeyCode.W))
		{
			zero.z += 1f;
		}
		if (Input.GetKey(KeyCode.A))
		{
			zero.x -= 1f;
		}
		if (Input.GetKey(KeyCode.S))
		{
			zero.z -= 1f;
		}
		if (Input.GetKey(KeyCode.D))
		{
			zero.x += 1f;
		}
		Vector3 vector = ((zero.sqrMagnitude > 0f) ? (zero.normalized * Speed * Time.deltaTime) : Vector3.zero);
		m_velocity = vector / Time.deltaTime;
		base.transform.position += vector;
	}
}
public class Pvr : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
	}

	public static bool IsMainKeyDown(int hand)
	{
		if (!Controller.UPvr_GetKeyDown(hand, Pvr_KeyCode.TRIGGER))
		{
			return Input.GetKeyDown(KeyCode.Mouse0);
		}
		return true;
	}

	public static bool IsMainKeyUp(int hand)
	{
		if (!Controller.UPvr_GetKeyUp(hand, Pvr_KeyCode.TRIGGER))
		{
			return Input.GetKeyUp(KeyCode.Mouse0);
		}
		return true;
	}

	public static bool IsMainKeyDown()
	{
		if (!Controller.UPvr_GetKeyDown(0, Pvr_KeyCode.TRIGGER) && !Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.TRIGGER))
		{
			return Input.GetKeyDown(KeyCode.Mouse0);
		}
		return true;
	}

	public static bool IsMainKeyUp()
	{
		if (!Controller.UPvr_GetKeyUp(0, Pvr_KeyCode.TRIGGER) && !Controller.UPvr_GetKeyUp(1, Pvr_KeyCode.TRIGGER))
		{
			return Input.GetKeyUp(KeyCode.Mouse0);
		}
		return true;
	}

	public static bool IsAppUp()
	{
		if (!Controller.UPvr_GetKeyUp(0, Pvr_KeyCode.APP) && !Controller.UPvr_GetKeyUp(1, Pvr_KeyCode.APP))
		{
			return Input.GetKeyUp(KeyCode.Escape);
		}
		return true;
	}

	public static bool GetMainKey(int hand)
	{
		if (!Controller.UPvr_GetKey(hand, Pvr_KeyCode.TRIGGER))
		{
			return Input.GetKey(KeyCode.Mouse0);
		}
		return true;
	}

	public static bool GetMainKey()
	{
		if (!Controller.UPvr_GetKey(Pvr_ControllerManager.controllerlink.mainHandID, Pvr_KeyCode.TRIGGER))
		{
			return Input.GetKey(KeyCode.Mouse0);
		}
		return true;
	}

	public static Ray GetXunlianRay()
	{
		return default(Ray);
	}

	public static Ray GetMainRay(LineRenderer a)
	{
		Vector3 position = a.GetPosition(0);
		Vector3 position2 = a.GetPosition(1);
		return new Ray(position, position2 - position);
	}
}
public class Lvyou : MonoBehaviour
{
	public class Aspot : Dbentry
	{
		public string Name { get; set; }

		public string Name2 { get; set; }

		public int Pid { get; set; }
	}

	public GameObject butemp;

	public Transform cnt;

	public static Aspot CurSport = new Aspot
	{
		Id = 2
	};

	private void Start()
	{
		this.Get("https://huaijiu.guavavr.com/qj/sp1", delegate(List<Aspot> fs)
		{
			foreach (Aspot c in fs)
			{
				Transform obj = UnityEngine.Object.Instantiate(butemp, cnt).transform;
				obj.GetComponentInChildren<Text>().text = c.Name;
				obj.gameObject.SetActive(value: true);
				obj.GetComponent<Button>().onClick.AddListener(delegate
				{
					CurSport = c;
					ScenesHelper.LoadScene(ScenesHelper.Travel__RoamScene);
				});
			}
		});
	}

	public void ToMenu()
	{
		ScenesHelper.LoadScene(ScenesHelper.WeiAiZhiCenterScene);
	}
}
public class Lvyou2 : MonoBehaviour
{
	public class Aspot : Dbentry
	{
		public string Name { get; set; }

		public string Name2 { get; set; }

		public int Pid { get; set; }
	}

	public GameObject butemp;

	public Transform cnt;

	private GameObject Menu;

	private int lastLoadId;

	private static Dictionary<string, string> SKYTEX = new Dictionary<string, string>
	{
		{ "_FrontTex", "f" },
		{ "_BackTex", "b" },
		{ "_UpTex", "u" },
		{ "_DownTex", "d" },
		{ "_LeftTex", "l" },
		{ "_RightTex", "r" }
	};

	private static Dictionary<string, string> SKYTEX2 = new Dictionary<string, string>
	{
		{ "_FrontTex", "f" },
		{ "_BackTex", "b" },
		{ "_UpTex", "u" },
		{ "_DownTex", "d" },
		{ "_LeftTex", "r" },
		{ "_RightTex", "l" }
	};

	private void Start()
	{
		butemp.SetActive(value: false);
		Menu = GameObject.Find("Canvas");
		this.Get("https://huaijiu.guavavr.com/qj/sp2?id=" + Lvyou.CurSport.Id, delegate(List<Aspot> fs)
		{
			foreach (Aspot c in fs)
			{
				Transform a = UnityEngine.Object.Instantiate(butemp, cnt).transform;
				$"https://crci-res.guavavr.com/qjt/{c.Id}_b.jpg".LoadWebTex(this, delegate(Texture2D ca)
				{
					a.GetComponent<Image>().sprite = ca.ToSprite();
				});
				a.GetComponentInChildren<Text>().text = c.Name;
				UnityEngine.Debug.Log(a.GetComponentInChildren<Button>());
				a.GetComponentInChildren<Button>().onClick.AddListener(delegate
				{
					UnityEngine.Debug.Log(333);
					UnityEngine.Debug.Log(c.Id + "," + lastLoadId);
					if (c.Id != lastLoadId)
					{
						Switch(c);
					}
				});
				a.gameObject.SetActive(value: true);
			}
			Switch(fs.FirstOrDefault());
		});
	}

	private void Update()
	{
		if (Pvr.IsAppUp())
		{
			Menu.SetActive(!Menu.activeSelf);
		}
	}

	public void Switch(Aspot c)
	{
		foreach (KeyValuePair<string, string> a in (c.Pid >= 4 && c.Pid <= 7) ? SKYTEX2 : SKYTEX)
		{
			$"https://crci-res.guavavr.com/qjt/{c.Id}_{a.Value}.jpg".LoadWebTex(this, delegate(Texture2D ca)
			{
				ca.wrapMode = TextureWrapMode.Clamp;
				RenderSettings.skybox.SetTexture(a.Key, ca);
			});
		}
		lastLoadId = c.Id;
	}

	public void ToMenu()
	{
		ScenesHelper.LoadScene(ScenesHelper.Travel_EntranceScene);
	}
}
public class Afile : Dbentry
{
	public string Data { get; set; }

	public int Uid { get; set; }

	public int Uid2 { get; set; }

	public string Type { get; set; }

	public string Tag { get; set; }

	public string uname { get; set; }

	public string upic { get; set; }

	public string usex { get; set; }
}
public class Dbentry
{
	public int Id { get; set; }

	public DateTime Createtime { get; set; }
}
public class Amsg : Dbentry
{
	public int Fid { get; set; }

	public int Uid { get; set; }

	public string Type { get; set; }

	public string Data { get; set; }

	public string uname { get; set; }

	public string upic { get; set; }
}
public class Ares
{
	public string msg { get; set; }

	public object data { get; set; }

	public bool suc { get; set; }
}
public class Atag
{
	public int Id { get; set; }

	public string Name { get; set; }

	public int Pid { get; set; }

	public string Pic { get; set; }
}
public class Auser : Dbentry
{
	public string Openid { get; set; }

	public string Name { get; set; }

	public string Phone { get; set; }

	public string Pic { get; set; }

	public string Sex { get; set; }
}
public class zta
{
	public List<Atag> a2 { get; set; }

	public Dictionary<string, string> r { get; set; }
}
public class AudioPlayerSwitchCtrl : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
	}
}
public class Dating : MonoBehaviour
{
	public LineRenderer line;

	public Text txt;

	public GameObject cvs;

	public Pvr_ControllerModuleInit right;

	private Animation ani;

	public ParticleSystem par;

	private AnimationState a1;

	private bool isLastMo;

	private HighlightEffect last;

	private float lastime;

	private Vector3 lastRpos = Vector3.zero;

	private void Start()
	{
		ani = GameObject.Find("风车把手").GetComponent<Animation>();
		par.Stop();
	}

	private void Update()
	{
		if (!isLastMo)
		{
			if (Physics.Raycast(Pvr.GetMainRay(line), out var hitInfo))
			{
				HighlightEffect component = hitInfo.collider.gameObject.GetComponent<HighlightEffect>();
				if (last != null && last != component)
				{
					last.highlighted = false;
				}
				if (component != null)
				{
					component.highlighted = true;
					last = component;
				}
			}
			else
			{
				if (last != null)
				{
					last.highlighted = false;
				}
				last = null;
			}
			if (Pvr.IsMainKeyDown(1) && last != null)
			{
				cvs.SetActive(value: true);
				txt.text = last.gameObject.name;
				if (txt.text == "风车把手")
				{
					txt.text += "\n\n扣住扳机，手柄划圈可以启动风车";
					isLastMo = true;
					ani.Play("modaozi");
					ani["modaozi"].speed = 0f;
					par.Play();
				}
				lastime = Time.time;
			}
		}
		else
		{
			if (lastRpos != Vector3.zero)
			{
				float num = Vector3.Distance(right.transform.position, lastRpos);
				ani["modaozi"].speed = num * 200f;
			}
			lastRpos = right.transform.position;
		}
		if (Pvr.IsMainKeyUp(1))
		{
			ani.Stop();
			par.Stop();
			isLastMo = false;
		}
		if (Time.time - lastime > 3.5f)
		{
			cvs.SetActive(value: false);
		}
	}
}
public class guava_smallGuyCtrl : MonoBehaviour
{
	public Animator m_animCtrl;

	public AudioSource m_audioSource;

	public GameObject m_objGuideTextParent;

	public Text m_txtGuideText;

	private float m_fTalkTime;

	private void Start()
	{
		Vector3 position = base.transform.position;
		position.y = 1.6f;
		base.transform.position = position;
		m_objGuideTextParent.SetActive(value: false);
	}

	private void Update()
	{
		if (m_fTalkTime > 0f)
		{
			m_fTalkTime -= Time.deltaTime;
			if (m_fTalkTime < 0f)
			{
				OnFinishTalk();
			}
		}
	}

	public void J_ResetHeadUIRotValueToCam(float fAngle)
	{
		Vector3 eulerAngles = base.transform.eulerAngles;
		eulerAngles.y = fAngle;
		base.transform.eulerAngles = eulerAngles;
	}

	public void PlayGuideVoice(AudioClip audioClip)
	{
		base.gameObject.SetActive(value: true);
		m_audioSource.clip = audioClip;
		m_audioSource.Play();
		m_fTalkTime = audioClip.length;
		if (m_fTalkTime > 0f)
		{
			m_animCtrl.SetBool("talking", value: true);
			TrainGuideManager.Inst.J_SetAllMedia_VolumeQuite(isQuite: true);
		}
	}

	private void OnFinishTalk()
	{
		TrainGuideManager.Inst.J_SetAllMedia_VolumeQuite(isQuite: false);
		m_animCtrl.SetBool("talking", value: false);
	}

	public void ShowGuideText(string words)
	{
		m_txtGuideText.text = words;
		m_objGuideTextParent.SetActive(value: true);
	}

	public void PlayFlyAnim()
	{
		m_animCtrl.SetBool("FlyAround", value: true);
	}

	public void StopFlyAnim()
	{
		m_animCtrl.SetBool("FlyAround", value: false);
	}

	public void J_HideSmallGuy()
	{
		base.gameObject.SetActive(value: false);
		TrainGuideManager.Inst.J_SetAllMedia_VolumeQuite(isQuite: false);
	}

	private void OnDestroy()
	{
		if ((bool)TrainGuideManager.Inst)
		{
			TrainGuideManager.Inst.J_SetAllMedia_VolumeQuite(isQuite: false);
		}
	}
}
public class HandRayTrigger : MonoBehaviour, IPointerEnterHandler, IEventSystemHandler, IPointerExitHandler, IPointerClickHandler
{
	public UnityEvent eventOnPointerClick;

	public UnityEvent eventOnPointerEnter;

	public UnityEvent eventOnPointerExit;

	private void Start()
	{
		if (base.gameObject.name == "CubeTrigger")
		{
			HandRayTrigger_VirtualButtonAction[] components = GetComponents<HandRayTrigger_VirtualButtonAction>();
			if (components != null && components.Length >= 2)
			{
				components[0].pvr_KeyCode = Pvr_KeyCode.A;
				components[1].pvr_KeyCode = Pvr_KeyCode.B;
			}
			HandRayTrigger component = GameObject.Find("相框-生活风貌").transform.Find("CubeTrigger").GetComponent<HandRayTrigger>();
			if (!component.enabled)
			{
				component.enabled = true;
			}
		}
	}

	public void OnPointerClick(PointerEventData eventData)
	{
		if (Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.TRIGGER) || Input.GetKeyDown(KeyCode.Mouse0))
		{
			eventOnPointerClick.Invoke();
		}
	}

	public void OnPointerEnter(PointerEventData eventData)
	{
		eventOnPointerEnter.Invoke();
	}

	public void OnPointerExit(PointerEventData eventData)
	{
		eventOnPointerExit.Invoke();
	}

	public void OnPointerClick()
	{
		eventOnPointerClick.Invoke();
	}

	public void OnPointerEnter()
	{
		eventOnPointerEnter.Invoke();
	}

	public void OnPointerExit()
	{
		eventOnPointerExit.Invoke();
	}
}
public class HandRayTrigger_VirtualButtonAction : MonoBehaviour, IPointerEnterHandler, IEventSystemHandler, IPointerExitHandler
{
	public Pvr_KeyCode pvr_KeyCode = Pvr_KeyCode.B;

	public UnityEvent eventOnVirtualButtonClick;

	private bool isPointerIn;

	public void OnPointerEnter(PointerEventData eventData)
	{
		isPointerIn = true;
	}

	public void OnPointerExit(PointerEventData eventData)
	{
		isPointerIn = false;
	}

	public void OnPointerEnter()
	{
		isPointerIn = true;
	}

	public void OnPointerExit()
	{
		isPointerIn = false;
	}

	private void Start()
	{
	}

	private void Update()
	{
		if (base.isActiveAndEnabled && isPointerIn && (Controller.UPvr_GetKeyDown(1, pvr_KeyCode) || Input.GetKeyDown(KeyCode.M)))
		{
			OnVirtualButtonClick();
		}
	}

	public void OnVirtualButtonClick()
	{
		eventOnVirtualButtonClick.Invoke();
	}
}
public class HeadRotAngleTargetCheckCtrl : MonoBehaviour
{
	public Transform transCamHead;

	public float fLookAngle = 30f;

	private bool isInChecking;

	public UnityEvent m_eventOnLookAtCallback;

	private void OnEnable()
	{
		J_StartCheckCamIsLookAtThis();
	}

	private void Update()
	{
		if (isInChecking)
		{
			Vector3 forward = transCamHead.forward;
			if (Vector3.Angle(base.transform.position - transCamHead.position, forward) < fLookAngle)
			{
				isInChecking = false;
				m_eventOnLookAtCallback.Invoke();
			}
		}
	}

	private void J_StartCheckCamIsLookAtThis()
	{
		isInChecking = true;
	}
}
public class HeadRotCheckCtrl : MonoBehaviour
{
	public Transform m_headCam;

	public float m_fTargetRotCheckValue = 120f;

	public float m_fMinCalculateValue = 1f;

	private float fRotValue;

	private Quaternion preHeadRot;

	private bool bStartCheck;

	public UnityEvent event_OnFinishRotCheck;

	public void J_StartCheckRot()
	{
		bStartCheck = true;
		preHeadRot = m_headCam.rotation;
	}

	private void _FinishRotCheck()
	{
		bStartCheck = false;
		fRotValue = 0f;
		event_OnFinishRotCheck.Invoke();
	}

	private void Update()
	{
		if (!bStartCheck || !(m_headCam != null) || !(preHeadRot != m_headCam.rotation))
		{
			return;
		}
		float num = Quaternion.Angle(preHeadRot, m_headCam.rotation);
		if (num > m_fMinCalculateValue)
		{
			fRotValue += num;
			if (fRotValue > m_fTargetRotCheckValue)
			{
				_FinishRotCheck();
			}
			preHeadRot = m_headCam.rotation;
		}
	}
}
public class highlightOutlineFlash : MonoBehaviour
{
	public HighlightEffect m_highlightEffect;

	public float floatSpeed = 1f;

	public bool isOnGlowing;

	private void Awake()
	{
		if (m_highlightEffect == null)
		{
			m_highlightEffect = GetComponent<HighlightEffect>();
		}
		if (m_highlightEffect != null)
		{
			m_highlightEffect.highlighted = false;
		}
	}

	private void Update()
	{
		if (isOnGlowing && m_highlightEffect != null)
		{
			m_highlightEffect.outline = Mathf.PingPong(Time.time * floatSpeed, 1f);
		}
	}

	public void StartOutlineGlow()
	{
		isOnGlowing = true;
		if (m_highlightEffect != null)
		{
			m_highlightEffect.highlighted = true;
		}
	}

	public void PauseOutlineGlow()
	{
		isOnGlowing = false;
		if (m_highlightEffect != null)
		{
			m_highlightEffect.highlighted = true;
			m_highlightEffect.outline = 1f;
		}
	}

	public void StopGlow()
	{
		isOnGlowing = false;
		if (m_highlightEffect != null)
		{
			m_highlightEffect.highlighted = false;
		}
	}
}
public class J_VoiceChatAgoraManager : MonoBehaviour
{
	private static string AppID = "a281da04b74c49448442adc5213f4319";

	private IRtcEngine mRtcEngine;

	private ArrayList permissionList = new ArrayList();

	private void Awake()
	{
		permissionList.Add("android.permission.RECORD_AUDIO");
		foreach (string permission in permissionList)
		{
			if (!Permission.HasUserAuthorizedPermission(permission))
			{
				Permission.RequestUserPermission(permission);
			}
		}
	}

	private void Start()
	{
		JoinChatChanel();
	}

	public void JoinChatChanel()
	{
		UnityEngine.Debug.Log("initializeEngine");
		mRtcEngine = IRtcEngine.GetEngine(AppID);
		mRtcEngine.SetDefaultMuteAllRemoteVideoStreams(mute: true);
		mRtcEngine.OnJoinChannelSuccess = onJoinChannelSuccess;
		mRtcEngine.OnUserJoined = onUserJoined;
		mRtcEngine.OnUserOffline = onUserOffline;
		mRtcEngine.EnableAudio();
		mRtcEngine.DisableVideo();
		mRtcEngine.JoinChannel(Application.identifier, null);
	}

	private void onJoinChannelSuccess(string channelName, uint uid, int elapsed)
	{
		UnityEngine.Debug.Log("JoinChannelSuccessHandler: uid = " + uid);
	}

	private void onUserJoined(uint uid, int elapsed)
	{
		UnityEngine.Debug.Log("onUserJoined: uid = " + uid + " elapsed = " + elapsed);
	}

	private void onUserOffline(uint uid, USER_OFFLINE_REASON reason)
	{
		UnityEngine.Debug.Log("onUserOffline: uid = " + uid + " reason = " + reason);
	}

	private void OnDestroy()
	{
		if (mRtcEngine != null)
		{
			IRtcEngine.Destroy();
			mRtcEngine = null;
		}
	}
}
public class Keting : MonoBehaviour
{
	public static Keting Ins;

	public GameObject ButonTemp;

	public GameObject ItemTemp;

	public GameObject ItemTemp2;

	public GameObject ZtTemp;

	public GameObject qsTemp;

	public List<Transform> Cnts;

	public List<GameObject> right;

	public GameObject listPageObj;

	public GameObject homePageObj;

	public GameObject infoPageObj;

	public Transform Cnt3;

	[Header("留言")]
	public AudioSource MsgAudio;

	public Transform Msgcnt;

	public GameObject MsgTemp;

	public Transform Luyincnt;

	public GameObject LuyinTemp;

	public GameObject Temps;

	public GameObject PlayBut;

	public GameObject PauseBut;

	[Header("播放器")]
	public Text Lentxt;

	public Text Postxt;

	private List<Afile> Fsdata = new List<Afile>();

	private zta zts = new zta();

	private List<Image> _butImgs;

	private List<Text> _butText;

	public Text Listitle;

	public RawImage img;

	public VideoPlayer video;

	public AudioSource audio;

	private Vector2 psize = Vector2.zero;

	public static Afile curFile = new Afile
	{
		Id = 16
	};

	public GameObject PlayPanel;

	public Slider jindu;

	private int curDelMsgid;

	[Header("删除录音")]
	public GameObject delPanel;

	private Button lastPlayBut;

	private Button lastPlayBut2;

	public GameObject MsgTextItem;

	public static int Uid => 1;

	private void Start()
	{
		Ins = this;
		GameObject.Find("msg")?.SetActive(value: false);
		GameObject.Find("list")?.SetActive(value: false);
		GameObject.Find("LiuYan")?.SetActive(value: false);
		GameObject.Find("lyfile")?.SetActive(value: false);
		GameObject.Find("info")?.SetActive(value: false);
		Temps.SetActive(value: false);
		initab();
		Tab(0);
		MsgAudio.playOnAwake = false;
		MsgAudio.loop = false;
	}

	public void LoadLastPage()
	{
		StartCoroutine(("https://huaijiu.guavavr.com/wx/vrfile?uid=" + Uid).HttpGet2(delegate(List<Afile> fs)
		{
			if (fs.Count >= 0)
			{
				Cnts[0].ClearChild();
				Fsdata = fs;
				foreach (Afile item in fs.OrderByDescending((Afile ca) => ca.Id))
				{
					Transform a = UnityEngine.Object.Instantiate(ItemTemp, Cnts[0]).transform;
					a.Find("img/" + item.usex.Null("男"))?.gameObject?.SetActive(value: true);
					if (!string.IsNullOrEmpty(item.upic))
					{
						item.upic.LoadWebTex(this, delegate(Texture2D ca)
						{
							a.Find("img").GetComponent<CircleImage>().sprite = ca.ToSprite();
						});
					}
					a.Find("Text").GetComponent<Text>().text = item.uname + "上传" + item.Tag + item.Type;
					a.Find("Text/date").GetComponent<Text>().text = item.Createtime.ToString("yyyy-MM-dd HH:mm");
					Button componentInChildren = a.GetComponentInChildren<Button>();
					int id = item.Id;
					componentInChildren.onClick.AddListener(delegate
					{
						InfoPage(id);
					});
					a.gameObject.SetActive(value: true);
				}
				ShowRight(0);
			}
		}));
	}

	public void LoadZtPage()
	{
		if (Cnts[1].childCount > 0)
		{
			ShowRight(1);
			return;
		}
		StartCoroutine("https://huaijiu.guavavr.com/wx/zts".HttpGet2(delegate(zta r1)
		{
			if (r1 != null)
			{
				zts = r1;
				foreach (Atag f in r1.a2)
				{
					GameObject a = UnityEngine.Object.Instantiate(ZtTemp, Cnts[1]);
					if (!string.IsNullOrEmpty(f.Pic))
					{
						f.Pic.LoadWebTex(this, delegate(Texture2D ca)
						{
							a.GetComponent<Image>().sprite = ca.ToSprite();
						});
					}
					a.GetComponentInChildren<Text>().text = f.Name;
					int num = Fsdata.Count((Afile ca) => zts.r.ContainsKey(f.Name) && zts.r[f.Name].Contains(ca.Tag));
					a.GetComponentsInChildren<Text>()[1].text = ((num > 0) ? "+" : "") + ((num > 99) ? "99" : num.ToString());
					a.GetComponentsInChildren<Image>()[1].gameObject.SetActive(num > 0);
					Button component = a.GetComponent<Button>();
					_ = f.Name;
					component.onClick.AddListener(delegate
					{
						ListPage(f.Name, 0);
					});
					a.SetActive(value: true);
				}
				ShowRight(1);
			}
		}));
	}

	public void LoadPeoplePage()
	{
		if (Cnts[2].childCount > 0)
		{
			ShowRight(2);
			return;
		}
		StartCoroutine(("https://huaijiu.guavavr.com/wx/yhs?uid=" + Uid).HttpGet2(delegate(List<Auser> ms)
		{
			if (ms != null)
			{
				Cnts[2].ClearChild();
				foreach (Auser f in ms)
				{
					Transform a = UnityEngine.Object.Instantiate(qsTemp, Cnts[2]).transform;
					a.Find(f.Sex.Null("男")).gameObject.SetActive(value: true);
					a.GetComponentInChildren<Text>().text = f.Name;
					if (!string.IsNullOrEmpty(f.Pic))
					{
						f.Pic.LoadWebTex(this, delegate(Texture2D ca)
						{
							a.GetComponentInChildren<CircleImage>().sprite = ca.ToSprite();
						});
					}
					Button componentInChildren = a.GetComponentInChildren<Button>();
					_ = f.Name;
					componentInChildren.onClick.AddListener(delegate
					{
						ListPage(f.Name, 1);
					});
					a.gameObject.SetActive(value: true);
				}
				ShowRight(2);
			}
		}));
	}

	private void initab()
	{
		GameObject gameObject = GameObject.Find("lefbut");
		_butImgs = gameObject.GetComponentsInChildren<Image>(includeInactive: false).ToList();
		_butText = gameObject.GetComponentsInChildren<Text>(includeInactive: true).ToList();
	}

	public void Tab(int id)
	{
		_butText.ForEach(delegate(Text ca)
		{
			ca.color = Color.white;
		});
		for (int i = 0; i < _butImgs.Count; i++)
		{
			switch (i % 3)
			{
			case 0:
				_butImgs[i].enabled = i / 3 == id;
				break;
			case 1:
				_butImgs[i].enabled = (i - 1) / 3 == id;
				break;
			default:
				_butImgs[i].enabled = (i - 2) / 3 != id;
				break;
			}
		}
		_butText[id].color = new Color(0.23137255f, 0.5372549f, 49f / 51f);
		switch (id)
		{
		case 0:
			LoadLastPage();
			break;
		case 1:
			LoadZtPage();
			break;
		case 2:
			LoadPeoplePage();
			break;
		}
		listPageObj.SetActive(value: false);
		homePageObj.SetActive(value: true);
	}

	private void ListPage(string name, int type)
	{
		Listitle.text = name.ToArray().Join(' ');
		homePageObj.SetActive(value: false);
		Transform cnt = Cnt3;
		cnt.ClearChild();
		List<Afile> list = new List<Afile>();
		list = ((type != 1) ? Fsdata.Where((Afile ca) => zts.r[name].Contains(ca.Tag)).ToList() : Fsdata.Where((Afile ca) => ca.uname == name).ToList());
		foreach (Afile item in list.OrderByDescending((Afile ca) => ca.Id))
		{
			Transform obj = UnityEngine.Object.Instantiate(ItemTemp2, cnt).transform;
			obj.Find("img/" + item.Type).gameObject.SetActive(value: true);
			obj.Find("Text").GetComponent<Text>().text = item.Tag + item.Type;
			obj.Find("Text/date").GetComponent<Text>().text = "上传人:" + item.uname + "        " + item.Createtime.ToShortDateString();
			Button componentInChildren = obj.GetComponentInChildren<Button>();
			int id = item.Id;
			componentInChildren.onClick.AddListener(delegate
			{
				InfoPage(id);
			});
			obj.gameObject.SetActive(value: true);
		}
		listPageObj.SetActive(value: true);
	}

	private void InfoPage(int id)
	{
		Afile afile = (curFile = Fsdata.FirstOrDefault((Afile ca) => ca.Id == id));
		infoPageObj.transform.Find(afile.Type).gameObject.SetActive(value: true);
		switch (afile.Type)
		{
		case "图片":
			afile.Data.LoadWebTex(this, delegate(Texture2D tex)
			{
				if (psize == Vector2.zero)
				{
					psize = infoPageObj.transform.Find("图片").GetComponent<RectTransform>().sizeDelta;
				}
				float num = psize.x / psize.y;
				float num2 = (float)tex.width * 1f / (float)tex.height * 1f;
				Vector2 sizeDelta = img.rectTransform.sizeDelta;
				UnityEngine.Debug.Log(num2 + "," + num);
				if (num2 > num)
				{
					img.rectTransform.sizeDelta = new Vector2(sizeDelta.x, sizeDelta.x / num2);
				}
				else
				{
					img.rectTransform.sizeDelta = new Vector2(sizeDelta.y * num2, sizeDelta.y);
				}
				img.texture = tex;
			});
			break;
		case "视频":
			video.url = afile.Data;
			video.Play();
			break;
		case "音乐":
			afile.Data.LoadWebAudio(this, delegate(AudioClip mp3)
			{
				audio.clip = mp3;
				audio.Play();
				Lentxt.text = mp3.length.ToMinSec();
			});
			break;
		}
		PlayPanel.SetActive(afile.Type != "图片");
		LoadMsg();
		LoadMsg2();
		infoPageObj.SetActive(value: true);
	}

	public void Pause()
	{
		if (curFile != null)
		{
			if (curFile.Type == "视频")
			{
				video.Pause();
			}
			if (curFile.Type == "音乐")
			{
				audio.Pause();
			}
			PlayBut.SetActive(value: true);
			PauseBut.SetActive(value: false);
		}
	}

	public void Replay()
	{
		if (curFile == null)
		{
			return;
		}
		if (curFile.Type == "视频")
		{
			if (video.time >= video.length)
			{
				video.time = 0.0;
			}
			video.Play();
		}
		if (curFile.Type == "音乐")
		{
			if (audio.time == 0f)
			{
				audio.time = 0f;
			}
			audio.Play();
		}
		PauseBut.SetActive(value: true);
		PlayBut.SetActive(value: false);
	}

	private void Update()
	{
		if (curFile == null)
		{
			return;
		}
		if (curFile.Type == "视频")
		{
			if (video.isPlaying && !SliderDrag.isDraging)
			{
				Lentxt.text = video.length.ToMinSec();
				Postxt.text = video.time.ToMinSec();
				jindu.value = (float)(video.time / video.length);
			}
			if (!video.isPlaying && PauseBut.activeSelf)
			{
				PlayBut.SetActive(value: true);
				PauseBut.SetActive(value: false);
			}
			if (video.isPlaying && PlayBut.activeSelf)
			{
				PlayBut.SetActive(value: false);
				PauseBut.SetActive(value: true);
			}
		}
		else if (curFile.Type == "音乐")
		{
			if (audio.isPlaying && !SliderDrag.isDraging)
			{
				Postxt.text = audio.time.ToMinSec();
				jindu.value = audio.time / audio.clip.length;
			}
			if (!audio.isPlaying && PauseBut.activeSelf)
			{
				PlayBut.SetActive(value: true);
				PauseBut.SetActive(value: false);
			}
			if (audio.isPlaying && PlayBut.activeSelf)
			{
				PlayBut.SetActive(value: false);
				PauseBut.SetActive(value: true);
			}
		}
	}

	public void Pos(float a)
	{
		if (curFile.Type == "视频")
		{
			video.time = (double)a * video.length;
		}
		else if (curFile.Type == "音乐")
		{
			audio.time = a * audio.clip.length;
		}
	}

	public void LoadMsg()
	{
		Afile afile = curFile;
		Msgcnt.ClearChild();
		StartCoroutine(("https://huaijiu.guavavr.com/wx/vrmsg?fid=" + afile.Id).HttpGet2(delegate(List<Amsg> ms)
		{
			if (ms == null)
			{
				return;
			}
			foreach (Amsg f in ms)
			{
				Transform a = UnityEngine.Object.Instantiate(MsgTemp, Msgcnt).transform;
				if (!string.IsNullOrEmpty(f.upic))
				{
					f.upic.LoadWebTex(this, delegate(Texture2D ca)
					{
						a.GetComponentInChildren<CircleImage>().sprite = ca.ToSprite();
					});
				}
				a.GetComponentInChildren<Text>().text = f.uname;
				if (f.Type == "文本")
				{
					a.GetComponentsInChildren<Text>()[1].text = f.Data;
					a.GetComponentsInChildren<Button>().ToList().ForEach(delegate(Button ca)
					{
						ca.gameObject.SetActive(value: false);
					});
				}
				else
				{
					Button but = a.GetComponentInChildren<Button>();
					Button but2 = a.GetComponentsInChildren<Button>()[1];
					_ = f.Id;
					but.onClick.AddListener(delegate
					{
						playMsg(but, but2, f);
					});
					but2.onClick.AddListener(delegate
					{
						pauseMsg(but, but2);
					});
					but.gameObject.SetActive(value: true);
					but2.gameObject.SetActive(value: false);
				}
				a.gameObject.SetActive(value: true);
			}
		}));
	}

	public void Quit()
	{
		SceneManager.LoadScene("2_MainStart");
	}

	public void LoadMsg2()
	{
		Afile afile = curFile;
		Luyincnt.ClearChild();
		StartCoroutine(("https://huaijiu.guavavr.com/wx/vrmsg2?fid=" + afile.Id).HttpGet2(delegate(List<Amsg> ms)
		{
			if (ms == null)
			{
				return;
			}
			foreach (Amsg f in ms)
			{
				Transform transform = UnityEngine.Object.Instantiate(LuyinTemp, Luyincnt).transform;
				transform.GetComponentInChildren<Text>().text = "新录音文件" + f.Id;
				transform.GetComponentInChildren<Text>().GetComponent<RectTransform>().sizeDelta = new Vector2(340f, 60f);
				Button but = transform.GetComponentInChildren<Button>();
				Button but2 = transform.GetComponentsInChildren<Button>()[1];
				_ = f.Id;
				but.onClick.AddListener(delegate
				{
					playMsg(but, but2, f);
				});
				but2.onClick.AddListener(delegate
				{
					pauseMsg(but, but2);
				});
				transform.GetComponentsInChildren<Button>()[2].onClick.AddListener(delegate
				{
					curDelMsgid = f.Id;
					delPanel.SetActive(value: true);
				});
				but.gameObject.SetActive(value: true);
				but2.gameObject.SetActive(value: false);
				transform.gameObject.SetActive(value: true);
			}
		}));
	}

	public void delMsg()
	{
		this.Get<string>("https://huaijiu.guavavr.com/wx/delmsg?id=" + curDelMsgid, delegate
		{
			delPanel.SetActive(value: false);
			LoadMsg2();
		});
	}

	private void playMsg(Button but, Button but2, Amsg f)
	{
		if (lastPlayBut != null)
		{
			lastPlayBut.gameObject.SetActive(value: true);
		}
		if (lastPlayBut2 != null)
		{
			lastPlayBut2.gameObject.SetActive(value: false);
		}
		but.gameObject.SetActive(value: false);
		but2.gameObject.SetActive(value: true);
		lastPlayBut = but;
		lastPlayBut2 = but2;
		audio.volume = 0.1f;
		f.Data.LoadWebAudio(this, delegate(AudioClip mp3)
		{
			MsgAudio.clip = mp3;
			MsgAudio.Play();
		});
	}

	private void pauseMsg(Button but, Button but2)
	{
		MsgAudio.Pause();
		but.gameObject.SetActive(value: true);
		but2.gameObject.SetActive(value: false);
		lastPlayBut = null;
		lastPlayBut2 = null;
		audio.volume = 1f;
	}

	private void PlayMsg(Amsg a)
	{
		if (a.Type == "文本")
		{
			MsgTextItem.GetComponentInChildren<Text>(includeInactive: true).text = a.Data;
			MsgTextItem.SetActive(value: true);
			return;
		}
		audio.volume = 0.01f;
		a.Data.LoadWebAudio(this, delegate(AudioClip mp3)
		{
			MsgAudio.clip = mp3;
			MsgAudio.Play();
		});
	}

	private void ShowRight(int i)
	{
		right.ForEach(delegate(GameObject ca)
		{
			ca.SetActive(value: false);
		});
		right[i].SetActive(value: true);
	}

	public void OnHidePlayMsg()
	{
		MsgAudio.Stop();
		audio.volume = 1f;
		MsgTextItem.SetActive(value: false);
	}

	public void OnInfoPageHide()
	{
		OnHidePlayMsg();
		audio.Stop();
		MsgAudio.Stop();
		video.Stop();
		infoPageObj.transform.Find("图片").gameObject.SetActive(value: false);
		infoPageObj.transform.Find("视频").gameObject.SetActive(value: false);
		infoPageObj.transform.Find("音乐").gameObject.SetActive(value: false);
	}
}
public class J_VRPlayer_NetSingle : NetworkBehaviour
{
	public Transform m_transHead;

	public Transform m_transRightHand;

	public GameObject m_ManModel;

	public Transform m_modleHead;

	public Transform m_modleHand;

	private void Start()
	{
		if (base.isLocalPlayer)
		{
			m_ManModel.SetActive(value: false);
		}
	}

	public override void OnStartLocalPlayer()
	{
		base.OnStartLocalPlayer();
		TrainGuide_VRPlayerCtrl.Inst.transform.position = base.transform.position;
		TrainGuide_VRPlayerCtrl.Inst.transform.eulerAngles = base.transform.eulerAngles;
	}

	private void FixedUpdate()
	{
		if (!base.isLocalPlayer)
		{
			m_modleHead.eulerAngles = m_transHead.transform.eulerAngles;
			m_modleHand.LookAt(m_transRightHand.position);
		}
		else
		{
			if (!TrainGuide_VRPlayerCtrl.Inst)
			{
				return;
			}
			base.transform.position = TrainGuide_VRPlayerCtrl.Inst.transform.position;
			m_transHead.transform.eulerAngles = TrainGuide_VRPlayerCtrl.Inst.m_transHead.eulerAngles;
			m_transRightHand.transform.position = TrainGuide_VRPlayerCtrl.Inst.m_transRightHand.position;
			Vector3 forward = base.transform.forward;
			forward.y = 0f;
			Vector3 forward2 = TrainGuide_VRPlayerCtrl.Inst.m_transHead.transform.forward;
			forward2.y = 0f;
			if (Vector3.Angle(forward, forward2) > 60f)
			{
				float num = Vector3.Angle(forward, forward2) - 60f;
				if (Vector3.Cross(forward, forward2).y > 0f)
				{
					base.transform.Rotate(Vector3.up, num);
				}
				else
				{
					base.transform.Rotate(Vector3.up, 0f - num);
				}
			}
		}
	}

	private void MirrorProcessed()
	{
	}
}
public class PrivateAlbumCtrl : MonoBehaviour
{
	public class cPrivateAlbum
	{
		public class cdata
		{
			public int id;

			public string file_type;

			public string file_url;
		}

		public int code;

		public string msg;

		public List<cdata> data;
	}

	public class WebRequestCert : CertificateHandler
	{
		protected override bool ValidateCertificate(byte[] certificateData)
		{
			return true;
		}
	}

	public static PrivateAlbumCtrl Inst;

	private string m_FileSourceFolder_Textures;

	private cPrivateAlbum m_albumData;

	public int m_iCurPageIndex;

	private int m_iMaxPageCount;

	public GameObject m_objPicOnDeskT;

	[Header("UI")]
	public Transform transUIScaleRoot;

	public Text errorTip;

	public Text m_txtAlbumPages;

	public RawImage m_rawImage;

	public GameObject m_objLoading;

	[Header("Content")]
	public VideoPlayer m_videoPlayer;

	public AudioSource m_audioSource;

	public GameObject[] listTriggers;

	private bool bCanInteract = true;

	public highlightOutlineFlash m_highlightEffectWall;

	private void Awake()
	{
		Inst = this;
	}

	private void Start()
	{
		m_FileSourceFolder_Textures = Application.persistentDataPath + "/TempFiles/PrivateAlbum/Textures/";
		if (!Directory.Exists(m_FileSourceFolder_Textures))
		{
			Directory.CreateDirectory(m_FileSourceFolder_Textures);
		}
		m_videoPlayer.SetTargetAudioSource(0, m_audioSource);
		m_videoPlayer.prepareCompleted += M_videoPlayer_prepareCompleted;
		m_txtAlbumPages.gameObject.SetActive(value: false);
		m_rawImage.color = Color.black;
		transUIScaleRoot.gameObject.SetActive(value: false);
		GameObject[] array = listTriggers;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetActive(value: false);
		}
	}

	public void J_EnableTriggers()
	{
		GameObject[] array = listTriggers;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetActive(value: true);
		}
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.S))
		{
			J_ShowNextContent();
		}
		if (Input.GetKeyDown(KeyCode.A))
		{
			J_ShowPreContent();
		}
	}

	public void J_TriggerAction()
	{
		if (bCanInteract)
		{
			bCanInteract = false;
			J_FinishAutoGlow();
			TrainGuideManager.Inst.J_PauseAllOtherMediaPlayers();
			m_objPicOnDeskT.SetActive(value: false);
			transUIScaleRoot.localScale = Vector3.zero;
			transUIScaleRoot.gameObject.SetActive(value: true);
			transUIScaleRoot.DOScale(1f, 1f).OnComplete(delegate
			{
				GetAPIdata();
			});
		}
	}

	public void J_CloseAlbum()
	{
		StopAllCoroutines();
		m_objPicOnDeskT.SetActive(value: true);
		transUIScaleRoot.gameObject.SetActive(value: false);
		bCanInteract = true;
	}

	public void J_StartGlowHighlight()
	{
		m_highlightEffectWall.StartOutlineGlow();
	}

	public void J_FinishAutoGlow()
	{
		m_highlightEffectWall.StopGlow();
	}

	private void GetAPIdata()
	{
		if ((bool)errorTip)
		{
			errorTip.gameObject.SetActive(value: false);
			errorTip.text = null;
		}
		string url = UrlUtils.baseUrl_es + "api/huaijiu";
		UnityWebRequestHelper.Instance.Get(url, delegate(RequestStatus status, string result)
		{
			cPrivateAlbum cPrivateAlbum = J_LitJson.JsonMapper.ToObject<cPrivateAlbum>(result);
			if (status == RequestStatus.success)
			{
				if ((bool)errorTip)
				{
					errorTip.gameObject.SetActive(value: false);
					errorTip.text = null;
				}
				m_albumData = cPrivateAlbum;
				Init();
			}
			else
			{
				errorTip.gameObject.SetActive(value: true);
				if (cPrivateAlbum == null)
				{
					errorTip.text = string.Format(result);
				}
				else
				{
					errorTip.text = $"errorcode:{cPrivateAlbum.code} msg:{cPrivateAlbum.msg}";
				}
			}
		}, isToken: true);
	}

	private void Init()
	{
		m_txtAlbumPages.text = m_iCurPageIndex + 1 + "/" + m_albumData.data.Count;
		m_txtAlbumPages.gameObject.SetActive(value: true);
		m_objLoading.SetActive(value: false);
		ShowAlbumContent(0);
	}

	public void J_ShowNextContent()
	{
		if (++m_iCurPageIndex > m_albumData.data.Count - 1)
		{
			m_iCurPageIndex = 0;
		}
		ShowAlbumContent(m_iCurPageIndex);
	}

	public void J_ShowPreContent()
	{
		if (--m_iCurPageIndex < 0)
		{
			m_iCurPageIndex = m_albumData.data.Count - 1;
		}
		ShowAlbumContent(m_iCurPageIndex);
	}

	private void ShowAlbumContent(int iindex)
	{
		m_iCurPageIndex = iindex;
		m_txtAlbumPages.text = m_iCurPageIndex + 1 + "/" + m_albumData.data.Count;
		m_objLoading.SetActive(value: true);
		cPrivateAlbum.cdata cdata = m_albumData.data[m_albumData.data.Count - iindex - 1];
		if (cdata.file_type == "image")
		{
			m_videoPlayer.Stop();
			TryGetTexture(cdata.file_url, delegate(object result)
			{
				m_rawImage.color = Color.white;
				m_objLoading.SetActive(value: false);
				if (m_rawImage.texture != null)
				{
					UnityEngine.Object.Destroy(m_rawImage.texture);
					m_rawImage.texture = null;
				}
				m_rawImage.texture = (Texture)result;
				float num = (float)m_rawImage.texture.width * 1f / (float)m_rawImage.texture.height;
				UnityEngine.Debug.Log(num);
				m_rawImage.GetComponent<AspectRatioFitter>().aspectRatio = num;
			});
		}
		else if (cdata.file_type == "video")
		{
			m_rawImage.color = Color.white;
			m_videoPlayer.url = cdata.file_url;
			m_videoPlayer.Play();
		}
	}

	private void M_videoPlayer_prepareCompleted(VideoPlayer source)
	{
		UnityEngine.Debug.Log(11);
		m_objLoading.SetActive(value: false);
		m_videoPlayer.aspectRatio = VideoAspectRatio.FitVertically;
		m_rawImage.texture = m_videoPlayer.texture;
		float num = (float)m_rawImage.texture.width * 1f / (float)m_rawImage.texture.height;
		UnityEngine.Debug.Log(num);
		m_rawImage.GetComponent<AspectRatioFitter>().aspectRatio = num;
	}

	public void TryGetTexture(string fileurl, Action<object> Callback)
	{
		int hashCode = fileurl.GetHashCode();
		string text = m_FileSourceFolder_Textures + hashCode;
		if (File.Exists(text))
		{
			if (Callback != null)
			{
				StartCoroutine(yieldLoadTexture_Local(hashCode, "file://" + text, Callback));
			}
		}
		else
		{
			StartCoroutine(yieldLoadTexture_WebUrl(hashCode, fileurl, text, Callback));
		}
	}

	private IEnumerator yieldLoadTexture_Local(int hashcode, string path, Action<object> action)
	{
		using UnityWebRequest webRequest = UnityWebRequest.Get(path);
		using DownloadHandlerTexture texDownloader = new DownloadHandlerTexture(readable: true);
		webRequest.downloadHandler = texDownloader;
		yield return webRequest.SendWebRequest();
		if (string.IsNullOrEmpty(webRequest.error))
		{
			action?.Invoke(texDownloader.texture);
		}
	}

	private IEnumerator yieldLoadTexture_WebUrl(int hashcode, string url, string localFilePath, Action<object> action)
	{
		using UnityWebRequest webRequest = UnityWebRequest.Get(url);
		webRequest.certificateHandler = new WebRequestCert();
		using DownloadHandlerTexture texDownloader = new DownloadHandlerTexture(readable: true);
		webRequest.downloadHandler = texDownloader;
		yield return webRequest.SendWebRequest();
		if (string.IsNullOrEmpty(webRequest.error))
		{
			_ = texDownloader.texture;
			File.WriteAllBytes(localFilePath, texDownloader.data);
			action?.Invoke(texDownloader.texture);
		}
	}
}
public class public_DistanceAction : MonoBehaviour
{
	public float dis = 1f;

	public Transform traA;

	public Transform traB;

	public UnityEvent eventDelayAction;

	private bool isAction;

	public UnityEvent farFromAction;

	private bool isFarFromAction;

	private void Start()
	{
	}

	private void Update()
	{
		if (!isAction && eventDelayAction != null && Vector3.Distance(traA.position, traB.position) < dis)
		{
			isAction = true;
			isFarFromAction = false;
			eventDelayAction?.Invoke();
		}
		if (!isFarFromAction && farFromAction != null && Vector3.Distance(traA.position, traB.position) > dis)
		{
			isAction = false;
			isFarFromAction = true;
			farFromAction?.Invoke();
		}
	}
}
public class public_Neo2_R_Action : MonoBehaviour
{
	public Texture aTexture;

	public Texture bTexture;

	public float changeTime = 0.5f;

	public Material mat;

	private float timer = 0.5f;

	private void OnEnable()
	{
		timer = changeTime;
	}

	private void Start()
	{
	}

	private void Update()
	{
		if (!base.gameObject.activeInHierarchy)
		{
			return;
		}
		timer -= Time.deltaTime;
		if (timer <= 0f)
		{
			if (mat.mainTexture == aTexture)
			{
				mat.mainTexture = bTexture;
			}
			else
			{
				mat.mainTexture = aTexture;
			}
			timer = changeTime;
		}
	}
}
public class public_RightPoints : MonoBehaviour
{
	public List<GameObject> rightStarts;

	public UnityEvent eventOnAllRight;

	private int iCurRightIndex;

	private void Start()
	{
		iCurRightIndex = 0;
		foreach (GameObject rightStart in rightStarts)
		{
			if (rightStart != null)
			{
				rightStart.SetActive(value: false);
			}
		}
	}

	public void J_AddOneRight()
	{
		if (base.isActiveAndEnabled && iCurRightIndex <= rightStarts.Count - 1)
		{
			if (rightStarts.Count > 0 && rightStarts[iCurRightIndex] != null)
			{
				rightStarts[iCurRightIndex].SetActive(value: true);
			}
			iCurRightIndex++;
			if (iCurRightIndex > rightStarts.Count - 1)
			{
				eventOnAllRight.Invoke();
			}
		}
	}
}
public class publicTrainStepEventCtrl : MonoBehaviour
{
	public AudioClip audioClipGuide;

	[TextArea]
	public string strGuideWords;

	public UnityEvent eventOnEnable;

	public UnityEvent eventTalkFinish;

	public UnityEvent eventOnEndCallback;

	private void Start()
	{
		if (eventOnEndCallback.GetPersistentEventCount() == 0)
		{
			UnityEngine.Debug.LogError("步骤无法正确执行：" + base.name);
		}
	}

	public void OnEnable()
	{
		eventOnEnable.Invoke();
		TrainGuideManager.Inst.J_SetpToTrainStep(this);
		Invoke("OnFinishTalk", audioClipGuide.length);
	}

	private void OnDisable()
	{
		CancelInvoke("OnFinishTalk");
	}

	public void OnEndCallback()
	{
		eventOnEndCallback.Invoke();
	}

	private void OnFinishTalk()
	{
		eventTalkFinish.Invoke();
	}
}
public class RawImageTexturesSwitchCtrl : MonoBehaviour
{
	public float fInteractionInterval = 0.5f;

	public RawImage listRawimagesTarget;

	public List<Texture> listTextures;

	public UnityEvent eventOnTextureChange;

	private int m_index;

	private bool bCanInteract = true;

	private void Start()
	{
		listRawimagesTarget.texture = listTextures[0];
	}

	public void J_SetNext()
	{
		if (listTextures.Count != 0 && bCanInteract)
		{
			bCanInteract = false;
			if (++m_index > listTextures.Count - 1)
			{
				m_index = 0;
			}
			eventOnTextureChange.Invoke();
			listRawimagesTarget.transform.DOLocalMoveY(-558f, 0.5f).OnComplete(delegate
			{
				listRawimagesTarget.texture = listTextures[m_index];
				listRawimagesTarget.transform.DOLocalMoveY(0f, 0.5f);
			});
			StartCoroutine(yieldInteractable());
		}
	}

	private IEnumerator yieldInteractable()
	{
		yield return new WaitForSeconds(fInteractionInterval);
		bCanInteract = true;
	}

	public void J_SetPre()
	{
		if (listTextures.Count != 0 && bCanInteract)
		{
			bCanInteract = false;
			if (--m_index < 0)
			{
				m_index = listTextures.Count - 1;
			}
			eventOnTextureChange.Invoke();
			listRawimagesTarget.transform.DOLocalMoveY(-558f, 0.5f).OnComplete(delegate
			{
				listRawimagesTarget.texture = listTextures[m_index];
				listRawimagesTarget.transform.DOLocalMoveY(0f, 0.5f);
			});
			StartCoroutine(yieldInteractable());
		}
	}
}
public class SliderDrag : MonoBehaviour, IBeginDragHandler, IEventSystemHandler, IEndDragHandler
{
	public static bool isDraging;

	public void OnBeginDrag(PointerEventData eventData)
	{
		isDraging = true;
	}

	public void OnEndDrag(PointerEventData eventData)
	{
		isDraging = false;
		Keting.Ins.Pos(base.gameObject.GetComponent<Slider>().value);
	}
}
public class TrainGuide_PhotoWallCtrl : MonoBehaviour
{
	private int m_iTriggerCount;

	public UnityEvent eventOnTriggerOnce;

	public UnityEvent eventOnTriggerMuityTimes;

	public highlightOutlineFlash m_highlightEffectWall;

	private RawImageTexturesSwitchCtrl[] listCtrledPhotos;

	public static int Mode;

	private bool bCanInteract;

	private void Awake()
	{
		listCtrledPhotos = GetComponentsInChildren<RawImageTexturesSwitchCtrl>();
	}

	public void SetMode(int m)
	{
		Mode = m;
	}

	public void J_SetInteractable(bool isinteractable)
	{
		bCanInteract = isinteractable;
	}

	public void J_AddInteractionCount()
	{
		if (Mode != 1 && bCanInteract)
		{
			m_iTriggerCount++;
			if (m_iTriggerCount == 1)
			{
				eventOnTriggerOnce.Invoke();
			}
			if (m_iTriggerCount == 2)
			{
				Invoke("DelayNextAction_2", 5f);
			}
		}
	}

	private void DelayNextAction_2()
	{
		eventOnTriggerMuityTimes.Invoke();
	}

	public void J_StartGlowHighlight()
	{
		m_highlightEffectWall.StartOutlineGlow();
	}

	public void J_FinishAutoGlow()
	{
		m_highlightEffectWall.StopGlow();
	}
}
public class TrainGuide_QuestionAskCtrl : MonoBehaviour
{
	[Serializable]
	public class cQuestions
	{
		public string title;

		[TextArea]
		public string strWords;

		public AudioClip audioClip;
	}

	public static TrainGuide_QuestionAskCtrl Inst;

	public AudioSource m_audioSource;

	public cQuestions[] listQuestions;

	public Transform transUIScaleRoot;

	public Text m_txtProgressI;

	public Text m_txtQuestion;

	public Text m_txtVoiceRecResult;

	private int m_index = -1;

	private int m_iTriggerCount;

	public UnityEvent eventOnTriggerOnce;

	public UnityEvent eventOnEndAllQuestions;

	public highlightOutlineFlash m_highlightEffectWall;

	public hj.AudioRecWordsCtrl m_audioRecWordsCtrl;

	private bool bCanInteract = true;

	private bool isAutoGlowing;

	private bool hasStartVoiceRec;

	private bool hasStartSpeak;

	private float frecStopTimer;

	private string prewords;

	private void Awake()
	{
		Inst = this;
		transUIScaleRoot.gameObject.SetActive(value: false);
		transUIScaleRoot.localScale = Vector3.zero;
		m_txtProgressI.text = null;
		m_txtQuestion.text = null;
		m_txtVoiceRecResult.text = null;
	}

	public void J_TriggerAction()
	{
		if (bCanInteract)
		{
			bCanInteract = false;
			m_iTriggerCount++;
			if (m_iTriggerCount == 1)
			{
				eventOnTriggerOnce.Invoke();
			}
			transUIScaleRoot.localScale = Vector3.zero;
			transUIScaleRoot.gameObject.SetActive(value: true);
			transUIScaleRoot.DOScale(1f, 1f).OnComplete(delegate
			{
				ShowNextQuestion();
			});
		}
	}

	private void ShowNextQuestion()
	{
		m_index++;
		StartCoroutine(yieldSpeakQuestion(m_index));
	}

	private IEnumerator yieldSpeakQuestion(int iquesttionIndex)
	{
		TrainGuideManager.Inst.J_PauseAllOtherMediaPlayers();
		m_txtProgressI.text = $"{iquesttionIndex + 1}/{listQuestions.Length}";
		m_txtQuestion.text = listQuestions[iquesttionIndex].strWords;
		m_audioSource.clip = listQuestions[iquesttionIndex].audioClip;
		m_txtVoiceRecResult.text = null;
		m_audioSource.Play();
		yield return new WaitForSeconds(m_audioSource.clip.length);
		if (m_index == listQuestions.Length - 1)
		{
			eventOnEndAllQuestions.Invoke();
			yield break;
		}
		hasStartVoiceRec = true;
		frecStopTimer = 0f;
		m_audioRecWordsCtrl.J_StartRec(OnVoiceWordsRec);
	}

	private void OnVoiceWordsRec(string strWordsAll)
	{
		if (prewords != strWordsAll && !string.IsNullOrEmpty(strWordsAll))
		{
			hasStartSpeak = true;
			frecStopTimer = 0f;
			prewords = strWordsAll;
			m_txtVoiceRecResult.text = strWordsAll;
		}
	}

	private void StopRec()
	{
		hasStartSpeak = false;
		hasStartVoiceRec = false;
		ShowNextQuestion();
		m_audioRecWordsCtrl.J_StopRec();
	}

	private void Update()
	{
		if (!hasStartVoiceRec)
		{
			return;
		}
		if (!hasStartSpeak)
		{
			if ((frecStopTimer += Time.deltaTime) > 10f)
			{
				StopRec();
			}
		}
		else if ((frecStopTimer += Time.deltaTime) > 5f)
		{
			StopRec();
		}
	}

	public void J_StartGlowHighlight()
	{
		isAutoGlowing = true;
		m_highlightEffectWall.StartOutlineGlow();
	}

	public void J_FinishAutoGlow()
	{
		isAutoGlowing = false;
		m_highlightEffectWall.StopGlow();
	}

	public void J_OnHandRayEnter()
	{
		if (bCanInteract)
		{
			m_highlightEffectWall.StartOutlineGlow();
		}
	}

	public void J_OnHandRayExit()
	{
		if (!isAutoGlowing)
		{
			m_highlightEffectWall.StopGlow();
		}
	}
}
public class TrainGuide_VideoFilmPlayerCtrl : MonoBehaviour
{
	public static TrainGuide_VideoFilmPlayerCtrl Inst;

	public AudioSource m_audioSourceBtnRot;

	public VideoPlayer m_videoPlayerCtrl;

	public AudioSource m_audioSourceVideo;

	public VideoClip[] listFiles;

	private int m_index = 1;

	private int m_iTriggerCount;

	public UnityEvent eventOnTriggerOnce;

	public UnityEvent eventOnTriggerMuityTimes;

	public highlightOutlineFlash m_highlightEffectWall;

	public GameObject[] listTriggers;

	private bool bCanInteract = true;

	private bool isAutoGlowing;

	private bool isDevicePlaying;

	private void Awake()
	{
		Inst = this;
		GameObject[] array = listTriggers;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetActive(value: false);
		}
	}

	public void J_OpenDevice()
	{
		if (!isDevicePlaying)
		{
			TrainGuideManager.Inst?.J_PauseAllOtherMediaPlayers();
			isDevicePlaying = true;
			J_ShowNextContent();
		}
		else
		{
			J_CloseDevice();
		}
	}

	public void J_CloseDevice()
	{
		isDevicePlaying = false;
		m_audioSourceBtnRot.Stop();
		m_videoPlayerCtrl.Stop();
		m_audioSourceVideo.Stop();
	}

	public void J_ShowNextContent()
	{
		if (bCanInteract && isDevicePlaying)
		{
			StopAllCoroutines();
			m_index++;
			if (m_index > 4)
			{
				m_index = 1;
			}
			StartCoroutine(yieldChangeContent());
		}
	}

	public void J_ShowPreContent()
	{
		if (bCanInteract && isDevicePlaying)
		{
			StopAllCoroutines();
			m_index--;
			if (m_index < 1)
			{
				m_index = 4;
			}
			StartCoroutine(yieldChangeContent());
		}
	}

	private IEnumerator yieldChangeContent()
	{
		bCanInteract = false;
		m_audioSourceBtnRot.Play();
		yield return new WaitForSeconds(m_audioSourceBtnRot.clip.length);
		m_videoPlayerCtrl.url = "https://crci-res.guavavr.com/hjsp/" + m_index + ".mp4";
		m_videoPlayerCtrl.SetTargetAudioSource(0, m_audioSourceVideo);
		m_videoPlayerCtrl.Play();
		bCanInteract = true;
		m_iTriggerCount++;
		if (TrainGuide_PhotoWallCtrl.Mode == 0)
		{
			if (m_iTriggerCount == 1)
			{
				eventOnTriggerOnce.Invoke();
			}
			if (m_iTriggerCount == 2)
			{
				Invoke("DelayNextAction_2", 5f);
			}
		}
	}

	private void DelayNextAction_2()
	{
		eventOnTriggerMuityTimes.Invoke();
	}

	public void J_StartGlowHighlight()
	{
		isAutoGlowing = true;
		m_highlightEffectWall.StartOutlineGlow();
	}

	public void J_FinishAutoGlow()
	{
		isAutoGlowing = false;
		m_highlightEffectWall.StopGlow();
	}

	public void J_OnHandRayEnter()
	{
		m_highlightEffectWall.StartOutlineGlow();
	}

	public void J_OnHandRayExit()
	{
		if (!isAutoGlowing)
		{
			m_highlightEffectWall.StopGlow();
		}
	}

	public void J_EnableTriggers()
	{
		GameObject[] array = listTriggers;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetActive(value: true);
		}
	}
}
public class TrainGuide_VoicePlayerCtrl : MonoBehaviour
{
	public static TrainGuide_VoicePlayerCtrl Inst;

	public AudioSource m_audioSourceBtnRot;

	public AudioSource m_audioSource;

	public AudioClip m_audioClipUnclear;

	public AudioClip[] listAudios;

	public AudioClip[] listAudios_Big02;

	private int m_index;

	private int m_index_big02;

	private int m_iTriggerCount;

	public UnityEvent eventOnTriggerOnce;

	public UnityEvent eventOnTriggerMuityTimes;

	public highlightOutlineFlash[] m_highlightEffects;

	private bool isDevicePlaying_Shouyinji;

	private bool isDevicePlaying_Chanpianji;

	public GameObject[] listTriggers;

	private bool bCanInteract = true;

	private bool isAutoGlowing;

	public GameObject[] listModels;

	private int imodelindex;

	private bool bCanModelInteract;

	private int iModelChangeTriggerCount;

	public UnityEvent eventOnModelChangeOnce;

	private void Awake()
	{
		Inst = this;
	}

	private void Start()
	{
		GameObject[] array = listTriggers;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetActive(value: false);
		}
	}

	public void J_OpenDevice_Shouyinji()
	{
		if (!isDevicePlaying_Shouyinji)
		{
			TrainGuideManager.Inst?.J_PauseAllOtherMediaPlayers();
			isDevicePlaying_Shouyinji = true;
			J_PlayNextAudio_Shouyinji();
		}
		else
		{
			J_CloseDevice_Shouyinji();
		}
	}

	public void J_OpenDevice_ChanPianji()
	{
		if (!isDevicePlaying_Chanpianji)
		{
			TrainGuideManager.Inst?.J_PauseAllOtherMediaPlayers();
			isDevicePlaying_Chanpianji = true;
			J_PlayNextAudio_Chanpianji();
		}
		else
		{
			J_CloseDevice_Chanpianji();
		}
	}

	public void J_CloseDevice_Shouyinji()
	{
		isDevicePlaying_Shouyinji = false;
		m_audioSourceBtnRot.Stop();
		m_audioSource.Stop();
	}

	public void J_CloseDevice_Chanpianji()
	{
		isDevicePlaying_Chanpianji = false;
		m_audioSourceBtnRot.Stop();
		m_audioSource.Stop();
	}

	public void J_PlayNextAudio_Shouyinji()
	{
		if (bCanInteract && isDevicePlaying_Shouyinji)
		{
			imodelindex = 0;
			StopAllCoroutines();
			m_index++;
			if (m_index > listAudios.Length - 1)
			{
				m_index = 0;
			}
			_ = listAudios[m_index];
			StartCoroutine(yieldChangeAudio(listAudios[m_index]));
		}
	}

	public void J_PlayPreAudio_Shouyinji()
	{
		if (bCanInteract && isDevicePlaying_Shouyinji)
		{
			imodelindex = 0;
			StopAllCoroutines();
			m_index--;
			if (m_index < 0)
			{
				m_index = listAudios.Length - 1;
			}
			StartCoroutine(yieldChangeAudio(listAudios[m_index]));
		}
	}

	public void J_PlayNextAudio_Chanpianji()
	{
		if (bCanInteract && isDevicePlaying_Chanpianji)
		{
			imodelindex = 1;
			StopAllCoroutines();
			m_index_big02++;
			if (m_index_big02 > listAudios_Big02.Length - 1)
			{
				m_index_big02 = 0;
			}
			StartCoroutine(yieldChangeAudio(listAudios_Big02[m_index]));
		}
	}

	public void J_PlayPreAudio_Chanpianji()
	{
		if (bCanInteract && isDevicePlaying_Chanpianji)
		{
			imodelindex = 1;
			StopAllCoroutines();
			m_index_big02--;
			if (m_index_big02 < 0)
			{
				m_index_big02 = listAudios_Big02.Length - 1;
			}
			StartCoroutine(yieldChangeAudio(listAudios_Big02[m_index]));
		}
	}

	private IEnumerator yieldChangeAudio(AudioClip playaudioClip)
	{
		bCanInteract = false;
		m_audioSourceBtnRot.Play();
		yield return new WaitForSeconds(m_audioSourceBtnRot.clip.length);
		m_audioSource.clip = m_audioClipUnclear;
		float num = UnityEngine.Random.Range(1f, 3f);
		float time = UnityEngine.Random.Range(0f, m_audioClipUnclear.length - num);
		m_audioSource.time = time;
		m_audioSource.Play();
		yield return new WaitForSeconds(num);
		m_audioSource.clip = playaudioClip;
		m_audioSource.Play();
		bCanInteract = true;
		m_iTriggerCount++;
		if (TrainGuide_PhotoWallCtrl.Mode == 0)
		{
			if (m_iTriggerCount == 1)
			{
				eventOnTriggerOnce.Invoke();
			}
			if (m_iTriggerCount == 2)
			{
				Invoke("DelayNextAction_2", 5f);
			}
		}
	}

	private void DelayNextAction_2()
	{
		eventOnTriggerMuityTimes.Invoke();
	}

	public void J_SetModelChangeEnable(bool isenable)
	{
		bCanModelInteract = isenable;
	}

	public void J_ChangeModelNext()
	{
		if (listModels.Length >= 2 && bCanModelInteract)
		{
			iModelChangeTriggerCount++;
			if (iModelChangeTriggerCount == 1)
			{
				Invoke("DelayNextAction_3", 3f);
			}
			bCanModelInteract = false;
			GameObject smallM = listModels[imodelindex];
			smallM.transform.DOScale(0f, 0.5f).OnComplete(delegate
			{
				smallM.SetActive(value: false);
			});
			imodelindex++;
			if (imodelindex > listModels.Length - 1)
			{
				imodelindex = 0;
			}
			listModels[imodelindex].SetActive(value: true);
			listModels[imodelindex].transform.localScale = Vector3.zero;
			listModels[imodelindex].transform.DOScale(Vector3.one, 1f);
			StartCoroutine(yieldInteractable());
		}
	}

	public void J_ChangeModelPre()
	{
		if (listModels.Length >= 2 && bCanModelInteract)
		{
			bCanModelInteract = false;
			GameObject smallM = listModels[imodelindex];
			smallM.transform.DOScale(0f, 0.5f).OnComplete(delegate
			{
				smallM.SetActive(value: false);
			});
			imodelindex--;
			if (imodelindex < 0)
			{
				imodelindex = listModels.Length - 1;
			}
			listModels[imodelindex].SetActive(value: true);
			listModels[imodelindex].transform.localScale = Vector3.zero;
			listModels[imodelindex].transform.DOScale(Vector3.one, 1f);
			StartCoroutine(yieldInteractable());
		}
	}

	private IEnumerator yieldInteractable()
	{
		yield return new WaitForSeconds(0.5f);
		bCanModelInteract = true;
	}

	private void DelayNextAction_3()
	{
		eventOnModelChangeOnce.Invoke();
	}

	public void J_StartGlowHighlight()
	{
		isAutoGlowing = true;
		highlightOutlineFlash[] highlightEffects = m_highlightEffects;
		for (int i = 0; i < highlightEffects.Length; i++)
		{
			highlightEffects[i].StartOutlineGlow();
		}
	}

	public void J_FinishAutoGlow()
	{
		isAutoGlowing = false;
		highlightOutlineFlash[] highlightEffects = m_highlightEffects;
		for (int i = 0; i < highlightEffects.Length; i++)
		{
			highlightEffects[i].StopGlow();
		}
	}

	public void J_EnableTriggers()
	{
		GameObject[] array = listTriggers;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetActive(value: true);
		}
	}
}
public class TrainGuide_VRPlayerCtrl : MonoBehaviour
{
	public static TrainGuide_VRPlayerCtrl Inst;

	public Transform m_transHead;

	public Transform m_transRightHand;

	public GameObject m_objMenuUI;

	public GameObject m_objHandRayConatienr;

	public GameObject m_objHandTeleportRay;

	public GameObject m_uiHandRay;

	public bool shouldModelHandRayEnable;

	private List<Transform> handRayTrigger_s = new List<Transform>();

	private float fquitTimer;

	private bool hasLoad;

	private void Awake()
	{
		Inst = this;
		if ((bool)m_objMenuUI)
		{
			m_objMenuUI.SetActive(value: false);
		}
		else
		{
			m_objMenuUI = base.transform.parent.GetChild(1).gameObject;
		}
	}

	public void J_ShowHandRay()
	{
		shouldModelHandRayEnable = true;
	}

	public void J_ShowHandTeleportRay(bool isActive)
	{
		m_objHandTeleportRay.SetActive(isActive);
	}

	private void Update()
	{
		if (fquitTimer > 0f)
		{
			fquitTimer -= Time.deltaTime;
		}
		if (Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.APP) || Input.GetKeyDown(KeyCode.Escape))
		{
			ClickMenuBtn();
		}
		Ray ray = new Ray(m_transRightHand.position, m_transRightHand.forward);
		if (Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.TRIGGER) && m_objHandRayConatienr.activeSelf && Physics.Raycast(ray, out var hitInfo, 200f, 1 << LayerMask.NameToLayer("Photo")))
		{
			hitInfo.transform.GetComponent<HandRayTrigger>().OnPointerClick();
		}
		if (Physics.Raycast(ray, out hitInfo, 200f, 1 << LayerMask.NameToLayer("Photo")) && m_objHandRayConatienr.activeSelf)
		{
			HandRayTrigger_VirtualButtonAction[] componentsInChildren;
			if (handRayTrigger_s.Count > 0)
			{
				if (handRayTrigger_s[0] == hitInfo.transform)
				{
					return;
				}
				foreach (Transform handRayTrigger_ in handRayTrigger_s)
				{
					componentsInChildren = handRayTrigger_.GetComponentsInChildren<HandRayTrigger_VirtualButtonAction>();
					for (int i = 0; i < componentsInChildren.Length; i++)
					{
						componentsInChildren[i].OnPointerExit();
					}
					handRayTrigger_.GetComponent<HandRayTrigger>().OnPointerExit();
				}
				handRayTrigger_s.Clear();
			}
			handRayTrigger_s.Add(hitInfo.transform);
			componentsInChildren = hitInfo.transform.GetComponentsInChildren<HandRayTrigger_VirtualButtonAction>();
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				componentsInChildren[i].OnPointerEnter();
			}
			hitInfo.transform.GetComponent<HandRayTrigger>()?.OnPointerEnter();
		}
		else
		{
			if (handRayTrigger_s.Count <= 0)
			{
				return;
			}
			foreach (Transform handRayTrigger_2 in handRayTrigger_s)
			{
				HandRayTrigger_VirtualButtonAction[] componentsInChildren = handRayTrigger_2.GetComponentsInChildren<HandRayTrigger_VirtualButtonAction>();
				for (int i = 0; i < componentsInChildren.Length; i++)
				{
					componentsInChildren[i].OnPointerExit();
				}
				handRayTrigger_2.GetComponent<HandRayTrigger>()?.OnPointerExit();
			}
			handRayTrigger_s.Clear();
		}
	}

	private void ClickMenuBtn()
	{
		if ((bool)m_objMenuUI)
		{
			m_objMenuUI.SetActive(!m_objMenuUI.activeSelf);
			m_objMenuUI.SetOtherUICanvaState();
		}
	}

	public void J_QuitApp()
	{
		ScenesHelper.LoadScene("怀旧-农村外景");
	}

	public void ReturnToCenter()
	{
		ScenesHelper.LoadScene(ScenesHelper.WeiAiXinCenterScene);
	}

	public void ShowMenuUI()
	{
		if ((bool)m_objMenuUI)
		{
			m_objMenuUI.SetActive(value: true);
		}
	}

	public void J_LoadScene(string sceneName)
	{
		if (!hasLoad)
		{
			hasLoad = true;
			Load.LoadScene2(sceneName);
		}
	}
}
public class TrainGuideManager : MonoBehaviour
{
	private static TrainGuideManager _Inst;

	public guava_smallGuyCtrl m_guava_SmallGuyCtrl;

	public AudioMixer m_audioMixer_Media;

	public static TrainGuideManager Inst
	{
		get
		{
			if (_Inst == null)
			{
				_Inst = new TrainGuideManager();
			}
			return _Inst;
		}
		set
		{
			_Inst = value;
		}
	}

	private void Awake()
	{
		Inst = this;
	}

	private void Start()
	{
	}

	private void Update()
	{
	}

	public void J_SetpToTrainStep(publicTrainStepEventCtrl trainStepCtrl)
	{
		if (TrainGuide_PhotoWallCtrl.Mode == 0)
		{
			m_guava_SmallGuyCtrl.PlayGuideVoice(trainStepCtrl.audioClipGuide);
			m_guava_SmallGuyCtrl.ShowGuideText(trainStepCtrl.strGuideWords);
			m_audioMixer_Media.SetFloat("MediaPlayerVolume", -40f);
		}
	}

	public void J_PauseAllOtherMediaPlayers()
	{
		TrainGuide_VoicePlayerCtrl.Inst?.J_CloseDevice_Chanpianji();
		TrainGuide_VoicePlayerCtrl.Inst?.J_CloseDevice_Shouyinji();
		TrainGuide_VideoFilmPlayerCtrl.Inst?.J_CloseDevice();
		PrivateAlbumCtrl.Inst?.J_CloseAlbum();
	}

	public void J_SetAllMedia_VolumeQuite(bool isQuite)
	{
		if (isQuite)
		{
			m_audioMixer_Media.SetFloat("MediaPlayerVolume", -10f);
		}
		else
		{
			m_audioMixer_Media.SetFloat("MediaPlayerVolume", 0f);
		}
	}
}
public class Yanmowu : MonoBehaviour
{
	public LineRenderer line;

	public Text txt;

	public GameObject cvs;

	public Pvr_ControllerModuleInit right;

	public Animator ani;

	public GameObject jiang;

	private AnimationState a1;

	private bool isLastMo;

	private HighlightEffect last;

	private float lastime;

	private GameObject dor;

	private Vector3 lastRpos = Vector3.zero;

	private void Start()
	{
		ani = GameObject.Find("石磨").GetComponent<Animator>();
	}

	private void Update()
	{
		if (!isLastMo)
		{
			if (Physics.Raycast(Pvr.GetMainRay(line), out var hitInfo))
			{
				HighlightEffect component = hitInfo.collider.gameObject.GetComponent<HighlightEffect>();
				if (last != null && last != component)
				{
					last.highlighted = false;
				}
				if (component != null)
				{
					component.highlighted = true;
					last = component;
				}
				else if (hitInfo.collider.gameObject.name == "出口门")
				{
					dor = hitInfo.collider.transform.GetChild(0).gameObject;
					dor.SetActive(value: true);
				}
			}
			else
			{
				dor?.SetActive(value: false);
				dor = null;
				if (last != null)
				{
					last.highlighted = false;
				}
				last = null;
			}
			if (Pvr.IsMainKeyDown(1))
			{
				if (last != null)
				{
					cvs.SetActive(value: true);
					txt.text = last.gameObject.name;
					if (txt.text == "石磨")
					{
						txt.text += "\n\n扣住扳机，手柄划圈可以磨磨";
						isLastMo = true;
						ani.Play("mo");
						ani.speed = 0f;
					}
					lastime = Time.time;
				}
				else if (dor != null)
				{
					Load.LoadScene2("怀旧-农村外景");
				}
			}
		}
		else
		{
			if (last != null)
			{
				last.highlighted = false;
			}
			if (lastRpos != Vector3.zero)
			{
				float num = Vector3.Distance(right.transform.position, lastRpos);
				ani.speed = num * 200f;
				if (ani.speed > 0.6f)
				{
					jiang.SetActive(value: true);
				}
			}
			lastRpos = right.transform.position;
		}
		if (Pvr.IsMainKeyUp(1))
		{
			ani.Play("shimo");
			jiang.SetActive(value: false);
			isLastMo = false;
		}
		if (Time.time - lastime > 3.5f)
		{
			cvs.SetActive(value: false);
		}
	}
}
public class ButtonHandler : MonoBehaviour
{
	public void onButtonClicked(Button button)
	{
		GameObject gameObject = GameObject.Find("GameController");
		if (gameObject != null)
		{
			TestHome component = gameObject.GetComponent<TestHome>();
			if (component == null)
			{
				UnityEngine.Debug.LogError("Missing game controller...");
			}
			else if (button.name == "JoinButton")
			{
				component.onJoinButtonClicked();
			}
			else if (button.name == "LeaveButton")
			{
				component.onLeaveButtonClicked();
			}
		}
	}
}
public class TestHelloUnityVideo
{
	private IRtcEngine mRtcEngine;

	private const float Offset = 100f;

	public void loadEngine(string appId)
	{
		UnityEngine.Debug.Log("initializeEngine");
		if (mRtcEngine != null)
		{
			UnityEngine.Debug.Log("Engine exists. Please unload it first!");
			return;
		}
		mRtcEngine = IRtcEngine.GetEngine(appId);
		mRtcEngine.SetLogFilter(LOG_FILTER.DEBUG);
	}

	public void join(string channel)
	{
		UnityEngine.Debug.Log("calling join (channel = " + channel + ")");
		if (mRtcEngine != null)
		{
			mRtcEngine.OnJoinChannelSuccess = onJoinChannelSuccess;
			mRtcEngine.OnUserJoined = onUserJoined;
			mRtcEngine.OnUserOffline = onUserOffline;
			mRtcEngine.EnableVideo();
			mRtcEngine.EnableVideoObserver();
			mRtcEngine.JoinChannel(channel, null);
		}
	}

	public string getSdkVersion()
	{
		return IRtcEngine.GetSdkVersion();
	}

	public void leave()
	{
		UnityEngine.Debug.Log("calling leave");
		if (mRtcEngine != null)
		{
			mRtcEngine.LeaveChannel();
			mRtcEngine.DisableVideoObserver();
		}
	}

	public void unloadEngine()
	{
		UnityEngine.Debug.Log("calling unloadEngine");
		if (mRtcEngine != null)
		{
			IRtcEngine.Destroy();
			mRtcEngine = null;
		}
	}

	public void EnableVideo(bool pauseVideo)
	{
		if (mRtcEngine != null)
		{
			if (!pauseVideo)
			{
				mRtcEngine.EnableVideo();
			}
			else
			{
				mRtcEngine.DisableVideo();
			}
		}
	}

	public void onSceneHelloVideoLoaded()
	{
		GameObject gameObject = GameObject.Find("Quad");
		if ((object)gameObject == null)
		{
			UnityEngine.Debug.Log("BBBB: failed to find Quad");
			return;
		}
		gameObject.AddComponent<VideoSurface>();
		GameObject gameObject2 = GameObject.Find("Cube");
		if ((object)gameObject2 == null)
		{
			UnityEngine.Debug.Log("BBBB: failed to find Cube");
		}
		else
		{
			gameObject2.AddComponent<VideoSurface>();
		}
	}

	private void onJoinChannelSuccess(string channelName, uint uid, int elapsed)
	{
		UnityEngine.Debug.Log("JoinChannelSuccessHandler: uid = " + uid);
		GameObject.Find("VersionText").GetComponent<Text>().text = "SDK Version : " + getSdkVersion();
	}

	private void onUserJoined(uint uid, int elapsed)
	{
		UnityEngine.Debug.Log("onUserJoined: uid = " + uid + " elapsed = " + elapsed);
		if ((object)GameObject.Find(uid.ToString()) == null)
		{
			VideoSurface videoSurface = makeImageSurface(uid.ToString());
			if ((object)videoSurface != null)
			{
				videoSurface.SetForUser(uid);
				videoSurface.SetEnable(enable: true);
				videoSurface.SetVideoSurfaceType(AgoraVideoSurfaceType.RawImage);
				videoSurface.SetGameFps(30u);
			}
		}
	}

	public VideoSurface makePlaneSurface(string goName)
	{
		GameObject gameObject = GameObject.CreatePrimitive(PrimitiveType.Plane);
		if (gameObject == null)
		{
			return null;
		}
		gameObject.name = goName;
		gameObject.transform.Rotate(-90f, 0f, 0f);
		float y = UnityEngine.Random.Range(3f, 5f);
		float x = UnityEngine.Random.Range(-2f, 2f);
		gameObject.transform.position = new Vector3(x, y, 0f);
		gameObject.transform.localScale = new Vector3(0.25f, 0.5f, 0.5f);
		return gameObject.AddComponent<VideoSurface>();
	}

	public VideoSurface makeImageSurface(string goName)
	{
		GameObject gameObject = new GameObject();
		if (gameObject == null)
		{
			return null;
		}
		gameObject.name = goName;
		gameObject.AddComponent<RawImage>();
		gameObject.AddComponent<UIElementDragger>();
		GameObject gameObject2 = GameObject.Find("Canvas");
		if (gameObject2 != null)
		{
			gameObject.transform.parent = gameObject2.transform;
		}
		gameObject.transform.Rotate(0f, 0f, 180f);
		float x = UnityEngine.Random.Range(100f - (float)Screen.width / 2f, (float)Screen.width / 2f - 100f);
		float y = UnityEngine.Random.Range(100f, (float)Screen.height / 2f - 100f);
		gameObject.transform.localPosition = new Vector3(x, y, 0f);
		gameObject.transform.localScale = new Vector3(3f, 4f, 1f);
		return gameObject.AddComponent<VideoSurface>();
	}

	private void onUserOffline(uint uid, USER_OFFLINE_REASON reason)
	{
		UnityEngine.Debug.Log("onUserOffline: uid = " + uid + " reason = " + reason);
		GameObject gameObject = GameObject.Find(uid.ToString());
		if ((object)gameObject != null)
		{
			UnityEngine.Object.Destroy(gameObject);
		}
	}
}
public class TestHome : MonoBehaviour
{
	private ArrayList permissionList = new ArrayList();

	private static TestHelloUnityVideo app;

	private string HomeSceneName = "SceneHome";

	private string PlaySceneName = "SceneHelloVideo";

	[SerializeField]
	private string AppID = "your_appid";

	private void Awake()
	{
		permissionList.Add("android.permission.RECORD_AUDIO");
		permissionList.Add("android.permission.CAMERA");
		UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
	}

	private void Start()
	{
		CheckAppId();
	}

	private void Update()
	{
		CheckPermissions();
	}

	private void CheckAppId()
	{
		GameObject gameObject = GameObject.Find("AppIDText");
		if (!(gameObject != null))
		{
			return;
		}
		Text component = gameObject.GetComponent<Text>();
		if (component != null)
		{
			if (string.IsNullOrEmpty(AppID))
			{
				component.text = "AppID: UNDEFINED!";
			}
			else
			{
				component.text = "AppID: " + AppID.Substring(0, 4) + "********" + AppID.Substring(AppID.Length - 4, 4);
			}
		}
	}

	private void CheckPermissions()
	{
		foreach (string permission in permissionList)
		{
			if (!Permission.HasUserAuthorizedPermission(permission))
			{
				Permission.RequestUserPermission(permission);
			}
		}
	}

	public void onJoinButtonClicked()
	{
		InputField component = GameObject.Find("ChannelName").GetComponent<InputField>();
		if (app == null)
		{
			app = new TestHelloUnityVideo();
			app.loadEngine(AppID);
		}
		app.join(component.text);
		SceneManager.sceneLoaded += OnLevelFinishedLoading;
		SceneManager.LoadScene(PlaySceneName, LoadSceneMode.Single);
	}

	public void onLeaveButtonClicked()
	{
		if (app != null)
		{
			app.leave();
			app.unloadEngine();
			app = null;
			SceneManager.LoadScene(HomeSceneName, LoadSceneMode.Single);
		}
		UnityEngine.Object.Destroy(base.gameObject);
	}

	public void OnLevelFinishedLoading(Scene scene, LoadSceneMode mode)
	{
		if (scene.name == PlaySceneName)
		{
			if (app != null)
			{
				app.onSceneHelloVideoLoaded();
			}
			SceneManager.sceneLoaded -= OnLevelFinishedLoading;
		}
	}

	private void OnApplicationPause(bool paused)
	{
		if (app != null)
		{
			app.EnableVideo(paused);
		}
	}

	private void OnApplicationQuit()
	{
		if (app != null)
		{
			app.unloadEngine();
		}
	}
}
public class UVAnimation : MonoBehaviour
{
	public bool pauseTimer;

	public Vector2 uvDefaultTiling = Vector2.one;

	public Vector2 uvDefaultOffset = Vector2.zero;

	public Vector2 uvOffsetSpeed = Vector2.zero;

	public Color matDefaultColor = Color.white;

	private Renderer _renderer;

	private Material _mat;

	private Vector2 m_offset;

	private Vector2 m_tiling;

	private void Awake()
	{
		Renderer component = GetComponent<Renderer>();
		if ((bool)component)
		{
			_renderer = component;
		}
		else
		{
			base.enabled = false;
		}
		if (_renderer != null && _renderer.material != null)
		{
			_renderer.material.SetColor("_TintColor", matDefaultColor);
		}
	}

	private void Start()
	{
		if ((bool)_renderer)
		{
			_mat = _renderer.material;
			m_offset = uvDefaultOffset;
			m_tiling = uvDefaultTiling;
			if (_mat != null)
			{
				_mat.mainTextureOffset = m_offset;
				_mat.mainTextureScale = m_tiling;
			}
		}
	}

	private void Update()
	{
		if (uvOffsetSpeed.x != 0f || uvOffsetSpeed.y != 0f)
		{
			m_offset.x += uvOffsetSpeed.x * (pauseTimer ? Time.deltaTime : Time.unscaledDeltaTime);
			if (m_offset.x > 1f)
			{
				m_offset.x -= 1f;
			}
			else if (m_offset.x < -1f)
			{
				m_offset.x += 1f;
			}
			m_offset.y += uvOffsetSpeed.y * (pauseTimer ? Time.deltaTime : Time.unscaledDeltaTime);
			if (m_offset.y > 1f)
			{
				m_offset.y -= 1f;
			}
			else if (m_offset.y < -1f)
			{
				m_offset.y += 1f;
			}
			_mat.mainTextureOffset = m_offset;
		}
	}

	private void OnDestroy()
	{
		if (_mat != null)
		{
			UnityEngine.Object.DestroyImmediate(_mat);
		}
	}
}
public class MobileBloom : MonoBehaviour
{
	[Range(0f, 5f)]
	public float BloomAmount = 1f;

	[Range(0f, 5f)]
	public float BlurAmount = 2f;

	[Range(0f, 1f)]
	public float FadeAmount = 0.2f;

	private static readonly int scrWidth = Screen.width / 4;

	private static readonly int scrHeight = Screen.height / 4;

	private static readonly int blAmountString = Shader.PropertyToID("_BloomAmount");

	private static readonly int blurAmountString = Shader.PropertyToID("_BlurAmount");

	private static readonly int fadeAmountString = Shader.PropertyToID("_FadeAmount");

	private static readonly int bloomTexString = Shader.PropertyToID("_BloomTex");

	public Material material;

	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		material.SetFloat(blurAmountString, BlurAmount / 2f);
		material.SetFloat(fadeAmountString, FadeAmount);
		RenderTexture temporary = RenderTexture.GetTemporary(scrWidth, scrHeight, 0, source.format);
		Graphics.Blit(source, temporary, material, 0);
		RenderTexture temporary2 = RenderTexture.GetTemporary(scrWidth / 2, scrHeight / 2, 0, source.format);
		Graphics.Blit(temporary, temporary2, material, 1);
		RenderTexture.ReleaseTemporary(temporary);
		RenderTexture temporary3 = RenderTexture.GetTemporary(scrWidth, scrHeight, 0, source.format);
		Graphics.Blit(temporary2, temporary3, material, 1);
		RenderTexture.ReleaseTemporary(temporary2);
		material.SetFloat(blAmountString, BloomAmount);
		material.SetTexture(bloomTexString, temporary3);
		Graphics.Blit(source, destination, material, 2);
		RenderTexture.ReleaseTemporary(temporary3);
	}

	public void Blor(Slider a)
	{
		BlurAmount = a.value;
	}

	public void Blum(Slider a)
	{
		BloomAmount = a.value;
	}
}
public class Move : MonoBehaviour
{
	public Vector3[] points;

	public Vector3[] orients;

	public float accuracy;

	private Vector3 currentPosiition;

	private Vector3 targetPos;

	private Vector3 targetOr;

	private int indexp;

	private int indexo;

	private void Start()
	{
		targetPos = points[0];
		targetOr = orients[0];
		indexp = 0;
		indexo = 0;
	}

	private void Update()
	{
		currentPosiition = base.transform.position;
		if (V3Equal(currentPosiition, targetPos))
		{
			targetPos = points[(indexp + 1 != points.Length) ? (++indexp) : 0];
			targetOr = orients[(indexo + 1 != points.Length) ? (++indexo) : 0];
		}
		base.gameObject.transform.position = Vector3.Lerp(currentPosiition, targetPos, 0.01f);
		base.gameObject.transform.rotation = Quaternion.Lerp(base.transform.rotation, Quaternion.Euler(targetOr), 0.01f);
	}

	public bool V3Equal(Vector3 a, Vector3 b)
	{
		return Vector3.SqrMagnitude(a - b) < accuracy;
	}
}
[AddComponentMenu("UI/CircleImage", 12)]
public class CircleImage : Image
{
	private readonly Color32 GRAY_COLOR = new Color32(60, 60, 60, byte.MaxValue);

	public int segements = 100;

	[SerializeField]
	public float showPercent = 1f;

	private List<Vector3> _vertexList = new List<Vector3>();

	public bool accurateRaycast;

	protected override void OnPopulateMesh(VertexHelper vh)
	{
		vh.Clear();
		_vertexList.Clear();
		AddVertex(vh);
		AddTriangle(vh);
	}

	private void AddVertex(VertexHelper vh)
	{
		float width = base.rectTransform.rect.width;
		float height = base.rectTransform.rect.height;
		int num = (int)((float)segements * showPercent);
		Vector4 vector = ((base.overrideSprite != null) ? DataUtility.GetInnerUV(base.overrideSprite) : Vector4.zero);
		float num2 = vector.z - vector.x;
		float num3 = vector.w - vector.y;
		Vector2 uvCenter = new Vector2((vector.x + vector.z) * 0.5f, (vector.y + vector.w) * 0.5f);
		Vector2 uvScale = new Vector2(num2 / width, num3 / height);
		float num4 = (float)Math.PI * 2f / (float)segements;
		float num5 = width * 0.5f;
		Vector2 vector2 = new Vector2((0.5f - base.rectTransform.pivot.x) * width, (0.5f - base.rectTransform.pivot.y) * height);
		Vector2 zero = Vector2.zero;
		Color32 originColor = GetOriginColor();
		UIVertex uIVertex = GetUIVertex(originColor, vector2, zero, uvCenter, uvScale);
		vh.AddVert(uIVertex);
		int num6 = num + 1;
		if (showPercent == 0f)
		{
			num6 = 0;
		}
		float num7 = 0f;
		Vector2 zero2 = Vector2.zero;
		for (int i = 0; i < segements + 1; i++)
		{
			float x = Mathf.Cos(num7) * num5;
			float y = Mathf.Sin(num7) * num5;
			num7 += num4;
			originColor = ((i >= num6) ? GRAY_COLOR : ((Color32)color));
			zero2 = new Vector2(x, y);
			UIVertex uIVertex2 = GetUIVertex(originColor, zero2 + vector2, zero2, uvCenter, uvScale);
			vh.AddVert(uIVertex2);
			if (accurateRaycast)
			{
				_vertexList.Add(zero2 + vector2);
			}
		}
	}

	private void AddTriangle(VertexHelper vh)
	{
		int num = 1;
		for (int i = 0; i < segements; i++)
		{
			if (num == segements)
			{
				vh.AddTriangle(num, 0, 1);
			}
			else
			{
				vh.AddTriangle(num, 0, num + 1);
			}
			num++;
		}
	}

	private Color32 GetOriginColor()
	{
		Color32 color = (Color.white - GRAY_COLOR) * showPercent;
		return new Color32((byte)(GRAY_COLOR.r + color.r), (byte)(GRAY_COLOR.g + color.g), (byte)(GRAY_COLOR.b + color.b), byte.MaxValue);
	}

	private UIVertex GetUIVertex(Color32 col, Vector3 pos, Vector2 uvPos, Vector2 uvCenter, Vector2 uvScale)
	{
		UIVertex result = default(UIVertex);
		result.color = col;
		result.position = pos;
		result.uv0 = new Vector2(uvPos.x * uvScale.x + uvCenter.x, uvPos.y * uvScale.y + uvCenter.y);
		return result;
	}

	public override bool IsRaycastLocationValid(Vector2 screenPoint, Camera eventCamera)
	{
		if (accurateRaycast)
		{
			Vector2 localPoint = Vector2.zero;
			RectTransformUtility.ScreenPointToLocalPointInRectangle(base.rectTransform, screenPoint, eventCamera, out localPoint);
			if (GetCrossPointNum(localPoint, _vertexList) % 2 != 1)
			{
				return false;
			}
			return true;
		}
		return base.IsRaycastLocationValid(screenPoint, eventCamera);
	}

	private int GetCrossPointNum(Vector2 clickPos, List<Vector3> _vertexList)
	{
		int num = 0;
		Vector3 zero = Vector3.zero;
		Vector3 zero2 = Vector3.zero;
		int count = _vertexList.Count;
		for (int i = 0; i < count; i++)
		{
			zero = _vertexList[i];
			zero2 = _vertexList[(i + 1) % count];
			if (IsYInRang(clickPos, zero, zero2))
			{
				float x = GetX(zero, zero2, clickPos.y);
				if (clickPos.x < x)
				{
					num++;
				}
			}
		}
		return num;
	}

	private bool IsYInRang(Vector2 clickPos, Vector3 vert1, Vector3 vert2)
	{
		if (vert1.y > vert2.y)
		{
			if (clickPos.y < vert1.y)
			{
				return clickPos.y > vert2.y;
			}
			return false;
		}
		if (clickPos.y > vert1.y)
		{
			return clickPos.y < vert2.y;
		}
		return false;
	}

	private float GetX(Vector3 vert1, Vector3 vert2, float y)
	{
		return (vert1.x - vert2.x) / (vert1.y - vert2.y) / (y - vert2.y) + vert2.x;
	}
}
[AddComponentMenu("UI/Effects/Gradient")]
public class jianbian : BaseMeshEffect
{
	public enum Type
	{
		Vertical,
		Horizontal
	}

	public Type GradientType;

	[Range(-1f, 1f)]
	public float Offset;

	public Gradient gradient;

	private List<UIVertex> vertexList = new List<UIVertex>();

	public override void ModifyMesh(VertexHelper helper)
	{
		if (!IsActive() || helper.currentVertCount == 0)
		{
			return;
		}
		vertexList.Clear();
		helper.GetUIVertexStream(vertexList);
		int count = vertexList.Count;
		switch (GradientType)
		{
		case Type.Vertical:
		{
			float num6 = vertexList[0].position.y;
			float num7 = vertexList[0].position.y;
			float num8 = 0f;
			for (int num9 = count - 1; num9 >= 1; num9--)
			{
				num8 = vertexList[num9].position.y;
				if (num8 > num7)
				{
					num7 = num8;
				}
				else if (num8 < num6)
				{
					num6 = num8;
				}
			}
			float num10 = 1f / (num7 - num6);
			UIVertex vertex2 = default(UIVertex);
			for (int j = 0; j < helper.currentVertCount; j++)
			{
				helper.PopulateUIVertex(ref vertex2, j);
				vertex2.color = gradient.Evaluate((vertex2.position.y - num6) * num10 - Offset);
				helper.SetUIVertex(vertex2, j);
			}
			break;
		}
		case Type.Horizontal:
		{
			float num = vertexList[0].position.x;
			float num2 = vertexList[0].position.x;
			float num3 = 0f;
			for (int num4 = count - 1; num4 >= 1; num4--)
			{
				num3 = vertexList[num4].position.x;
				if (num3 > num2)
				{
					num2 = num3;
				}
				else if (num3 < num)
				{
					num = num3;
				}
			}
			float num5 = 1f / (num2 - num);
			UIVertex vertex = default(UIVertex);
			for (int i = 0; i < helper.currentVertCount; i++)
			{
				helper.PopulateUIVertex(ref vertex, i);
				vertex.color = gradient.Evaluate((vertex.position.x - num) * num5 - Offset);
				helper.SetUIVertex(vertex, i);
			}
			break;
		}
		}
	}
}
public class C_SLoadingCtrl : MonoBehaviour
{
	public static C_SLoadingCtrl Inst;

	public GameObject m_loadingPanel;

	public Text m_downloadProgress;

	private void Awake()
	{
		Inst = this;
		m_loadingPanel.SetActive(value: false);
	}

	private void Start()
	{
	}

	public void J_ShowLoadingPanel()
	{
		m_loadingPanel.SetActive(value: true);
		m_downloadProgress.text = null;
	}

	public void J_SetProgress(float fprogress)
	{
		m_downloadProgress.text = (fprogress * 100f).ToString("f2") + "%";
	}

	public void J_HideLoadingPanel()
	{
		m_loadingPanel.SetActive(value: false);
	}
}
public class dontdestory : MonoBehaviour
{
	private void Awake()
	{
		UnityEngine.Object.DontDestroyOnLoad(this);
	}

	private void Update()
	{
	}
}
public class MainPlayController : MonoBehaviour
{
	public static MainPlayController Inst;

	public AudioSource m_audioPanBai;

	public AudioSource m_audioBGMusic;

	[Header("UI")]
	public GameObject objCanvaMenu;

	public GameObject panelMainMuenu;

	public GameObject panelThemeSelect;

	public GameObject panelThemeContentsSelect;

	public GameObject panelContentChange;

	public GameObject Pico;

	public static bool hasStartPlayOneTheme;

	public int iCurPlayedThemeID;

	private bool bcanChangeAaigin_panbai = true;

	private bool bcanChangeAaigin_GMusic = true;

	private bool bcanChangeAaigin_scene = true;

	private string preloadedScenename;

	private float fdoubleclickTimer;

	private void Awake()
	{
		Inst = this;
		UnityEngine.Object.DontDestroyOnLoad(this);
		objCanvaMenu.SetActive(value: true);
		panelMainMuenu.SetActive(value: false);
		panelThemeSelect.SetActive(value: true);
		panelThemeContentsSelect.SetActive(value: false);
		panelContentChange.SetActive(value: false);
	}

	public void J_SwitchPanBai(string panbaiFile)
	{
		hasStartPlayOneTheme = true;
		if (!bcanChangeAaigin_panbai)
		{
			return;
		}
		bcanChangeAaigin_panbai = false;
		m_audioPanBai.clip = null;
		motion_SourcesManager.TryGetAudio(panbaiFile, delegate(object result)
		{
			bcanChangeAaigin_panbai = true;
			m_audioPanBai.clip = (AudioClip)result;
			if (!string.IsNullOrEmpty(preloadedScenename))
			{
				m_audioPanBai.Play();
			}
		});
	}

	public void J_SwitchBGMusic(string bgmusicFile)
	{
		if (!bcanChangeAaigin_GMusic)
		{
			return;
		}
		bcanChangeAaigin_GMusic = false;
		m_audioBGMusic.Stop();
		m_audioBGMusic.clip = null;
		if (bgmusicFile == "")
		{
			bcanChangeAaigin_GMusic = true;
			return;
		}
		motion_SourcesManager.TryGetAudio(bgmusicFile, delegate(object result)
		{
			bcanChangeAaigin_GMusic = true;
			m_audioBGMusic.clip = (AudioClip)result;
			if (!string.IsNullOrEmpty(preloadedScenename))
			{
				m_audioBGMusic.Play();
			}
		});
	}

	public void J_SwitchScene(string sceneFile, string sceneName)
	{
		if (!bcanChangeAaigin_scene)
		{
			return;
		}
		C_SLoadingCtrl.Inst.J_ShowLoadingPanel();
		bcanChangeAaigin_scene = false;
		preloadedScenename = null;
		motion_SourcesManager.TryGetABasset(sceneFile, delegate
		{
			C_SLoadingCtrl.Inst.J_HideLoadingPanel();
			bcanChangeAaigin_scene = true;
			string.IsNullOrEmpty(preloadedScenename);
			if (m_audioPanBai.clip != null)
			{
				m_audioPanBai.Play();
			}
			if (m_audioBGMusic.clip != null)
			{
				m_audioBGMusic.Play();
			}
			preloadedScenename = sceneName;
			SceneManager.LoadScene(sceneName, LoadSceneMode.Single);
			if (sceneName.Contains("蝴蝶谷"))
			{
				base.transform.position = new Vector3(330.348f, 15.271f, 377.5037f);
			}
			else if (sceneName.Contains("古建-湖心"))
			{
				base.transform.position = new Vector3(375.88f, 17.116f, 336.2f);
			}
			else if (sceneName.Contains("海边小屋"))
			{
				base.transform.position = new Vector3(1687.453f, 93f, 641.7972f);
			}
			else
			{
				base.transform.position = Vector3.zero;
			}
		}, sceneName);
	}

	public void J_QuitAPP()
	{
		ClickQuit();
	}

	private void Update()
	{
		if (fdoubleclickTimer > 0f)
		{
			fdoubleclickTimer -= Time.deltaTime;
		}
		if (Controller.UPvr_GetKeyDown(Pvr_ControllerManager.controllerlink.mainHandID, Pvr_KeyCode.APP) || Input.GetKeyDown(KeyCode.Escape))
		{
			onMenuKeyDown();
		}
	}

	private void onMenuKeyDown()
	{
		if (fdoubleclickTimer > 0f)
		{
			ClickQuit();
		}
		else
		{
			fdoubleclickTimer = 0.3f;
		}
		if (!objCanvaMenu.activeInHierarchy)
		{
			objCanvaMenu.SetActive(value: true);
			panelMainMuenu.SetActive(value: true);
			objCanvaMenu.transform.rotation = Quaternion.Euler(0f, Camera.main.transform.eulerAngles.y, 0f);
		}
		else if (panelThemeContentsSelect.activeInHierarchy)
		{
			panelThemeContentsSelect.SetActive(value: false);
			panelThemeSelect.SetActive(value: true);
		}
		else if (panelContentChange.activeInHierarchy)
		{
			panelContentChange.SetActive(value: false);
			panelMainMuenu.SetActive(value: true);
		}
		else if (hasStartPlayOneTheme)
		{
			if (panelThemeSelect.activeInHierarchy)
			{
				panelThemeSelect.SetActive(value: false);
				panelMainMuenu.SetActive(value: true);
			}
			else if (panelMainMuenu.activeInHierarchy)
			{
				panelMainMuenu.SetActive(value: false);
				objCanvaMenu.SetActive(value: false);
			}
		}
	}

	public void J_CloseAllUI()
	{
		objCanvaMenu.SetActive(value: false);
		panelMainMuenu.SetActive(value: false);
		panelThemeSelect.SetActive(value: false);
		panelThemeContentsSelect.SetActive(value: false);
		panelContentChange.SetActive(value: false);
	}

	public void ClickQuit()
	{
		ScenesHelper.LoadScene(ScenesHelper.WeiAiXinCenterScene);
		UnityEngine.Object.Destroy(base.gameObject);
	}
}
public static class motion_SourcesManager
{
	private static string m_FileSourceFolder_Textures;

	private static string m_FileSourceFolder_Audios;

	private static string m_FileSourceFolder_ABassets;

	private static Dictionary<int, Texture> m_listTextrues;

	private static Dictionary<int, AudioClip> m_listAudios;

	private static Dictionary<int, AssetBundle> m_listABassets;

	private static Dictionary<int, List<Action<object>>> _listLoadingQueue;

	static motion_SourcesManager()
	{
		m_listTextrues = new Dictionary<int, Texture>();
		m_listAudios = new Dictionary<int, AudioClip>();
		m_listABassets = new Dictionary<int, AssetBundle>();
		_listLoadingQueue = new Dictionary<int, List<Action<object>>>();
		UnityEngine.Debug.Log("--source manager init");
		m_FileSourceFolder_Textures = Application.persistentDataPath + "/TempFiles/Textures/";
		m_FileSourceFolder_Audios = Application.persistentDataPath + "/TempFiles/Audios/";
		m_FileSourceFolder_ABassets = Application.persistentDataPath + "/TempFiles/ABassets/";
		if (!Directory.Exists(m_FileSourceFolder_Textures))
		{
			Directory.CreateDirectory(m_FileSourceFolder_Textures);
		}
		if (!Directory.Exists(m_FileSourceFolder_Audios))
		{
			Directory.CreateDirectory(m_FileSourceFolder_Audios);
		}
		if (!Directory.Exists(m_FileSourceFolder_ABassets))
		{
			Directory.CreateDirectory(m_FileSourceFolder_ABassets);
		}
	}

	public static void TryGetTexture(string filename, Action<object> Callback)
	{
		if (Callback == null)
		{
			return;
		}
		int hashCode = filename.GetHashCode();
		string text = m_FileSourceFolder_Textures + hashCode;
		if (m_listTextrues.ContainsKey(hashCode))
		{
			Callback?.Invoke(m_listTextrues[hashCode]);
		}
		else if (File.Exists(text))
		{
			if (Callback != null)
			{
				MainPlayController.Inst.StartCoroutine(yieldTryLoadTexture(hashCode, "file://" + text, Callback));
			}
		}
		else
		{
			MainPlayController.Inst.StartCoroutine(yieldTryLoadTexture(hashCode, filename, Callback, updateFile: true, text));
		}
	}

	public static void TryGetAudio(string filename, Action<object> Callback)
	{
		if (Callback == null)
		{
			return;
		}
		int hashCode = filename.GetHashCode();
		string text = m_FileSourceFolder_Audios + hashCode;
		if (m_listAudios.ContainsKey(hashCode))
		{
			Callback?.Invoke(m_listAudios[hashCode]);
		}
		else if (File.Exists(text))
		{
			if (Callback != null)
			{
				MainPlayController.Inst.StartCoroutine(yieldLoadUrl_Audio(hashCode, "file://" + text, Callback));
			}
		}
		else
		{
			MainPlayController.Inst.StartCoroutine(yieldLoadUrl_Audio(hashCode, filename, Callback, updateFile: true, text));
		}
	}

	public static void TryGetABasset(string filename, Action<object> Callback, string scenename = null)
	{
		if (Callback == null)
		{
			return;
		}
		string text = ((Application.platform != RuntimePlatform.Android) ? (Application.streamingAssetsPath + "/StandaloneWindows/" + scenename) : (Application.streamingAssetsPath + "/Android/" + scenename));
		UnityEngine.Debug.Log(text);
		int hashCode = scenename.GetHashCode();
		if (m_listABassets.ContainsKey(hashCode))
		{
			Callback?.Invoke(m_listABassets[hashCode]);
			return;
		}
		if (File.Exists(text))
		{
			UnityEngine.Debug.Log("-local");
			if (Callback != null)
			{
				MainPlayController.Inst.StartCoroutine(yieldTryLoadABasset(hashCode, "file://" + text, Callback));
			}
			return;
		}
		int hashCode2 = filename.GetHashCode();
		string text2 = m_FileSourceFolder_ABassets + hashCode2;
		if (m_listABassets.ContainsKey(hashCode2))
		{
			Callback?.Invoke(m_listABassets[hashCode2]);
		}
		else if (File.Exists(text2))
		{
			if (Callback != null)
			{
				MainPlayController.Inst.StartCoroutine(yieldTryLoadABasset(hashCode2, "file://" + text2, Callback));
			}
		}
		else
		{
			MainPlayController.Inst.StartCoroutine(yieldTryLoadABasset(hashCode2, filename, Callback, updateFile: true, text2));
		}
	}

	private static IEnumerator yieldTryLoadTexture(int hashcode, string path, Action<object> action, bool updateFile = false, string localFilePath = null)
	{
		if (_listLoadingQueue.ContainsKey(hashcode))
		{
			if (action != null)
			{
				_listLoadingQueue[hashcode].Add(action);
			}
			yield break;
		}
		if (action != null)
		{
			List<Action<object>> list = new List<Action<object>>();
			list.Add(action);
			_listLoadingQueue.Add(hashcode, list);
		}
		using UnityWebRequest webRequest = UnityWebRequest.Get(path);
		using DownloadHandlerTexture texDownloader = new DownloadHandlerTexture(readable: true);
		webRequest.downloadHandler = texDownloader;
		yield return webRequest.SendWebRequest();
		if (!string.IsNullOrEmpty(webRequest.error))
		{
			yield break;
		}
		Texture texture = texDownloader.texture;
		if (!m_listTextrues.ContainsKey(hashcode))
		{
			m_listTextrues.Add(hashcode, texture);
		}
		if (updateFile)
		{
			File.WriteAllBytes(localFilePath, texDownloader.data);
		}
		if (!_listLoadingQueue.ContainsKey(hashcode))
		{
			yield break;
		}
		foreach (Action<object> item in _listLoadingQueue[hashcode])
		{
			item(texture);
		}
		_listLoadingQueue.Remove(hashcode);
	}

	private static IEnumerator yieldLoadUrl_Audio(int hashcode, string path, Action<object> action, bool updateFile = false, string localFilePath = null)
	{
		if (_listLoadingQueue.ContainsKey(hashcode))
		{
			if (action != null)
			{
				_listLoadingQueue[hashcode].Add(action);
			}
			yield break;
		}
		UnityEngine.Debug.Log(path);
		if (action != null)
		{
			List<Action<object>> list = new List<Action<object>>();
			list.Add(action);
			_listLoadingQueue.Add(hashcode, list);
		}
		using UnityWebRequest webRequest = UnityWebRequestMultimedia.GetAudioClip(path, AudioType.MPEG);
		yield return webRequest.SendWebRequest();
		if (!string.IsNullOrEmpty(webRequest.error))
		{
			yield break;
		}
		AudioClip content = DownloadHandlerAudioClip.GetContent(webRequest);
		if (!m_listAudios.ContainsKey(hashcode))
		{
			m_listAudios.Add(hashcode, content);
		}
		if (updateFile)
		{
			File.WriteAllBytes(localFilePath, webRequest.downloadHandler.data);
		}
		if (!_listLoadingQueue.ContainsKey(hashcode))
		{
			yield break;
		}
		foreach (Action<object> item in _listLoadingQueue[hashcode])
		{
			item(content);
		}
		_listLoadingQueue.Remove(hashcode);
	}

	private static IEnumerator yieldTryLoadABasset(int hashcode, string path, Action<object> action, bool updateFile = false, string localFilePath = null)
	{
		if (_listLoadingQueue.ContainsKey(hashcode))
		{
			if (action != null)
			{
				_listLoadingQueue[hashcode].Add(action);
			}
			yield break;
		}
		UnityEngine.Debug.Log(path);
		if (action != null)
		{
			List<Action<object>> list = new List<Action<object>>();
			list.Add(action);
			_listLoadingQueue.Add(hashcode, list);
		}
		using UnityWebRequest webRequest = UnityWebRequest.Get(path);
		webRequest.SendWebRequest();
		while (!webRequest.isDone)
		{
			if (action != null)
			{
				UnityEngine.Debug.Log(webRequest.downloadProgress);
				if ((bool)C_SLoadingCtrl.Inst)
				{
					C_SLoadingCtrl.Inst.J_SetProgress(webRequest.downloadProgress);
				}
			}
			yield return new WaitForFixedUpdate();
		}
		if (string.IsNullOrEmpty(webRequest.error))
		{
			UnityEngine.Debug.Log(1);
			AssetBundle assetBundle = AssetBundle.LoadFromMemory(webRequest.downloadHandler.data);
			string[] allAssetNames = assetBundle.GetAllAssetNames();
			for (int i = 0; i < allAssetNames.Length; i++)
			{
				UnityEngine.Debug.Log(allAssetNames[i]);
			}
			if (!m_listABassets.ContainsKey(hashcode))
			{
				m_listABassets.Add(hashcode, assetBundle);
			}
			if (updateFile)
			{
				File.WriteAllBytes(localFilePath, webRequest.downloadHandler.data);
			}
			if (!_listLoadingQueue.ContainsKey(hashcode))
			{
				yield break;
			}
			foreach (Action<object> item in _listLoadingQueue[hashcode])
			{
				UnityEngine.Debug.Log(3);
				item(assetBundle);
			}
			_listLoadingQueue.Remove(hashcode);
			yield break;
		}
		UnityEngine.Debug.LogError(webRequest.error);
	}

	private static IEnumerator LoadAsset(string path, string id, Action<AssetBundle> action, Action<byte[]> saveAction = null)
	{
		UnityWebRequest webRequest = UnityWebRequest.Get(path);
		yield return webRequest.SendWebRequest();
		if (!webRequest.isNetworkError)
		{
			AssetBundle obj = AssetBundle.LoadFromMemory(webRequest.downloadHandler.data);
			action?.Invoke(obj);
			saveAction?.Invoke(webRequest.downloadHandler.data);
		}
		else
		{
			UnityEngine.Debug.LogError("资源下载失败: " + webRequest.error);
		}
	}

	public static void CreateFile(string foldrePath, string fileName, byte[] assetbundle)
	{
		CheckDirectory(foldrePath);
		File.WriteAllBytes(foldrePath + "/" + fileName, assetbundle);
	}

	private static void CheckDirectory(string path)
	{
		if (!Directory.Exists(path))
		{
			Directory.CreateDirectory(path);
		}
	}
}
public class item_BGMusicSelection : MonoBehaviour
{
	public Text m_txtTitle;

	public Text m_txtCategory;

	public Toggle m_toggleClick;
}
public class item_PanBaiSelecton : MonoBehaviour
{
	public Text m_txtTitle;

	public Text m_txtCategory;

	public Toggle m_toggleClick;
}
public class item_SceneSelection : MonoBehaviour
{
	public RawImage m_image;

	public Text m_txtTitle;

	public Text m_txtCategory;

	public Toggle m_toggleClick;
}
public class item_ThemePresetSelection : MonoBehaviour
{
	public Text m_txtPresetName;

	public Text m_txtPresetDescription;

	public Text m_txtPanBaiName;

	public Text m_txtMusicName;

	public RawImage m_rawSceneTexture;

	public Text m_txtSceneName;

	public Text m_txtSceneDescipttion;

	public Button m_btnClick;
}
public class item_ThemeSelection : MonoBehaviour
{
	public RawImage m_MoodImage;

	public Text m_txtTitle;

	public Button m_btnClick;
}
public class M_motion_Theme
{
	public class cdata
	{
		public int id;

		public string mood_name;

		public string mood_image;

		public string mood_description;

		public string res_url_pre;
	}

	public int code;

	public string msg;

	public List<cdata> data;
}
public class M_Theme_Contents
{
	public class cdata
	{
		public List<cScene> scene_list;

		public List<cmusic> music_list;

		public List<cspeak> speak_list;
	}

	public class cScene
	{
		public class cCategory
		{
			public int id;

			public string category_name;
		}

		public int id;

		public string scene_name;

		public string scene_images;

		public string scene_model_name;

		public string scene_model_url;

		public string main_name;

		public string scene_description;

		public int version;

		public List<cCategory> category_arr;

		public string res_url_pre;
	}

	public class cmusic
	{
		public class cCategory
		{
			public int id;

			public string category_name;
		}

		public int id;

		public string music_name;

		public string music_file_name;

		public string music_url;

		public string music_description;

		public int version;

		public List<cCategory> category_arr;

		public string res_url_pre;
	}

	public class cspeak
	{
		public class cCategory
		{
			public int id;

			public string category_name;
		}

		public int id;

		public string speak_title;

		public string speak_file_name;

		public string speak_url;

		public string speak_content;

		public string speak_description;

		public int version;

		public List<cCategory> category_arr;

		public string res_url_pre;
	}

	public int code;

	public string msg;

	public cdata data;
}
public class M_ThemePreset
{
	public class cdata
	{
		public int id;

		public string theme_name;

		public string theme_description;

		public int scene_id;

		public int music_id;

		public int speak_id;

		public int user_id;

		public cScene scene;

		public cmusic music;

		public cspeak speak;
	}

	public class cScene
	{
		public int id;

		public string scene_name;

		public string scene_images;

		public string scene_model_name;

		public string scene_model_url;

		public string main_name;

		public string scene_description;

		public int version;

		public string res_url_pre;
	}

	public class cmusic
	{
		public int id;

		public string music_name;

		public string music_file_name;

		public string music_url;

		public string music_description;

		public int version;

		public string res_url_pre;
	}

	public class cspeak
	{
		public int id;

		public string speak_title;

		public string speak_file_name;

		public string speak_url;

		public string speak_content;

		public string speak_description;

		public int version;

		public string res_url_pre;
	}

	public int code;

	public string msg;

	public List<cdata> data;
}
public class motion_NetworkManager : MonoBehaviour
{
	public static string baseUrl = "https://crci.guavavr.com/api/mood";

	public static string api_moodThemeList => baseUrl + "/index";

	public static string api_moodsysList => baseUrl + "/sys";

	public static string api_moodContentsList => baseUrl + "/res";
}
public class V_ContentChangeCtrl : MonoBehaviour
{
	[Header("旁白")]
	public Transform m_trancContainer_PanBai;

	private ToggleGroup togglegourp_panbai;

	public GameObject m_Template_PanBai;

	private List<GameObject> listSeletctions_PanBai = new List<GameObject>();

	[Header("场景")]
	public Transform m_trancContainer_Scene;

	private ToggleGroup togglegourp_Scene;

	public GameObject m_Template_Scene;

	private List<GameObject> listSeletctions_Scene = new List<GameObject>();

	[Header("背景音乐")]
	public Transform m_trancContainer_Music;

	private ToggleGroup togglegourp_Music;

	public GameObject m_Template_Music;

	private List<GameObject> listSeletctions_Music = new List<GameObject>();

	public Text errorTip;

	private Coroutine coroutineApiDownload;

	private M_Theme_Contents.cspeak selectedPanBai;

	private M_Theme_Contents.cmusic selectedBGMusic;

	private M_Theme_Contents.cScene selectedScene;

	private M_Theme_Contents _data;

	private void Awake()
	{
		for (int num = m_trancContainer_PanBai.childCount - 1; num >= 0; num--)
		{
			if (!(m_trancContainer_PanBai.GetChild(num).gameObject == m_Template_PanBai.gameObject))
			{
				UnityEngine.Object.Destroy(m_trancContainer_PanBai.GetChild(num).gameObject);
			}
		}
		togglegourp_panbai = m_trancContainer_PanBai.GetComponent<ToggleGroup>();
		if (togglegourp_panbai == null)
		{
			togglegourp_panbai = m_trancContainer_PanBai.gameObject.AddComponent<ToggleGroup>();
		}
		m_Template_PanBai.gameObject.SetActive(value: false);
		for (int num2 = m_trancContainer_Scene.childCount - 1; num2 >= 0; num2--)
		{
			if (!(m_trancContainer_Scene.GetChild(num2).gameObject == m_Template_Scene.gameObject))
			{
				UnityEngine.Object.Destroy(m_trancContainer_Scene.GetChild(num2).gameObject);
			}
		}
		togglegourp_Scene = m_trancContainer_Scene.GetComponent<ToggleGroup>();
		if (togglegourp_Scene == null)
		{
			togglegourp_Scene = m_trancContainer_Scene.gameObject.AddComponent<ToggleGroup>();
		}
		m_Template_Scene.gameObject.SetActive(value: false);
		for (int num3 = m_trancContainer_Music.childCount - 1; num3 >= 0; num3--)
		{
			if (!(m_trancContainer_Music.GetChild(num3).gameObject == m_Template_Music.gameObject))
			{
				UnityEngine.Object.Destroy(m_trancContainer_Music.GetChild(num3).gameObject);
			}
		}
		togglegourp_Music = m_trancContainer_Music.GetComponent<ToggleGroup>();
		if (togglegourp_Music == null)
		{
			togglegourp_Music = m_trancContainer_Music.gameObject.AddComponent<ToggleGroup>();
		}
		m_Template_Music.gameObject.SetActive(value: false);
		if ((bool)errorTip)
		{
			errorTip.gameObject.SetActive(value: false);
		}
	}

	public void J_ShowPanel(int themeID)
	{
		_ClearPool();
		base.gameObject.SetActive(value: true);
		if (coroutineApiDownload != null)
		{
			StopCoroutine(coroutineApiDownload);
		}
		coroutineApiDownload = StartCoroutine(GetAPIdata(themeID));
	}

	private void OnEnable()
	{
		J_ShowPanel(MainPlayController.Inst.iCurPlayedThemeID);
	}

	private void OnDisable()
	{
		if (coroutineApiDownload != null)
		{
			StopCoroutine(coroutineApiDownload);
		}
		coroutineApiDownload = null;
		_ClearPool();
	}

	private IEnumerator GetAPIdata(int themeid)
	{
		if ((bool)errorTip)
		{
			errorTip.gameObject.SetActive(value: false);
			errorTip.text = null;
		}
		new WWWForm().AddField("id", themeid);
		using UnityWebRequest webRequest = UnityWebRequest.Get(UrlUtils.baseUrl_es + UrlUtils.moodContentsList + "?id=" + themeid);
		yield return webRequest.SendWebRequest();
		if (string.IsNullOrEmpty(webRequest.error))
		{
			M_Theme_Contents m_Theme_Contents = J_LitJson.JsonMapper.ToObject<M_Theme_Contents>(webRequest.downloadHandler.text);
			if (m_Theme_Contents.code == 1)
			{
				Init(m_Theme_Contents);
			}
			else if ((bool)errorTip)
			{
				errorTip.gameObject.SetActive(value: true);
				errorTip.text = $"errorcode:{m_Theme_Contents.code} msg:{m_Theme_Contents.msg}";
			}
		}
		else if ((bool)errorTip)
		{
			errorTip.gameObject.SetActive(value: true);
			errorTip.text = string.Format(webRequest.error);
		}
	}

	private void Init(M_Theme_Contents data)
	{
		UnityEngine.Debug.Log(222);
		selectedPanBai = null;
		selectedBGMusic = null;
		selectedScene = null;
		foreach (M_Theme_Contents.cspeak item in data.data.speak_list)
		{
			M_Theme_Contents.cspeak tempData2 = item;
			GameObject gameObject = UnityEngine.Object.Instantiate(m_Template_PanBai, m_trancContainer_PanBai);
			listSeletctions_PanBai.Add(gameObject);
			gameObject.transform.localPosition = Vector3.zero;
			gameObject.transform.localEulerAngles = Vector3.zero;
			gameObject.transform.localScale = Vector3.one;
			gameObject.gameObject.SetActive(value: true);
			item_PanBaiSelecton component = gameObject.GetComponent<item_PanBaiSelecton>();
			component.m_txtTitle.text = item.speak_title;
			motion_SourcesManager.TryGetAudio(item.res_url_pre + item.speak_url, null);
			component.m_txtCategory.text = null;
			for (int i = 0; i < item.category_arr.Count; i++)
			{
				component.m_txtCategory.text += item.category_arr[i].category_name;
				if (i < item.category_arr.Count - 1)
				{
					component.m_txtCategory.text += "、";
				}
			}
			component.m_toggleClick.group = togglegourp_panbai;
			component.m_toggleClick.onValueChanged.AddListener(delegate(bool isOn)
			{
				if (isOn)
				{
					selectedPanBai = tempData2;
					string panbaiFile = selectedPanBai.res_url_pre + selectedPanBai.speak_url;
					MainPlayController.Inst.J_SwitchPanBai(panbaiFile);
				}
			});
		}
		foreach (M_Theme_Contents.cScene item2 in data.data.scene_list)
		{
			M_Theme_Contents.cScene tempData = item2;
			GameObject gameObject2 = UnityEngine.Object.Instantiate(m_Template_Scene, m_trancContainer_Scene);
			listSeletctions_Scene.Add(gameObject2);
			gameObject2.transform.localPosition = Vector3.zero;
			gameObject2.transform.localEulerAngles = Vector3.zero;
			gameObject2.transform.localScale = Vector3.one;
			gameObject2.gameObject.SetActive(value: true);
			item_SceneSelection scriptCtrl = gameObject2.GetComponent<item_SceneSelection>();
			scriptCtrl.m_txtTitle.text = item2.scene_name;
			motion_SourcesManager.TryGetTexture(item2.res_url_pre + item2.scene_images, delegate(object texture)
			{
				if (!(this == null) && base.isActiveAndEnabled)
				{
					scriptCtrl.m_image.texture = (Texture)texture;
				}
			});
			motion_SourcesManager.TryGetABasset(item2.res_url_pre + item2.scene_model_url, null);
			scriptCtrl.m_txtCategory.text = null;
			for (int j = 0; j < item2.category_arr.Count; j++)
			{
				scriptCtrl.m_txtCategory.text += item2.category_arr[j].category_name;
				if (j < item2.category_arr.Count - 1)
				{
					scriptCtrl.m_txtCategory.text += "、";
				}
			}
			scriptCtrl.m_toggleClick.group = togglegourp_Scene;
			scriptCtrl.m_toggleClick.onValueChanged.AddListener(delegate(bool isOn)
			{
				if (isOn)
				{
					selectedScene = tempData;
					string sceneFile = selectedScene.res_url_pre + selectedScene.scene_model_url;
					string main_name = selectedScene.main_name;
					MainPlayController.Inst.J_SwitchScene(sceneFile, main_name);
				}
			});
		}
		data.data.music_list.Insert(0, new M_Theme_Contents.cmusic
		{
			music_name = "无",
			music_url = ""
		});
		_data = data;
		SetMusicList(data.data.music_list);
		InitMusicTag();
	}

	private void SetMusicList(List<M_Theme_Contents.cmusic> ds)
	{
		for (int i = 1; i < m_trancContainer_Music.transform.childCount; i++)
		{
			UnityEngine.Object.Destroy(m_trancContainer_Music.GetChild(i).gameObject);
		}
		foreach (M_Theme_Contents.cmusic d in ds)
		{
			M_Theme_Contents.cmusic tempData = d;
			GameObject gameObject = UnityEngine.Object.Instantiate(m_Template_Music, m_trancContainer_Music);
			listSeletctions_Music.Add(gameObject);
			gameObject.transform.localPosition = Vector3.zero;
			gameObject.transform.localEulerAngles = Vector3.zero;
			gameObject.transform.localScale = Vector3.one;
			gameObject.gameObject.SetActive(value: true);
			item_BGMusicSelection component = gameObject.GetComponent<item_BGMusicSelection>();
			component.m_txtTitle.text = d.music_name;
			if (d.music_name != "无")
			{
				motion_SourcesManager.TryGetAudio(d.res_url_pre + d.music_url, null);
				component.m_txtCategory.text = null;
				for (int j = 0; j < d.category_arr.Count; j++)
				{
					component.m_txtCategory.text += d.category_arr[j].category_name;
					if (j < d.category_arr.Count - 1)
					{
						component.m_txtCategory.text += "、";
					}
				}
			}
			else
			{
				component.m_txtCategory.text = "无背景乐";
			}
			component.m_toggleClick.group = togglegourp_Music;
			component.m_toggleClick.onValueChanged.AddListener(delegate(bool isOn)
			{
				if (isOn)
				{
					selectedBGMusic = tempData;
					if (selectedBGMusic.music_url != "")
					{
						string bgmusicFile = selectedBGMusic.res_url_pre + selectedBGMusic.music_url;
						MainPlayController.Inst.J_SwitchBGMusic(bgmusicFile);
					}
					else
					{
						MainPlayController.Inst.J_SwitchBGMusic("");
					}
				}
			});
		}
	}

	public void InitMusicTag()
	{
		GameObject gameObject = GameObject.Find("Container音乐Tag2");
		GameObject gameObject2 = GameObject.Find("Template背景音乐TagSlot2");
		gameObject2.SetActive(value: false);
		List<string> list = (from ca in _data.data.music_list
			where ca.category_arr != null && ca.category_arr.Count > 0
			select ca.category_arr.FirstOrDefault()?.category_name).Distinct().ToList();
		list.Insert(0, "全部音乐");
		foreach (string item in list)
		{
			if (item != null)
			{
				GameObject gameObject3 = UnityEngine.Object.Instantiate(gameObject2, gameObject.transform);
				gameObject3.transform.Find("TextTitle").GetComponent<Text>().text = item;
				setTogle(gameObject3.GetComponentInChildren<Toggle>(includeInactive: true), gameObject.GetComponent<ToggleGroup>(), item);
				gameObject3.SetActive(value: true);
			}
		}
	}

	private void setTogle(Toggle a, ToggleGroup b, string tag)
	{
		a.onValueChanged.AddListener(delegate(bool ba)
		{
			if (ba)
			{
				SetMusicList(_data.data.music_list.Where((M_Theme_Contents.cmusic ca) => tag == "全部音乐" || (ca.category_arr != null && ca.category_arr.Any((M_Theme_Contents.cmusic.cCategory ca2) => ca2.category_name == tag))).ToList());
			}
		});
		a.group = b;
	}

	private void _ClearPool()
	{
		for (int num = listSeletctions_PanBai.Count - 1; num >= 0; num--)
		{
			UnityEngine.Object.Destroy(listSeletctions_PanBai[num].gameObject);
		}
		listSeletctions_PanBai.Clear();
		for (int num2 = listSeletctions_Scene.Count - 1; num2 >= 0; num2--)
		{
			UnityEngine.Object.Destroy(listSeletctions_Scene[num2].gameObject);
		}
		listSeletctions_Scene.Clear();
		for (int num3 = listSeletctions_Music.Count - 1; num3 >= 0; num3--)
		{
			UnityEngine.Object.Destroy(listSeletctions_Music[num3].gameObject);
		}
		listSeletctions_Music.Clear();
	}
}
public class V_motion_Theme : MonoBehaviour
{
	public V_SelectedThemeCtrl m_SelectedThemeCtrl;

	public Transform m_trancContainer;

	public GameObject m_Template;

	public Text errorTip;

	private Coroutine coroutineApiDownload;

	private List<GameObject> listSeletctions = new List<GameObject>();

	private void Awake()
	{
		for (int num = m_trancContainer.childCount - 1; num >= 0; num--)
		{
			if (!(m_trancContainer.GetChild(num).gameObject == m_Template.gameObject))
			{
				UnityEngine.Object.Destroy(m_trancContainer.GetChild(num).gameObject);
			}
		}
		m_Template.gameObject.SetActive(value: false);
		if ((bool)errorTip)
		{
			errorTip.gameObject.SetActive(value: false);
		}
	}

	private void OnEnable()
	{
		_ClearPool();
		if (coroutineApiDownload != null)
		{
			StopCoroutine(coroutineApiDownload);
		}
		coroutineApiDownload = StartCoroutine(GetAPIdata());
	}

	private void OnDisable()
	{
		if (coroutineApiDownload != null)
		{
			StopCoroutine(coroutineApiDownload);
		}
		coroutineApiDownload = null;
		_ClearPool();
	}

	private IEnumerator GetAPIdata()
	{
		if ((bool)errorTip)
		{
			errorTip.gameObject.SetActive(value: false);
			errorTip.text = null;
		}
		using UnityWebRequest webRequest = UnityWebRequest.Get(UrlUtils.baseUrl_es + UrlUtils.moodThemeList);
		yield return webRequest.SendWebRequest();
		if (string.IsNullOrEmpty(webRequest.error))
		{
			M_motion_Theme m_motion_Theme = J_LitJson.JsonMapper.ToObject<M_motion_Theme>(webRequest.downloadHandler.text);
			if (m_motion_Theme.code == 1)
			{
				Init(m_motion_Theme);
			}
			else if ((bool)errorTip)
			{
				errorTip.gameObject.SetActive(value: true);
				errorTip.text = $"errorcode:{m_motion_Theme.code} msg:{m_motion_Theme.msg}";
			}
		}
		else if ((bool)errorTip)
		{
			errorTip.gameObject.SetActive(value: true);
			errorTip.text = string.Format(webRequest.error);
		}
	}

	private void Init(M_motion_Theme data)
	{
		foreach (M_motion_Theme.cdata datum in data.data)
		{
			M_motion_Theme.cdata themedata = datum;
			GameObject gameObject = UnityEngine.Object.Instantiate(m_Template, m_trancContainer);
			listSeletctions.Add(gameObject);
			gameObject.transform.localPosition = Vector3.zero;
			gameObject.transform.localEulerAngles = Vector3.zero;
			gameObject.transform.localScale = Vector3.one;
			gameObject.gameObject.SetActive(value: true);
			item_ThemeSelection scriptCtrl = gameObject.GetComponent<item_ThemeSelection>();
			scriptCtrl.m_txtTitle.text = datum.mood_name;
			motion_SourcesManager.TryGetTexture(datum.res_url_pre + datum.mood_image, delegate(object texture)
			{
				if (!(this == null) && base.isActiveAndEnabled)
				{
					scriptCtrl.m_MoodImage.texture = (Texture)texture;
				}
			});
			scriptCtrl.m_btnClick.onClick.AddListener(delegate
			{
				base.gameObject.SetActive(value: false);
				m_SelectedThemeCtrl.J_ShowThemeContents(themedata);
			});
		}
	}

	private void _ClearPool()
	{
		for (int num = listSeletctions.Count - 1; num >= 0; num--)
		{
			UnityEngine.Object.Destroy(listSeletctions[num].gameObject);
		}
		listSeletctions.Clear();
	}
}
public class V_SelectedThemeCtrl : MonoBehaviour
{
	[HideInInspector]
	public M_motion_Theme.cdata iCurSelectedTheme;

	public RawImage m_rawimage_theme;

	public Text m_txtThemeTitle;

	public Toggle m_toggleThemePreset;

	public Toggle m_toggleFreePlay;

	public Button m_btnBackToThemeSelections;

	public V_motion_Theme m_PanelMotion_ThemeSelections;

	public V_Theme_preset m_panelThemePreset;

	public V_Theme_FreePlay m_panelThemeFreeplay;

	private void Awake()
	{
		m_toggleThemePreset.onValueChanged.AddListener(delegate(bool isOn)
		{
			if (isOn)
			{
				m_panelThemePreset.J_ShowPanel(iCurSelectedTheme.id);
			}
			else
			{
				m_panelThemePreset.gameObject.SetActive(value: false);
			}
		});
		m_toggleFreePlay.onValueChanged.AddListener(delegate(bool isOn)
		{
			if (isOn)
			{
				m_panelThemeFreeplay.J_ShowPanel(iCurSelectedTheme.id);
			}
			else
			{
				m_panelThemeFreeplay.gameObject.SetActive(value: false);
			}
		});
		m_btnBackToThemeSelections.onClick.AddListener(delegate
		{
			base.gameObject.SetActive(value: false);
			m_PanelMotion_ThemeSelections.gameObject.SetActive(value: true);
		});
	}

	private void OnDisable()
	{
		m_toggleThemePreset.isOn = false;
		m_toggleFreePlay.isOn = false;
	}

	public void J_ShowThemeContents(M_motion_Theme.cdata themeData)
	{
		iCurSelectedTheme = themeData;
		base.gameObject.SetActive(value: true);
		m_toggleFreePlay.isOn = true;
		m_txtThemeTitle.text = iCurSelectedTheme.mood_name;
		motion_SourcesManager.TryGetTexture(iCurSelectedTheme.res_url_pre + iCurSelectedTheme.mood_image, delegate(object texture)
		{
			if (!(this == null) && base.isActiveAndEnabled)
			{
				m_rawimage_theme.texture = (Texture)texture;
			}
		});
	}
}
public class V_Theme_FreePlay : MonoBehaviour
{
	public Button m_btnStartPlay;

	[Header("旁白")]
	public Transform m_trancContainer_PanBai;

	private ToggleGroup togglegourp_panbai;

	public GameObject m_Template_PanBai;

	private List<GameObject> listSeletctions_PanBai = new List<GameObject>();

	[Header("场景")]
	public Transform m_trancContainer_Scene;

	private ToggleGroup togglegourp_Scene;

	public GameObject m_Template_Scene;

	private List<GameObject> listSeletctions_Scene = new List<GameObject>();

	[Header("背景音乐")]
	public Transform m_trancContainer_Music;

	private ToggleGroup togglegourp_Music;

	public GameObject m_Template_Music;

	private List<GameObject> listSeletctions_Music = new List<GameObject>();

	public Text errorTip;

	private Coroutine coroutineApiDownload;

	private int iCurSelectedThemeID;

	private M_Theme_Contents.cspeak selectedPanBai;

	private M_Theme_Contents.cmusic selectedBGMusic;

	private M_Theme_Contents.cScene selectedScene;

	private M_Theme_Contents _data;

	private GameObject Template背景音乐TagSlot;

	private void Awake()
	{
		for (int num = m_trancContainer_PanBai.childCount - 1; num >= 0; num--)
		{
			if (!(m_trancContainer_PanBai.GetChild(num).gameObject == m_Template_PanBai.gameObject))
			{
				UnityEngine.Object.Destroy(m_trancContainer_PanBai.GetChild(num).gameObject);
			}
		}
		togglegourp_panbai = m_trancContainer_PanBai.GetComponent<ToggleGroup>();
		if (togglegourp_panbai == null)
		{
			togglegourp_panbai = m_trancContainer_PanBai.gameObject.AddComponent<ToggleGroup>();
		}
		m_Template_PanBai.gameObject.SetActive(value: false);
		for (int num2 = m_trancContainer_Scene.childCount - 1; num2 >= 0; num2--)
		{
			if (!(m_trancContainer_Scene.GetChild(num2).gameObject == m_Template_Scene.gameObject))
			{
				UnityEngine.Object.Destroy(m_trancContainer_Scene.GetChild(num2).gameObject);
			}
		}
		togglegourp_Scene = m_trancContainer_Scene.GetComponent<ToggleGroup>();
		if (togglegourp_Scene == null)
		{
			togglegourp_Scene = m_trancContainer_Scene.gameObject.AddComponent<ToggleGroup>();
		}
		m_Template_Scene.gameObject.SetActive(value: false);
		for (int num3 = m_trancContainer_Music.childCount - 1; num3 >= 0; num3--)
		{
			if (!(m_trancContainer_Music.GetChild(num3).gameObject == m_Template_Music.gameObject))
			{
				UnityEngine.Object.Destroy(m_trancContainer_Music.GetChild(num3).gameObject);
			}
		}
		togglegourp_Music = m_trancContainer_Music.GetComponent<ToggleGroup>();
		if (togglegourp_Music == null)
		{
			togglegourp_Music = m_trancContainer_Music.gameObject.AddComponent<ToggleGroup>();
		}
		m_Template_Music.gameObject.SetActive(value: false);
		m_btnStartPlay.onClick.AddListener(ClickBtnStartPlay);
		if ((bool)errorTip)
		{
			errorTip.gameObject.SetActive(value: false);
		}
	}

	private void ClickBtnStartPlay()
	{
		string sceneFile = selectedScene.res_url_pre + selectedScene.scene_model_url;
		string main_name = selectedScene.main_name;
		string bgmusicFile = ((selectedBGMusic.music_url == "") ? "" : (selectedBGMusic.res_url_pre + selectedBGMusic.music_url));
		string panbaiFile = selectedPanBai.res_url_pre + selectedPanBai.speak_url;
		MainPlayController.Inst.J_SwitchPanBai(panbaiFile);
		MainPlayController.Inst.J_SwitchBGMusic(bgmusicFile);
		MainPlayController.Inst.J_SwitchScene(sceneFile, main_name);
		MainPlayController.Inst.J_CloseAllUI();
		MainPlayController.Inst.iCurPlayedThemeID = iCurSelectedThemeID;
	}

	public void J_ShowPanel(int themeID)
	{
		iCurSelectedThemeID = themeID;
		_ClearPool();
		base.gameObject.SetActive(value: true);
		if (coroutineApiDownload != null)
		{
			StopCoroutine(coroutineApiDownload);
		}
		coroutineApiDownload = StartCoroutine(GetAPIdata(themeID));
	}

	private void OnDisable()
	{
		if (coroutineApiDownload != null)
		{
			StopCoroutine(coroutineApiDownload);
		}
		coroutineApiDownload = null;
		_ClearPool();
	}

	private IEnumerator GetAPIdata(int themeid)
	{
		if ((bool)errorTip)
		{
			errorTip.gameObject.SetActive(value: false);
			errorTip.text = null;
		}
		new WWWForm().AddField("id", themeid);
		using UnityWebRequest webRequest = UnityWebRequest.Get(UrlUtils.baseUrl_es + UrlUtils.moodContentsList + "?id=" + themeid);
		yield return webRequest.SendWebRequest();
		if (string.IsNullOrEmpty(webRequest.error))
		{
			M_Theme_Contents m_Theme_Contents = J_LitJson.JsonMapper.ToObject<M_Theme_Contents>(webRequest.downloadHandler.text);
			if (m_Theme_Contents.code == 1)
			{
				Init(m_Theme_Contents);
			}
			else if ((bool)errorTip)
			{
				errorTip.gameObject.SetActive(value: true);
				errorTip.text = $"errorcode:{m_Theme_Contents.code} msg:{m_Theme_Contents.msg}";
			}
		}
		else if ((bool)errorTip)
		{
			errorTip.gameObject.SetActive(value: true);
			errorTip.text = string.Format(webRequest.error);
		}
	}

	private void Init(M_Theme_Contents data)
	{
		_data = data;
		selectedPanBai = null;
		selectedBGMusic = null;
		selectedScene = null;
		bool flag = true;
		foreach (M_Theme_Contents.cspeak item in data.data.speak_list)
		{
			M_Theme_Contents.cspeak tempData2 = item;
			GameObject gameObject = UnityEngine.Object.Instantiate(m_Template_PanBai, m_trancContainer_PanBai);
			listSeletctions_PanBai.Add(gameObject);
			gameObject.transform.localPosition = Vector3.zero;
			gameObject.transform.localEulerAngles = Vector3.zero;
			gameObject.transform.localScale = Vector3.one;
			gameObject.gameObject.SetActive(value: true);
			item_PanBaiSelecton component = gameObject.GetComponent<item_PanBaiSelecton>();
			component.m_txtTitle.text = item.speak_title;
			motion_SourcesManager.TryGetAudio(item.res_url_pre + item.speak_url, null);
			component.m_txtCategory.text = null;
			for (int i = 0; i < item.category_arr.Count; i++)
			{
				component.m_txtCategory.text += item.category_arr[i].category_name;
				if (i < item.category_arr.Count - 1)
				{
					component.m_txtCategory.text += "、";
				}
			}
			component.m_toggleClick.group = togglegourp_panbai;
			component.m_toggleClick.onValueChanged.AddListener(delegate(bool isOn)
			{
				if (isOn)
				{
					selectedPanBai = tempData2;
				}
			});
			if (flag)
			{
				flag = false;
				component.m_toggleClick.isOn = true;
			}
		}
		flag = true;
		foreach (M_Theme_Contents.cScene item2 in data.data.scene_list)
		{
			M_Theme_Contents.cScene tempData = item2;
			GameObject gameObject2 = UnityEngine.Object.Instantiate(m_Template_Scene, m_trancContainer_Scene);
			listSeletctions_Scene.Add(gameObject2);
			gameObject2.transform.localPosition = Vector3.zero;
			gameObject2.transform.localEulerAngles = Vector3.zero;
			gameObject2.transform.localScale = Vector3.one;
			gameObject2.gameObject.SetActive(value: true);
			item_SceneSelection scriptCtrl = gameObject2.GetComponent<item_SceneSelection>();
			scriptCtrl.m_txtTitle.text = item2.scene_name;
			motion_SourcesManager.TryGetTexture(item2.res_url_pre + item2.scene_images, delegate(object texture)
			{
				if (!(this == null) && base.isActiveAndEnabled)
				{
					scriptCtrl.m_image.texture = (Texture)texture;
				}
			});
			motion_SourcesManager.TryGetABasset(item2.res_url_pre + item2.scene_model_url, null);
			scriptCtrl.m_txtCategory.text = null;
			for (int j = 0; j < item2.category_arr.Count; j++)
			{
				scriptCtrl.m_txtCategory.text += item2.category_arr[j].category_name;
				if (j < item2.category_arr.Count - 1)
				{
					scriptCtrl.m_txtCategory.text += "、";
				}
			}
			scriptCtrl.m_toggleClick.group = togglegourp_Scene;
			scriptCtrl.m_toggleClick.onValueChanged.AddListener(delegate(bool isOn)
			{
				if (isOn)
				{
					selectedScene = tempData;
				}
			});
			if (flag)
			{
				flag = false;
				scriptCtrl.m_toggleClick.isOn = true;
			}
		}
		flag = true;
		data.data.music_list.Insert(0, new M_Theme_Contents.cmusic
		{
			music_name = "无",
			music_url = ""
		});
		SetMusicList(data.data.music_list);
		InitMusicTag();
	}

	private void SetMusicList(List<M_Theme_Contents.cmusic> ds)
	{
		for (int i = 1; i < m_trancContainer_Music.transform.childCount; i++)
		{
			UnityEngine.Object.Destroy(m_trancContainer_Music.GetChild(i).gameObject);
		}
		bool flag = true;
		foreach (M_Theme_Contents.cmusic d in ds)
		{
			M_Theme_Contents.cmusic tempData = d;
			GameObject gameObject = UnityEngine.Object.Instantiate(m_Template_Music, m_trancContainer_Music);
			listSeletctions_Music.Add(gameObject);
			gameObject.transform.localPosition = Vector3.zero;
			gameObject.transform.localEulerAngles = Vector3.zero;
			gameObject.transform.localScale = Vector3.one;
			gameObject.gameObject.SetActive(value: true);
			item_BGMusicSelection component = gameObject.GetComponent<item_BGMusicSelection>();
			component.m_txtTitle.text = d.music_name;
			if (d.music_name != "无")
			{
				motion_SourcesManager.TryGetAudio(d.res_url_pre + d.music_url, null);
				component.m_txtCategory.text = null;
				for (int j = 0; j < d.category_arr.Count; j++)
				{
					component.m_txtCategory.text += d.category_arr[j].category_name;
					if (j < d.category_arr.Count - 1)
					{
						component.m_txtCategory.text += "、";
					}
				}
			}
			else
			{
				component.m_txtCategory.text = "无背景乐";
			}
			component.m_toggleClick.group = togglegourp_Music;
			component.m_toggleClick.onValueChanged.AddListener(delegate(bool isOn)
			{
				if (isOn)
				{
					selectedBGMusic = tempData;
				}
			});
			if (flag)
			{
				flag = false;
				component.m_toggleClick.isOn = true;
			}
		}
	}

	public void InitMusicTag()
	{
		GameObject gameObject = GameObject.Find("Container音乐Tag");
		if (Template背景音乐TagSlot == null)
		{
			Template背景音乐TagSlot = GameObject.Find("Template背景音乐TagSlot");
			Template背景音乐TagSlot.SetActive(value: false);
		}
		List<string> list = (from ca in _data.data.music_list
			where ca.category_arr != null && ca.category_arr.Count > 0
			select ca.category_arr.FirstOrDefault()?.category_name).Distinct().ToList();
		list.Insert(0, "全部音乐");
		gameObject.transform.ClearChild(Template背景音乐TagSlot.transform);
		foreach (string item in list)
		{
			if (item != null)
			{
				GameObject gameObject2 = UnityEngine.Object.Instantiate(Template背景音乐TagSlot, gameObject.transform);
				gameObject2.transform.Find("TextTitle").GetComponent<Text>().text = item;
				setTogle(gameObject2.GetComponentInChildren<Toggle>(includeInactive: true), gameObject.GetComponent<ToggleGroup>(), item);
				gameObject2.SetActive(value: true);
			}
		}
	}

	private void setTogle(Toggle a, ToggleGroup b, string tag)
	{
		a.onValueChanged.AddListener(delegate(bool ba)
		{
			if (ba)
			{
				SetMusicList(_data.data.music_list.Where((M_Theme_Contents.cmusic ca) => tag == "全部音乐" || (ca.category_arr != null && ca.category_arr.Any((M_Theme_Contents.cmusic.cCategory ca2) => ca2.category_name == tag))).ToList());
			}
		});
		a.group = b;
	}

	private void _ClearPool()
	{
		for (int num = listSeletctions_PanBai.Count - 1; num >= 0; num--)
		{
			UnityEngine.Object.Destroy(listSeletctions_PanBai[num].gameObject);
		}
		listSeletctions_PanBai.Clear();
		for (int num2 = listSeletctions_Scene.Count - 1; num2 >= 0; num2--)
		{
			UnityEngine.Object.Destroy(listSeletctions_Scene[num2].gameObject);
		}
		listSeletctions_Scene.Clear();
		for (int num3 = listSeletctions_Music.Count - 1; num3 >= 0; num3--)
		{
			UnityEngine.Object.Destroy(listSeletctions_Music[num3].gameObject);
		}
		listSeletctions_Music.Clear();
	}
}
public class V_Theme_preset : MonoBehaviour
{
	[Header("旁白")]
	public Transform m_trancContainer_preset;

	public GameObject m_Template_slot;

	public Text errorTip;

	private List<GameObject> listSeletctions_presets = new List<GameObject>();

	private Coroutine coroutineApiDownload;

	private int iCurSelectedThemeID;

	private void Awake()
	{
		for (int num = m_trancContainer_preset.childCount - 1; num >= 0; num--)
		{
			if (!(m_trancContainer_preset.GetChild(num).gameObject == m_Template_slot.gameObject))
			{
				UnityEngine.Object.Destroy(m_trancContainer_preset.GetChild(num).gameObject);
			}
		}
		m_Template_slot.gameObject.SetActive(value: false);
	}

	private void OnDisable()
	{
		if (coroutineApiDownload != null)
		{
			StopCoroutine(coroutineApiDownload);
		}
		coroutineApiDownload = null;
		_ClearPool();
	}

	public void J_ShowPanel(int themeID)
	{
		iCurSelectedThemeID = themeID;
		_ClearPool();
		base.gameObject.SetActive(value: true);
		if (coroutineApiDownload != null)
		{
			StopCoroutine(coroutineApiDownload);
		}
		coroutineApiDownload = StartCoroutine(GetAPIdata(themeID));
	}

	private IEnumerator GetAPIdata(int themeid)
	{
		if ((bool)errorTip)
		{
			errorTip.gameObject.SetActive(value: false);
			errorTip.text = null;
		}
		new WWWForm().AddField("id", themeid);
		using UnityWebRequest webRequest = UnityWebRequest.Get(UrlUtils.baseUrl_es + UrlUtils.moodsysList + "?id=" + themeid);
		yield return webRequest.SendWebRequest();
		if (string.IsNullOrEmpty(webRequest.error))
		{
			M_ThemePreset m_ThemePreset = J_LitJson.JsonMapper.ToObject<M_ThemePreset>(webRequest.downloadHandler.text);
			if (m_ThemePreset.code == 1)
			{
				Init(m_ThemePreset);
			}
			else if ((bool)errorTip)
			{
				errorTip.gameObject.SetActive(value: true);
				errorTip.text = $"errorcode:{m_ThemePreset.code} msg:{m_ThemePreset.msg}";
			}
		}
		else if ((bool)errorTip)
		{
			errorTip.gameObject.SetActive(value: true);
			errorTip.text = string.Format(webRequest.error);
		}
	}

	private void Init(M_ThemePreset data)
	{
		foreach (M_ThemePreset.cdata datum in data.data)
		{
			GameObject gameObject = UnityEngine.Object.Instantiate(m_Template_slot, m_trancContainer_preset);
			listSeletctions_presets.Add(gameObject);
			gameObject.transform.localPosition = Vector3.zero;
			gameObject.transform.localEulerAngles = Vector3.zero;
			gameObject.transform.localScale = Vector3.one;
			gameObject.gameObject.SetActive(value: true);
			item_ThemePresetSelection scriptCtrl = gameObject.GetComponent<item_ThemePresetSelection>();
			scriptCtrl.m_txtPresetName.text = datum.theme_name;
			scriptCtrl.m_txtPresetDescription.text = datum.theme_description;
			scriptCtrl.m_txtPanBaiName.text = datum.speak.speak_title;
			scriptCtrl.m_txtMusicName.text = ((datum.music == null) ? "无音乐" : datum.music.music_name);
			scriptCtrl.m_txtSceneName.text = datum.scene.scene_name;
			scriptCtrl.m_txtSceneDescipttion.text = datum.scene.scene_description;
			motion_SourcesManager.TryGetTexture(datum.scene.res_url_pre + datum.scene.scene_images, delegate(object texture)
			{
				if (!(this == null) && base.isActiveAndEnabled)
				{
					scriptCtrl.m_rawSceneTexture.texture = (Texture)texture;
				}
			});
			string sceneFile = datum.scene.res_url_pre + datum.scene.scene_model_url;
			string sceneName = datum.scene.main_name;
			string musicfile = ((datum.music == null) ? "" : (datum.music.res_url_pre + datum.music.music_url));
			string panbaifile = datum.speak.res_url_pre + datum.speak.speak_url;
			motion_SourcesManager.TryGetAudio(panbaifile, null);
			motion_SourcesManager.TryGetAudio(musicfile, null);
			motion_SourcesManager.TryGetABasset(sceneFile, null);
			scriptCtrl.m_btnClick.onClick.AddListener(delegate
			{
				MainPlayController.Inst.J_SwitchPanBai(panbaifile);
				MainPlayController.Inst.J_SwitchBGMusic(musicfile);
				MainPlayController.Inst.J_SwitchScene(sceneFile, sceneName);
				MainPlayController.Inst.J_CloseAllUI();
				MainPlayController.Inst.iCurPlayedThemeID = iCurSelectedThemeID;
			});
			scriptCtrl.m_btnClick.gameObject.SetActive(value: false);
		}
	}

	private void _ClearPool()
	{
		for (int num = listSeletctions_presets.Count - 1; num >= 0; num--)
		{
			UnityEngine.Object.Destroy(listSeletctions_presets[num].gameObject);
		}
		listSeletctions_presets.Clear();
	}
}
public class setTextColor : MonoBehaviour
{
	public void SetColr(bool isSel)
	{
		GetComponent<Text>().color = (isSel ? Color.white : new Color(20f / 51f, 52f / 85f, 0.56078434f));
	}
}
public class qiehuanShouBing : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
	}
}
public class RayTelep : MonoBehaviour
{
	private new Vector3 tag;

	private Vector3 stp;

	private float mtime;

	private TeleportDoorCtrl lastHitDoor;

	private void Start()
	{
	}

	private void Update()
	{
		if (mtime != 0f)
		{
			float num = (Time.time - mtime) / ((Vector3.Distance(tag, stp) < 2f) ? 0.15f : 0.3f);
			if (num > 1f)
			{
				mtime = 0f;
			}
			else
			{
				WaveVRHead.Inst.transform.position = Vector3.Lerp(stp, tag, num);
			}
		}
		if (!Pvr.IsMainKeyUp() || !Physics.Raycast(Pvr.GetXunlianRay(), out var hitInfo))
		{
			return;
		}
		switch (hitInfo.collider.gameObject.layer)
		{
		case 1:
		{
			TeleportDoorCtrl component2 = hitInfo.collider.GetComponent<TeleportDoorCtrl>();
			if (component2 != null)
			{
				component2.OnPlayerTeleport();
				break;
			}
			Vector3 point = hitInfo.point;
			stp = WaveVRHead.Inst.transform.position;
			tag = new Vector3(point.x, WaveVRHead.Inst.transform.position.y, point.z);
			mtime = Time.time;
			break;
		}
		case 5:
		{
			EventTrigger component = hitInfo.collider.GetComponent<EventTrigger>();
			if ((bool)component)
			{
				component.OnPointerClick(null);
			}
			break;
		}
		}
	}

	private void rsetDoor()
	{
		if (lastHitDoor != null)
		{
			lastHitDoor.OnTeleportRayExit();
			lastHitDoor = null;
		}
	}
}
public class resetZonghe : MonoBehaviour
{
	private void Start()
	{
		LT_MissionHallManager.firstEnter = true;
		LT_MissionHallManager.hasAcceptTask = false;
		TaskManager.m_listTasks = new Dictionary<string, LT_Task.Task>();
		J_MapEnterance.m_targetMapName = null;
		J_MapEnterance.m_fromMapName = null;
		LT_BagManager.m_listBagGoods = new List<LT_BagManager.Item>();
		LT_BagManager.onGoodChange = null;
		TaskManager.onChange = null;
		TaskManager.onMissionComplete = null;
		TaskDataManager._inst = new TaskDataManager();
	}

	private void Update()
	{
	}
}
public class test : MonoBehaviour
{
	private IEnumerator Start()
	{
		GameObject obj = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("WaveVRHead2"));
		obj.transform.eulerAngles = new Vector3(0f, base.transform.eulerAngles.y, 0f);
		obj.transform.position = GameObject.Find("CamStayPos").transform.position;
		obj.GetComponent<WaveVRHead>().SceneManager_activeSceneChanged(default(Scene), SceneManager.GetActiveScene());
		yield return new WaitForSecondsRealtime(2f);
		LT_Task.Task task = TaskManager.Inst.InitTask("购买物品-便利店");
		TaskManager.Inst.AcceptTask(task);
		TaskManager.Inst.StartTask(TaskManager.Inst.FindNextTask());
		TaskManager.Inst.AcceptTask(TaskManager.Inst.InitTask("言语-便利店"));
		TaskManager.Inst.AcceptTask(TaskManager.Inst.InitTask("言语-药店"));
	}

	private void Update()
	{
	}
}
public class WaveVRHead : MonoBehaviour
{
	public delegate void ControllerModelLoaded(GameObject go);

	public static WaveVRHead Inst;

	public GameObject Original;

	public Transform headCam;

	public static bool isRes;

	public GameObject MenuUI;

	[Header("Hand Controller A")]
	public GameObject HandMenuUI;

	public GameObject CurveRayTeleportCtrl;

	public GameObject HandRayGrabber;

	public GameObject ControllerLoader_R;

	public GameObject ControllerLoader_L;

	public GameObject RightHandPosTracker;

	public GameObject RightHandRayBeam;

	public Text m_txtHeadUITip;

	[Header("LT_综合训练")]
	public GameObject[] LT_objects;

	[Header("单项训练")]
	public GameObject[] singleTrain_objects;

	public GameObject m_rightHand;

	private GameObject _rightHand;

	private GameObject _rightHandBeam;

	private GameObject _rightHandPointer;

	public GameObject m_leftHand;

	private GameObject _leftHand;

	private GameObject _leftHandBeam;

	private GameObject _leftHandPointer;

	public Camera Head;

	public Pvr_ControllerModuleInit lt;

	public Pvr_ControllerModuleInit rt;

	private bool bShowHandler = true;

	private LayerMask iHeadCamLayerMask = int.MaxValue;

	public Canvas wanTip;

	public Pvr_ControllerManager man;

	public bool isHideHand;

	public GameObject Grab;

	private DateTime lastMenuTime = DateTime.MinValue;

	public GameObject m_rightHandBeam => _rightHandBeam;

	public GameObject m_leftHandBeam => _leftHandBeam;

	private void Awake()
	{
		Load.InitVersion();
		if (Inst != null)
		{
			UnityEngine.Object.Destroy(Inst.gameObject);
			Inst = null;
		}
		if (Inst == null)
		{
			Inst = this;
			Original.SetActive(value: true);
			UnityEngine.Object.DontDestroyOnLoad(this);
			StartCoroutine(yieldSetLayer());
			SceneManager.activeSceneChanged += SceneManager_activeSceneChanged;
		}
		if ((bool)MenuUI)
		{
			MenuUI.SetActive(value: false);
		}
	}

	private void OnDestroy()
	{
		isRes = false;
	}

	private void Start()
	{
		if ((bool)MenuUI)
		{
			MenuUI.SetActive(value: false);
		}
	}

	public void ToMenu()
	{
		Inst.SetGrab(showOrHide: false);
		UnityEngine.Object.Destroy(Inst.gameObject);
		Inst = null;
		SceneManager.LoadScene(isRes ? "2_MainStart" : "综合训练-单项训练");
	}

	public void ShowWanTip(bool isAll)
	{
		if ((bool)wanTip)
		{
			StartCoroutine(_ShowWanTip(isAll));
		}
	}

	private IEnumerator _ShowWanTip(bool isAll)
	{
		wanTip.gameObject.SetActive(value: true);
		wanTip.transform.GetChild(0).GetChild(0).gameObject.SetActive(!isAll);
		wanTip.transform.GetChild(0).GetChild(1).gameObject.SetActive(isAll);
		yield return new WaitForSecondsRealtime(3f);
		if (!isAll)
		{
			wanTip.gameObject.SetActive(value: false);
		}
	}

	public void SceneManager_activeSceneChanged(Scene arg0, Scene a)
	{
		setScene(a);
		if (a.name == "LT_运动馆" && (bool)Inst)
		{
			Inst.ShowHand();
		}
		UnityEngine.Debug.LogError("SceneManager_activeSceneChanged:" + a.path);
		J_WaveVR_CurveRayTeleport.J_SetTeleportHandEnable(isEnable: true);
		GameObject[] rootGameObjects = a.GetRootGameObjects();
		for (int i = 0; i < rootGameObjects.Length; i++)
		{
			findCanvas(rootGameObjects[i].transform, 0);
		}
	}

	private void setScene(Scene a)
	{
	}

	private void initCanvas(Canvas a)
	{
		if ((a.transform.parent != null && (a.transform.parent.name.Contains("Door") || a.transform.parent.name.Contains("标牌"))) || a.name == "CanvasClock" || a.name.Contains("CanvasWords"))
		{
			return;
		}
		RectTransform component = a.GetComponent<RectTransform>();
		a.worldCamera = Inst.Head;
		if (component.sizeDelta.x < 200f)
		{
			RectTransform[] componentsInChildren = a.gameObject.GetComponentsInChildren<RectTransform>();
			a.GetComponent<RectTransform>().sizeDelta = new Vector2(componentsInChildren.Max((RectTransform ca) => ca.sizeDelta.x) + 200f, componentsInChildren.Max((RectTransform ca) => ca.sizeDelta.y) + 200f);
		}
		if (a.GetComponent<Pvr_UICanvas>() == null)
		{
			a.gameObject.AddComponent<Pvr_UICanvas>();
		}
	}

	private void findCanvas(Transform a, int depth, int maxDepth = 6)
	{
		if (depth >= maxDepth)
		{
			return;
		}
		Canvas component = a.gameObject.GetComponent<Canvas>();
		if ((bool)component)
		{
			initCanvas(component);
			return;
		}
		for (int i = 0; i < a.childCount; i++)
		{
			findCanvas(a.GetChild(i), depth + 1, maxDepth);
		}
	}

	public void HideHand(bool setVar = true)
	{
		if (setVar)
		{
			isHideHand = true;
		}
		lt.gameObject.SetActive(value: false);
		rt.gameObject.SetActive(value: false);
	}

	public void ShowHand(bool setVar = true)
	{
		if (setVar)
		{
			isHideHand = false;
		}
		lt.gameObject.SetActive(value: true);
		rt.gameObject.SetActive(value: true);
	}

	public void SetGrab(bool showOrHide)
	{
		Grab.SetActive(showOrHide);
		if (Grab.activeSelf)
		{
			Pvr_ControllerModuleInit.rayLen = 0.5f;
			rt.rayDefaultLength = 0.5f;
			Grab.GetComponent<WaveVR_HandRayGrabber>().m_maxRayDis = 0.5f;
		}
		else
		{
			Pvr_ControllerModuleInit.rayLen = 10f;
			rt.rayDefaultLength = 10f;
		}
	}

	private void onControllerLoaded(params object[] args)
	{
		StartCoroutine(yieldSetLayer());
	}

	private void onControllerUnloaded(params object[] args)
	{
	}

	private IEnumerator yieldSetLayer()
	{
		yield return new WaitForSeconds(1f);
		recurseChangeLayer(Original.gameObject.transform, LayerMask.NameToLayer("MenuUI"));
		yield return null;
	}

	public void SetHnadlerVisiable(bool isShow)
	{
		if (isShow)
		{
			ShowHand();
		}
		else
		{
			HideHand();
		}
	}

	private void setChildMeshsVisiable(GameObject objmodel, bool isVisiable)
	{
		if (objmodel != null)
		{
			MeshRenderer[] componentsInChildren = objmodel.GetComponentsInChildren<MeshRenderer>();
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				componentsInChildren[i].enabled = isVisiable;
			}
		}
	}

	public void SetMenuUILayerEnable(bool isEnable)
	{
		string text = "MenuUI";
		int num = LayerMask.NameToLayer(text);
		if (num == -1)
		{
			UnityEngine.Debug.LogError("Layer中不存在,请手动添加Layer:" + text);
		}
		else if (isEnable)
		{
			PhysicsRaycaster[] componentsInChildren = GetComponentsInChildren<PhysicsRaycaster>();
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				componentsInChildren[i].eventMask = 1 << num;
			}
			recurseChangeLayer(Original.gameObject.transform, num);
			SetHnadlerVisiable(isShow: true);
		}
		else
		{
			PhysicsRaycaster[] componentsInChildren = GetComponentsInChildren<PhysicsRaycaster>();
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				componentsInChildren[i].eventMask = iHeadCamLayerMask;
			}
		}
	}

	private void recurseChangeLayer(Transform trans, int iLayerI)
	{
		trans.gameObject.layer = iLayerI;
		foreach (Transform tran in trans)
		{
			recurseChangeLayer(tran, iLayerI);
		}
	}

	public void ForceSetHeadToTarget(Vector3 vPos)
	{
		Vector3 position = vPos - (headCam.transform.position - base.transform.position);
		base.transform.position = position;
	}

	public void ForceSetHeadToTarget(Vector3 vPos, Vector3 vAngle)
	{
		base.transform.eulerAngles = new Vector3(0f, vAngle.y - headCam.transform.localEulerAngles.y, 0f);
		ForceSetHeadToTarget(vPos);
	}

	public void SetHeadUITip(string strMsg)
	{
		if (!(m_txtHeadUITip == null))
		{
			m_txtHeadUITip.text = strMsg;
			m_txtHeadUITip.color = Color.green;
			m_txtHeadUITip.transform.DOScale(Vector3.one * 1.5f, 1f).OnComplete(delegate
			{
				m_txtHeadUITip.transform.DOScale(Vector3.one, 0.5f);
				m_txtHeadUITip.color = Color.white;
			});
		}
	}

	private void Update()
	{
		if (Controller.UPvr_GetKeyDown(Pvr_ControllerManager.controllerlink.mainHandID, Pvr_KeyCode.X) || Controller.UPvr_GetKeyDown(Pvr_ControllerManager.controllerlink.mainHandID, Pvr_KeyCode.A) || Input.GetKeyUp(KeyCode.A) || Input.GetKeyDown(KeyCode.X))
		{
			if (rt.gameObject.activeSelf)
			{
				HideHand();
			}
			else
			{
				ShowHand();
			}
		}
		if (SceneManager.GetActiveScene().name.Contains("综合训练-"))
		{
			return;
		}
		if ((bool)MenuUI && MenuUI.activeSelf && (DateTime.Now - lastMenuTime).TotalSeconds > 1.5)
		{
			MenuUI.SetActive(value: false);
		}
		if (Pvr.IsAppUp() && (bool)MenuUI)
		{
			if (MenuUI.activeSelf)
			{
				ToMenu();
				MenuUI.SetActive(value: false);
			}
			else
			{
				lastMenuTime = DateTime.Now;
				MenuUI.SetActive(!MenuUI.activeSelf);
			}
		}
	}

	public void J_OnHandMenuChange(bool isOn)
	{
		if (isOn)
		{
			CurveRayTeleportCtrl.SetActive(value: false);
			HandRayGrabber.SetActive(value: false);
			SetHandControllerRayEnable(isEnable: false);
		}
		else
		{
			CurveRayTeleportCtrl.SetActive(value: true);
			HandRayGrabber.SetActive(value: true);
			SetHandControllerRayEnable(isEnable: true);
		}
	}

	private void SetHandControllerRayEnable(bool isEnable)
	{
		if (_rightHandBeam != null)
		{
			_rightHandBeam.SetActive(isEnable);
		}
		if (_rightHandPointer != null)
		{
			_rightHandPointer.SetActive(isEnable);
		}
		if (_leftHandBeam != null)
		{
			_leftHandBeam.SetActive(isEnable);
		}
		if (_leftHandPointer != null)
		{
			_leftHandPointer.SetActive(isEnable);
		}
	}
}
public class WaveVRHeadReset : MonoBehaviour
{
	private bool isFind;

	private void Awake()
	{
		J_ResetPos();
	}

	public void J_ResetPos()
	{
		if ("水果店-言语-说水果名称,花店-言语-说花名,教室-复读,便利店-言语-物以类聚,生鲜超市-言语-原料推理,家具店-家具百科".Contains(SceneManager.GetActiveScene().name) && (WaveVRHead.Inst == null || WaveVRHead.Inst.gameObject == null))
		{
			UnityEngine.Object.Instantiate(Resources.Load<GameObject>("WaveVRHead"));
			WaveVRHead.isRes = true;
		}
		WaveVRHead inst = WaveVRHead.Inst;
		if (inst != null)
		{
			inst.ForceSetHeadToTarget(base.transform.position, base.transform.eulerAngles);
		}
	}

	private IEnumerator stFind()
	{
		yield return new WaitForSecondsRealtime(0.5f);
		GameObject[] rootGameObjects = SceneManager.GetActiveScene().GetRootGameObjects();
		for (int i = 0; i < rootGameObjects.Length; i++)
		{
			if (isFind)
			{
				break;
			}
			findAliyun(rootGameObjects[i].transform, 0);
		}
	}

	private void findAliyun(Transform a, int depth, int maxDepth = 6)
	{
		if (depth >= maxDepth)
		{
			return;
		}
		AudioRecWordsCtrl component = a.gameObject.GetComponent<AudioRecWordsCtrl>();
		if ((bool)component)
		{
			isFind = true;
			component.gameObject.SetActive(value: true);
			return;
		}
		for (int i = 0; i < a.childCount; i++)
		{
			findAliyun(a.GetChild(i), depth + 1, maxDepth);
		}
	}
}
public class Zonghe : MonoBehaviour
{
	public RayTelep tele;

	public GameObject menu;

	private void Start()
	{
	}

	private void Update()
	{
		if (Pvr.IsAppUp())
		{
			menu.SetActive(!menu.activeSelf);
			menu.SetOtherUICanvaState();
			if (menu.activeSelf)
			{
				WaveVRHead.Inst.ShowHand(setVar: false);
			}
			else if (WaveVRHead.Inst.isHideHand)
			{
				WaveVRHead.Inst.HideHand(setVar: false);
			}
			tele.enabled = !menu.activeSelf;
		}
	}
}
public class _TEST : MonoBehaviour
{
	public GameObject m_ps;

	public GameObject target;

	private bool isstart;

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.A))
		{
			isstart = true;
			StartCoroutine(MoveObject(4f));
		}
		if (Input.GetKeyDown(KeyCode.S))
		{
			isstart = false;
		}
	}

	private IEnumerator MoveObject(float time)
	{
		float dur = 0f;
		m_ps.transform.localScale = Vector3.one;
		m_ps.SetActive(value: true);
		while (m_ps.transform.localScale.x > 0.11f)
		{
			dur += Time.deltaTime;
			m_ps.transform.position = Vector3.SlerpUnclamped(m_ps.transform.position, target.transform.position, Time.deltaTime * 4f);
			m_ps.transform.localScale = Vector3.SlerpUnclamped(m_ps.transform.localScale, Vector3.one * 0.1f, Time.deltaTime * 4f);
			yield return null;
		}
		m_ps.SetActive(value: false);
	}
}
public class WavUtility
{
	private const int BlockSize_16Bit = 2;

	public static AudioClip ToAudioClip(string filePath)
	{
		if (!filePath.StartsWith(Application.persistentDataPath) && !filePath.StartsWith(Application.dataPath))
		{
			UnityEngine.Debug.LogWarning("This only supports files that are stored using Unity's Application data path. \nTo load bundled resources use 'Resources.Load(\"filename\") typeof(AudioClip)' method. \nhttps://docs.unity3d.com/ScriptReference/Resources.Load.html");
			return null;
		}
		return ToAudioClip(File.ReadAllBytes(filePath));
	}

	public static AudioClip ToAudioClip(byte[] fileBytes, int offsetSamples = 0, string name = "wav")
	{
		int num = BitConverter.ToInt32(fileBytes, 16);
		FormatCode(BitConverter.ToUInt16(fileBytes, 20));
		ushort channels = BitConverter.ToUInt16(fileBytes, 22);
		int frequency = BitConverter.ToInt32(fileBytes, 24);
		ushort num2 = BitConverter.ToUInt16(fileBytes, 34);
		int num3 = 20 + num + 4;
		int dataSize = BitConverter.ToInt32(fileBytes, num3);
		float[] array = num2 switch
		{
			8 => Convert8BitByteArrayToAudioClipData(fileBytes, num3, dataSize), 
			16 => Convert16BitByteArrayToAudioClipData(fileBytes, num3, dataSize), 
			24 => Convert24BitByteArrayToAudioClipData(fileBytes, num3, dataSize), 
			32 => Convert32BitByteArrayToAudioClipData(fileBytes, num3, dataSize), 
			_ => throw new Exception(num2 + " bit depth is not supported."), 
		};
		AudioClip audioClip = AudioClip.Create(name, array.Length, channels, frequency, stream: false);
		audioClip.SetData(array, 0);
		return audioClip;
	}

	private static float[] Convert8BitByteArrayToAudioClipData(byte[] source, int headerOffset, int dataSize)
	{
		int num = BitConverter.ToInt32(source, headerOffset);
		headerOffset += 4;
		float[] array = new float[num];
		sbyte b = sbyte.MaxValue;
		for (int i = 0; i < num; i++)
		{
			array[i] = (float)(int)source[i] / (float)b;
		}
		return array;
	}

	private static float[] Convert16BitByteArrayToAudioClipData(byte[] source, int headerOffset, int dataSize)
	{
		int num = BitConverter.ToInt32(source, headerOffset);
		headerOffset += 4;
		int num2 = 2;
		int num3 = num / num2;
		float[] array = new float[num3];
		short num4 = short.MaxValue;
		int num5 = 0;
		for (int i = 0; i < num3; i++)
		{
			num5 = i * num2 + headerOffset;
			array[i] = (float)BitConverter.ToInt16(source, num5) / (float)num4;
		}
		return array;
	}

	private static float[] Convert24BitByteArrayToAudioClipData(byte[] source, int headerOffset, int dataSize)
	{
		int num = BitConverter.ToInt32(source, headerOffset);
		headerOffset += 4;
		int num2 = 3;
		int num3 = num / num2;
		int num4 = int.MaxValue;
		float[] array = new float[num3];
		byte[] array2 = new byte[4];
		int num5 = 0;
		for (int i = 0; i < num3; i++)
		{
			num5 = i * num2 + headerOffset;
			Buffer.BlockCopy(source, num5, array2, 1, num2);
			array[i] = (float)BitConverter.ToInt32(array2, 0) / (float)num4;
		}
		return array;
	}

	private static float[] Convert32BitByteArrayToAudioClipData(byte[] source, int headerOffset, int dataSize)
	{
		int num = BitConverter.ToInt32(source, headerOffset);
		headerOffset += 4;
		int num2 = 4;
		int num3 = num / num2;
		int num4 = int.MaxValue;
		float[] array = new float[num3];
		int num5 = 0;
		for (int i = 0; i < num3; i++)
		{
			num5 = i * num2 + headerOffset;
			array[i] = (float)BitConverter.ToInt32(source, num5) / (float)num4;
		}
		return array;
	}

	public static byte[] FromAudioClip(AudioClip audioClip)
	{
		string filepath;
		return FromAudioClip(audioClip, out filepath, saveAsFile: false);
	}

	public static byte[] FromAudioClip(AudioClip audioClip, out string filepath, bool saveAsFile = true, string dirname = "recordings")
	{
		MemoryStream stream = new MemoryStream();
		ushort bitDepth = 16;
		int fileSize = audioClip.samples * 2 + 44;
		WriteFileHeader(ref stream, fileSize);
		WriteFileFormat(ref stream, audioClip.channels, audioClip.frequency, bitDepth);
		WriteFileData(ref stream, audioClip, bitDepth);
		byte[] array = stream.ToArray();
		if (saveAsFile)
		{
			filepath = string.Format("{0}/{1}/{2}.{3}", Application.streamingAssetsPath, dirname, DateTime.UtcNow.ToString("yyMMdd-HHmmss-fff"), "wav");
			Directory.CreateDirectory(Path.GetDirectoryName(filepath));
			File.WriteAllBytes(filepath, array);
			UnityEngine.Debug.Log("Auto-saved .wav file: " + filepath);
		}
		else
		{
			filepath = null;
		}
		stream.Dispose();
		return array;
	}

	private static int WriteFileHeader(ref MemoryStream stream, int fileSize)
	{
		byte[] bytes = Encoding.ASCII.GetBytes("RIFF");
		int num = 0 + WriteBytesToMemoryStream(ref stream, bytes, "ID");
		int value = fileSize - 8;
		int num2 = num + WriteBytesToMemoryStream(ref stream, BitConverter.GetBytes(value), "CHUNK_SIZE");
		byte[] bytes2 = Encoding.ASCII.GetBytes("WAVE");
		return num2 + WriteBytesToMemoryStream(ref stream, bytes2, "FORMAT");
	}

	private static int WriteFileFormat(ref MemoryStream stream, int channels, int sampleRate, ushort bitDepth)
	{
		byte[] bytes = Encoding.ASCII.GetBytes("fmt ");
		int num = 0 + WriteBytesToMemoryStream(ref stream, bytes, "FMT_ID");
		int value = 16;
		int num2 = num + WriteBytesToMemoryStream(ref stream, BitConverter.GetBytes(value), "SUBCHUNK_SIZE");
		ushort value2 = 1;
		int num3 = num2 + WriteBytesToMemoryStream(ref stream, BitConverter.GetBytes(value2), "AUDIO_FORMAT");
		ushort value3 = Convert.ToUInt16(channels);
		int num4 = num3 + WriteBytesToMemoryStream(ref stream, BitConverter.GetBytes(value3), "CHANNELS") + WriteBytesToMemoryStream(ref stream, BitConverter.GetBytes(sampleRate), "SAMPLE_RATE");
		int value4 = sampleRate * channels * BytesPerSample(bitDepth);
		int num5 = num4 + WriteBytesToMemoryStream(ref stream, BitConverter.GetBytes(value4), "BYTE_RATE");
		ushort value5 = Convert.ToUInt16(channels * BytesPerSample(bitDepth));
		return num5 + WriteBytesToMemoryStream(ref stream, BitConverter.GetBytes(value5), "BLOCK_ALIGN") + WriteBytesToMemoryStream(ref stream, BitConverter.GetBytes(bitDepth), "BITS_PER_SAMPLE");
	}

	private static int WriteFileData(ref MemoryStream stream, AudioClip audioClip, ushort bitDepth)
	{
		float[] data = new float[audioClip.samples * audioClip.channels];
		audioClip.GetData(data, 0);
		byte[] bytes = ConvertAudioClipDataToInt16ByteArray(data);
		byte[] bytes2 = Encoding.ASCII.GetBytes("data");
		int num = 0 + WriteBytesToMemoryStream(ref stream, bytes2, "DATA_ID");
		int value = Convert.ToInt32(audioClip.samples * 2);
		return num + WriteBytesToMemoryStream(ref stream, BitConverter.GetBytes(value), "SAMPLES") + WriteBytesToMemoryStream(ref stream, bytes, "DATA");
	}

	private static byte[] ConvertAudioClipDataToInt16ByteArray(float[] data)
	{
		MemoryStream memoryStream = new MemoryStream();
		int count = 2;
		short num = short.MaxValue;
		for (int i = 0; i < data.Length; i++)
		{
			memoryStream.Write(BitConverter.GetBytes(Convert.ToInt16(data[i] * (float)num)), 0, count);
		}
		byte[] result = memoryStream.ToArray();
		memoryStream.Dispose();
		return result;
	}

	private static int WriteBytesToMemoryStream(ref MemoryStream stream, byte[] bytes, string tag = "")
	{
		int num = bytes.Length;
		stream.Write(bytes, 0, num);
		return num;
	}

	public static ushort BitDepth(AudioClip audioClip)
	{
		return Convert.ToUInt16((float)(audioClip.samples * audioClip.channels) * audioClip.length / (float)audioClip.frequency);
	}

	private static int BytesPerSample(ushort bitDepth)
	{
		return bitDepth / 8;
	}

	private static int BlockSize(ushort bitDepth)
	{
		return bitDepth switch
		{
			32 => 4, 
			16 => 2, 
			8 => 1, 
			_ => throw new Exception(bitDepth + " bit depth is not supported."), 
		};
	}

	private static string FormatCode(ushort code)
	{
		switch (code)
		{
		case 1:
			return "PCM";
		case 2:
			return "ADPCM";
		case 3:
			return "IEEE";
		case 7:
			return "μ-law";
		case 65534:
			return "WaveFormatExtensable";
		default:
			UnityEngine.Debug.LogWarning("Unknown wav code format:" + code);
			return "";
		}
	}
}
public class WordToVoice : MonoBehaviour
{
	public delegate void CallBack(string name);

	public delegate string ds();

	[TextArea(0, 6)]
	public string strwords;

	private string token = "";

	private string grant_Type = "client_credentials";

	private string client_ID = "6B9HuKm2xSssYVwCcGBHYV7r";

	private string client_Secret = "RDUye6TkYQ4CLYEEfpdT0mY1YfAFQcoI";

	private string baiduAPI = "https://tsn.baidu.com/text2audio";

	private string getTokenAPIPath = "https://openapi.baidu.com/oauth/2.0/token";

	private byte[] clipByte;

	public static string audioToString;

	public AudioSource audioSource;

	private void Awake()
	{
		StartCoroutine(GetToken(getTokenAPIPath));
	}

	private IEnumerator GetToken(string url)
	{
		bool flag = false;
		token = PlayerPrefs.GetString("baidu_token");
		if (string.IsNullOrEmpty(token))
		{
			flag = true;
		}
		else if ((DateTime.Now - DateTime.FromFileTime(long.Parse(PlayerPrefs.GetString("baidu_token_DateTime")))).Days > 25)
		{
			flag = true;
		}
		if (flag)
		{
			WWWForm wWWForm = new WWWForm();
			wWWForm.AddField("grant_type", grant_Type);
			wWWForm.AddField("client_id", client_ID);
			wWWForm.AddField("client_secret", client_Secret);
			using UnityWebRequest getTW = UnityWebRequest.Post(url, wWWForm);
			yield return getTW.SendWebRequest();
			if (getTW.isDone)
			{
				if (getTW.error == null)
				{
					token = J_LitJson.JsonMapper.ToObject(getTW.downloadHandler.text)["access_token"].ToString();
					PlayerPrefs.SetString("baidu_token", token);
					PlayerPrefs.SetString("baidu_token_DateTime", DateTime.Now.ToFileTime().ToString());
					UnityEngine.Debug.Log(token);
					UnityEngine.Debug.Log("获取百度用户令牌 初始化完成");
				}
				else
				{
					UnityEngine.Debug.Log("error:" + getTW.error);
				}
			}
		}
		StartCoroutine(GetAudioString());
		yield return null;
	}

	private IEnumerator GetAudioString()
	{
		WWWForm wWWForm = new WWWForm();
		wWWForm.AddField("tex", strwords);
		wWWForm.AddField("tok", token);
		wWWForm.AddField("cuid", "11");
		wWWForm.AddField("ctp", 1);
		wWWForm.AddField("aue", 3);
		wWWForm.AddField("lan", "zh");
		UnityEngine.Debug.Log(token);
		using UnityWebRequest getASW = UnityWebRequest.Post(baiduAPI, wWWForm);
		UnityEngine.Debug.Log(getASW.uri);
		UnityEngine.Debug.Log(getASW.url);
		yield return getASW.SendWebRequest();
		if (getASW.isDone)
		{
			File.WriteAllBytes(string.Concat(Directory.GetParent(Application.dataPath), "/1.mp3"), getASW.downloadHandler.data);
		}
	}
}
public class ClothMemoryManager : MonoBehaviour
{
	[Serializable]
	public class cClothSale
	{
		public GameObject objIcon;

		[HideInInspector]
		public Text txtMoney;

		public GameObject objCloth;

		[HideInInspector]
		public int imoney;
	}

	public int m_iLevel = 1;

	public cClothSale[] listSaleCloth;

	public Text timeSalePanel_CountDown;

	[Header("价目表")]
	public GameObject canvasSaleTable;

	[Header("店员")]
	public GameObject canvasSalerSayWords;

	public Text m_txtSayWords;

	public Animation m_animCtrl;

	[Header("判断Canava")]
	public GameObject canvasSayYesOrNo;

	[Header("再来一次")]
	public GameObject canvasPlayAgain;

	public Text txtplayagain;

	public AudioSource audioSourceCorrect;

	public AudioSource audioSourceError;

	private List<cClothSale> _listShowedCloth = new List<cClothSale>();

	private Coroutine coroutineTimeCountDonw;

	private bool hasStartSale;

	private bool isClothMoneyRight;

	private void Start()
	{
		m_animCtrl.Play("idle");
		canvasSalerSayWords.SetActive(value: false);
		canvasPlayAgain.SetActive(value: false);
		canvasSaleTable.SetActive(value: false);
		canvasSayYesOrNo.SetActive(value: false);
		cClothSale[] array = listSaleCloth;
		foreach (cClothSale obj in array)
		{
			obj.txtMoney = obj.objIcon.transform.Find("TextMoney").GetComponent<Text>();
			obj.objIcon.SetActive(value: false);
			obj.objCloth.SetActive(value: false);
		}
	}

	public void J_StartPlay()
	{
		m_animCtrl.Play("idle");
		canvasSayYesOrNo.SetActive(value: false);
		canvasSalerSayWords.SetActive(value: false);
		int num = m_iLevel;
		if (num > listSaleCloth.Length)
		{
			num = listSaleCloth.Length;
		}
		cClothSale[] array = listSaleCloth;
		foreach (cClothSale obj in array)
		{
			obj.objIcon.SetActive(value: false);
			obj.objCloth.SetActive(value: false);
		}
		canvasSaleTable.SetActive(value: true);
		_listShowedCloth = listSaleCloth.OrderBy((cClothSale c) => Guid.NewGuid()).Take(num).ToList();
		for (int j = 0; j < num; j++)
		{
			cClothSale cClothSale = _listShowedCloth[j];
			cClothSale.objIcon.SetActive(value: true);
			cClothSale.imoney = UnityEngine.Random.Range(10, 200);
			cClothSale.txtMoney.text = cClothSale.imoney + "元";
		}
		hasStartSale = false;
		coroutineTimeCountDonw = StartCoroutine(yieldCloseSalePanel(3 + num * 3));
	}

	private IEnumerator yieldCloseSalePanel(int iwaitSecond)
	{
		int i = iwaitSecond;
		while (i >= 0)
		{
			timeSalePanel_CountDown.text = string.Concat(i);
			yield return new WaitForSeconds(1f);
			int num = i - 1;
			i = num;
		}
		if (!hasStartSale)
		{
			J_StartSaleCheck();
		}
	}

	public void J_StartSaleCheck()
	{
		StopCoroutine(coroutineTimeCountDonw);
		hasStartSale = true;
		canvasSayYesOrNo.SetActive(value: true);
		m_animCtrl.Play("抬手");
		canvasSaleTable.SetActive(value: false);
		cClothSale cClothSale = _listShowedCloth[UnityEngine.Random.Range(0, _listShowedCloth.Count)];
		cClothSale.objCloth.SetActive(value: true);
		isClothMoneyRight = UnityEngine.Random.value > 0.5f;
		int num = (int)UnityEngine.Random.Range(-50f, 50f);
		int num2 = 0;
		if (num >= 0)
		{
			isClothMoneyRight = true;
			num2 = cClothSale.imoney + num;
		}
		else
		{
			isClothMoneyRight = false;
			num2 = cClothSale.imoney + num;
			if (num2 < 1)
			{
				num2 = 1;
			}
			m_txtSayWords.text = num2 + "元";
		}
		canvasSalerSayWords.SetActive(value: true);
		m_txtSayWords.text = cClothSale.objCloth.name + "卖" + num2 + "元怎么样？";
	}

	public void J_SayYesOrNo(bool yesOrNo)
	{
		canvasSayYesOrNo.SetActive(value: false);
		canvasSalerSayWords.SetActive(value: false);
		canvasPlayAgain.SetActive(value: true);
		if (yesOrNo == isClothMoneyRight)
		{
			m_iLevel++;
			audioSourceCorrect.Play();
			txtplayagain.J_MakeShowResult(J_PlayResult.Result.Succeed);
			m_animCtrl.CrossFade("拍手", 1f);
		}
		else
		{
			audioSourceError.Play();
			txtplayagain.J_MakeShowResult(J_PlayResult.Result.Failed);
			m_animCtrl.CrossFade("摇头", 1f);
		}
	}
}
public class KuaiDiMemoryManager : MonoBehaviour
{
	public int m_iLevel = 1;

	public Transform transDoorsContainer;

	private Button[] m_listDoorBtns;

	private List<int> m_listBtnIndexes = new List<int>();

	public Transform transDooooAudiosContainer;

	private AudioSource[] m_listAudioDoooo;

	public Color colorOn = Color.cyan;

	public GameObject objStartClickTip;

	[Header("再来一次")]
	public GameObject canvasPlayAgain;

	public Text txtplayagain;

	public AudioSource audioSourceCorrect;

	public AudioSource audioSourceError;

	private Queue<int> rightOrder = new Queue<int>();

	private Color[] basecolor = new Color[16];

	private int iAudioClickIndex;

	public Pvr_UICanvas cvs;

	private void Start()
	{
		cvs.enabled = false;
		canvasPlayAgain.SetActive(value: false);
		objStartClickTip.SetActive(value: false);
		m_listDoorBtns = transDoorsContainer.GetComponentsInChildren<Button>();
		for (int i = 0; i < m_listDoorBtns.Length; i++)
		{
			int iIndex = i;
			m_listBtnIndexes.Add(iIndex);
			Button tempBtn = m_listDoorBtns[i];
			basecolor[i] = tempBtn.image.color;
			tempBtn.onClick.AddListener(delegate
			{
				UnityEngine.Debug.LogWarning(iIndex);
				tempBtn.interactable = false;
				if (rightOrder.Dequeue() == iIndex)
				{
					m_listAudioDoooo[iAudioClickIndex].Play();
					if (++iAudioClickIndex > m_listAudioDoooo.Length)
					{
						iAudioClickIndex = 0;
					}
					if (rightOrder.Count == 0)
					{
						OnResult(isSucced: true);
					}
				}
				else
				{
					OnResult(isSucced: false);
				}
			});
		}
		m_listAudioDoooo = GetComponentsInChildren<AudioSource>();
	}

	public void J_StartPlay()
	{
		int num = m_iLevel;
		if (num < 2)
		{
			num = 2;
		}
		if (num > m_listBtnIndexes.Count)
		{
			num = m_listBtnIndexes.Count;
		}
		StartCoroutine(yieldPlayDoor(num));
	}

	private IEnumerator yieldPlayDoor(int idoorCount)
	{
		yield return new WaitForSeconds(1f);
		int iAudioIndex = 0;
		rightOrder.Clear();
		List<int> randomListBtnII = m_listBtnIndexes.OrderBy((int c) => Guid.NewGuid()).ToList();
		int i = 0;
		while (i < idoorCount)
		{
			int num = randomListBtnII[i];
			rightOrder.Enqueue(num);
			Button tempBtn = m_listDoorBtns[num];
			Color oriColor = tempBtn.image.color;
			tempBtn.image.color = colorOn;
			m_listAudioDoooo[iAudioIndex].Play();
			int num2 = iAudioIndex + 1;
			iAudioIndex = num2;
			if (num2 > m_listAudioDoooo.Length)
			{
				iAudioIndex = 0;
			}
			yield return new WaitForSeconds(0.5f);
			tempBtn.image.color = oriColor;
			num2 = i + 1;
			i = num2;
		}
		yield return new WaitForSeconds(1f);
		objStartClickTip.SetActive(value: true);
		_SetDoorBtnsInteractable(isenable: true);
		yield return new WaitForSeconds(0.7f);
		objStartClickTip.SetActive(value: false);
	}

	private void _SetDoorBtnsInteractable(bool isenable)
	{
		cvs.enabled = isenable;
		iAudioClickIndex = 0;
	}

	private void OnResult(bool isSucced)
	{
		for (int i = 0; i < m_listDoorBtns.Length; i++)
		{
			m_listDoorBtns[i].interactable = true;
		}
		_SetDoorBtnsInteractable(isenable: false);
		if (isSucced)
		{
			m_iLevel++;
			StartCoroutine(yiledPlayAudiRight());
			txtplayagain.J_MakeShowResult(J_PlayResult.Result.Succeed);
		}
		else
		{
			canvasPlayAgain.SetActive(value: true);
			audioSourceError.Play();
			txtplayagain.J_MakeShowResult(J_PlayResult.Result.Failed);
		}
	}

	private IEnumerator yiledPlayAudiRight()
	{
		yield return new WaitForSeconds(0.5f);
		canvasPlayAgain.SetActive(value: true);
		audioSourceCorrect.Play();
	}
}
public class MedicalPatientDragManager : MonoBehaviour
{
	[Serializable]
	public class cItemIll
	{
		public string illName;

		public GameObject illTargetA;

		public GameObject objDrag;

		[HideInInspector]
		public Button btnDrug;

		[HideInInspector]
		public GameObject drugTip;
	}

	public cItemIll[] listItemIlls;

	[Header("人")]
	public GameObject objPeople;

	public Animation m_peopleAnimCtrl;

	[Header("再来一次")]
	public GameObject canvasPlayAgain;

	public Text txtplayagain;

	public AudioSource audioSourceCorrect;

	public AudioSource audioSourceError;

	public Pvr_UICanvas cvs;

	private bool bHasShowResult;

	private cItemIll m_curIll;

	private void Start()
	{
		Vector3 size = cvs.GetComponent<BoxCollider>().size;
		cvs.GetComponent<BoxCollider>().size = new Vector3(size.x, size.y, 50f);
		objPeople.SetActive(value: false);
		canvasPlayAgain.SetActive(value: false);
		cItemIll[] array = listItemIlls;
		foreach (cItemIll cItemIll in array)
		{
			cItemIll tempObj = cItemIll;
			cItemIll.drugTip = cItemIll.objDrag.transform.Find("ImageDrugTip").gameObject;
			cItemIll.btnDrug = cItemIll.objDrag.GetComponentInChildren<Button>();
			cItemIll.illTargetA.SetActive(value: false);
			cItemIll.objDrag.SetActive(value: false);
			cItemIll.btnDrug.onClick.AddListener(delegate
			{
				if (!bHasShowResult)
				{
					UnityEngine.Debug.Log(tempObj.illName);
					if (tempObj == m_curIll)
					{
						OnResult(isSucced: true);
					}
					else
					{
						OnResult(isSucced: false);
					}
				}
			});
		}
	}

	private void OnResult(bool isSucced)
	{
		bHasShowResult = true;
		m_curIll.illTargetA.SetActive(value: false);
		objPeople.SetActive(value: true);
		canvasPlayAgain.SetActive(value: true);
		if (isSucced)
		{
			audioSourceCorrect.Play();
			txtplayagain.text = "病人康复了，谢谢！";
			m_peopleAnimCtrl.CrossFade("拍手", 1f);
		}
		else
		{
			audioSourceError.Play();
			txtplayagain.text = "用错药啦，要多加注意";
			m_peopleAnimCtrl.CrossFade("摇头", 1f);
		}
	}

	public void J_StartPlay()
	{
		Vector3 size = cvs.GetComponent<BoxCollider>().size;
		cvs.GetComponent<BoxCollider>().size = new Vector3(size.x, size.y, 50f);
		bHasShowResult = false;
		objPeople.SetActive(value: false);
		canvasPlayAgain.SetActive(value: false);
		cItemIll[] array = listItemIlls;
		foreach (cItemIll obj in array)
		{
			obj.illTargetA.SetActive(value: false);
			obj.objDrag.SetActive(value: false);
			obj.drugTip.SetActive(value: false);
		}
		List<cItemIll> list = listItemIlls.OrderBy((cItemIll c) => Guid.NewGuid()).Take(3).ToList();
		UnityEngine.Debug.Log(list.Count());
		m_curIll = list[0];
		m_curIll.objDrag.SetActive(value: true);
		m_curIll.illTargetA.SetActive(value: true);
		foreach (cItemIll item in list)
		{
			item.objDrag.SetActive(value: true);
		}
	}
}
public class MemoryYinPinMakeManager : MonoBehaviour
{
	[Serializable]
	public class cDrinkPo
	{
		public string strDrinkName;

		public Collider colliderDrink;

		public Transform stayPoint;

		public GameObject objAnimFruid;
	}

	[Serializable]
	public class cPeiLiaoPo
	{
		public string strName;

		public Collider col;

		public GameObject objAnim;
	}

	public class cPointClickEvent : MonoBehaviour, IHandRayPointerDown
	{
		public Action m_acitonOnClick;

		public void OnHandPointerDown(WaveVR_HandRayGrabber hand)
		{
			if (m_acitonOnClick != null)
			{
				m_acitonOnClick();
			}
		}
	}

	public class cTriggerAreaCtrl : MonoBehaviour
	{
		public Action m_acitonOnTriggerEnter;

		private void OnTriggerEnter(Collider other)
		{
			UnityEngine.Debug.LogWarning("--enter check");
			if (m_acitonOnTriggerEnter != null)
			{
				m_acitonOnTriggerEnter();
			}
		}
	}

	public int m_iLevel = 1;

	public Button m_btnStartMaking;

	private WaveVR_rayInteractObject _grabCtrl;

	private J_InteractableOutline _grabOutlineCtrl;

	public GameObject m_objBeiZi;

	public GameObject m_beiziFruid;

	public GameObject m_objGaiZi;

	public float m_fMoveSpeed = 0.35f;

	public Transform pointStart;

	public Transform pointDrinkChose;

	public Transform pointPeiLiaoChose;

	public Transform pointEndPack;

	public cDrinkPo[] m_listOriDrinks;

	public cPeiLiaoPo[] m_listOriPeiLiao;

	public Animator objAnimPack;

	public GameObject objDrinkSelectionTip;

	public GameObject objPeiLiaoelectionTip;

	public GameObject objPcakOverTip;

	[Header("顾客")]
	public Collider p_triggerArea;

	public Animation m_peopleAnimCtrl;

	public Text m_txtP_DrinkQuest;

	[Header("再来一次")]
	public GameObject canvasPlayAgain;

	public Text txtplayagain;

	public AudioSource audioSourceCorrect;

	public AudioSource audioSourceError;

	private string strRealDrinkName = "";

	private Coroutine coroutineMaking;

	private bool m_isInAnim;

	private bool isInDrinkSelecting;

	private cDrinkPo objDrinkSelection;

	private bool isInPeiLiaoSelection;

	private cPeiLiaoPo objPeiLiaoSelction;

	private void Start()
	{
		m_btnStartMaking.gameObject.SetActive(value: false);
		canvasPlayAgain.SetActive(value: false);
		m_txtP_DrinkQuest.text = "";
		_grabCtrl = m_objBeiZi.GetComponent<WaveVR_rayInteractObject>();
		_grabOutlineCtrl = m_objBeiZi.GetComponent<J_InteractableOutline>();
		_grabCtrl.enabled = false;
		_grabOutlineCtrl.enabled = false;
		objAnimPack.enabled = false;
		m_objBeiZi.SetActive(value: false);
		isInDrinkSelecting = false;
		objDrinkSelection = null;
		isInPeiLiaoSelection = false;
		objPeiLiaoSelction = null;
		objDrinkSelectionTip.SetActive(value: false);
		objPeiLiaoelectionTip.SetActive(value: false);
		objPcakOverTip.SetActive(value: false);
		m_beiziFruid.transform.localScale = new Vector3(1f, 0f, 1f);
		m_btnStartMaking.onClick.AddListener(J_StartMakeDrink);
		cDrinkPo[] listOriDrinks = m_listOriDrinks;
		foreach (cDrinkPo cDrinkPo in listOriDrinks)
		{
			cDrinkPo tempObj = cDrinkPo;
			tempObj.objAnimFruid.SetActive(value: false);
			cDrinkPo.colliderDrink.gameObject.AddComponent<cPointClickEvent>().m_acitonOnClick = delegate
			{
				if (!m_isInAnim && isInDrinkSelecting)
				{
					isInDrinkSelecting = false;
					objDrinkSelection = tempObj;
				}
			};
		}
		cPeiLiaoPo[] listOriPeiLiao = m_listOriPeiLiao;
		foreach (cPeiLiaoPo cPeiLiaoPo in listOriPeiLiao)
		{
			cPeiLiaoPo tempObj2 = cPeiLiaoPo;
			tempObj2.objAnim.SetActive(value: false);
			cPeiLiaoPo.col.gameObject.AddComponent<cPointClickEvent>().m_acitonOnClick = delegate
			{
				if (!m_isInAnim && isInPeiLiaoSelection)
				{
					isInPeiLiaoSelection = false;
					objPeiLiaoSelction = tempObj2;
					tempObj2.objAnim.SetActive(value: true);
				}
			};
		}
		p_triggerArea.gameObject.AddComponent<cTriggerAreaCtrl>().m_acitonOnTriggerEnter = delegate
		{
			m_objBeiZi.SetActive(value: false);
			if (objDrinkSelection != null && objPeiLiaoSelction != null)
			{
				string text = objPeiLiaoSelction.strName + objDrinkSelection.strDrinkName;
				UnityEngine.Debug.LogWarning("--made " + text);
				if (text == strRealDrinkName)
				{
					UnityEngine.Debug.LogError("--right");
					OnResult(isSucced: true);
					return;
				}
			}
			OnResult(isSucced: false);
			UnityEngine.Debug.LogError("--wrong");
		};
	}

	public void J_StartPlay()
	{
		m_isInAnim = false;
		m_btnStartMaking.gameObject.SetActive(value: true);
		m_btnStartMaking.GetComponentInChildren<Text>().text = "开始制作";
		string strDrinkName = m_listOriDrinks[UnityEngine.Random.Range(0, m_listOriDrinks.Length)].strDrinkName;
		string strName = m_listOriPeiLiao[UnityEngine.Random.Range(0, m_listOriPeiLiao.Length)].strName;
		strRealDrinkName = strName + strDrinkName;
		m_txtP_DrinkQuest.text = $"一杯<color=#00FF00>{strRealDrinkName}</color>";
	}

	public void J_StartMakeDrink()
	{
		if (!m_isInAnim)
		{
			m_btnStartMaking.GetComponentInChildren<Text>().text = "重新制作";
			if (coroutineMaking != null)
			{
				StopCoroutine(coroutineMaking);
			}
			coroutineMaking = StartCoroutine(_yieldStartMakeDrink());
		}
	}

	private IEnumerator _yieldStartMakeDrink()
	{
		_grabCtrl.enabled = false;
		_grabOutlineCtrl.enabled = false;
		isInDrinkSelecting = false;
		objDrinkSelection = null;
		isInPeiLiaoSelection = false;
		objPeiLiaoSelction = null;
		WaveVRHead.Inst.SetGrab(showOrHide: false);
		objDrinkSelectionTip.SetActive(value: false);
		objPeiLiaoelectionTip.SetActive(value: false);
		objPcakOverTip.SetActive(value: false);
		m_beiziFruid.transform.localScale = new Vector3(1f, 0f, 1f);
		m_objGaiZi.SetActive(value: false);
		m_objBeiZi.SetActive(value: true);
		m_objBeiZi.transform.position = pointStart.position;
		m_isInAnim = true;
		m_objBeiZi.transform.DOMove(pointDrinkChose.position, 1f).OnComplete(delegate
		{
			m_isInAnim = false;
			isInDrinkSelecting = true;
			objDrinkSelectionTip.SetActive(value: true);
		});
		yield return new WaitUntil(() => objDrinkSelection != null);
		isInDrinkSelecting = false;
		m_isInAnim = true;
		m_objBeiZi.transform.DOMove(objDrinkSelection.stayPoint.position, 1.5f).OnComplete(delegate
		{
			objDrinkSelection.objAnimFruid.SetActive(value: true);
			m_beiziFruid.transform.DOScale(new Vector3(1f, 0f, 1f), 0.5f).OnComplete(delegate
			{
				m_beiziFruid.transform.DOScale(Vector3.one, 1f).OnComplete(delegate
				{
					objDrinkSelection.objAnimFruid.SetActive(value: false);
					objDrinkSelectionTip.SetActive(value: false);
					m_objBeiZi.transform.DOMove(pointPeiLiaoChose.position, 2f).OnComplete(delegate
					{
						m_isInAnim = false;
						isInPeiLiaoSelection = true;
						objPeiLiaoelectionTip.SetActive(value: true);
					});
				});
			});
		});
		yield return new WaitUntil(() => objPeiLiaoSelction != null);
		objPeiLiaoelectionTip.SetActive(value: false);
		isInPeiLiaoSelection = false;
		m_isInAnim = true;
		yield return new WaitForSeconds(3f);
		objPeiLiaoSelction.objAnim.SetActive(value: false);
		WaveVRHead.Inst.SetGrab(showOrHide: true);
		m_objBeiZi.transform.DOMove(pointEndPack.position, 1f).OnComplete(delegate
		{
			objAnimPack.enabled = true;
			objAnimPack.Update(0f);
		});
		yield return new WaitForSeconds(1f);
		m_objGaiZi.SetActive(value: true);
		yield return new WaitForSeconds(1f);
		objPcakOverTip.SetActive(value: true);
		m_isInAnim = false;
		_grabCtrl.enabled = true;
		_grabOutlineCtrl.enabled = true;
		UnityEngine.Debug.LogError("--end");
	}

	private void OnResult(bool isSucced)
	{
		m_isInAnim = true;
		m_btnStartMaking.gameObject.SetActive(value: false);
		canvasPlayAgain.SetActive(value: true);
		if (isSucced)
		{
			audioSourceCorrect.Play();
			txtplayagain.J_MakeShowResult(Color.green, "真是太棒了，真好喝");
			m_peopleAnimCtrl.CrossFade("拍手", 1f);
		}
		else
		{
			audioSourceError.Play();
			txtplayagain.J_MakeShowResult(Color.red, "搭配错啦，下次继续加油哦");
			m_peopleAnimCtrl.CrossFade("摇头", 1f);
		}
	}

	private IEnumerator _yieldMoveToTargetPoint(GameObject moveObj, Vector3 vTargetPoint, Action actionOnReachPoint)
	{
		Vector3 position = moveObj.transform.position;
		Vector3 vMoveDir = vTargetPoint - position;
		float fStime = vMoveDir.magnitude / m_fMoveSpeed;
		while (fStime > 0f)
		{
			yield return new WaitForFixedUpdate();
			fStime -= Time.deltaTime;
			moveObj.transform.position = vTargetPoint - vMoveDir.normalized * fStime * m_fMoveSpeed;
		}
		UnityEngine.Debug.LogWarning("--reach point");
		moveObj.transform.position = vTargetPoint;
	}

	private void Update()
	{
		if (Pvr.IsMainKeyDown() && Physics.Raycast(Pvr.GetXunlianRay(), out var hitInfo, 100f, 1024))
		{
			cPointClickEvent component = hitInfo.transform.gameObject.GetComponent<cPointClickEvent>();
			if (component != null)
			{
				component.m_acitonOnClick();
			}
		}
	}
}
public class WordsCookedFood_RawMaterialManager : MonoBehaviour
{
	[Serializable]
	public class cCookedFood
	{
		public string foodName;

		public Texture pic;

		[TextArea]
		public string foodRawMaterials;
	}

	public AudioRecWordsCtrl audioRecCtrl;

	public GameObject canvasQuestion;

	public Text m_txtQuestion;

	public RawImage m_questionImg;

	public Button m_btnShowResult;

	public GameObject m_objTip;

	public GameObject canvasResult;

	public Text m_txtSimilerRate;

	public Text m_txtFoodName;

	public Text m_txtFoodStep;

	public _ClockTimer m_Clock;

	public cCookedFood[] listCookedFoods;

	private cCookedFood m_curFood;

	private void Start()
	{
		audioRecCtrl.gameObject.SetActive(value: false);
		canvasQuestion.SetActive(value: false);
		m_objTip.SetActive(value: false);
		canvasResult.SetActive(value: false);
		m_Clock.gameObject.SetActive(value: false);
		m_Clock.eventOnTimerOver.AddListener(_ShowResult);
		m_btnShowResult.onClick.AddListener(delegate
		{
			if (string.IsNullOrEmpty(audioRecCtrl.txtResult.text))
			{
				StartCoroutine(yieldShowTIp());
			}
			else
			{
				_ShowResult();
			}
		});
	}

	private IEnumerator yieldShowTIp()
	{
		m_objTip.SetActive(value: true);
		yield return new WaitForSeconds(1f);
		m_objTip.SetActive(value: false);
	}

	public void J_StartPlay()
	{
		m_Clock.ftimer = 30f;
		m_Clock.gameObject.SetActive(value: true);
		canvasQuestion.SetActive(value: true);
		audioRecCtrl.gameObject.SetActive(value: true);
		audioRecCtrl.J_StartRec();
		canvasResult.SetActive(value: false);
		m_curFood = listCookedFoods[UnityEngine.Random.Range(0, listCookedFoods.Length)];
		m_questionImg.texture = m_curFood.pic;
		m_txtQuestion.text = $"请问做一道<color=#20FF00>{m_curFood.foodName}</color>，需要准备哪些原材料呢？";
	}

	public void _ShowResult()
	{
		m_Clock.gameObject.SetActive(value: false);
		canvasQuestion.SetActive(value: false);
		try
		{
			audioRecCtrl.J_StopRec();
			audioRecCtrl.gameObject.SetActive(value: false);
		}
		catch
		{
		}
		canvasResult.SetActive(value: true);
		m_txtFoodName.text = $"<color=#20FF00>{m_curFood.foodName}</color>的步骤";
		m_txtFoodStep.text = m_curFood.foodRawMaterials;
		string text = audioRecCtrl.txtResult.text;
		UnityEngine.Debug.Log(text);
		UnityEngine.Debug.Log(m_curFood.foodRawMaterials);
		float num = (float)J_Utility.GetSimilarityWith(text.Replace("，", "").Replace(",", ""), m_curFood.foodRawMaterials.Replace("、", ""));
		UnityEngine.Debug.Log(num);
		m_txtSimilerRate.text = "匹配度：" + (num * 100f).ToString("f2") + "%";
	}
}
public class WordsCookedFoodManager : MonoBehaviour
{
	[Serializable]
	public class cCookedFood
	{
		public string foodName;

		[TextArea(3, 7)]
		public string foodStep;
	}

	public AudioRecWordsCtrl audioRecCtrl;

	public GameObject canvasQuestion;

	public Text m_txtQuestion;

	public Button m_btnShowResult;

	public Text m_txtShowResult;

	public GameObject m_objTip;

	public GameObject canvasResult;

	public Text m_txtFoodName;

	public Text m_txtFoodStep;

	public _ClockTimer m_Clock;

	public cCookedFood[] listCookedFoods;

	private bool isTimeCountDown;

	private cCookedFood m_curFood;

	private void Start()
	{
		audioRecCtrl.gameObject.SetActive(value: false);
		canvasQuestion.SetActive(value: false);
		m_objTip.SetActive(value: false);
		canvasResult.SetActive(value: false);
		m_Clock.gameObject.SetActive(value: false);
		m_Clock.eventOnTimerOver.AddListener(_ShowResult);
		m_btnShowResult.onClick.AddListener(delegate
		{
			if (isTimeCountDown)
			{
				StartCoroutine(yieldShowTIp());
			}
			else
			{
				_ShowResult();
			}
		});
	}

	private IEnumerator yieldShowTIp()
	{
		m_objTip.SetActive(value: true);
		yield return new WaitForSeconds(1f);
		m_objTip.SetActive(value: false);
	}

	public void J_StartPlay()
	{
		m_Clock.ftimer = 60f;
		m_Clock.gameObject.SetActive(value: true);
		canvasQuestion.SetActive(value: true);
		audioRecCtrl.gameObject.SetActive(value: true);
		audioRecCtrl.J_StartRec();
		canvasResult.SetActive(value: false);
		m_curFood = listCookedFoods[UnityEngine.Random.Range(0, listCookedFoods.Length)];
		m_txtQuestion.text = $"请问做一道<color=#20FF00>{m_curFood.foodName}</color>，需要准备哪些步骤呢？";
		StartCoroutine(yieldWaitForEnableToShow());
	}

	private IEnumerator yieldWaitForEnableToShow()
	{
		isTimeCountDown = true;
		int i = 10;
		while (i > 0)
		{
			m_txtShowResult.text = $"查看步骤({i})";
			yield return new WaitForSeconds(1f);
			int num = i - 1;
			i = num;
		}
		isTimeCountDown = false;
		m_txtShowResult.text = "查看步骤";
	}

	public void _ShowResult()
	{
		m_Clock.gameObject.SetActive(value: false);
		canvasQuestion.SetActive(value: false);
		audioRecCtrl.J_StopRec();
		audioRecCtrl.gameObject.SetActive(value: false);
		m_txtFoodName.text = $"<color=#20FF00>{m_curFood.foodName}</color>的步骤";
		m_txtFoodStep.text = m_curFood.foodStep;
		canvasResult.SetActive(value: true);
	}
}
public class GM_QandA : MonoBehaviour
{
	private void Start()
	{
		QQandAA_Base QandA = new QQandAA_Base();
		QandA.setQuestion("请问今天是几月几日");
		QandA.setAnswerCheckMethod(delegate(string recResult)
		{
			string text = DateTime.Now.ToString("MM月dd");
			UnityEngine.Debug.Log(text);
			if (recResult.Contains(text))
			{
				QandA.bIsRight = true;
			}
			else
			{
				QandA.bIsRight = false;
			}
		});
	}

	private void Update()
	{
	}
}
public abstract class QandA_Base
{
	public abstract string GetQuestion();

	public abstract bool CheckAnser(string recResult);

	public void setQuestion(string question)
	{
	}

	public void setAnswerCheckMethod(Action method)
	{
		method();
	}
}
public class QQandAA_Base
{
	public bool bIsRight;

	private static Action<string> answerCheckMethod;

	public void setQuestion(string question)
	{
	}

	public void setAnswerCheckMethod(Action<string> method)
	{
		answerCheckMethod = method;
	}

	public void CheckAnser(string recResult)
	{
		answerCheckMethod(recResult);
	}
}
public class questionAnswer01 : QandA_Base
{
	private string question;

	public questionAnswer01()
	{
		question = "请问今天是几月几日";
	}

	public override string GetQuestion()
	{
		return question;
	}

	public override bool CheckAnser(string recResult)
	{
		string text = DateTime.Now.ToString("MM月dd");
		UnityEngine.Debug.Log(text);
		if (recResult.Contains(text))
		{
			return true;
		}
		return false;
	}
}
public class questionAnswer02 : QandA_Base
{
	private List<string> listSeasons;

	private string strSeason;

	private string strPreOrNext;

	private string strAnswerRightSeason;

	public questionAnswer02()
	{
		listSeasons = new List<string> { "春", "夏", "秋", "冬" };
		int num = UnityEngine.Random.Range(0, listSeasons.Count);
		strSeason = listSeasons[num];
		if (((UnityEngine.Random.Range(0, 2) != 0) ? 1 : (-1)) == -1)
		{
			strPreOrNext = "前";
			if (--num < 0)
			{
				num = listSeasons.Count - 1;
			}
			strAnswerRightSeason = listSeasons[num];
		}
		else
		{
			strPreOrNext = "后";
			if (++num > listSeasons.Count - 1)
			{
				num = 0;
			}
			strAnswerRightSeason = listSeasons[num];
		}
	}

	public override string GetQuestion()
	{
		return $"请说出{strSeason}天的{strPreOrNext}一个季节是什么季节？";
	}

	public override bool CheckAnser(string recResult)
	{
		if (recResult.Contains(recResult))
		{
			return true;
		}
		return false;
	}
}
public class questionAnswer03 : QandA_Base
{
	private string question;

	private List<string> listResults = new List<string>
	{
		"鼠", "牛", "虎", "兔", "龙", "蛇", "马", "羊", "猴", "鸡",
		"狗", "猪"
	};

	public questionAnswer03()
	{
		question = "请说出十二生肖里的任意四种动物的名称";
	}

	public override string GetQuestion()
	{
		return question;
	}

	public override bool CheckAnser(string recResult)
	{
		int num = 0;
		foreach (string listResult in listResults)
		{
			if (recResult.Contains(listResult))
			{
				num++;
			}
		}
		if (num >= 4)
		{
			return true;
		}
		return false;
	}
}
public class GameManagerSpeechRepeat : MonoBehaviour
{
	public enum ewordState
	{
		词语 = 1,
		成语,
		短语,
		句子
	}

	public int m_iScore;

	public ewordState m_curWordState = ewordState.词语;

	private int irightCount;

	public AudioRecWordsCtrl m_audioRecCtrl;

	public Text m_txtWordTitle;

	public Text m_txtWordShow;

	public AudioSource m_wordAudio;

	public Text m_txtSTip;

	public Text m_txtSimilerRate;

	[Header("repeat count")]
	public GameObject m_objRepeatCount;

	public Image m_imgRepeatTimeCountDown;

	public GameObject m_canvasResult;

	public Transform m_containerRightWords;

	public Text m_txtScore;

	private Dictionary<ewordState, List<string>> m_dicAllWords = new Dictionary<ewordState, List<string>>();

	[HideInInspector]
	public string m_repeatWord;

	private Coroutine coru_timecount;

	private bool isTimeOUT;

	private bool recResult;

	private void Start()
	{
		m_audioRecCtrl.gameObject.SetActive(value: false);
		m_txtWordShow.text = "";
		m_txtSTip.text = "";
		m_txtSimilerRate.text = "";
		m_objRepeatCount.SetActive(value: false);
		InitAllWords();
	}

	public void J_StartPlay()
	{
		m_curWordState = ewordState.词语;
		m_iScore = 0;
		m_txtScore.text = "";
		irightCount = 0;
		Text[] componentsInChildren = m_containerRightWords.GetComponentsInChildren<Text>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			componentsInChildren[i].text = "";
		}
		takeNextWord();
	}

	private void OnDestroy()
	{
	}

	public void takeNextWord()
	{
		StopAllCoroutines();
		m_txtSTip.text = "";
		m_txtSimilerRate.text = "";
		m_objRepeatCount.SetActive(value: false);
		m_txtWordTitle.text = Enum.GetName(typeof(ewordState), m_curWordState) + "篇";
		List<string> list = m_dicAllWords[m_curWordState];
		m_repeatWord = list[UnityEngine.Random.Range(0, list.Count)];
		m_txtWordShow.text = m_repeatWord;
		UnityEngine.Debug.LogWarning("--get audio");
		BaiduWordToVoiceBase.J_GetAudio(m_repeatWord, delegate(AudioClip audio)
		{
			StartCoroutine(yieldTryRecWords(audio));
		});
	}

	private IEnumerator yieldTryRecWords(AudioClip audio)
	{
		m_wordAudio.clip = audio;
		if (m_wordAudio.clip != null)
		{
			m_wordAudio.Play();
			float length = audio.length;
			yield return new WaitForSecondsRealtime((length < 1.5f) ? 1.5f : length);
		}
		else
		{
			yield return new WaitForSecondsRealtime(2f);
		}
		UnityEngine.Debug.LogWarning("--start rec");
		m_audioRecCtrl.gameObject.SetActive(value: true);
		m_audioRecCtrl.J_StartRec(oneSentence: true);
		float minSimillarRate = 0.5f;
		switch (m_curWordState)
		{
		case ewordState.词语:
			minSimillarRate = 0.5f;
			break;
		case ewordState.成语:
			minSimillarRate = 0.6f;
			break;
		case ewordState.短语:
			minSimillarRate = 0.7f;
			break;
		case ewordState.句子:
			minSimillarRate = 0.8f;
			break;
		}
		recResult = false;
		if (audio != null)
		{
			coru_timecount = StartCoroutine(yieldRepeatCountTime(audio.length + 5f));
		}
		else
		{
			coru_timecount = StartCoroutine(yieldRepeatCountTime((float)m_repeatWord.Length * 0.7f + 5f));
		}
		m_audioRecCtrl.actionOnRecStopped = delegate(string strrecogedwords)
		{
			UnityEngine.Debug.LogWarning("rec stop");
			if (!isTimeOUT)
			{
				recResult = true;
				if (coru_timecount != null)
				{
					StopCoroutine(coru_timecount);
					m_objRepeatCount.SetActive(value: false);
				}
				double levenshteinDistance = J_Utility.getLevenshteinDistance(strrecogedwords.Replace("，", "").Replace(",", ""), m_repeatWord.Replace("，", "").Replace(",", "").Replace("\"", ""));
				double num = 1.0 - levenshteinDistance;
				m_txtSimilerRate.text = "相似度：" + (num * 100.0).ToString("f2") + "%";
				if (num > (double)minSimillarRate)
				{
					m_txtSTip.J_MakeShowResult(J_PlayResult.Result.Succeed);
					m_iScore++;
					m_txtScore.text = m_iScore.ToString();
					m_containerRightWords.GetChild(irightCount).GetComponent<Text>().text = ((strrecogedwords.Length > 8) ? (strrecogedwords.Substring(0, 8) + "...") : strrecogedwords);
					irightCount++;
					if (irightCount >= 5)
					{
						Text[] componentsInChildren = m_containerRightWords.GetComponentsInChildren<Text>();
						for (int i = 0; i < componentsInChildren.Length; i++)
						{
							componentsInChildren[i].text = "";
						}
						m_curWordState++;
						irightCount = 0;
						if (m_curWordState > ewordState.句子)
						{
							m_canvasResult.SetActive(value: true);
							return;
						}
					}
				}
				else
				{
					m_txtSTip.J_MakeShowResult(J_PlayResult.Result.Failed);
				}
				m_audioRecCtrl.J_StopRec();
				Invoke("takeNextWord", 3f);
			}
		};
		yield return null;
	}

	private IEnumerator yieldRepeatCountTime(float fSeconds)
	{
		isTimeOUT = false;
		m_objRepeatCount.SetActive(value: true);
		m_imgRepeatTimeCountDown.fillAmount = 1f;
		float ftimer = fSeconds;
		while (!recResult && ftimer > 0f)
		{
			ftimer -= Time.deltaTime;
			m_imgRepeatTimeCountDown.fillAmount = ftimer / fSeconds;
			yield return new WaitForFixedUpdate();
		}
		m_objRepeatCount.SetActive(value: false);
		m_txtWordShow.text = "";
		if (!recResult)
		{
			isTimeOUT = true;
			m_audioRecCtrl.J_StopRec();
			m_txtSTip.J_MakeShowResult(J_PlayResult.Result.TimeOut);
			Invoke("takeNextWord", 3f);
		}
	}

	private void InitAllWords()
	{
		string text = "--词语:";
		string text2 = "--成语:";
		string text3 = "--短语:";
		string text4 = "--句子:";
		TextAsset textAsset = Resources.Load<TextAsset>("SpeechRepeatWords");
		int num = textAsset.text.IndexOf(text);
		int num2 = textAsset.text.IndexOf(text2);
		int num3 = textAsset.text.IndexOf(text3);
		int num4 = textAsset.text.IndexOf(text4);
		m_dicAllWords.Add(ewordState.词语, _getWords(textAsset.text, num + text.Length, num2));
		m_dicAllWords.Add(ewordState.成语, _getWords(textAsset.text, num2 + text2.Length, num3));
		m_dicAllWords.Add(ewordState.短语, _getSentences(textAsset.text, num3 + text3.Length, num4));
		m_dicAllWords.Add(ewordState.句子, _getSentences(textAsset.text, num4 + text4.Length, textAsset.text.Length));
	}

	private List<string> _getWords(string strWords, int startIndex, int endindex)
	{
		List<string> list = new List<string>();
		string[] array = strWords.Substring(startIndex, endindex - startIndex).Replace("\n", "、").Split('、');
		foreach (string text in array)
		{
			if (!string.IsNullOrEmpty(text.Trim()))
			{
				list.Add(text);
			}
		}
		return list;
	}

	private List<string> _getSentences(string strWords, int startIndex, int endindex)
	{
		List<string> list = new List<string>();
		string[] array = strWords.Substring(startIndex, endindex - startIndex).Split('\n');
		foreach (string text in array)
		{
			if (!string.IsNullOrEmpty(text.Trim()))
			{
				list.Add(text);
			}
		}
		return list;
	}
}
public class SpeechRecWordsCtrl : BaiduAudioRecBase
{
	public Text txtResult;

	[HideInInspector]
	public string m_recogedWords = "";

	public Action actionOnRecStopped;

	private void Start()
	{
		if (txtResult != null)
		{
			txtResult.text = "";
		}
	}

	public void J_StartRec(int iMiliSecondStop = 2000)
	{
		StartVoiceRec(iMiliSecondStop);
		if (txtResult != null)
		{
			txtResult.text = "";
		}
	}

	public void J_StopRec()
	{
		StopVoiceRec();
	}

	protected override void OnRecStateChange(string msg)
	{
		if (!(msg == "start"))
		{
			if (msg == "stop")
			{
				UnityEngine.Debug.Log("-- baidu voice rec stopped");
				actionOnRecStopped();
			}
			else
			{
				UnityEngine.Debug.LogError("--unkonw state:" + msg);
			}
		}
		else
		{
			UnityEngine.Debug.Log("--baidu voice rec started");
		}
	}

	public override void OnReceivedRecResult(M_BaiduAudioRecResult recResult)
	{
		UnityEngine.Debug.Log(recResult.error);
		if (recStart)
		{
			m_recogedWords = recResult.best_result.Replace(",", "");
		}
		if (txtResult != null)
		{
			txtResult.text = m_recogedWords;
		}
	}
}
public class ColorIdentifyManager : MonoBehaviour
{
	[Serializable]
	public class cChiarColor
	{
		public string colorName;

		public Color colorRGB;
	}

	public class cChair : MonoBehaviour
	{
		public bool isRightChair;

		public MeshRenderer matrenderChair;

		public Text txtColor;

		public monoChairClickEvent chairTigger;
	}

	public class monoChairClickEvent : MonoBehaviour, IHandRayPointerDown
	{
		public Action onPointerDown;

		public void OnHandPointerDown(WaveVR_HandRayGrabber hand)
		{
			if (onPointerDown != null)
			{
				onPointerDown();
			}
		}
	}

	public int m_iCurLevel = 1;

	public Text m_txtLevel;

	public cChiarColor[] listChiarColors;

	private ArrayList _listChairColorNames = new ArrayList();

	public GameObject prefabAnchairChair;

	public MeshRenderer origiChairMat;

	public _ClockTimer m_Clock;

	public GameObject canvasPlayAgain;

	public Text txtplayagain;

	public AudioSource audioSourceCorrect;

	public AudioSource audioSourceError;

	private float fChairAngle = 22f;

	private int maxChairNum = 10;

	private int iCorrectChairCount;

	private List<GameObject> _listBornChairs = new List<GameObject>();

	private void Start()
	{
		cChair cChair = prefabAnchairChair.AddComponent<cChair>();
		cChair.matrenderChair = origiChairMat;
		cChair.chairTigger = prefabAnchairChair.gameObject.AddComponent<monoChairClickEvent>();
		cChair.txtColor = prefabAnchairChair.transform.Find("椅子/Canvas/Image/Text").GetComponent<Text>();
		prefabAnchairChair.SetActive(value: false);
		for (int i = 0; i < listChiarColors.Length; i++)
		{
			listChiarColors[i].colorRGB.a = 1f;
			_listChairColorNames.Add(listChiarColors[i].colorName);
		}
		canvasPlayAgain.SetActive(value: false);
		m_Clock.gameObject.SetActive(value: false);
		m_Clock.eventOnTimerOver.AddListener(J_TimeReached);
	}

	private cChiarColor Random_GetAChairColor()
	{
		return listChiarColors[UnityEngine.Random.Range(0, listChiarColors.Length)];
	}

	private string Random_GetAChairColorName(string exceptName = null)
	{
		ArrayList arrayList = (ArrayList)_listChairColorNames.Clone();
		if (exceptName != null)
		{
			arrayList.Remove(exceptName);
		}
		return (string)arrayList[UnityEngine.Random.Range(0, arrayList.Count)];
	}

	private Color Random_ChairColor()
	{
		return listChiarColors[UnityEngine.Random.Range(0, listChiarColors.Length)].colorRGB;
	}

	public void J_StartPlay()
	{
		_listBornChairs.Clear();
		int num = (m_iCurLevel + 1) / 2 + 1;
		if (num > maxChairNum)
		{
			num = maxChairNum;
		}
		iCorrectChairCount = 0;
		int num2 = UnityEngine.Random.Range(0, num);
		for (int i = 0; i < num; i++)
		{
			GameObject gameObject = UnityEngine.Object.Instantiate(prefabAnchairChair);
			_listBornChairs.Add(gameObject);
			gameObject.SetActive(value: true);
			gameObject.transform.SetParent(prefabAnchairChair.transform.parent);
			gameObject.transform.position = prefabAnchairChair.transform.position;
			float num3 = (float)((i + 1) / 2) * fChairAngle;
			gameObject.transform.localEulerAngles = new Vector3(0f, (i % 2 == 1) ? (num3 - fChairAngle / 2f) : (0f - num3 - fChairAngle / 2f), 0f);
			cChair component = gameObject.GetComponent<cChair>();
			cChiarColor cChiarColor = Random_GetAChairColor();
			component.matrenderChair.material.color = cChiarColor.colorRGB;
			if (m_iCurLevel < 3)
			{
				component.txtColor.color = cChiarColor.colorRGB;
			}
			else
			{
				component.txtColor.color = Random_ChairColor();
			}
			component.isRightChair = UnityEngine.Random.value < 0.5f;
			if (i == num2)
			{
				component.isRightChair = true;
			}
			if (component.isRightChair)
			{
				component.txtColor.text = cChiarColor.colorName;
				iCorrectChairCount++;
			}
			else
			{
				component.txtColor.text = Random_GetAChairColorName(cChiarColor.colorName);
			}
		}
		float num4 = 60f - (float)m_iCurLevel * 3f;
		float num5 = (float)num * 2f + (float)iCorrectChairCount * 2f + 4f;
		if (num4 < num5)
		{
			num4 = num5;
		}
		m_Clock.ftimer = num4;
		m_Clock.gameObject.SetActive(value: true);
	}

	private void onResultRight()
	{
		UnityEngine.Debug.Log("--right");
		_ClearChairs();
		m_Clock.gameObject.SetActive(value: false);
		m_iCurLevel++;
		canvasPlayAgain.SetActive(value: true);
		txtplayagain.J_MakeShowResult(J_PlayResult.Result.Succeed);
		m_txtLevel.text = string.Concat(m_iCurLevel);
	}

	private void onResultWrong()
	{
		UnityEngine.Debug.Log("--wrong");
		audioSourceError.Play();
		_ClearChairs();
		m_Clock.gameObject.SetActive(value: false);
		if (m_iCurLevel - 1 < 0)
		{
			m_iCurLevel = 0;
		}
		canvasPlayAgain.SetActive(value: true);
		txtplayagain.J_MakeShowResult(J_PlayResult.Result.Failed);
		m_txtLevel.text = string.Concat(m_iCurLevel);
	}

	private void _ClearChairs()
	{
		for (int num = _listBornChairs.Count - 1; num >= 0; num--)
		{
			UnityEngine.Object.Destroy(_listBornChairs[num].gameObject);
		}
		_listBornChairs.Clear();
	}

	private void J_TimeReached()
	{
		onResultWrong();
	}

	private void onclick(cChair tempChairCTrl)
	{
		GameObject gameObject = tempChairCTrl.gameObject;
		if (tempChairCTrl.isRightChair)
		{
			audioSourceCorrect.Play();
			iCorrectChairCount--;
			_listBornChairs.Remove(gameObject);
			UnityEngine.Object.Destroy(gameObject);
			if (iCorrectChairCount <= 0)
			{
				onResultRight();
			}
		}
		else
		{
			onResultWrong();
		}
	}

	private void Update()
	{
		if (Pvr.IsMainKeyDown() && Physics.Raycast(Pvr.GetXunlianRay(), out var hitInfo, 100f, 1024))
		{
			onclick(hitInfo.transform.parent.parent.parent.gameObject.GetComponent<cChair>());
		}
	}
}
public class MainStreet_RouteManager : MonoBehaviour
{
	[Serializable]
	public class cGpsMapAnchor
	{
		private Vector3 vAreaRight;

		private Vector3 vAreaForward;

		[Header("左下角，forward为方向")]
		public Transform leftBottom;

		public Transform rightTop;

		public Vector3 FromWorldToScreenPoint(Vector3 vPos)
		{
			vAreaRight = Vector3.Dot(rightTop.position - leftBottom.position, leftBottom.right) * leftBottom.right;
			vAreaForward = Vector3.Dot(rightTop.position - leftBottom.position, leftBottom.forward) * leftBottom.forward;
			float x = Vector3.Dot(vPos - leftBottom.position, leftBottom.right) / vAreaRight.magnitude;
			float y = Vector3.Dot(vPos - leftBottom.position, leftBottom.forward) / vAreaForward.magnitude;
			return new Vector2(x, y);
		}

		public Vector3 FromScreenToWorldPoint(Vector2 vScreenRate)
		{
			vAreaRight = Vector3.Dot(rightTop.position - leftBottom.position, leftBottom.right) * leftBottom.right;
			vAreaForward = Vector3.Dot(rightTop.position - leftBottom.position, leftBottom.forward) * leftBottom.forward;
			return leftBottom.position + (vAreaRight * vScreenRate.x + vAreaForward * vScreenRate.y);
		}
	}

	public cGpsMapAnchor worldMapGPS;

	public cGpsMapAnchor uiMapGPS;

	[Header("地图")]
	public GameObject m_MapLock;

	public Transform m_anchorMe;

	public int timeCountDown = 5;

	public Text m_txtTimeCount;

	public float fReachMinDis = 8f;

	public Transform m_anchorUITargetPoint;

	public Transform targetPointsContainer;

	private Transform targetReachPoint;

	[Header("结果")]
	public float m_fMaxRouteTime = 60f;

	public GameObject m_canvasResult;

	public Text m_txtResultState;

	private Transform m_camHead;

	private Coroutine coroutineTimeCountDown;

	private bool bReachTargetPoint;

	private void Start()
	{
		if ((bool)WaveVRHead.Inst)
		{
			m_camHead = WaveVRHead.Inst.headCam;
		}
		if (m_camHead == null)
		{
			m_camHead = Camera.main.transform;
		}
		m_MapLock.SetActive(value: false);
		m_canvasResult.gameObject.SetActive(value: false);
		for (int i = 0; i < targetPointsContainer.childCount; i++)
		{
			targetPointsContainer.GetChild(i).gameObject.SetActive(value: false);
		}
		J_WaveVR_CurveRayTeleport.J_SetTeleportHandEnable(isEnable: false);
	}

	public void J_REPLAY()
	{
		StopAllCoroutines();
		J_WaveVR_CurveRayTeleport.J_SetTeleportHandEnable(isEnable: false);
		UnityEngine.Object.FindObjectOfType<WaveVRHeadReset>().J_ResetPos();
		J_StartPlay();
	}

	private void OnDestroy()
	{
		StopAllCoroutines();
	}

	public void J_StartPlay()
	{
		bReachTargetPoint = false;
		int index = UnityEngine.Random.Range(0, targetPointsContainer.childCount);
		for (int i = 0; i < targetPointsContainer.childCount; i++)
		{
			targetPointsContainer.GetChild(i).gameObject.SetActive(value: false);
		}
		targetReachPoint = targetPointsContainer.GetChild(index).transform;
		targetReachPoint.gameObject.SetActive(value: true);
		m_anchorUITargetPoint.transform.position = uiMapGPS.FromScreenToWorldPoint(worldMapGPS.FromWorldToScreenPoint(targetReachPoint.position));
		J_WaveVR_CurveRayTeleport.J_SetTeleportHandEnable(isEnable: true);
		coroutineTimeCountDown = StartCoroutine(yieldCountTimeDown(60));
		m_MapLock.SetActive(value: true);
	}

	private IEnumerator yieldCountTimeDown(int iTimeCount)
	{
		int i = iTimeCount;
		while (i >= 0)
		{
			m_txtTimeCount.text = string.Concat(i);
			yield return new WaitForSeconds(1f);
			int num = i - 1;
			i = num;
		}
		bReachTargetPoint = false;
		m_canvasResult.SetActive(value: true);
		setResultCanavasPos();
		m_txtResultState.J_MakeShowResult(J_PlayResult.Result.TimeOut);
	}

	private void Update()
	{
		if (!bReachTargetPoint)
		{
			if (targetReachPoint != null && Vector3.Distance(targetReachPoint.position, m_camHead.position) < 8f)
			{
				targetReachPoint.gameObject.SetActive(value: false);
				targetReachPoint = null;
				bReachTargetPoint = true;
				_ReachTargetPoint();
			}
			if (m_camHead != null)
			{
				m_MapLock.transform.position = m_camHead.position;
				m_MapLock.transform.rotation = m_camHead.rotation;
				m_anchorMe.transform.localEulerAngles = new Vector3(0f, 0f, 0f - m_camHead.eulerAngles.y);
				m_anchorMe.transform.position = uiMapGPS.FromScreenToWorldPoint(worldMapGPS.FromWorldToScreenPoint(m_camHead.position));
			}
		}
	}

	private void _ReachTargetPoint()
	{
		bReachTargetPoint = true;
		m_canvasResult.SetActive(value: true);
		m_MapLock.SetActive(value: false);
		setResultCanavasPos();
		m_txtResultState.J_MakeShowResult(J_PlayResult.Result.Succeed);
	}

	private void setResultCanavasPos()
	{
		J_WaveVR_CurveRayTeleport.J_SetTeleportHandEnable(isEnable: false);
		Vector3 forward = m_camHead.forward;
		forward.y = 0f;
		m_canvasResult.transform.position = m_camHead.position + forward.normalized * 1.5f;
		m_canvasResult.transform.forward = forward.normalized;
	}
}
public class iconGoodNum : MonoBehaviour
{
	public bool m_bSelected;

	public int m_iGoodIndex;
}
public class ListenMemoryManager_Buy : MonoBehaviour
{
	public int m_iScore;

	private int iMinCount = 2;

	private int iMaxCount = 9;

	private static readonly string prefString_Score = "ViewMemoryBuy_Score_Listen";

	public List<Texture2D> listFruitTextures;

	private int[] listArray;

	public GameObject m_canvasGameStart;

	[Header("购物清单")]
	public GameObject m_canvaBuyList;

	public Transform transContainer_BuyList;

	public UnityEngine.Object icon_buylist;

	public Text m_txtTimeCount;

	public int timeCountDown = 5;

	[Header("一段音乐")]
	public AudioSource audioSourceMusic;

	[Header("全部菜单")]
	public GameObject m_canvaAllItemsList;

	public Transform transContainer_allitemsList;

	public UnityEngine.Object iconBtn_menu;

	[Header("购物篮")]
	public GameObject m_canvasCart;

	public Transform transContainer_cart;

	public Button m_btnSubmit;

	[Header("结果")]
	public GameObject m_canvasResult;

	public Text m_txtResultState;

	private AudioSource audioWordsPlay;

	private List<int> listRightGoodItems;

	private List<int> listSelectedGood = new List<int>();

	private static UnityEngine.Random random = new UnityEngine.Random();

	private AudioSource m_audioWordsPlay
	{
		get
		{
			if (audioWordsPlay == null)
			{
				audioWordsPlay = base.gameObject.AddComponent<AudioSource>();
			}
			return audioWordsPlay;
		}
	}

	private void Start()
	{
		m_iScore = PlayerPrefs.GetInt(prefString_Score);
		listArray = new int[listFruitTextures.Count];
		for (int i = 0; i < listArray.Length; i++)
		{
			listArray[i] = i;
		}
		m_canvasGameStart.SetActive(value: true);
		m_canvaBuyList.SetActive(value: false);
		m_canvaAllItemsList.SetActive(value: false);
		m_canvasCart.SetActive(value: false);
		m_canvasResult.SetActive(value: false);
		m_btnSubmit.onClick.AddListener(CheckResult);
	}

	public void J_StartGame()
	{
		m_canvaBuyList.SetActive(value: false);
		m_canvaAllItemsList.SetActive(value: false);
		m_canvasCart.SetActive(value: false);
		m_canvasResult.SetActive(value: false);
		m_canvasGameStart.SetActive(value: false);
		for (int num = transContainer_BuyList.childCount - 1; num >= 0; num--)
		{
			UnityEngine.Object.Destroy(transContainer_BuyList.GetChild(num).gameObject);
		}
		int irandomCount = Mathf.Clamp(m_iScore, 0, iMaxCount - iMinCount) + iMinCount;
		listRightGoodItems = RandomNums(listArray, irandomCount);
		string text = "请购买 ";
		foreach (int listRightGoodItem in listRightGoodItems)
		{
			GameObject obj = UnityEngine.Object.Instantiate(icon_buylist) as GameObject;
			obj.SetActive(value: true);
			obj.transform.SetParent(transContainer_BuyList);
			obj.transform.localPosition = Vector3.zero;
			obj.transform.localEulerAngles = Vector3.zero;
			obj.transform.localScale = Vector3.one;
			obj.GetComponentInChildren<RawImage>().texture = listFruitTextures[listRightGoodItem];
			string text2 = listFruitTextures[listRightGoodItem].name;
			obj.GetComponentInChildren<Text>().text = text2;
			text = text + text2 + "、";
		}
		m_canvaBuyList.SetActive(value: false);
		BaiduWordToVoiceBase.J_GetAudio(text, delegate(AudioClip audioclip)
		{
			if (audioclip != null)
			{
				StartCoroutine(yieldPlayWordsA(audioclip));
			}
		});
	}

	private IEnumerator yieldCountTimeDown(int iTimeCount)
	{
		int i = iTimeCount;
		while (i >= 0)
		{
			m_txtTimeCount.text = string.Concat(i);
			yield return new WaitForSeconds(1f);
			int num = i - 1;
			i = num;
		}
		StartCoroutine(yieldPlayMusic());
	}

	private IEnumerator yieldPlayWordsA(AudioClip audioClip)
	{
		m_audioWordsPlay.clip = audioClip;
		m_audioWordsPlay.Play();
		yield return new WaitForSeconds(audioClip.length + 1f);
		StartCoroutine(yieldPlayMusic());
	}

	private IEnumerator yieldPlayMusic()
	{
		m_canvaBuyList.SetActive(value: false);
		audioSourceMusic.Play();
		yield return new WaitForSeconds(m_iScore + 2);
		audioSourceMusic.Stop();
		ShowAllCartItems();
	}

	private void ShowAllCartItems()
	{
		listSelectedGood.Clear();
		m_canvaAllItemsList.SetActive(value: true);
		for (int num = transContainer_allitemsList.childCount - 1; num >= 0; num--)
		{
			UnityEngine.Object.Destroy(transContainer_allitemsList.GetChild(num).gameObject);
		}
		for (int i = 0; i < listFruitTextures.Count; i++)
		{
			int iindex = i;
			GameObject tempobj = UnityEngine.Object.Instantiate(iconBtn_menu) as GameObject;
			tempobj.SetActive(value: true);
			tempobj.transform.SetParent(transContainer_allitemsList);
			tempobj.transform.localPosition = Vector3.zero;
			tempobj.transform.localEulerAngles = Vector3.zero;
			tempobj.transform.localScale = Vector3.one;
			tempobj.GetComponent<RawImage>().texture = listFruitTextures[i];
			tempobj.GetComponentInChildren<Text>().text = listFruitTextures[i].name;
			tempobj.GetComponent<iconGoodNum>().m_iGoodIndex = iindex;
			tempobj.GetComponent<Button>().onClick.AddListener(delegate
			{
				UnityEngine.Debug.Log(iindex);
				iconGoodNum component = tempobj.GetComponent<iconGoodNum>();
				if (!component.m_bSelected)
				{
					if (listSelectedGood.Count < listRightGoodItems.Count)
					{
						component.m_bSelected = true;
						tempobj.GetComponent<RawImage>().color = Color.gray;
						listSelectedGood.Add(iindex);
						setCartItems();
					}
				}
				else
				{
					component.m_bSelected = false;
					tempobj.GetComponent<RawImage>().color = Color.white;
					listSelectedGood.Remove(iindex);
					setCartItems();
				}
			});
		}
		m_canvasCart.SetActive(value: true);
		for (int num2 = transContainer_cart.childCount - 1; num2 >= 0; num2--)
		{
			UnityEngine.Object.Destroy(transContainer_cart.GetChild(num2).gameObject);
		}
		for (int j = 0; j < listRightGoodItems.Count; j++)
		{
			GameObject obj = UnityEngine.Object.Instantiate(iconBtn_menu) as GameObject;
			obj.SetActive(value: true);
			obj.transform.SetParent(transContainer_cart);
			obj.transform.localPosition = Vector3.zero;
			obj.transform.localEulerAngles = Vector3.zero;
			obj.transform.localScale = Vector3.one;
			obj.GetComponent<RawImage>().texture = null;
			obj.GetComponentInChildren<Text>().text = "";
			obj.GetComponent<Button>().interactable = false;
		}
		m_btnSubmit.interactable = false;
	}

	private void setCartItems()
	{
		for (int i = 0; i < listRightGoodItems.Count; i++)
		{
			if (i < listSelectedGood.Count)
			{
				int igoodIndex = listSelectedGood[i];
				Transform child = transContainer_cart.GetChild(i);
				child.GetComponent<RawImage>().texture = listFruitTextures[igoodIndex];
				child.GetComponentInChildren<Text>().text = listFruitTextures[igoodIndex].name;
				child.GetComponent<iconGoodNum>().m_iGoodIndex = igoodIndex;
				Button component = child.GetComponent<Button>();
				component.interactable = true;
				component.onClick.RemoveAllListeners();
				component.onClick.AddListener(delegate
				{
					listSelectedGood.Remove(igoodIndex);
					Transform child3 = transContainer_allitemsList.GetChild(igoodIndex);
					child3.GetComponent<RawImage>().color = Color.white;
					child3.GetComponent<iconGoodNum>().m_bSelected = false;
					setCartItems();
				});
			}
			else
			{
				Transform child2 = transContainer_cart.GetChild(i);
				child2.GetComponent<RawImage>().texture = null;
				child2.GetComponentInChildren<Text>().text = "";
				Button component2 = child2.GetComponent<Button>();
				component2.interactable = false;
				component2.onClick.RemoveAllListeners();
			}
		}
		m_btnSubmit.interactable = listSelectedGood.Count == listRightGoodItems.Count;
	}

	private void CheckResult()
	{
		bool flag = true;
		foreach (int listRightGoodItem in listRightGoodItems)
		{
			if (!listSelectedGood.Contains(listRightGoodItem))
			{
				flag = false;
			}
		}
		if (flag)
		{
			m_txtResultState.J_MakeShowResult(J_PlayResult.Result.Succeed);
			if (m_iScore + 1 < iMaxCount - iMinCount)
			{
				m_iScore++;
			}
		}
		else
		{
			m_txtResultState.J_MakeShowResult(J_PlayResult.Result.Failed);
			if (--m_iScore < 0)
			{
				m_iScore = 0;
			}
		}
		PlayerPrefs.SetInt(prefString_Score, m_iScore);
		m_canvaAllItemsList.SetActive(value: false);
		m_canvasCart.SetActive(value: false);
		m_canvasResult.SetActive(value: true);
	}

	public static List<int> RandomNums(int[] nums, int irandomCount)
	{
		if (irandomCount > nums.Length)
		{
			UnityEngine.Debug.LogError("too much");
			return null;
		}
		List<int> list = nums.ToList();
		List<int> list2 = new List<int>();
		while (list2.Count < irandomCount)
		{
			int index = UnityEngine.Random.Range(0, list.Count);
			int item = list[index];
			list.RemoveAt(index);
			list2.Add(item);
		}
		return list2;
	}
}
public class ViewMemoryManager_Buy : MonoBehaviour
{
	public int m_iScore;

	private int iMinCount = 2;

	private int iMaxCount = 9;

	private static readonly string prefString_Score = "ViewMemoryBuy_Score";

	public List<Texture2D> listFruitTextures;

	private int[] listArray;

	public GameObject m_canvasGameStart;

	[Header("购物清单")]
	public GameObject m_canvaBuyList;

	public Transform transContainer_BuyList;

	public UnityEngine.Object icon_buylist;

	public Text m_txtTimeCount;

	[Header("一段音乐")]
	public AudioSource audioSourceMusic;

	[Header("全部菜单")]
	public GameObject m_canvaAllItemsList;

	public Transform transContainer_allitemsList;

	public UnityEngine.Object iconBtn_menu;

	[Header("购物篮")]
	public GameObject m_canvasCart;

	public Transform transContainer_cart;

	public Button m_btnSubmit;

	[Header("结果")]
	public GameObject m_canvasResult;

	public Text m_txtResultState;

	private List<int> listRightGoodItems;

	private List<int> listSelectedGood = new List<int>();

	private void Start()
	{
		m_iScore = PlayerPrefs.GetInt(prefString_Score);
		listArray = new int[listFruitTextures.Count];
		for (int i = 0; i < listArray.Length; i++)
		{
			listArray[i] = i;
		}
		m_canvasGameStart.SetActive(value: true);
		m_canvaBuyList.SetActive(value: false);
		m_canvaAllItemsList.SetActive(value: false);
		m_canvasCart.SetActive(value: false);
		m_canvasResult.SetActive(value: false);
		m_btnSubmit.onClick.AddListener(CheckResult);
	}

	public void J_StartGame()
	{
		m_canvaBuyList.SetActive(value: false);
		m_canvaAllItemsList.SetActive(value: false);
		m_canvasCart.SetActive(value: false);
		m_canvasResult.SetActive(value: false);
		m_canvasGameStart.SetActive(value: false);
		for (int num = transContainer_BuyList.childCount - 1; num >= 0; num--)
		{
			UnityEngine.Object.Destroy(transContainer_BuyList.GetChild(num).gameObject);
		}
		int count = Mathf.Clamp(m_iScore, 0, iMaxCount - iMinCount) + iMinCount;
		listRightGoodItems = listArray.OrderBy((int c) => Guid.NewGuid()).Take(count).ToList();
		foreach (int listRightGoodItem in listRightGoodItems)
		{
			GameObject obj = UnityEngine.Object.Instantiate(icon_buylist) as GameObject;
			obj.SetActive(value: true);
			obj.transform.SetParent(transContainer_BuyList);
			obj.transform.localPosition = Vector3.zero;
			obj.transform.localEulerAngles = Vector3.zero;
			obj.transform.localScale = Vector3.one;
			obj.GetComponentInChildren<RawImage>().texture = listFruitTextures[listRightGoodItem];
			obj.GetComponentInChildren<Text>().text = listFruitTextures[listRightGoodItem].name;
		}
		m_canvaBuyList.SetActive(value: true);
		StartCoroutine(yieldCountTimeDown(3 + listRightGoodItems.Count));
	}

	private IEnumerator yieldCountTimeDown(int iTimeCount)
	{
		int i = iTimeCount;
		while (i >= 0)
		{
			m_txtTimeCount.text = string.Concat(i);
			yield return new WaitForSeconds(1f);
			int num = i - 1;
			i = num;
		}
		StartCoroutine(yieldPlayMusic());
	}

	private IEnumerator yieldPlayMusic()
	{
		m_canvaBuyList.SetActive(value: false);
		audioSourceMusic.Play();
		yield return new WaitForSeconds((float)m_iScore * 2f + 2f);
		audioSourceMusic.Stop();
		ShowAllCartItems();
	}

	private void ShowAllCartItems()
	{
		listSelectedGood.Clear();
		m_canvaAllItemsList.SetActive(value: true);
		for (int num = transContainer_allitemsList.childCount - 1; num >= 0; num--)
		{
			UnityEngine.Object.Destroy(transContainer_allitemsList.GetChild(num).gameObject);
		}
		for (int i = 0; i < listFruitTextures.Count; i++)
		{
			int iindex = i;
			GameObject tempobj = UnityEngine.Object.Instantiate(iconBtn_menu) as GameObject;
			tempobj.SetActive(value: true);
			tempobj.transform.SetParent(transContainer_allitemsList);
			tempobj.transform.localPosition = Vector3.zero;
			tempobj.transform.localEulerAngles = Vector3.zero;
			tempobj.transform.localScale = Vector3.one;
			tempobj.GetComponent<RawImage>().texture = listFruitTextures[i];
			tempobj.GetComponentInChildren<Text>().text = listFruitTextures[i].name;
			tempobj.GetComponent<iconGoodNum>().m_iGoodIndex = iindex;
			tempobj.GetComponent<Button>().onClick.AddListener(delegate
			{
				UnityEngine.Debug.Log(iindex);
				iconGoodNum component = tempobj.GetComponent<iconGoodNum>();
				if (!component.m_bSelected)
				{
					if (listSelectedGood.Count < listRightGoodItems.Count)
					{
						component.m_bSelected = true;
						tempobj.GetComponent<RawImage>().color = Color.gray;
						listSelectedGood.Add(iindex);
						setCartItems();
					}
				}
				else
				{
					component.m_bSelected = false;
					tempobj.GetComponent<RawImage>().color = Color.white;
					listSelectedGood.Remove(iindex);
					setCartItems();
				}
			});
		}
		m_canvasCart.SetActive(value: true);
		for (int num2 = transContainer_cart.childCount - 1; num2 >= 0; num2--)
		{
			UnityEngine.Object.Destroy(transContainer_cart.GetChild(num2).gameObject);
		}
		for (int j = 0; j < listRightGoodItems.Count; j++)
		{
			GameObject obj = UnityEngine.Object.Instantiate(iconBtn_menu) as GameObject;
			obj.SetActive(value: true);
			obj.transform.SetParent(transContainer_cart);
			obj.transform.localPosition = Vector3.zero;
			obj.transform.localEulerAngles = Vector3.zero;
			obj.transform.localScale = Vector3.one;
			obj.GetComponent<RawImage>().texture = null;
			obj.GetComponentInChildren<Text>().text = "";
			obj.GetComponent<Button>().interactable = false;
		}
		m_btnSubmit.interactable = false;
	}

	private void setCartItems()
	{
		for (int i = 0; i < listRightGoodItems.Count; i++)
		{
			if (i < listSelectedGood.Count)
			{
				int igoodIndex = listSelectedGood[i];
				Transform child = transContainer_cart.GetChild(i);
				child.GetComponent<RawImage>().texture = listFruitTextures[igoodIndex];
				child.GetComponentInChildren<Text>().text = listFruitTextures[igoodIndex].name;
				child.GetComponent<iconGoodNum>().m_iGoodIndex = igoodIndex;
				Button component = child.GetComponent<Button>();
				component.interactable = true;
				component.onClick.RemoveAllListeners();
				component.onClick.AddListener(delegate
				{
					listSelectedGood.Remove(igoodIndex);
					Transform child3 = transContainer_allitemsList.GetChild(igoodIndex);
					child3.GetComponent<RawImage>().color = Color.white;
					child3.GetComponent<iconGoodNum>().m_bSelected = false;
					setCartItems();
				});
			}
			else
			{
				Transform child2 = transContainer_cart.GetChild(i);
				child2.GetComponent<RawImage>().texture = null;
				child2.GetComponentInChildren<Text>().text = "";
				Button component2 = child2.GetComponent<Button>();
				component2.interactable = false;
				component2.onClick.RemoveAllListeners();
			}
		}
		m_btnSubmit.interactable = listSelectedGood.Count == listRightGoodItems.Count;
	}

	private void CheckResult()
	{
		bool flag = true;
		foreach (int listRightGoodItem in listRightGoodItems)
		{
			if (!listSelectedGood.Contains(listRightGoodItem))
			{
				flag = false;
			}
		}
		if (flag)
		{
			m_txtResultState.J_MakeShowResult(J_PlayResult.Result.Succeed);
			if (m_iScore + 1 < iMaxCount - iMinCount)
			{
				m_iScore++;
			}
		}
		else
		{
			m_txtResultState.J_MakeShowResult(J_PlayResult.Result.Failed);
			if (--m_iScore < 0)
			{
				m_iScore = 0;
			}
		}
		PlayerPrefs.SetInt(prefString_Score, m_iScore);
		m_canvaAllItemsList.SetActive(value: false);
		m_canvasCart.SetActive(value: false);
		m_canvasResult.SetActive(value: true);
	}
}
public class NumsMemoryManager : MonoBehaviour
{
	public int m_iLevel;

	public Text m_txtLevel;

	[Header("字母显示")]
	public GameObject canvasLetterShow;

	public Text m_txtLetterShow;

	[Header("数字面板")]
	public NumsPadCtrl numsPadCtrl;

	[Header("结果")]
	public GameObject m_canvasResult;

	public Text m_txtResultState;

	public GameObject m_psScoreAdd;

	private string m_CorrectNums = "123456789";

	private string m_ElseLetters = "ABCDEFGHJKLMNPQRSTUVWXYZ";

	private string m_strCorrectNum;

	private int iLetterNumP = 3;

	private void Awake()
	{
		canvasLetterShow.SetActive(value: false);
		numsPadCtrl.gameObject.SetActive(value: false);
		m_canvasResult.SetActive(value: false);
	}

	public void J_StartPlay()
	{
		StartCoroutine(yieldShowLetters());
	}

	private IEnumerator yieldShowLetters()
	{
		m_psScoreAdd.SetActive(value: false);
		canvasLetterShow.SetActive(value: true);
		numsPadCtrl.gameObject.SetActive(value: false);
		m_txtLetterShow.text = "";
		m_strCorrectNum = null;
		string strShowLetters = "";
		int num = m_iLevel + 1;
		for (int j = 0; j < num; j++)
		{
			int startIndex = UnityEngine.Random.Range(0, 1 + iLetterNumP);
			string text = m_CorrectNums[UnityEngine.Random.Range(0, m_CorrectNums.Length)].ToString();
			m_strCorrectNum += text;
			string text2 = "";
			for (int k = 0; k < iLetterNumP; k++)
			{
				text2 += m_ElseLetters[UnityEngine.Random.Range(0, m_ElseLetters.Length)];
			}
			strShowLetters += text2.Insert(startIndex, text);
		}
		m_txtLetterShow.text = "注意";
		yield return new WaitForSeconds(1.5f);
		int i = 0;
		while (i < strShowLetters.Length)
		{
			m_txtLetterShow.text = strShowLetters[i].ToString();
			yield return new WaitForSeconds(0.5f);
			int num2 = i + 1;
			i = num2;
		}
		canvasLetterShow.SetActive(value: false);
		numsPadCtrl.gameObject.SetActive(value: true);
		numsPadCtrl.OnNumsSubmit(delegate(string nums)
		{
			numsPadCtrl.gameObject.SetActive(value: false);
			m_canvasResult.gameObject.SetActive(value: true);
			if (nums == m_strCorrectNum)
			{
				m_txtResultState.J_MakeShowResult(J_PlayResult.Result.Succeed);
				m_iLevel++;
				m_txtLevel.text = m_iLevel.ToString();
				m_txtLevel.color = Color.green;
				m_txtLevel.transform.DOScale(1.8f, 1f).OnComplete(delegate
				{
					m_txtLevel.transform.localScale = Vector3.one;
					m_txtLevel.color = Color.white;
				});
				m_psScoreAdd.SetActive(value: true);
			}
			else
			{
				m_txtResultState.J_MakeShowResult(J_PlayResult.Result.Failed);
				if (--m_iLevel < 0)
				{
					m_iLevel = 0;
				}
				m_txtLevel.text = m_iLevel.ToString();
				m_txtLevel.color = Color.red;
				m_txtLevel.transform.DOScale(1.8f, 1f).OnComplete(delegate
				{
					m_txtLevel.transform.localScale = Vector3.one;
					m_txtLevel.color = Color.white;
				});
			}
		});
	}
}
public class NumsPadCtrl : MonoBehaviour
{
	public delegate void delegateClickHandler();

	public Action<string> eventOnNumsSubmit;

	public Text m_txtNumsShow;

	public Button[] m_listButtons;

	public Button m_btnSubmit;

	private string m_strClickNums;

	private void Awake()
	{
		m_strClickNums = "";
		for (int i = 0; i < m_listButtons.Length; i++)
		{
			int iNum = i + 1;
			m_listButtons[i].GetComponentInChildren<Text>().text = iNum.ToString();
			m_listButtons[i].onClick.AddListener(delegate
			{
				m_strClickNums += iNum;
				m_txtNumsShow.text = m_strClickNums;
			});
		}
		m_btnSubmit.onClick.AddListener(delegate
		{
			if (eventOnNumsSubmit != null)
			{
				eventOnNumsSubmit(m_strClickNums);
			}
		});
	}

	public void OnEnable()
	{
		m_strClickNums = "";
		m_txtNumsShow.text = m_strClickNums;
	}

	public void OnNumsSubmit(Action<string> callback)
	{
		eventOnNumsSubmit = callback;
	}
}
public class PicturesFlowManager : MonoBehaviour
{
	[Serializable]
	public class cPicFlow
	{
		[Serializable]
		public class cSinglePic
		{
			public string picTip;

			public Texture2D picTexture;
		}

		public string strFlowName;

		public cSinglePic[] flowPictures;
	}

	public class cTempIconMono : MonoBehaviour
	{
		public int irightFlowIndex;

		public int iClickedFlowIndex;

		public RawImage rawIconPic;

		public Text txtTip;

		public GameObject objClicked;

		public Text txtClickedNum;
	}

	public cPicFlow[] listFlows;

	[Header("流程canvas")]
	public GameObject canvasMainFlow;

	public Text m_txtMainFlow_Title;

	public Text m_txtRealFlowTips;

	public Transform m_iconsContainer;

	[Header("再来一次")]
	public GameObject canvasPlayAgain;

	public Text txtplayagain;

	public AudioSource audioSourceCorrect;

	public AudioSource audioSourceError;

	private List<cTempIconMono> listIcons = new List<cTempIconMono>();

	private bool lockShowingResult;

	private int iCurClickedNum;

	private int iMaxFlowNCount;

	private void Start()
	{
		canvasMainFlow.SetActive(value: false);
		canvasPlayAgain.SetActive(value: false);
		for (int i = 0; i < m_iconsContainer.childCount; i++)
		{
			Transform child = m_iconsContainer.GetChild(i);
			cTempIconMono icCtrl = child.gameObject.AddComponent<cTempIconMono>();
			listIcons.Add(icCtrl);
			icCtrl.rawIconPic = child.Find("picture").GetComponent<RawImage>();
			icCtrl.txtTip = child.Find("Text").GetComponent<Text>();
			icCtrl.objClicked = child.Find("ImageClick").gameObject;
			icCtrl.txtClickedNum = child.Find("ImageClick/Image/Text").GetComponent<Text>();
			child.GetComponent<Button>().onClick.AddListener(delegate
			{
				if (!lockShowingResult)
				{
					UnityEngine.Debug.LogWarning(icCtrl.irightFlowIndex);
					if (!icCtrl.objClicked.gameObject.activeInHierarchy)
					{
						iCurClickedNum++;
						icCtrl.objClicked.gameObject.SetActive(value: true);
						icCtrl.iClickedFlowIndex = iCurClickedNum;
						icCtrl.txtClickedNum.text = string.Concat(iCurClickedNum);
						if (iCurClickedNum >= iMaxFlowNCount)
						{
							CheckResult();
						}
					}
					else
					{
						iCurClickedNum--;
						icCtrl.objClicked.gameObject.SetActive(value: false);
					}
				}
			});
		}
	}

	private void CheckResult()
	{
		lockShowingResult = true;
		bool flag = true;
		foreach (cTempIconMono listIcon in listIcons)
		{
			if (listIcon.irightFlowIndex != listIcon.iClickedFlowIndex)
			{
				flag = false;
				break;
			}
		}
		m_txtRealFlowTips.gameObject.SetActive(value: true);
		if (flag)
		{
			audioSourceCorrect.Play();
			canvasPlayAgain.SetActive(value: true);
			txtplayagain.J_MakeShowResult(J_PlayResult.Result.Succeed);
		}
		else
		{
			audioSourceError.Play();
			canvasPlayAgain.SetActive(value: true);
			txtplayagain.J_MakeShowResult(J_PlayResult.Result.Failed);
		}
	}

	public void J_StartPlay()
	{
		UnityEngine.Debug.Log("--play");
		lockShowingResult = false;
		canvasMainFlow.SetActive(value: true);
		cPicFlow cPicFlow = listFlows[UnityEngine.Random.Range(0, listFlows.Length)];
		List<int> list = new List<int>();
		m_txtRealFlowTips.gameObject.SetActive(value: false);
		m_txtRealFlowTips.text = "";
		for (int i = 0; i < cPicFlow.flowPictures.Length; i++)
		{
			list.Add(i);
			Text txtRealFlowTips = m_txtRealFlowTips;
			txtRealFlowTips.text = txtRealFlowTips.text + cPicFlow.flowPictures[i].picTip + ";";
		}
		iMaxFlowNCount = list.Count;
		List<int> list2 = list.OrderBy((int c) => Guid.NewGuid()).ToList();
		m_txtMainFlow_Title.text = cPicFlow.strFlowName;
		iCurClickedNum = 0;
		for (int j = 0; j < listIcons.Count; j++)
		{
			cTempIconMono cTempIconMono = listIcons[j];
			cTempIconMono.objClicked.gameObject.SetActive(value: false);
			if (j < list2.Count)
			{
				cTempIconMono.gameObject.SetActive(value: true);
				int num = list2[j];
				cPicFlow.cSinglePic cSinglePic = cPicFlow.flowPictures[num];
				cTempIconMono.irightFlowIndex = num + 1;
				cTempIconMono.txtTip.text = cSinglePic.picTip;
				cTempIconMono.rawIconPic.texture = cSinglePic.picTexture;
			}
			else
			{
				cTempIconMono.gameObject.SetActive(value: false);
			}
		}
	}
}
public class GoodsClassifyManager : MonoBehaviour
{
	[Serializable]
	public struct sTriggerArea
	{
		public string name;

		public Text m_txtBoxName;

		public GameObject boxTrigger;

		public GameObject goodsContainer;
	}

	public class boxContainer : MonoBehaviour
	{
		public Text m_txtBoxName;
	}

	public class itemGood : MonoBehaviour
	{
		public bool isInRightBox;

		public GameObject goodBox;

		public Vector3 originalPos;

		public Quaternion originalRot;
	}

	public int m_iLevel = 1;

	public _ClockTimer m_Clock;

	public AudioSource audioSourceCorrect;

	public AudioSource audioSourceError;

	public List<sTriggerArea> listTiggerAreas;

	public GameObject canvasPlayAgain;

	public Text txtplayagain;

	private List<GameObject> listGoods = new List<GameObject>();

	private int iRightCount;

	private bool isWrongOnce;

	private void Start()
	{
		m_Clock.gameObject.SetActive(value: false);
		canvasPlayAgain.SetActive(value: false);
		m_Clock.gameObject.SetActive(value: false);
		CollectGoods();
		m_Clock.eventOnTimerOver.AddListener(J_TimeReached);
		WaveVRHead.Inst.SetGrab(showOrHide: true);
	}

	private void OnDisable()
	{
		WaveVRHead.Inst.SetGrab(showOrHide: false);
	}

	private void CollectGoods()
	{
		foreach (sTriggerArea listTiggerArea in listTiggerAreas)
		{
			listTiggerArea.boxTrigger.AddComponent<boxContainer>().m_txtBoxName = listTiggerArea.m_txtBoxName;
			foreach (Transform item in listTiggerArea.goodsContainer.transform)
			{
				listGoods.Add(item.gameObject);
				item.gameObject.SetActive(value: false);
				itemGood itemGood = item.gameObject.AddComponent<itemGood>();
				itemGood.goodBox = listTiggerArea.boxTrigger;
				itemGood.originalPos = item.position;
				itemGood.originalRot = item.rotation;
			}
		}
	}

	public void J_StartPlay()
	{
		int num = m_iLevel;
		iRightCount = 0;
		m_Clock.gameObject.SetActive(value: false);
		m_Clock.gameObject.SetActive(value: true);
		m_Clock.ftimer = (float)m_iLevel * 5f + 10f;
		isWrongOnce = false;
		foreach (GameObject listGood in listGoods)
		{
			listGood.SetActive(value: false);
		}
		GameObject[] array = new GameObject[listGoods.Count];
		listGoods.CopyTo(array);
		List<GameObject> list = array.ToList();
		if (num > list.Count)
		{
			num = list.Count;
		}
		for (int i = 0; i < num; i++)
		{
			int num2 = UnityEngine.Random.Range(0, list.Count);
			UnityEngine.Debug.LogWarning(num2);
			GameObject gameObject = list[num2];
			list.RemoveAt(num2);
			gameObject.SetActive(value: true);
			SetGoodInteractEvents(gameObject);
		}
	}

	private void SetGoodInteractEvents(GameObject tempobj)
	{
		WaveVR_rayInteractObject component = tempobj.GetComponent<WaveVR_rayInteractObject>();
		OnTriggerEvent onTriggerEvent;
		if ((onTriggerEvent = tempobj.GetComponent<OnTriggerEvent>()) == null)
		{
			onTriggerEvent = tempobj.AddComponent<OnTriggerEvent>();
		}
		itemGood tempGoodCtrl = component.GetComponent<itemGood>();
		tempGoodCtrl.isInRightBox = false;
		bool isHandGrabbed = false;
		tempobj.transform.position = tempGoodCtrl.originalPos;
		tempobj.transform.rotation = tempGoodCtrl.originalRot;
		List<boxContainer> tempListEnteredBox = new List<boxContainer>();
		onTriggerEvent.m_actionsOnTriggerEnter.RemoveAllListeners();
		onTriggerEvent.m_actionsOnTriggerEnter.AddListener(delegate(Collider collider)
		{
			boxContainer componentInParent2 = collider.GetComponentInParent<boxContainer>();
			if (componentInParent2 != null)
			{
				tempListEnteredBox.Add(componentInParent2);
				if (!isHandGrabbed)
				{
					CheckResult(componentInParent2, tempGoodCtrl);
				}
			}
		});
		onTriggerEvent.m_actionsOnTriggerExit.RemoveAllListeners();
		onTriggerEvent.m_actionsOnTriggerExit.AddListener(delegate(Collider collider)
		{
			boxContainer componentInParent = collider.GetComponentInParent<boxContainer>();
			if (componentInParent != null && tempListEnteredBox.Contains(componentInParent))
			{
				tempListEnteredBox.Remove(componentInParent);
			}
		});
		component.m_actionOnHandGrab.RemoveAllListeners();
		component.m_actionOnHandGrab.AddListener(delegate
		{
			isHandGrabbed = true;
		});
		component.m_actionOnHandRelease.RemoveAllListeners();
		component.m_actionOnHandRelease.AddListener(delegate
		{
			isHandGrabbed = false;
			if (tempListEnteredBox.Count > 0)
			{
				boxContainer boxcontiain = tempListEnteredBox[tempListEnteredBox.Count - 1];
				CheckResult(boxcontiain, tempGoodCtrl);
			}
		});
	}

	private void CheckResult(boxContainer boxcontiain, itemGood good)
	{
		if (boxcontiain.gameObject == good.goodBox)
		{
			if (good.isInRightBox)
			{
				return;
			}
			UnityEngine.Debug.Log("--right");
			good.isInRightBox = true;
			audioSourceCorrect.Play();
			boxcontiain.m_txtBoxName.J_DoColorFlash(Color.white, Color.green);
			if (++iRightCount < m_iLevel)
			{
				return;
			}
			m_Clock.gameObject.SetActive(value: false);
			foreach (GameObject listGood in listGoods)
			{
				listGood.SetActive(value: false);
			}
			canvasPlayAgain.SetActive(value: true);
			txtplayagain.text = "真棒，下次继续努力喲\n(*^▽^*)";
			if (!isWrongOnce)
			{
				m_iLevel++;
			}
		}
		else
		{
			UnityEngine.Debug.Log("--wrong");
			audioSourceError.Play();
			good.isInRightBox = false;
			isWrongOnce = true;
			boxcontiain.m_txtBoxName.J_DoColorFlash(Color.white, Color.red);
			good.transform.position = good.originalPos;
			good.transform.rotation = good.originalRot;
		}
	}

	public void J_TimeReached()
	{
		m_Clock.gameObject.SetActive(value: false);
		foreach (GameObject listGood in listGoods)
		{
			listGood.SetActive(value: false);
		}
		canvasPlayAgain.SetActive(value: true);
		txtplayagain.J_MakeShowResult(J_PlayResult.Result.TimeOut);
	}
}
public class TeleportionGoodsClassifyManager : MonoBehaviour
{
	public struct sPlateGood
	{
		public GameObject plate;

		public GameObject good;
	}

	public class boxContainer : MonoBehaviour
	{
		public int iboxIndex;

		public SpriteRenderer pic;
	}

	public class itemGood : MonoBehaviour
	{
		public float MoveSpeed = 2f;

		public string goodBoxName;

		private bool isTouchTelepor;

		private void OnCollisionEnter(UnityEngine.Collision collision)
		{
			if (collision.collider.name == "Cube传送带")
			{
				isTouchTelepor = true;
			}
		}

		private void OnCollisionExit(UnityEngine.Collision collision)
		{
			if (collision.collider.name == "Cube传送带")
			{
				isTouchTelepor = false;
			}
		}

		private void Update()
		{
			if (isTouchTelepor)
			{
				base.transform.position += Vector3.left * MoveSpeed * Time.deltaTime;
			}
		}
	}

	public int m_iLevel = 1;

	public float fMoveSpeed = 0.2f;

	public Transform transStartPos;

	public AudioSource audioSourceCorrect;

	public AudioSource audioSourceError;

	public GameObject canvasPlayAgain;

	public Transform PlateContainer;

	public Transform GoodContainer;

	private List<sPlateGood> listPlateGoods = new List<sPlateGood>();

	private bool isWrongOnce;

	private Dictionary<int, List<GameObject>> listShowedPlates = new Dictionary<int, List<GameObject>>();

	private int iShowedPlates;

	private List<GameObject> listBrnedGoods = new List<GameObject>();

	private void Start()
	{
		WaveVRHead.Inst.SetGrab(showOrHide: true);
		CollectGoods();
	}

	private void OnDisable()
	{
		WaveVRHead.Inst.SetGrab(showOrHide: false);
	}

	private void CollectGoods()
	{
		if (PlateContainer.childCount != GoodContainer.childCount)
		{
			UnityEngine.Debug.LogError("--数量不匹配");
			return;
		}
		for (int i = 0; i < PlateContainer.childCount; i++)
		{
			sPlateGood item = default(sPlateGood);
			item.plate = PlateContainer.GetChild(i).gameObject;
			item.good = GoodContainer.GetChild(i).gameObject;
			boxContainer boxContainer = item.plate.AddComponent<boxContainer>();
			boxContainer.iboxIndex = i;
			boxContainer.pic = item.plate.GetComponentInChildren<SpriteRenderer>();
			item.good.gameObject.AddComponent<itemGood>().goodBoxName = item.plate.name;
			item.plate.gameObject.SetActive(value: false);
			item.good.gameObject.SetActive(value: false);
			listPlateGoods.Add(item);
		}
	}

	public void J_StartPlay()
	{
		int num = m_iLevel * 3 - 2;
		int num2 = ((m_iLevel > listPlateGoods.Count) ? listPlateGoods.Count : m_iLevel);
		Dictionary<int, int> dictionary = new Dictionary<int, int>();
		for (int i = 0; i < num2; i++)
		{
			dictionary.Add(i, 1);
		}
		for (int j = 0; j < num - num2; j++)
		{
			dictionary[UnityEngine.Random.Range(0, num2)]++;
		}
		isWrongOnce = false;
		listShowedPlates.Clear();
		for (int k = 0; k < dictionary.Count; k++)
		{
			int num3 = dictionary[k];
			listShowedPlates.Add(k, new List<GameObject>());
			sPlateGood sPlateGood = listPlateGoods[k];
			for (int l = 0; l < num3; l++)
			{
				GameObject gameObject = UnityEngine.Object.Instantiate(sPlateGood.plate);
				gameObject.SetActive(value: true);
				gameObject.name = sPlateGood.plate.name;
				if (l == num3 - 1)
				{
					UnityEngine.Debug.Log(2);
					gameObject.GetComponentInChildren<SphereCollider>().enabled = true;
				}
				else
				{
					UnityEngine.Debug.Log(1);
					gameObject.GetComponentInChildren<SphereCollider>().enabled = false;
				}
				listShowedPlates[k].Add(gameObject);
				iShowedPlates++;
				gameObject.transform.position = sPlateGood.plate.transform.position + Vector3.up * l * 0.015f;
				gameObject.transform.eulerAngles = sPlateGood.plate.transform.eulerAngles;
			}
		}
		StartCoroutine(yieldLoopBornGoods(dictionary.Count));
	}

	private IEnumerator yieldLoopBornGoods(int iPlateCount)
	{
		listBrnedGoods.Clear();
		while (true)
		{
			GameObject good = listPlateGoods[UnityEngine.Random.Range(0, iPlateCount)].good;
			GameObject gameObject = UnityEngine.Object.Instantiate(good);
			gameObject.SetActive(value: true);
			if (listBrnedGoods.Count > 20)
			{
				listBrnedGoods.RemoveAt(0);
			}
			listBrnedGoods.Add(gameObject);
			gameObject.transform.position = transStartPos.transform.position;
			gameObject.transform.eulerAngles = good.transform.eulerAngles;
			SetGoodInteractEvents(gameObject);
			yield return new WaitForSeconds(2f);
		}
	}

	private void SetGoodInteractEvents(GameObject tempobj)
	{
		WaveVR_rayInteractObject component = tempobj.GetComponent<WaveVR_rayInteractObject>();
		OnTriggerEvent onTriggerEvent;
		if ((onTriggerEvent = tempobj.GetComponent<OnTriggerEvent>()) == null)
		{
			onTriggerEvent = tempobj.AddComponent<OnTriggerEvent>();
		}
		itemGood tempGoodCtrl = component.GetComponent<itemGood>();
		tempGoodCtrl.MoveSpeed = fMoveSpeed + 0.05f * (float)m_iLevel;
		List<boxContainer> tempListEnteredBox = new List<boxContainer>();
		bool isHandGrabbed = false;
		onTriggerEvent.m_actionsOnTriggerEnter.RemoveAllListeners();
		onTriggerEvent.m_actionsOnTriggerEnter.AddListener(delegate(Collider collider)
		{
			boxContainer componentInParent2 = collider.GetComponentInParent<boxContainer>();
			if (componentInParent2 != null)
			{
				tempListEnteredBox.Add(componentInParent2);
				if (!isHandGrabbed)
				{
					CheckResult(componentInParent2, tempGoodCtrl);
				}
			}
		});
		onTriggerEvent.m_actionsOnTriggerExit.RemoveAllListeners();
		onTriggerEvent.m_actionsOnTriggerExit.AddListener(delegate(Collider collider)
		{
			boxContainer componentInParent = collider.GetComponentInParent<boxContainer>();
			if (componentInParent != null && tempListEnteredBox.Contains(componentInParent))
			{
				tempListEnteredBox.Remove(componentInParent);
			}
		});
		component.m_actionOnHandGrab.RemoveAllListeners();
		component.m_actionOnHandGrab.AddListener(delegate
		{
			isHandGrabbed = true;
		});
		component.m_actionOnHandRelease.RemoveAllListeners();
		component.m_actionOnHandRelease.AddListener(delegate
		{
			isHandGrabbed = false;
			if (tempListEnteredBox.Count > 0)
			{
				boxContainer boxcontiain = tempListEnteredBox[tempListEnteredBox.Count - 1];
				CheckResult(boxcontiain, tempGoodCtrl);
			}
		});
	}

	private void CheckResult(boxContainer boxcontiain, itemGood good)
	{
		listBrnedGoods.Remove(good.gameObject);
		UnityEngine.Object.Destroy(good.gameObject);
		if (boxcontiain.gameObject.name == good.goodBoxName)
		{
			UnityEngine.Debug.Log("--right");
			List<GameObject> list = listShowedPlates[boxcontiain.iboxIndex];
			list.Remove(boxcontiain.gameObject);
			UnityEngine.Object.Destroy(boxcontiain.gameObject);
			if (list.Count > 0)
			{
				list[list.Count - 1].GetComponentInChildren<SphereCollider>().enabled = true;
			}
			UnityEngine.Debug.Log("--right");
			audioSourceCorrect.Play();
			if (--iShowedPlates <= 0)
			{
				StopAllCoroutines();
				for (int num = listBrnedGoods.Count - 1; num >= 0; num--)
				{
					UnityEngine.Object.Destroy(listBrnedGoods[num].gameObject);
				}
				listBrnedGoods.Clear();
				canvasPlayAgain.SetActive(value: true);
				if (!isWrongOnce)
				{
					m_iLevel++;
				}
			}
		}
		else
		{
			UnityEngine.Debug.Log("--wrong");
			audioSourceError.Play();
			isWrongOnce = true;
			boxcontiain.pic.J_DoColorFlash(Color.white, Color.red);
		}
	}
}
public class ShoesHiding_Manager : MonoBehaviour
{
	public class cBoxTrigger : MonoBehaviour, IHandRayPointerDown
	{
		public bool hasClicked;

		public GameObject boxTop;

		public Transform shoesStayPos;

		public Action onPointerDown;

		public void OnHandPointerDown(WaveVR_HandRayGrabber hand)
		{
			if (onPointerDown != null)
			{
				onPointerDown();
			}
		}
	}

	public int m_iCurLevel = 1;

	public Transform transBoxContainer;

	public GameObject objRightShoes;

	public Transform objWrongShoesContainer;

	public AudioSource audioSourceCorrect;

	public AudioSource audioSourceError;

	public GameObject canvasPlayAgain;

	public Text txtplayagain;

	public _ClockTimer m_Clock;

	private int iRightShoesCount = 1;

	private int iWrongShoesCount;

	private List<cBoxTrigger> m_listBoxs = new List<cBoxTrigger>();

	private List<int> listCorrectBoxIndexs = new List<int>();

	private List<GameObject> listInstantShoes = new List<GameObject>();

	private static bool lockShowingResult;

	private void Start()
	{
		canvasPlayAgain.SetActive(value: false);
		m_Clock.gameObject.SetActive(value: false);
		objRightShoes.SetActive(value: false);
		objWrongShoesContainer.gameObject.SetActive(value: false);
		SetShoesNum(m_iCurLevel);
		m_listBoxs.Clear();
		for (int i = 0; i < transBoxContainer.childCount; i++)
		{
			int iboxIndex = i;
			Transform child = transBoxContainer.GetChild(i);
			cBoxTrigger boxCtrl = child.Find("CubeBox").gameObject.AddComponent<cBoxTrigger>();
			boxCtrl.boxTop = child.Find("盖子").gameObject;
			boxCtrl.shoesStayPos = child.Find("shoesStayPos");
			m_listBoxs.Add(boxCtrl);
			cBoxTrigger cBoxTrigger = boxCtrl;
			cBoxTrigger.onPointerDown = (Action)Delegate.Combine(cBoxTrigger.onPointerDown, (Action)delegate
			{
				UnityEngine.Debug.LogWarning("--click " + iboxIndex);
				if (!lockShowingResult && !boxCtrl.hasClicked)
				{
					boxCtrl.hasClicked = true;
					boxCtrl.boxTop.gameObject.SetActive(value: false);
					if (listCorrectBoxIndexs.Contains(iboxIndex))
					{
						UnityEngine.Debug.LogWarning("--right");
						audioSourceCorrect.Play();
						listCorrectBoxIndexs.Remove(iboxIndex);
						if (listCorrectBoxIndexs.Count == 0)
						{
							onResult(isSucceed: true);
						}
					}
					else
					{
						UnityEngine.Debug.LogWarning("--wrong");
						audioSourceError.Play();
						onResult(isSucceed: false);
					}
				}
			});
		}
		m_Clock.eventOnTimerOver.AddListener(J_TimeReached);
	}

	public void J_StartPlay()
	{
		for (int num = listInstantShoes.Count - 1; num >= 0; num--)
		{
			UnityEngine.Object.Destroy(listInstantShoes[num].gameObject);
		}
		listInstantShoes.Clear();
		foreach (cBoxTrigger listBox in m_listBoxs)
		{
			listBox.hasClicked = false;
			listBox.boxTop.SetActive(value: false);
		}
		listCorrectBoxIndexs.Clear();
		List<int> list = new List<int>();
		for (int i = 0; i < m_listBoxs.Count; i++)
		{
			list.Add(i);
		}
		for (int j = 0; j < iRightShoesCount; j++)
		{
			int index = UnityEngine.Random.Range(0, list.Count);
			int num2 = list[index];
			list.RemoveAt(index);
			listCorrectBoxIndexs.Add(num2);
			cBoxTrigger cBoxTrigger = m_listBoxs[num2];
			GameObject gameObject = UnityEngine.Object.Instantiate(objRightShoes);
			listInstantShoes.Add(gameObject);
			gameObject.gameObject.SetActive(value: true);
			gameObject.transform.parent = cBoxTrigger.shoesStayPos;
			gameObject.transform.localPosition = Vector3.zero;
			gameObject.transform.localEulerAngles = Vector3.zero;
		}
		for (int k = 0; k < iRightShoesCount; k++)
		{
			int index2 = UnityEngine.Random.Range(0, list.Count);
			int index3 = list[index2];
			list.RemoveAt(index2);
			cBoxTrigger cBoxTrigger2 = m_listBoxs[index3];
			GameObject gameObject2 = UnityEngine.Object.Instantiate(objWrongShoesContainer.GetChild(UnityEngine.Random.Range(0, objWrongShoesContainer.childCount)).gameObject);
			listInstantShoes.Add(gameObject2);
			gameObject2.gameObject.SetActive(value: true);
			gameObject2.transform.parent = cBoxTrigger2.shoesStayPos;
			gameObject2.transform.localPosition = Vector3.zero;
			gameObject2.transform.localEulerAngles = Vector3.zero;
		}
		StartCoroutine(yieldWaitForHide(1f + 0.5f * (float)(iRightShoesCount + iWrongShoesCount / 2)));
	}

	private IEnumerator yieldWaitForHide(float fSecnod)
	{
		yield return new WaitForSeconds(fSecnod);
		foreach (cBoxTrigger listBox in m_listBoxs)
		{
			listBox.boxTop.SetActive(value: true);
		}
		yield return new WaitForSeconds(1f);
		m_Clock.ftimer = 10f;
		m_Clock.gameObject.SetActive(value: true);
		lockShowingResult = false;
	}

	private void onResult(bool isSucceed)
	{
		lockShowingResult = true;
		m_Clock.gameObject.SetActive(value: false);
		yieldShowReusltPanel(isSucceed);
		if (isSucceed)
		{
			m_iCurLevel++;
			SetShoesNum(m_iCurLevel);
		}
	}

	private void yieldShowReusltPanel(bool issucceed)
	{
		foreach (cBoxTrigger listBox in m_listBoxs)
		{
			listBox.boxTop.SetActive(value: false);
		}
		canvasPlayAgain.SetActive(value: true);
		if (issucceed)
		{
			txtplayagain.J_MakeShowResult(J_PlayResult.Result.Succeed);
		}
		else
		{
			txtplayagain.J_MakeShowResult(J_PlayResult.Result.Failed);
		}
	}

	private void SetShoesNum(int ilevel)
	{
		int num = ilevel;
		if (num > 26)
		{
			num = 26;
		}
		iRightShoesCount = GetMinRightShoeCount(num);
		iWrongShoesCount = num - (int)((float)((iRightShoesCount + 1) * iRightShoesCount) / 2f);
	}

	private int GetMinRightShoeCount(int ilevel)
	{
		return Mathf.FloorToInt(Mathf.Sqrt(ilevel * 8 + 1) / 2f - 0.5f);
	}

	public void J_TimeReached()
	{
		lockShowingResult = true;
		m_Clock.gameObject.SetActive(value: false);
		foreach (cBoxTrigger listBox in m_listBoxs)
		{
			listBox.boxTop.SetActive(value: false);
		}
		canvasPlayAgain.SetActive(value: true);
		txtplayagain.J_MakeShowResult(J_PlayResult.Result.TimeOut);
	}
}
public class GameManager18_QSG : MonoBehaviour
{
	public bool isOneHand = true;

	public int m_iScore;

	public Text m_txtHighestScore;

	private int fHighestScore;

	public int iMaxTopscore = 100;

	public string m_SceneLetter = "Z-羽毛球场";

	public string m_TaskLetter = "1";

	public Transform m_vCubeBornPos;

	[Header("params")]
	public Vector3 vBornDelayPos = new Vector3(0.2f, 0f, 0f);

	public Vector2 m_vRange_MoveSpeed = new Vector2(-3f, -0.5f);

	public Vector2 m_vRange_BronDelay = new Vector2(0.7f, 2.5f);

	[Header("objects")]
	public GameObject m_SwordYellow;

	public GameObject m_SwordRed;

	public GameObject m_objCubeYellow;

	public GameObject m_objCubeRed;

	public AudioSource m_audioHit;

	public AudioSource m_audioWrongSword;

	public AudioSource m_audioWrongDir;

	public ParticleSystem m_psRight;

	public ParticleSystem m_psWrong;

	public ParticleSystem m_psWrongDirPoint;

	public List<UnityEngine.Object> m_listFruitsItems;

	public Text m_txtScore;

	private int[] arrRanAngles = new int[4] { 0, 90, 180, 270 };

	public float _fMoveSpeed => m_vRange_MoveSpeed.y - (m_vRange_MoveSpeed.y - m_vRange_MoveSpeed.x) * (float)Mathf.Clamp(m_iScore, 0, iMaxTopscore) / (float)iMaxTopscore;

	private float _fBronDelay => m_vRange_BronDelay.y - (m_vRange_BronDelay.y - m_vRange_BronDelay.x) * (float)Mathf.Clamp(m_iScore, 0, iMaxTopscore) / (float)iMaxTopscore;

	private void Awake()
	{
		fHighestScore = PlayerPrefs.GetInt("HighestScore_qsg");
		m_txtHighestScore.text = string.Concat(fHighestScore);
		m_objCubeYellow.SetActive(value: false);
		m_objCubeRed.SetActive(value: false);
		WaveVRHead.Inst.HideHand();
		J_StartPlayG();
	}

	private void OnDisable()
	{
		WaveVRHead.Inst.ShowHand();
	}

	private void Update()
	{
		GameObject rightHand = WaveVRHead.Inst.m_rightHand;
		if (rightHand != null)
		{
			m_SwordRed.transform.position = rightHand.transform.position;
			m_SwordRed.transform.eulerAngles = rightHand.transform.eulerAngles;
		}
		GameObject leftHand = WaveVRHead.Inst.m_leftHand;
		if (leftHand != null)
		{
			m_SwordYellow.transform.position = leftHand.transform.position;
			m_SwordYellow.transform.eulerAngles = leftHand.transform.eulerAngles;
		}
	}

	public void J_StartPlayG()
	{
		StartCoroutine(yiledBornCubes());
	}

	private IEnumerator yiledBornCubes()
	{
		while (true)
		{
			GameObject rightSword = null;
			GameObject wrongSword = null;
			GameObject original;
			if (isOneHand)
			{
				original = m_objCubeRed;
				rightSword = m_SwordRed.gameObject;
			}
			else if (UnityEngine.Random.Range(0, 2) == 0)
			{
				original = m_objCubeYellow;
				rightSword = m_SwordYellow.gameObject;
				wrongSword = m_SwordRed.gameObject;
			}
			else
			{
				original = m_objCubeRed;
				rightSword = m_SwordRed.gameObject;
				wrongSword = m_SwordYellow.gameObject;
			}
			int index = UnityEngine.Random.Range(0, m_listFruitsItems.Count);
			Coroutine coroutineMove = null;
			GameObject tempCube = UnityEngine.Object.Instantiate(original);
			tempCube.transform.SetParent(base.transform);
			tempCube.SetActive(value: true);
			tempCube.transform.position = m_vCubeBornPos.position + new Vector3(UnityEngine.Random.Range(0f - vBornDelayPos.x, vBornDelayPos.x), 0f, 0f);
			tempCube.transform.Rotate(0f, 0f, randomRAngle());
			GameObject tempobj = UnityEngine.Object.Instantiate(m_listFruitsItems[index]) as GameObject;
			tempobj.transform.SetParent(tempCube.transform);
			tempobj.transform.localPosition = Vector3.zero;
			tempobj.transform.localEulerAngles = Vector3.zero;
			tempobj.transform.localScale = Vector3.one;
			tempCube.GetComponent<__.OnColliderEvent>().m_actionsOnCollisionEnter.AddListener(delegate(UnityEngine.Collision collision)
			{
				if (collision.gameObject.transform.IsChildOf(rightSword.transform))
				{
					if (Vector3.Dot(collision.gameObject.GetComponent<VelocityEstimator>().GetVelocityEstimate(), tempCube.transform.up) < -0.5f)
					{
						UnityEngine.Debug.Log("--right");
						m_psRight.transform.eulerAngles = new Vector3(tempCube.transform.eulerAngles.x, tempCube.transform.eulerAngles.y, tempCube.transform.eulerAngles.z + 90f);
						m_psRight.transform.position = tempCube.transform.position;
						m_psRight.Play();
						m_audioHit.Play();
						tempobj.transform.SetParent(tempCube.transform.parent);
						UnityEngine.Object.Destroy(tempCube);
						MeshRenderer[] componentsInChildren = tempobj.GetComponentsInChildren<MeshRenderer>();
						for (int i = 0; i < componentsInChildren.Length; i++)
						{
							componentsInChildren[i].gameObject.AddComponent<Rigidbody>().AddExplosionForce(600f, tempobj.transform.position, 3f);
						}
						StartCoroutine(yiledDestroyObj(tempobj, 1f));
						AddScore(isAdd: true);
					}
					else
					{
						UnityEngine.Debug.LogWarning("--wrong dir");
						m_audioWrongSword.Play();
						m_psWrong.transform.position = tempCube.transform.position;
						m_psWrong.Play();
						tempobj.transform.SetParent(tempCube.transform.parent);
						UnityEngine.Object.Destroy(tempCube);
						tempobj.gameObject.AddComponent<Rigidbody>().AddExplosionForce(6000f, tempobj.transform.position, 3f);
						StartCoroutine(yiledDestroyObj(tempobj, 1f));
						AddScore(isAdd: false);
					}
					StopCoroutine(coroutineMove);
					coroutineMove = null;
				}
				else if (collision.gameObject.transform.IsChildOf(wrongSword.transform))
				{
					UnityEngine.Debug.LogWarning("--wrong swords");
					m_audioWrongSword.Play();
					m_psWrong.transform.position = tempCube.transform.position;
					m_psWrong.Play();
				}
			});
			coroutineMove = StartCoroutine(yieldMoveObj(tempCube));
			yield return new WaitForSeconds(_fBronDelay);
		}
	}

	private int randomRAngle()
	{
		int num = UnityEngine.Random.Range(0, arrRanAngles.Length);
		return arrRanAngles[num];
	}

	private IEnumerator yieldMoveObj(GameObject obj)
	{
		float fMaxMoveDis = 16f;
		float num;
		do
		{
			yield return new WaitForEndOfFrame();
			Vector3 vector = new Vector3(0f, 0f, _fMoveSpeed * Time.deltaTime);
			obj.transform.position += vector;
			fMaxMoveDis = (num = fMaxMoveDis - vector.magnitude);
		}
		while (!(num < 0f));
		if (obj != null)
		{
			UnityEngine.Object.Destroy(obj);
		}
	}

	private IEnumerator yiledDestroyObj(GameObject obj, float second)
	{
		yield return new WaitForSeconds(second);
		if (obj != null)
		{
			UnityEngine.Object.Destroy(obj);
		}
	}

	private void AddScore(bool isAdd)
	{
		UnityEngine.Debug.Log("score" + isAdd);
		if (isAdd)
		{
			m_iScore++;
			if (m_iScore > fHighestScore)
			{
				fHighestScore = m_iScore;
				m_txtHighestScore.text = string.Concat(fHighestScore);
				PlayerPrefs.SetInt("HighestScore_qsg", fHighestScore);
			}
			m_txtScore.text = "Score:" + m_iScore;
			StartCoroutine(yieldScaleScore(isAdd: true));
		}
		else
		{
			if (--m_iScore < 0)
			{
				m_iScore = 0;
			}
			m_txtScore.text = "Score:" + m_iScore;
			StartCoroutine(yieldScaleScore(isAdd: false));
		}
	}

	private IEnumerator yieldScaleScore(bool isAdd)
	{
		if (isAdd)
		{
			m_txtScore.DOColor(Color.cyan, 0.3f);
			m_txtScore.transform.DOScale(1.25f, 0.3f);
			yield return new WaitForSeconds(0.3f);
			m_txtScore.DOColor(Color.white, 0.15f);
			m_txtScore.transform.DOScale(1f, 0.15f);
		}
		else
		{
			m_txtScore.DOColor(Color.red, 0.3f);
			m_txtScore.transform.DOScale(0.75f, 0.3f);
			yield return new WaitForSeconds(0.3f);
			m_txtScore.DOColor(Color.white, 0.15f);
			m_txtScore.transform.DOScale(1f, 0.15f);
		}
	}
}
public class QSG_CubeMove : MonoBehaviour
{
	public float fMoveSpeed = 1f;

	public GameObject m_objBreakCube;

	public Action<UnityEngine.Collision> m_OnTriggerEnter;

	private void Awake()
	{
		m_objBreakCube.SetActive(value: false);
	}

	private void Start()
	{
		base.transform.Rotate(0f, 0f, UnityEngine.Random.Range(0f, 360f));
	}

	private void OnCollisionEnter(UnityEngine.Collision collision)
	{
		UnityEngine.Debug.Log(1);
		if (m_OnTriggerEnter != null)
		{
			m_OnTriggerEnter(collision);
		}
	}

	public void BreakCube()
	{
		m_objBreakCube.transform.SetParent(null);
		m_objBreakCube.SetActive(value: true);
		Invoke("deleteCube", 1f);
		base.gameObject.SetActive(value: false);
	}

	private void deleteCube()
	{
		UnityEngine.Object.Destroy(base.gameObject);
		UnityEngine.Object.Destroy(m_objBreakCube);
	}
}
public class QSG_ItemObject : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
	}
}
public class ClothNotForgetManager : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
	}
}
public class AudioRecWordsCtrl : MonoBehaviour
{
	public class VoiceResult
	{
		public Header header;

		public string name;

		public Payload payload;
	}

	public class Header
	{
		public string name;
	}

	public class Payload
	{
		public string result;
	}

	public Text txtResult;

	private string recogedWordsAll = "";

	private string recogedWords = "";

	private bool isOne;

	public Action<string> actionOnRecStopped;

	private AndroidJavaClass ajc;

	private AndroidJavaObject ajo;

	private bool isInit;

	private string tempmsg = "";

	private void Start()
	{
		recogedWordsAll = "";
		if (txtResult != null)
		{
			txtResult.text = "";
		}
	}

	public void J_StartRec()
	{
		J_StartRec(oneSentence: false);
	}

	public void J_StartRec(bool oneSentence)
	{
		isOne = oneSentence;
		recogedWordsAll = "";
		if (txtResult != null)
		{
			txtResult.text = "";
		}
		ks();
	}

	public void J_StopRec()
	{
		js();
	}

	private void OnDisable()
	{
		stop();
	}

	private void OnDestroy()
	{
		stop();
		ajo.Call("Destory");
	}

	private void stop()
	{
		js();
	}

	public void init(bool st = false)
	{
		try
		{
			if (isInit)
			{
				if (st)
				{
					ks();
				}
				return;
			}
			ajc = new AndroidJavaClass("cn.Guava.CRCI.AliyunVoice");
			ajc.CallStatic("start");
			ajo = ajc.GetStatic<AndroidJavaObject>("instance");
			StartCoroutine(HttpGet(UrlUtils.baseUrl_es + "api/aliyun", delegate(string tk)
			{
				string value = new Regex("\"data\":\"(\\w+)\"").Match(tk).Groups[1].Value;
				string text = ajo.Call<string>("Init", new object[6]
				{
					"3CvZr9CLdQCBSaZ0",
					value,
					base.gameObject.name,
					"OnRecStateChange",
					"OnRecCallback",
					"OnVolumnCallback"
				});
				if (text == "0")
				{
					isInit = true;
					if (st)
					{
						ks();
					}
				}
				else
				{
					log("aliyun 初始化失败:" + text);
				}
			}));
		}
		catch (Exception ex)
		{
			log("init error:" + ex.Message);
		}
	}

	private void log(string s)
	{
	}

	private void log2(string s)
	{
	}

	public void ks()
	{
		if (!isInit)
		{
			init(st: true);
			return;
		}
		int num = ajo.Call<int>("Start", Array.Empty<object>());
		log2("aliyun Start:" + num);
	}

	public void js()
	{
		int num = ajo.Call<int>("Stop", Array.Empty<object>());
		log2("aliyun End:" + num);
	}

	public void OnRecStateChange(string msg)
	{
		log("aliyun OnRecStateChange:" + msg);
	}

	public void OnVolumnCallback(string val)
	{
	}

	private void Update()
	{
		if (tempmsg != "")
		{
			string obj = tempmsg;
			tempmsg = "";
			actionOnRecStopped?.Invoke(obj);
		}
	}

	public void OnRecCallback(string msg)
	{
		log(msg);
		VoiceResult voiceResult = LitJson.JsonMapper.ToObject<VoiceResult>(msg);
		if (voiceResult == null || voiceResult.payload == null || string.IsNullOrEmpty(voiceResult.payload.result))
		{
			return;
		}
		string text = voiceResult.payload.result.FilterRecWord();
		if ((bool)txtResult)
		{
			txtResult.text = recogedWordsAll + text;
		}
		if (voiceResult.header != null && voiceResult.header.name != null && voiceResult.header.name.Contains("SentenceEnd"))
		{
			recogedWordsAll = recogedWordsAll + text + (isOne ? "" : "，");
			if (isOne)
			{
				tempmsg = text;
			}
		}
	}

	private IEnumerator HttpGet(string uri, Action<string> cb)
	{
		new WWWForm();
		using UnityWebRequest webRequest = UnityWebRequest.Get(uri);
		yield return webRequest.SendWebRequest();
		if (webRequest.isHttpError || webRequest.isNetworkError)
		{
			log("HttpGet:" + webRequest.error);
			yield break;
		}
		try
		{
			cb(webRequest.downloadHandler.text);
		}
		catch (Exception ex)
		{
			log("json format error:" + webRequest.downloadHandler.text);
			log(ex.Message);
		}
	}
}
public class _ClockTimer : MonoBehaviour
{
	public float ftimer = 60f;

	public Text m_txtClock;

	public UnityEvent eventOnTimerOver;

	private Coroutine coroutineTimeCountDown;

	private void OnEnable()
	{
		coroutineTimeCountDown = StartCoroutine(yieldTimeCountDown(ftimer));
	}

	private void OnDisable()
	{
		if (coroutineTimeCountDown != null)
		{
			StopCoroutine(coroutineTimeCountDown);
		}
	}

	private IEnumerator yieldTimeCountDown(float ftime)
	{
		float ftimer = ftime;
		while (ftimer > 0f)
		{
			int num = (int)ftimer / 60;
			if (m_txtClock != null)
			{
				m_txtClock.text = num.ToString("00") + ":" + ((int)ftimer - num * 60).ToString("00");
			}
			ftimer -= 1f;
			yield return new WaitForSeconds(1f);
		}
		if (m_txtClock != null)
		{
			m_txtClock.text = "00:00";
		}
		onTimeOver();
	}

	private void onTimeOver()
	{
		eventOnTimerOver.Invoke();
	}
}
public class AutoMove_A2B : MonoBehaviour
{
	public Transform pFrom;

	public Transform pTo;

	public float m_fPassTime = 2f;

	public float m_fGravity = -5f;

	private float fPassTime;

	private float fGravity;

	private Vector3 speed;

	private Vector3 Gravity;

	private float dpassedTime;

	private bool isStartMove;

	private void Start()
	{
	}

	private void OnEnable()
	{
		StartMoveFromTo(pFrom.transform.position, pTo.transform.position, m_fPassTime, m_fGravity);
	}

	private void Update()
	{
		if (Time.timeScale != 0f && isStartMove)
		{
			Vector3 vector = speed * Time.deltaTime + new Vector3(0f, fGravity * (dpassedTime += Time.deltaTime), 0f) * Time.deltaTime;
			base.transform.transform.forward = vector;
			base.transform.position += vector;
			if (dpassedTime >= fPassTime)
			{
				StopMove();
			}
		}
	}

	public void StartMoveFromTo(Vector3 vFrom, Vector3 vTo, float psTime, float gravity)
	{
		fPassTime = psTime;
		fGravity = gravity;
		base.transform.position = vFrom;
		speed = new Vector3((vTo.x - vFrom.x) / fPassTime, (vTo.y - vFrom.y) / fPassTime - 0.5f * fGravity * fPassTime, (vTo.z - vFrom.z) / fPassTime);
		Gravity = Vector3.zero;
		dpassedTime = 0f;
		isStartMove = true;
	}

	public void StopMove()
	{
		isStartMove = false;
	}
}
public class C_HandMenuCtrl : MonoBehaviour
{
	public static C_HandMenuCtrl Inst;

	public GameObject m_objOriginal;

	public Transform m_VRHead;

	public GameObject m_objMenuDialog;

	public Text m_txtDialogMsg;

	private void Awake()
	{
		Inst = this;
		SceneManager.activeSceneChanged += SceneManager_activeSceneChanged;
	}

	public static bool IsMenuOn()
	{
		if (Inst == null)
		{
			return false;
		}
		return Inst.m_objOriginal.activeInHierarchy;
	}

	private void SceneManager_activeSceneChanged(Scene arg0, Scene arg1)
	{
		UnityEngine.Debug.LogWarning("--scene change:" + arg1.name);
		Time.timeScale = 1f;
		m_objOriginal.SetActive(value: false);
		WaveVRHead.Inst.SetHnadlerVisiable(isShow: true);
		WaveVRHead.Inst.SetMenuUILayerEnable(isEnable: false);
		m_objMenuDialog.SetActive(value: false);
	}

	public void J_SwicthShowMenuUI()
	{
		if (m_objOriginal.activeInHierarchy)
		{
			J_HideMenuUI();
		}
		else
		{
			J_ShowMenuUI();
		}
	}

	public void J_ShowMenuUI()
	{
		Time.timeScale = 0f;
		m_objOriginal.SetActive(value: true);
		WaveVRHead.Inst.SetMenuUILayerEnable(isEnable: true);
		base.transform.position = m_VRHead.transform.position + m_VRHead.transform.forward * 1.45f;
		base.transform.forward = m_VRHead.transform.forward;
	}

	public void J_HideMenuUI()
	{
		Time.timeScale = 1f;
		m_objOriginal.SetActive(value: false);
		WaveVRHead.Inst.SetMenuUILayerEnable(isEnable: false);
		m_objMenuDialog.SetActive(value: false);
	}

	public void J_ShowMenuDialog(string strMsg)
	{
		J_ShowMenuUI();
		m_objMenuDialog.SetActive(value: true);
		m_txtDialogMsg.text = strMsg;
	}

	private void Update()
	{
		if (Controller.UPvr_GetKeyUp(Pvr_ControllerManager.controllerlink.mainHandID, Pvr_KeyCode.APP))
		{
			J_SwicthShowMenuUI();
		}
	}

	public void J_LoadScene(string sceneName)
	{
		Load.LoadScene2(sceneName);
	}

	public void J_QuitAPP()
	{
		SceneManager.LoadScene("2_MainStart", LoadSceneMode.Single);
	}
}
public class CinePathCartCtrl : MonoBehaviour
{
	public CinemachineDollyCart cineCart;

	public void J_SetToPath(CinemachinePathBase cinePath)
	{
		base.gameObject.SetActive(value: true);
		base.enabled = true;
		cineCart.m_Speed = 0f;
		cineCart.m_Path = cinePath;
		cineCart.m_Position = 0f;
	}

	public void J_StartMove(float fspeed = 1f)
	{
		cineCart.m_Speed = fspeed;
	}
}
public class DelaySelfDestroy : MonoBehaviour
{
	public float fDelaySecond = 1f;

	private void Start()
	{
		Invoke("destroySelf", fDelaySecond);
	}

	private void destroySelf()
	{
		UnityEngine.Object.Destroy(base.gameObject);
	}
}
public class DelayTimeAction : MonoBehaviour
{
	public float delaySecond;

	public UnityEvent eventDelay;

	private void OnEnable()
	{
		if (delaySecond >= 0f)
		{
			Invoke("delayAction", delaySecond);
		}
	}

	private void delayAction()
	{
		eventDelay.Invoke();
	}
}
public class headUITipCtrl : MonoBehaviour
{
	public void J_SetHeadUITip(string strmsg)
	{
		if ((bool)WaveVRHead.Inst)
		{
			WaveVRHead.Inst.SetHeadUITip(strmsg);
		}
	}
}
public class justClock : MonoBehaviour
{
	public string format;

	public Text m_txtClock;

	private float ftimer = 1f;

	private void OnEnable()
	{
		m_txtClock.text = DateTime.Now.ToString(format);
	}

	private void FixedUpdate()
	{
		if ((ftimer += Time.deltaTime) > 1f)
		{
			ftimer = 0f;
			m_txtClock.text = DateTime.Now.ToString(format);
		}
	}
}
public class justClock_textMeshPro : MonoBehaviour
{
	public string format;

	public TextMeshProUGUI m_txtClock;

	private float ftimer = 1f;

	private void OnEnable()
	{
		m_txtClock.text = DateTime.Now.ToString(format);
	}

	private void FixedUpdate()
	{
		if ((ftimer += Time.deltaTime) > 1f)
		{
			ftimer = 0f;
			m_txtClock.text = DateTime.Now.ToString(format);
		}
	}
}
public class LockVRPlayer : MonoBehaviour
{
	private Transform m_target;

	private float lockAngle;

	public void J_LockVRPlayer()
	{
		m_target = WaveVRHead.Inst.transform;
		lockAngle = m_target.eulerAngles.y - base.transform.eulerAngles.y;
	}

	public void J_UnlockTarget()
	{
		m_target = null;
	}

	private void LateUpdate()
	{
		if (m_target != null)
		{
			m_target.transform.position = base.transform.position;
			m_target.transform.eulerAngles = new Vector3(0f, base.transform.eulerAngles.y + lockAngle, 0f);
		}
	}
}
public class monoEvent : MonoBehaviour
{
	public UnityEvent eventOnEnable;

	public UnityEvent eventOnDisable;

	private void OnEnable()
	{
		eventOnEnable.Invoke();
	}

	private void OnDisable()
	{
		eventOnDisable.Invoke();
	}
}
public class OnPointerEvent : MonoBehaviour, IPointerClickHandler, IEventSystemHandler
{
	public UnityEvent eOnPointerClick;

	public void OnPointerClick(PointerEventData eventData)
	{
		eOnPointerClick.Invoke();
	}
}
public class OnTriggerEvent : MonoBehaviour
{
	[Serializable]
	public class triggerEvent : UnityEvent<Collider>
	{
	}

	public triggerEvent m_actionsOnTriggerEnter = new triggerEvent();

	public triggerEvent m_actionsOnTriggerExit = new triggerEvent();

	private void OnTriggerEnter(Collider other)
	{
		if (m_actionsOnTriggerEnter != null)
		{
			m_actionsOnTriggerEnter.Invoke(other);
		}
	}

	private void OnTriggerExit(Collider other)
	{
		if (m_actionsOnTriggerExit != null)
		{
			m_actionsOnTriggerExit.Invoke(other);
		}
	}
}
public class PlayerAreaTriggerEvent : MonoBehaviour
{
	public float fDistance = 1f;

	public UnityEvent m_eventOnEnterArea;

	public UnityEvent m_eventOnExitArea;

	private Transform playerHead;

	private bool hasInArea;

	private void Start()
	{
		playerHead = WaveVRHead.Inst.transform;
	}

	private void FixedUpdate()
	{
		if (playerHead == null)
		{
			return;
		}
		if (Vector3.Distance(playerHead.position, base.transform.position) < fDistance)
		{
			if (!hasInArea)
			{
				hasInArea = true;
				m_eventOnEnterArea.Invoke();
			}
		}
		else if (hasInArea)
		{
			hasInArea = false;
			m_eventOnExitArea.Invoke();
		}
	}

	private void OnDrawGizmosSelected()
	{
		Gizmos.DrawWireSphere(base.transform.position, fDistance);
	}
}
public class WavrVR_ControllerAction : MonoBehaviour
{
	public Pvr_KeyCode wVR_InputId;

	public UnityEvent onVirtualBtnDown;

	public UnityEvent onVirtualBtnUp;

	[Header("左摇杆0 / 右摇杆1")]
	public int Joysticks_HandId = 1;

	public UnityEvent onUpJoysticks;

	public UnityEvent onDownJoysticks;

	public UnityEvent onLeftJoysticks;

	public UnityEvent onRightJoysticks;

	private void Start()
	{
	}

	private void Update()
	{
		if (Controller.UPvr_GetKeyDown(Joysticks_HandId, getCode()))
		{
			onVirtualBtnDown.Invoke();
		}
		if (Controller.UPvr_GetKeyUp(Joysticks_HandId, getCode()))
		{
			onVirtualBtnUp.Invoke();
		}
		if (Input.GetKey(KeyCode.UpArrow) || (Controller.UPvr_GetAxis2D(Joysticks_HandId).y > 0.5f && CheckAngle(Controller.UPvr_GetAxis2D(Joysticks_HandId).normalized, Vector2.up)))
		{
			onUpJoysticks.Invoke();
		}
		else if (Input.GetKey(KeyCode.DownArrow) || (Controller.UPvr_GetAxis2D(Joysticks_HandId).y < -0.5f && CheckAngle(Controller.UPvr_GetAxis2D(Joysticks_HandId).normalized, Vector2.down)))
		{
			onDownJoysticks.Invoke();
		}
		else if (Input.GetKey(KeyCode.LeftArrow) || (Controller.UPvr_GetAxis2D(Joysticks_HandId).x < -0.5f && CheckAngle(Controller.UPvr_GetAxis2D(Joysticks_HandId).normalized, Vector2.left)))
		{
			onLeftJoysticks.Invoke();
		}
		else if (Input.GetKey(KeyCode.RightArrow) || (Controller.UPvr_GetAxis2D(Joysticks_HandId).x > 0.5f && CheckAngle(Controller.UPvr_GetAxis2D(Joysticks_HandId).normalized, Vector2.right)))
		{
			onRightJoysticks.Invoke();
		}
	}

	private Pvr_KeyCode getCode()
	{
		return wVR_InputId;
	}

	private bool CheckAngle(Vector2 normal, Vector2 vector)
	{
		if (Vector2.Angle(normal, vector) < 45f)
		{
			return true;
		}
		return false;
	}
}
public enum WVR_InputId
{
	WVR_InputId_0 = 0,
	WVR_InputId_1 = 1,
	WVR_InputId_2 = 2,
	WVR_InputId_3 = 3,
	WVR_InputId_4 = 4,
	WVR_InputId_5 = 5,
	WVR_InputId_6 = 6,
	WVR_InputId_7 = 7,
	WVR_InputId_8 = 8,
	WVR_InputId_9 = 9,
	WVR_InputId_14 = 14,
	WVR_InputId_15 = 15,
	WVR_InputId_16 = 16,
	WVR_InputId_17 = 17,
	WVR_InputId_18 = 18,
	WVR_InputId_Alias1_System = 0,
	WVR_InputId_Alias1_Menu = 1,
	WVR_InputId_Alias1_Grip = 2,
	WVR_InputId_Alias1_DPad_Left = 3,
	WVR_InputId_Alias1_DPad_Up = 4,
	WVR_InputId_Alias1_DPad_Right = 5,
	WVR_InputId_Alias1_DPad_Down = 6,
	WVR_InputId_Alias1_Volume_Up = 7,
	WVR_InputId_Alias1_Volume_Down = 8,
	WVR_InputId_Alias1_Digital_Trigger = 9,
	WVR_InputId_Alias1_Back = 14,
	WVR_InputId_Alias1_Enter = 15,
	WVR_InputId_Alias1_Touchpad = 16,
	WVR_InputId_Alias1_Trigger = 17,
	WVR_InputId_Alias1_Thumbstick = 18,
	WVR_InputId_Max = 32
}
public class LevelSelectCtrl : MonoBehaviour
{
	public void J_LoadScene(string sceneName)
	{
		if (sceneName == "TaskSelectionScene")
		{
			LoadLevelSelectionScene();
		}
		else
		{
			Load.LoadScene2(sceneName);
		}
	}

	public void J_ReloadCurrentScene()
	{
		SceneManager.LoadScene(SceneManager.GetActiveScene().name);
	}

	public void ReturnToCenterScene()
	{
		ScenesHelper.LoadScene(ScenesHelper.WeiAiXinCenterScene);
	}

	public static void LoadLevelSelectionScene()
	{
		bool isRes = WaveVRHead.isRes;
		WaveVRHead.Inst.SetGrab(showOrHide: false);
		UnityEngine.Object.Destroy(WaveVRHead.Inst.gameObject);
		WaveVRHead.Inst = null;
		SceneManager.LoadScene(isRes ? "2_MainStart" : "综合训练-单项训练");
	}

	public void J_QuitAPP()
	{
		ToMenu();
	}

	public void ToMenu()
	{
		UnityEngine.Object.Destroy(WaveVRHead.Inst.gameObject);
		WaveVRHead.Inst = null;
		SceneManager.LoadScene("2_MainStart");
	}
}
public static class J_expandMethods
{
	public static void J_DoColorFlash(this Text target, Color fromColor, Color toColor)
	{
		float ftime = 0.5f;
		target.DOColor(toColor, ftime).OnComplete(delegate
		{
			target.DOColor(fromColor, ftime).OnComplete(delegate
			{
				target.DOColor(toColor, ftime).OnComplete(delegate
				{
					target.DOColor(fromColor, ftime);
				});
			});
		});
	}

	public static void J_DoColorFlash(this SpriteRenderer target, Color fromColor, Color toColor)
	{
		float ftime = 0.5f;
		target.DOColor(toColor, ftime).OnComplete(delegate
		{
			target.DOColor(fromColor, ftime).OnComplete(delegate
			{
				target.DOColor(toColor, ftime).OnComplete(delegate
				{
					target.DOColor(fromColor, ftime);
				});
			});
		});
	}
}
public static class J_PlayResult
{
	public enum Result
	{
		Succeed,
		Failed,
		TimeOut
	}

	public static void J_MakeShowResult(this Text txt, Result result)
	{
		Color color = Color.white;
		string text = "";
		switch (result)
		{
		case Result.Succeed:
			color = Color.green;
			text = "真是太棒啦\n(*^▽^*)";
			break;
		case Result.Failed:
			color = Color.red;
			text = "真可惜，还差一点点\no(╥\ufe4f╥)o";
			break;
		case Result.TimeOut:
			color = Color.red;
			text = "时间到，下次继续努力\no(╥\ufe4f╥)o";
			break;
		}
		txt.color = color;
		txt.text = text;
	}

	public static void J_MakeShowResult(this Text txt, Color color, string strmsg)
	{
		txt.color = color;
		txt.text = strmsg;
	}
}
public class NetworkManager : MonoBehaviour
{
	public static string NetworkURL => "test7.guavaamoy.com";
}
public class TaskSelectionSceneCtrl : MonoBehaviour
{
	public Toggle[] m_toggles;

	public GameObject[] m_toggleContens;

	public static int m_iSelectedIndex;

	private IEnumerator Start()
	{
		for (int i = 0; i < m_toggles.Length; i++)
		{
			int iindex = i;
			m_toggles[i].isOn = false;
			m_toggles[i].onValueChanged.AddListener(delegate(bool isOn)
			{
				if (isOn)
				{
					m_iSelectedIndex = iindex;
				}
			});
		}
		GameObject[] toggleContens = m_toggleContens;
		for (int j = 0; j < toggleContens.Length; j++)
		{
			toggleContens[j].SetActive(value: false);
		}
		yield return null;
		m_toggles[m_iSelectedIndex].isOn = false;
		m_toggles[m_iSelectedIndex].isOn = true;
		toggleContens = WaveVRHead.Inst.singleTrain_objects;
		foreach (GameObject gameObject in toggleContens)
		{
			if (gameObject != null)
			{
				gameObject.SetActive(value: true);
			}
		}
	}
}
public class randomTextSpoke : MonoBehaviour
{
	public AudioSource audioSource;

	public Text m_txtShow;

	[TextArea]
	public string[] listStrings;

	private void Start()
	{
		string text = listStrings[UnityEngine.Random.Range(0, listStrings.Length)];
		m_txtShow.text = text;
		BaiduWordToVoiceBase.J_GetAudio(text, delegate(AudioClip audioclip)
		{
			if (audioclip != null)
			{
				audioSource.clip = audioclip;
				audioSource.Play();
			}
		}, 5);
	}

	private void Update()
	{
	}
}
public class vr_RayscrollView : MonoBehaviour, IPointerEnterHandler, IEventSystemHandler, IPointerExitHandler
{
	public RectTransform viewport;

	public RectTransform content;

	private Vector3 anchorLeftPos;

	private Vector3 anchorRightPos;

	public float fMoveDisBaseLimit;

	private bool isEnableS;

	private PointerEventData m_pointerEventData;

	private void Start()
	{
		anchorLeftPos = viewport.TransformPoint(new Vector3((0f - viewport.rect.width) / 2f, 0f));
		anchorRightPos = viewport.TransformPoint(new Vector3(viewport.rect.width / 2f, 0f));
		if (fMoveDisBaseLimit <= 0f)
		{
			base.enabled = false;
			isEnableS = false;
		}
		else
		{
			isEnableS = true;
			content.anchoredPosition = new Vector3(0f, 0f, 0f);
		}
	}

	private void Update()
	{
		if (isEnableS && m_pointerEventData != null && m_pointerEventData.pointerCurrentRaycast.isValid)
		{
			Vector3 worldPosition = m_pointerEventData.pointerCurrentRaycast.worldPosition;
			if (worldPosition.magnitude != 0f)
			{
				Vector3 vector = anchorRightPos - anchorLeftPos;
				float num = Vector3.Dot(worldPosition - anchorLeftPos, vector.normalized) / vector.magnitude * fMoveDisBaseLimit;
				content.anchoredPosition = new Vector3(0f - num, 0f, 0f);
			}
		}
	}

	public void OnPointerEnter(PointerEventData eventData)
	{
		m_pointerEventData = eventData;
	}

	public void OnPointerExit(PointerEventData eventData)
	{
		m_pointerEventData = null;
	}
}
public class TeleportDoorCtrl : MonoBehaviour
{
	public UnityEvent eventOnTRayEnter;

	public UnityEvent eventOnTRayExit;

	public UnityEvent eventOnTeleport;

	private MeshRenderer m_meshRenderer;

	private bool bFlashing;

	private Coroutine coroutineColorChange;

	private void Awake()
	{
		m_meshRenderer = GetComponent<MeshRenderer>();
		m_meshRenderer.enabled = false;
	}

	public void OnTeleportRayEnter()
	{
		UnityEngine.Debug.LogError("OnTeleportRayEnter");
		if (!bFlashing)
		{
			bFlashing = true;
			coroutineColorChange = StartCoroutine(yieldColorChange());
		}
		m_meshRenderer.enabled = true;
		eventOnTRayEnter.Invoke();
	}

	public void OnTeleportRayExit()
	{
		UnityEngine.Debug.LogError("OnTeleportRayExit");
		m_meshRenderer.enabled = false;
		bFlashing = false;
		if (coroutineColorChange != null)
		{
			StopCoroutine(coroutineColorChange);
			coroutineColorChange = null;
		}
		eventOnTRayExit.Invoke();
	}

	public void OnPlayerTeleport()
	{
		UnityEngine.Debug.LogError("OnPlayerTeleport");
		eventOnTeleport.Invoke();
	}

	private IEnumerator yieldColorChange()
	{
		Material meshMat = m_meshRenderer.material;
		Color tempColor = meshMat.color;
		tempColor.a = 0.2f;
		int flashDir = 1;
		while (bFlashing)
		{
			tempColor.a += (float)flashDir * 1.5f * Time.deltaTime;
			if (tempColor.a > 0.8f)
			{
				flashDir = -1;
			}
			if (tempColor.a < 0.2f)
			{
				flashDir = 1;
			}
			meshMat.color = tempColor;
			yield return null;
		}
	}
}
public class LT_BagManager : MonoBehaviour
{
	public class Item
	{
		public string id;

		public Gooditem iteminfo;

		public int iAmount;
	}

	public static List<Item> m_listBagGoods = new List<Item>();

	public static Action onGoodChange;

	private void Start()
	{
	}

	public static void J_AddGood(Gooditem good, int amount)
	{
		IEnumerable<Item> source = m_listBagGoods.Where((Item obj) => obj.id == good.id);
		Item item;
		if (source.Count() > 0)
		{
			item = source.First();
		}
		else
		{
			item = new Item();
			item.id = good.id;
			item.iteminfo = good;
			m_listBagGoods.Add(item);
		}
		item.iAmount += amount;
		if (onGoodChange != null)
		{
			onGoodChange();
		}
		TaskArgs taskArgs = new TaskArgs();
		taskArgs.taskType = eTaskType.BuyGood;
		taskArgs.itemId = good.id;
		taskArgs.amount = amount;
		TaskManager.Inst.CheackTask(taskArgs);
	}

	public static void J_RemoveGood(Gooditem good, int amount)
	{
		IEnumerable<Item> source = m_listBagGoods.Where((Item obj) => obj.id == good.id);
		if (source.Count() > 0)
		{
			Item item = source.First();
			item.iAmount -= amount;
			if (onGoodChange != null)
			{
				onGoodChange();
			}
			if (item.iAmount <= 0)
			{
				m_listBagGoods.Remove(item);
			}
			TaskArgs taskArgs = new TaskArgs();
			taskArgs.taskType = eTaskType.BuyGood;
			taskArgs.itemId = good.id;
			taskArgs.amount = -amount;
			TaskManager.Inst.CheackTask(taskArgs);
		}
	}
}
public class LT_MainStreetManager : MonoBehaviour
{
	[Serializable]
	public class cPlaces
	{
		public string name;

		public Transform doorCamStayPos;

		public string sceneName;
	}

	public List<cPlaces> listPlaces;

	public Dictionary<string, cPlaces> m_listPlacesDic = new Dictionary<string, cPlaces>();

	public static string preEnterDoorPlace;

	private void Awake()
	{
		foreach (cPlaces listPlace in listPlaces)
		{
			if (m_listPlacesDic.ContainsKey(listPlace.name))
			{
				UnityEngine.Debug.LogError("--duplicate :" + listPlace.name);
			}
			else
			{
				m_listPlacesDic.Add(listPlace.name, listPlace);
			}
		}
		if (string.IsNullOrEmpty(preEnterDoorPlace))
		{
			preEnterDoorPlace = "康复中心";
		}
		SetToPlaceDoor(preEnterDoorPlace);
	}

	private void SetToPlaceDoor(string strPlaceName)
	{
		cPlaces cPlaces = m_listPlacesDic[strPlaceName];
		if (WaveVRHead.Inst != null)
		{
			cPlaces.doorCamStayPos.gameObject.SetActive(value: true);
		}
		preEnterDoorPlace = null;
	}

	public void J_LoadScene(string strPlaceName)
	{
		if (!m_listPlacesDic.ContainsKey(strPlaceName))
		{
			UnityEngine.Debug.LogError("place not exist");
			return;
		}
		preEnterDoorPlace = strPlaceName;
		Load.LoadScene2(m_listPlacesDic[strPlaceName].sceneName);
	}
}
public class LT_MissionHallManager : MonoBehaviour
{
	public GameObject canvasTaskListAc;

	public static bool hasAcceptTask = false;

	public Transform transStartPos;

	public Text m_missionContent;

	private List<LT_Task.Task> listCTask = new List<LT_Task.Task>();

	public static bool firstEnter = true;

	private IEnumerator Start()
	{
		if (firstEnter)
		{
			GameObject[] lT_objects = WaveVRHead.Inst.LT_objects;
			foreach (GameObject gameObject in lT_objects)
			{
				if (gameObject != null)
				{
					gameObject.SetActive(value: true);
				}
			}
			WaveVRHead.Inst.ForceSetHeadToTarget(transStartPos.transform.position, transStartPos.transform.eulerAngles);
			firstEnter = false;
		}
		if (hasAcceptTask)
		{
			canvasTaskListAc.SetActive(value: false);
			yield break;
		}
		canvasTaskListAc.SetActive(value: true);
		foreach (LT_Task.Task value in TaskDataManager.Inst.m_dicAllTasks.Values)
		{
			listCTask.Add(TaskManager.Inst.InitTask(value.taskID));
		}
		m_missionContent.text = "";
		for (int j = 0; j < listCTask.Count; j++)
		{
			LT_Task.Task task = listCTask[j];
			if (task != null)
			{
				Text missionContent = m_missionContent;
				missionContent.text = missionContent.text + (j + 1) + "、" + task.description + "\n";
			}
		}
		yield return new WaitForEndOfFrame();
		canvasTaskListAc.SetActive(value: false);
		yield return new WaitForEndOfFrame();
		canvasTaskListAc.SetActive(value: true);
	}

	public void J_StartPlayTasks()
	{
		hasAcceptTask = true;
		foreach (LT_Task.Task item in listCTask)
		{
			if (item != null)
			{
				TaskManager.Inst.AcceptTask(item);
			}
		}
		TaskManager.Inst.StartTask(TaskManager.Inst.FindNextTask());
	}
}
public static class ResourcesDataManager
{
	private static Dictionary<string, UnityEngine.Object> listLoadedObjects = new Dictionary<string, UnityEngine.Object>();

	public static UnityEngine.Object TryGetObject(string filepath)
	{
		if (listLoadedObjects.ContainsKey(filepath))
		{
			return listLoadedObjects[filepath];
		}
		UnityEngine.Object @object = Resources.Load(filepath);
		if (@object == null)
		{
			UnityEngine.Debug.LogError("Resources资源不存在:" + filepath);
		}
		listLoadedObjects.Add(filepath, @object);
		return @object;
	}
}
public class TaskManager : MonoBehaviour
{
	public static TaskManager Inst;

	public static Dictionary<string, LT_Task.Task> m_listTasks = new Dictionary<string, LT_Task.Task>();

	public static Action onChange;

	public static Action onMissionComplete;

	private void Awake()
	{
		Inst = this;
	}

	public LT_Task.Task InitTask(string taskID, int ilevel = 1)
	{
		LT_Task.Task task = TaskDataManager.Inst.GetTaskByID(taskID);
		if (task == null)
		{
			UnityEngine.Debug.LogError("--任务ID不存在:" + taskID);
			return null;
		}
		UnityEngine.Debug.Log("--接受任务:" + taskID);
		TaskDataManager.SetTaskParams(ref task, ilevel);
		return task;
	}

	public void AcceptTask(LT_Task.Task task)
	{
		if (m_listTasks.ContainsKey(task.taskID))
		{
			UnityEngine.Debug.Log($"{task.taskID},任务已经接受过");
			return;
		}
		m_listTasks.Add(task.taskID, task);
		if (onChange != null)
		{
			onChange();
		}
	}

	public LT_Task.Task FindNextTask()
	{
		IEnumerable<LT_Task.Task> source = m_listTasks.Values.Where((LT_Task.Task obj) => !obj.isComplete);
		if (source.Count() == 0)
		{
			UnityEngine.Debug.LogError("--任务全部完成");
			return null;
		}
		return source.First();
	}

	public void StartTask(LT_Task.Task task)
	{
		UnityEngine.Debug.LogWarning("--开始执行任务:" + task.taskID + " 地图:" + task.map);
		J_MapEnterance.m_targetMapName = task.map;
		J_MapEnterance.Inst.FindPathToMap(WaveVRHead.Inst.headCam.position, task.map);
	}

	public static LT_Task.Task FindSpeechTask(string mapName)
	{
		UnityEngine.Debug.LogWarning("try find speech task in map " + mapName);
		IEnumerable<LT_Task.Task> source = m_listTasks.Values.Where((LT_Task.Task obj) => !obj.isComplete && obj.map == mapName && obj.type == 2);
		if (source.Count() > 0)
		{
			return source.First();
		}
		return null;
	}

	public static LT_Task.Task FindSportTask(string taskid)
	{
		UnityEngine.Debug.LogWarning("try find sport task " + taskid);
		IEnumerable<LT_Task.Task> source = m_listTasks.Values.Where((LT_Task.Task obj) => !obj.isComplete && obj.taskID == taskid && obj.type == 3);
		if (source.Count() > 0)
		{
			return source.First();
		}
		return null;
	}

	public void CheackTask(TaskArgs args)
	{
		LT_Task.Task task = null;
		foreach (LT_Task.Task value in m_listTasks.Values)
		{
			if (value.isComplete || value.type != (int)args.taskType)
			{
				continue;
			}
			for (int i = 0; i < value.taskConditions.Count; i++)
			{
				TaskCondition taskCondition = value.taskConditions[i];
				if (taskCondition.CheckCondition(args))
				{
					if (taskCondition.isFinish)
					{
						task = value;
					}
					break;
				}
			}
		}
		if (task != null)
		{
			UnityEngine.Debug.LogWarning("--check is all complete?");
			bool flag = true;
			foreach (TaskCondition taskCondition2 in task.taskConditions)
			{
				UnityEngine.Debug.LogError(taskCondition2.isFinish);
				if (!taskCondition2.isFinish)
				{
					flag = false;
					break;
				}
			}
			if (!flag)
			{
				UnityEngine.Debug.LogError("--任务还没全部完成");
				task = null;
			}
		}
		if (task != null)
		{
			UnityEngine.Debug.LogWarning("--任务完成 " + task.taskID);
			task.isComplete = true;
			if (onChange != null)
			{
				onChange();
			}
			if (onMissionComplete != null)
			{
				onMissionComplete();
			}
			LT_Task.Task task2 = FindNextTask();
			if (task2 == null)
			{
				WaveVRHead.Inst?.ShowWanTip(isAll: true);
				J_MapEnterance.m_targetMapName = null;
			}
			else
			{
				WaveVRHead.Inst?.ShowWanTip(isAll: false);
				StartTask(task2);
			}
		}
	}
}
public class LT_V_TaskListView : MonoBehaviour
{
	public class taskDes : MonoBehaviour
	{
		public Text m_txtDes;

		public Text m_txtState;
	}

	public Transform transTasksContainer;

	public GameObject prefabTaskI;

	private Dictionary<string, taskDes> listTaskViews = new Dictionary<string, taskDes>();

	private void Awake()
	{
		taskDes taskDes = prefabTaskI.gameObject.AddComponent<taskDes>();
		taskDes.m_txtDes = prefabTaskI.transform.Find("TextDes").GetComponent<Text>();
		taskDes.m_txtState = prefabTaskI.transform.Find("TextState").GetComponent<Text>();
		taskDes.gameObject.SetActive(value: false);
		listTaskViews.Clear();
		for (int num = transTasksContainer.childCount - 1; num >= 0; num--)
		{
			Transform child = transTasksContainer.GetChild(num);
			if (!(prefabTaskI == child.gameObject))
			{
				UnityEngine.Object.Destroy(child.gameObject);
			}
		}
	}

	private void OnEnable()
	{
		J_RefreshTaskView();
	}

	public void J_RefreshTaskView()
	{
		foreach (LT_Task.Task value in TaskManager.m_listTasks.Values)
		{
			UnityEngine.Debug.LogWarning(value.taskID);
			if (!listTaskViews.ContainsKey(value.taskID))
			{
				GameObject gameObject = UnityEngine.Object.Instantiate(prefabTaskI);
				gameObject.transform.SetParent(transTasksContainer);
				gameObject.transform.localPosition = Vector3.zero;
				gameObject.transform.localEulerAngles = Vector3.zero;
				gameObject.transform.localScale = Vector3.one;
				gameObject.SetActive(value: true);
				listTaskViews.Add(value.taskID, gameObject.GetComponent<taskDes>());
			}
			taskDes taskDes = listTaskViews[value.taskID];
			taskDes.m_txtDes.text = value.description;
			if (value.isComplete)
			{
				taskDes.m_txtState.color = Color.green;
				taskDes.m_txtState.text = "完成";
			}
			else
			{
				taskDes.m_txtState.color = Color.white;
				taskDes.m_txtState.text = "<=正在进行";
			}
		}
	}
}
public class BakeryVolumeReceiver : MonoBehaviour
{
	public bool forceUsage;

	internal int enterCounter;

	internal BakeryVolumeTrigger movableTrigger;

	private Renderer[] renderers;

	private MaterialPropertyBlock current;

	private void Awake()
	{
		if (renderers == null)
		{
			renderers = GetComponentsInChildren<Renderer>();
		}
		if (forceUsage)
		{
			SetPropertyBlock(new MaterialPropertyBlock());
		}
	}

	public void SetPropertyBlock(MaterialPropertyBlock mb)
	{
		if (renderers == null)
		{
			renderers = GetComponentsInChildren<Renderer>();
		}
		for (int i = 0; i < renderers.Length; i++)
		{
			renderers[i].SetPropertyBlock(mb);
		}
		current = mb;
	}

	private void LateUpdate()
	{
		if (!(movableTrigger == null))
		{
			movableTrigger.UpdateBounds();
			SetPropertyBlock(current);
		}
	}
}
public class BakeryVolumeTrigger : MonoBehaviour
{
	public bool movable;

	private BakeryVolume vol;

	private MaterialPropertyBlock mb;

	private static MaterialPropertyBlock mbEmpty;

	private static int mVolumeMin;

	private static int mVolumeInvSize;

	private void Awake()
	{
		if (mbEmpty == null)
		{
			mbEmpty = new MaterialPropertyBlock();
		}
		vol = GetComponent<BakeryVolume>();
		mb = new MaterialPropertyBlock();
		if (vol.bakedTexture0 != null)
		{
			mb.SetTexture("_Volume0", vol.bakedTexture0);
			mb.SetTexture("_Volume1", vol.bakedTexture1);
			mb.SetTexture("_Volume2", vol.bakedTexture2);
			if (vol.bakedTexture3 != null)
			{
				mb.SetTexture("_Volume3", vol.bakedTexture3);
			}
		}
		if (vol.bakedMask != null)
		{
			mb.SetTexture("_VolumeMask", vol.bakedMask);
		}
		if (mVolumeMin == 0)
		{
			mVolumeMin = Shader.PropertyToID("_VolumeMin");
		}
		if (mVolumeInvSize == 0)
		{
			mVolumeInvSize = Shader.PropertyToID("_VolumeInvSize");
		}
		mb.SetVector(mVolumeMin, vol.GetMin());
		mb.SetVector(mVolumeInvSize, vol.GetInvSize());
		if (vol.supportRotationAfterBake)
		{
			mb.SetMatrix("_VolumeMatrix", vol.GetMatrix());
		}
	}

	private void OnTriggerEnter(Collider c)
	{
		BakeryVolumeReceiver component = c.GetComponent<BakeryVolumeReceiver>();
		if (!(component == null))
		{
			UnityEngine.Debug.Log(c.name + " entered " + base.name);
			component.enterCounter++;
			component.movableTrigger = (movable ? this : null);
			component.SetPropertyBlock(mb);
		}
	}

	private void OnTriggerExit(Collider c)
	{
		BakeryVolumeReceiver component = c.GetComponent<BakeryVolumeReceiver>();
		if (!(component == null))
		{
			UnityEngine.Debug.Log(c.name + " exited " + base.name);
			component.enterCounter--;
			if (component.enterCounter == 0)
			{
				component.SetPropertyBlock(mbEmpty);
			}
		}
	}

	public void UpdateBounds()
	{
		vol.UpdateBounds();
		mb.SetVector(mVolumeMin, vol.GetMin());
		mb.SetVector(mVolumeInvSize, vol.GetInvSize());
	}
}
public class VolumeTestScene2 : MonoBehaviour
{
	public Transform secondFloor;

	public BakeryVolumeTrigger[] secondFloorVolumes;

	public float secondFloorHeight;

	public bool randomizeLastRoom;

	public Transform baseRoom;

	public Transform alternativeRoom;

	private void SwapRooms()
	{
		Vector3 position = alternativeRoom.position;
		alternativeRoom.position = baseRoom.position;
		baseRoom.position = position;
	}

	private void UpdateRooms()
	{
		for (int i = 0; i < secondFloorVolumes.Length; i++)
		{
			secondFloorVolumes[i].UpdateBounds();
		}
	}

	private void Start()
	{
		if (randomizeLastRoom && UnityEngine.Random.Range(0, 2) == 1)
		{
			SwapRooms();
		}
		secondFloor.position += Vector3.up * secondFloorHeight;
		UpdateRooms();
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.Space))
		{
			SwapRooms();
			UpdateRooms();
		}
	}
}
public class MenuSceneLoader : MonoBehaviour
{
	public GameObject menuUI;

	private GameObject m_Go;

	private void Awake()
	{
		if (m_Go == null)
		{
			m_Go = UnityEngine.Object.Instantiate(menuUI);
		}
	}
}
public class PauseMenu : MonoBehaviour
{
	private Toggle m_MenuToggle;

	private float m_TimeScaleRef = 1f;

	private float m_VolumeRef = 1f;

	private bool m_Paused;

	private void Awake()
	{
		m_MenuToggle = GetComponent<Toggle>();
	}

	private void MenuOn()
	{
		m_TimeScaleRef = Time.timeScale;
		Time.timeScale = 0f;
		m_VolumeRef = AudioListener.volume;
		AudioListener.volume = 0f;
		m_Paused = true;
	}

	public void MenuOff()
	{
		Time.timeScale = m_TimeScaleRef;
		AudioListener.volume = m_VolumeRef;
		m_Paused = false;
	}

	public void OnMenuStatusChange()
	{
		if (m_MenuToggle.isOn && !m_Paused)
		{
			MenuOn();
		}
		else if (!m_MenuToggle.isOn && m_Paused)
		{
			MenuOff();
		}
	}
}
public class SceneAndURLLoader : MonoBehaviour
{
	private PauseMenu m_PauseMenu;

	private void Awake()
	{
		m_PauseMenu = GetComponentInChildren<PauseMenu>();
	}

	public void SceneLoad(string sceneName)
	{
		m_PauseMenu.MenuOff();
		SceneManager.LoadScene(sceneName);
	}

	public void LoadURL(string url)
	{
		Application.OpenURL(url);
	}
}
public class CameraSwitch : MonoBehaviour
{
	public GameObject[] objects;

	public Text text;

	private int m_CurrentActiveObject;

	private void OnEnable()
	{
		text.text = objects[m_CurrentActiveObject].name;
	}

	public void NextCamera()
	{
		int num = ((m_CurrentActiveObject + 1 < objects.Length) ? (m_CurrentActiveObject + 1) : 0);
		for (int i = 0; i < objects.Length; i++)
		{
			objects[i].SetActive(i == num);
		}
		m_CurrentActiveObject = num;
		text.text = objects[m_CurrentActiveObject].name;
	}
}
public class LevelReset : MonoBehaviour, IPointerClickHandler, IEventSystemHandler
{
	public void OnPointerClick(PointerEventData data)
	{
		SceneManager.LoadScene(SceneManager.GetSceneAt(0).name);
	}
}
public static class CarWheelsRotation
{
	public static float AngleSigned(Vector3 v1, Vector3 v2, Vector3 n)
	{
		return Mathf.Atan2(Vector3.Dot(n, Vector3.Cross(v1, v2)), Vector3.Dot(v1, v2)) * 57.29578f;
	}
}
public class Lights : MonoBehaviour
{
	private enum States
	{
		On,
		Off
	}

	public LensFlare[] flares;

	public Light[] lights;

	public LensFlare[] stopFlares;

	public Light[] stopLights;

	public AudioSource Signal;

	private States currentState;

	private void Start()
	{
		for (int i = 0; i < stopLights.Length; i++)
		{
			stopLights[i].enabled = false;
		}
		for (int j = 0; j < stopFlares.Length; j++)
		{
			stopFlares[j].enabled = false;
		}
	}

	private void Update()
	{
		if (Input.GetKeyUp(KeyCode.L))
		{
			switch (currentState)
			{
			case States.Off:
			{
				for (int k = 0; k < flares.Length; k++)
				{
					flares[k].enabled = true;
				}
				for (int l = 0; l < lights.Length; l++)
				{
					lights[l].enabled = true;
				}
				currentState = States.On;
				break;
			}
			case States.On:
			{
				for (int i = 0; i < flares.Length; i++)
				{
					flares[i].enabled = false;
				}
				for (int j = 0; j < lights.Length; j++)
				{
					lights[j].enabled = false;
				}
				currentState = States.Off;
				break;
			}
			}
		}
		if (Input.GetKey(KeyCode.S))
		{
			for (int m = 0; m < stopLights.Length; m++)
			{
				stopLights[m].enabled = true;
			}
			for (int n = 0; n < stopFlares.Length; n++)
			{
				stopFlares[n].enabled = true;
			}
		}
		if (Input.GetKeyUp(KeyCode.S))
		{
			for (int num = 0; num < stopLights.Length; num++)
			{
				stopLights[num].enabled = false;
			}
			for (int num2 = 0; num2 < stopFlares.Length; num2++)
			{
				stopFlares[num2].enabled = false;
			}
		}
		if (Input.GetKey(KeyCode.K) && !Signal.isPlaying)
		{
			Signal.Play();
		}
	}
}
public class RotateGameObject : MonoBehaviour
{
	public float rot_speed_x;

	public float rot_speed_y;

	public float rot_speed_z;

	public bool local;

	private void Start()
	{
	}

	private void FixedUpdate()
	{
		if (local)
		{
			base.transform.Rotate(Time.fixedDeltaTime * new Vector3(rot_speed_x, rot_speed_y, rot_speed_z), Space.Self);
		}
		else
		{
			base.transform.Rotate(Time.fixedDeltaTime * new Vector3(rot_speed_x, rot_speed_y, rot_speed_z), Space.World);
		}
	}
}
public class CamMouseOrbit : MonoBehaviour
{
	private float x;

	private float y;

	private float dist;

	public Transform target;

	public float distance = 10f;

	public float xSpeed = 5f;

	public float ySpeed = 2.5f;

	public float distSpeed = 10f;

	public float yMinLimit = -20f;

	public float yMaxLimit = 80f;

	public float distMinLimit = 5f;

	public float distMaxLimit = 50f;

	public float orbitDamping = 4f;

	public float distDamping = 4f;

	private void Awake()
	{
		dist = distance;
	}

	private void Start()
	{
		Vector3 eulerAngles = base.transform.eulerAngles;
		x = eulerAngles.y;
		y = eulerAngles.x;
		if ((bool)GetComponent<Rigidbody>())
		{
			GetComponent<Rigidbody>().freezeRotation = true;
		}
	}

	private void FixedUpdate()
	{
		if ((bool)target)
		{
			x += Input.GetAxis("Mouse X") * xSpeed;
			y -= Input.GetAxis("Mouse Y") * ySpeed;
			distance -= Input.GetAxis("Mouse ScrollWheel") * distSpeed;
			y = ClampAngle(y, yMinLimit, yMaxLimit);
			distance = Mathf.Clamp(distance, distMinLimit, distMaxLimit);
			dist = Mathf.Lerp(dist, distance, distDamping * Time.deltaTime);
			base.transform.rotation = Quaternion.Slerp(base.transform.rotation, Quaternion.Euler(y, x, 0f), Time.deltaTime * orbitDamping);
			base.transform.position = base.transform.rotation * new Vector3(0f, 0f, 0f - dist) + target.position;
		}
	}

	private float ClampAngle(float a, float min, float max)
	{
		while (max < min)
		{
			max += 360f;
		}
		while (a > max)
		{
			a -= 360f;
		}
		while (a < min)
		{
			a += 360f;
		}
		if (a > max)
		{
			if ((double)a - (double)(max + min) * 0.5 < 180.0)
			{
				return max;
			}
			return min;
		}
		return a;
	}
}
[AddComponentMenu("Camera-Control/Mouse Look")]
public class MouseLookAdvanced : MonoBehaviour
{
	public float sensitivityX = 5f;

	public float sensitivityY = 5f;

	public float minimumX = -360f;

	public float maximumX = 360f;

	public float minimumY = -90f;

	public float maximumY = 90f;

	public float smoothSpeed = 20f;

	private float verticalAcceleration;

	private float rotationX;

	private float smoothRotationX;

	private float rotationY;

	private float smoothRotationY;

	private Vector3 vMousePos;

	public float Speed = 100f;

	private Vector3 sp;

	private Vector3 ep;

	private float dist;

	private bool capt;

	private bool captRot;

	private bool IsCursorLock
	{
		get
		{
			return Cursor.lockState == CursorLockMode.Locked;
		}
		set
		{
			Cursor.lockState = (value ? CursorLockMode.Locked : CursorLockMode.None);
		}
	}

	private void Start()
	{
		rotationY = 0f - base.transform.localEulerAngles.x;
		rotationX = base.transform.localEulerAngles.y;
		smoothRotationX = base.transform.localEulerAngles.y;
		smoothRotationY = 0f - base.transform.localEulerAngles.x;
	}

	private void FixedUpdate()
	{
		if (Input.touchCount > 0)
		{
			if (Input.touchCount == 1 && !captRot)
			{
				sp = Input.touches[0].position;
				captRot = true;
			}
			if (Input.touchCount == 1 && captRot)
			{
				Vector2 vector = (Vector2)sp - Input.touches[0].position;
				base.transform.Rotate(vector.normalized * 5f);
			}
			if (captRot && (Input.touchCount == 0 || Input.touches[0].phase == TouchPhase.Ended))
			{
				captRot = false;
			}
			if (Input.touchCount > 1 && !capt)
			{
				sp = Input.touches[0].position;
				ep = Input.touches[1].position;
				dist = Vector3.Distance(sp, ep);
				capt = true;
			}
			if (!capt)
			{
				return;
			}
			if (Input.touchCount == 0)
			{
				capt = false;
				return;
			}
			if (Input.touches[0].phase == TouchPhase.Ended)
			{
				capt = false;
				return;
			}
			float num = Vector3.Distance(Input.touches[0].position, Input.touches[1].position);
			if (num > dist)
			{
				Vector3 vector2 = new Vector3(0f, 0f, num - dist);
				Vector3 vector3 = base.transform.rotation * vector2;
				base.transform.position += vector3 * Time.smoothDeltaTime;
			}
			if (num < dist)
			{
				Vector3 vector4 = new Vector3(0f, 0f, num - dist);
				Vector3 vector5 = base.transform.rotation * vector4;
				base.transform.position += vector5 * Time.smoothDeltaTime;
			}
		}
		else
		{
			verticalAcceleration = 0f;
			if (Input.GetMouseButtonDown(1))
			{
				IsCursorLock = !IsCursorLock;
			}
			if (Input.GetKey(KeyCode.Space))
			{
				verticalAcceleration = 1f;
			}
			if (Input.GetKey(KeyCode.LeftShift))
			{
				verticalAcceleration = -1f;
			}
			if (IsCursorLock)
			{
				rotationX += Input.GetAxis("Mouse X") * sensitivityX;
				rotationY += Input.GetAxis("Mouse Y") * sensitivityY;
				rotationY = Mathf.Clamp(rotationY, minimumY, maximumY);
				smoothRotationX += (rotationX - smoothRotationX) * smoothSpeed * Time.smoothDeltaTime;
				smoothRotationY += (rotationY - smoothRotationY) * smoothSpeed * Time.smoothDeltaTime;
				base.transform.localEulerAngles = new Vector3(0f - smoothRotationY, smoothRotationX, 0f);
				Vector3 vector6 = new Vector3(Input.GetAxis("Horizontal"), 0f, Input.GetAxis("Vertical"));
				Vector3 vector7 = base.transform.rotation * vector6;
				base.transform.position += vector7 * Speed * Time.smoothDeltaTime;
				base.transform.position += new Vector3(0f, Speed / 2f * verticalAcceleration * Time.smoothDeltaTime, 0f);
				base.transform.position += base.transform.rotation * Vector3.forward * Input.GetAxis("Mouse ScrollWheel") * 200f;
			}
		}
	}
}
public class AddTrailer : MonoBehaviour
{
	[SerializeField]
	[Tooltip("Prefab trailer / Префаб прицепа")]
	private GameObject trailerPrefab;

	[SerializeField]
	[Tooltip("Coordinates relative to the truck in which the trailer appears / Координата относительно грузовика, в которой появится прицеп")]
	private Vector3 trailerInitPosition;

	public GameObject trailer;

	public WheelCollider[] wc;

	private void Start()
	{
		Init();
		trailer.transform.position = new Vector3(trailer.transform.position.x, trailer.transform.position.y + 0.3f, trailer.transform.position.z);
	}

	public void OnDestroy()
	{
		if (Application.isPlaying)
		{
			UnityEngine.Object.Destroy(trailer);
		}
		else
		{
			UnityEngine.Object.DestroyImmediate(trailer);
		}
	}

	public void Init()
	{
		if (trailer == null)
		{
			trailer = UnityEngine.Object.Instantiate(trailerPrefab, base.transform.TransformPoint(trailerInitPosition), base.transform.localRotation);
		}
		trailer.GetComponent<ConfigurableJoint>().connectedBody = GetComponent<Rigidbody>();
		SetIgnoreCollisions();
		trailer.transform.rotation = base.transform.localRotation;
		ParentOfTrailer component = trailer.GetComponent<ParentOfTrailer>();
		component.PAR = base.gameObject;
		component.InitTag();
	}

	private void SetIgnoreCollisions()
	{
		Collider[] componentsInChildren = trailer.GetComponentsInChildren<Collider>();
		Collider[] componentsInChildren2 = base.gameObject.GetComponentsInChildren<Collider>();
		for (int i = 0; i < componentsInChildren2.Length; i++)
		{
			for (int j = 0; j < componentsInChildren.Length; j++)
			{
				Physics.IgnoreCollision(componentsInChildren[j], componentsInChildren2[i]);
			}
		}
	}

	private void OnDrawGizmos()
	{
		Gizmos.color = Color.cyan;
		Gizmos.DrawWireSphere(base.transform.TransformPoint(trailerInitPosition), 0.05f);
	}
}
[RequireComponent(typeof(CarMove))]
public class CarAIController : MonoBehaviour
{
	private Rigidbody rigbody;

	private BoxCollider bc;

	private MovePath movePath;

	private CarMove carMove;

	private Vector3 fwdVector;

	private Vector3 LRVector;

	private float startSpeed;

	[SerializeField]
	private float curMoveSpeed;

	[SerializeField]
	private float angleBetweenPoint;

	private float targetSteerAngle;

	private float upTurnTimer;

	private bool moveBrake;

	private bool isACar;

	private bool isABike;

	public bool tempStop;

	private bool insideSemaphore;

	private bool hasTrailer;

	[SerializeField]
	[Tooltip("Vehicle Speed / Скорость автомобиля")]
	private float moveSpeed;

	[SerializeField]
	[Tooltip("Acceleration of the car / Ускорение автомобиля")]
	private float speedIncrease;

	[SerializeField]
	[Tooltip("Deceleration of the car / Торможение автомобиля")]
	private float speedDecrease;

	[SerializeField]
	[Tooltip("Distance to the car for braking / Дистанция до автомобиля для торможения")]
	private float distanceToCar;

	[SerializeField]
	[Tooltip("Distance to the traffic light for braking / Дистанция до светофора для торможения")]
	private float distanceToSemaphore;

	[SerializeField]
	[Tooltip("Maximum rotation angle for braking / Максимальный угол поворота для притормаживания")]
	private float maxAngleToMoveBreak = 8f;

	public float MOVE_SPEED
	{
		get
		{
			return moveSpeed;
		}
		set
		{
			moveSpeed = value;
		}
	}

	public float INCREASE
	{
		get
		{
			return speedIncrease;
		}
		set
		{
			speedIncrease = value;
		}
	}

	public float DECREASE
	{
		get
		{
			return speedDecrease;
		}
		set
		{
			speedDecrease = value;
		}
	}

	public float START_SPEED
	{
		get
		{
			return startSpeed;
		}
		private set
		{
		}
	}

	public float TO_CAR
	{
		get
		{
			return distanceToCar;
		}
		set
		{
			distanceToCar = value;
		}
	}

	public float TO_SEMAPHORE
	{
		get
		{
			return distanceToSemaphore;
		}
		set
		{
			distanceToSemaphore = value;
		}
	}

	public float MaxAngle
	{
		get
		{
			return maxAngleToMoveBreak;
		}
		set
		{
			maxAngleToMoveBreak = value;
		}
	}

	public bool INSIDE
	{
		get
		{
			return insideSemaphore;
		}
		set
		{
			insideSemaphore = value;
		}
	}

	public bool TEMP_STOP
	{
		get
		{
			return tempStop;
		}
		private set
		{
		}
	}

	private void Awake()
	{
		rigbody = GetComponent<Rigidbody>();
		movePath = GetComponent<MovePath>();
		carMove = GetComponent<CarMove>();
	}

	private void Start()
	{
		startSpeed = moveSpeed;
		if (GetComponentsInChildren<WheelCollider>().Length > 2)
		{
			isACar = true;
		}
		else
		{
			isABike = true;
		}
		BoxCollider[] componentsInChildren = GetComponentsInChildren<BoxCollider>();
		bc = (isACar ? componentsInChildren[0] : componentsInChildren[1]);
		if ((bool)GetComponent<AddTrailer>())
		{
			hasTrailer = true;
		}
	}

	private void Update()
	{
		fwdVector = new Vector3(base.transform.position.x + (base.transform.forward.x * bc.size.z / 2f + 0.1f), base.transform.position.y + 0.5f, base.transform.position.z + (base.transform.forward.z * bc.size.z / 2f + 0.1f));
		LRVector = new Vector3(base.transform.position.x + (base.transform.forward.x * bc.size.z / 2f + 0.1f), base.transform.position.y + 0.5f, base.transform.position.z + (base.transform.forward.z * bc.size.z / 2f + 0.1f));
		PushRay();
		if (carMove != null && isACar)
		{
			carMove.Move(curMoveSpeed, 0f, 0f);
		}
	}

	private void FixedUpdate()
	{
		GetPath();
		Drive();
		if (moveBrake)
		{
			moveSpeed = startSpeed * 0.5f;
		}
	}

	private void GetPath()
	{
		Vector3 vector = new Vector3(movePath.finishPos.x, rigbody.transform.position.y, movePath.finishPos.z);
		float num = Vector3.Distance(Vector3.ProjectOnPlane(rigbody.transform.position, Vector3.up), Vector3.ProjectOnPlane(movePath.finishPos, Vector3.up));
		if (num < 5f && (movePath.loop || (!movePath.loop && movePath.targetPoint > 0 && movePath.targetPoint < movePath.targetPointsTotal)))
		{
			if (movePath.forward)
			{
				vector = ((movePath.targetPoint >= movePath.targetPointsTotal) ? movePath.walkPath.getNextPoint(movePath.w, 0) : movePath.walkPath.getNextPoint(movePath.w, movePath.targetPoint + 1));
				vector.y = rigbody.transform.position.y;
			}
			else
			{
				vector = ((movePath.targetPoint <= 0) ? movePath.walkPath.getNextPoint(movePath.w, movePath.targetPointsTotal) : movePath.walkPath.getNextPoint(movePath.w, movePath.targetPoint - 1));
				vector.y = rigbody.transform.position.y;
			}
		}
		if (!isACar)
		{
			Vector3 vector2 = vector - rigbody.transform.position;
			if (vector2 != Vector3.zero)
			{
				Quaternion identity = Quaternion.identity;
				identity = Quaternion.Lerp(rigbody.transform.rotation, Quaternion.LookRotation(vector2), Time.fixedDeltaTime * 4f);
				identity.x = rigbody.transform.rotation.x;
				identity.z = rigbody.transform.rotation.z;
				rigbody.transform.rotation = identity;
			}
		}
		if (num < 10f)
		{
			if (movePath.nextFinishPos != Vector3.zero)
			{
				Vector3 from = movePath.nextFinishPos - base.transform.position;
				angleBetweenPoint = Mathf.Abs(Vector3.SignedAngle(from, base.transform.forward, Vector3.up));
				if (angleBetweenPoint > maxAngleToMoveBreak)
				{
					moveBrake = true;
				}
			}
		}
		else
		{
			moveBrake = false;
		}
		if (num > movePath._walkPointThreshold)
		{
			if (Time.deltaTime > 0f)
			{
				Vector3 vector3 = movePath.finishPos - rigbody.transform.position;
				if (!isACar)
				{
					vector3.y = rigbody.velocity.y;
					rigbody.velocity = new Vector3(vector3.normalized.x * curMoveSpeed, vector3.y, vector3.normalized.z * curMoveSpeed);
				}
				else
				{
					vector3.y = rigbody.velocity.y;
				}
			}
		}
		else if (num <= movePath._walkPointThreshold && movePath.forward)
		{
			if (movePath.targetPoint != movePath.targetPointsTotal)
			{
				movePath.targetPoint++;
				movePath.finishPos = movePath.walkPath.getNextPoint(movePath.w, movePath.targetPoint);
				if (movePath.targetPoint != movePath.targetPointsTotal)
				{
					movePath.nextFinishPos = movePath.walkPath.getNextPoint(movePath.w, movePath.targetPoint + 1);
				}
			}
			else if (movePath.targetPoint == movePath.targetPointsTotal)
			{
				if (movePath.loop)
				{
					movePath.finishPos = movePath.walkPath.getStartPoint(movePath.w);
					movePath.targetPoint = 0;
				}
				else
				{
					movePath.walkPath.SpawnPoints[movePath.w].AddToSpawnQuery(new MovePathParams());
					UnityEngine.Object.Destroy(base.gameObject);
				}
			}
		}
		else
		{
			if (!(num <= movePath._walkPointThreshold) || movePath.forward)
			{
				return;
			}
			if (movePath.targetPoint > 0)
			{
				movePath.targetPoint--;
				movePath.finishPos = movePath.walkPath.getNextPoint(movePath.w, movePath.targetPoint);
				if (movePath.targetPoint > 0)
				{
					movePath.nextFinishPos = movePath.walkPath.getNextPoint(movePath.w, movePath.targetPoint - 1);
				}
			}
			else if (movePath.targetPoint == 0)
			{
				if (movePath.loop)
				{
					movePath.finishPos = movePath.walkPath.getNextPoint(movePath.w, movePath.targetPointsTotal);
					movePath.targetPoint = movePath.targetPointsTotal;
				}
				else
				{
					movePath.walkPath.SpawnPoints[movePath.w].AddToSpawnQuery(new MovePathParams());
					UnityEngine.Object.Destroy(base.gameObject);
				}
			}
		}
	}

	private void Drive()
	{
		CarWheels component = GetComponent<CarWheels>();
		if (tempStop)
		{
			if (hasTrailer)
			{
				curMoveSpeed = Mathf.Lerp(curMoveSpeed, 0f, Time.fixedDeltaTime * (speedDecrease * 2.5f));
			}
			else
			{
				curMoveSpeed = Mathf.Lerp(curMoveSpeed, 0f, Time.fixedDeltaTime * speedDecrease);
			}
			if (curMoveSpeed < 0.15f)
			{
				curMoveSpeed = 0f;
			}
		}
		else
		{
			curMoveSpeed = Mathf.Lerp(curMoveSpeed, moveSpeed, Time.fixedDeltaTime * speedIncrease);
		}
		CarOverturned();
		if (isACar)
		{
			for (int i = 0; i < component.WheelColliders.Length; i++)
			{
				if (component.WheelColliders[i].transform.localPosition.z > 0f)
				{
					component.WheelColliders[i].steerAngle = Mathf.Clamp(CarWheelsRotation.AngleSigned(base.transform.forward, movePath.finishPos - base.transform.position, base.transform.up), -30f, 30f);
				}
			}
		}
		if (rigbody.velocity.magnitude > curMoveSpeed)
		{
			rigbody.velocity = rigbody.velocity.normalized * curMoveSpeed;
		}
	}

	private void CarOverturned()
	{
		WheelCollider[] wheelColliders = GetComponent<CarWheels>().WheelColliders;
		bool flag = false;
		int num = wheelColliders.Length;
		WheelCollider[] array = wheelColliders;
		for (int i = 0; i < array.Length; i++)
		{
			if (!array[i].isGrounded)
			{
				num--;
			}
		}
		if (num == 0)
		{
			flag = true;
		}
		if (flag)
		{
			upTurnTimer += Time.deltaTime;
		}
		else
		{
			upTurnTimer = 0f;
		}
		if (upTurnTimer > 3f)
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}

	private void PushRay()
	{
		Ray ray = new Ray(fwdVector, base.transform.forward * 20f);
		Ray ray2 = new Ray(LRVector - base.transform.right, base.transform.forward * 20f);
		Ray ray3 = new Ray(LRVector + base.transform.right, base.transform.forward * 20f);
		if (Physics.Raycast(ray, out var hitInfo, 20f) || Physics.Raycast(ray2, out hitInfo, 20f) || Physics.Raycast(ray3, out hitInfo, 20f))
		{
			float distance = Vector3.Distance(fwdVector, hitInfo.point);
			if (hitInfo.transform.CompareTag("Car"))
			{
				GameObject gameObject = (hitInfo.transform.GetComponentInChildren<ParentOfTrailer>() ? hitInfo.transform.GetComponent<ParentOfTrailer>().PAR : hitInfo.transform.gameObject);
				if (gameObject != null && gameObject.GetComponent<MovePath>().w == movePath.w)
				{
					ReasonsStoppingCars.CarInView(gameObject, rigbody, distance, startSpeed, ref moveSpeed, ref tempStop, distanceToCar);
				}
			}
			else if (hitInfo.transform.CompareTag("Bcycle"))
			{
				ReasonsStoppingCars.BcycleGyroInView(hitInfo.transform.GetComponentInChildren<BcycleGyroController>(), rigbody, distance, startSpeed, ref moveSpeed, ref tempStop);
			}
			else if (hitInfo.transform.CompareTag("PeopleSemaphore"))
			{
				ReasonsStoppingCars.SemaphoreInView(hitInfo.transform.GetComponent<SemaphorePeople>(), distance, startSpeed, insideSemaphore, ref moveSpeed, ref tempStop, distanceToSemaphore);
			}
			else if (hitInfo.transform.CompareTag("Player") || hitInfo.transform.CompareTag("People"))
			{
				ReasonsStoppingCars.PlayerInView(hitInfo.transform, distance, startSpeed, ref moveSpeed, ref tempStop);
			}
			else
			{
				if (!moveBrake)
				{
					moveSpeed = startSpeed;
				}
				tempStop = false;
			}
		}
		else
		{
			if (!moveBrake)
			{
				moveSpeed = startSpeed;
			}
			tempStop = false;
		}
	}
}
public class CarControl : MonoBehaviour
{
	private CarMove m_Car;

	private void Awake()
	{
		m_Car = GetComponent<CarMove>();
	}

	private void FixedUpdate()
	{
		float axis = CrossPlatformInputManager.GetAxis("Horizontal");
		float axis2 = CrossPlatformInputManager.GetAxis("Vertical");
		m_Car.Move(axis2, axis2, 0f, axis);
	}
}
internal enum CarDriveType
{
	FrontWheelDrive,
	RearWheelDrive,
	FourWheelDrive
}
internal enum SpeedType
{
	MPH,
	KPH
}
public class CarMove : MonoBehaviour
{
	private CarWheels carWheels;

	[SerializeField]
	private CarDriveType m_CarDriveType = CarDriveType.FourWheelDrive;

	[SerializeField]
	private float m_MaximumSteerAngle = 25f;

	[Range(0f, 1f)]
	[SerializeField]
	private float m_SteerHelper = 0.7f;

	[Range(0f, 1f)]
	[SerializeField]
	private float m_TractionControl = 1f;

	[SerializeField]
	private float m_FullTorqueOverAllWheels = 2000f;

	[SerializeField]
	private float m_ReverseTorque = 150f;

	[SerializeField]
	private float m_MaxHandbrakeTorque = 100000000f;

	[SerializeField]
	private float m_Downforce = 100f;

	[SerializeField]
	private SpeedType m_SpeedType;

	[SerializeField]
	private float m_Topspeed = 140f;

	[SerializeField]
	private static int NoOfGears = 5;

	[SerializeField]
	private float m_RevRangeBoundary = 1f;

	[SerializeField]
	private float m_SlipLimit = 0.4f;

	[SerializeField]
	private float m_BrakeTorque = 20000f;

	private Vector3 m_Prevpos;

	private Vector3 m_Pos;

	private float m_SteerAngle;

	private int m_GearNum;

	private float m_GearFactor;

	private float m_OldRotation;

	private float m_CurrentTorque;

	private Rigidbody m_Rigidbody;

	private const float k_ReversingThreshold = 0.01f;

	public bool Skidding { get; private set; }

	public float BrakeInput { get; private set; }

	public float CurrentSteerAngle => m_SteerAngle;

	public float CurrentSpeed => m_Rigidbody.velocity.magnitude * 2.2369363f;

	public float MaxSpeed => m_Topspeed;

	public float Revs { get; private set; }

	public float AccelInput { get; private set; }

	private void Awake()
	{
		carWheels = GetComponent<CarWheels>();
	}

	private void Start()
	{
		m_MaxHandbrakeTorque = float.MaxValue;
		m_Rigidbody = GetComponent<Rigidbody>();
		m_CurrentTorque = m_FullTorqueOverAllWheels - m_TractionControl * m_FullTorqueOverAllWheels;
	}

	private void GearChanging()
	{
		float num = Mathf.Abs(CurrentSpeed / MaxSpeed);
		float num2 = 1f / (float)NoOfGears * (float)(m_GearNum + 1);
		float num3 = 1f / (float)NoOfGears * (float)m_GearNum;
		if (m_GearNum > 0 && num < num3)
		{
			m_GearNum--;
		}
		if (num > num2 && m_GearNum < NoOfGears - 1)
		{
			m_GearNum++;
		}
	}

	private static float CurveFactor(float factor)
	{
		return 1f - (1f - factor) * (1f - factor);
	}

	private static float ULerp(float from, float to, float value)
	{
		return (1f - value) * from + value * to;
	}

	private void CalculateGearFactor()
	{
		float num = 1f / (float)NoOfGears;
		float b = Mathf.InverseLerp(num * (float)m_GearNum, num * (float)(m_GearNum + 1), Mathf.Abs(CurrentSpeed / MaxSpeed));
		m_GearFactor = Mathf.Lerp(m_GearFactor, b, Time.deltaTime * 5f);
	}

	private void CalculateRevs()
	{
		CalculateGearFactor();
		float num = (float)m_GearNum / (float)NoOfGears;
		float from = ULerp(0f, m_RevRangeBoundary, CurveFactor(num));
		float to = ULerp(m_RevRangeBoundary, 1f, num);
		Revs = ULerp(from, to, m_GearFactor);
	}

	public void Move(float accel, float footbrake, float handbrake, float steering = 0f)
	{
		steering = Mathf.Clamp(steering, -1f, 1f);
		AccelInput = (accel = Mathf.Clamp(accel, 0f, 1f));
		BrakeInput = (footbrake = -1f * Mathf.Clamp(footbrake, -1f, 0f));
		handbrake = Mathf.Clamp(handbrake, 0f, 1f);
		m_SteerAngle = steering * m_MaximumSteerAngle;
		carWheels.WheelColliders[0].steerAngle = m_SteerAngle;
		carWheels.WheelColliders[1].steerAngle = m_SteerAngle;
		SteerHelper();
		ApplyDrive(accel, footbrake);
		CapSpeed();
		if (handbrake > 0f)
		{
			float brakeTorque = handbrake * m_MaxHandbrakeTorque;
			carWheels.WheelColliders[2].brakeTorque = brakeTorque;
			carWheels.WheelColliders[3].brakeTorque = brakeTorque;
		}
		CalculateRevs();
		GearChanging();
		AddDownForce();
		TractionControl();
	}

	private void CapSpeed()
	{
		float magnitude = m_Rigidbody.velocity.magnitude;
		switch (m_SpeedType)
		{
		case SpeedType.MPH:
			magnitude *= 2.2369363f;
			if (magnitude > m_Topspeed)
			{
				m_Rigidbody.velocity = m_Topspeed / 2.2369363f * m_Rigidbody.velocity.normalized;
			}
			break;
		case SpeedType.KPH:
			magnitude *= 3.6f;
			if (magnitude > m_Topspeed)
			{
				m_Rigidbody.velocity = m_Topspeed / 3.6f * m_Rigidbody.velocity.normalized;
			}
			break;
		}
	}

	private void ApplyDrive(float accel, float footbrake)
	{
		switch (m_CarDriveType)
		{
		case CarDriveType.FourWheelDrive:
		{
			float num = accel * (m_CurrentTorque / 4f);
			for (int i = 0; i < carWheels.WheelColliders.Length; i++)
			{
				carWheels.WheelColliders[i].motorTorque = num;
			}
			break;
		}
		case CarDriveType.FrontWheelDrive:
		{
			float num = accel * (m_CurrentTorque / 2f);
			WheelCollider obj2 = carWheels.WheelColliders[0];
			float motorTorque = (carWheels.WheelColliders[1].motorTorque = num);
			obj2.motorTorque = motorTorque;
			break;
		}
		case CarDriveType.RearWheelDrive:
		{
			float num = accel * (m_CurrentTorque / 2f);
			WheelCollider obj = carWheels.WheelColliders[2];
			float motorTorque = (carWheels.WheelColliders[3].motorTorque = num);
			obj.motorTorque = motorTorque;
			break;
		}
		}
		for (int j = 0; j < carWheels.WheelColliders.Length; j++)
		{
			if (CurrentSpeed > 5f && Vector3.Angle(base.transform.forward, m_Rigidbody.velocity) < 50f)
			{
				carWheels.WheelColliders[j].brakeTorque = m_BrakeTorque * footbrake;
			}
			else if (footbrake > 0f)
			{
				carWheels.WheelColliders[j].brakeTorque = 0f;
				carWheels.WheelColliders[j].motorTorque = (0f - m_ReverseTorque) * footbrake;
			}
		}
	}

	private void SteerHelper()
	{
		for (int i = 0; i < carWheels.WheelColliders.Length; i++)
		{
			carWheels.WheelColliders[i].GetGroundHit(out var hit);
			if (hit.normal == Vector3.zero)
			{
				return;
			}
		}
		if (Mathf.Abs(m_OldRotation - base.transform.eulerAngles.y) < 10f)
		{
			Quaternion quaternion = Quaternion.AngleAxis((base.transform.eulerAngles.y - m_OldRotation) * m_SteerHelper, Vector3.up);
			m_Rigidbody.velocity = quaternion * m_Rigidbody.velocity;
		}
		m_OldRotation = base.transform.eulerAngles.y;
	}

	private void AddDownForce()
	{
		carWheels.WheelColliders[0].attachedRigidbody.AddForce(-base.transform.up * m_Downforce * carWheels.WheelColliders[0].attachedRigidbody.velocity.magnitude);
	}

	private void TractionControl()
	{
		WheelHit hit;
		switch (m_CarDriveType)
		{
		case CarDriveType.FourWheelDrive:
		{
			for (int i = 0; i < carWheels.WheelColliders.Length; i++)
			{
				carWheels.WheelColliders[i].GetGroundHit(out hit);
				AdjustTorque(hit.forwardSlip);
			}
			break;
		}
		case CarDriveType.RearWheelDrive:
			carWheels.WheelColliders[2].GetGroundHit(out hit);
			AdjustTorque(hit.forwardSlip);
			carWheels.WheelColliders[3].GetGroundHit(out hit);
			AdjustTorque(hit.forwardSlip);
			break;
		case CarDriveType.FrontWheelDrive:
			carWheels.WheelColliders[0].GetGroundHit(out hit);
			AdjustTorque(hit.forwardSlip);
			carWheels.WheelColliders[1].GetGroundHit(out hit);
			AdjustTorque(hit.forwardSlip);
			break;
		}
	}

	private void AdjustTorque(float forwardSlip)
	{
		if (forwardSlip >= m_SlipLimit && m_CurrentTorque >= 0f)
		{
			m_CurrentTorque -= 10f * m_TractionControl;
			return;
		}
		m_CurrentTorque += 10f * m_TractionControl;
		if (m_CurrentTorque > m_FullTorqueOverAllWheels)
		{
			m_CurrentTorque = m_FullTorqueOverAllWheels;
		}
	}
}
public class CarWheels : MonoBehaviour
{
	public WheelCollider[] WheelColliders;

	public Transform[] tireMeshes;

	public bool useCustomCenterOfMass;

	public Vector3 centerOfMassOffset;

	private void Start()
	{
		CheckCenterOfMass();
	}

	private void Update()
	{
		UpdateMeshesPositions();
	}

	private void CheckCenterOfMass()
	{
		if (useCustomCenterOfMass)
		{
			GetComponent<Rigidbody>().centerOfMass = centerOfMassOffset;
		}
	}

	private void UpdateMeshesPositions()
	{
		for (int i = 0; i < WheelColliders.Length; i++)
		{
			WheelColliders[i].GetWorldPose(out var pos, out var quat);
			tireMeshes[i].position = pos;
			tireMeshes[i].rotation = quat;
		}
	}
}
[ExecuteInEditMode]
public class EasySuspension : MonoBehaviour
{
	[Range(0f, 20f)]
	public float naturalFrequency = 10f;

	[Range(0f, 3f)]
	public float dampingRatio = 0.8f;

	[Range(-1f, 1f)]
	public float forceShift = 0.03f;

	public bool setSuspensionDistance = true;

	private void Update()
	{
		WheelCollider[] componentsInChildren = GetComponentsInChildren<WheelCollider>();
		foreach (WheelCollider wheelCollider in componentsInChildren)
		{
			JointSpring suspensionSpring = wheelCollider.suspensionSpring;
			suspensionSpring.spring = Mathf.Pow(Mathf.Sqrt(wheelCollider.sprungMass) * naturalFrequency, 2f);
			suspensionSpring.damper = 2f * dampingRatio * Mathf.Sqrt(suspensionSpring.spring * wheelCollider.sprungMass);
			wheelCollider.suspensionSpring = suspensionSpring;
			Vector3 vector = base.transform.InverseTransformPoint(wheelCollider.transform.position);
			float num = GetComponent<Rigidbody>().centerOfMass.y - vector.y + wheelCollider.radius;
			wheelCollider.forceAppPointDistance = num - forceShift;
			if (suspensionSpring.targetPosition > 0f && setSuspensionDistance)
			{
				wheelCollider.suspensionDistance = wheelCollider.sprungMass * Physics.gravity.magnitude / (suspensionSpring.targetPosition * suspensionSpring.spring);
			}
		}
	}
}
public class ParentOfTrailer : MonoBehaviour
{
	private GameObject par;

	public GameObject PAR
	{
		get
		{
			if (par != null)
			{
				return par;
			}
			return null;
		}
		set
		{
			par = value;
		}
	}

	public void InitTag()
	{
		base.gameObject.tag = par.tag;
	}
}
public class ReasonsStoppingCars : MonoBehaviour
{
	public static void CarInView(GameObject go, Rigidbody rigbody, float distance, float startSpeed, ref float moveSpeed, ref bool tempStop, float distanceToCar = 15f)
	{
		if (go == null)
		{
			return;
		}
		CarAIController component = go.GetComponent<CarAIController>();
		if (distance >= distanceToCar)
		{
			if (component.TEMP_STOP)
			{
				moveSpeed = startSpeed * 0.5f;
			}
			else
			{
				moveSpeed = startSpeed;
			}
			tempStop = false;
		}
		else if (distance < distanceToCar)
		{
			if (component.GetComponent<Rigidbody>().velocity.magnitude < rigbody.velocity.magnitude)
			{
				tempStop = true;
			}
			else if (!component.TEMP_STOP)
			{
				tempStop = false;
			}
		}
	}

	public static void SemaphoreInView(SemaphorePeople semaphore, float distance, float startSpeed, bool insideSemaphore, ref float moveSpeed, ref bool tempStop, float distanceToSem = 10f)
	{
		if (distance >= distanceToSem)
		{
			if (semaphore.CAR_CAN)
			{
				if (semaphore.HOW_MANY > 0)
				{
					moveSpeed = startSpeed * 0.5f;
				}
				else if (semaphore.FLICKER)
				{
					if (!insideSemaphore)
					{
						moveSpeed = startSpeed * 0.5f;
						return;
					}
					moveSpeed = startSpeed;
					tempStop = false;
				}
				else
				{
					moveSpeed = startSpeed;
					tempStop = false;
				}
			}
			else if (!insideSemaphore)
			{
				moveSpeed = startSpeed * 0.5f;
			}
			else
			{
				moveSpeed = startSpeed;
				tempStop = false;
			}
		}
		else if (semaphore.CAR_CAN)
		{
			if (semaphore.HOW_MANY > 0)
			{
				tempStop = true;
				return;
			}
			moveSpeed = startSpeed;
			tempStop = false;
		}
		else if (!insideSemaphore)
		{
			tempStop = true;
		}
		else if (semaphore.HOW_MANY > 0)
		{
			tempStop = true;
		}
		else
		{
			tempStop = false;
			moveSpeed = startSpeed;
		}
	}

	public static void PlayerInView(Transform player, float distance, float startSpeed, ref float moveSpeed, ref bool tempStop)
	{
		if (distance >= 8f)
		{
			moveSpeed = startSpeed * 0.5f;
		}
		else
		{
			tempStop = true;
		}
	}

	public static void BcycleGyroInView(BcycleGyroController controller, Rigidbody rigbody, float distance, float startSpeed, ref float moveSpeed, ref bool tempStop)
	{
		if (distance >= 9f)
		{
			if (controller.tempStop)
			{
				moveSpeed = startSpeed * 0.5f;
			}
			else
			{
				moveSpeed = startSpeed;
			}
			tempStop = false;
		}
		else if (distance < 9f)
		{
			if (controller.GetComponent<Rigidbody>().velocity.magnitude < rigbody.velocity.magnitude)
			{
				UnityEngine.Debug.Log("1");
				tempStop = true;
			}
			else if (!controller.tempStop)
			{
				tempStop = false;
			}
		}
	}
}
public class BcycleGyroPath : WalkPath
{
	[Tooltip("Bicyclist Speed/ Скорость велосипедиста")]
	public float moveSpeed = 8f;

	[Tooltip("Acceleration / Ускорение")]
	public float increaseSpeed = 2f;

	[Tooltip("Braking / Торможение")]
	public float decreaseSpeed = 5f;

	[Range(0.1f, 5f)]
	[Tooltip("Offset from the line along the X axis / Смещение от линии по оси X")]
	public float randXPos = 0.1f;

	[Range(0.1f, 5f)]
	[Tooltip("Offset from the line along the Z axis / Смещение от линии по оси Z")]
	public float randZPos = 0.1f;

	[Tooltip("Скорость поворота")]
	public float speedRotation = 5f;

	[HideInInspector]
	[SerializeField]
	[Tooltip("Ignore pedestrian colliders? / Игнорировать коллайдеры пешеходов?")]
	private bool _ignorePeople;

	[HideInInspector]
	[SerializeField]
	[Tooltip("Customize your animation speed / Настроить свою скорость анимации?")]
	private bool _overrideDefaultAnimationMultiplier = true;

	[HideInInspector]
	[SerializeField]
	[Tooltip("Animation speed / Скорость анимации")]
	private float _customAnimationMultiplier = 2f;

	[Tooltip("Distance to next point / Расстояние до следующей точки")]
	public float nextPointThreshold = 3f;

	private void Start()
	{
		if (_ignorePeople)
		{
			Physics.IgnoreLayerCollision(12, 8, ignore: true);
		}
	}

	public override void CreateSpawnPoints()
	{
		SpawnPoints = new SpawnPoint[points.GetLength(0)];
		for (int i = 0; i < points.GetLength(0); i++)
		{
			Vector3 spawnPoint = (_forward[i] ? points[i, 0] : points[i, points.GetLength(1) - 1]);
			Vector3 nextPoint = (_forward[i] ? points[i, 2] : points[i, points.GetLength(1) - 3]);
			SpawnPoints[i] = SpawnPoint.PeopleCreate($"SpawnPoint (Path {i + 1})", spawnPoint, nextPoint, lineSpacing, i, _forward[i], this, 3f, 1f);
		}
	}

	public override void SpawnOnePeople(int w, bool forward)
	{
		List<GameObject> list = new List<GameObject>(walkingPrefabs);
		for (int num = list.Count - 1; num >= 0; num--)
		{
			if (list[num] == null)
			{
				list.RemoveAt(num);
			}
		}
		walkingPrefabs = list.ToArray();
		int num2 = UnityEngine.Random.Range(0, walkingPrefabs.Length);
		GameObject gameObject = base.gameObject;
		gameObject = (forward ? UnityEngine.Object.Instantiate(walkingPrefabs[num2], points[w, 1], Quaternion.identity) : UnityEngine.Object.Instantiate(walkingPrefabs[num2], points[w, pointLength[0] - 2], Quaternion.identity));
		MovePath movePath = gameObject.AddComponent<MovePath>();
		BcycleGyroController _bcycleGyro = gameObject.AddComponent<BcycleGyroController>();
		InitializeBcycleGyro(ref _bcycleGyro);
		movePath.randXFinish = UnityEngine.Random.Range(0f - randXPos, randXPos);
		movePath.randZFinish = UnityEngine.Random.Range(0f - randZPos, randZPos);
		gameObject.transform.parent = par.transform;
		movePath.walkPath = this;
		if (!forward)
		{
			movePath.InitStartPosition(w, pointLength[0] - 3, loopPath, forward);
			gameObject.transform.LookAt(points[w, pointLength[0] - 3]);
		}
		else
		{
			movePath.InitStartPosition(w, 1, loopPath, forward);
			gameObject.transform.LookAt(points[w, 2]);
		}
		movePath._walkPointThreshold = nextPointThreshold;
	}

	public override void SpawnPeople()
	{
		List<GameObject> list = new List<GameObject>(walkingPrefabs);
		for (int num = list.Count - 1; num >= 0; num--)
		{
			if (list[num] == null)
			{
				list.RemoveAt(num);
			}
		}
		walkingPrefabs = list.ToArray();
		if (points == null)
		{
			DrawCurved(withDraw: false);
		}
		if (par == null)
		{
			par = new GameObject();
			par.transform.parent = base.gameObject.transform;
			par.name = "walkingObjects";
		}
		int num2 = (loopPath ? (pointLength[0] - 1) : (pointLength[0] - 2));
		if (num2 < 2)
		{
			return;
		}
		int num3 = (loopPath ? (pointLength[0] - 1) : (pointLength[0] - 2));
		for (int i = 0; i < numberOfWays; i++)
		{
			_distances = new float[num3];
			float num4 = 0f;
			for (int j = 1; j < num3; j++)
			{
				num4 += ((!loopPath || j != num3 - 1) ? (points[i, j + 1] - points[i, j]) : (points[i, 1] - points[i, num3])).magnitude;
				_distances[j] = num4;
			}
			bool forward = false;
			switch (direction.ToString())
			{
			case "Forward":
				forward = true;
				break;
			case "Backward":
				forward = false;
				break;
			case "HugLeft":
				forward = (i + 2) % 2 == 0;
				break;
			case "HugRight":
				forward = (i + 2) % 2 != 0;
				break;
			case "WeaveLeft":
				forward = i != 1 && i != 2 && (i - 1) % 4 != 0 && (i - 2) % 4 != 0;
				break;
			case "WeaveRight":
				forward = i == 1 || i == 2 || (i - 1) % 4 == 0 || (i - 2) % 4 == 0;
				break;
			}
			int num5 = Mathf.FloorToInt(Density * num4 / _minimalObjectLength);
			float num6 = _minimalObjectLength + (num4 - (float)num5 * _minimalObjectLength) / (float)num5;
			int[] randomPrefabIndexes = CommonUtils.GetRandomPrefabIndexes(num5, ref walkingPrefabs);
			Vector3[] array = new Vector3[_distances.Length];
			for (int k = 1; k < _distances.Length; k++)
			{
				array[k - 1] = points[i, k];
			}
			array[_distances.Length - 1] = (loopPath ? points[i, 1] : points[i, _distances.Length]);
			for (int l = 0; l < num5; l++)
			{
				_ = base.gameObject;
				float num7 = UnityEngine.Random.Range((0f - num6) / 3f, num6 / 3f) + (float)i * num6;
				float distance = (float)(l + 1) * num6 + num7;
				Vector3 routePosition = GetRoutePosition(array, distance, num3, loopPath);
				float num8 = UnityEngine.Random.Range(0f - randXPos, randXPos);
				float num9 = UnityEngine.Random.Range(0f - randZPos, randZPos);
				routePosition = new Vector3(routePosition.x + num8, routePosition.y, routePosition.z + num9);
				Vector3 origin = new Vector3(routePosition.x, routePosition.y + 10000f, routePosition.z);
				RaycastHit[] array2 = Physics.RaycastAll(origin, Vector3.down, float.PositiveInfinity);
				bool flag = false;
				for (int m = 0; m < array2.Length; m++)
				{
					if (array2[m].collider.GetComponent<SemaphoreSimulator>() != null || array2[m].collider.GetComponent<SemaphorePeople>() != null)
					{
						flag = true;
					}
				}
				if (flag)
				{
					continue;
				}
				float num10 = 0f;
				int num11 = 0;
				origin = new Vector3(routePosition.x, routePosition.y + highToSpawn, routePosition.z);
				array2 = Physics.RaycastAll(origin, Vector3.down, float.PositiveInfinity);
				for (int n = 0; n < array2.Length; n++)
				{
					if (num10 < Vector3.Distance(array2[0].point, origin))
					{
						num11 = n;
						num10 = Vector3.Distance(array2[0].point, origin);
					}
				}
				if (array2.Length != 0)
				{
					routePosition.y = array2[num11].point.y;
				}
				GameObject obj = UnityEngine.Object.Instantiate(walkingPrefabs[randomPrefabIndexes[l]], routePosition, Quaternion.identity);
				MovePath movePath = obj.AddComponent<MovePath>();
				BcycleGyroController _bcycleGyro = obj.AddComponent<BcycleGyroController>();
				InitializeBcycleGyro(ref _bcycleGyro);
				movePath.randXFinish = num8;
				movePath.randZFinish = num9;
				obj.transform.parent = par.transform;
				movePath.walkPath = this;
				movePath._walkPointThreshold = nextPointThreshold;
				movePath.InitStartPosition(i, GetRoutePoint((float)(l + 1) * num6 + num7, i, num3, forward, loopPath), loopPath, forward);
				movePath.SetLookPosition();
			}
		}
	}

	private void InitializeBcycleGyro(ref BcycleGyroController _bcycleGyro)
	{
		float num = moveSpeed + UnityEngine.Random.Range(moveSpeed * -0.15f, moveSpeed * 0.15f);
		_bcycleGyro.moveSpeed = num;
		_bcycleGyro.increaseSpeed = increaseSpeed;
		_bcycleGyro.decreaseSpeed = decreaseSpeed;
		_bcycleGyro.speedRotation = speedRotation;
		_bcycleGyro.OverrideDefaultAnimationMultiplier = _overrideDefaultAnimationMultiplier;
		_bcycleGyro.CustomAnimationMultiplier = _customAnimationMultiplier;
	}
}
public class CarWalkPath : WalkPath
{
	[Tooltip("Vehicle Speed / Скорость машины")]
	public float moveSpeed = 12f;

	[Tooltip("Vehicle Deseleration / Торможение машины")]
	public float speadDecrease = 2f;

	[Tooltip("Vehicle Acceleration / Ускорение автомобиля")]
	public float speadIncrease = 2f;

	[Tooltip("Distance to Car / Расстояние до автомобиля")]
	public float distanceToCar = 10f;

	[Tooltip("Distance to traffic lights / Расстояние до светофора")]
	public float distanceToSemaphore = 10f;

	[HideInInspector]
	[SerializeField]
	[Tooltip("Ignore pedestrian colliders? / Игнорировать коллайдеры пешеходов?")]
	private bool _ignorePeople;

	[Tooltip("Distance to the point / Расстояние до точки")]
	public float nextPointThreshold = 3f;

	[Tooltip("Maximum rotation angle for braking / Максимальный угол поворота для притормаживания")]
	public float maxAngleToMoveBreak = 8f;

	private void Start()
	{
		if (_ignorePeople)
		{
			Physics.IgnoreLayerCollision(9, 8, ignore: true);
		}
	}

	public override void CreateSpawnPoints()
	{
		SpawnPoints = new SpawnPoint[points.GetLength(0)];
		for (int i = 0; i < points.GetLength(0); i++)
		{
			Vector3 spawnPoint = (_forward[i] ? points[i, 0] : points[i, points.GetLength(1) - 1]);
			Vector3 nextPoint = (_forward[i] ? points[i, 2] : points[i, points.GetLength(1) - 3]);
			SpawnPoints[i] = SpawnPoint.CarCreate($"SpawnPoint (Path {i + 1})", spawnPoint, nextPoint, lineSpacing, i, _forward[i], this);
		}
	}

	public override void SpawnOnePeople(int w, bool forward)
	{
		List<GameObject> list = new List<GameObject>(walkingPrefabs);
		for (int num = list.Count - 1; num >= 0; num--)
		{
			if (list[num] == null)
			{
				list.RemoveAt(num);
			}
		}
		walkingPrefabs = list.ToArray();
		int num2 = UnityEngine.Random.Range(0, walkingPrefabs.Length);
		GameObject gameObject = base.gameObject;
		gameObject = (forward ? UnityEngine.Object.Instantiate(walkingPrefabs[num2], points[w, 1], Quaternion.identity) : UnityEngine.Object.Instantiate(walkingPrefabs[num2], points[w, pointLength[0] - 2], Quaternion.identity));
		MovePath movePath = gameObject.AddComponent<MovePath>();
		CarAIController carAIController = gameObject.AddComponent<CarAIController>();
		CarInitialize(ref carAIController);
		gameObject.transform.parent = par.transform;
		movePath.walkPath = this;
		if (!forward)
		{
			movePath.InitStartPosition(w, pointLength[0] - 3, loopPath, forward);
			gameObject.transform.LookAt(points[w, pointLength[0] - 3]);
		}
		else
		{
			movePath.InitStartPosition(w, 1, loopPath, forward);
			gameObject.transform.LookAt(points[w, 2]);
		}
		movePath._walkPointThreshold = nextPointThreshold;
	}

	public override void SpawnPeople()
	{
		List<GameObject> list = new List<GameObject>(walkingPrefabs);
		for (int num = list.Count - 1; num >= 0; num--)
		{
			if (list[num] == null)
			{
				list.RemoveAt(num);
			}
		}
		walkingPrefabs = list.ToArray();
		if (points == null)
		{
			DrawCurved(withDraw: false);
		}
		if (par == null)
		{
			par = new GameObject();
			par.transform.parent = base.gameObject.transform;
			par.name = "walkingObjects";
		}
		int num2 = (loopPath ? (pointLength[0] - 1) : (pointLength[0] - 2));
		if (num2 < 2)
		{
			return;
		}
		int num3 = (loopPath ? (pointLength[0] - 1) : (pointLength[0] - 2));
		for (int i = 0; i < numberOfWays; i++)
		{
			_distances = new float[num3];
			float num4 = 0f;
			for (int j = 1; j < num3; j++)
			{
				num4 += ((!loopPath || j != num3 - 1) ? (points[i, j + 1] - points[i, j]) : (points[i, 1] - points[i, num3])).magnitude;
				_distances[j] = num4;
			}
			bool forward = false;
			switch (direction.ToString())
			{
			case "Forward":
				forward = true;
				break;
			case "Backward":
				forward = false;
				break;
			case "HugLeft":
				forward = (i + 2) % 2 == 0;
				break;
			case "HugRight":
				forward = (i + 2) % 2 != 0;
				break;
			case "WeaveLeft":
				forward = i != 1 && i != 2 && (i - 1) % 4 != 0 && (i - 2) % 4 != 0;
				break;
			case "WeaveRight":
				forward = i == 1 || i == 2 || (i - 1) % 4 == 0 || (i - 2) % 4 == 0;
				break;
			}
			int num5 = Mathf.FloorToInt(Density * num4 / _minimalObjectLength * 0.2f);
			float num6 = _minimalObjectLength + (num4 - (float)num5 * _minimalObjectLength) / (float)num5;
			int[] randomPrefabIndexes = CommonUtils.GetRandomPrefabIndexes(num5, ref walkingPrefabs);
			Vector3[] array = new Vector3[_distances.Length];
			for (int k = 1; k < _distances.Length; k++)
			{
				array[k - 1] = points[i, k];
			}
			array[_distances.Length - 1] = (loopPath ? points[i, 1] : points[i, _distances.Length]);
			for (int l = 0; l < num5; l++)
			{
				GameObject gameObject = base.gameObject;
				float num7 = UnityEngine.Random.Range((0f - num6) / 3f, num6 / 3f) + (float)i * num6;
				float distance = (float)(l + 1) * num6 + num7;
				Vector3 routePosition = GetRoutePosition(array, distance, num3, loopPath);
				Vector3 origin = new Vector3(routePosition.x, routePosition.y + 10000f, routePosition.z);
				RaycastHit[] array2 = Physics.RaycastAll(origin, Vector3.down, float.PositiveInfinity);
				bool flag = false;
				for (int m = 0; m < array2.Length; m++)
				{
					if (array2[m].collider.GetComponent<SemaphoreSimulator>() != null || array2[m].collider.GetComponent<SemaphorePeople>() != null)
					{
						flag = true;
					}
				}
				if (flag)
				{
					continue;
				}
				float num8 = 0f;
				int num9 = 0;
				origin = new Vector3(routePosition.x, routePosition.y + highToSpawn, routePosition.z);
				array2 = Physics.RaycastAll(origin, Vector3.down, float.PositiveInfinity);
				for (int n = 0; n < array2.Length; n++)
				{
					if (num8 < Vector3.Distance(array2[0].point, origin))
					{
						num9 = n;
						num8 = Vector3.Distance(array2[0].point, origin);
					}
				}
				if (array2.Length != 0)
				{
					routePosition.y = array2[num9].point.y;
				}
				gameObject = UnityEngine.Object.Instantiate(walkingPrefabs[randomPrefabIndexes[l]], routePosition, Quaternion.identity);
				MovePath movePath = gameObject.AddComponent<MovePath>();
				CarAIController carAIController = gameObject.AddComponent<CarAIController>();
				CarInitialize(ref carAIController);
				gameObject.transform.parent = par.transform;
				movePath.walkPath = this;
				movePath._walkPointThreshold = nextPointThreshold;
				movePath.InitStartPosition(i, GetRoutePoint((float)(l + 1) * num6 + num7, i, num3, forward, loopPath), loopPath, forward);
				movePath.SetLookPosition();
				if ((bool)gameObject.GetComponent<AddTrailer>())
				{
					gameObject.GetComponent<AddTrailer>().Init();
				}
			}
		}
	}

	private void CarInitialize(ref CarAIController carAIController)
	{
		float value = moveSpeed + UnityEngine.Random.Range(moveSpeed * -0.15f, moveSpeed * 0.15f);
		value = Mathf.Clamp(value, 0f, 15f);
		carAIController.MOVE_SPEED = value;
		carAIController.INCREASE = speadIncrease;
		carAIController.DECREASE = speadDecrease;
		carAIController.TO_CAR = distanceToCar;
		carAIController.TO_SEMAPHORE = distanceToSemaphore;
		carAIController.MaxAngle = maxAngleToMoveBreak;
	}
}
public class MovePath : MonoBehaviour
{
	[HideInInspector]
	public float _walkPointThreshold = 0.5f;

	[HideInInspector]
	public int w;

	[HideInInspector]
	public bool forward;

	[HideInInspector]
	public WalkPath walkPath;

	public Vector3 finishPos;

	public Vector3 nextFinishPos = Vector3.zero;

	[HideInInspector]
	public int targetPoint;

	[HideInInspector]
	public int targetPointsTotal;

	[HideInInspector]
	public float randXFinish;

	[HideInInspector]
	public float randZFinish;

	[HideInInspector]
	public bool loop;

	public void InitStartPosition(int _w, int _i, bool _loop, bool _forward)
	{
		forward = _forward;
		WalkPath walkPath = this.walkPath;
		w = _w;
		targetPointsTotal = walkPath.getPointsTotal(0) - 2;
		loop = _loop;
		if (loop)
		{
			if (_i < targetPointsTotal && _i > 0)
			{
				if (forward)
				{
					targetPoint = _i + 1;
					finishPos = walkPath.getNextPoint(w, _i + 1);
				}
				else
				{
					targetPoint = _i;
					finishPos = walkPath.getNextPoint(w, _i);
				}
			}
			else if (forward)
			{
				targetPoint = 1;
				finishPos = walkPath.getNextPoint(w, 1);
			}
			else
			{
				targetPoint = targetPointsTotal;
				finishPos = walkPath.getNextPoint(w, targetPointsTotal);
			}
		}
		else if (forward)
		{
			targetPoint = _i + 1;
			finishPos = walkPath.getNextPoint(w, _i + 1);
		}
		else
		{
			targetPoint = _i;
			finishPos = walkPath.getNextPoint(w, _i);
		}
	}

	public void SetLookPosition()
	{
		Vector3 worldPosition = new Vector3(finishPos.x, base.transform.position.y, finishPos.z);
		base.transform.LookAt(worldPosition);
	}
}
public class NewPath : MonoBehaviour
{
	private List<Vector3> points = new List<Vector3>();

	private List<Transform> pointsTransform = new List<Transform>();

	public int pointLenght;

	public Vector3 mousePos;

	public string pathName;

	public bool errors;

	public bool exit;

	public GameObject par;

	[HideInInspector]
	[SerializeField]
	public PathType PathType;

	public List<Vector3> PointsGet()
	{
		return points;
	}

	public List<Transform> PointsTransform()
	{
		return pointsTransform;
	}

	public void PointSet(int index, Vector3 pos)
	{
		points.Add(pos);
		if (par == null)
		{
			par = new GameObject();
			par.name = "New path points";
			par.transform.parent = base.gameObject.transform;
		}
		GameObject gameObject = UnityEngine.Object.Instantiate(GameObject.Find("Population System").GetComponent<PopulationSystemManager>().pointPrefab, pos, Quaternion.identity);
		gameObject.name = "p" + index;
		gameObject.transform.parent = par.transform;
		pointsTransform.Add(gameObject.transform);
	}
}
public enum PathType
{
	PeoplePath,
	VehiclePath,
	BcyclesGyroPath
}
public enum AnimationState
{
	idle1,
	walk,
	run
}
public class PeopleWalkPath : WalkPath
{
	[Tooltip("Animation of the pedestrian at the start / Анимация пешехода при старте")]
	public AnimationState animationState = AnimationState.walk;

	[Range(0f, 5f)]
	[Tooltip("Offset from the line along the X axis / Смещение от линии по оси X")]
	public float randXPos = 0.1f;

	[Range(0f, 5f)]
	[Tooltip("Offset from the line along the Z axis / Смещение от линии по оси Z")]
	public float randZPos = 0.1f;

	[HideInInspector]
	[SerializeField]
	[Tooltip("Ignore the colliders of other pedestrians / Игнорировать коллайдеры других пешеходов?")]
	private bool _ignorePeople;

	[HideInInspector]
	[SerializeField]
	[Tooltip("Set your animation speed? / Установить свою скорость анимации?")]
	private bool _overrideDefaultAnimationMultiplier = true;

	[HideInInspector]
	[SerializeField]
	[Tooltip("Speed animation of walking / Скорость анимации ходьбы")]
	private float _customWalkAnimationMultiplier = 1.1f;

	[HideInInspector]
	[SerializeField]
	[Tooltip("Running animation speed / Скорость анимации бега")]
	private float _customRunAnimationMultiplier = 0.5f;

	private float nextPointThreshold = 1f;

	[Tooltip("Walking speed / Скорость ходьбы")]
	public float walkSpeed = 1.2f;

	[Tooltip("Running speed / Скорость бега")]
	public float runSpeed = 3f;

	private float speedRotation = 15f;

	[Tooltip("Viewing Angle / Угол обзора")]
	public float viewAngle = 55f;

	[Tooltip("Radius of visibility / Радиус видимости")]
	public float viewRadius = 3f;

	[Tooltip("Distance to the pedestrian / Дистанция до пешехода")]
	public float distToPeople = 4f;

	[Tooltip("Layers of car, traffic light, pedestrians, player / Слои автомобиля, светофора, пешеходов, игрока")]
	public LayerMask targetMask = 3840;

	[HideInInspector]
	public LayerMask obstacleMask;

	private void Start()
	{
		if (_ignorePeople)
		{
			Physics.IgnoreLayerCollision(8, 8, ignore: true);
		}
	}

	public override void CreateSpawnPoints()
	{
		SpawnPoints = new SpawnPoint[points.GetLength(0)];
		for (int i = 0; i < points.GetLength(0); i++)
		{
			Vector3 spawnPoint = (_forward[i] ? points[i, 0] : points[i, points.GetLength(1) - 1]);
			Vector3 nextPoint = (_forward[i] ? points[i, 2] : points[i, points.GetLength(1) - 3]);
			SpawnPoints[i] = SpawnPoint.PeopleCreate($"SpawnPoint (Path {i + 1})", spawnPoint, nextPoint, lineSpacing, i, _forward[i], this, 3f, 1f);
		}
	}

	public override void SpawnOnePeople(int w, bool forward)
	{
		List<GameObject> list = new List<GameObject>(walkingPrefabs);
		for (int num = list.Count - 1; num >= 0; num--)
		{
			if (list[num] == null)
			{
				list.RemoveAt(num);
			}
		}
		walkingPrefabs = list.ToArray();
		int num2 = UnityEngine.Random.Range(0, walkingPrefabs.Length);
		GameObject gameObject = base.gameObject;
		gameObject = (forward ? UnityEngine.Object.Instantiate(walkingPrefabs[num2], points[w, 1], Quaternion.identity) : UnityEngine.Object.Instantiate(walkingPrefabs[num2], points[w, pointLength[0] - 2], Quaternion.identity));
		MovePath movePath = gameObject.AddComponent<MovePath>();
		Passersby _passersby = gameObject.AddComponent<Passersby>();
		movePath.randXFinish = UnityEngine.Random.Range(0f - randXPos, randXPos);
		movePath.randZFinish = UnityEngine.Random.Range(0f - randZPos, randZPos);
		InitializePassersby(ref _passersby);
		gameObject.transform.parent = par.transform;
		movePath.walkPath = this;
		if (!forward)
		{
			movePath.InitStartPosition(w, pointLength[0] - 3, loopPath, forward);
			gameObject.transform.LookAt(points[w, pointLength[0] - 3]);
		}
		else
		{
			movePath.InitStartPosition(w, 1, loopPath, forward);
			gameObject.transform.LookAt(points[w, 2]);
		}
		movePath._walkPointThreshold = nextPointThreshold;
	}

	public override void SpawnPeople()
	{
		List<GameObject> list = new List<GameObject>(walkingPrefabs);
		for (int num = list.Count - 1; num >= 0; num--)
		{
			if (list[num] == null)
			{
				list.RemoveAt(num);
			}
		}
		walkingPrefabs = list.ToArray();
		if (points == null)
		{
			DrawCurved(withDraw: false);
		}
		if (par == null)
		{
			par = new GameObject();
			par.transform.parent = base.gameObject.transform;
			par.name = "walkingObjects";
		}
		int num2 = (loopPath ? (pointLength[0] - 1) : (pointLength[0] - 2));
		if (num2 < 2)
		{
			return;
		}
		int num3 = (loopPath ? (pointLength[0] - 1) : (pointLength[0] - 2));
		for (int i = 0; i < numberOfWays; i++)
		{
			_distances = new float[num3];
			float num4 = 0f;
			for (int j = 1; j < num3; j++)
			{
				num4 += ((!loopPath || j != num3 - 1) ? (points[i, j + 1] - points[i, j]) : (points[i, 1] - points[i, num3])).magnitude;
				_distances[j] = num4;
			}
			bool forward = false;
			switch (direction.ToString())
			{
			case "Forward":
				forward = true;
				break;
			case "Backward":
				forward = false;
				break;
			case "HugLeft":
				forward = (i + 2) % 2 == 0;
				break;
			case "HugRight":
				forward = (i + 2) % 2 != 0;
				break;
			case "WeaveLeft":
				forward = i != 1 && i != 2 && (i - 1) % 4 != 0 && (i - 2) % 4 != 0;
				break;
			case "WeaveRight":
				forward = i == 1 || i == 2 || (i - 1) % 4 == 0 || (i - 2) % 4 == 0;
				break;
			}
			int num5 = Mathf.FloorToInt(Density * num4 / _minimalObjectLength);
			float num6 = _minimalObjectLength + (num4 - (float)num5 * _minimalObjectLength) / (float)num5;
			int[] randomPrefabIndexes = CommonUtils.GetRandomPrefabIndexes(num5, ref walkingPrefabs);
			Vector3[] array = new Vector3[_distances.Length];
			for (int k = 1; k < _distances.Length; k++)
			{
				array[k - 1] = points[i, k];
			}
			array[_distances.Length - 1] = (loopPath ? points[i, 1] : points[i, _distances.Length]);
			for (int l = 0; l < num5; l++)
			{
				_ = base.gameObject;
				float num7 = UnityEngine.Random.Range((0f - num6) / 3f, num6 / 3f) + (float)i * num6;
				float distance = (float)(l + 1) * num6 + num7;
				Vector3 routePosition = GetRoutePosition(array, distance, num3, loopPath);
				float num8 = UnityEngine.Random.Range(0f - randXPos, randXPos);
				float num9 = UnityEngine.Random.Range(0f - randZPos, randZPos);
				routePosition = new Vector3(routePosition.x + num8, routePosition.y, routePosition.z + num9);
				Vector3 origin = new Vector3(routePosition.x, routePosition.y + 10000f, routePosition.z);
				RaycastHit[] array2 = Physics.RaycastAll(origin, Vector3.down, float.PositiveInfinity);
				bool flag = false;
				for (int m = 0; m < array2.Length; m++)
				{
					if (array2[m].collider.GetComponent<SemaphoreSimulator>() != null || array2[m].collider.GetComponent<SemaphorePeople>() != null)
					{
						flag = true;
					}
				}
				if (flag)
				{
					continue;
				}
				float num10 = 0f;
				int num11 = 0;
				origin = new Vector3(routePosition.x, routePosition.y + highToSpawn, routePosition.z);
				array2 = Physics.RaycastAll(origin, Vector3.down, float.PositiveInfinity);
				for (int n = 0; n < array2.Length; n++)
				{
					if (num10 < Vector3.Distance(array2[0].point, origin))
					{
						num11 = n;
						num10 = Vector3.Distance(array2[0].point, origin);
					}
				}
				if (array2.Length != 0)
				{
					routePosition.y = array2[num11].point.y;
				}
				GameObject obj = UnityEngine.Object.Instantiate(walkingPrefabs[randomPrefabIndexes[l]], routePosition, Quaternion.identity);
				MovePath movePath = obj.AddComponent<MovePath>();
				Passersby _passersby = obj.AddComponent<Passersby>();
				movePath.randXFinish = num8;
				movePath.randZFinish = num9;
				InitializePassersby(ref _passersby);
				obj.transform.parent = par.transform;
				movePath.walkPath = this;
				movePath._walkPointThreshold = nextPointThreshold;
				movePath.InitStartPosition(i, GetRoutePoint((float)(l + 1) * num6 + num7, i, num3, forward, loopPath), loopPath, forward);
				movePath.SetLookPosition();
			}
		}
	}

	private void InitializePassersby(ref Passersby _passersby)
	{
		_passersby.ANIMATION_STATE = animationState;
		_passersby.WALK_SPEED = walkSpeed;
		_passersby.RUN_SPEED = runSpeed;
		_passersby.SPEED_ROTATION = speedRotation;
		_passersby.VIEW_ANGLE = viewAngle;
		_passersby.VIEW_RADIUS = viewRadius;
		_passersby.targetMask = targetMask;
		_passersby.obstacleMask = obstacleMask;
		_passersby.DIST_TO_PEOPLE = distToPeople;
		_passersby.OverrideDefaultAnimationMultiplier = _overrideDefaultAnimationMultiplier;
		_passersby.CustomWalkAnimationMultiplier = _customWalkAnimationMultiplier;
		_passersby.CustomRunAnimationMultiplier = _customRunAnimationMultiplier;
	}
}
public class MovePathParams
{
}
public class SpawnPoint : MonoBehaviour
{
	private int _insideObjectsCount;

	private WalkPath _walkPath;

	private bool _isForward;

	private int _pathIndex;

	private Queue<MovePathParams> _movePathQueue = new Queue<MovePathParams>();

	public bool IsSpawnPointFree => _insideObjectsCount == 0;

	public static SpawnPoint PeopleCreate(string name, Vector3 spawnPoint, Vector3 nextPoint, float lineSpacing, int pathIndex, bool isForward, WalkPath walkPath, float boxHeight = 3f, float boxLength = 10f)
	{
		GameObject obj = new GameObject(name);
		obj.transform.position = spawnPoint;
		BoxCollider boxCollider = obj.AddComponent<BoxCollider>();
		SpawnPoint spawnPoint2 = obj.AddComponent<SpawnPoint>();
		boxCollider.isTrigger = true;
		boxCollider.transform.localScale = new Vector3(lineSpacing - 0.05f, boxHeight, boxLength);
		obj.transform.LookAt(nextPoint);
		obj.transform.localPosition += new Vector3(0f, boxHeight / 2f, 0f);
		obj.transform.Translate(Vector3.forward * boxLength / 2f);
		spawnPoint2._walkPath = walkPath;
		spawnPoint2._isForward = isForward;
		spawnPoint2._pathIndex = pathIndex;
		return spawnPoint2;
	}

	public static SpawnPoint CarCreate(string name, Vector3 spawnPoint, Vector3 nextPoint, float lineSpacing, int pathIndex, bool isForward, WalkPath walkPath, float boxHeight = 3f, float boxLength = 10f)
	{
		GameObject obj = new GameObject(name);
		obj.transform.position = spawnPoint;
		BoxCollider boxCollider = obj.AddComponent<BoxCollider>();
		SpawnPoint spawnPoint2 = obj.AddComponent<SpawnPoint>();
		boxCollider.isTrigger = true;
		boxCollider.transform.localScale = new Vector3(lineSpacing - 0.05f, boxHeight, boxLength);
		obj.transform.LookAt(nextPoint);
		obj.transform.localPosition += new Vector3(0f, boxHeight / 2f, 0f);
		obj.transform.Translate(Vector3.forward * boxLength / 2f);
		spawnPoint2._walkPath = walkPath;
		spawnPoint2._isForward = isForward;
		spawnPoint2._pathIndex = pathIndex;
		return spawnPoint2;
	}

	public void AddToSpawnQuery(MovePathParams movePathParams)
	{
		_movePathQueue.Enqueue(movePathParams);
	}

	private void FixedUpdate()
	{
		if (IsSpawnPointFree && _movePathQueue.Count > 0)
		{
			_movePathQueue.Dequeue();
			_walkPath.SpawnOnePeople(_pathIndex, _isForward);
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		_insideObjectsCount++;
	}

	private void OnTriggerExit(Collider other)
	{
		_insideObjectsCount--;
	}
}
public abstract class WalkPath : MonoBehaviour
{
	public enum EnumDir
	{
		Forward,
		Backward,
		HugLeft,
		HugRight,
		WeaveLeft,
		WeaveRight
	}

	protected float[] _distances;

	protected bool inverseDrawOrder = true;

	[Tooltip("Objects of motion / Объекты движения")]
	public GameObject[] walkingPrefabs;

	[Tooltip("Number of paths / Количество путей")]
	public int numberOfWays = 1;

	[Tooltip("Space between paths / Пространство между путями")]
	public float lineSpacing = 1f;

	[Tooltip("Density of movement of objects / Плотность движения объектов")]
	[Range(0.01f, 0.5f)]
	public float Density = 0.2f;

	[Tooltip("Distance between objects / Дистанция между объектами")]
	[SerializeField]
	[Range(1f, 10f)]
	protected float _minimalObjectLength = 1f;

	[Tooltip("Make the path closed in the ring / Сделать путь замкнутым в кольцо")]
	public bool loopPath;

	[Tooltip("Direction of movement / Направление движения. Левостороннее, правостороннее, итд.")]
	public EnumDir direction;

	[HideInInspector]
	public List<Vector3> pathPoint = new List<Vector3>();

	[HideInInspector]
	public List<GameObject> pathPointTransform = new List<GameObject>();

	[HideInInspector]
	public SpawnPoint[] SpawnPoints;

	[HideInInspector]
	public GameObject par;

	[HideInInspector]
	public PathType PathType;

	[HideInInspector]
	public int[] pointLength = new int[2];

	[HideInInspector]
	public bool[] _forward;

	[HideInInspector]
	public bool disableLineDraw;

	public Vector3[,] points;

	[Tooltip("Radius of the sphere-scraper [m] / Радиус сферы-стёрки [м]")]
	[Range(0.1f, 25f)]
	public float eraseRadius = 2f;

	[Tooltip("The minimum distance from the cursor to the line at which you can add a new point to the path [m] / Минимальное расстояние от курсора до линии, при котором можно добавить новую точку в путь [м]")]
	[Range(0.5f, 10f)]
	public float addPointDistance = 2f;

	[Tooltip("Adjust the spawn of cars to the nearest surface. This option will be useful if there are bridges in the scene / Регулировка спавна автомобилей к ближайшей поверхности. Этот параметор будет полезен, если в сцене есть мосты.")]
	public float highToSpawn = 1f;

	[HideInInspector]
	public bool newPointCreation;

	[HideInInspector]
	public bool oldPointDeleting;

	[HideInInspector]
	public Vector3 mousePosition = Vector3.zero;

	private int deletePointIndex = -1;

	private int firstPointIndex = -1;

	private int secondPointIndex = -1;

	public Vector3 getNextPoint(int w, int index)
	{
		return points[w, index];
	}

	public Vector3 getStartPoint(int w)
	{
		return points[w, 1];
	}

	public int getPointsTotal(int w)
	{
		return pointLength[w];
	}

	private void Awake()
	{
		DrawCurved(withDraw: false);
		if (!loopPath)
		{
			CreateSpawnPoints();
		}
	}

	public abstract void CreateSpawnPoints();

	public abstract void SpawnOnePeople(int w, bool forward);

	public abstract void SpawnPeople();

	public void DrawCurved(bool withDraw)
	{
		if (numberOfWays < 1)
		{
			numberOfWays = 1;
		}
		if (lineSpacing < 0.6f)
		{
			lineSpacing = 0.6f;
		}
		_forward = new bool[numberOfWays];
		for (int i = 0; i < numberOfWays; i++)
		{
			if (direction.ToString() == "Forward")
			{
				_forward[i] = true;
			}
			else if (direction.ToString() == "Backward")
			{
				_forward[i] = false;
			}
			else if (direction.ToString() == "HugLeft")
			{
				if ((i + 2) % 2 == 0)
				{
					_forward[i] = true;
				}
				else
				{
					_forward[i] = false;
				}
			}
			else if (direction.ToString() == "HugRight")
			{
				if ((i + 2) % 2 == 0)
				{
					_forward[i] = false;
				}
				else
				{
					_forward[i] = true;
				}
			}
			else if (direction.ToString() == "WeaveLeft")
			{
				if (i == 1 || i == 2 || (i - 1) % 4 == 0 || (i - 2) % 4 == 0)
				{
					_forward[i] = false;
				}
				else
				{
					_forward[i] = true;
				}
			}
			else if (direction.ToString() == "WeaveRight")
			{
				if (i == 1 || i == 2 || (i - 1) % 4 == 0 || (i - 2) % 4 == 0)
				{
					_forward[i] = true;
				}
				else
				{
					_forward[i] = false;
				}
			}
		}
		if (pathPoint.Count < 2)
		{
			return;
		}
		points = new Vector3[numberOfWays, pathPoint.Count + 2];
		pointLength[0] = pathPoint.Count + 2;
		for (int j = 0; j < pathPointTransform.Count; j++)
		{
			Vector3 vector;
			Vector3 vector2;
			if (j == 0)
			{
				vector = ((!loopPath) ? Vector3.zero : (pathPointTransform[pathPointTransform.Count - 1].transform.position - pathPointTransform[j].transform.position));
				vector2 = pathPointTransform[j].transform.position - pathPointTransform[j + 1].transform.position;
			}
			else if (j == pathPointTransform.Count - 1)
			{
				vector = pathPointTransform[j - 1].transform.position - pathPointTransform[j].transform.position;
				vector2 = ((!loopPath) ? Vector3.zero : (pathPointTransform[j].transform.position - pathPointTransform[0].transform.position));
			}
			else
			{
				vector = pathPointTransform[j - 1].transform.position - pathPointTransform[j].transform.position;
				vector2 = pathPointTransform[j].transform.position - pathPointTransform[j + 1].transform.position;
			}
			Vector3 vector3 = Vector3.Normalize(Quaternion.Euler(0f, 90f, 0f) * (vector + vector2));
			points[0, j + 1] = ((numberOfWays % 2 == 1) ? pathPointTransform[j].transform.position : (pathPointTransform[j].transform.position + vector3 * lineSpacing / 2f));
			if (numberOfWays > 1)
			{
				points[1, j + 1] = points[0, j + 1] - vector3 * lineSpacing;
			}
			for (int k = 1; k < numberOfWays; k++)
			{
				points[k, j + 1] = points[0, j + 1] + vector3 * lineSpacing * (float)Math.Pow(-1.0, k) * ((k + 1) / 2);
			}
		}
		for (int l = 0; l < numberOfWays; l++)
		{
			points[l, 0] = points[l, 1];
			points[l, pointLength[0] - 1] = points[l, pointLength[0] - 2];
		}
		if (!withDraw)
		{
			return;
		}
		for (int m = 0; m < numberOfWays; m++)
		{
			if (loopPath)
			{
				Gizmos.color = (_forward[m] ? Color.green : Color.red);
				Gizmos.DrawLine(points[m, 0], points[m, pathPoint.Count]);
			}
			for (int n = 1; n < pathPoint.Count; n++)
			{
				Gizmos.color = (_forward[m] ? Color.green : Color.red);
				Gizmos.DrawLine(points[m, n + 1], points[m, n]);
			}
		}
	}

	protected Vector3 GetRoutePosition(Vector3[] pointArray, float distance, int pointCount, bool loopPath)
	{
		int i = 0;
		float length = _distances[_distances.Length - 1];
		for (distance = Mathf.Repeat(distance, length); _distances[i] < distance; i++)
		{
		}
		int num = (i - 1 + pointCount) % pointCount;
		int num2 = i;
		float t = Mathf.InverseLerp(_distances[num], _distances[num2], distance);
		return Vector3.Lerp(pointArray[num], pointArray[num2], t);
	}

	protected int GetRoutePoint(float distance, int wayIndex, int pointCount, bool forward, bool loopPath)
	{
		int i = 0;
		float length = _distances[_distances.Length - 1];
		for (distance = Mathf.Repeat(distance, length); _distances[i] < distance; i++)
		{
		}
		return i;
	}

	private bool PointWithSphereCollision(Vector3 colisionSpherePosition, Vector3 pointPosition)
	{
		return Vector3.Magnitude(colisionSpherePosition - pointPosition) < eraseRadius;
	}

	private bool PointWithLineCollision(Vector3 lineStartPosition, Vector3 lineEndPosition, Vector3 pointPosition)
	{
		return Distance(lineStartPosition, lineEndPosition, pointPosition) < addPointDistance;
	}

	private float Distance(Vector3 lineStartPosition, Vector3 lineEndPosition, Vector3 pointPosition)
	{
		float num = Vector3.SqrMagnitude(lineEndPosition - lineStartPosition);
		if (num == 0f)
		{
			return Vector3.Distance(pointPosition, lineStartPosition);
		}
		float num2 = Mathf.Max(0f, Mathf.Min(1f, Vector3.Dot(pointPosition - lineStartPosition, lineEndPosition - lineStartPosition) / num));
		Vector3 b = lineStartPosition + num2 * (lineEndPosition - lineStartPosition);
		return Vector3.Distance(pointPosition, b);
	}

	public void AddPoint()
	{
		if (firstPointIndex != -1 || secondPointIndex != firstPointIndex)
		{
			GameObject gameObject = UnityEngine.Object.Instantiate(GameObject.Find("Population System").GetComponent<PopulationSystemManager>().pointPrefab, mousePosition, Quaternion.identity);
			gameObject.name = "p+";
			gameObject.transform.parent = pathPointTransform[firstPointIndex].transform.parent;
			pathPointTransform.Insert(firstPointIndex + 1, gameObject);
			pathPoint.Insert(firstPointIndex + 1, gameObject.transform.position);
		}
	}

	public void DeletePoint()
	{
		if (deletePointIndex != -1)
		{
			UnityEngine.Object.DestroyImmediate(pathPointTransform[deletePointIndex]);
			pathPointTransform.RemoveAt(deletePointIndex);
			pathPoint.RemoveAt(deletePointIndex);
		}
	}
}
public class BcycleGyroController : MonoBehaviour
{
	private Animator anim;

	private Rigidbody rigBody;

	private BoxCollider bc;

	private MovePath movePath;

	private Vector3 fwdVector;

	private float curMoveSpeed;

	private float startSpeed;

	[Tooltip("Speed bicyclist / Скорость велосипедиста")]
	public float moveSpeed;

	[Tooltip("Acceleration / Ускорение")]
	public float increaseSpeed;

	[Tooltip("Braking / Торможение")]
	public float decreaseSpeed;

	[Tooltip("Swing speed / Скорость поворота")]
	public float speedRotation;

	[HideInInspector]
	public bool insideSemaphore;

	[HideInInspector]
	public bool tempStop;

	[SerializeField]
	[Tooltip("Set your animation speed / Выставить свою скорость анимации?")]
	private bool _overrideDefaultAnimationMultiplier;

	[SerializeField]
	[Tooltip("Animation speed / Скорость анимации")]
	private float _customAnimationMultiplier = 1f;

	public float CustomAnimationMultiplier
	{
		get
		{
			return _customAnimationMultiplier;
		}
		set
		{
			_customAnimationMultiplier = value;
		}
	}

	public float SPEED_ROTATION
	{
		get
		{
			return speedRotation;
		}
		set
		{
			speedRotation = value;
		}
	}

	public bool OverrideDefaultAnimationMultiplier
	{
		get
		{
			return _overrideDefaultAnimationMultiplier;
		}
		set
		{
			_overrideDefaultAnimationMultiplier = value;
		}
	}

	private void Awake()
	{
		anim = GetComponent<Animator>();
		rigBody = GetComponent<Rigidbody>();
		bc = GetComponentInChildren<BoxCollider>();
		movePath = GetComponent<MovePath>();
	}

	private void Start()
	{
		startSpeed = moveSpeed;
		BoxCollider[] componentsInChildren = GetComponentsInChildren<BoxCollider>();
		bc = componentsInChildren[0];
	}

	private void Update()
	{
		GetPath();
		Move();
		PushRay();
		fwdVector = new Vector3(base.transform.position.x + base.transform.forward.x, base.transform.position.y + 0.5f, base.transform.position.z + base.transform.forward.z * bc.size.z);
		if (anim != null)
		{
			if (_overrideDefaultAnimationMultiplier)
			{
				anim.speed = curMoveSpeed * _customAnimationMultiplier;
			}
			else
			{
				anim.speed = curMoveSpeed * 1.2f;
			}
		}
	}

	private void Move()
	{
		if (tempStop)
		{
			curMoveSpeed = Mathf.Lerp(curMoveSpeed, 0f, Time.deltaTime * decreaseSpeed);
			if (curMoveSpeed < 0.15f)
			{
				curMoveSpeed = 0f;
			}
		}
		else
		{
			curMoveSpeed = Mathf.Lerp(curMoveSpeed, moveSpeed, Time.deltaTime * increaseSpeed);
		}
		if (rigBody.velocity.magnitude > curMoveSpeed)
		{
			rigBody.velocity = rigBody.velocity.normalized * curMoveSpeed;
		}
	}

	private void GetPath()
	{
		Vector3 vector = new Vector3(movePath.finishPos.x + movePath.randXFinish, movePath.finishPos.y, movePath.finishPos.z + movePath.randZFinish);
		Vector3 vector2 = new Vector3(vector.x, rigBody.transform.position.y, vector.z);
		float num = Vector3.Distance(Vector3.ProjectOnPlane(rigBody.transform.position, Vector3.up), Vector3.ProjectOnPlane(vector, Vector3.up));
		if (num < 2f && (movePath.loop || (!movePath.loop && movePath.targetPoint > 0 && movePath.targetPoint < movePath.targetPointsTotal)))
		{
			if (movePath.forward)
			{
				vector2 = ((movePath.targetPoint >= movePath.targetPointsTotal) ? movePath.walkPath.getNextPoint(movePath.w, 0) : movePath.walkPath.getNextPoint(movePath.w, movePath.targetPoint + 1));
				vector2.y = rigBody.transform.position.y;
			}
			else
			{
				vector2 = ((movePath.targetPoint <= 0) ? movePath.walkPath.getNextPoint(movePath.w, movePath.targetPointsTotal) : movePath.walkPath.getNextPoint(movePath.w, movePath.targetPoint - 1));
				vector2.y = rigBody.transform.position.y;
			}
		}
		Vector3 vector3 = vector2 - rigBody.transform.position;
		if (vector3 != Vector3.zero)
		{
			Quaternion identity = Quaternion.identity;
			identity = Quaternion.Lerp(rigBody.transform.rotation, Quaternion.LookRotation(vector3), Time.deltaTime * speedRotation);
			identity.x = rigBody.transform.rotation.x;
			identity.z = rigBody.transform.rotation.z;
			rigBody.transform.rotation = identity;
		}
		if (num > movePath._walkPointThreshold)
		{
			if (Time.deltaTime > 0f)
			{
				Vector3 vector4 = movePath.finishPos - rigBody.transform.position;
				vector4.y = rigBody.velocity.y;
				rigBody.velocity = new Vector3(vector4.normalized.x * curMoveSpeed, vector4.y, vector4.normalized.z * curMoveSpeed);
			}
		}
		else if (num <= movePath._walkPointThreshold && movePath.forward)
		{
			if (movePath.targetPoint != movePath.targetPointsTotal)
			{
				movePath.targetPoint++;
				movePath.finishPos = movePath.walkPath.getNextPoint(movePath.w, movePath.targetPoint);
			}
			else if (movePath.targetPoint == movePath.targetPointsTotal)
			{
				if (movePath.loop)
				{
					movePath.finishPos = movePath.walkPath.getStartPoint(movePath.w);
					movePath.targetPoint = 0;
				}
				else
				{
					movePath.walkPath.SpawnPoints[movePath.w].AddToSpawnQuery(new MovePathParams());
					UnityEngine.Object.Destroy(base.gameObject);
				}
			}
		}
		else
		{
			if (!(num <= movePath._walkPointThreshold) || movePath.forward)
			{
				return;
			}
			if (movePath.targetPoint > 0)
			{
				movePath.targetPoint--;
				movePath.finishPos = movePath.walkPath.getNextPoint(movePath.w, movePath.targetPoint);
			}
			else if (movePath.targetPoint == 0)
			{
				if (movePath.loop)
				{
					movePath.finishPos = movePath.walkPath.getNextPoint(movePath.w, movePath.targetPointsTotal);
					movePath.targetPoint = movePath.targetPointsTotal;
				}
				else
				{
					movePath.walkPath.SpawnPoints[movePath.w].AddToSpawnQuery(new MovePathParams());
					UnityEngine.Object.Destroy(base.gameObject);
				}
			}
		}
	}

	private void PushRay()
	{
		if (Physics.Raycast(new Ray(fwdVector, base.transform.forward * 10f), out var hitInfo, 20f))
		{
			float distance = Vector3.Distance(fwdVector, hitInfo.point);
			if (hitInfo.transform.CompareTag("Car"))
			{
				GameObject gameObject = (hitInfo.transform.GetComponentInChildren<ParentOfTrailer>() ? hitInfo.transform.GetComponent<ParentOfTrailer>().PAR : hitInfo.transform.gameObject);
				if (gameObject != null)
				{
					ReasonsStoppingCars.CarInView(gameObject, rigBody, distance, startSpeed, ref moveSpeed, ref tempStop);
				}
			}
			else if (hitInfo.transform.CompareTag("Bcycle"))
			{
				ReasonsStoppingCars.BcycleGyroInView(hitInfo.transform.GetComponentInChildren<BcycleGyroController>(), rigBody, distance, startSpeed, ref moveSpeed, ref tempStop);
			}
			else if (hitInfo.transform.CompareTag("PeopleSemaphore"))
			{
				ReasonsStoppingCars.SemaphoreInView(hitInfo.transform.GetComponent<SemaphorePeople>(), distance, startSpeed, insideSemaphore, ref moveSpeed, ref tempStop);
			}
			else if (hitInfo.transform.CompareTag("Player"))
			{
				ReasonsStoppingCars.PlayerInView(hitInfo.transform, distance, startSpeed, ref moveSpeed, ref tempStop);
			}
			else
			{
				moveSpeed = startSpeed;
				tempStop = false;
			}
		}
		else
		{
			moveSpeed = startSpeed;
			tempStop = false;
		}
	}

	private void OnDrawGizmosSelected()
	{
		Gizmos.color = Color.yellow;
		if (bc != null)
		{
			Gizmos.DrawRay(new Vector3(base.transform.position.x + base.transform.forward.x, base.transform.position.y + 0.5f, base.transform.position.z + base.transform.forward.z * bc.size.z), base.transform.forward * 20f);
		}
	}
}
public class Passersby : MonoBehaviour
{
	private Rigidbody rigBody;

	private Animator animator;

	private MovePath movePath;

	private Passersby nearPassersby;

	private SemaphorePeople nearSemaphore;

	private Transform nearCar;

	private Transform nearPlayer;

	private AnimationState lastState;

	[SerializeField]
	private float curMoveSpeed;

	private float moveSpeed;

	private float startWalkSpeed;

	private float startRunSpeed;

	private bool redSemaphore;

	private bool insideSemaphore;

	private bool tempStop;

	private bool timeToWalk = true;

	[Tooltip("Layers of car, traffic light, pedestrians, player / Слои автомобиля, светофора, пешеходов, игрока")]
	public LayerMask targetMask;

	[HideInInspector]
	public LayerMask obstacleMask;

	[SerializeField]
	private AnimationState animationState;

	[SerializeField]
	[Tooltip("Walking speed / Скорость ходьбы")]
	private float walkSpeed;

	[SerializeField]
	[Tooltip("Running speed / Скорость бега")]
	private float runSpeed;

	[SerializeField]
	[Tooltip("Swing speed / Скорость поворота")]
	private float speedRotation;

	[SerializeField]
	[Tooltip("Viewing Angle / Угол обзора")]
	private float viewAngle;

	[SerializeField]
	[Tooltip("Radius of visibility / Радиус видимости")]
	private float viewRadius;

	[SerializeField]
	[Tooltip("Distance to pedestrian / Расстояние до пешехода")]
	private float distToPeople;

	[SerializeField]
	[Tooltip("Set your animation speed / Установить свою скорость анимации?")]
	private bool _overrideDefaultAnimationMultiplier;

	[SerializeField]
	[Tooltip("Speed animation walking / Скорость анимации ходьбы")]
	private float _customWalkAnimationMultiplier = 1f;

	[SerializeField]
	[Tooltip("Running animation speed / Скорость анимации бега")]
	private float _customRunAnimationMultiplier = 1f;

	public AnimationState ANIMATION_STATE
	{
		get
		{
			return animationState;
		}
		set
		{
			animationState = value;
		}
	}

	public AnimationState LastState
	{
		get
		{
			return lastState;
		}
		set
		{
			lastState = value;
		}
	}

	public float WALK_SPEED
	{
		get
		{
			return walkSpeed;
		}
		set
		{
			walkSpeed = value;
		}
	}

	public float RUN_SPEED
	{
		get
		{
			return runSpeed;
		}
		set
		{
			runSpeed = value;
		}
	}

	public float SPEED_ROTATION
	{
		get
		{
			return speedRotation;
		}
		set
		{
			speedRotation = value;
		}
	}

	public float VIEW_ANGLE
	{
		get
		{
			return viewAngle;
		}
		set
		{
			viewAngle = value;
		}
	}

	public float VIEW_RADIUS
	{
		get
		{
			return viewRadius;
		}
		set
		{
			viewRadius = value;
		}
	}

	public bool INSIDE
	{
		get
		{
			return insideSemaphore;
		}
		set
		{
			insideSemaphore = value;
		}
	}

	public bool RED
	{
		get
		{
			return redSemaphore;
		}
		set
		{
			redSemaphore = value;
		}
	}

	public float DIST_TO_PEOPLE
	{
		get
		{
			return distToPeople;
		}
		set
		{
			distToPeople = value;
		}
	}

	public float CustomWalkAnimationMultiplier
	{
		get
		{
			return _customWalkAnimationMultiplier;
		}
		set
		{
			_customWalkAnimationMultiplier = value;
		}
	}

	public float CustomRunAnimationMultiplier
	{
		get
		{
			return _customRunAnimationMultiplier;
		}
		set
		{
			_customRunAnimationMultiplier = value;
		}
	}

	public bool OverrideDefaultAnimationMultiplier
	{
		get
		{
			return _overrideDefaultAnimationMultiplier;
		}
		set
		{
			_overrideDefaultAnimationMultiplier = value;
		}
	}

	private void Awake()
	{
		rigBody = GetComponent<Rigidbody>();
		animator = GetComponent<Animator>();
		movePath = GetComponent<MovePath>();
	}

	private void Start()
	{
		lastState = animationState;
		startWalkSpeed = walkSpeed;
		startRunSpeed = runSpeed;
		animator.CrossFade(animationState.ToString(), 0.1f, 0, UnityEngine.Random.Range(0f, 1f));
	}

	private void Update()
	{
		ActionNearPassersby();
		ActionNearSemaphore();
		ActionNearCar();
		ActionNearPlayer();
		Move();
		if (insideSemaphore && redSemaphore)
		{
			animationState = AnimationState.run;
		}
		if (tempStop)
		{
			if (curMoveSpeed < 0.3f)
			{
				animator.Play("idle1");
			}
		}
		else
		{
			animator.Play(animationState.ToString());
		}
		curMoveSpeed = Mathf.Lerp(curMoveSpeed, moveSpeed, Time.deltaTime * 4.5f);
		AISight();
	}

	private void FixedUpdate()
	{
		GetPath();
	}

	private void Move()
	{
		switch (animationState)
		{
		case AnimationState.idle1:
			moveSpeed = 0f;
			if (curMoveSpeed < 0.15f)
			{
				curMoveSpeed = 0f;
			}
			break;
		case AnimationState.walk:
			moveSpeed = walkSpeed;
			if (_overrideDefaultAnimationMultiplier)
			{
				animator.speed = curMoveSpeed * _customWalkAnimationMultiplier;
			}
			else
			{
				animator.speed = curMoveSpeed * 1.2f;
			}
			break;
		case AnimationState.run:
			moveSpeed = runSpeed;
			if (_overrideDefaultAnimationMultiplier)
			{
				animator.speed = curMoveSpeed * _customRunAnimationMultiplier;
			}
			else
			{
				animator.speed = curMoveSpeed / 3f;
			}
			break;
		}
		tempStop = animationState == AnimationState.idle1;
	}

	private void AISight()
	{
		nearPassersby = null;
		nearSemaphore = null;
		nearCar = null;
		nearPlayer = null;
		Collider[] targetsInViewRadius = Physics.OverlapSphere(base.transform.position, viewRadius, targetMask);
		List<Passersby> list = new List<Passersby>();
		List<SemaphorePeople> list2 = new List<SemaphorePeople>();
		List<Transform> list3 = new List<Transform>();
		List<Transform> list4 = new List<Transform>();
		SortTargetsInView(list, targetsInViewRadius, "People");
		SortTargetsInView(list2, targetsInViewRadius, "PeopleSemaphore");
		SortTargetsInView(list3, targetsInViewRadius, "Car");
		SortTargetsInView(list4, targetsInViewRadius, "Player");
		if (nearPassersby == null && nearSemaphore == null && nearCar == null && nearPlayer == null && !insideSemaphore && !redSemaphore)
		{
			animationState = lastState;
		}
	}

	private void GetPath()
	{
		Vector3 vector = new Vector3(movePath.finishPos.x + movePath.randXFinish, movePath.finishPos.y, movePath.finishPos.z + movePath.randZFinish);
		Vector3 vector2 = new Vector3(vector.x, rigBody.transform.position.y, vector.z);
		float num = Vector3.Distance(Vector3.ProjectOnPlane(rigBody.transform.position, Vector3.up), Vector3.ProjectOnPlane(vector, Vector3.up));
		if (num < 0.2f && animationState == AnimationState.walk && (movePath.loop || (!movePath.loop && movePath.targetPoint > 0 && movePath.targetPoint < movePath.targetPointsTotal)))
		{
			if (movePath.forward)
			{
				vector2 = ((movePath.targetPoint >= movePath.targetPointsTotal) ? movePath.walkPath.getNextPoint(movePath.w, 0) : movePath.walkPath.getNextPoint(movePath.w, movePath.targetPoint + 1));
				vector2.y = rigBody.transform.position.y;
			}
			else
			{
				vector2 = ((movePath.targetPoint <= 0) ? movePath.walkPath.getNextPoint(movePath.w, movePath.targetPointsTotal) : movePath.walkPath.getNextPoint(movePath.w, movePath.targetPoint - 1));
				vector2.y = rigBody.transform.position.y;
			}
		}
		if (num < 0.5f && animationState == AnimationState.run && (movePath.loop || (!movePath.loop && movePath.targetPoint > 0 && movePath.targetPoint < movePath.targetPointsTotal)))
		{
			if (movePath.forward)
			{
				vector2 = ((movePath.targetPoint >= movePath.targetPointsTotal) ? movePath.walkPath.getNextPoint(movePath.w, 0) : movePath.walkPath.getNextPoint(movePath.w, movePath.targetPoint + 1));
				vector2.y = rigBody.transform.position.y;
			}
			else
			{
				vector2 = ((movePath.targetPoint <= 0) ? movePath.walkPath.getNextPoint(movePath.w, movePath.targetPointsTotal) : movePath.walkPath.getNextPoint(movePath.w, movePath.targetPoint - 1));
				vector2.y = rigBody.transform.position.y;
			}
		}
		Vector3 vector3 = vector2 - base.transform.position;
		if (vector3 != Vector3.zero)
		{
			Vector3 zero = Vector3.zero;
			rigBody.constraints = (RigidbodyConstraints)80;
			zero = Vector3.RotateTowards(base.transform.forward, vector3, speedRotation * Time.deltaTime, 0f);
			base.transform.rotation = Quaternion.LookRotation(zero);
		}
		if (num > movePath._walkPointThreshold)
		{
			if (Time.deltaTime > 0f)
			{
				base.transform.position += base.transform.forward * curMoveSpeed * Time.deltaTime;
			}
		}
		else if (num <= movePath._walkPointThreshold && movePath.forward)
		{
			if (movePath.targetPoint != movePath.targetPointsTotal)
			{
				movePath.targetPoint++;
				movePath.finishPos = movePath.walkPath.getNextPoint(movePath.w, movePath.targetPoint);
			}
			else
			{
				if (movePath.targetPoint != movePath.targetPointsTotal)
				{
					return;
				}
				if (movePath.loop)
				{
					movePath.finishPos = movePath.walkPath.getStartPoint(movePath.w);
					movePath.targetPoint = 0;
					return;
				}
				if (movePath != null)
				{
					movePath.walkPath.SpawnPoints[movePath.w].AddToSpawnQuery(new MovePathParams());
				}
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}
		else
		{
			if (!(num <= movePath._walkPointThreshold) || movePath.forward)
			{
				return;
			}
			if (movePath.targetPoint > 0)
			{
				movePath.targetPoint--;
				movePath.finishPos = movePath.walkPath.getNextPoint(movePath.w, movePath.targetPoint);
			}
			else if (movePath.targetPoint == 0)
			{
				if (movePath.loop)
				{
					movePath.finishPos = movePath.walkPath.getNextPoint(movePath.w, movePath.targetPointsTotal);
					movePath.targetPoint = movePath.targetPointsTotal;
				}
				else
				{
					movePath.walkPath.SpawnPoints[movePath.w].AddToSpawnQuery(new MovePathParams());
					UnityEngine.Object.Destroy(base.gameObject);
				}
			}
		}
	}

	private void SortTargetsInView<T>(IList<T> list, Collider[] targetsInViewRadius, string tag)
	{
		foreach (Collider collider in targetsInViewRadius)
		{
			if (collider.transform.CompareTag(tag) && !(collider.transform.position == base.transform.position) && (!(typeof(T) == typeof(Passersby)) || (!(collider.transform.parent.name != base.transform.parent.name) && collider.GetComponent<MovePath>().w == movePath.w)))
			{
				Vector3 lhs = base.transform.TransformDirection(Vector3.forward);
				Vector3 rhs = collider.transform.position - base.transform.position;
				if (Vector3.Dot(lhs, rhs) > 0f)
				{
					list.Add(collider.GetComponent<T>());
				}
			}
		}
		if (typeof(T) == typeof(Passersby))
		{
			List<Passersby> list2 = list as List<Passersby>;
			NearTarget(list2);
		}
		else if (typeof(T) == typeof(SemaphorePeople))
		{
			List<SemaphorePeople> list3 = list as List<SemaphorePeople>;
			NearTarget(list3);
		}
		else if (typeof(T) == typeof(Transform))
		{
			if (tag == "Car")
			{
				List<Transform> list4 = list as List<Transform>;
				NearTarget(list4, "Car");
			}
			else if (tag == "Player")
			{
				List<Transform> list5 = list as List<Transform>;
				NearTarget(list5, "Player");
			}
		}
	}

	private void NearTarget<T>(IList<T> list, string tag = "")
	{
		foreach (T item in list)
		{
			Transform transform = null;
			if (typeof(T) == typeof(Passersby))
			{
				transform = (item as Passersby).GetComponent<Transform>();
			}
			else if (typeof(T) == typeof(SemaphorePeople))
			{
				transform = (item as SemaphorePeople).GetComponent<Transform>();
			}
			else if (typeof(T) == typeof(Transform))
			{
				if (tag == "Car")
				{
					transform = (item as Transform).GetComponent<Transform>();
				}
				else if (tag == "Player")
				{
					transform = (item as Transform).GetComponent<Transform>();
				}
			}
			Vector3 normalized = (new Vector3(transform.position.x, transform.position.y, transform.position.z) - base.transform.position).normalized;
			if (!(Vector3.Angle(base.transform.forward, normalized) < viewAngle / 2f))
			{
				continue;
			}
			float num = Vector3.Distance(base.transform.position, transform.position);
			float num2 = 0f;
			if (typeof(T) == typeof(Passersby))
			{
				if (nearPassersby != null)
				{
					num2 = Vector3.Distance(base.transform.position, nearPassersby.transform.position);
				}
			}
			else if (typeof(T) == typeof(SemaphorePeople))
			{
				if (nearSemaphore != null)
				{
					num2 = Vector3.Distance(base.transform.position, nearSemaphore.transform.position);
				}
			}
			else if (typeof(T) == typeof(Transform))
			{
				if (tag == "Car")
				{
					if (nearCar != null)
					{
						num2 = Vector3.Distance(base.transform.position, nearCar.transform.position);
					}
				}
				else if (tag == "Player" && nearPlayer != null)
				{
					num2 = Vector3.Distance(base.transform.position, nearPlayer.transform.position);
				}
			}
			if (Physics.Raycast(base.transform.position, normalized, num, obstacleMask))
			{
				continue;
			}
			if (typeof(T) == typeof(Passersby))
			{
				if (nearPassersby == null)
				{
					nearPassersby = item as Passersby;
				}
				else if (num < num2)
				{
					nearPassersby = item as Passersby;
				}
			}
			else if (typeof(T) == typeof(SemaphorePeople))
			{
				if (nearSemaphore == null)
				{
					nearSemaphore = item as SemaphorePeople;
				}
				else if (num < num2)
				{
					nearSemaphore = item as SemaphorePeople;
				}
			}
			else
			{
				if (!(typeof(T) == typeof(Transform)))
				{
					continue;
				}
				if (tag == "Car")
				{
					if (nearCar == null)
					{
						nearCar = item as Transform;
					}
					else if (num < num2)
					{
						nearCar = item as Transform;
					}
				}
				else if (tag == "Player")
				{
					if (nearPlayer == null)
					{
						nearPlayer = item as Transform;
					}
					else if (num < num2)
					{
						nearPlayer = item as Transform;
					}
				}
			}
		}
	}

	private void ActionNearPassersby()
	{
		if (nearPassersby != null)
		{
			if (Vector3.Distance(base.transform.position, nearPassersby.transform.position) < distToPeople)
			{
				if (nearPassersby.ANIMATION_STATE == AnimationState.idle1)
				{
					animationState = AnimationState.idle1;
					timeToWalk = false;
				}
				else
				{
					walkSpeed = nearPassersby.walkSpeed;
					runSpeed = nearPassersby.runSpeed;
				}
			}
			if (animationState == AnimationState.idle1 && nearPassersby.ANIMATION_STATE != 0 && !timeToWalk)
			{
				StartCoroutine(StartMove());
				timeToWalk = true;
			}
		}
		else
		{
			walkSpeed = startWalkSpeed;
			runSpeed = startRunSpeed;
		}
	}

	private void ActionNearSemaphore()
	{
		if (!(nearSemaphore == null) && Vector3.Distance(base.transform.position, nearSemaphore.transform.position) < 25f)
		{
			if (nearSemaphore.PEOPLE_CAN)
			{
				animationState = lastState;
			}
			else if (!insideSemaphore)
			{
				animationState = AnimationState.idle1;
			}
		}
	}

	private void ActionNearCar()
	{
		if (!(nearCar == null))
		{
			if (Vector3.Distance(base.transform.position, nearCar.transform.position) < 10f)
			{
				animationState = AnimationState.idle1;
			}
			else
			{
				animationState = lastState;
			}
		}
	}

	private void ActionNearPlayer()
	{
		if (!(nearPlayer == null))
		{
			if (Vector3.Distance(base.transform.position, nearPlayer.transform.position) < 10f)
			{
				animationState = AnimationState.idle1;
			}
			else
			{
				animationState = lastState;
			}
		}
	}

	private IEnumerator StartMove()
	{
		yield return new WaitForSeconds(1.2f);
		animationState = lastState;
		tempStop = false;
	}

	public Vector3 DirFromAngle(float angleInDegrees, bool angleIsGlobal)
	{
		if (!angleIsGlobal)
		{
			angleInDegrees += base.transform.eulerAngles.y;
		}
		return new Vector3(Mathf.Sin(angleInDegrees * ((float)Math.PI / 180f)), 0f, Mathf.Cos(angleInDegrees * ((float)Math.PI / 180f)));
	}
}
public abstract class UnitBase : MonoBehaviour
{
	public List<Transform> visiblePoints;

	public static bool IsVisibleUnit<T>(T unit, Transform from, float angle, float distance, LayerMask mask) where T : UnitBase
	{
		bool result = false;
		if (unit != null)
		{
			foreach (Transform visiblePoint in unit.visiblePoints)
			{
				if (IsVisibleObject(from, visiblePoint.position, unit.gameObject, angle, distance, mask))
				{
					result = true;
					break;
				}
			}
		}
		return result;
	}

	public static bool IsVisibleObject(Transform from, Vector3 point, GameObject target, float angle, float distance, LayerMask mask)
	{
		bool result = false;
		if (IsAvailablePoint(from, point, angle, distance))
		{
			Vector3 direction = point - from.position;
			if (Physics.Raycast(new Ray(from.position, direction), out var hitInfo, distance, mask.value) && hitInfo.collider.gameObject == target)
			{
				result = true;
			}
		}
		return result;
	}

	public static bool IsAvailablePoint(Transform from, Vector3 point, float angle, float distance)
	{
		bool result = false;
		if (from != null && Vector3.Distance(from.position, point) <= distance)
		{
			Vector3 vector = point - from.position;
			float num = Vector3.Dot(from.forward, vector.normalized);
			result = !(num < 1f) || Mathf.Acos(num) * 57.29578f <= angle;
		}
		return result;
	}
}
public static class CommonUtils
{
	public static int[] GetRandomPrefabIndexes(int numRequired, ref GameObject[] peoplePrefabs)
	{
		List<int> list = new List<int>();
		List<GameObject> list2 = new List<GameObject>(peoplePrefabs);
		list2.Shuffle();
		peoplePrefabs = list2.ToArray();
		int i = 0;
		int num = 0;
		for (; i < numRequired; i++)
		{
			list.Add((num < peoplePrefabs.Length) ? num++ : (num = 0));
		}
		list.Shuffle();
		return list.ToArray();
	}
}
public class PeopleController : MonoBehaviour
{
	[HideInInspector]
	public float timer;

	[HideInInspector]
	public string[] animNames;

	private void Start()
	{
		Tick();
	}

	private void Tick()
	{
		timer = 0f;
		int num = UnityEngine.Random.Range(0, animNames.Length);
		SetAnimClip(animNames[num]);
		timer = UnityEngine.Random.Range(3f, 5f);
	}

	public void SetTarget(Vector3 _target)
	{
		Vector3 worldPosition = new Vector3(_target.x, base.transform.position.y, _target.z);
		base.transform.LookAt(worldPosition);
	}

	private void Update()
	{
		if (timer >= 0f)
		{
			timer -= Time.deltaTime;
		}
		else
		{
			Tick();
		}
	}

	public void SetAnimClip(string animName)
	{
		GetComponent<Animator>().CrossFade(animName, 0.1f, 0, UnityEngine.Random.Range(0f, 1f));
	}
}
public class PopulationSystemManager : MonoBehaviour
{
	[SerializeField]
	private GameObject planePrefab;

	[SerializeField]
	private GameObject circlePrefab;

	public GameObject standardCrossroad;

	public GameObject TCrossroad;

	public GameObject pointPrefab;

	[HideInInspector]
	public bool isConcert;

	[HideInInspector]
	public bool isStreet;

	[HideInInspector]
	public Vector3 mousePos;

	public void Concert(Vector3 pos)
	{
		isConcert = false;
		GameObject obj = new GameObject();
		obj.transform.position = pos;
		obj.name = "Audience";
		obj.AddComponent<StandingPeopleConcert>();
		StandingPeopleConcert component = obj.GetComponent<StandingPeopleConcert>();
		component.planePrefab = planePrefab;
		component.circlePrefab = circlePrefab;
		component.SpawnRectangleSurface();
	}

	public void Street(Vector3 pos)
	{
		isStreet = false;
		GameObject obj = new GameObject();
		obj.transform.position = pos;
		obj.name = "Talking people";
		obj.AddComponent<StandingPeopleStreet>();
		StandingPeopleStreet component = obj.GetComponent<StandingPeopleStreet>();
		component.planePrefab = planePrefab;
		component.circlePrefab = circlePrefab;
		component.SpawnRectangleSurface();
	}
}
public static class ShfuffleExtension
{
	private static readonly System.Random RandomGenerator = new System.Random();

	public static void Shuffle<T>(this IList<T> shuffleList)
	{
		int num = shuffleList.Count;
		while (num > 1)
		{
			num--;
			int index = RandomGenerator.Next(num + 1);
			T value = shuffleList[index];
			shuffleList[index] = shuffleList[num];
			shuffleList[num] = value;
		}
	}
}
public class StandingPeopleConcert : MonoBehaviour
{
	public enum TestEnum
	{
		Rectangle,
		Circle
	}

	[HideInInspector]
	public GameObject planePrefab;

	[HideInInspector]
	public GameObject circlePrefab;

	[HideInInspector]
	public GameObject surface;

	[HideInInspector]
	public Vector2 planeSize = new Vector2(1f, 1f);

	public GameObject[] peoplePrefabs = new GameObject[0];

	[HideInInspector]
	private List<Vector3> spawnPoints = new List<Vector3>();

	[HideInInspector]
	public GameObject target;

	[HideInInspector]
	public int peopleCount;

	[HideInInspector]
	public bool isCircle;

	[HideInInspector]
	public float circleDiametr = 1f;

	[HideInInspector]
	public bool showSurface = true;

	public TestEnum SurfaceType;

	[HideInInspector]
	public GameObject par;

	public void OnDrawGizmos()
	{
		if (!isCircle)
		{
			surface.transform.localScale = new Vector3(planeSize.x, planeSize.y, 1f);
		}
		else
		{
			surface.transform.localScale = new Vector3(circleDiametr, circleDiametr, 1f);
		}
	}

	public void SpawnRectangleSurface()
	{
		if (surface != null)
		{
			UnityEngine.Object.DestroyImmediate(surface);
		}
		GameObject gameObject = (surface = UnityEngine.Object.Instantiate(planePrefab, base.transform.position, Quaternion.identity));
		isCircle = false;
		gameObject.transform.eulerAngles = new Vector3(gameObject.transform.eulerAngles.x - 90f, gameObject.transform.eulerAngles.y, gameObject.transform.eulerAngles.z);
		gameObject.transform.position += new Vector3(0f, 0.01f, 0f);
		gameObject.transform.parent = base.transform;
		gameObject.name = "surface";
	}

	public void SpawnCircleSurface()
	{
		if (surface != null)
		{
			UnityEngine.Object.DestroyImmediate(surface);
		}
		GameObject gameObject = UnityEngine.Object.Instantiate(circlePrefab, base.transform.position, Quaternion.identity);
		isCircle = true;
		gameObject.transform.eulerAngles = new Vector3(gameObject.transform.eulerAngles.x - 90f, gameObject.transform.eulerAngles.y, gameObject.transform.eulerAngles.z);
		gameObject.transform.position += new Vector3(0f, 0.01f, 0f);
		gameObject.transform.parent = base.transform;
		gameObject.name = "surface";
		surface = gameObject;
	}

	public void RemoveButton()
	{
		if (par != null)
		{
			UnityEngine.Object.DestroyImmediate(par);
		}
	}

	public void PopulateButton()
	{
		RemoveButton();
		GameObject gameObject = (par = new GameObject());
		gameObject.transform.parent = base.gameObject.transform;
		gameObject.name = "people";
		spawnPoints.Clear();
		SpawnPeople(peopleCount);
	}

	private void SpawnPeople(int _peopleCount)
	{
		int[] randomPrefabIndexes = CommonUtils.GetRandomPrefabIndexes(_peopleCount, ref peoplePrefabs);
		for (int i = 0; i < _peopleCount; i++)
		{
			Vector3 vector = (isCircle ? RandomCirclePosition() : RandomRectanglePosition());
			if (vector != Vector3.zero)
			{
				GameObject gameObject = UnityEngine.Object.Instantiate(peoplePrefabs[randomPrefabIndexes[i]], vector, Quaternion.identity);
				if (Physics.Raycast(gameObject.transform.position + Vector3.up * 0.1f, Vector3.zero, out var hitInfo))
				{
					gameObject.transform.position = new Vector3(gameObject.transform.position.x, hitInfo.point.y, gameObject.transform.position.z);
				}
				gameObject.AddComponent<PeopleController>();
				spawnPoints.Add(gameObject.transform.position);
				if (target != null)
				{
					gameObject.GetComponent<PeopleController>().SetTarget(target.transform.position);
				}
				else
				{
					gameObject.transform.localEulerAngles = new Vector3(gameObject.transform.rotation.x, base.transform.rotation.y, gameObject.transform.rotation.z);
				}
				gameObject.GetComponent<PeopleController>().animNames = new string[4] { "idle1", "idle2", "cheer", "claphands" };
				gameObject.transform.parent = par.transform;
				gameObject.GetComponent<Rigidbody>().freezeRotation = true;
			}
		}
	}

	private Vector3 RandomRectanglePosition()
	{
		Vector3 vector = new Vector3(0f, 0f, 0f);
		for (int i = 0; i < 10; i++)
		{
			vector.x = surface.transform.position.x - GetRealPlaneSize().x / 2f + 0.3f + UnityEngine.Random.Range(0f, GetRealPlaneSize().x - 0.6f);
			vector.z = surface.transform.position.z - GetRealPlaneSize().y / 2f + 0.3f + UnityEngine.Random.Range(0f, GetRealPlaneSize().y - 0.6f);
			vector.y = surface.transform.position.y;
			if (IsRandomPositionFree(vector))
			{
				return vector;
			}
		}
		return Vector3.zero;
	}

	private Vector3 RandomCirclePosition()
	{
		Vector3 position = surface.transform.position;
		float num = GetRealPlaneSize().x / 2f;
		Vector3 vector = default(Vector3);
		for (int i = 0; i < 10; i++)
		{
			float num2 = UnityEngine.Random.value * num;
			float num3 = UnityEngine.Random.value * 360f;
			vector.x = position.x + num2 * Mathf.Sin(num3 * ((float)Math.PI / 180f));
			vector.y = position.y;
			vector.z = position.z + num2 * Mathf.Cos(num3 * ((float)Math.PI / 180f));
			if (IsRandomPositionFree(vector))
			{
				return vector;
			}
		}
		return Vector3.zero;
	}

	private bool IsRandomPositionFree(Vector3 pos)
	{
		for (int i = 0; i < spawnPoints.Count; i++)
		{
			if (spawnPoints[i].x - 0.6f < pos.x && spawnPoints[i].x + 1f > pos.x && spawnPoints[i].z - 0.5f < pos.z && spawnPoints[i].z + 0.6f > pos.z)
			{
				return false;
			}
		}
		return true;
	}

	private Vector2 GetRealPlaneSize()
	{
		Vector3 size = surface.GetComponent<MeshRenderer>().bounds.size;
		return new Vector2(size.x, size.z);
	}

	private Vector2 GetRealPeopleModelSize()
	{
		Vector3 size = peoplePrefabs[1].GetComponent<MeshRenderer>().bounds.size;
		return new Vector2(size.x, size.z);
	}
}
public class StandingPeopleStreet : MonoBehaviour
{
	public enum TestEnum
	{
		Rectangle,
		Circle
	}

	[HideInInspector]
	public GameObject planePrefab;

	[HideInInspector]
	public GameObject circlePrefab;

	[HideInInspector]
	public GameObject surface;

	[HideInInspector]
	public Vector2 planeSize = new Vector2(1f, 1f);

	public GameObject[] peoplePrefabs = new GameObject[0];

	[HideInInspector]
	public List<Vector3> spawnPoints = new List<Vector3>();

	[HideInInspector]
	public int peopleCount;

	[HideInInspector]
	public bool isCircle;

	[HideInInspector]
	public float circleDiametr = 1f;

	[HideInInspector]
	public bool showSurface = true;

	public TestEnum SurfaceType;

	[HideInInspector]
	public GameObject par;

	public void OnDrawGizmos()
	{
		if (!isCircle)
		{
			surface.transform.localScale = new Vector3(planeSize.x, planeSize.y, 1f);
		}
		else
		{
			surface.transform.localScale = new Vector3(circleDiametr, circleDiametr, 1f);
		}
	}

	public void SpawnRectangleSurface()
	{
		if (surface != null)
		{
			UnityEngine.Object.DestroyImmediate(surface);
		}
		GameObject gameObject = (surface = UnityEngine.Object.Instantiate(planePrefab, base.transform.position, Quaternion.identity));
		isCircle = false;
		gameObject.transform.eulerAngles = new Vector3(gameObject.transform.eulerAngles.x - 90f, gameObject.transform.eulerAngles.y, gameObject.transform.eulerAngles.z);
		gameObject.transform.position += new Vector3(0f, 0.01f, 0f);
		gameObject.transform.parent = base.transform;
		gameObject.name = "surface";
	}

	public void SpawnCircleSurface()
	{
		if (surface != null)
		{
			UnityEngine.Object.DestroyImmediate(surface);
		}
		GameObject gameObject = UnityEngine.Object.Instantiate(circlePrefab, base.transform.position, Quaternion.identity);
		isCircle = true;
		gameObject.transform.eulerAngles = new Vector3(gameObject.transform.eulerAngles.x - 90f, gameObject.transform.eulerAngles.y, gameObject.transform.eulerAngles.z);
		gameObject.transform.position += new Vector3(0f, 0.01f, 0f);
		gameObject.transform.parent = base.transform;
		gameObject.name = "surface";
		surface = gameObject;
	}

	public void RemoveButton()
	{
		if (par != null)
		{
			UnityEngine.Object.DestroyImmediate(par);
		}
		par = null;
	}

	public void PopulateButton()
	{
		RemoveButton();
		GameObject gameObject = (par = new GameObject());
		gameObject.transform.parent = base.gameObject.transform;
		gameObject.name = "people";
		spawnPoints.Clear();
		SpawnPeople(peopleCount);
	}

	private void SpawnPeople(int _peopleCount)
	{
		int num = UnityEngine.Random.Range(0, _peopleCount / 3) * 3;
		int num2 = UnityEngine.Random.Range(0, (_peopleCount - num) / 2) * 2;
		int num3 = _peopleCount - num - num2;
		int[] randomPrefabIndexes = CommonUtils.GetRandomPrefabIndexes(peopleCount, ref peoplePrefabs);
		int num4 = 0;
		for (int i = 0; i < num3; i++)
		{
			Vector3 vector = (isCircle ? RandomCirclePosition() : RandomRectanglePosition());
			if (vector != Vector3.zero)
			{
				GameObject gameObject = UnityEngine.Object.Instantiate(peoplePrefabs[randomPrefabIndexes[num4]], vector, Quaternion.identity);
				num4++;
				if (Physics.Raycast(gameObject.transform.position + Vector3.up * 0.1f, Vector3.down, out var hitInfo))
				{
					gameObject.transform.position = new Vector3(gameObject.transform.position.x, hitInfo.point.y, gameObject.transform.position.z);
				}
				gameObject.AddComponent<PeopleController>();
				spawnPoints.Add(gameObject.transform.position);
				gameObject.transform.localEulerAngles = new Vector3(gameObject.transform.rotation.x, UnityEngine.Random.Range(1, 359), gameObject.transform.rotation.z);
				gameObject.GetComponent<PeopleController>().animNames = new string[2] { "idle1", "idle2" };
				gameObject.transform.parent = par.transform;
				gameObject.GetComponent<Rigidbody>().freezeRotation = true;
			}
		}
		for (int j = 0; j < num2 / 2; j++)
		{
			Vector3 vector2 = (isCircle ? RandomCirclePosition() : RandomRectanglePosition());
			if (!(vector2 != Vector3.zero))
			{
				continue;
			}
			Vector3 vector3 = Vector3.zero;
			Vector3 vector4 = Vector3.zero;
			for (int k = 0; k < 100; k++)
			{
				for (int l = 0; l < 10; l++)
				{
					vector3 = vector2 + new Vector3(UnityEngine.Random.Range(-0.5f, 0.5f), 0f, UnityEngine.Random.Range(-0.5f, 0.5f));
					if (IsRandomPositionFree(vector3, Vector3.zero, Vector3.zero))
					{
						break;
					}
					vector3 = Vector3.zero;
				}
				for (int m = 0; m < 10; m++)
				{
					vector4 = vector2 + new Vector3(UnityEngine.Random.Range(-0.5f, 0.5f), 0f, UnityEngine.Random.Range(-0.5f, 0.5f));
					if (IsRandomPositionFree(vector4, vector3, Vector3.zero))
					{
						break;
					}
					vector4 = Vector3.zero;
				}
				if (vector3 != Vector3.zero && vector4 != Vector3.zero)
				{
					spawnPoints.Add(vector3);
					spawnPoints.Add(vector4);
					break;
				}
				vector3 = Vector3.zero;
				vector4 = Vector3.zero;
			}
			if (vector3 != Vector3.zero && vector4 != Vector3.zero)
			{
				int num5 = UnityEngine.Random.Range(0, peoplePrefabs.Length);
				GameObject gameObject2 = base.gameObject;
				gameObject2 = UnityEngine.Object.Instantiate(peoplePrefabs[num5], vector3, Quaternion.identity);
				if (Physics.Raycast(gameObject2.transform.position + Vector3.up * 0.1f, Vector3.down, out var hitInfo2))
				{
					gameObject2.transform.position = new Vector3(gameObject2.transform.position.x, hitInfo2.point.y, gameObject2.transform.position.z);
				}
				gameObject2.AddComponent<PeopleController>();
				gameObject2.GetComponent<PeopleController>().animNames = new string[3] { "talk1", "talk2", "listen" };
				gameObject2.transform.parent = par.transform;
				num5 = UnityEngine.Random.Range(0, peoplePrefabs.Length);
				GameObject gameObject3 = base.gameObject;
				gameObject3 = UnityEngine.Object.Instantiate(peoplePrefabs[num5], vector4, Quaternion.identity);
				if (Physics.Raycast(gameObject3.transform.position + Vector3.up * 0.1f, Vector3.down, out var hitInfo3))
				{
					gameObject3.transform.position = new Vector3(gameObject3.transform.position.x, hitInfo3.point.y, gameObject3.transform.position.z);
				}
				gameObject3.AddComponent<PeopleController>();
				gameObject3.GetComponent<PeopleController>().animNames = new string[3] { "talk1", "talk2", "listen" };
				gameObject3.transform.parent = par.transform;
				gameObject3.GetComponent<PeopleController>().SetTarget(gameObject2.transform.position);
				gameObject2.GetComponent<PeopleController>().SetTarget(gameObject3.transform.position);
			}
		}
		for (int n = 0; n < num / 3; n++)
		{
			Vector3 vector5 = (isCircle ? RandomCirclePosition() : RandomRectanglePosition());
			if (!(vector5 != Vector3.zero))
			{
				continue;
			}
			int num6 = UnityEngine.Random.Range(0, peoplePrefabs.Length);
			Vector3 vector6 = Vector3.zero;
			Vector3 vector7 = Vector3.zero;
			Vector3 vector8 = Vector3.zero;
			for (int num7 = 0; num7 < 100; num7++)
			{
				for (int num8 = 0; num8 < 10; num8++)
				{
					vector6 = vector5 + new Vector3(UnityEngine.Random.Range(-0.5f, 0.5f), 0f, UnityEngine.Random.Range(-0.5f, 0.5f));
					if (IsRandomPositionFree(vector6, Vector3.zero, Vector3.zero))
					{
						break;
					}
					vector6 = Vector3.zero;
				}
				for (int num9 = 0; num9 < 10; num9++)
				{
					if (vector6 != Vector3.zero)
					{
						vector7 = vector5 + new Vector3(UnityEngine.Random.Range(-0.5f, 0.5f), 0f, UnityEngine.Random.Range(-0.5f, 0.5f));
						if (IsRandomPositionFree(vector7, vector6, Vector3.zero))
						{
							break;
						}
						vector7 = Vector3.zero;
					}
					else
					{
						vector7 = Vector3.zero;
					}
				}
				for (int num10 = 0; num10 < 10; num10++)
				{
					if (vector7 != Vector3.zero && vector6 != Vector3.zero)
					{
						vector8 = vector5 + new Vector3(UnityEngine.Random.Range(-0.5f, 0.5f), 0f, UnityEngine.Random.Range(-0.5f, 0.5f));
						if (IsRandomPositionFree(vector8, vector6, vector7))
						{
							break;
						}
						vector8 = Vector3.zero;
					}
					else
					{
						vector8 = Vector3.zero;
					}
				}
				if (vector6 != Vector3.zero && vector7 != Vector3.zero && vector8 != Vector3.zero)
				{
					spawnPoints.Add(vector6);
					spawnPoints.Add(vector7);
					spawnPoints.Add(vector8);
					break;
				}
				vector6 = Vector3.zero;
				vector7 = Vector3.zero;
				vector8 = Vector3.zero;
			}
			if (!(vector6 != Vector3.zero))
			{
				continue;
			}
			if (vector6 != Vector3.zero)
			{
				GameObject gameObject4 = UnityEngine.Object.Instantiate(peoplePrefabs[num6], vector6, Quaternion.identity);
				if (Physics.Raycast(gameObject4.transform.position + Vector3.up * 0.1f, Vector3.down, out var hitInfo4))
				{
					gameObject4.transform.position = new Vector3(gameObject4.transform.position.x, hitInfo4.point.y, gameObject4.transform.position.z);
				}
				gameObject4.AddComponent<PeopleController>();
				gameObject4.GetComponent<PeopleController>().SetTarget(vector5);
				gameObject4.GetComponent<PeopleController>().animNames = new string[3] { "talk1", "talk2", "listen" };
				gameObject4.transform.parent = par.transform;
			}
			num6 = UnityEngine.Random.Range(0, peoplePrefabs.Length);
			if (vector6 != Vector3.zero)
			{
				GameObject gameObject5 = UnityEngine.Object.Instantiate(peoplePrefabs[num6], vector7, Quaternion.identity);
				if (Physics.Raycast(gameObject5.transform.position + Vector3.up * 0.1f, Vector3.down, out var hitInfo5))
				{
					gameObject5.transform.position = new Vector3(gameObject5.transform.position.x, hitInfo5.point.y, gameObject5.transform.position.z);
				}
				gameObject5.AddComponent<PeopleController>();
				gameObject5.GetComponent<PeopleController>().SetTarget(vector5);
				gameObject5.GetComponent<PeopleController>().animNames = new string[3] { "talk1", "talk2", "listen" };
				gameObject5.transform.parent = par.transform;
			}
			num6 = UnityEngine.Random.Range(0, peoplePrefabs.Length);
			if (vector6 != Vector3.zero)
			{
				GameObject gameObject6 = UnityEngine.Object.Instantiate(peoplePrefabs[num6], vector8, Quaternion.identity);
				if (Physics.Raycast(gameObject6.transform.position + Vector3.up * 0.1f, Vector3.down, out var hitInfo6))
				{
					gameObject6.transform.position = new Vector3(gameObject6.transform.position.x, hitInfo6.point.y, gameObject6.transform.position.z);
				}
				gameObject6.AddComponent<PeopleController>();
				gameObject6.GetComponent<PeopleController>().SetTarget(vector5);
				gameObject6.GetComponent<PeopleController>().animNames = new string[3] { "talk1", "talk2", "listen" };
				gameObject6.transform.parent = par.transform;
			}
		}
	}

	private Vector3 RandomRectanglePosition()
	{
		Vector3 vector = new Vector3(0f, 0f, 0f);
		for (int i = 0; i < 10; i++)
		{
			vector.x = surface.transform.position.x - GetRealPlaneSize().x / 2f + 0.3f + UnityEngine.Random.Range(0f, GetRealPlaneSize().x - 0.6f);
			vector.z = surface.transform.position.z - GetRealPlaneSize().y / 2f + 0.3f + UnityEngine.Random.Range(0f, GetRealPlaneSize().y - 0.6f);
			vector.y = surface.transform.position.y;
			if (IsRandomPositionFree(vector, Vector3.zero, Vector3.zero))
			{
				return vector;
			}
		}
		return Vector3.zero;
	}

	private Vector3 RandomCirclePosition()
	{
		Vector3 position = surface.transform.position;
		float num = GetRealPlaneSize().x / 2f;
		Vector3 vector = default(Vector3);
		for (int i = 0; i < 10; i++)
		{
			float num2 = UnityEngine.Random.value * num;
			float num3 = UnityEngine.Random.value * 360f;
			vector.x = position.x + num2 * Mathf.Sin(num3 * ((float)Math.PI / 180f));
			vector.y = position.y;
			vector.z = position.z + num2 * Mathf.Cos(num3 * ((float)Math.PI / 180f));
			if (Vector3.Distance(vector, position) < GetRealPlaneSize().x / 2f - 0.3f && IsRandomPositionFree(vector, Vector3.zero, Vector3.zero))
			{
				return vector;
			}
		}
		return Vector3.zero;
	}

	private bool IsRandomPositionFree(Vector3 pos, Vector3 helpPoint1, Vector3 helpPoint2)
	{
		for (int i = 0; i < spawnPoints.Count; i++)
		{
			if (spawnPoints[i].x - 0.5f < pos.x && spawnPoints[i].x + 0.5f > pos.x && spawnPoints[i].z - 0.5f < pos.z && spawnPoints[i].z + 0.5f > pos.z)
			{
				return false;
			}
		}
		if (helpPoint1 != Vector3.zero)
		{
			if (helpPoint1.x - 0.6f < pos.x && helpPoint1.x + 0.6f > pos.x && helpPoint1.z - 0.6f < pos.z && helpPoint1.z + 0.6f > pos.z)
			{
				return false;
			}
			if (!isCircle)
			{
				if (!(helpPoint1.x + 0.3f > surface.transform.position.x - GetRealPlaneSize().x / 2f) && !(helpPoint1.x - 0.3f < surface.transform.position.x + GetRealPlaneSize().x / 2f) && !(helpPoint1.z + 0.3f > surface.transform.position.z - GetRealPlaneSize().y / 2f) && !(helpPoint1.z - 0.3f < surface.transform.position.z + GetRealPlaneSize().y / 2f))
				{
					return false;
				}
			}
			else if (Vector3.Distance(helpPoint1, surface.transform.position) >= GetRealPlaneSize().x / 2f - 0.3f)
			{
				return false;
			}
		}
		if (helpPoint2 != Vector3.zero)
		{
			if (helpPoint2.x - 0.6f < pos.x && helpPoint2.x + 0.6f > pos.x && helpPoint2.z - 0.6f < pos.z && helpPoint2.z + 0.6f > pos.z)
			{
				return false;
			}
			if (!isCircle)
			{
				if (!(helpPoint2.x + 0.3f > surface.transform.position.x - GetRealPlaneSize().x / 2f) && !(helpPoint2.x - 0.3f < surface.transform.position.x + GetRealPlaneSize().x / 2f) && !(helpPoint2.z + 0.3f > surface.transform.position.z - GetRealPlaneSize().y / 2f) && !(helpPoint2.z - 0.3f < surface.transform.position.z + GetRealPlaneSize().y / 2f))
				{
					return false;
				}
			}
			else if (Vector3.Distance(helpPoint2, surface.transform.position) >= GetRealPlaneSize().x / 2f - 0.3f)
			{
				return false;
			}
		}
		return true;
	}

	private Vector2 GetRealPlaneSize()
	{
		Vector3 size = surface.GetComponent<MeshRenderer>().bounds.size;
		return new Vector2(size.x, size.z);
	}

	private Vector2 GetRealPeopleModelSize()
	{
		Vector3 size = peoplePrefabs[1].GetComponent<MeshRenderer>().bounds.size;
		return new Vector2(size.x, size.z);
	}
}
public class LightManager : MonoBehaviour
{
	public bool TCrossroad;

	public bool standardCrossroad;
}
public class SemaphorePeople : MonoBehaviour
{
	private int howManyInMe;

	[SerializeField]
	private bool carCan;

	[SerializeField]
	private bool peopleCan;

	private bool flicker;

	public bool CAR_CAN
	{
		get
		{
			return carCan;
		}
		set
		{
			carCan = value;
		}
	}

	public bool PEOPLE_CAN
	{
		get
		{
			return peopleCan;
		}
		set
		{
			peopleCan = value;
		}
	}

	public int HOW_MANY
	{
		get
		{
			return howManyInMe;
		}
		private set
		{
		}
	}

	public bool FLICKER
	{
		get
		{
			return flicker;
		}
		set
		{
			flicker = value;
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.CompareTag("People"))
		{
			howManyInMe++;
		}
	}

	private void OnTriggerStay(Collider other)
	{
		if (other.CompareTag("People") && (bool)other.transform.GetComponent<Passersby>())
		{
			Passersby component = other.GetComponent<Passersby>();
			component.INSIDE = true;
			if (!peopleCan)
			{
				component.RED = true;
			}
			else
			{
				component.RED = false;
			}
		}
		if (other.CompareTag("Car") && (bool)other.transform.GetComponent<CarAIController>())
		{
			other.GetComponent<CarAIController>().INSIDE = true;
		}
		if (other.transform.CompareTag("Bcycle") && (bool)other.transform.GetComponentInParent<BcycleGyroController>())
		{
			other.GetComponentInParent<BcycleGyroController>().insideSemaphore = true;
		}
	}

	private void OnTriggerExit(Collider other)
	{
		if (other.CompareTag("Car") && (bool)other.transform.GetComponent<CarAIController>())
		{
			other.GetComponent<CarAIController>().INSIDE = false;
		}
		if (other.transform.CompareTag("Bcycle") && (bool)other.transform.GetComponentInParent<BcycleGyroController>())
		{
			other.GetComponentInParent<BcycleGyroController>().insideSemaphore = false;
		}
		if (other.CompareTag("People") && (bool)other.transform.GetComponent<Passersby>())
		{
			Passersby component = other.GetComponent<Passersby>();
			StartCoroutine(StopInside(component));
		}
		if (other.CompareTag("People"))
		{
			howManyInMe--;
		}
	}

	private IEnumerator StopInside(Passersby passersby)
	{
		yield return new WaitForSeconds(1f);
		passersby.INSIDE = false;
		passersby.RED = false;
		passersby.ANIMATION_STATE = passersby.LastState;
	}
}
public class SemaphoreSimulator : MonoBehaviour
{
	private float greenTimer;

	private float yellowTimer;

	private float redTimer;

	private float peopleTimer;

	private int stage;

	private bool yellowOn;

	private bool timeBreak;

	private bool timePeople;

	[SerializeField]
	[Tooltip("Selecting the direction of the initial motion at the traffic light / Выбор направления начального движения на светофоре")]
	private bool blockForward;

	[SerializeField]
	[Tooltip("Traffic lights for transport on one side / Светофоры для транспорта с одной стороны")]
	private TLGraphicsControl[] FWDlights;

	[SerializeField]
	[Tooltip("Traffic lights for transport on the other side / Светофоры для транспорта с другой стороны")]
	private TLGraphicsControl[] LRlights;

	[SerializeField]
	[Tooltip("Traffic lights for pedestrians on one side / Светофоры для пешеходов с одной стороны")]
	private TLGraphicsControl[] FWDpeopleLight;

	[SerializeField]
	[Tooltip("Traffic lights for pedestrians on the other side / Светофоры для пешеходов с другой стороны")]
	private TLGraphicsControl[] LRpeopleLight;

	[SerializeField]
	[Tooltip("Triggers of traffic lights on one side / Тригеры светофоров с одной стороны")]
	private SemaphorePeople[] FWDpeopleZebra;

	[SerializeField]
	[Tooltip("Triggers of traffic lights on the other side / Тригеры светофоров с другой стороны")]
	private SemaphorePeople[] LRpeopleZebra;

	[SerializeField]
	[Tooltip("Time for green light / Время для зеленого света")]
	private float greenTime;

	[SerializeField]
	[Tooltip("Time for yellow light / Время для желтого света")]
	private float yellowTime;

	[SerializeField]
	[Tooltip("Time for red light / Время для красного света")]
	private float redTime;

	[SerializeField]
	[Tooltip("Time for pedestrians / Время для пешеходов")]
	private float peopleTime;

	public bool YELLOW_ON
	{
		get
		{
			return yellowOn;
		}
		set
		{
			yellowOn = value;
			YellowTime();
		}
	}

	public int STAGE
	{
		get
		{
			return stage;
		}
		set
		{
			stage = value;
		}
	}

	private void Awake()
	{
		greenTimer = greenTime;
		yellowTimer = yellowTime;
		redTimer = redTime;
		peopleTimer = peopleTime;
	}

	private void Start()
	{
		for (int i = 0; i < FWDpeopleLight.Length; i++)
		{
			FWDpeopleLight[i].DisableGreen(withArrow: false);
			FWDpeopleLight[i].EnableRed();
		}
		for (int j = 0; j < LRpeopleLight.Length; j++)
		{
			LRpeopleLight[j].DisableGreen(withArrow: false);
			LRpeopleLight[j].EnableRed();
		}
		SanityCheck();
		SetFlow();
	}

	private void SanityCheck()
	{
		if (blockForward)
		{
			if (LRlights.Length == 0)
			{
				blockForward = false;
			}
		}
		else if (FWDlights.Length == 0)
		{
			blockForward = true;
		}
	}

	private void Update()
	{
		if (yellowOn)
		{
			yellowTimer -= Time.deltaTime;
			if (yellowTimer <= 0f)
			{
				yellowOn = false;
				yellowTimer = yellowTime;
				if (timeBreak)
				{
					if (stage == 0)
					{
						stage++;
					}
					else
					{
						stage = 0;
					}
					timeBreak = false;
					SetFlow();
					greenTimer = greenTime;
				}
				else
				{
					if (blockForward)
					{
						for (int i = 0; i < LRlights.Length; i++)
						{
							LRlights[i].DisableYellow();
							LRlights[i].EnableRed();
						}
					}
					else
					{
						for (int j = 0; j < FWDlights.Length; j++)
						{
							FWDlights[j].DisableYellow();
							FWDlights[j].EnableRed();
						}
					}
					if (stage == 0)
					{
						timeBreak = true;
					}
					else if (stage == 1)
					{
						for (int k = 0; k < FWDpeopleLight.Length; k++)
						{
							FWDpeopleLight[k].DisableRed();
							FWDpeopleLight[k].EnableGreen(withArrow: false);
						}
						for (int l = 0; l < LRpeopleLight.Length; l++)
						{
							LRpeopleLight[l].DisableRed();
							LRpeopleLight[l].EnableGreen(withArrow: false);
						}
						for (int m = 0; m < FWDpeopleZebra.Length; m++)
						{
							FWDpeopleZebra[m].PEOPLE_CAN = true;
						}
						for (int n = 0; n < LRpeopleZebra.Length; n++)
						{
							LRpeopleZebra[n].PEOPLE_CAN = true;
						}
						peopleTimer = peopleTime;
						timePeople = true;
					}
				}
			}
		}
		else if (timeBreak)
		{
			TimeBreak();
		}
		if (greenTimer > 0f)
		{
			greenTimer -= Time.deltaTime;
			if (greenTimer <= 0f)
			{
				StartFlickerGreen();
			}
		}
		if (timePeople)
		{
			TimePeople();
		}
	}

	private void StartFlickerGreen()
	{
		if (blockForward)
		{
			for (int i = 0; i < LRlights.Length; i++)
			{
				LRlights[i].FlickerGreen(4f, 0.5f);
			}
		}
		else
		{
			for (int j = 0; j < FWDlights.Length; j++)
			{
				FWDlights[j].FlickerGreen(4f, 0.5f);
			}
		}
	}

	private void TimeBreak()
	{
		redTimer -= Time.deltaTime;
		if (!(redTimer <= 0f))
		{
			return;
		}
		if (blockForward)
		{
			if (FWDlights.Length != 0)
			{
				blockForward = false;
				for (int i = 0; i < FWDlights.Length; i++)
				{
					FWDlights[i].EnableYellow();
				}
			}
			else
			{
				for (int j = 0; j < LRlights.Length; j++)
				{
					LRlights[j].EnableYellow();
				}
			}
		}
		else if (LRlights.Length != 0)
		{
			blockForward = true;
			for (int k = 0; k < LRlights.Length; k++)
			{
				LRlights[k].EnableYellow();
			}
		}
		else
		{
			for (int l = 0; l < FWDlights.Length; l++)
			{
				FWDlights[l].EnableYellow();
			}
		}
		redTimer = redTime;
		yellowOn = true;
		UnityEngine.Debug.Log("32");
	}

	private void TimePeople()
	{
		peopleTimer -= Time.deltaTime;
		if (peopleTimer <= 0f)
		{
			timePeople = false;
			for (int i = 0; i < FWDpeopleLight.Length; i++)
			{
				FWDpeopleLight[i].FlickerGreen(4f, 0.5f);
			}
			for (int j = 0; j < LRpeopleLight.Length; j++)
			{
				LRpeopleLight[j].FlickerGreen(4f, 0.5f);
			}
			for (int k = 0; k < FWDpeopleZebra.Length; k++)
			{
				FWDpeopleZebra[k].PEOPLE_CAN = false;
			}
			for (int l = 0; l < LRpeopleZebra.Length; l++)
			{
				LRpeopleZebra[l].PEOPLE_CAN = false;
			}
		}
	}

	private void AllowFwd()
	{
		for (int i = 0; i < FWDlights.Length; i++)
		{
			FWDlights[i].EnableGreen(withArrow: true);
			FWDlights[i].DisableRed();
			FWDlights[i].DisableYellow();
		}
		for (int j = 0; j < LRlights.Length; j++)
		{
			LRlights[j].DisableGreen(withArrow: true);
			LRlights[j].DisableYellow();
			LRlights[j].EnableRed();
		}
		for (int k = 0; k < FWDpeopleZebra.Length; k++)
		{
			FWDpeopleZebra[k].CAR_CAN = true;
		}
	}

	private void AllowLR()
	{
		for (int i = 0; i < LRlights.Length; i++)
		{
			LRlights[i].EnableGreen(withArrow: true);
			LRlights[i].DisableRed();
			LRlights[i].DisableYellow();
		}
		for (int j = 0; j < FWDlights.Length; j++)
		{
			FWDlights[j].DisableGreen(withArrow: true);
			FWDlights[j].DisableYellow();
			FWDlights[j].EnableRed();
		}
		for (int k = 0; k < LRpeopleZebra.Length; k++)
		{
			LRpeopleZebra[k].CAR_CAN = true;
		}
	}

	private void SetFlow()
	{
		if (blockForward)
		{
			AllowLR();
		}
		else
		{
			AllowFwd();
		}
	}

	public void ResetSemaphore()
	{
		timeBreak = true;
	}

	private void YellowTime()
	{
		if (blockForward)
		{
			for (int i = 0; i < LRpeopleZebra.Length; i++)
			{
				LRpeopleZebra[i].CAR_CAN = false;
			}
		}
		else
		{
			for (int j = 0; j < FWDpeopleZebra.Length; j++)
			{
				FWDpeopleZebra[j].CAR_CAN = false;
			}
		}
	}

	private void OnTriggerStay(Collider other)
	{
		if (other.transform.CompareTag("Car") && (bool)other.transform.GetComponentInParent<CarAIController>())
		{
			other.GetComponentInParent<CarAIController>().INSIDE = true;
		}
		if (other.transform.CompareTag("Bcycle") && (bool)other.transform.GetComponentInParent<BcycleGyroController>())
		{
			other.GetComponentInParent<BcycleGyroController>().insideSemaphore = true;
		}
	}

	private void OnTriggerExit(Collider other)
	{
		if (other.transform.CompareTag("Car") && (bool)other.transform.GetComponentInParent<CarAIController>())
		{
			other.GetComponentInParent<CarAIController>().INSIDE = false;
		}
		if (other.transform.CompareTag("Bcycle") && (bool)other.transform.GetComponentInParent<BcycleGyroController>())
		{
			other.GetComponentInParent<BcycleGyroController>().insideSemaphore = false;
		}
	}
}
public class TLGraphicsControl : MonoBehaviour
{
	private Material green;

	private Material yellow;

	private Material red;

	private Material arrow;

	[SerializeField]
	private bool greenOn;

	[SerializeField]
	private bool yellowOn;

	[SerializeField]
	private bool redOn;

	[SerializeField]
	private bool arrowOn;

	private bool flickerGreen;

	private bool flickerGreenCurrent;

	private float flickerTime;

	private float flickerRate;

	private float flickerCurrent;

	public TLGraphicsControl secondSide;

	public Texture2D greenG;

	public Texture2D yellowG;

	public Texture2D redG;

	public Texture2D arrowG;

	public MeshRenderer mshG;

	public MeshRenderer mshY;

	public MeshRenderer mshR;

	public MeshRenderer mshA;

	public bool twoSided;

	public bool hasArrow;

	private void Awake()
	{
		green = mshG.materials[1];
		if (mshY != null)
		{
			yellow = mshY.materials[1];
		}
		red = mshR.materials[1];
		if (hasArrow)
		{
			arrow = mshA.materials[1];
		}
	}

	private void Update()
	{
		if (!flickerGreen)
		{
			return;
		}
		flickerTime -= Time.deltaTime;
		if (flickerTime < 0f)
		{
			flickerGreen = false;
			DisableGreen(hasArrow);
			SemaphoreSimulator componentInParent = GetComponentInParent<SemaphoreSimulator>();
			if (mshY == null)
			{
				EnableRed();
				if (componentInParent.STAGE == 1)
				{
					componentInParent.ResetSemaphore();
				}
			}
			else
			{
				EnableYellow();
				if (!componentInParent.YELLOW_ON && (componentInParent.STAGE == 0 || componentInParent.STAGE == 1))
				{
					componentInParent.YELLOW_ON = true;
				}
			}
		}
		flickerCurrent -= Time.deltaTime;
		if (!(flickerCurrent < 0f))
		{
			return;
		}
		flickerCurrent = flickerRate;
		flickerGreenCurrent = !flickerGreenCurrent;
		if (flickerGreenCurrent)
		{
			green.EnableKeyword("_EMISSION");
			if (hasArrow)
			{
				arrow.EnableKeyword("_EMISSION");
			}
		}
		else
		{
			green.DisableKeyword("_EMISSION");
			if (hasArrow)
			{
				arrow.DisableKeyword("_EMISSION");
			}
		}
	}

	public void EnableGreen(bool withArrow)
	{
		if (!greenOn)
		{
			green.EnableKeyword("_EMISSION");
			green.SetTexture("_EmissionMap", greenG);
			greenOn = true;
			if (withArrow)
			{
				EnableArrow();
			}
			if (twoSided)
			{
				secondSide.EnableGreen(withArrow: false);
			}
		}
	}

	public void EnableYellow()
	{
		if (!yellowOn)
		{
			yellow.EnableKeyword("_EMISSION");
			yellow.SetTexture("_EmissionMap", yellowG);
			yellowOn = true;
			if (twoSided)
			{
				secondSide.EnableYellow();
			}
		}
	}

	public void EnableRed()
	{
		if (!redOn)
		{
			red.EnableKeyword("_EMISSION");
			red.SetTexture("_EmissionMap", redG);
			redOn = true;
			if (twoSided)
			{
				secondSide.EnableRed();
			}
		}
	}

	public void EnableArrow()
	{
		if (!arrowOn && hasArrow)
		{
			arrow.EnableKeyword("_EMISSION");
			arrow.SetTexture("_EmissionMap", arrowG);
			arrowOn = true;
			if (twoSided)
			{
				secondSide.EnableArrow();
			}
		}
	}

	public void DisableGreen(bool withArrow)
	{
		if (greenOn)
		{
			green.DisableKeyword("_EMISSION");
			greenOn = false;
			if (withArrow && hasArrow)
			{
				DisableArrow();
			}
			if (twoSided)
			{
				secondSide.DisableGreen(withArrow: false);
			}
		}
	}

	public void DisableYellow()
	{
		if (yellowOn)
		{
			yellow.DisableKeyword("_EMISSION");
			yellowOn = false;
			if (twoSided)
			{
				secondSide.DisableYellow();
			}
		}
	}

	public void DisableRed()
	{
		if (redOn)
		{
			red.DisableKeyword("_EMISSION");
			redOn = false;
			if (twoSided)
			{
				secondSide.DisableRed();
			}
		}
	}

	public void DisableArrow()
	{
		if (arrowOn)
		{
			arrow.DisableKeyword("_EMISSION");
			arrowOn = false;
			if (twoSided)
			{
				secondSide.DisableArrow();
			}
		}
	}

	public void FlickerGreen(float time, float rate)
	{
		if (twoSided)
		{
			secondSide.FlickerGreen(time, rate);
		}
		flickerTime = time;
		flickerRate = (flickerCurrent = rate);
		flickerGreen = true;
	}
}
public class InteractionModeHandle : MonoBehaviour
{
	private class Log
	{
		public static void d(string b, string a)
		{
		}

		public static void e(string b, string a)
		{
		}
	}

	private class RequestCompleteHandler : AndroidJavaProxy
	{
		internal RequestCompleteHandler()
			: base(new AndroidJavaClass("com.htc.vr.unity.InteractionModeSettingCallback"))
		{
		}

		public void onRequestCompletedwithObject(string s)
		{
			Log.d("onRequestCompletedwithObject", " callback from init = " + s);
		}
	}

	private static string LOG_TAG = "InteractionModeHandle";

	private static bool isDeny = false;

	private static int retryCount = 0;

	private static int RETRY_LIMIT = 0;

	private bool isGazeMode;

	private const string DB_SETTINGS_CLASSNAME = "com.htc.vr.unity.InteractionModeSetting";

	private const string DB_SETTINGS_CALLBACK_CLASSNAME = "com.htc.vr.unity.InteractionModeSettingCallback";

	private AndroidJavaObject dbSetting;

	private void Start()
	{
		SetOverrideDefault(value: false);
		using AndroidJavaClass androidJavaClass = new AndroidJavaClass("com.unity3d.player.UnityPlayer");
		Log.d(LOG_TAG, " init AndroidJavaClass");
		using AndroidJavaObject androidJavaObject = androidJavaClass.GetStatic<AndroidJavaObject>("currentActivity");
		AndroidJavaClass androidJavaClass2 = new AndroidJavaClass("com.htc.vr.unity.InteractionModeSetting");
		if (androidJavaClass2 == null)
		{
			Log.e(LOG_TAG, "Interaction mode Start() com.htc.vr.unity.InteractionModeSetting is null");
			return;
		}
		dbSetting = androidJavaClass2.CallStatic<AndroidJavaObject>("getInstance", new object[2]
		{
			androidJavaObject,
			new RequestCompleteHandler()
		});
		if (dbSetting == null)
		{
			Log.e(LOG_TAG, "Interaction mode Start() could NOT get instance of com.htc.vr.unity.InteractionModeSetting");
		}
		Log.d(LOG_TAG, "Interaction mode Start() : com.htc.vr.unity.InteractionModeSetting");
	}

	private void OnDisable()
	{
		Log.d(LOG_TAG, " init AndroidJavaClass");
		if (new AndroidJavaClass("com.htc.vr.unity.InteractionModeSetting") == null)
		{
			Log.e(LOG_TAG, "writeinteractionvalue() com.htc.vr.unity.InteractionModeSetting is null");
		}
		else if (dbSetting != null)
		{
			dbSetting.Call("onDisable");
		}
		else
		{
			Log.e(LOG_TAG, "writeinteractionvalue() could NOT get instance of com.htc.vr.unity.InteractionModeSetting");
		}
	}

	public void changetoControllerMode()
	{
		writeinteractionvalue(3);
		isGazeMode = false;
	}

	public void changetoGazeMode()
	{
		writeinteractionvalue(2);
		isGazeMode = true;
	}

	public void gaze_timeoutMode()
	{
		writeGazeTriggermodevalue(1);
	}

	public void gaze_buttonMode()
	{
		writeGazeTriggermodevalue(2);
	}

	public void gaze_TimeoutandButtonMode()
	{
		writeGazeTriggermodevalue(3);
	}

	private void Update()
	{
	}

	private string[] getDBsetting()
	{
		Log.d(LOG_TAG, "getDBsetting ");
		return dbSetting.Call<string[]>("getDBSetting", Array.Empty<object>());
	}

	public void writeinteractionvalue(int value)
	{
		Log.d(LOG_TAG, " init AndroidJavaClass");
		if (new AndroidJavaClass("com.htc.vr.unity.InteractionModeSetting") == null)
		{
			Log.e(LOG_TAG, "writeinteractionvalue() com.htc.vr.unity.InteractionModeSetting is null");
		}
		else if (dbSetting != null)
		{
			string text = value.ToString();
			Log.d(LOG_TAG, "writeinteractionvalue() got instance of com.htc.vr.unity.InteractionModeSetting, change Interaction mode to " + text);
			dbSetting.Call("setInteractionModeValue", text);
		}
		else
		{
			Log.e(LOG_TAG, "writeinteractionvalue() could NOT get instance of com.htc.vr.unity.InteractionModeSetting");
		}
	}

	public void writeGazeTriggermodevalue(int value)
	{
		if (isGazeMode)
		{
			Log.d(LOG_TAG, " init AndroidJavaClass");
			if (new AndroidJavaClass("com.htc.vr.unity.InteractionModeSetting") == null)
			{
				Log.e(LOG_TAG, "write GazeTrigger mode value() com.htc.vr.unity.InteractionModeSetting is null");
			}
			else if (dbSetting != null)
			{
				string text = value.ToString();
				Log.d(LOG_TAG, "write GazeTrigger mode value()  got instance of com.htc.vr.unity.InteractionModeSetting, change Gaze Trigger mode to " + text);
				dbSetting.Call("setGazemodeTriggerType", text);
			}
			else
			{
				Log.e(LOG_TAG, "write Gaze Trigger Mode Value() could NOT get instance of com.htc.vr.unity.InteractionModeSetting");
			}
		}
	}

	private void SetOverrideDefault(bool value)
	{
		Log.d(LOG_TAG, "SetOverrideDefault: " + value);
	}
}
public class J_WaveVR_CurveRayTeleport : MonoBehaviour
{
	public GameObject m_Player;

	public Transform m_Head;

	[Space(5f)]
	public LayerMask m_TeleportLayerMask;

	public int m_segmentCount = 35;

	[Tooltip("The amount of time in seconds to predict the motion of the projectile.")]
	public float arcDuration = 3f;

	[Tooltip("The speed at which the line segments of the arc move.")]
	public float arcSpeed = 10f;

	public float scale = 2f;

	private bool m_bIsRayGround;

	public LineRenderer m_lineRender;

	public GameObject m_objGroundQuad;

	public static Action actionOnTeleport;

	private bool isShowCurveRay;

	private Vector3 vCheckPrePos;

	private RaycastHit hitInfo;

	private Vector3 hitPoint;

	private Vector3 vGravity = new Vector3(0f, -9.81f, 0f);

	private static bool m_isTeleportable = true;

	private void Update()
	{
		if (m_isTeleportable && isShowCurveRay)
		{
			FindCurveRayCast();
		}
	}

	public void J_ShowCurveRay()
	{
		isShowCurveRay = true;
		m_lineRender.gameObject.SetActive(value: true);
	}

	public void J_CheckCurveRayCast()
	{
		if (m_bIsRayGround)
		{
			UnityEngine.Debug.Log("--Teleport");
			if (m_Player != null)
			{
				m_Player.transform.position = hitPoint;
				actionOnTeleport?.Invoke();
			}
		}
		isShowCurveRay = false;
		m_bIsRayGround = false;
		m_lineRender.gameObject.SetActive(value: false);
		m_objGroundQuad.gameObject.SetActive(value: false);
	}

	public void UpJoysticks()
	{
		Vector3 vector = new Vector3(m_Head.forward.x, 0f, m_Head.forward.z);
		m_Player.transform.position += vector * 0.03f;
	}

	public void DownJoysticks()
	{
		Vector3 vector = new Vector3(m_Head.forward.x, 0f, m_Head.forward.z);
		m_Player.transform.position -= vector * 0.03f;
	}

	public void LeftJoysticks()
	{
		Vector3 vector = new Vector3(m_Head.right.x, 0f, m_Head.right.z);
		m_Player.transform.position -= vector * 0.03f;
	}

	public void RightJoysticks()
	{
		Vector3 vector = new Vector3(m_Head.right.x, 0f, m_Head.right.z);
		m_Player.transform.position += vector * 0.03f;
	}

	private void FindCurveRayCast()
	{
		m_bIsRayGround = false;
		float num = arcDuration / (float)m_segmentCount;
		float num2 = 0f;
		hitInfo = default(RaycastHit);
		Vector3 start = base.transform.position;
		List<Vector3> list = new List<Vector3>();
		list.Add(base.transform.position);
		for (int i = 0; i < m_segmentCount; i++)
		{
			float num3 = num2 + num;
			Vector3 arcPositionAtTime = GetArcPositionAtTime(num3);
			if (Physics.Linecast(start, arcPositionAtTime, out hitInfo, m_TeleportLayerMask))
			{
				m_bIsRayGround = true;
				hitPoint = hitInfo.point;
				list.Add(hitPoint);
				m_objGroundQuad.gameObject.SetActive(value: true);
				m_objGroundQuad.transform.position = hitPoint;
				m_objGroundQuad.transform.forward = hitInfo.normal;
				break;
			}
			num2 = num3;
			start = arcPositionAtTime;
			list.Add(arcPositionAtTime);
		}
		if (!m_bIsRayGround)
		{
			m_objGroundQuad.gameObject.SetActive(value: false);
		}
		m_lineRender.positionCount = list.Count;
		m_lineRender.SetPositions(list.ToArray());
	}

	private Vector3 GetArcPositionAtTime(float time)
	{
		return base.transform.position + (base.transform.forward * arcSpeed * time + 0.5f * time * time * vGravity) * scale;
	}

	private bool IsInLayer(GameObject objChcek)
	{
		UnityEngine.Debug.Log(m_TeleportLayerMask.value + ":" + objChcek.gameObject.layer + ":" + (m_TeleportLayerMask.value & objChcek.gameObject.layer));
		if ((m_TeleportLayerMask.value & (int)Mathf.Pow(2f, objChcek.gameObject.layer)) == (int)Mathf.Pow(2f, objChcek.gameObject.layer))
		{
			return true;
		}
		return false;
	}

	public static void J_SetTeleportHandEnable(bool isEnable)
	{
		m_isTeleportable = isEnable;
	}
}
public class WaveVR_HandGrabber : MonoBehaviour
{
	public struct AttachedObject
	{
		public WaveVR_interactableObject interactableObject;

		public Rigidbody attachedRigidbody;

		public Vector3 initialPositionalOffset;

		public Quaternion initialRotationalOffset;
	}

	public AttachedObject attachedObject;

	private WaveVR_interactableObject _hoveringInteractable;

	private List<WaveVR_interactableObject> listHoveredObjcets = new List<WaveVR_interactableObject>();

	protected const float MaxVelocityChange = 10f;

	protected const float VelocityMagic = 600f;

	protected const float AngularVelocityMagic = 50f;

	protected const float MaxAngularVelocityChange = 20f;

	public WaveVR_interactableObject hoveredObject
	{
		get
		{
			return _hoveringInteractable;
		}
		set
		{
			if (_hoveringInteractable != value)
			{
				if (_hoveringInteractable != null)
				{
					_hoveringInteractable.SendMessage("OnHandHoverEnd", this, SendMessageOptions.DontRequireReceiver);
				}
				_hoveringInteractable = value;
				if (_hoveringInteractable != null)
				{
					_hoveringInteractable.SendMessage("OnHandHoverBegin", this, SendMessageOptions.DontRequireReceiver);
				}
			}
		}
	}

	private void Awake()
	{
		initTriggerCollider();
	}

	private void initTriggerCollider()
	{
		BoxCollider boxCollider = base.gameObject.AddComponent<BoxCollider>();
		boxCollider.center = new Vector3(0f, -0.0025f, -0.002f);
		boxCollider.size = new Vector3(0.04f, 0.025f, 0.17f);
		boxCollider.isTrigger = true;
	}

	private void Update()
	{
		if (Input.GetKey(KeyCode.RightArrow))
		{
			base.transform.position += Vector3.right * Time.deltaTime;
		}
		if (Pvr.IsMainKeyDown(1) && hoveredObject != null && attachedObject.interactableObject == null)
		{
			AttatchObject(hoveredObject);
		}
		if (Pvr.IsMainKeyUp(1) && attachedObject.interactableObject != null)
		{
			attachedObject.interactableObject = null;
		}
	}

	private void AttatchObject(WaveVR_interactableObject interactObject)
	{
		UnityEngine.Debug.Log("--hand grab:" + interactObject.name);
		attachedObject.interactableObject = interactObject;
		attachedObject.attachedRigidbody = interactObject.attachedRigidbody;
		attachedObject.initialPositionalOffset = base.transform.InverseTransformPoint(interactObject.transform.position);
		attachedObject.initialRotationalOffset = Quaternion.Inverse(base.transform.rotation) * interactObject.transform.rotation;
	}

	private void OnTriggerEnter(Collider other)
	{
		WaveVR_interactableObject componentInParent = other.GetComponentInParent<WaveVR_interactableObject>();
		if (componentInParent != null && !listHoveredObjcets.Contains(componentInParent))
		{
			UnityEngine.Debug.Log("--interactable object enter");
			listHoveredObjcets.Add(componentInParent);
			hoveredObject = componentInParent;
		}
	}

	private void OnTriggerExit(Collider other)
	{
		WaveVR_interactableObject componentInParent = other.GetComponentInParent<WaveVR_interactableObject>();
		if (componentInParent != null)
		{
			UnityEngine.Debug.Log("--interactable object exit");
			if (listHoveredObjcets.Contains(componentInParent))
			{
				listHoveredObjcets.Remove(componentInParent);
			}
			if (hoveredObject == componentInParent)
			{
				hoveredObject = null;
			}
		}
	}

	private void FixedUpdate()
	{
		if (attachedObject.interactableObject != null)
		{
			UpdateAttachedVelocity(attachedObject);
		}
	}

	protected void UpdateAttachedVelocity(AttachedObject attachedObjectInfo)
	{
		if (GetUpdatedAttachedVelocities(attachedObjectInfo, out var velocityTarget, out var angularTarget))
		{
			float num = 1f;
			float maxDistanceDelta = 20f * num;
			float maxDistanceDelta2 = 10f * num;
			attachedObjectInfo.attachedRigidbody.velocity = Vector3.MoveTowards(attachedObjectInfo.attachedRigidbody.velocity, velocityTarget, maxDistanceDelta2);
			attachedObjectInfo.attachedRigidbody.angularVelocity = Vector3.MoveTowards(attachedObjectInfo.attachedRigidbody.angularVelocity, angularTarget, maxDistanceDelta);
		}
	}

	protected bool GetUpdatedAttachedVelocities(AttachedObject attachedObjectInfo, out Vector3 velocityTarget, out Vector3 angularTarget)
	{
		bool flag = false;
		float num = 600f;
		float num2 = 50f;
		Vector3 vector = TargetItemPosition(attachedObjectInfo) - attachedObjectInfo.attachedRigidbody.position;
		velocityTarget = vector * num * Time.deltaTime;
		if (!float.IsNaN(velocityTarget.x) && !float.IsInfinity(velocityTarget.x))
		{
			flag = true;
		}
		else
		{
			velocityTarget = Vector3.zero;
		}
		(TargetItemRotation(attachedObjectInfo) * Quaternion.Inverse(attachedObjectInfo.attachedRigidbody.transform.rotation)).ToAngleAxis(out var angle, out var axis);
		if (angle > 180f)
		{
			angle -= 360f;
		}
		if (angle != 0f && !float.IsNaN(axis.x) && !float.IsInfinity(axis.x))
		{
			angularTarget = angle * axis * num2 * Time.deltaTime;
			flag = flag;
		}
		else
		{
			angularTarget = Vector3.zero;
		}
		return flag;
	}

	protected Vector3 TargetItemPosition(AttachedObject attachedObject)
	{
		return base.transform.TransformPoint(attachedObject.initialPositionalOffset);
	}

	protected Quaternion TargetItemRotation(AttachedObject attachedObject)
	{
		return base.transform.rotation * attachedObject.initialRotationalOffset;
	}
}
public class WaveVR_HandRayGrabber : MonoBehaviour
{
	public float m_maxRayDis = 10f;

	public LayerMask eventMask;

	public GameObject m_picHandS;

	private WaveVR_rayInteractObject _interactableObject;

	public Vector3 initialPositionalOffset;

	private GameObject _hoveringOBJ;

	private RaycastHit hitinfo;

	private bool isKeyDown;

	public WaveVR_rayInteractObject attachedObject
	{
		get
		{
			return _interactableObject;
		}
		set
		{
			if (_interactableObject != value)
			{
				if (_interactableObject != null)
				{
					_interactableObject.SendMessageUpwards("OnHandDettached", this, SendMessageOptions.DontRequireReceiver);
				}
				_interactableObject = value;
				if (_interactableObject != null)
				{
					_interactableObject.SendMessageUpwards("OnHandAttatched", this, SendMessageOptions.DontRequireReceiver);
				}
			}
		}
	}

	public GameObject hoveredObject
	{
		get
		{
			return _hoveringOBJ;
		}
		set
		{
			if (_hoveringOBJ != value)
			{
				if (_hoveringOBJ != null)
				{
					_hoveringOBJ.SendMessageUpwards("OnHandHoverEnd", this, SendMessageOptions.DontRequireReceiver);
				}
				_hoveringOBJ = value;
				if (_hoveringOBJ != null)
				{
					_hoveringOBJ.SendMessageUpwards("OnHandHoverBegin", this, SendMessageOptions.DontRequireReceiver);
				}
			}
		}
	}

	private void Start()
	{
	}

	private void Update()
	{
		if (attachedObject == null)
		{
			Ray xunlianRay = Pvr.GetXunlianRay();
			if (Physics.Linecast(xunlianRay.origin, xunlianRay.origin + xunlianRay.direction * m_maxRayDis, out hitinfo, eventMask))
			{
				hoveredObject = hitinfo.collider.gameObject;
			}
			else
			{
				hoveredObject = null;
			}
		}
		if (!isKeyDown && Pvr.IsMainKeyDown())
		{
			isKeyDown = true;
			if (hoveredObject != null && attachedObject == null)
			{
				hoveredObject.SendMessageUpwards("OnHandPointerDown", this, SendMessageOptions.DontRequireReceiver);
				WaveVR_rayInteractObject componentInParent = hoveredObject.GetComponentInParent<WaveVR_rayInteractObject>();
				if (componentInParent != null && componentInParent.isActiveAndEnabled)
				{
					AttatchObject(componentInParent);
				}
			}
		}
		else if (isKeyDown && Pvr.IsMainKeyUp())
		{
			isKeyDown = false;
			if (attachedObject != null)
			{
				AttatchObject(null);
			}
		}
	}

	private void AttatchObject(WaveVR_rayInteractObject interactObject)
	{
		if (interactObject != null)
		{
			UnityEngine.Debug.Log("--hand grab:" + interactObject.name);
			attachedObject = interactObject;
			initialPositionalOffset = base.transform.InverseTransformPoint(interactObject.transform.position);
		}
		else
		{
			attachedObject = null;
		}
	}

	private void LateUpdate()
	{
		if (attachedObject != null)
		{
			UpdateAttachedObject(attachedObject.gameObject);
		}
	}

	protected void UpdateAttachedObject(GameObject attachedObjectInfo)
	{
		attachedObjectInfo.transform.position = base.transform.TransformPoint(initialPositionalOffset);
	}
}
public interface IHandRayAction
{
	void OnHandHoverBegin(WaveVR_HandRayGrabber hand);

	void OnHandHoverEnd(WaveVR_HandRayGrabber hand);

	void OnHandAttatched(WaveVR_HandRayGrabber hand);

	void OnHandDettached(WaveVR_HandRayGrabber hand);
}
public interface IHandRayPointerDown
{
	void OnHandPointerDown(WaveVR_HandRayGrabber hand);
}
[RequireComponent(typeof(Rigidbody))]
public class WaveVR_interactableObject : MonoBehaviour
{
	[Serializable]
	public class triggerEvent : UnityEvent<Collider>
	{
	}

	[Serializable]
	public class handGrabEvent : UnityEvent
	{
	}

	public triggerEvent m_actionsOnTriggerEnter = new triggerEvent();

	public triggerEvent m_actionsOnTriggerExit = new triggerEvent();

	public handGrabEvent m_actionOnHandGrab = new handGrabEvent();

	public handGrabEvent m_actionOnHandRelease = new handGrabEvent();

	[HideInInspector]
	public Rigidbody attachedRigidbody;

	private void Start()
	{
		attachedRigidbody = GetComponent<Rigidbody>();
	}

	private void Update()
	{
	}

	private void OnTriggerEnter(Collider other)
	{
		if (m_actionsOnTriggerEnter != null)
		{
			m_actionsOnTriggerEnter.Invoke(other);
		}
	}

	private void OnTriggerExit(Collider other)
	{
		if (m_actionsOnTriggerExit != null)
		{
			m_actionsOnTriggerExit.Invoke(other);
		}
	}

	private void OnHandHoverBegin(WaveVR_HandGrabber hand)
	{
	}

	private void OnHandHoverEnd(WaveVR_HandGrabber hand)
	{
	}

	private void OnHandAttatched(WaveVR_HandGrabber hand)
	{
		m_actionOnHandGrab.Invoke();
	}

	private void OnHandDettached(WaveVR_HandGrabber hand)
	{
		m_actionOnHandRelease.Invoke();
	}
}
[RequireComponent(typeof(J_InteractableOutline))]
public class WaveVR_rayInteractObject : MonoBehaviour, IHandRayAction
{
	[Serializable]
	public class triggerEvent : UnityEvent
	{
	}

	[Serializable]
	public class handGrabEvent : UnityEvent
	{
	}

	public triggerEvent m_actionsOnHandHover = new triggerEvent();

	public triggerEvent m_actionsHandHoverEnd = new triggerEvent();

	public handGrabEvent m_actionOnHandGrab = new handGrabEvent();

	public handGrabEvent m_actionOnHandRelease = new handGrabEvent();

	private Rigidbody _rigidbody;

	private void Start()
	{
		_rigidbody = GetComponent<Rigidbody>();
	}

	public void OnHandHoverBegin(WaveVR_HandRayGrabber hand)
	{
		if (m_actionsOnHandHover != null)
		{
			m_actionsOnHandHover.Invoke();
		}
	}

	public void OnHandHoverEnd(WaveVR_HandRayGrabber hand)
	{
		if (m_actionsHandHoverEnd != null)
		{
			m_actionsHandHoverEnd.Invoke();
		}
	}

	public void OnHandAttatched(WaveVR_HandRayGrabber hand)
	{
		if (_rigidbody != null)
		{
			_rigidbody.isKinematic = true;
		}
		if (m_actionOnHandGrab != null)
		{
			m_actionOnHandGrab.Invoke();
		}
	}

	public void OnHandDettached(WaveVR_HandRayGrabber hand)
	{
		if (_rigidbody != null)
		{
			_rigidbody.isKinematic = false;
		}
		if (m_actionOnHandRelease != null)
		{
			m_actionOnHandRelease.Invoke();
		}
	}
}
public class WaveVR_AddEventSystemGUI : MonoBehaviour
{
	private bool added;

	private void OnEnable()
	{
		_ = GetComponent<Canvas>() != null;
	}

	private void OnDisable()
	{
	}
}
public class PathNode : MonoBehaviour
{
	public List<PathNode> Nodes = new List<PathNode>();

	public static List<PathNode> AllNodes = new List<PathNode>();

	public static List<PathNode> CarNodes = new List<PathNode>();

	private void Awake()
	{
		if (base.transform.parent.name == "汽车路径")
		{
			CarNodes.Add(this);
		}
		else
		{
			AllNodes.Add(this);
		}
	}

	public Vector3 Pos()
	{
		return base.transform.position + new Vector3(UnityEngine.Random.Range(-0.1f, 0.1f), 0f, UnityEngine.Random.Range(-0.1f, 0.1f));
	}
}
public class FallToGround : MonoBehaviour
{
	public GameObject target;

	private Vector3 vprePos;

	private RaycastHit hitinfo;

	private Vector3 vCCpos;

	private bool triFall;

	private void Start()
	{
	}

	private void FixedUpdate()
	{
		if (triFall && vprePos != base.transform.position)
		{
			vprePos = base.transform.position;
			if (Physics.Linecast(target.transform.position + Vector3.up * 3f, target.transform.position - Vector3.up * 6f, out hitinfo))
			{
				vCCpos = target.transform.position;
				vCCpos.y = hitinfo.point.y;
				target.transform.position = vCCpos;
			}
		}
	}

	private void OnBecameVisible()
	{
		triFall = true;
	}

	private void OnBecameInvisible()
	{
		triFall = false;
	}
}
public class People_RandomAnim : MonoBehaviour
{
	[Serializable]
	public class animParam
	{
		public string triggerName;

		[Range(0f, 100f)]
		[Tooltip("数值越高，命中率越大")]
		public float weight;

		[HideInInspector]
		public Vector2 vWRange;
	}

	public Animator m_animCtr;

	public Vector2 timeRange = new Vector2(4f, 15f);

	public List<animParam> listRandomParms;

	private void Start()
	{
		StartCoroutine(yieldRandomAnim());
	}

	private IEnumerator yieldRandomAnim()
	{
		float fTotalWeight = 0f;
		for (int i = 0; i < listRandomParms.Count; i++)
		{
			animParam animParam = listRandomParms[i];
			float x = fTotalWeight;
			float y;
			fTotalWeight = (y = fTotalWeight + listRandomParms[i].weight);
			animParam.vWRange = new Vector2(x, y);
		}
		if (fTotalWeight > 0f)
		{
			while (true)
			{
				float num = UnityEngine.Random.Range(timeRange.x, timeRange.y);
				if (num < 0f)
				{
					num = 1f;
				}
				yield return new WaitForSeconds(num);
				float num2 = UnityEngine.Random.Range(0f, fTotalWeight);
				for (int j = 0; j < listRandomParms.Count; j++)
				{
					animParam animParam2 = listRandomParms[j];
					if (animParam2.vWRange.x < num2 && num2 < animParam2.vWRange.y)
					{
						m_animCtr.SetTrigger(animParam2.triggerName);
						break;
					}
				}
			}
		}
		UnityEngine.Debug.LogError("time不可以<0");
	}

	private void OnAnimatorIK(int layerIndex)
	{
		if (WaveVRHead.Inst != null)
		{
			Vector3 position = WaveVRHead.Inst.headCam.position;
			Vector3 vector = position;
			vector.y = base.transform.position.y;
			Vector3 to = vector - base.transform.position;
			if (Vector3.Distance(position, base.transform.position) < 3f && Vector3.Angle(base.transform.forward, to) < 60f)
			{
				m_animCtr.SetLookAtWeight(1f, 0.05f, 1f, 0f, 0f);
				m_animCtr.SetLookAtPosition(position);
			}
		}
	}
}
public class SetCorrectCameraHeight : MonoBehaviour
{
	private enum TrackingSpace
	{
		Stationary,
		RoomScale
	}

	[Header("Camera Settings")]
	[SerializeField]
	[Tooltip("Decide if experience is Room Scale or Stationary. Note this option does nothing for mobile VR experiences, these experience will default to Stationary")]
	private TrackingSpace m_TrackingSpace;

	[SerializeField]
	[Tooltip("Camera Height - overwritten by device settings when using Room Scale ")]
	private float m_StationaryCameraYOffset = 1.36144f;

	[SerializeField]
	[Tooltip("GameObject to move to desired height off the floor (defaults to this object if none provided)")]
	private GameObject m_CameraFloorOffsetObject;

	private void Awake()
	{
		if (!m_CameraFloorOffsetObject)
		{
			UnityEngine.Debug.LogWarning("No camera container specified for VR Rig, using attached GameObject");
			m_CameraFloorOffsetObject = base.gameObject;
		}
	}

	private void Start()
	{
		SetCameraHeight();
	}

	private void SetCameraHeight()
	{
		float y = m_StationaryCameraYOffset;
		if (m_TrackingSpace == TrackingSpace.Stationary)
		{
			XRDevice.SetTrackingSpaceType(TrackingSpaceType.Stationary);
			InputTracking.Recenter();
		}
		else if (m_TrackingSpace == TrackingSpace.RoomScale && XRDevice.SetTrackingSpaceType(TrackingSpaceType.RoomScale))
		{
			y = 0f;
		}
		if ((bool)m_CameraFloorOffsetObject)
		{
			m_CameraFloorOffsetObject.transform.localPosition = new Vector3(m_CameraFloorOffsetObject.transform.localPosition.x, y, m_CameraFloorOffsetObject.transform.localPosition.z);
		}
	}
}
public class SimpleTalk : MonoBehaviour
{
	public SkinnedMeshRenderer mouth;

	private float frTime;

	private float fblendValue;

	private float ftargetValue;

	private void Update()
	{
		if ((frTime -= Time.deltaTime) < 0f)
		{
			frTime = UnityEngine.Random.Range(0.1f, 1f);
			ftargetValue = frTime * 100f;
		}
		fblendValue = Mathf.Lerp(fblendValue, ftargetValue, Time.deltaTime * 10f);
		mouth.SetBlendShapeWeight(0, fblendValue);
	}
}
public class Readme : ScriptableObject
{
	[Serializable]
	public class Section
	{
		public string heading;

		public string text;

		public string linkText;

		public string url;
	}

	public Texture2D icon;

	public string title;

	public Section[] sections;

	public bool loadedLayout;
}
public class YaoDianPatientAnimCtrl : MonoBehaviour
{
	public UnityEvent m_eventOnAction;

	public void PlayAction()
	{
		m_eventOnAction.Invoke();
	}
}
public class Wenlu : MonoBehaviour
{
	private class qingjing
	{
		public Dictionary<string, string> Par = new Dictionary<string, string>();

		public List<juzi> juzi = new List<juzi>();
	}

	private class juzi
	{
		public string id;

		public string Ask;

		public List<hd> Ansers = new List<hd>();

		public bool isPar;

		public string ParKey;

		public string TitleParKey = "";
	}

	private class hd
	{
		public List<string> huida = new List<string>();

		public string jump;

		public bool isPar;
	}

	private TrainControl_Communication.M_communicationScene data;

	public AudioSource m_audio_AIspeak;

	public Text txt;

	public GameObject endPanel;

	public GameObject Panel;

	public Animator ani;

	public int type;

	public Button dianhuaStartBut;

	public AudioSource dianhua;

	private qingjing qing;

	private juzi cur;

	private Dictionary<string, string> Par = new Dictionary<string, string>();

	private static string WL1 = "\r\nA001\tA-警察\t您好，我是一名人民警察。如果您和您的亲人朋友走失了，我会帮助您。只要您跟我说，是，好，需要。\t\t\r\n\r\n是，需要，对，好\t\t\t;\t\tA002\t\r\n\t\t不;\t\tA999\t\r\n\t\t\t\t\t\t\t\t\r\nA002\tA-警察\t请问您是本地人吗？如果您是本地人，请您说：是，对；如果您不是，请您说：不，不是。\t\t\t\t\t\t\t是，对\t;\t\tA003\t\r\n\t\t不，不是;\t\tA003\t\r\n\t\t\t\t\t\t\t\t\r\nA003\tA-警察\t请问您这次是一个人出行吗？(如果是，请您说：是，对；如果不是，请您说：不，不是)\r\n\r\n是，对\t;\t\tA004\t\r\n\t\t不，不是;\t\tA004\t\r\n\t\t\t\t\t\t\t\t\r\nA004\tA-警察\t请说出您的亲人或朋友的名字\t\t\t\t\t\t\r\n\t\t回答{亲人名字}\t\t\t;识别记录用户的内容，之后会用以复述；跳转至对话A005\t\t\t\r\n\t\t\t\t\t\t\t\t\r\nA005\tA-警察\t我跟您确认下，您的亲人或朋友的名字叫{亲人名字}，对吗？(如果正确的话，请您说：是，对，正确；如果不正确，请您说：不，不对，不是，错。)\r\n\t\t\t\t\t\t\r\n\t\t是，对，正确\t\t\t;\t\tA006\t\r\n\t\t不，不对，不是，错\t\t\t;\t\tA004\t\r\n\t\t\t\t\t\t\t\t\r\nA006\tA-警察\t请说出您的亲人或朋友的电话号码\t\t\t\t\t\t\r\n\t\t回答{电话}\t\t\t;识别记录用户的内容里的数字并把它们连起来，之后会用以复述；跳转至对话A007\t\t\t\r\n\t\t\t\t\t\t\t\t\r\nA007\tA-警察\t我跟您确认下，您亲人或朋友的电话号码是{电话}，对吗？(如果正确的话，请您说：是，对，正确；如果不正确，请您说：不，不对，不是，错。)\t\t\t\t\t\t\r\n\r\n\t\t是，对，正确\t\t\t;\t\tA008\t\r\n\t\t不，不对，不是，错\t\t\t;\t\tA006\t\r\n\t\t\t\t\t\t\t\t\r\nA008\tA-警察\t您还记得您的家庭地址吗？如果记得请说出具体地址，如果忘了，请告诉我：不，记不住，忘了。\r\n\r\n\t\t回答{地址}\t\t\t;识别记录用户说的内容，之后会复述；跳转至对话A009\t\t\t\r\n\t\t不，记不住，忘了\t\t\t;\t\tA888\t\r\n\t\t\t\t\t\t\t\t\r\nA009\tA-警察\t我跟您确认下，您的家庭住址是{地址}，对吗？(如果正确的话，请您说：是，对，正确；如果不正确，请您说：不，不对，不是，错。)\t\r\n\r\n\t\t是，对，正确\t\t\t;\t\tA888\t\r\n\t\t不，不对，不是，错\t\t\t;\t\tA008\t\r\n\t\t\t\t\t\t\t\t\r\nA888\tA-警察\t好的，感谢您提供的信息，我会尽快联系您的亲人或朋友。现在，我先离开了。\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\r\nA999\tA-警察\t好的，如果您走失了，需要帮助请记得找我。\t\t\t\t\t\t\r\n";

	private static string WL2 = "\r\nB001\tA-电话\t您好，感谢您的接听，我是一名电话安全检查员。我的工作需要您帮忙回答几个简单的问题。你能不能帮帮我？\r\n\t\t是，能，好，可以，没问题\t\t\t;\t\tB002\r\n\t\t\t不，拒绝，没空\t\t\t;\t\tB999\r\n\t\t\t\t\t\t\t\t\r\nB002\tA-电话\t请问您那边现在是什么时间？\t\t\t\t\t\r\n\t\t回答{时间}\t\t\t;识别记录用户的内容，之后会用以复述；跳转至对话B003\t\t\r\n\t\t\t\t\t\t\t\t\r\nB003\tA-电话\t我跟您确认下，您那边现在时间是{时间}，对吗？如果正确的话，请您说：是，对，正确；如果不正确，请您说：不，不对，不是，错。\t\t\t\t\t\r\n\t\t是，对，正确\t\t\t;\t\tB004\r\n\t\t\t不，不对，不是，错\t\t\t;\t\tB002\r\n\t\t\t\t\t\t\t\t\r\nB004\tA-电话\t请您告诉我，您现在接听的电话是什么颜色的？\t\t\t\t\t\r\n\t\t回答{颜色}\t\t\t;识别记录用户的内容中的颜色，之后会用以复述；跳转至对话B005\t\t\r\n\t\t\t\t\t\t\t\t\r\nB005\tA-电话\t我跟您确认下，您说现在接听的电话是{颜色}的，对吗？(如果正确的话，请您说：是，对，正确；如果不正确，请您说：不，不对，不是，错。)\t\t\t\t\t\r\n\t\t是，对，正确\t\t\t;\t\tB006\r\n\t\t\t不，不对，不是，错\t\t\t;\t\tB004\r\n\t\t\t\t\t\t\t\t\r\nB006\tA-电话\t请问您现在所在的位置周边都有什么店铺？如果没有，请您说：没有。\t\t\t\t\t\r\n\t\t回答{内容}\t\t\t;B007\t\r\n        没;B888\r\n\t\t\t\t\t\t\t\t\r\nB007\tA-电话\t我跟您确认下，您说您周边有{内容}，对吗？(如果正确的话，请您说：是，对，正确；如果不正确，请您说：不，不对，不是，错。)\t\t\t\t\r\n\t\t是，对，正确\t\t\t;\t\tB888\r\n\t\t\t不，不对，不是，错\t\t\t;\t\tB006\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\r\nB888\tA-电话\t您回答的内容让我工作进展得很顺利，谢谢您！再次感谢您的配合，再见！\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\r\nB999\tA-电话\t好的，抱歉向您提出了无理的要求，再见！\t\t\t\t\t\r\n\r\n";

	private void Start()
	{
		qing = GetQingjing((type == 0) ? WL1 : WL2);
		UnityEngine.Debug.Log(qing.Json());
		endPanel.SetActive(value: false);
		if (type == 0)
		{
			say(qing.juzi.FirstOrDefault());
		}
		else
		{
			DianhuaSt();
		}
	}

	public void DianhuaSt()
	{
		Panel.SetActive(value: false);
		dianhua.loop = true;
		dianhua.Play();
		dianhuaStartBut.gameObject.SetActive(value: true);
	}

	public void DianhuaSt2()
	{
		dianhuaStartBut.gameObject.SetActive(value: false);
		dianhua.Stop();
		txt.text = "训练开始";
		Panel.SetActive(value: true);
		say(qing.juzi.FirstOrDefault());
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.A))
		{
			J_VoiceRecCtrl.Inst.actionOnVoiceResultRec?.Invoke(new DataRequestResult_voiceData
			{
				file_txt = "是"
			});
		}
		if (Input.GetKeyDown(KeyCode.B))
		{
			J_VoiceRecCtrl.Inst.actionOnVoiceResultRec?.Invoke(new DataRequestResult_voiceData
			{
				file_txt = "记不住"
			});
		}
	}

	private void say(juzi a)
	{
		cur = a;
		this.Wait(2f, delegate
		{
			txt.text = a.Ask;
			if (a.TitleParKey != "")
			{
				txt.text = a.Ask.Replace("{" + a.TitleParKey + "}", Par[a.TitleParKey]);
			}
			string voiceTxt = new Regex("\\([\\w\\W]+\\)").Replace(txt.text, "");
			baidu_WordToVoiceUtility.J_GetWordAudio(voiceTxt, delegate(AudioClip audioclip)
			{
				m_audio_AIspeak.clip = audioclip;
				m_audio_AIspeak.Play();
				ani.CrossFade("talking", 0.1f);
				this.Wait((float)voiceTxt.Length * 0.24f, delegate
				{
					ani.CrossFade("Idle", 0.1f);
					if (a.Ansers.Count < 1)
					{
						txt.text = "训练结束";
						endPanel.SetActive(value: true);
					}
					else
					{
						J_VoiceRecCtrl.Inst.StartRec();
						J_VoiceRecCtrl.Inst.J_SetWordsRecResultReceiver(delegate(DataRequestResult_voiceData recWords)
						{
							hd hd = a.Ansers.LastOrDefault((hd ca) => IsMatch(recWords.file_txt, ca.huida));
							if (string.IsNullOrEmpty(recWords.file_txt) || recWords.file_txt.Replace("。", "").Trim().Length < 1 || (!a.isPar && hd == null))
							{
								baidu_WordToVoiceUtility.J_GetWordAudio("不好意思,没有听清楚,请再说一遍!", delegate(AudioClip audioclip2)
								{
									m_audio_AIspeak.clip = audioclip2;
									m_audio_AIspeak.Play();
									J_VoiceRecCtrl.Inst.m_txtRecResult.text = "";
								}, (type == 0) ? 1 : 0);
							}
							else
							{
								J_VoiceRecCtrl.Inst.StopRec(hideResult: true);
								if (hd != null)
								{
									say(qing.juzi.FirstOrDefault((juzi ca) => ca.id == hd.jump));
								}
								else if (a.isPar)
								{
									Par[a.ParKey] = recWords.file_txt;
									string[] array = "1,2,3,4,5,6,7,8,9,0,1".Split(',');
									string[] array2 = "一,二,三,四,五,六,七,八,九,零,幺".Split(',');
									for (int i = 0; i < array2.Length; i++)
									{
										Par[a.ParKey] = Par[a.ParKey].Replace(array2[i], array[i]);
									}
									say(qing.juzi.FirstOrDefault((juzi ca) => ca.id == a.Ansers.FirstOrDefault().jump));
								}
							}
						});
					}
				});
			}, (type == 0) ? 1 : 0);
		});
	}

	private bool IsMatch(string say, List<string> ass)
	{
		return ass.Any((string ca) => say.Contains(ca));
	}

	public void Rstart()
	{
		endPanel.SetActive(value: false);
		if (type == 0)
		{
			say(qing.juzi.FirstOrDefault());
		}
		else
		{
			DianhuaSt();
		}
	}

	private qingjing GetQingjing(string txt)
	{
		string[] array = txt.Split(Environment.NewLine.ToCharArray(), StringSplitOptions.RemoveEmptyEntries);
		juzi juzi = null;
		qingjing qingjing = new qingjing();
		Regex regex = new Regex("^([AB0-9]+)");
		Regex regex2 = new Regex("([AB0-9]+)");
		Regex regex3 = new Regex("\\{(.+)\\}");
		string[] array2 = array;
		foreach (string text in array2)
		{
			if (string.IsNullOrEmpty(text) || (text.Contains("关键字") && text.Contains("事件")))
			{
				continue;
			}
			Match match = regex.Match(text);
			Match match2 = regex2.Match(text);
			Match match3 = regex3.Match(text);
			if (match.Success)
			{
				juzi = new juzi();
				juzi.id = match.Groups[1].Value;
				juzi.Ask = text.Split('\t')[2];
				if (match3.Success && qingjing.Par.ContainsKey(match3.Groups[1].Value))
				{
					juzi.TitleParKey = match3.Groups[1].Value;
					qingjing.Par[match3.Groups[1].Value] = juzi.id;
				}
				qingjing.juzi.Add(juzi);
			}
			else if (match2.Success)
			{
				string[] array3 = text.Split(';');
				hd hd = new hd();
				hd.huida = (from ca in array3[0].Trim().Split('，')
					select ca.Trim()).ToList();
				hd.jump = match2.Groups[1].Value;
				hd hd2 = hd;
				if (match3.Success)
				{
					juzi.ParKey = match3.Groups[1].Value;
					qingjing.Par[juzi.ParKey] = "";
					juzi.isPar = true;
					hd2.isPar = true;
				}
				juzi.Ansers.Add(hd2);
			}
		}
		return qingjing;
	}
}
[RequireComponent(typeof(ParticleSystem))]
public class CFX_AutoStopLoopedEffect : MonoBehaviour
{
	public float effectDuration = 2.5f;

	private float d;

	private void OnEnable()
	{
		d = effectDuration;
	}

	private void Update()
	{
		if (!(d > 0f))
		{
			return;
		}
		d -= Time.deltaTime;
		if (d <= 0f)
		{
			GetComponent<ParticleSystem>().Stop(withChildren: true);
			CFX_Demo_Translate component = base.gameObject.GetComponent<CFX_Demo_Translate>();
			if (component != null)
			{
				component.enabled = false;
			}
		}
	}
}
public class CFX_Demo : MonoBehaviour
{
	public bool orderedSpawns = true;

	public float step = 1f;

	public float range = 5f;

	private float order = -5f;

	public Material groundMat;

	public Material waterMat;

	public GameObject[] ParticleExamples;

	private Dictionary<string, float> ParticlesYOffsetD = new Dictionary<string, float>
	{
		{ "CFX_ElectricGround", 0.15f },
		{ "CFX_ElectricityBall", 1f },
		{ "CFX_ElectricityBolt", 1f },
		{ "CFX_Explosion", 2f },
		{ "CFX_SmallExplosion", 1.5f },
		{ "CFX_SmokeExplosion", 2.5f },
		{ "CFX_Flame", 1f },
		{ "CFX_DoubleFlame", 1f },
		{ "CFX_Hit", 1f },
		{ "CFX_CircularLightWall", 0.05f },
		{ "CFX_LightWall", 0.05f },
		{ "CFX_Flash", 2f },
		{ "CFX_Poof", 1.5f },
		{ "CFX_Virus", 1f },
		{ "CFX_SmokePuffs", 2f },
		{ "CFX_Slash", 1f },
		{ "CFX_Splash", 0.05f },
		{ "CFX_Fountain", 0.05f },
		{ "CFX_Ripple", 0.05f },
		{ "CFX_Magic", 2f },
		{ "CFX_SoftStar", 1f },
		{ "CFX_SpikyAura_Sphere", 1f },
		{ "CFX_Firework", 2.4f },
		{ "CFX_GroundA", 0.05f }
	};

	private int exampleIndex;

	private string randomSpawnsDelay = "0.5";

	private bool randomSpawns;

	private bool slowMo;

	private void OnMouseDown()
	{
		RaycastHit hitInfo = default(RaycastHit);
		if (GetComponent<Collider>().Raycast(Camera.main.ScreenPointToRay(Input.mousePosition), out hitInfo, 9999f))
		{
			GameObject gameObject = spawnParticle();
			gameObject.transform.position = hitInfo.point + gameObject.transform.position;
		}
	}

	private GameObject spawnParticle()
	{
		GameObject gameObject = UnityEngine.Object.Instantiate(ParticleExamples[exampleIndex]);
		gameObject.SetActive(value: true);
		for (int i = 0; i < gameObject.transform.childCount; i++)
		{
			gameObject.transform.GetChild(i).gameObject.SetActive(value: true);
		}
		float y = 0f;
		foreach (KeyValuePair<string, float> item in ParticlesYOffsetD)
		{
			if (gameObject.name.StartsWith(item.Key))
			{
				y = item.Value;
				break;
			}
		}
		gameObject.transform.position = new Vector3(0f, y, 0f);
		return gameObject;
	}

	private void OnGUI()
	{
		GUILayout.BeginArea(new Rect(5f, 20f, Screen.width - 10, 30f));
		GUILayout.BeginHorizontal();
		GUILayout.Label("Effect", GUILayout.Width(50f));
		if (GUILayout.Button("<", GUILayout.Width(20f)))
		{
			prevParticle();
		}
		GUILayout.Label(ParticleExamples[exampleIndex].name, GUILayout.Width(190f));
		if (GUILayout.Button(">", GUILayout.Width(20f)))
		{
			nextParticle();
		}
		GUILayout.Label("Click on the ground to spawn selected particles");
		if (GUILayout.Button(CFX_Demo_RotateCamera.rotating ? "Pause Camera" : "Rotate Camera", GUILayout.Width(140f)))
		{
			CFX_Demo_RotateCamera.rotating = !CFX_Demo_RotateCamera.rotating;
		}
		if (GUILayout.Button(randomSpawns ? "Stop Random Spawns" : "Start Random Spawns", GUILayout.Width(140f)))
		{
			randomSpawns = !randomSpawns;
			if (randomSpawns)
			{
				StartCoroutine("RandomSpawnsCoroutine");
			}
			else
			{
				StopCoroutine("RandomSpawnsCoroutine");
			}
		}
		randomSpawnsDelay = GUILayout.TextField(randomSpawnsDelay, 10, GUILayout.Width(42f));
		randomSpawnsDelay = Regex.Replace(randomSpawnsDelay, "[^0-9.]", "");
		if (GUILayout.Button(GetComponent<Renderer>().enabled ? "Hide Ground" : "Show Ground", GUILayout.Width(90f)))
		{
			GetComponent<Renderer>().enabled = !GetComponent<Renderer>().enabled;
		}
		if (GUILayout.Button(slowMo ? "Normal Speed" : "Slow Motion", GUILayout.Width(100f)))
		{
			slowMo = !slowMo;
			if (slowMo)
			{
				Time.timeScale = 0.33f;
			}
			else
			{
				Time.timeScale = 1f;
			}
		}
		GUILayout.EndHorizontal();
		GUILayout.EndArea();
	}

	private IEnumerator RandomSpawnsCoroutine()
	{
		while (true)
		{
			GameObject gameObject = spawnParticle();
			if (orderedSpawns)
			{
				gameObject.transform.position = base.transform.position + new Vector3(order, gameObject.transform.position.y, 0f);
				order -= step;
				if (order < 0f - range)
				{
					order = range;
				}
			}
			else
			{
				gameObject.transform.position = base.transform.position + new Vector3(UnityEngine.Random.Range(0f - range, range), 0f, UnityEngine.Random.Range(0f - range, range)) + new Vector3(0f, gameObject.transform.position.y, 0f);
			}
			yield return new WaitForSeconds(float.Parse(randomSpawnsDelay));
		}
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.LeftArrow))
		{
			prevParticle();
		}
		else if (Input.GetKeyDown(KeyCode.RightArrow))
		{
			nextParticle();
		}
	}

	private void prevParticle()
	{
		exampleIndex--;
		if (exampleIndex < 0)
		{
			exampleIndex = ParticleExamples.Length - 1;
		}
		if (ParticleExamples[exampleIndex].name.Contains("Splash") || ParticleExamples[exampleIndex].name == "CFX_Ripple" || ParticleExamples[exampleIndex].name == "CFX_Fountain")
		{
			GetComponent<Renderer>().material = waterMat;
		}
		else
		{
			GetComponent<Renderer>().material = groundMat;
		}
	}

	private void nextParticle()
	{
		exampleIndex++;
		if (exampleIndex >= ParticleExamples.Length)
		{
			exampleIndex = 0;
		}
		if (ParticleExamples[exampleIndex].name.Contains("Splash") || ParticleExamples[exampleIndex].name == "CFX_Ripple" || ParticleExamples[exampleIndex].name == "CFX_Fountain")
		{
			GetComponent<Renderer>().material = waterMat;
		}
		else
		{
			GetComponent<Renderer>().material = groundMat;
		}
	}
}
public class CFX_Demo_New : MonoBehaviour
{
	public Renderer groundRenderer;

	public Collider groundCollider;

	[Space]
	[Space]
	public Image slowMoBtn;

	public Text slowMoLabel;

	public Image camRotBtn;

	public Text camRotLabel;

	public Image groundBtn;

	public Text groundLabel;

	[Space]
	public Text EffectLabel;

	public Text EffectIndexLabel;

	private GameObject[] ParticleExamples;

	private int exampleIndex;

	private bool slowMo;

	private Vector3 defaultCamPosition;

	private Quaternion defaultCamRotation;

	private List<GameObject> onScreenParticles = new List<GameObject>();

	private void Awake()
	{
		List<GameObject> list = new List<GameObject>();
		int childCount = base.transform.childCount;
		for (int i = 0; i < childCount; i++)
		{
			GameObject item = base.transform.GetChild(i).gameObject;
			list.Add(item);
		}
		list.Sort((GameObject o1, GameObject o2) => o1.name.CompareTo(o2.name));
		ParticleExamples = list.ToArray();
		defaultCamPosition = Camera.main.transform.position;
		defaultCamRotation = Camera.main.transform.rotation;
		StartCoroutine("CheckForDeletedParticles");
		UpdateUI();
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.LeftArrow))
		{
			prevParticle();
		}
		else if (Input.GetKeyDown(KeyCode.RightArrow))
		{
			nextParticle();
		}
		else if (Input.GetKeyDown(KeyCode.Delete))
		{
			destroyParticles();
		}
		if (Input.GetMouseButtonDown(0))
		{
			RaycastHit hitInfo = default(RaycastHit);
			if (groundCollider.Raycast(Camera.main.ScreenPointToRay(Input.mousePosition), out hitInfo, 9999f))
			{
				GameObject gameObject = spawnParticle();
				gameObject.transform.position = hitInfo.point + gameObject.transform.position;
			}
		}
		float axis = Input.GetAxis("Mouse ScrollWheel");
		if (axis != 0f)
		{
			Camera.main.transform.Translate(Vector3.forward * ((axis < 0f) ? (-1f) : 1f), Space.Self);
		}
		if (Input.GetMouseButtonDown(2))
		{
			Camera.main.transform.position = defaultCamPosition;
			Camera.main.transform.rotation = defaultCamRotation;
		}
	}

	public void OnToggleGround()
	{
		Color white = Color.white;
		groundRenderer.enabled = !groundRenderer.enabled;
		white.a = (groundRenderer.enabled ? 1f : 0.33f);
		groundBtn.color = white;
		groundLabel.color = white;
	}

	public void OnToggleCamera()
	{
		Color white = Color.white;
		CFX_Demo_RotateCamera.rotating = !CFX_Demo_RotateCamera.rotating;
		white.a = (CFX_Demo_RotateCamera.rotating ? 1f : 0.33f);
		camRotBtn.color = white;
		camRotLabel.color = white;
	}

	public void OnToggleSlowMo()
	{
		Color white = Color.white;
		slowMo = !slowMo;
		if (slowMo)
		{
			Time.timeScale = 0.33f;
			white.a = 1f;
		}
		else
		{
			Time.timeScale = 1f;
			white.a = 0.33f;
		}
		slowMoBtn.color = white;
		slowMoLabel.color = white;
	}

	public void OnPreviousEffect()
	{
		prevParticle();
	}

	public void OnNextEffect()
	{
		nextParticle();
	}

	private void UpdateUI()
	{
		EffectLabel.text = ParticleExamples[exampleIndex].name;
		EffectIndexLabel.text = string.Format("{0}/{1}", (exampleIndex + 1).ToString("00"), ParticleExamples.Length.ToString("00"));
	}

	private GameObject spawnParticle()
	{
		GameObject gameObject = UnityEngine.Object.Instantiate(ParticleExamples[exampleIndex]);
		gameObject.transform.position = new Vector3(0f, gameObject.transform.position.y, 0f);
		gameObject.SetActive(value: true);
		ParticleSystem component = gameObject.GetComponent<ParticleSystem>();
		if (component != null && component.main.loop)
		{
			component.gameObject.AddComponent<CFX_AutoStopLoopedEffect>();
			component.gameObject.AddComponent<CFX_AutoDestructShuriken>();
		}
		onScreenParticles.Add(gameObject);
		return gameObject;
	}

	private IEnumerator CheckForDeletedParticles()
	{
		while (true)
		{
			yield return new WaitForSeconds(5f);
			for (int num = onScreenParticles.Count - 1; num >= 0; num--)
			{
				if (onScreenParticles[num] == null)
				{
					onScreenParticles.RemoveAt(num);
				}
			}
		}
	}

	private void prevParticle()
	{
		exampleIndex--;
		if (exampleIndex < 0)
		{
			exampleIndex = ParticleExamples.Length - 1;
		}
		UpdateUI();
	}

	private void nextParticle()
	{
		exampleIndex++;
		if (exampleIndex >= ParticleExamples.Length)
		{
			exampleIndex = 0;
		}
		UpdateUI();
	}

	private void destroyParticles()
	{
		for (int num = onScreenParticles.Count - 1; num >= 0; num--)
		{
			if (onScreenParticles[num] != null)
			{
				UnityEngine.Object.Destroy(onScreenParticles[num]);
			}
			onScreenParticles.RemoveAt(num);
		}
	}
}
public class CFX_Demo_RandomDir : MonoBehaviour
{
	public Vector3 min = new Vector3(0f, 0f, 0f);

	public Vector3 max = new Vector3(0f, 360f, 0f);

	private void Start()
	{
		base.transform.eulerAngles = new Vector3(UnityEngine.Random.Range(min.x, max.x), UnityEngine.Random.Range(min.y, max.y), UnityEngine.Random.Range(min.z, max.z));
	}
}
public class CFX_Demo_RandomDirectionTranslate : MonoBehaviour
{
	public float speed = 30f;

	public Vector3 baseDir = Vector3.zero;

	public Vector3 axis = Vector3.forward;

	public bool gravity;

	private Vector3 dir;

	private void Start()
	{
		dir = new Vector3(UnityEngine.Random.Range(0f, 360f), UnityEngine.Random.Range(0f, 360f), UnityEngine.Random.Range(0f, 360f)).normalized;
		dir.Scale(axis);
		dir += baseDir;
	}

	private void Update()
	{
		base.transform.Translate(dir * speed * Time.deltaTime);
		if (gravity)
		{
			base.transform.Translate(Physics.gravity * Time.deltaTime);
		}
	}
}
public class CFX_Demo_RotateCamera : MonoBehaviour
{
	public static bool rotating = true;

	public float speed = 30f;

	public Transform rotationCenter;

	private void Update()
	{
		if (rotating)
		{
			base.transform.RotateAround(rotationCenter.position, Vector3.up, speed * Time.deltaTime);
		}
	}
}
public class CFX_Demo_Translate : MonoBehaviour
{
	public float speed = 30f;

	public Vector3 rotation = Vector3.forward;

	public Vector3 axis = Vector3.forward;

	public bool gravity;

	private Vector3 dir;

	private void Start()
	{
		dir = new Vector3(UnityEngine.Random.Range(0f, 360f), UnityEngine.Random.Range(0f, 360f), UnityEngine.Random.Range(0f, 360f));
		dir.Scale(rotation);
		base.transform.localEulerAngles = dir;
	}

	private void Update()
	{
		base.transform.Translate(axis * speed * Time.deltaTime, Space.Self);
	}
}
[RequireComponent(typeof(ParticleSystem))]
public class CFX_AutoDestructShuriken : MonoBehaviour
{
	public bool OnlyDeactivate;

	private void OnEnable()
	{
		StartCoroutine("CheckIfAlive");
	}

	private IEnumerator CheckIfAlive()
	{
		ParticleSystem ps = GetComponent<ParticleSystem>();
		while (ps != null)
		{
			yield return new WaitForSeconds(0.5f);
			if (!ps.IsAlive(withChildren: true))
			{
				if (OnlyDeactivate)
				{
					base.gameObject.SetActive(value: false);
				}
				else
				{
					UnityEngine.Object.Destroy(base.gameObject);
				}
				break;
			}
		}
	}
}
public class CFX_AutodestructWhenNoChildren : MonoBehaviour
{
	private void Update()
	{
		if (base.transform.childCount == 0)
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}
}
public class CFX_AutoRotate : MonoBehaviour
{
	public Vector3 rotation;

	public Space space = Space.Self;

	private void Update()
	{
		base.transform.Rotate(rotation * Time.deltaTime, space);
	}
}
public class CFX_InspectorHelp : MonoBehaviour
{
	public bool Locked;

	public string Title;

	public string HelpText;

	public int MsgType;

	[ContextMenu("Unlock editing")]
	private void Unlock()
	{
		Locked = false;
	}
}
[RequireComponent(typeof(Light))]
public class CFX_LightIntensityFade : MonoBehaviour
{
	public float duration = 1f;

	public float delay;

	public float finalIntensity;

	private float baseIntensity;

	public bool autodestruct;

	private float p_lifetime;

	private float p_delay;

	private void Start()
	{
		baseIntensity = GetComponent<Light>().intensity;
	}

	private void OnEnable()
	{
		p_lifetime = 0f;
		p_delay = delay;
		if (delay > 0f)
		{
			GetComponent<Light>().enabled = false;
		}
	}

	private void Update()
	{
		if (p_delay > 0f)
		{
			p_delay -= Time.deltaTime;
			if (p_delay <= 0f)
			{
				GetComponent<Light>().enabled = true;
			}
		}
		else if (p_lifetime / duration < 1f)
		{
			GetComponent<Light>().intensity = Mathf.Lerp(baseIntensity, finalIntensity, p_lifetime / duration);
			p_lifetime += Time.deltaTime;
		}
		else if (autodestruct)
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}
}
public class CFX_ShurikenThreadFix : MonoBehaviour
{
	private ParticleSystem[] systems;

	private void OnEnable()
	{
		systems = GetComponentsInChildren<ParticleSystem>();
		ParticleSystem[] array = systems;
		foreach (ParticleSystem obj in array)
		{
			obj.Stop(withChildren: true);
			obj.Clear(withChildren: true);
		}
		StartCoroutine("WaitFrame");
	}

	private IEnumerator WaitFrame()
	{
		yield return null;
		ParticleSystem[] array = systems;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].Play(withChildren: true);
		}
	}
}
public class CFX_SpawnSystem : MonoBehaviour
{
	private static CFX_SpawnSystem instance;

	public GameObject[] objectsToPreload = new GameObject[0];

	public int[] objectsToPreloadTimes = new int[0];

	public bool hideObjectsInHierarchy;

	public bool spawnAsChildren = true;

	public bool onlyGetInactiveObjects;

	public bool instantiateIfNeeded;

	private bool allObjectsLoaded;

	private Dictionary<int, List<GameObject>> instantiatedObjects = new Dictionary<int, List<GameObject>>();

	private Dictionary<int, int> poolCursors = new Dictionary<int, int>();

	public static bool AllObjectsLoaded => instance.allObjectsLoaded;

	public static GameObject GetNextObject(GameObject sourceObj, bool activateObject = true)
	{
		int instanceID = sourceObj.GetInstanceID();
		if (!instance.poolCursors.ContainsKey(instanceID))
		{
			UnityEngine.Debug.LogError("[CFX_SpawnSystem.GetNextObject()] Object hasn't been preloaded: " + sourceObj.name + " (ID:" + instanceID + ")\n", instance);
			return null;
		}
		int num = instance.poolCursors[instanceID];
		GameObject gameObject = null;
		if (instance.onlyGetInactiveObjects)
		{
			int num2 = num;
			while (true)
			{
				gameObject = instance.instantiatedObjects[instanceID][num];
				instance.increasePoolCursor(instanceID);
				num = instance.poolCursors[instanceID];
				if (gameObject != null && !gameObject.activeSelf)
				{
					break;
				}
				if (num == num2)
				{
					if (instance.instantiateIfNeeded)
					{
						UnityEngine.Debug.Log("[CFX_SpawnSystem.GetNextObject()] A new instance has been created for \"" + sourceObj.name + "\" because no active instance were found in the pool.\n", instance);
						PreloadObject(sourceObj);
						List<GameObject> list = instance.instantiatedObjects[instanceID];
						gameObject = list[list.Count - 1];
						break;
					}
					UnityEngine.Debug.LogWarning("[CFX_SpawnSystem.GetNextObject()] There are no active instances available in the pool for \"" + sourceObj.name + "\"\nYou may need to increase the preloaded object count for this prefab?", instance);
					return null;
				}
			}
		}
		else
		{
			gameObject = instance.instantiatedObjects[instanceID][num];
			instance.increasePoolCursor(instanceID);
		}
		if (activateObject && gameObject != null)
		{
			gameObject.SetActive(value: true);
		}
		return gameObject;
	}

	public static void PreloadObject(GameObject sourceObj, int poolSize = 1)
	{
		instance.addObjectToPool(sourceObj, poolSize);
	}

	public static void UnloadObjects(GameObject sourceObj)
	{
		instance.removeObjectsFromPool(sourceObj);
	}

	private void addObjectToPool(GameObject sourceObject, int number)
	{
		int instanceID = sourceObject.GetInstanceID();
		if (!instantiatedObjects.ContainsKey(instanceID))
		{
			instantiatedObjects.Add(instanceID, new List<GameObject>());
			poolCursors.Add(instanceID, 0);
		}
		for (int i = 0; i < number; i++)
		{
			GameObject gameObject = UnityEngine.Object.Instantiate(sourceObject);
			gameObject.SetActive(value: false);
			CFX_AutoDestructShuriken[] componentsInChildren = gameObject.GetComponentsInChildren<CFX_AutoDestructShuriken>(includeInactive: true);
			for (int j = 0; j < componentsInChildren.Length; j++)
			{
				componentsInChildren[j].OnlyDeactivate = true;
			}
			CFX_LightIntensityFade[] componentsInChildren2 = gameObject.GetComponentsInChildren<CFX_LightIntensityFade>(includeInactive: true);
			for (int j = 0; j < componentsInChildren2.Length; j++)
			{
				componentsInChildren2[j].autodestruct = false;
			}
			instantiatedObjects[instanceID].Add(gameObject);
			if (hideObjectsInHierarchy)
			{
				gameObject.hideFlags = HideFlags.HideInHierarchy;
			}
			if (spawnAsChildren)
			{
				gameObject.transform.parent = base.transform;
			}
		}
	}

	private void removeObjectsFromPool(GameObject sourceObject)
	{
		int instanceID = sourceObject.GetInstanceID();
		if (!instantiatedObjects.ContainsKey(instanceID))
		{
			UnityEngine.Debug.LogWarning("[CFX_SpawnSystem.removeObjectsFromPool()] There aren't any preloaded object for: " + sourceObject.name + " (ID:" + instanceID + ")\n", base.gameObject);
			return;
		}
		for (int num = instantiatedObjects[instanceID].Count - 1; num >= 0; num--)
		{
			GameObject obj = instantiatedObjects[instanceID][num];
			instantiatedObjects[instanceID].RemoveAt(num);
			UnityEngine.Object.Destroy(obj);
		}
		instantiatedObjects.Remove(instanceID);
		poolCursors.Remove(instanceID);
	}

	private void increasePoolCursor(int uniqueId)
	{
		instance.poolCursors[uniqueId]++;
		if (instance.poolCursors[uniqueId] >= instance.instantiatedObjects[uniqueId].Count)
		{
			instance.poolCursors[uniqueId] = 0;
		}
	}

	private void Awake()
	{
		if (instance != null)
		{
			UnityEngine.Debug.LogWarning("CFX_SpawnSystem: There should only be one instance of CFX_SpawnSystem per Scene!\n", base.gameObject);
		}
		instance = this;
	}

	private void Start()
	{
		allObjectsLoaded = false;
		for (int i = 0; i < objectsToPreload.Length; i++)
		{
			PreloadObject(objectsToPreload[i], objectsToPreloadTimes[i]);
		}
		allObjectsLoaded = true;
	}
}
public class ETFXProjectileScript : MonoBehaviour
{
	public GameObject impactParticle;

	public GameObject projectileParticle;

	public GameObject muzzleParticle;

	[Header("Adjust if not using Sphere Collider")]
	public float colliderRadius = 1f;

	[Range(0f, 1f)]
	public float collideOffset = 0.15f;

	private void Start()
	{
		projectileParticle = UnityEngine.Object.Instantiate(projectileParticle, base.transform.position, base.transform.rotation);
		projectileParticle.transform.parent = base.transform;
		if ((bool)muzzleParticle)
		{
			muzzleParticle = UnityEngine.Object.Instantiate(muzzleParticle, base.transform.position, base.transform.rotation);
			UnityEngine.Object.Destroy(muzzleParticle, 1.5f);
		}
	}

	private void FixedUpdate()
	{
		if (GetComponent<Rigidbody>().velocity.magnitude != 0f)
		{
			base.transform.rotation = Quaternion.LookRotation(GetComponent<Rigidbody>().velocity);
		}
		float radius = ((!base.transform.GetComponent<SphereCollider>()) ? colliderRadius : base.transform.GetComponent<SphereCollider>().radius);
		Vector3 velocity = base.transform.GetComponent<Rigidbody>().velocity;
		if (base.transform.GetComponent<Rigidbody>().useGravity)
		{
			velocity += Physics.gravity * Time.deltaTime;
		}
		velocity = velocity.normalized;
		float maxDistance = base.transform.GetComponent<Rigidbody>().velocity.magnitude * Time.deltaTime;
		if (!Physics.SphereCast(base.transform.position, radius, velocity, out var hitInfo, maxDistance))
		{
			return;
		}
		base.transform.position = hitInfo.point + hitInfo.normal * collideOffset;
		GameObject obj = UnityEngine.Object.Instantiate(impactParticle, base.transform.position, Quaternion.FromToRotation(Vector3.up, hitInfo.normal));
		ParticleSystem[] componentsInChildren = GetComponentsInChildren<ParticleSystem>();
		for (int i = 1; i < componentsInChildren.Length; i++)
		{
			ParticleSystem particleSystem = componentsInChildren[i];
			if (particleSystem.gameObject.name.Contains("Trail"))
			{
				particleSystem.transform.SetParent(null);
				UnityEngine.Object.Destroy(particleSystem.gameObject, 2f);
			}
		}
		UnityEngine.Object.Destroy(projectileParticle, 3f);
		UnityEngine.Object.Destroy(obj, 3.5f);
		UnityEngine.Object.Destroy(base.gameObject);
	}
}
public class ETFXSceneManager : MonoBehaviour
{
	public bool GUIHide;

	public bool GUIHide2;

	public bool GUIHide3;

	public bool GUIHide4;

	public void LoadScene2DDemo()
	{
		SceneManager.LoadScene("etfx_2ddemo");
	}

	public void LoadSceneCards()
	{
		SceneManager.LoadScene("etfx_cards");
	}

	public void LoadSceneCombat()
	{
		SceneManager.LoadScene("etfx_combat");
	}

	public void LoadSceneDecals()
	{
		SceneManager.LoadScene("etfx_decals");
	}

	public void LoadSceneDecals2()
	{
		SceneManager.LoadScene("etfx_decals2");
	}

	public void LoadSceneEmojis()
	{
		SceneManager.LoadScene("etfx_emojis");
	}

	public void LoadSceneEmojis2()
	{
		SceneManager.LoadScene("etfx_emojis2");
	}

	public void LoadSceneExplosions()
	{
		SceneManager.LoadScene("etfx_explosions");
	}

	public void LoadSceneExplosions2()
	{
		SceneManager.LoadScene("etfx_explosions2");
	}

	public void LoadSceneFire()
	{
		SceneManager.LoadScene("etfx_fire");
	}

	public void LoadSceneFire2()
	{
		SceneManager.LoadScene("etfx_fire2");
	}

	public void LoadSceneFire3()
	{
		SceneManager.LoadScene("etfx_fire3");
	}

	public void LoadSceneFireworks()
	{
		SceneManager.LoadScene("etfx_fireworks");
	}

	public void LoadSceneFlares()
	{
		SceneManager.LoadScene("etfx_flares");
	}

	public void LoadSceneMagic()
	{
		SceneManager.LoadScene("etfx_magic");
	}

	public void LoadSceneMagic2()
	{
		SceneManager.LoadScene("etfx_magic2");
	}

	public void LoadSceneMagic3()
	{
		SceneManager.LoadScene("etfx_magic3");
	}

	public void LoadSceneMainDemo()
	{
		SceneManager.LoadScene("etfx_maindemo");
	}

	public void LoadSceneMissiles()
	{
		SceneManager.LoadScene("etfx_missiles");
	}

	public void LoadScenePortals()
	{
		SceneManager.LoadScene("etfx_portals");
	}

	public void LoadScenePortals2()
	{
		SceneManager.LoadScene("etfx_portals2");
	}

	public void LoadScenePowerups()
	{
		SceneManager.LoadScene("etfx_powerups");
	}

	public void LoadScenePowerups2()
	{
		SceneManager.LoadScene("etfx_powerups2");
	}

	public void LoadSceneSparkles()
	{
		SceneManager.LoadScene("etfx_sparkles");
	}

	public void LoadSceneSwordCombat()
	{
		SceneManager.LoadScene("etfx_swordcombat");
	}

	public void LoadSceneSwordCombat2()
	{
		SceneManager.LoadScene("etfx_swordcombat2");
	}

	public void LoadSceneMoney()
	{
		SceneManager.LoadScene("etfx_money");
	}

	public void LoadSceneHealing()
	{
		SceneManager.LoadScene("etfx_healing");
	}

	public void LoadSceneWind()
	{
		SceneManager.LoadScene("etfx_wind");
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.L))
		{
			GUIHide = !GUIHide;
			if (GUIHide)
			{
				GameObject.Find("CanvasSceneSelect").GetComponent<Canvas>().enabled = false;
			}
			else
			{
				GameObject.Find("CanvasSceneSelect").GetComponent<Canvas>().enabled = true;
			}
		}
		if (Input.GetKeyDown(KeyCode.J))
		{
			GUIHide2 = !GUIHide2;
			if (GUIHide2)
			{
				GameObject.Find("Canvas").GetComponent<Canvas>().enabled = false;
			}
			else
			{
				GameObject.Find("Canvas").GetComponent<Canvas>().enabled = true;
			}
		}
		if (Input.GetKeyDown(KeyCode.H))
		{
			GUIHide3 = !GUIHide3;
			if (GUIHide3)
			{
				GameObject.Find("ParticleSysDisplayCanvas").GetComponent<Canvas>().enabled = false;
			}
			else
			{
				GameObject.Find("ParticleSysDisplayCanvas").GetComponent<Canvas>().enabled = true;
			}
		}
		if (Input.GetKeyDown(KeyCode.K))
		{
			GUIHide4 = !GUIHide4;
			if (GUIHide3)
			{
				GameObject.Find("CanvasTips").GetComponent<Canvas>().enabled = false;
			}
			else
			{
				GameObject.Find("CanvasTips").GetComponent<Canvas>().enabled = true;
			}
		}
	}
}
public class ParticleEffectsLibrary : MonoBehaviour
{
	public static ParticleEffectsLibrary GlobalAccess;

	public int TotalEffects;

	public int CurrentParticleEffectIndex;

	public int CurrentParticleEffectNum;

	public Vector3[] ParticleEffectSpawnOffsets;

	public float[] ParticleEffectLifetimes;

	public GameObject[] ParticleEffectPrefabs;

	private string effectNameString = "";

	private List<Transform> currentActivePEList;

	private Vector3 spawnPosition = Vector3.zero;

	private void Awake()
	{
		GlobalAccess = this;
		currentActivePEList = new List<Transform>();
		TotalEffects = ParticleEffectPrefabs.Length;
		CurrentParticleEffectNum = 1;
		if (ParticleEffectSpawnOffsets.Length != TotalEffects)
		{
			UnityEngine.Debug.LogError("ParticleEffectsLibrary-ParticleEffectSpawnOffset: Not all arrays match length, double check counts.");
		}
		if (ParticleEffectPrefabs.Length != TotalEffects)
		{
			UnityEngine.Debug.LogError("ParticleEffectsLibrary-ParticleEffectPrefabs: Not all arrays match length, double check counts.");
		}
		effectNameString = ParticleEffectPrefabs[CurrentParticleEffectIndex].name + " (" + CurrentParticleEffectNum + " of " + TotalEffects + ")";
	}

	private void Start()
	{
	}

	public string GetCurrentPENameString()
	{
		return ParticleEffectPrefabs[CurrentParticleEffectIndex].name + " (" + CurrentParticleEffectNum + " of " + TotalEffects + ")";
	}

	public void PreviousParticleEffect()
	{
		if (ParticleEffectLifetimes[CurrentParticleEffectIndex] == 0f && currentActivePEList.Count > 0)
		{
			for (int i = 0; i < currentActivePEList.Count; i++)
			{
				if (currentActivePEList[i] != null)
				{
					UnityEngine.Object.Destroy(currentActivePEList[i].gameObject);
				}
			}
			currentActivePEList.Clear();
		}
		if (CurrentParticleEffectIndex > 0)
		{
			CurrentParticleEffectIndex--;
		}
		else
		{
			CurrentParticleEffectIndex = TotalEffects - 1;
		}
		CurrentParticleEffectNum = CurrentParticleEffectIndex + 1;
		effectNameString = ParticleEffectPrefabs[CurrentParticleEffectIndex].name + " (" + CurrentParticleEffectNum + " of " + TotalEffects + ")";
	}

	public void NextParticleEffect()
	{
		if (ParticleEffectLifetimes[CurrentParticleEffectIndex] == 0f && currentActivePEList.Count > 0)
		{
			for (int i = 0; i < currentActivePEList.Count; i++)
			{
				if (currentActivePEList[i] != null)
				{
					UnityEngine.Object.Destroy(currentActivePEList[i].gameObject);
				}
			}
			currentActivePEList.Clear();
		}
		if (CurrentParticleEffectIndex < TotalEffects - 1)
		{
			CurrentParticleEffectIndex++;
		}
		else
		{
			CurrentParticleEffectIndex = 0;
		}
		CurrentParticleEffectNum = CurrentParticleEffectIndex + 1;
		effectNameString = ParticleEffectPrefabs[CurrentParticleEffectIndex].name + " (" + CurrentParticleEffectNum + " of " + TotalEffects + ")";
	}

	public void SpawnParticleEffect(Vector3 positionInWorldToSpawn)
	{
		spawnPosition = positionInWorldToSpawn + ParticleEffectSpawnOffsets[CurrentParticleEffectIndex];
		GameObject gameObject = UnityEngine.Object.Instantiate(ParticleEffectPrefabs[CurrentParticleEffectIndex], spawnPosition, ParticleEffectPrefabs[CurrentParticleEffectIndex].transform.rotation);
		gameObject.name = "PE_" + ParticleEffectPrefabs[CurrentParticleEffectIndex];
		if (ParticleEffectLifetimes[CurrentParticleEffectIndex] == 0f)
		{
			currentActivePEList.Add(gameObject.transform);
		}
		currentActivePEList.Add(gameObject.transform);
		if (ParticleEffectLifetimes[CurrentParticleEffectIndex] != 0f)
		{
			UnityEngine.Object.Destroy(gameObject, ParticleEffectLifetimes[CurrentParticleEffectIndex]);
		}
	}
}
public enum ButtonTypes
{
	NotDefined,
	Previous,
	Next
}
public class PEButtonScript : MonoBehaviour, IEventSystemHandler, IPointerEnterHandler, IPointerExitHandler
{
	private Button myButton;

	public ButtonTypes ButtonType;

	private void Start()
	{
		myButton = base.gameObject.GetComponent<Button>();
	}

	public void OnPointerEnter(PointerEventData eventData)
	{
		UICanvasManager.GlobalAccess.MouseOverButton = true;
		UICanvasManager.GlobalAccess.UpdateToolTip(ButtonType);
	}

	public void OnPointerExit(PointerEventData eventData)
	{
		UICanvasManager.GlobalAccess.MouseOverButton = false;
		UICanvasManager.GlobalAccess.ClearToolTip();
	}

	public void OnButtonClicked()
	{
		UICanvasManager.GlobalAccess.UIButtonClick(ButtonType);
	}
}
public class UICanvasManager : MonoBehaviour
{
	public static UICanvasManager GlobalAccess;

	public bool MouseOverButton;

	public Text PENameText;

	public Text ToolTipText;

	private RaycastHit rayHit;

	private void Awake()
	{
		GlobalAccess = this;
	}

	private void Start()
	{
		if (PENameText != null)
		{
			PENameText.text = ParticleEffectsLibrary.GlobalAccess.GetCurrentPENameString();
		}
	}

	private void Update()
	{
		if (!MouseOverButton && Input.GetMouseButtonUp(0))
		{
			SpawnCurrentParticleEffect();
		}
		if (Input.GetKeyUp(KeyCode.A))
		{
			SelectPreviousPE();
		}
		if (Input.GetKeyUp(KeyCode.D))
		{
			SelectNextPE();
		}
	}

	public void UpdateToolTip(ButtonTypes toolTipType)
	{
		if (ToolTipText != null)
		{
			switch (toolTipType)
			{
			case ButtonTypes.Previous:
				ToolTipText.text = "Select Previous Particle Effect";
				break;
			case ButtonTypes.Next:
				ToolTipText.text = "Select Next Particle Effect";
				break;
			}
		}
	}

	public void ClearToolTip()
	{
		if (ToolTipText != null)
		{
			ToolTipText.text = "";
		}
	}

	private void SelectPreviousPE()
	{
		ParticleEffectsLibrary.GlobalAccess.PreviousParticleEffect();
		if (PENameText != null)
		{
			PENameText.text = ParticleEffectsLibrary.GlobalAccess.GetCurrentPENameString();
		}
	}

	private void SelectNextPE()
	{
		ParticleEffectsLibrary.GlobalAccess.NextParticleEffect();
		if (PENameText != null)
		{
			PENameText.text = ParticleEffectsLibrary.GlobalAccess.GetCurrentPENameString();
		}
	}

	private void SpawnCurrentParticleEffect()
	{
		if (Physics.Raycast(Camera.main.ScreenPointToRay(Input.mousePosition), out rayHit))
		{
			ParticleEffectsLibrary.GlobalAccess.SpawnParticleEffect(rayHit.point);
		}
	}

	public void UIButtonClick(ButtonTypes buttonTypeClicked)
	{
		switch (buttonTypeClicked)
		{
		case ButtonTypes.Previous:
			SelectPreviousPE();
			break;
		case ButtonTypes.Next:
			SelectNextPE();
			break;
		}
	}
}
public class J_FishRandomMovement : MonoBehaviour
{
	public GameObject m_objFish;

	public Vector3 m_RangeSize = Vector3.one;

	public float m_MoveSpeed = 1f;

	public float m_rotationSpeed = 2f;

	private float speedMuit = 1f;

	private float neighbourDistance = 5f;

	private bool turning;

	private Vector3 vOriginalPos;

	private Vector3 targetPos;

	private float fRandSecond;

	private Rigidbody rigidbody;

	private void Start()
	{
		rigidbody = m_objFish.GetComponent<Rigidbody>();
		vOriginalPos = base.transform.position;
		setTargetPos();
	}

	private void Update()
	{
		Vector3 forward = targetPos - m_objFish.transform.position;
		m_objFish.transform.rotation = Quaternion.Slerp(m_objFish.transform.rotation, Quaternion.LookRotation(forward), m_rotationSpeed * Time.deltaTime);
		m_objFish.transform.Translate(0f, 0f, Time.deltaTime * speedMuit * m_MoveSpeed);
		if ((fRandSecond -= Time.deltaTime) < 0f)
		{
			setTargetPos();
		}
	}

	private void setTargetPos()
	{
		targetPos = vOriginalPos + new Vector3(UnityEngine.Random.Range(0f - m_RangeSize.x, m_RangeSize.x), UnityEngine.Random.Range(0f - m_RangeSize.y, m_RangeSize.y), UnityEngine.Random.Range(0f - m_RangeSize.z, m_RangeSize.z));
		fRandSecond = (targetPos - m_objFish.transform.position).magnitude / m_MoveSpeed;
		speedMuit = UnityEngine.Random.Range(0.5f, 1.5f);
		if (rigidbody != null)
		{
			rigidbody.Sleep();
		}
	}

	private void OnDrawGizmosSelected()
	{
		Gizmos.DrawWireCube(base.transform.position, m_RangeSize * 2f);
		Gizmos.color = Color.red;
		Gizmos.DrawSphere(targetPos, 0.1f);
	}
}
public class Move2D : MonoBehaviour
{
	public delegate void OverMoveEventHandler(GameObject gObj);

	public delegate void RunTimeEventHandler(GameObject gObj, RunTimeEventArgs bte);

	public class RunTimeEventArgs : EventArgs
	{
		public readonly float runTime;

		public readonly float totalTime;

		public RunTimeEventArgs(float rt, float tt)
		{
			runTime = rt;
			totalTime = tt;
		}
	}

	private float moveTime;

	private Vector3 speed;

	private float timeDelta;

	private AnimationCurve anmc;

	private bool isMoveRuning;

	private Vector2 moveEndPosition;

	public bool IsMoveRuning => isMoveRuning;

	public Vector3 MoveEndPosition => moveEndPosition;

	public event OverMoveEventHandler OverMove;

	public event RunTimeEventHandler RunTime;

	private static Move2D createMove(GameObject runObj)
	{
		Move2D move2D = runObj.GetComponent<Move2D>();
		if (move2D == null)
		{
			move2D = runObj.AddComponent<Move2D>();
		}
		return move2D;
	}

	public static Move2D createMove_Line(GameObject runObj, Vector3 endPostion, float moveTime)
	{
		Move2D move2D = createMove(runObj);
		move2D.initMove_Line(endPostion, moveTime);
		return move2D;
	}

	private void initMove_Line(Vector3 endPostion, float moveTime)
	{
		anmc = null;
		moveEndPosition = endPostion;
		speed = endPostion / moveTime;
		timeDelta = 0f;
		this.moveTime = moveTime;
		isMoveRuning = true;
	}

	public static Move2D createMove_Lines(GameObject runObj, Vector3 endPostion, float moveTime)
	{
		Move2D move2D = createMove(runObj);
		move2D.initMove_Lines(endPostion, moveTime);
		return move2D;
	}

	private void initMove_Lines(Vector3 endPostion, float moveTime)
	{
		anmc = null;
		moveEndPosition = endPostion;
		speed = endPostion / moveTime;
		timeDelta = 0f;
		this.moveTime = moveTime;
		isMoveRuning = true;
	}

	public static Move2D createMove_CurveUp(GameObject runObj, Vector3 endPostion, float moveTime, float maxHeight, float curveCoefficient = -999999f)
	{
		Move2D move2D = createMove(runObj);
		if (curveCoefficient == -999999f)
		{
			curveCoefficient = maxHeight * 0.5f;
		}
		move2D.initMove_CurveUp(endPostion, moveTime, maxHeight, curveCoefficient);
		return move2D;
	}

	private void initMove_CurveUp(Vector3 endPostion, float moveTime, float maxHeight, float curveCoefficient)
	{
		Keyframe[] array = new Keyframe[2]
		{
			new Keyframe(0f, 0f),
			default(Keyframe)
		};
		array[0].outTangent = curveCoefficient;
		array[1] = new Keyframe(moveTime, maxHeight);
		anmc = new AnimationCurve(array);
		moveEndPosition = endPostion;
		speed = endPostion / moveTime;
		timeDelta = 0f;
		this.moveTime = moveTime;
		isMoveRuning = true;
	}

	public static Move2D createMove_CurveUpDown(GameObject runObj, Vector3 endPostion, float moveTime, float maxHeight, float curveCoefficient = -999999f)
	{
		Move2D move2D = createMove(runObj);
		if (curveCoefficient == -999999f)
		{
			curveCoefficient = ((!(maxHeight >= 3f)) ? (maxHeight * 0.5f) : ((maxHeight - 3f) * 0.5f + 2.5f));
		}
		move2D.initMove_CurveUpDown(endPostion, moveTime, maxHeight, curveCoefficient);
		return move2D;
	}

	private void initMove_CurveUpDown(Vector3 endPostion, float moveTime, float maxHeight, float curveCoefficient)
	{
		Keyframe[] array = new Keyframe[3]
		{
			new Keyframe(0f, 0f),
			default(Keyframe),
			default(Keyframe)
		};
		array[0].outTangent = curveCoefficient;
		array[1] = new Keyframe(moveTime / 2f, maxHeight);
		array[1].inTangent = 0f;
		array[1].outTangent = 0f;
		array[2] = new Keyframe(moveTime, 0f);
		array[2].inTangent = 0f - curveCoefficient;
		anmc = new AnimationCurve(array);
		moveEndPosition = endPostion;
		speed = endPostion / moveTime;
		timeDelta = 0f;
		this.moveTime = moveTime;
		isMoveRuning = true;
	}

	public static Move2D createMove_CurveFloat(GameObject runObj, Vector3 endPostion, int average, float moveTime, float maxHeight, float curveCoefficient = -999999f)
	{
		Move2D move2D = createMove(runObj);
		if (curveCoefficient == -999999f)
		{
			curveCoefficient = ((!(maxHeight >= 3f)) ? (maxHeight * 0.5f) : ((maxHeight - 3f) * 0.5f + 2.5f));
		}
		move2D.initMove_CurveFloat(endPostion, average, moveTime, maxHeight, curveCoefficient);
		return move2D;
	}

	private void initMove_CurveFloat(Vector3 endPostion, int average, float moveTime, float maxHeight, float curveCoefficient)
	{
		Keyframe[] array = new Keyframe[average + 2];
		for (int i = 0; i < average + 2; i++)
		{
			if (i == 0)
			{
				array[i] = new Keyframe(0f, 0f);
				array[i].outTangent = curveCoefficient;
				continue;
			}
			if (i == average + 1)
			{
				array[i] = new Keyframe(moveTime, 0f);
				array[i].outTangent = curveCoefficient;
				continue;
			}
			float time = moveTime / (float)(average * 2) * (float)(i * 2 - 1);
			array[i] = new Keyframe(time, (i % 2 == 0) ? (0f - maxHeight) : maxHeight);
			array[i].inTangent = 0f;
			array[i].outTangent = 0f;
		}
		anmc = new AnimationCurve(array);
		moveEndPosition = endPostion;
		speed = endPostion / moveTime;
		timeDelta = 0f;
		this.moveTime = moveTime;
		isMoveRuning = true;
	}

	public static Move2D createMove_Bounce3(GameObject runObj, Vector3 endPostion, float moveTime, float maxHeight, float curveCoefficient = -999999f)
	{
		Move2D move2D = createMove(runObj);
		if (curveCoefficient == -999999f)
		{
			curveCoefficient = maxHeight;
		}
		move2D.initMove_Bounce3(endPostion, moveTime, maxHeight, curveCoefficient);
		return move2D;
	}

	private void initMove_Bounce3(Vector3 endPostion, float moveTime, float maxHeight, float curveCoefficient)
	{
		Keyframe[] array = new Keyframe[7]
		{
			new Keyframe(0f, 0f),
			default(Keyframe),
			default(Keyframe),
			default(Keyframe),
			default(Keyframe),
			default(Keyframe),
			default(Keyframe)
		};
		array[0].outTangent = curveCoefficient;
		array[1] = new Keyframe(moveTime * 0.35f, maxHeight);
		array[1].inTangent = 0f;
		array[1].outTangent = 0f;
		array[2] = new Keyframe(moveTime * 0.7f, 0f);
		array[2].inTangent = 0f - curveCoefficient;
		array[2].outTangent = curveCoefficient;
		array[3] = new Keyframe(moveTime * 0.8f, maxHeight / 3f);
		array[3].inTangent = 0f;
		array[3].outTangent = 0f;
		array[4] = new Keyframe(moveTime * 0.9f, 0f);
		array[4].inTangent = 0f - curveCoefficient;
		array[4].outTangent = curveCoefficient;
		array[5] = new Keyframe(moveTime * 0.95f, maxHeight / 6f);
		array[5].inTangent = 0f;
		array[5].outTangent = 0f;
		array[6] = new Keyframe(moveTime, 0f);
		array[6].inTangent = 0f - curveCoefficient;
		anmc = new AnimationCurve(array);
		moveEndPosition = endPostion;
		speed = endPostion / moveTime;
		timeDelta = 0f;
		this.moveTime = moveTime;
		isMoveRuning = true;
	}

	private void Update()
	{
		if (timeDelta <= moveTime)
		{
			Vector3 vector = speed * timeDelta;
			if (anmc != null)
			{
				vector.y += anmc.Evaluate(timeDelta);
			}
			base.transform.LookAt(base.transform.parent.TransformPoint(vector));
			base.transform.localPosition = vector;
			if (this.RunTime != null)
			{
				this.RunTime(base.gameObject, new RunTimeEventArgs(timeDelta, moveTime));
			}
			timeDelta += Time.deltaTime;
		}
		else
		{
			if (this.RunTime != null)
			{
				this.RunTime(base.gameObject, new RunTimeEventArgs(timeDelta, moveTime));
			}
			if (this.OverMove != null)
			{
				this.OverMove(base.gameObject);
			}
			StopMove2D();
		}
	}

	public void StopMove2D()
	{
		UnityEngine.Object.Destroy(this);
		isMoveRuning = false;
	}
}
public class Move2D_Line : MonoBehaviour
{
	public delegate void OverMoveEventHandler(GameObject gObj);

	public delegate void RunTimeEventHandler(GameObject gObj, RunTimeEventArgs bte);

	public class RunTimeEventArgs : EventArgs
	{
		public readonly float runTime;

		public readonly float totalTime;

		public RunTimeEventArgs(float rt, float tt)
		{
			runTime = rt;
			totalTime = tt;
		}
	}

	private float moveTime;

	private Vector3 speed;

	private float timeDelta;

	private int index;

	private List<float> moveTimeList;

	private AnimationCurve anmc;

	private bool isMoveRuning;

	private List<Vector3> moveEndPosition_World;

	private List<Vector3> moveEndPosition;

	public bool IsMoveRuning => isMoveRuning;

	public List<Vector3> MoveEndPosition_World => moveEndPosition_World;

	public List<Vector3> MoveEndPosition => moveEndPosition;

	public event OverMoveEventHandler OverMove;

	public event RunTimeEventHandler RunTime;

	private static Move2D_Line createMove(GameObject runObj)
	{
		Move2D_Line move2D_Line = runObj.GetComponent<Move2D_Line>();
		if (move2D_Line == null)
		{
			move2D_Line = runObj.AddComponent<Move2D_Line>();
		}
		return move2D_Line;
	}

	public static Move2D_Line createMove_LineChange(GameObject runObj, Vector3 endPostion, float moveTime, float percent)
	{
		Move2D_Line move2D_Line = createMove(runObj);
		move2D_Line.initMove_LineChange(endPostion, moveTime, percent);
		return move2D_Line;
	}

	private void initMove_LineChange(Vector3 endPostions, float moveTime, float percent)
	{
		anmc = null;
		moveEndPosition_World = new List<Vector3>();
		List<Vector3> list = new List<Vector3>();
		Vector3 betweenPoint = GetBetweenPoint(endPostions, base.transform.localPosition, percent);
		betweenPoint.y = base.transform.localPosition.y;
		list.Add(betweenPoint);
		moveEndPosition_World.Add(base.transform.parent.TransformPoint(betweenPoint));
		betweenPoint.y = endPostions.y;
		list.Add(betweenPoint);
		moveEndPosition_World.Add(base.transform.parent.TransformPoint(betweenPoint));
		list.Add(endPostions);
		moveEndPosition_World.Add(base.transform.parent.TransformPoint(endPostions));
		List<float> list2 = new List<float>();
		float num = 0f;
		for (int i = 0; i < list.Count; i++)
		{
			if (i == 0)
			{
				list2.Add(Vector3.Distance(base.transform.localPosition, list[0]));
			}
			else
			{
				list2.Add(Vector3.Distance(list[i - 1], list[i]));
			}
			num += list2[i];
		}
		moveTimeList = new List<float>();
		for (int j = 0; j < list2.Count; j++)
		{
			moveTimeList.Add(list2[j] / num * moveTime);
		}
		moveEndPosition = list;
		index = 0;
		speed = list[0] / moveTimeList[0];
		timeDelta = 0f;
		this.moveTime = moveTime;
		isMoveRuning = true;
	}

	public static Move2D_Line createMove_Lines(GameObject runObj, List<Vector3> endPostion, float moveTime)
	{
		Move2D_Line move2D_Line = createMove(runObj);
		move2D_Line.initMove_Lines(endPostion, moveTime);
		return move2D_Line;
	}

	private void initMove_Lines(List<Vector3> endPostions, float moveTime)
	{
		anmc = null;
		List<float> list = new List<float>();
		moveEndPosition_World = new List<Vector3>();
		float num = 0f;
		for (int i = 0; i < endPostions.Count; i++)
		{
			if (i == 0)
			{
				list.Add(Vector3.Distance(base.transform.localPosition, endPostions[0]));
			}
			else
			{
				list.Add(Vector3.Distance(endPostions[i - 1], endPostions[i]));
			}
			num += list[i];
			moveEndPosition_World.Add(base.transform.parent.TransformPoint(endPostions[i]));
		}
		moveTimeList = new List<float>();
		for (int j = 0; j < list.Count; j++)
		{
			moveTimeList.Add(list[j] / num * moveTime);
		}
		moveEndPosition = endPostions;
		index = 0;
		speed = endPostions[0] / moveTimeList[0];
		timeDelta = 0f;
		this.moveTime = moveTime;
		isMoveRuning = true;
	}

	private Vector3 GetBetweenPoint(Vector3 start, Vector3 end, float percent = 0.5f)
	{
		Vector3 normalized = (end - start).normalized;
		float num = Vector3.Distance(start, end);
		return normalized * (num * percent) + start;
	}

	private Vector3 GetBetweenPointByDis(Vector3 start, Vector3 end, float distance)
	{
		return (end - start).normalized * distance + start;
	}

	private void Update()
	{
		if (timeDelta <= moveTimeList[index])
		{
			Vector3 vector = speed * timeDelta;
			if (anmc != null)
			{
				vector.y += anmc.Evaluate(timeDelta);
			}
			base.transform.LookAt(base.transform.parent.TransformPoint(vector));
			base.transform.localPosition = vector;
			if (this.RunTime != null)
			{
				this.RunTime(base.gameObject, new RunTimeEventArgs(timeDelta, moveTime));
			}
			timeDelta += Time.deltaTime;
		}
		else if (index < moveEndPosition.Count - 1)
		{
			index++;
			Vector3 vector2 = moveEndPosition[index] - moveEndPosition[index - 1];
			speed = vector2 / moveTimeList[index];
			timeDelta = 0f;
			base.transform.parent.position = moveEndPosition_World[index - 1];
		}
		else
		{
			if (this.RunTime != null)
			{
				this.RunTime(base.gameObject, new RunTimeEventArgs(timeDelta, moveTime));
			}
			if (this.OverMove != null)
			{
				this.OverMove(base.gameObject);
			}
			StopMove2D();
		}
	}

	public void StopMove2D()
	{
		UnityEngine.Object.Destroy(this);
		isMoveRuning = false;
	}
}
public class Move2D_X : MonoBehaviour
{
	public delegate void OverMoveEventHandler(GameObject gObj);

	public delegate void RunTimeEventHandler(GameObject gObj, RunTimeEventArgs bte);

	public class RunTimeEventArgs : EventArgs
	{
		public readonly float runTime;

		public readonly float totalTime;

		public RunTimeEventArgs(float rt, float tt)
		{
			runTime = rt;
			totalTime = tt;
		}
	}

	private float moveTime;

	private Vector3 speed;

	private float timeDelta;

	private AnimationCurve anmc;

	private bool isMoveRuning;

	private Vector2 moveEndPosition;

	private float dpassedTime;

	private float height;

	public bool IsMoveRuning => isMoveRuning;

	public Vector3 MoveEndPosition => moveEndPosition;

	public event OverMoveEventHandler OverMove;

	public event RunTimeEventHandler RunTime;

	private static Move2D_X createMove(GameObject runObj)
	{
		Move2D_X move2D_X = runObj.GetComponent<Move2D_X>();
		if (move2D_X == null)
		{
			move2D_X = runObj.AddComponent<Move2D_X>();
		}
		return move2D_X;
	}

	public static Move2D_X createMove_CurveUpDown(GameObject runObj, Vector3 endPostion, float moveTime, float maxHeight, float curveCoefficient = -999999f)
	{
		Move2D_X move2D_X = createMove(runObj);
		if (curveCoefficient == -999999f)
		{
			curveCoefficient = ((!(maxHeight >= 3f)) ? (maxHeight * 0.5f) : ((maxHeight - 3f) * 0.5f + 2.5f));
		}
		move2D_X.initMove_CurveUpDown(endPostion, moveTime, maxHeight, curveCoefficient);
		return move2D_X;
	}

	private void initMove_CurveUpDown(Vector3 endPostion, float moveTime, float maxHeight, float curveCoefficient)
	{
		Keyframe[] array = new Keyframe[3]
		{
			new Keyframe(0f, 0f),
			default(Keyframe),
			default(Keyframe)
		};
		array[0].outTangent = 0f;
		array[1] = new Keyframe(moveTime / 2f, maxHeight);
		array[1].inTangent = 0f;
		array[1].outTangent = 0f;
		array[2] = new Keyframe(moveTime, 0f);
		array[2].inTangent = 0f;
		anmc = new AnimationCurve(array);
		moveEndPosition = endPostion;
		speed = endPostion / moveTime;
		timeDelta = 0f;
		this.moveTime = moveTime;
		isMoveRuning = true;
		dpassedTime = 0f;
		height = maxHeight;
	}

	private void Update()
	{
		if (timeDelta <= moveTime)
		{
			Vector3 vector = speed * timeDelta;
			if (anmc != null)
			{
				vector.x += anmc.Evaluate(timeDelta);
			}
			base.transform.LookAt(base.transform.parent.TransformPoint(vector));
			base.transform.localPosition = vector;
			if (this.RunTime != null)
			{
				this.RunTime(base.gameObject, new RunTimeEventArgs(timeDelta, moveTime));
			}
			timeDelta += Time.deltaTime;
		}
		else
		{
			if (this.RunTime != null)
			{
				this.RunTime(base.gameObject, new RunTimeEventArgs(timeDelta, moveTime));
			}
			if (this.OverMove != null)
			{
				this.OverMove(base.gameObject);
			}
			StopMove2D();
		}
	}

	public void StopMove2D()
	{
		UnityEngine.Object.Destroy(this);
		isMoveRuning = false;
	}
}
[ExecuteInEditMode]
public class PlanarReflection : MonoBehaviour
{
	private Camera reflectionCamera;

	private RenderTexture reflectionRT;

	private bool isReflectionCameraRendering;

	private Material reflectionMaterial;

	private void OnWillRenderObject()
	{
		if (!isReflectionCameraRendering)
		{
			isReflectionCameraRendering = true;
			if (reflectionCamera == null)
			{
				GameObject gameObject = new GameObject("Reflection Camera");
				reflectionCamera = gameObject.AddComponent<Camera>();
				reflectionCamera.CopyFrom(Camera.current);
			}
			if (reflectionRT == null)
			{
				reflectionRT = RenderTexture.GetTemporary(1024, 1024, 24);
			}
			UpdateCamearaParams(Camera.current, reflectionCamera);
			reflectionCamera.clearFlags = CameraClearFlags.Color;
			reflectionCamera.backgroundColor = new Color(0f, 0f, 0f, 0f);
			reflectionCamera.targetTexture = reflectionRT;
			reflectionCamera.enabled = false;
			Matrix4x4 matrix4x = CaculateReflectMatrix();
			reflectionCamera.worldToCameraMatrix = Camera.current.worldToCameraMatrix * matrix4x;
			Vector3 up = base.transform.up;
			float w = 0f - Vector3.Dot(up, base.transform.position);
			Vector4 vector = new Vector4(up.x, up.y, up.z, w);
			Vector4 clipPlane = reflectionCamera.worldToCameraMatrix.inverse.transpose * vector;
			Matrix4x4 projectionMatrix = reflectionCamera.CalculateObliqueMatrix(clipPlane);
			reflectionCamera.projectionMatrix = projectionMatrix;
			GL.invertCulling = true;
			reflectionCamera.Render();
			GL.invertCulling = false;
			if (reflectionMaterial == null)
			{
				Renderer component = GetComponent<Renderer>();
				reflectionMaterial = component.sharedMaterial;
			}
			reflectionMaterial.SetTexture("_ReflectionTex", reflectionRT);
			isReflectionCameraRendering = false;
		}
	}

	private Matrix4x4 CaculateReflectMatrix()
	{
		Vector3 up = base.transform.up;
		float num = 0f - Vector3.Dot(up, base.transform.position);
		Matrix4x4 result = default(Matrix4x4);
		result.m00 = 1f - 2f * up.x * up.x;
		result.m01 = -2f * up.x * up.y;
		result.m02 = -2f * up.x * up.z;
		result.m03 = -2f * num * up.x;
		result.m10 = -2f * up.x * up.y;
		result.m11 = 1f - 2f * up.y * up.y;
		result.m12 = -2f * up.y * up.z;
		result.m13 = -2f * num * up.y;
		result.m20 = -2f * up.x * up.z;
		result.m21 = -2f * up.y * up.z;
		result.m22 = 1f - 2f * up.z * up.z;
		result.m23 = -2f * num * up.z;
		result.m30 = 0f;
		result.m31 = 0f;
		result.m32 = 0f;
		result.m33 = 1f;
		return result;
	}

	private void UpdateCamearaParams(Camera srcCamera, Camera destCamera)
	{
		if (!(destCamera == null) && !(srcCamera == null))
		{
			destCamera.clearFlags = srcCamera.clearFlags;
			destCamera.backgroundColor = srcCamera.backgroundColor;
			destCamera.farClipPlane = srcCamera.farClipPlane;
			destCamera.nearClipPlane = srcCamera.nearClipPlane;
			destCamera.orthographic = srcCamera.orthographic;
			destCamera.fieldOfView = srcCamera.fieldOfView;
			destCamera.aspect = srcCamera.aspect;
			destCamera.orthographicSize = srcCamera.orthographicSize;
		}
	}

	private Matrix4x4 CaculateObliqueViewFrustumMatrix(Vector4 plane, Camera camera)
	{
		Vector4 clipPlane = camera.worldToCameraMatrix.inverse.transpose * plane;
		return camera.CalculateObliqueMatrix(clipPlane);
	}
}
public class Interpolate
{
	public enum EaseType
	{
		Linear,
		EaseInQuad,
		EaseOutQuad,
		EaseInOutQuad,
		EaseInCubic,
		EaseOutCubic,
		EaseInOutCubic,
		EaseInQuart,
		EaseOutQuart,
		EaseInOutQuart,
		EaseInQuint,
		EaseOutQuint,
		EaseInOutQuint,
		EaseInSine,
		EaseOutSine,
		EaseInOutSine,
		EaseInExpo,
		EaseOutExpo,
		EaseInOutExpo,
		EaseInCirc,
		EaseOutCirc,
		EaseInOutCirc
	}

	public delegate Vector3 ToVector3<T>(T v);

	public delegate float Function(float a, float b, float c, float d);

	private static Vector3 Identity(Vector3 v)
	{
		return v;
	}

	private static Vector3 TransformDotPosition(Transform t)
	{
		return t.position;
	}

	private static IEnumerable<float> NewTimer(float duration)
	{
		float elapsedTime = 0f;
		while (elapsedTime < duration)
		{
			yield return elapsedTime;
			elapsedTime += Time.deltaTime;
			if (elapsedTime >= duration)
			{
				yield return elapsedTime;
			}
		}
	}

	private static IEnumerable<float> NewCounter(int start, int end, int step)
	{
		for (int i = start; i <= end; i += step)
		{
			yield return i;
		}
	}

	public static IEnumerator NewEase(Function ease, Vector3 start, Vector3 end, float duration)
	{
		IEnumerable<float> driver = NewTimer(duration);
		return NewEase(ease, start, end, duration, driver);
	}

	public static IEnumerator NewEase(Function ease, Vector3 start, Vector3 end, int slices)
	{
		IEnumerable<float> driver = NewCounter(0, slices + 1, 1);
		return NewEase(ease, start, end, slices + 1, driver);
	}

	private static IEnumerator NewEase(Function ease, Vector3 start, Vector3 end, float total, IEnumerable<float> driver)
	{
		Vector3 distance = end - start;
		foreach (float item in driver)
		{
			yield return Ease(ease, start, distance, item, total);
		}
	}

	private static Vector3 Ease(Function ease, Vector3 start, Vector3 distance, float elapsedTime, float duration)
	{
		start.x = ease(start.x, distance.x, elapsedTime, duration);
		start.y = ease(start.y, distance.y, elapsedTime, duration);
		start.z = ease(start.z, distance.z, elapsedTime, duration);
		return start;
	}

	public static Function Ease(EaseType type)
	{
		Function result = null;
		switch (type)
		{
		case EaseType.Linear:
			result = Linear;
			break;
		case EaseType.EaseInQuad:
			result = EaseInQuad;
			break;
		case EaseType.EaseOutQuad:
			result = EaseOutQuad;
			break;
		case EaseType.EaseInOutQuad:
			result = EaseInOutQuad;
			break;
		case EaseType.EaseInCubic:
			result = EaseInCubic;
			break;
		case EaseType.EaseOutCubic:
			result = EaseOutCubic;
			break;
		case EaseType.EaseInOutCubic:
			result = EaseInOutCubic;
			break;
		case EaseType.EaseInQuart:
			result = EaseInQuart;
			break;
		case EaseType.EaseOutQuart:
			result = EaseOutQuart;
			break;
		case EaseType.EaseInOutQuart:
			result = EaseInOutQuart;
			break;
		case EaseType.EaseInQuint:
			result = EaseInQuint;
			break;
		case EaseType.EaseOutQuint:
			result = EaseOutQuint;
			break;
		case EaseType.EaseInOutQuint:
			result = EaseInOutQuint;
			break;
		case EaseType.EaseInSine:
			result = EaseInSine;
			break;
		case EaseType.EaseOutSine:
			result = EaseOutSine;
			break;
		case EaseType.EaseInOutSine:
			result = EaseInOutSine;
			break;
		case EaseType.EaseInExpo:
			result = EaseInExpo;
			break;
		case EaseType.EaseOutExpo:
			result = EaseOutExpo;
			break;
		case EaseType.EaseInOutExpo:
			result = EaseInOutExpo;
			break;
		case EaseType.EaseInCirc:
			result = EaseInCirc;
			break;
		case EaseType.EaseOutCirc:
			result = EaseOutCirc;
			break;
		case EaseType.EaseInOutCirc:
			result = EaseInOutCirc;
			break;
		}
		return result;
	}

	public static IEnumerable<Vector3> NewBezier(Function ease, Transform[] nodes, float duration)
	{
		IEnumerable<float> steps = NewTimer(duration);
		return NewBezier<Transform>(ease, nodes, TransformDotPosition, duration, steps);
	}

	public static IEnumerable<Vector3> NewBezier(Function ease, Transform[] nodes, int slices)
	{
		IEnumerable<float> steps = NewCounter(0, slices + 1, 1);
		return NewBezier<Transform>(ease, nodes, TransformDotPosition, slices + 1, steps);
	}

	public static IEnumerable<Vector3> NewBezier(Function ease, Vector3[] points, float duration)
	{
		IEnumerable<float> steps = NewTimer(duration);
		return NewBezier<Vector3>(ease, points, Identity, duration, steps);
	}

	public static IEnumerable<Vector3> NewBezier(Function ease, Vector3[] points, int slices)
	{
		IEnumerable<float> steps = NewCounter(0, slices + 1, 1);
		return NewBezier<Vector3>(ease, points, Identity, slices + 1, steps);
	}

	private static IEnumerable<Vector3> NewBezier<T>(Function ease, IList nodes, ToVector3<T> toVector3, float maxStep, IEnumerable<float> steps)
	{
		if (nodes.Count < 2)
		{
			yield break;
		}
		Vector3[] points = new Vector3[nodes.Count];
		foreach (float step in steps)
		{
			for (int i = 0; i < nodes.Count; i++)
			{
				points[i] = toVector3((T)nodes[i]);
			}
			yield return Bezier(ease, points, step, maxStep);
		}
	}

	private static Vector3 Bezier(Function ease, Vector3[] points, float elapsedTime, float duration)
	{
		for (int num = points.Length - 1; num > 0; num--)
		{
			for (int i = 0; i < num; i++)
			{
				points[i].x = ease(points[i].x, points[i + 1].x - points[i].x, elapsedTime, duration);
				points[i].y = ease(points[i].y, points[i + 1].y - points[i].y, elapsedTime, duration);
				points[i].z = ease(points[i].z, points[i + 1].z - points[i].z, elapsedTime, duration);
			}
		}
		return points[0];
	}

	public static IEnumerable<Vector3> NewCatmullRom(Transform[] nodes, int slices, bool loop)
	{
		return NewCatmullRom<Transform>(nodes, TransformDotPosition, slices, loop);
	}

	public static IEnumerable<Vector3> NewCatmullRom(Vector3[] points, int slices, bool loop)
	{
		return NewCatmullRom<Vector3>(points, Identity, slices, loop);
	}

	private static IEnumerable<Vector3> NewCatmullRom<T>(IList nodes, ToVector3<T> toVector3, int slices, bool loop)
	{
		if (nodes.Count < 2)
		{
			yield break;
		}
		yield return toVector3((T)nodes[0]);
		int last = nodes.Count - 1;
		for (int current = 0; loop || current < last; current++)
		{
			if (loop && current > last)
			{
				current = 0;
			}
			int previous = ((current != 0) ? (current - 1) : (loop ? last : current));
			int start = current;
			int end = ((current != last) ? (current + 1) : ((!loop) ? current : 0));
			int next = ((end != last) ? (end + 1) : ((!loop) ? end : 0));
			int stepCount = slices + 1;
			for (int step = 1; step <= stepCount; step++)
			{
				yield return CatmullRom(toVector3((T)nodes[previous]), toVector3((T)nodes[start]), toVector3((T)nodes[end]), toVector3((T)nodes[next]), step, stepCount);
			}
		}
	}

	private static Vector3 CatmullRom(Vector3 previous, Vector3 start, Vector3 end, Vector3 next, float elapsedTime, float duration)
	{
		float num = elapsedTime / duration;
		float num2 = num * num;
		float num3 = num2 * num;
		return previous * (-0.5f * num3 + num2 - 0.5f * num) + start * (1.5f * num3 + -2.5f * num2 + 1f) + end * (-1.5f * num3 + 2f * num2 + 0.5f * num) + next * (0.5f * num3 - 0.5f * num2);
	}

	private static float Linear(float start, float distance, float elapsedTime, float duration)
	{
		if (elapsedTime > duration)
		{
			elapsedTime = duration;
		}
		return distance * (elapsedTime / duration) + start;
	}

	private static float EaseInQuad(float start, float distance, float elapsedTime, float duration)
	{
		elapsedTime = ((elapsedTime > duration) ? 1f : (elapsedTime / duration));
		return distance * elapsedTime * elapsedTime + start;
	}

	private static float EaseOutQuad(float start, float distance, float elapsedTime, float duration)
	{
		elapsedTime = ((elapsedTime > duration) ? 1f : (elapsedTime / duration));
		return (0f - distance) * elapsedTime * (elapsedTime - 2f) + start;
	}

	private static float EaseInOutQuad(float start, float distance, float elapsedTime, float duration)
	{
		elapsedTime = ((elapsedTime > duration) ? 2f : (elapsedTime / (duration / 2f)));
		if (elapsedTime < 1f)
		{
			return distance / 2f * elapsedTime * elapsedTime + start;
		}
		elapsedTime -= 1f;
		return (0f - distance) / 2f * (elapsedTime * (elapsedTime - 2f) - 1f) + start;
	}

	private static float EaseInCubic(float start, float distance, float elapsedTime, float duration)
	{
		elapsedTime = ((elapsedTime > duration) ? 1f : (elapsedTime / duration));
		return distance * elapsedTime * elapsedTime * elapsedTime + start;
	}

	private static float EaseOutCubic(float start, float distance, float elapsedTime, float duration)
	{
		elapsedTime = ((elapsedTime > duration) ? 1f : (elapsedTime / duration));
		elapsedTime -= 1f;
		return distance * (elapsedTime * elapsedTime * elapsedTime + 1f) + start;
	}

	private static float EaseInOutCubic(float start, float distance, float elapsedTime, float duration)
	{
		elapsedTime = ((elapsedTime > duration) ? 2f : (elapsedTime / (duration / 2f)));
		if (elapsedTime < 1f)
		{
			return distance / 2f * elapsedTime * elapsedTime * elapsedTime + start;
		}
		elapsedTime -= 2f;
		return distance / 2f * (elapsedTime * elapsedTime * elapsedTime + 2f) + start;
	}

	private static float EaseInQuart(float start, float distance, float elapsedTime, float duration)
	{
		elapsedTime = ((elapsedTime > duration) ? 1f : (elapsedTime / duration));
		return distance * elapsedTime * elapsedTime * elapsedTime * elapsedTime + start;
	}

	private static float EaseOutQuart(float start, float distance, float elapsedTime, float duration)
	{
		elapsedTime = ((elapsedTime > duration) ? 1f : (elapsedTime / duration));
		elapsedTime -= 1f;
		return (0f - distance) * (elapsedTime * elapsedTime * elapsedTime * elapsedTime - 1f) + start;
	}

	private static float EaseInOutQuart(float start, float distance, float elapsedTime, float duration)
	{
		elapsedTime = ((elapsedTime > duration) ? 2f : (elapsedTime / (duration / 2f)));
		if (elapsedTime < 1f)
		{
			return distance / 2f * elapsedTime * elapsedTime * elapsedTime * elapsedTime + start;
		}
		elapsedTime -= 2f;
		return (0f - distance) / 2f * (elapsedTime * elapsedTime * elapsedTime * elapsedTime - 2f) + start;
	}

	private static float EaseInQuint(float start, float distance, float elapsedTime, float duration)
	{
		elapsedTime = ((elapsedTime > duration) ? 1f : (elapsedTime / duration));
		return distance * elapsedTime * elapsedTime * elapsedTime * elapsedTime * elapsedTime + start;
	}

	private static float EaseOutQuint(float start, float distance, float elapsedTime, float duration)
	{
		elapsedTime = ((elapsedTime > duration) ? 1f : (elapsedTime / duration));
		elapsedTime -= 1f;
		return distance * (elapsedTime * elapsedTime * elapsedTime * elapsedTime * elapsedTime + 1f) + start;
	}

	private static float EaseInOutQuint(float start, float distance, float elapsedTime, float duration)
	{
		elapsedTime = ((elapsedTime > duration) ? 2f : (elapsedTime / (duration / 2f)));
		if (elapsedTime < 1f)
		{
			return distance / 2f * elapsedTime * elapsedTime * elapsedTime * elapsedTime * elapsedTime + start;
		}
		elapsedTime -= 2f;
		return distance / 2f * (elapsedTime * elapsedTime * elapsedTime * elapsedTime * elapsedTime + 2f) + start;
	}

	private static float EaseInSine(float start, float distance, float elapsedTime, float duration)
	{
		if (elapsedTime > duration)
		{
			elapsedTime = duration;
		}
		return (0f - distance) * Mathf.Cos(elapsedTime / duration * ((float)Math.PI / 2f)) + distance + start;
	}

	private static float EaseOutSine(float start, float distance, float elapsedTime, float duration)
	{
		if (elapsedTime > duration)
		{
			elapsedTime = duration;
		}
		return distance * Mathf.Sin(elapsedTime / duration * ((float)Math.PI / 2f)) + start;
	}

	private static float EaseInOutSine(float start, float distance, float elapsedTime, float duration)
	{
		if (elapsedTime > duration)
		{
			elapsedTime = duration;
		}
		return (0f - distance) / 2f * (Mathf.Cos((float)Math.PI * elapsedTime / duration) - 1f) + start;
	}

	private static float EaseInExpo(float start, float distance, float elapsedTime, float duration)
	{
		if (elapsedTime > duration)
		{
			elapsedTime = duration;
		}
		return distance * Mathf.Pow(2f, 10f * (elapsedTime / duration - 1f)) + start;
	}

	private static float EaseOutExpo(float start, float distance, float elapsedTime, float duration)
	{
		if (elapsedTime > duration)
		{
			elapsedTime = duration;
		}
		return distance * (0f - Mathf.Pow(2f, -10f * elapsedTime / duration) + 1f) + start;
	}

	private static float EaseInOutExpo(float start, float distance, float elapsedTime, float duration)
	{
		elapsedTime = ((elapsedTime > duration) ? 2f : (elapsedTime / (duration / 2f)));
		if (elapsedTime < 1f)
		{
			return distance / 2f * Mathf.Pow(2f, 10f * (elapsedTime - 1f)) + start;
		}
		elapsedTime -= 1f;
		return distance / 2f * (0f - Mathf.Pow(2f, -10f * elapsedTime) + 2f) + start;
	}

	private static float EaseInCirc(float start, float distance, float elapsedTime, float duration)
	{
		elapsedTime = ((elapsedTime > duration) ? 1f : (elapsedTime / duration));
		return (0f - distance) * (Mathf.Sqrt(1f - elapsedTime * elapsedTime) - 1f) + start;
	}

	private static float EaseOutCirc(float start, float distance, float elapsedTime, float duration)
	{
		elapsedTime = ((elapsedTime > duration) ? 1f : (elapsedTime / duration));
		elapsedTime -= 1f;
		return distance * Mathf.Sqrt(1f - elapsedTime * elapsedTime) + start;
	}

	private static float EaseInOutCirc(float start, float distance, float elapsedTime, float duration)
	{
		elapsedTime = ((elapsedTime > duration) ? 2f : (elapsedTime / (duration / 2f)));
		if (elapsedTime < 1f)
		{
			return (0f - distance) / 2f * (Mathf.Sqrt(1f - elapsedTime * elapsedTime) - 1f) + start;
		}
		elapsedTime -= 2f;
		return distance / 2f * (Mathf.Sqrt(1f - elapsedTime * elapsedTime) + 1f) + start;
	}
}
public class MeleeWeaponTrail : MonoBehaviour
{
	[Serializable]
	public class Point
	{
		public float timeCreated;

		public Vector3 basePosition;

		public Vector3 tipPosition;
	}

	[SerializeField]
	private bool _emit = true;

	private bool _use = true;

	[SerializeField]
	private float _emitTime;

	[SerializeField]
	private Material _material;

	[SerializeField]
	private float _lifeTime = 1f;

	[SerializeField]
	private Color[] _colors;

	[SerializeField]
	private float[] _sizes;

	[SerializeField]
	private float _minVertexDistance = 0.1f;

	[SerializeField]
	private float _maxVertexDistance = 10f;

	private float _minVertexDistanceSqr;

	private float _maxVertexDistanceSqr;

	[SerializeField]
	private float _maxAngle = 3f;

	[SerializeField]
	private bool _autoDestruct;

	[SerializeField]
	private int subdivisions = 4;

	[SerializeField]
	private Transform _base;

	[SerializeField]
	private Transform _tip;

	private List<Point> _points = new List<Point>();

	private List<Point> _smoothedPoints = new List<Point>();

	private GameObject _trailObject;

	private Mesh _trailMesh;

	private Vector3 _lastPosition;

	public bool Emit
	{
		set
		{
			_emit = value;
		}
	}

	public bool Use
	{
		set
		{
			_use = value;
		}
	}

	private void Start()
	{
		_lastPosition = base.transform.position;
		_trailObject = new GameObject("Trail");
		_trailObject.transform.parent = null;
		_trailObject.transform.position = Vector3.zero;
		_trailObject.transform.rotation = Quaternion.identity;
		_trailObject.transform.localScale = Vector3.one;
		_trailObject.AddComponent(typeof(MeshFilter));
		_trailObject.AddComponent(typeof(MeshRenderer));
		_trailObject.GetComponent<Renderer>().material = _material;
		_trailMesh = new Mesh();
		_trailMesh.name = base.name + "TrailMesh";
		_trailObject.GetComponent<MeshFilter>().mesh = _trailMesh;
		_minVertexDistanceSqr = _minVertexDistance * _minVertexDistance;
		_maxVertexDistanceSqr = _maxVertexDistance * _maxVertexDistance;
	}

	private void OnDisable()
	{
		UnityEngine.Object.Destroy(_trailObject);
	}

	private void Update()
	{
		if (!_use)
		{
			return;
		}
		if (_emit && _emitTime != 0f)
		{
			_emitTime -= Time.deltaTime;
			if (_emitTime == 0f)
			{
				_emitTime = -1f;
			}
			if (_emitTime < 0f)
			{
				_emit = false;
			}
		}
		if (!_emit && _points.Count == 0 && _autoDestruct)
		{
			UnityEngine.Object.Destroy(_trailObject);
			UnityEngine.Object.Destroy(base.gameObject);
		}
		if (!Camera.main)
		{
			return;
		}
		float sqrMagnitude = (_lastPosition - base.transform.position).sqrMagnitude;
		if (_emit)
		{
			if (sqrMagnitude > _minVertexDistanceSqr)
			{
				bool flag = false;
				if (_points.Count < 3)
				{
					flag = true;
				}
				else
				{
					Vector3 from = _points[_points.Count - 2].tipPosition - _points[_points.Count - 3].tipPosition;
					Vector3 to = _points[_points.Count - 1].tipPosition - _points[_points.Count - 2].tipPosition;
					if (Vector3.Angle(from, to) > _maxAngle || sqrMagnitude > _maxVertexDistanceSqr)
					{
						flag = true;
					}
				}
				if (flag)
				{
					Point point = new Point();
					point.basePosition = _base.position;
					point.tipPosition = _tip.position;
					point.timeCreated = Time.time;
					_points.Add(point);
					_lastPosition = base.transform.position;
					if (_points.Count == 1)
					{
						_smoothedPoints.Add(point);
					}
					else if (_points.Count > 1)
					{
						for (int i = 0; i < 1 + subdivisions; i++)
						{
							_smoothedPoints.Add(point);
						}
					}
					if (_points.Count >= 4)
					{
						IEnumerable<Vector3> collection = Interpolate.NewCatmullRom(new Vector3[4]
						{
							_points[_points.Count - 4].tipPosition,
							_points[_points.Count - 3].tipPosition,
							_points[_points.Count - 2].tipPosition,
							_points[_points.Count - 1].tipPosition
						}, subdivisions, loop: false);
						IEnumerable<Vector3> collection2 = Interpolate.NewCatmullRom(new Vector3[4]
						{
							_points[_points.Count - 4].basePosition,
							_points[_points.Count - 3].basePosition,
							_points[_points.Count - 2].basePosition,
							_points[_points.Count - 1].basePosition
						}, subdivisions, loop: false);
						List<Vector3> list = new List<Vector3>(collection);
						List<Vector3> list2 = new List<Vector3>(collection2);
						float timeCreated = _points[_points.Count - 4].timeCreated;
						float timeCreated2 = _points[_points.Count - 1].timeCreated;
						for (int j = 0; j < list.Count; j++)
						{
							int num = _smoothedPoints.Count - (list.Count - j);
							if (num > -1 && num < _smoothedPoints.Count)
							{
								Point point2 = new Point();
								point2.basePosition = list2[j];
								point2.tipPosition = list[j];
								point2.timeCreated = Mathf.Lerp(timeCreated, timeCreated2, (float)j / (float)list.Count);
								_smoothedPoints[num] = point2;
							}
						}
					}
				}
				else
				{
					_points[_points.Count - 1].basePosition = _base.position;
					_points[_points.Count - 1].tipPosition = _tip.position;
					_smoothedPoints[_smoothedPoints.Count - 1].basePosition = _base.position;
					_smoothedPoints[_smoothedPoints.Count - 1].tipPosition = _tip.position;
				}
			}
			else
			{
				if (_points.Count > 0)
				{
					_points[_points.Count - 1].basePosition = _base.position;
					_points[_points.Count - 1].tipPosition = _tip.position;
				}
				if (_smoothedPoints.Count > 0)
				{
					_smoothedPoints[_smoothedPoints.Count - 1].basePosition = _base.position;
					_smoothedPoints[_smoothedPoints.Count - 1].tipPosition = _tip.position;
				}
			}
		}
		RemoveOldPoints(_points);
		if (_points.Count == 0)
		{
			_trailMesh.Clear();
		}
		RemoveOldPoints(_smoothedPoints);
		if (_smoothedPoints.Count == 0)
		{
			_trailMesh.Clear();
		}
		List<Point> smoothedPoints = _smoothedPoints;
		if (smoothedPoints.Count <= 1)
		{
			return;
		}
		Vector3[] array = new Vector3[smoothedPoints.Count * 2];
		Vector2[] array2 = new Vector2[smoothedPoints.Count * 2];
		int[] array3 = new int[(smoothedPoints.Count - 1) * 6];
		Color[] array4 = new Color[smoothedPoints.Count * 2];
		for (int k = 0; k < smoothedPoints.Count; k++)
		{
			Point point3 = smoothedPoints[k];
			float num2 = (Time.time - point3.timeCreated) / _lifeTime;
			Color color = Color.Lerp(Color.white, Color.clear, num2);
			if (_colors != null && _colors.Length != 0)
			{
				float num3 = num2 * (float)(_colors.Length - 1);
				float num4 = Mathf.Floor(num3);
				float num5 = Mathf.Clamp(Mathf.Ceil(num3), 1f, _colors.Length - 1);
				float t = Mathf.InverseLerp(num4, num5, num3);
				if (num4 >= (float)_colors.Length)
				{
					num4 = _colors.Length - 1;
				}
				if (num4 < 0f)
				{
					num4 = 0f;
				}
				if (num5 >= (float)_colors.Length)
				{
					num5 = _colors.Length - 1;
				}
				if (num5 < 0f)
				{
					num5 = 0f;
				}
				color = Color.Lerp(_colors[(int)num4], _colors[(int)num5], t);
			}
			float num6 = 0f;
			if (_sizes != null && _sizes.Length != 0)
			{
				float num7 = num2 * (float)(_sizes.Length - 1);
				float num8 = Mathf.Floor(num7);
				float num9 = Mathf.Clamp(Mathf.Ceil(num7), 1f, _sizes.Length - 1);
				float t2 = Mathf.InverseLerp(num8, num9, num7);
				if (num8 >= (float)_sizes.Length)
				{
					num8 = _sizes.Length - 1;
				}
				if (num8 < 0f)
				{
					num8 = 0f;
				}
				if (num9 >= (float)_sizes.Length)
				{
					num9 = _sizes.Length - 1;
				}
				if (num9 < 0f)
				{
					num9 = 0f;
				}
				num6 = Mathf.Lerp(_sizes[(int)num8], _sizes[(int)num9], t2);
			}
			Vector3 vector = point3.tipPosition - point3.basePosition;
			array[k * 2] = point3.basePosition - vector * (num6 * 0.5f);
			array[k * 2 + 1] = point3.tipPosition + vector * (num6 * 0.5f);
			array4[k * 2] = (array4[k * 2 + 1] = color);
			float x = (float)k / (float)smoothedPoints.Count;
			array2[k * 2] = new Vector2(x, 0f);
			array2[k * 2 + 1] = new Vector2(x, 1f);
			if (k > 0)
			{
				array3[(k - 1) * 6] = k * 2 - 2;
				array3[(k - 1) * 6 + 1] = k * 2 - 1;
				array3[(k - 1) * 6 + 2] = k * 2;
				array3[(k - 1) * 6 + 3] = k * 2 + 1;
				array3[(k - 1) * 6 + 4] = k * 2;
				array3[(k - 1) * 6 + 5] = k * 2 - 1;
			}
		}
		_trailMesh.Clear();
		_trailMesh.vertices = array;
		_trailMesh.colors = array4;
		_trailMesh.uv = array2;
		_trailMesh.triangles = array3;
	}

	private void RemoveOldPoints(List<Point> pointList)
	{
		List<Point> list = new List<Point>();
		foreach (Point point in pointList)
		{
			if (Time.time - point.timeCreated > _lifeTime)
			{
				list.Add(point);
			}
		}
		foreach (Point item in list)
		{
			pointList.Remove(item);
		}
	}
}
public class BallBirthTest : MonoBehaviour
{
	public string mapName = "1";

	public float mass = 1f;

	public int force = 500;

	private Transform curMapTra;

	private Transform curStartPoint;

	private void Start()
	{
		GameObject gameObject = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("Prefabs/Maps/M" + mapName), base.transform);
		curMapTra = gameObject.transform;
		curStartPoint = curMapTra.Find("StartPoint");
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.Space))
		{
			GameObject obj = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("Prefabs/AllBall"), curMapTra);
			obj.transform.localPosition = curStartPoint.localPosition;
			Rigidbody component = obj.GetComponent<Rigidbody>();
			component.mass = mass;
			component.AddForce(-curStartPoint.right * force);
		}
	}
}
public class MouseOrbitDemo : MonoBehaviour
{
	public Transform target;

	public float distance = 8f;

	public float xSpeed = 250f;

	public float ySpeed = 120f;

	public float yMinLimit = -90f;

	public float yMaxLimit = 90f;

	private float x;

	private float y;

	private void Start()
	{
		Vector3 eulerAngles = base.transform.eulerAngles;
		x = eulerAngles.y;
		y = eulerAngles.x;
		if ((bool)GetComponent<Rigidbody>())
		{
			GetComponent<Rigidbody>().freezeRotation = true;
		}
	}

	private void LateUpdate()
	{
		if ((bool)target)
		{
			x += Input.GetAxis("Mouse X") * xSpeed * 0.02f;
			y -= Input.GetAxis("Mouse Y") * ySpeed * 0.02f;
			y = ClampAngle(y, yMinLimit, yMaxLimit);
			Quaternion quaternion = Quaternion.Euler(y, x, 0f);
			Vector3 position = quaternion * new Vector3(0f, 0f, 0f - distance) + target.position;
			base.transform.rotation = quaternion;
			base.transform.position = position;
		}
	}

	private static float ClampAngle(float angle, float min, float max)
	{
		if (angle < -360f)
		{
			angle += 360f;
		}
		if (angle > 360f)
		{
			angle -= 360f;
		}
		return Mathf.Clamp(angle, min, max);
	}
}
[ExecuteInEditMode]
[RequireComponent(typeof(Camera))]
[AddComponentMenu("V-Lights/VLight Image Effects")]
public class VLightInterleavedSampling : MonoBehaviour
{
	public static bool renderingInterleaved;

	public static bool lightsModified;

	[SerializeField]
	[Header("Reduces banding. Requires floating point textures support.")]
	private bool _useHighPrecisionFrameBuffer;

	[SerializeField]
	[Header("Min pixel width to use interleaved")]
	private int minInterleavedRes = 128;

	[SerializeField]
	private bool useInterleavedSampling = true;

	[SerializeField]
	private float ditherOffset = 0.02f;

	[SerializeField]
	private float blurRadius = 1.5f;

	[SerializeField]
	private int blurIterations = 1;

	[SerializeField]
	[Header("Locked to 2 when using Bilateral filtering")]
	private int downSample = 4;

	[SerializeField]
	private Shader postEffectShader;

	[SerializeField]
	private Shader volumeLightShader;

	[Header("Reduce edge bleeding at a cost to performance")]
	[SerializeField]
	private bool _useBilateralFiltering;

	[SerializeField]
	private Shader _downScaleDepthShader;

	[SerializeField]
	private float _depthThreshold = 0.01f;

	[SerializeField]
	private float _blurDepth = 100f;

	private Camera _ppCameraGO;

	private LayerMask _volumeLightLayer;

	private RenderTexture interleavedBuffer;

	private VLight[] _vlights;

	private Material _postMaterial;

	private Material _downscaleDepthMaterial;

	private Camera _camera;

	public static int renderCount;

	private Material PostMaterial
	{
		get
		{
			if (_postMaterial == null)
			{
				_postMaterial = new Material(postEffectShader);
				_postMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return _postMaterial;
		}
	}

	private Material DownscaleDepthMaterial
	{
		get
		{
			if (_downscaleDepthMaterial == null)
			{
				_downscaleDepthMaterial = new Material(_downScaleDepthShader);
				_downscaleDepthMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return _downscaleDepthMaterial;
		}
	}

	private Camera cam
	{
		get
		{
			if (_camera == null)
			{
				_camera = GetComponent<Camera>();
			}
			return _camera;
		}
	}

	private void OnEnable()
	{
		Init();
	}

	private void OnDisable()
	{
		CleanUp();
	}

	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		Camera current = Camera.current;
		Plane[] planes = GeometryUtility.CalculateFrustumPlanes(current);
		if (!Application.isPlaying)
		{
			_vlights = UnityEngine.Object.FindObjectsOfType<VLight>();
		}
		if (lightsModified)
		{
			lightsModified = false;
			_vlights = UnityEngine.Object.FindObjectsOfType<VLight>();
		}
		Bounds b = default(Bounds);
		bool flag = false;
		bool flag2 = false;
		for (int i = 0; i < _vlights.Length; i++)
		{
			VLight vLight = _vlights[i];
			if (GeometryUtility.TestPlanesAABB(planes, vLight.MeshRender.bounds))
			{
				b.max = current.cameraToWorldMatrix.MultiplyPoint(vLight.MaxBounds);
				b.min = current.cameraToWorldMatrix.MultiplyPoint(vLight.MinBounds);
				Rect rect = VLightGeometryUtil.BoundsToRect(b, current);
				if (rect.width * rect.height > (float)(minInterleavedRes * minInterleavedRes))
				{
					flag2 = true;
				}
				flag = true;
			}
		}
		if (!flag)
		{
			Graphics.Blit(source, destination);
			return;
		}
		int num = Mathf.Clamp(downSample, 1, 20);
		blurIterations = Mathf.Clamp(blurIterations, 0, 20);
		if (_useBilateralFiltering)
		{
			num = 2;
		}
		int pixelWidth = current.pixelWidth;
		int pixelHeight = current.pixelHeight;
		int width = current.pixelWidth / num;
		int height = current.pixelHeight / num;
		RenderTextureFormat format = (_useHighPrecisionFrameBuffer ? RenderTextureFormat.ARGBFloat : RenderTextureFormat.ARGB32);
		RenderTexture temporary = RenderTexture.GetTemporary(width, height, 0, format);
		if (interleavedBuffer != null && (interleavedBuffer.width != pixelWidth || interleavedBuffer.height != pixelHeight))
		{
			if (Application.isPlaying)
			{
				UnityEngine.Object.Destroy(interleavedBuffer);
			}
			else
			{
				UnityEngine.Object.DestroyImmediate(interleavedBuffer);
			}
			interleavedBuffer = null;
		}
		if (interleavedBuffer == null)
		{
			interleavedBuffer = new RenderTexture(pixelWidth, pixelHeight, 0);
			interleavedBuffer.hideFlags = HideFlags.HideAndDontSave;
		}
		Camera pPCamera = GetPPCamera();
		pPCamera.CopyFrom(current);
		pPCamera.enabled = false;
		pPCamera.depthTextureMode = DepthTextureMode.None;
		pPCamera.clearFlags = CameraClearFlags.Color;
		pPCamera.cullingMask = _volumeLightLayer;
		pPCamera.useOcclusionCulling = false;
		pPCamera.backgroundColor = Color.clear;
		pPCamera.renderingPath = RenderingPath.VertexLit;
		renderingInterleaved = false;
		if (useInterleavedSampling && flag2)
		{
			RenderTexture temporary2 = RenderTexture.GetTemporary(width, height, 0, format);
			RenderTexture temporary3 = RenderTexture.GetTemporary(width, height, 0, format);
			RenderTexture temporary4 = RenderTexture.GetTemporary(width, height, 0, format);
			pPCamera.projectionMatrix = current.projectionMatrix;
			pPCamera.pixelRect = new Rect(0f, 0f, (float)current.pixelWidth / current.rect.width + (float)Screen.width / current.rect.width, (float)current.pixelHeight / current.rect.height + (float)Screen.height / current.rect.height);
			float num2 = 0f;
			renderCount = 0;
			RenderSample(num2, pPCamera, temporary);
			if (renderCount == 0)
			{
				Graphics.Blit(source, destination);
				RenderTexture.ReleaseTemporary(temporary);
				RenderTexture.ReleaseTemporary(temporary2);
				RenderTexture.ReleaseTemporary(temporary3);
				RenderTexture.ReleaseTemporary(temporary4);
				return;
			}
			renderingInterleaved = true;
			num2 += ditherOffset;
			RenderSample(num2, pPCamera, temporary2);
			num2 += ditherOffset;
			RenderSample(num2, pPCamera, temporary3);
			num2 += ditherOffset;
			RenderSample(num2, pPCamera, temporary4);
			PostMaterial.SetTexture("_MainTexA", temporary);
			PostMaterial.SetTexture("_MainTexB", temporary2);
			PostMaterial.SetTexture("_MainTexC", temporary3);
			PostMaterial.SetTexture("_MainTexD", temporary4);
			interleavedBuffer.DiscardContents();
			Graphics.Blit(null, interleavedBuffer, PostMaterial, 0);
			RenderTexture.ReleaseTemporary(temporary2);
			RenderTexture.ReleaseTemporary(temporary3);
			RenderTexture.ReleaseTemporary(temporary4);
		}
		else
		{
			pPCamera.projectionMatrix = current.projectionMatrix;
			pPCamera.pixelRect = new Rect(0f, 0f, (float)current.pixelWidth / current.rect.width + (float)Screen.width / current.rect.width, (float)current.pixelHeight / current.rect.height + (float)Screen.height / current.rect.height);
			renderCount = 0;
			RenderSample(0f, pPCamera, temporary);
			if (renderCount == 0)
			{
				Graphics.Blit(source, destination);
				RenderTexture.ReleaseTemporary(temporary);
				return;
			}
			Graphics.Blit(temporary, interleavedBuffer);
		}
		renderingInterleaved = false;
		RenderTexture temporary5 = RenderTexture.GetTemporary(pixelWidth, pixelHeight, 0);
		temporary5.DiscardContents();
		PostMaterial.SetFloat("_BlurSize", blurRadius);
		if (_useBilateralFiltering)
		{
			RenderTexture temporary6 = RenderTexture.GetTemporary(width, height, 0, RenderTextureFormat.ARGB32, RenderTextureReadWrite.Linear, 1);
			temporary6.wrapMode = TextureWrapMode.Clamp;
			Graphics.Blit(source, temporary6, DownscaleDepthMaterial);
			PostMaterial.SetFloat("BlurDepthFalloff", _blurDepth);
			PostMaterial.SetTexture("LowResDepthTexture", temporary6);
			for (int j = 0; j < blurIterations; j++)
			{
				PostMaterial.SetVector("BlurDir", new Vector2(0f, blurRadius));
				Graphics.Blit(interleavedBuffer, temporary5, PostMaterial, 4);
				PostMaterial.SetVector("BlurDir", new Vector2(blurRadius, 0f));
				Graphics.Blit(temporary5, interleavedBuffer, PostMaterial, 4);
				PostMaterial.SetVector("BlurDir", new Vector2(0f, blurRadius));
				Graphics.Blit(interleavedBuffer, temporary5, PostMaterial, 4);
				PostMaterial.SetVector("BlurDir", new Vector2(blurRadius, 0f));
				Graphics.Blit(temporary5, interleavedBuffer, PostMaterial, 4);
			}
			RenderTexture.ReleaseTemporary(temporary5);
			RenderTexture.ReleaseTemporary(temporary);
			PostMaterial.SetFloat("DepthThreshold", _depthThreshold);
			RenderTexture temporary7 = RenderTexture.GetTemporary(width, height, 0, RenderTextureFormat.ARGB32);
			Graphics.Blit(interleavedBuffer, temporary7);
			temporary7.filterMode = FilterMode.Point;
			PostMaterial.SetTexture("_MainTexBlurred", interleavedBuffer);
			PostMaterial.SetTexture("_MainTexBlurredPoint", temporary7);
			Graphics.Blit(source, destination, PostMaterial, 3);
			RenderTexture.ReleaseTemporary(temporary7);
			RenderTexture.ReleaseTemporary(temporary6);
		}
		else
		{
			for (int k = 0; k < blurIterations; k++)
			{
				Graphics.Blit(interleavedBuffer, temporary5, PostMaterial, 1);
				interleavedBuffer.DiscardContents();
				Graphics.Blit(temporary5, interleavedBuffer, PostMaterial, 2);
				temporary5.DiscardContents();
			}
			PostMaterial.SetTexture("_MainTexBlurred", interleavedBuffer);
			Graphics.Blit(source, destination, PostMaterial, 5);
			RenderTexture.ReleaseTemporary(temporary5);
			RenderTexture.ReleaseTemporary(temporary);
		}
	}

	private void RenderSample(float offset, Camera ppCamera, RenderTexture buffer)
	{
		Shader.SetGlobalFloat("_InterleavedOffset", offset);
		ppCamera.targetTexture = buffer;
		ppCamera.SetReplacementShader(volumeLightShader, "RenderType");
		ppCamera.Render();
	}

	private void Init()
	{
		if (LayerMask.NameToLayer("vlight") == -1)
		{
			UnityEngine.Debug.LogWarning("vlight layer does not exist! Cannot use interleaved sampling please add this layer.");
			return;
		}
		if (!SystemInfo.supportsImageEffects)
		{
			UnityEngine.Debug.LogWarning("Cannot use interleaved sampling. Image effects not supported");
			return;
		}
		_volumeLightLayer = 1 << LayerMask.NameToLayer("vlight");
		cam.cullingMask &= ~(int)_volumeLightLayer;
		cam.depthTextureMode |= DepthTextureMode.Depth;
		if (_downScaleDepthShader == null)
		{
			_downScaleDepthShader = Shader.Find("Hidden/V-Light/Downscale Depth");
		}
		if (postEffectShader == null)
		{
			postEffectShader = Shader.Find("Hidden/V-Light/Post");
		}
		if (volumeLightShader == null)
		{
			volumeLightShader = Shader.Find("V-Light/Volumetric Light Depth");
		}
		_vlights = UnityEngine.Object.FindObjectsOfType<VLight>();
	}

	private void CleanUp()
	{
		cam.cullingMask |= _volumeLightLayer;
		if (Application.isEditor)
		{
			UnityEngine.Object.DestroyImmediate(_downscaleDepthMaterial);
			UnityEngine.Object.DestroyImmediate(_postMaterial);
			if (interleavedBuffer != null)
			{
				UnityEngine.Object.DestroyImmediate(interleavedBuffer);
			}
		}
		else
		{
			UnityEngine.Object.Destroy(_downscaleDepthMaterial);
			UnityEngine.Object.Destroy(_postMaterial);
			if (interleavedBuffer != null)
			{
				UnityEngine.Object.Destroy(interleavedBuffer);
			}
		}
	}

	private Camera GetPPCamera()
	{
		if (_ppCameraGO == null)
		{
			GameObject gameObject = GameObject.Find("Post Processing Camera");
			if (gameObject != null && gameObject.GetComponent<Camera>() != null)
			{
				_ppCameraGO = gameObject.GetComponent<Camera>();
				_ppCameraGO.useOcclusionCulling = false;
			}
			else
			{
				GameObject gameObject2 = new GameObject("Post Processing Camera");
				_ppCameraGO = gameObject2.AddComponent<Camera>();
				_ppCameraGO.useOcclusionCulling = false;
				_ppCameraGO.enabled = false;
				gameObject2.hideFlags = HideFlags.HideAndDontSave;
			}
		}
		return _ppCameraGO;
	}
}
public static class VLightGeometryUtil
{
	private static Vector3[] _outputList = new Vector3[20];

	private static Vector3[] _inputList = new Vector3[20];

	private static Vector3[] _cachedPoints = new Vector3[8];

	private static Vector3[] _cachedScreenPoints = new Vector3[8];

	private static Rect _cachedRect = default(Rect);

	public static void RecalculateFrustrumPoints(bool ortho, float orthographicSize, float fieldOfView, float near, float far, float aspectRatio, out Vector3[] _frustrumPoints)
	{
		if (!ortho)
		{
			float num = 2f * Mathf.Tan(fieldOfView * 0.5f * ((float)Math.PI / 180f)) * near;
			float num2 = num * aspectRatio;
			float num3 = 2f * Mathf.Tan(fieldOfView * 0.5f * ((float)Math.PI / 180f)) * far;
			float num4 = num3 * aspectRatio;
			Vector3 vector = Vector3.forward * far;
			Vector3 vector2 = vector + Vector3.up * num3 / 2f - Vector3.right * num4 / 2f;
			Vector3 vector3 = vector + Vector3.up * num3 / 2f + Vector3.right * num4 / 2f;
			Vector3 vector4 = vector - Vector3.up * num3 / 2f - Vector3.right * num4 / 2f;
			Vector3 vector5 = vector - Vector3.up * num3 / 2f + Vector3.right * num4 / 2f;
			Vector3 vector6 = Vector3.forward * near;
			Vector3 vector7 = vector6 + Vector3.up * num / 2f - Vector3.right * num2 / 2f;
			Vector3 vector8 = vector6 + Vector3.up * num / 2f + Vector3.right * num2 / 2f;
			Vector3 vector9 = vector6 - Vector3.up * num / 2f - Vector3.right * num2 / 2f;
			Vector3 vector10 = vector6 - Vector3.up * num / 2f + Vector3.right * num2 / 2f;
			_frustrumPoints = new Vector3[8];
			_frustrumPoints[0] = vector7;
			_frustrumPoints[1] = vector2;
			_frustrumPoints[2] = vector8;
			_frustrumPoints[3] = vector3;
			_frustrumPoints[4] = vector9;
			_frustrumPoints[5] = vector4;
			_frustrumPoints[6] = vector10;
			_frustrumPoints[7] = vector5;
		}
		else
		{
			float num5 = orthographicSize * aspectRatio;
			_frustrumPoints = new Vector3[8];
			_frustrumPoints[0] = new Vector3(0f - num5, orthographicSize, near);
			_frustrumPoints[1] = new Vector3(0f - num5, orthographicSize, far);
			_frustrumPoints[2] = new Vector3(num5, orthographicSize, near);
			_frustrumPoints[3] = new Vector3(num5, orthographicSize, far);
			_frustrumPoints[4] = new Vector3(0f - num5, 0f - orthographicSize, near);
			_frustrumPoints[5] = new Vector3(0f - num5, 0f - orthographicSize, far);
			_frustrumPoints[6] = new Vector3(num5, 0f - orthographicSize, near);
			_frustrumPoints[7] = new Vector3(num5, 0f - orthographicSize, far);
		}
	}

	public static Vector3[] ClipPolygonAgainstPlane(Vector3[] subjectPolygon, Plane[] planes)
	{
		int num = 0;
		int num2 = 0;
		Array.Copy(subjectPolygon, _outputList, subjectPolygon.Length);
		num = subjectPolygon.Length;
		for (int i = 0; i < planes.Length; i++)
		{
			Plane plane = planes[i];
			Array.Copy(_outputList, _inputList, num);
			num2 = num;
			num = 0;
			if (num2 == 0)
			{
				continue;
			}
			Vector3 vector = _inputList[num2 - 1];
			for (int j = 0; j < num2; j++)
			{
				Vector3 vector2 = _inputList[j];
				bool side = plane.GetSide(vector2);
				bool side2 = plane.GetSide(vector);
				if (side)
				{
					if (!side2 && ComputeIntersection(vector, vector2, plane, 0f, out var result))
					{
						_outputList[num++] = result;
					}
					_outputList[num++] = vector2;
				}
				else if (side2)
				{
					if (ComputeIntersection(vector, vector2, plane, 0f, out var result2))
					{
						_outputList[num++] = result2;
					}
					else
					{
						_outputList[num++] = vector2;
					}
				}
				vector = vector2;
			}
		}
		Vector3[] array = new Vector3[num];
		Array.Copy(_outputList, array, num);
		return array;
	}

	public static bool ComputeIntersection(Vector3 start, Vector3 end, Plane plane, float e, out Vector3 result)
	{
		Vector3 rhs = start - end;
		float num = Vector3.Dot(plane.normal, start) + plane.distance;
		float num2 = Vector3.Dot(plane.normal, rhs);
		float num3 = num / num2;
		if (Mathf.Abs(num3) < e)
		{
			result = Vector3.zero;
		}
		else
		{
			if (num3 > 0f && num3 < 1f)
			{
				result = (end - start) * num3 + start;
				return true;
			}
			result = Vector3.zero;
		}
		return false;
	}

	public static Vector4 Vector4Multiply(Vector4 right, Vector4 left)
	{
		return new Vector4(right.x * left.x, right.y * left.y, right.z * left.z, right.w * left.w);
	}

	public static Vector4 Vector4Frac(Vector4 vector)
	{
		return new Vector4(Frac(vector.x), Frac(vector.y), Frac(vector.z), Frac(vector.w));
	}

	public static float Frac(float value)
	{
		return value - (float)Mathf.FloorToInt(value);
	}

	public static Color FloatToRGBA(float value)
	{
		Vector4 vector = new Vector4(1f, 255f, 65025f, 160581380f) * value;
		vector = Vector4Frac(vector);
		vector -= Vector4Multiply(new Vector4(vector.y, vector.z, vector.w, vector.w), new Vector4(0.003921569f, 0.003921569f, 0.003921569f, 0f));
		return vector;
	}

	public static Rect BoundsToRect(Bounds b, Camera camera)
	{
		_cachedPoints[0] = new Vector3(b.min.x, b.min.y, b.min.z);
		_cachedPoints[1] = new Vector3(b.max.x, b.min.y, b.min.z);
		_cachedPoints[2] = new Vector3(b.max.x, b.max.y, b.min.z);
		_cachedPoints[3] = new Vector3(b.min.x, b.max.y, b.min.z);
		_cachedPoints[4] = new Vector3(b.min.x, b.min.y, b.max.z);
		_cachedPoints[5] = new Vector3(b.max.x, b.min.y, b.max.z);
		_cachedPoints[6] = new Vector3(b.max.x, b.max.y, b.max.z);
		_cachedPoints[7] = new Vector3(b.min.x, b.max.y, b.max.z);
		Bounds bounds = default(Bounds);
		for (int i = 0; i < 8; i++)
		{
			_cachedScreenPoints[i] = camera.WorldToScreenPoint(_cachedPoints[i]);
			if (i == 0)
			{
				bounds = new Bounds(_cachedScreenPoints[0], Vector3.zero);
			}
			bounds.Encapsulate(_cachedScreenPoints[i]);
		}
		_cachedRect.xMin = bounds.min.x;
		_cachedRect.yMin = bounds.min.y;
		_cachedRect.xMax = bounds.max.x;
		_cachedRect.yMax = bounds.max.y;
		return _cachedRect;
	}
}
[ExecuteInEditMode]
[RequireComponent(typeof(Camera))]
[RequireComponent(typeof(MeshRenderer))]
[RequireComponent(typeof(MeshFilter))]
[HelpURL("http://vlights-system.blogspot.com.au/p/documentation_15.html")]
public class VLight : MonoBehaviour
{
	public enum VolumeShape
	{
		Cube,
		Sphere,
		RoundedCube,
		Cylinder
	}

	public enum ShadowMode
	{
		None,
		Realtime,
		Baked
	}

	public enum LightTypes
	{
		Spot,
		Point,
		Area,
		Orthographic
	}

	private const int GRADIENT_SIZE = 128;

	[HideInInspector]
	public bool lockTransforms;

	[HideInInspector]
	[SerializeField]
	public bool renderWireFrame;

	[Space(20f, order = 0)]
	[Header("==== General light settings ====", order = 1)]
	public LightTypes lightType;

	public float lightMultiplier = 1f;

	public float spotExponent = 1f;

	public float constantAttenuation = 1f;

	public float linearAttenuation = 10f;

	public float quadraticAttenuation = 100f;

	public float aspect = 1f;

	[Header("- only be changed when not playing -")]
	[Range(2f, 200f)]
	public int slices = 30;

	public Color colorTint = Color.white;

	[Tooltip("- scrolling noise and volume texture -")]
	public Vector3 noiseSpeed;

	[SerializeField]
	[Tooltip("- applies a dither pattern to reduce undersampling -")]
	private bool useDithering;

	[SerializeField]
	[Range(-200f, 200f)]
	private float ditherAmount;

	[SerializeField]
	[Tooltip("- smooth intersection between geometry -")]
	private bool useSoftBlend;

	[SerializeField]
	[Tooltip("- control the falloff of the light using a curve -")]
	private bool useCurves;

	[SerializeField]
	[Header("- amount to shift noise when light moves -")]
	private float worldScrollAmount;

	[Space(20f, order = 0)]
	[Header("==== Shadow settings ====", order = 1)]
	public ShadowMode shadowMode;

	[Range(8f, 2048f)]
	[SerializeField]
	[Tooltip("- This must be a power of 2 -")]
	private int shadowMapRes = 256;

	[SerializeField]
	private int shadowBlurPasses;

	[SerializeField]
	private float shadowBlurSize;

	[SerializeField]
	[Header("- for special objects like speed tree -")]
	private bool renderFullShadows;

	[SerializeField]
	[Header("- enable if shadow artifacts occur -")]
	private bool _renderShadowMapInUpdate;

	[Space(20f, order = 0)]
	[Header("==== Spot/Orthographic light settings ====", order = 1)]
	public float spotRange = 1f;

	public float spotNear = 0.1f;

	public float spotAngle = 45f;

	public float orthoSize = 0.5f;

	[SerializeField]
	private Texture spotEmission;

	[SerializeField]
	private Texture spotNoise;

	[SerializeField]
	private Texture spotShadow;

	[Space(20f, order = 0)]
	[Header("==== Point light settings ====", order = 1)]
	public float pointLightRadius = 1f;

	[SerializeField]
	private Cubemap pointEmission;

	[SerializeField]
	private Cubemap pointNoise;

	[SerializeField]
	private Texture pointShadow;

	[Space(20f, order = 0)]
	[Header("==== Area volume settings ====", order = 1)]
	[SerializeField]
	private Texture3D areaVolume;

	[SerializeField]
	private VolumeShape volumeShape;

	[SerializeField]
	[Range(0f, 1f)]
	private float shapeValue;

	[SerializeField]
	private Vector3 volumeTextureOffset = Vector3.zero;

	[SerializeField]
	private float volumeTextureScale = 0.5f;

	[SerializeField]
	[Header("- only changed when not playing -")]
	private Gradient lightGradient = new Gradient
	{
		alphaKeys = new GradientAlphaKey[2]
		{
			new GradientAlphaKey(1f, 0f),
			new GradientAlphaKey(1f, 1f)
		},
		colorKeys = new GradientColorKey[2]
		{
			new GradientColorKey(Color.white, 0f),
			new GradientColorKey(Color.black, 1f)
		}
	};

	[SerializeField]
	private AnimationCurve fallOffCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	[SerializeField]
	private Vector3 _boundsCentreOffset = Vector3.zero;

	[SerializeField]
	[HideInInspector]
	private Texture2D _fallOffTexture;

	[SerializeField]
	[HideInInspector]
	private Material spotMaterial;

	[SerializeField]
	[HideInInspector]
	private Material pointMaterial;

	[SerializeField]
	[HideInInspector]
	private Material areaMaterial;

	[SerializeField]
	[HideInInspector]
	private Material orthoMaterial;

	[SerializeField]
	[HideInInspector]
	private Shader renderDepthShader;

	[HideInInspector]
	[SerializeField]
	private Mesh meshContainer;

	private int _idColorTint;

	private int _idLightMultiplier;

	private int _idSpotExponent;

	private int _idConstantAttenuation;

	private int _idLinearAttenuation;

	private int _idQuadraticAttenuation;

	private int _idLightParams;

	private int _idMinBounds;

	private int _idMaxBounds;

	private int _idViewWorldLight;

	private int _idRotation;

	private int _idLocalRotation;

	private int _idProjection;

	private int _idNoiseOffset;

	private int _idJitterAmount;

	private int _idFallOffTex;

	private int _idDitherTex;

	private int _idVolumeParams;

	private int _idVolumeOffset;

	private LightTypes _prevLightType;

	private ShadowMode _prevShadowMode;

	private bool _prevRenderFullShadows;

	private int _prevSlices;

	private bool _frustrumSwitch;

	private bool _prevIsOrtho;

	private float _prevNear;

	private float _prevFar;

	private float _prevFov;

	private float _prevOrthoSize;

	private float _prevPointLightRadius;

	private float _prevOrtho;

	private float _prevOrthoAspect;

	private Vector3 _prevBoundsCentreOffset = Vector3.zero;

	private Matrix4x4 _worldToCamera;

	private Matrix4x4 _projectionMatrixCached;

	private Matrix4x4 _viewWorldToCameraMatrixCached;

	private Matrix4x4 _viewCameraToWorldMatrixCached;

	private Matrix4x4 _localToWorldMatrix;

	private Matrix4x4 _rotation;

	private Matrix4x4 _localRotation;

	private Matrix4x4 _viewWorldLight;

	private Vector3[] _frustrumPoints;

	private Vector3 _angle = Vector3.zero;

	private Vector3 _minBounds;

	private Vector3 _maxBounds;

	private bool _cameraHasBeenUpdated;

	private MeshFilter _meshFilter;

	private RenderTexture _depthTexture;

	private const int VERT_COUNT = 65000;

	private const int TRI_COUNT = 195000;

	private const StringComparison STR_CMP_TYPE = StringComparison.OrdinalIgnoreCase;

	private bool _builtMesh;

	private int _maxSlices;

	private Material _postMaterial;

	private static Cubemap _emptyCubemap;

	private static Texture3D _emptyTexture3D;

	private static Texture2D _emptyTexture2D;

	private static Texture2D _ditherTexture;

	private MaterialPropertyBlock _propertyBlock;

	private Renderer _renderer;

	private Camera _camera;

	private Transform _cachedTransform;

	[HideInInspector]
	private Vector3[] _pointsViewSpace = new Vector3[8];

	private int _waterLayer = -1;

	private int _vlightLayer = -1;

	private bool _queueRenderShadowMap;

	public Vector3 MinBounds => _minBounds;

	public Vector3 MaxBounds => _maxBounds;

	private Material LightMaterial
	{
		get
		{
			if (MeshRender.sharedMaterial == null)
			{
				CreateMaterials();
			}
			return MeshRender.sharedMaterial;
		}
	}

	private Material PostMaterial
	{
		get
		{
			if (_postMaterial == null)
			{
				_postMaterial = new Material(Shader.Find("Hidden/V-Light/Post"));
				_postMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return _postMaterial;
		}
	}

	private int MaxSlices
	{
		get
		{
			return _maxSlices;
		}
		set
		{
			_maxSlices = value;
		}
	}

	private static Cubemap EmptyCubemap
	{
		get
		{
			if (_emptyCubemap == null)
			{
				_emptyCubemap = new Cubemap(1, TextureFormat.ARGB32, mipChain: false);
				_emptyCubemap.hideFlags = HideFlags.DontSave;
				_emptyCubemap.SetPixel(CubemapFace.NegativeX, 0, 0, Color.gray);
				_emptyCubemap.SetPixel(CubemapFace.NegativeY, 0, 0, Color.gray);
				_emptyCubemap.SetPixel(CubemapFace.NegativeZ, 0, 0, Color.gray);
				_emptyCubemap.SetPixel(CubemapFace.PositiveX, 0, 0, Color.gray);
				_emptyCubemap.SetPixel(CubemapFace.PositiveY, 0, 0, Color.gray);
				_emptyCubemap.SetPixel(CubemapFace.PositiveZ, 0, 0, Color.gray);
				_emptyCubemap.Apply();
			}
			return _emptyCubemap;
		}
	}

	private static Texture3D EmptyTexture3D
	{
		get
		{
			if (_emptyTexture3D == null)
			{
				_emptyTexture3D = new Texture3D(1, 1, 1, TextureFormat.ARGB32, mipChain: false);
				_emptyTexture3D.SetPixels32(new Color32[1]
				{
					new Color32(128, 128, 128, 128)
				});
				_emptyTexture3D.hideFlags = HideFlags.DontSave;
				_emptyTexture3D.Apply();
			}
			return _emptyTexture3D;
		}
	}

	private static Texture2D EmptyTexture2D
	{
		get
		{
			if (_emptyTexture2D == null)
			{
				_emptyTexture2D = new Texture2D(1, 1, TextureFormat.ARGB32, mipChain: false);
				_emptyTexture2D.SetPixels32(new Color32[1]
				{
					new Color32(128, 128, 128, 128)
				});
				_emptyTexture2D.hideFlags = HideFlags.DontSave;
				_emptyTexture2D.Apply();
			}
			return _emptyTexture2D;
		}
	}

	private static Texture2D DitherTexture
	{
		get
		{
			if (_ditherTexture == null)
			{
				_ditherTexture = new Texture2D(8, 8, TextureFormat.ARGB32, mipChain: false, linear: true);
				_ditherTexture.wrapMode = TextureWrapMode.Repeat;
				_ditherTexture.hideFlags = HideFlags.DontSave;
				float[] array = new float[64]
				{
					0f, 32f, 8f, 40f, 2f, 34f, 10f, 42f, 48f, 16f,
					56f, 24f, 50f, 18f, 58f, 26f, 12f, 44f, 4f, 36f,
					14f, 46f, 6f, 38f, 60f, 28f, 52f, 20f, 62f, 30f,
					54f, 22f, 3f, 35f, 11f, 43f, 1f, 33f, 9f, 41f,
					51f, 19f, 59f, 27f, 49f, 17f, 57f, 25f, 15f, 47f,
					7f, 39f, 13f, 45f, 5f, 37f, 63f, 31f, 55f, 23f,
					61f, 29f, 53f, 21f
				};
				Color[] array2 = new Color[64];
				for (int i = 0; i < array.Length; i++)
				{
					array2[i] = new Color(array[i] / 64f, array[i] / 64f, array[i] / 64f, 1f);
				}
				_ditherTexture.SetPixels(array2);
				_ditherTexture.Apply();
			}
			return _ditherTexture;
		}
	}

	private Texture2D FallOffTexture
	{
		get
		{
			if (_fallOffTexture == null)
			{
				_fallOffTexture = new Texture2D(128, 1);
				_fallOffTexture.wrapMode = TextureWrapMode.Clamp;
				_fallOffTexture.hideFlags = HideFlags.DontSave;
				UpdateFalloffCurve();
			}
			return _fallOffTexture;
		}
	}

	public Shader RenderDepthShader
	{
		get
		{
			if (renderDepthShader == null)
			{
				renderDepthShader = Shader.Find("V-Light/Volumetric Light Depth");
			}
			return renderDepthShader;
		}
	}

	public MaterialPropertyBlock PropertyBlock
	{
		get
		{
			if (_propertyBlock == null)
			{
				_propertyBlock = new MaterialPropertyBlock();
			}
			return _propertyBlock;
		}
	}

	public Renderer MeshRender
	{
		get
		{
			if (_renderer == null)
			{
				_renderer = GetComponent<Renderer>();
			}
			return _renderer;
		}
	}

	public Camera cam
	{
		get
		{
			if (_camera == null)
			{
				_camera = GetComponent<Camera>();
			}
			return _camera;
		}
	}

	private Transform CachedTransform
	{
		get
		{
			if (_cachedTransform == null)
			{
				_cachedTransform = base.transform;
			}
			return _cachedTransform;
		}
	}

	private int WaterLayer
	{
		get
		{
			if (_waterLayer == -1)
			{
				_waterLayer = 1 << LayerMask.NameToLayer("Water");
			}
			return _waterLayer;
		}
	}

	private int VLightLayer
	{
		get
		{
			if (_vlightLayer == -1)
			{
				_vlightLayer = 1 << LayerMask.NameToLayer("vlight");
			}
			return _vlightLayer;
		}
	}

	private void OnEnable()
	{
		_maxSlices = slices;
		int num = LayerMask.NameToLayer("vlight");
		if (num != -1)
		{
			base.gameObject.layer = num;
		}
		cam.enabled = false;
		cam.cullingMask &= ~(1 << base.gameObject.layer);
		VLightInterleavedSampling.lightsModified = true;
		_queueRenderShadowMap = true;
	}

	private void OnDisable()
	{
		VLightInterleavedSampling.lightsModified = true;
	}

	private void OnApplicationQuit()
	{
	}

	private void OnDestroy()
	{
		CleanMaterials();
		SafeDestroy(meshContainer, forceImmediate: true);
		SafeDestroy(_depthTexture, forceImmediate: true);
		SafeDestroy(_fallOffTexture, forceImmediate: true);
		SafeDestroy(_ditherTexture, forceImmediate: true);
		SafeDestroy(_emptyTexture2D, forceImmediate: true);
		SafeDestroy(_emptyTexture3D, forceImmediate: true);
		SafeDestroy(_emptyCubemap, forceImmediate: true);
	}

	private void Start()
	{
		CreateMaterials();
		UpdateLightMatrices();
		BuildMesh(manualPositioning: false, slices, Vector3.one, Vector3.one);
	}

	private void Reset()
	{
		CleanMaterials();
		SafeDestroy(_emptyTexture2D);
		SafeDestroy(_emptyTexture3D);
		SafeDestroy(_emptyCubemap);
		SafeDestroy(_depthTexture);
		SafeDestroy(_fallOffTexture);
		SafeDestroy(_ditherTexture);
		SafeDestroy(meshContainer);
	}

	private void CreateMaterials()
	{
		_idColorTint = Shader.PropertyToID("_Color");
		_idLightMultiplier = Shader.PropertyToID("_Strength");
		_idSpotExponent = Shader.PropertyToID("_SpotExp");
		_idConstantAttenuation = Shader.PropertyToID("_ConstantAttn");
		_idLinearAttenuation = Shader.PropertyToID("_LinearAttn");
		_idQuadraticAttenuation = Shader.PropertyToID("_QuadAttn");
		_idLightParams = Shader.PropertyToID("_LightParams");
		_idMinBounds = Shader.PropertyToID("_minBounds");
		_idMaxBounds = Shader.PropertyToID("_maxBounds");
		_idViewWorldLight = Shader.PropertyToID("_ViewWorldLight");
		_idLocalRotation = Shader.PropertyToID("_LocalRotation");
		_idRotation = Shader.PropertyToID("_Rotation");
		_idProjection = Shader.PropertyToID("_Projection");
		_idNoiseOffset = Shader.PropertyToID("_NoiseOffset");
		_idJitterAmount = Shader.PropertyToID("_JitterAmount");
		_idDitherTex = Shader.PropertyToID("_DitherTex");
		_idFallOffTex = Shader.PropertyToID("_FallOffTex");
		_idVolumeOffset = Shader.PropertyToID("_VolumeOffset");
		_idVolumeParams = Shader.PropertyToID("_VolumeParams");
		if (MeshRender.sharedMaterial != null)
		{
			SafeDestroy(MeshRender.sharedMaterial);
		}
		if (pointMaterial == null)
		{
			pointMaterial = new Material(Shader.Find("V-Light/Point Light 2"));
			pointMaterial.hideFlags = HideFlags.DontSave;
		}
		if (spotMaterial == null)
		{
			spotMaterial = new Material(Shader.Find("V-Light/Spot Light 2"));
			spotMaterial.hideFlags = HideFlags.DontSave;
		}
		if (areaMaterial == null)
		{
			areaMaterial = new Material(Shader.Find("V-Light/Area"));
			areaMaterial.hideFlags = HideFlags.DontSave;
		}
		if (orthoMaterial == null)
		{
			orthoMaterial = new Material(Shader.Find("V-Light/Orthographic"));
			orthoMaterial.hideFlags = HideFlags.DontSave;
		}
		switch (lightType)
		{
		case LightTypes.Spot:
			MeshRender.sharedMaterial = UnityEngine.Object.Instantiate(spotMaterial);
			break;
		case LightTypes.Point:
			MeshRender.sharedMaterial = UnityEngine.Object.Instantiate(pointMaterial);
			break;
		case LightTypes.Area:
			MeshRender.sharedMaterial = UnityEngine.Object.Instantiate(areaMaterial);
			break;
		case LightTypes.Orthographic:
			MeshRender.sharedMaterial = UnityEngine.Object.Instantiate(orthoMaterial);
			break;
		}
		MeshRender.sharedMaterial.hideFlags = HideFlags.DontSave;
	}

	private void CleanMaterials()
	{
		SafeDestroy(meshContainer);
		SafeDestroy(MeshRender.sharedMaterial);
		meshContainer = null;
	}

	private void OnDrawGizmosSelected()
	{
		Gizmos.DrawWireSphere(MeshRender.bounds.center, 0.05f);
		if (_frustrumPoints != null)
		{
			Gizmos.color = new Color(0f, 1f, 0f, 0.2f);
			Gizmos.DrawLine(CachedTransform.TransformPoint(_frustrumPoints[0]), CachedTransform.TransformPoint(_frustrumPoints[1]));
			Gizmos.DrawLine(CachedTransform.TransformPoint(_frustrumPoints[2]), CachedTransform.TransformPoint(_frustrumPoints[3]));
			Gizmos.DrawLine(CachedTransform.TransformPoint(_frustrumPoints[4]), CachedTransform.TransformPoint(_frustrumPoints[5]));
			Gizmos.DrawLine(CachedTransform.TransformPoint(_frustrumPoints[6]), CachedTransform.TransformPoint(_frustrumPoints[7]));
			Gizmos.DrawLine(CachedTransform.TransformPoint(_frustrumPoints[1]), CachedTransform.TransformPoint(_frustrumPoints[3]));
			Gizmos.DrawLine(CachedTransform.TransformPoint(_frustrumPoints[3]), CachedTransform.TransformPoint(_frustrumPoints[7]));
			Gizmos.DrawLine(CachedTransform.TransformPoint(_frustrumPoints[7]), CachedTransform.TransformPoint(_frustrumPoints[5]));
			Gizmos.DrawLine(CachedTransform.TransformPoint(_frustrumPoints[5]), CachedTransform.TransformPoint(_frustrumPoints[1]));
			Gizmos.DrawLine(CachedTransform.TransformPoint(_frustrumPoints[0]), CachedTransform.TransformPoint(_frustrumPoints[2]));
			Gizmos.DrawLine(CachedTransform.TransformPoint(_frustrumPoints[2]), CachedTransform.TransformPoint(_frustrumPoints[6]));
			Gizmos.DrawLine(CachedTransform.TransformPoint(_frustrumPoints[6]), CachedTransform.TransformPoint(_frustrumPoints[4]));
			Gizmos.DrawLine(CachedTransform.TransformPoint(_frustrumPoints[4]), CachedTransform.TransformPoint(_frustrumPoints[0]));
		}
	}

	private void CalculateMinMax(out Vector3 min, out Vector3 max, bool forceFrustrumUpdate)
	{
		if (_frustrumPoints == null || forceFrustrumUpdate)
		{
			if (lightType == LightTypes.Point || lightType == LightTypes.Area)
			{
				VLightGeometryUtil.RecalculateFrustrumPoints(cam.orthographic, pointLightRadius, spotAngle, 0f - pointLightRadius, pointLightRadius, aspect, out _frustrumPoints);
			}
			else
			{
				VLightGeometryUtil.RecalculateFrustrumPoints(cam.orthographic, orthoSize, spotAngle, Mathf.Max(0.01f, spotNear), spotRange, aspect, out _frustrumPoints);
			}
		}
		Vector3 vector = new Vector3(float.NegativeInfinity, float.NegativeInfinity, float.NegativeInfinity);
		Vector3 vector2 = new Vector3(float.PositiveInfinity, float.PositiveInfinity, float.PositiveInfinity);
		Matrix4x4 matrix4x = _viewWorldToCameraMatrixCached * _localToWorldMatrix;
		for (int i = 0; i < _frustrumPoints.Length; i++)
		{
			_pointsViewSpace[i] = matrix4x.MultiplyPoint3x4(_frustrumPoints[i]);
			vector.x = ((vector.x > _pointsViewSpace[i].x) ? vector.x : _pointsViewSpace[i].x);
			vector.y = ((vector.y > _pointsViewSpace[i].y) ? vector.y : _pointsViewSpace[i].y);
			vector.z = ((vector.z > _pointsViewSpace[i].z) ? vector.z : _pointsViewSpace[i].z);
			vector2.x = ((vector2.x <= _pointsViewSpace[i].x) ? vector2.x : _pointsViewSpace[i].x);
			vector2.y = ((vector2.y <= _pointsViewSpace[i].y) ? vector2.y : _pointsViewSpace[i].y);
			vector2.z = ((vector2.z <= _pointsViewSpace[i].z) ? vector2.z : _pointsViewSpace[i].z);
		}
		min = vector;
		max = vector2;
	}

	private Matrix4x4 CalculateProjectionMatrix()
	{
		float fieldOfView = cam.fieldOfView;
		float nearClipPlane = cam.nearClipPlane;
		float farClipPlane = cam.farClipPlane;
		fieldOfView = spotAngle;
		nearClipPlane = Mathf.Max(0.01f, spotNear);
		farClipPlane = spotRange;
		cam.farClipPlane = farClipPlane;
		if (lightType == LightTypes.Point || lightType == LightTypes.Area)
		{
			nearClipPlane = 0f - pointLightRadius;
			farClipPlane = pointLightRadius;
		}
		if (!cam.orthographic)
		{
			return Matrix4x4.Perspective(fieldOfView, aspect, nearClipPlane, farClipPlane);
		}
		float num = orthoSize;
		return Matrix4x4.Ortho((0f - num) * aspect, num * aspect, 0f - num, num, nearClipPlane, farClipPlane);
	}

	private void BuildMesh(bool manualPositioning, int planeCount, Vector3 minBounds, Vector3 maxBounds)
	{
		if (meshContainer == null || meshContainer.name.IndexOf(GetInstanceID().ToString(), StringComparison.OrdinalIgnoreCase) != 0)
		{
			meshContainer = new Mesh();
			meshContainer.MarkDynamic();
			meshContainer.hideFlags = HideFlags.HideAndDontSave;
			meshContainer.name = GetInstanceID().ToString();
		}
		if (_meshFilter == null)
		{
			_meshFilter = GetComponent<MeshFilter>();
		}
		Vector3[] array = new Vector3[65000];
		int[] array2 = new int[195000];
		int num = 0;
		int num2 = 0;
		float num3 = 1f / (float)(planeCount - 1);
		float num4 = (manualPositioning ? 1f : 0f);
		float x = 0f;
		float x2 = 1f;
		float y = 0f;
		float y2 = 1f;
		int num5 = 0;
		for (int i = 0; i < planeCount; i++)
		{
			Vector3[] array3 = new Vector3[4];
			Vector3[] array5;
			if (manualPositioning)
			{
				Plane[] array4 = GeometryUtility.CalculateFrustumPlanes(_projectionMatrixCached * cam.worldToCameraMatrix);
				for (int j = 0; j < array4.Length; j++)
				{
					Vector3 point = array4[j].normal * (0f - array4[j].distance);
					array4[j] = new Plane(_viewWorldToCameraMatrixCached.MultiplyVector(array4[j].normal), _viewWorldToCameraMatrixCached.MultiplyPoint3x4(point));
				}
				array3[0] = CalculateTriLerp(new Vector3(x, y, num4), minBounds, maxBounds);
				array3[1] = CalculateTriLerp(new Vector3(x, y2, num4), minBounds, maxBounds);
				array3[2] = CalculateTriLerp(new Vector3(x2, y2, num4), minBounds, maxBounds);
				array3[3] = CalculateTriLerp(new Vector3(x2, y, num4), minBounds, maxBounds);
				array5 = VLightGeometryUtil.ClipPolygonAgainstPlane(array3, array4);
			}
			else
			{
				float z = num4;
				array3[0] = new Vector3(x, y, z);
				array3[1] = new Vector3(x, y2, z);
				array3[2] = new Vector3(x2, y2, z);
				array3[3] = new Vector3(x2, y, z);
				array5 = array3;
			}
			num4 += (manualPositioning ? (0f - num3) : num3);
			if (array5.Length > 2)
			{
				Array.Copy(array5, 0, array, num, array5.Length);
				num += array5.Length;
				int[] array6 = new int[(array5.Length - 2) * 3];
				int num6 = 0;
				for (int k = 0; k < array6.Length; k += 3)
				{
					array6[k] = num5;
					array6[k + 1] = num5 + (num6 + 1);
					array6[k + 2] = num5 + (num6 + 2);
					num6++;
				}
				num5 += array5.Length;
				Array.Copy(array6, 0, array2, num2, array6.Length);
				num2 += array6.Length;
			}
		}
		meshContainer.Clear();
		Vector3[] array7 = new Vector3[num];
		Array.Copy(array, array7, num);
		meshContainer.vertices = array7;
		int[] array8 = new int[num2];
		Array.Copy(array2, array8, num2);
		meshContainer.triangles = array8;
		meshContainer.normals = new Vector3[num];
		meshContainer.uv = new Vector2[num];
		Vector3 zero = Vector3.zero;
		Vector3[] frustrumPoints = _frustrumPoints;
		foreach (Vector3 vector in frustrumPoints)
		{
			zero += vector;
		}
		zero /= (float)_frustrumPoints.Length;
		Bounds bounds = new Bounds(zero, Vector3.zero);
		frustrumPoints = _frustrumPoints;
		foreach (Vector3 point2 in frustrumPoints)
		{
			bounds.Encapsulate(point2);
		}
		_meshFilter.sharedMesh = meshContainer;
		bounds.center += _boundsCentreOffset;
		_meshFilter.sharedMesh.bounds = bounds;
	}

	private Vector3 CalculateTriLerp(Vector3 vertex, Vector3 minBounds, Vector3 maxBounds)
	{
		Vector3 vector = new Vector3(1f, 1f, 1f) - vertex;
		return new Vector3(minBounds.x * vertex.x, minBounds.y * vertex.y, maxBounds.z * vertex.z) + new Vector3(maxBounds.x * vector.x, maxBounds.y * vector.y, minBounds.z * vector.z);
	}

	public void RenderShadowMap()
	{
		_ = cam.farClipPlane;
		switch (shadowMode)
		{
		case ShadowMode.None:
			cam.depthTextureMode = DepthTextureMode.None;
			break;
		case ShadowMode.Baked:
			cam.depthTextureMode = DepthTextureMode.None;
			break;
		case ShadowMode.Realtime:
			if (!SystemInfo.supportsImageEffects)
			{
				break;
			}
			cam.backgroundColor = Color.white;
			cam.clearFlags = CameraClearFlags.Color;
			cam.renderingPath = RenderingPath.VertexLit;
			cam.cullingMask &= ~(WaterLayer | VLightLayer);
			cam.depthTextureMode = (renderFullShadows ? DepthTextureMode.Depth : DepthTextureMode.None);
			CreateDepthTexture(lightType);
			if (RenderDepthShader != null)
			{
				switch (lightType)
				{
				case LightTypes.Spot:
				case LightTypes.Orthographic:
					cam.targetTexture = _depthTexture;
					cam.projectionMatrix = CalculateProjectionMatrix();
					if (renderFullShadows)
					{
						cam.Render();
						Graphics.Blit(null, _depthTexture, PostMaterial, 6);
					}
					else
					{
						cam.RenderWithShader(RenderDepthShader, "RenderType");
					}
					if (shadowBlurPasses > 0)
					{
						RenderTexture temporary = RenderTexture.GetTemporary(shadowMapRes, shadowMapRes, 0, RenderTextureFormat.ARGB32, RenderTextureReadWrite.Linear);
						temporary.DiscardContents();
						PostMaterial.SetFloat("_BlurSize", shadowBlurSize);
						for (int i = 0; i < shadowBlurPasses; i++)
						{
							Graphics.Blit(_depthTexture, temporary, PostMaterial, 1);
							_depthTexture.DiscardContents();
							Graphics.Blit(temporary, _depthTexture, PostMaterial, 2);
							temporary.DiscardContents();
						}
						RenderTexture.ReleaseTemporary(temporary);
					}
					break;
				case LightTypes.Point:
					cam.projectionMatrix = Matrix4x4.Perspective(90f, 1f, 0.1f, pointLightRadius);
					cam.SetReplacementShader(RenderDepthShader, "RenderType");
					cam.RenderToCubemap(_depthTexture, 63);
					cam.ResetReplacementShader();
					break;
				case LightTypes.Area:
					break;
				}
			}
			else
			{
				UnityEngine.Debug.LogWarning("Could not find depth shader. Cannot render shadows");
			}
			break;
		}
	}

	private RenderTexture GenerateShadowMap(int res)
	{
		return new RenderTexture(res, res, 16, RenderTextureFormat.ARGB32, RenderTextureReadWrite.Linear);
	}

	private void CreateDepthTexture(LightTypes type)
	{
		shadowMapRes = Mathf.NextPowerOfTwo(shadowMapRes);
		if (_depthTexture == null || _depthTexture.width != shadowMapRes)
		{
			if (_depthTexture != null)
			{
				SafeDestroy(_depthTexture);
			}
			_depthTexture = GenerateShadowMap(shadowMapRes);
			_depthTexture.hideFlags = HideFlags.HideAndDontSave;
			_depthTexture.isPowerOfTwo = true;
			if (type == LightTypes.Point)
			{
				_depthTexture.dimension = TextureDimension.Cube;
			}
		}
		else if (type == LightTypes.Point && _depthTexture.dimension != TextureDimension.Cube && _depthTexture.IsCreated())
		{
			SafeDestroy(_depthTexture);
			_depthTexture = GenerateShadowMap(shadowMapRes);
			_depthTexture.hideFlags = HideFlags.HideAndDontSave;
			_depthTexture.isPowerOfTwo = true;
			_depthTexture.dimension = TextureDimension.Cube;
		}
		else if ((type == LightTypes.Spot || type == LightTypes.Orthographic) && _depthTexture.dimension == TextureDimension.Cube && _depthTexture.IsCreated())
		{
			SafeDestroy(_depthTexture);
			_depthTexture = GenerateShadowMap(shadowMapRes);
			_depthTexture.hideFlags = HideFlags.HideAndDontSave;
			_depthTexture.isPowerOfTwo = true;
			_depthTexture.dimension = TextureDimension.Tex2D;
		}
	}

	public void OnWillRenderObject()
	{
		VLightInterleavedSampling.renderCount++;
		if (!VLightInterleavedSampling.renderingInterleaved)
		{
			UpdateSettings();
			UpdateViewMatrices(Camera.current);
			UpdateLightMatrices();
			if (!_renderShadowMapInUpdate)
			{
				RenderShadowMap();
			}
			_queueRenderShadowMap = true;
			MeshRender.GetPropertyBlock(PropertyBlock);
			SetShaderPropertiesBlock(PropertyBlock);
			MeshRender.SetPropertyBlock(PropertyBlock);
		}
		if (useCurves && Application.isEditor)
		{
			UpdateFalloffCurve();
		}
	}

	private void Update()
	{
		if (useCurves)
		{
			if (Application.isEditor)
			{
				UpdateFalloffCurve();
			}
		}
		else
		{
			SafeDestroy(_fallOffTexture);
		}
		if (_queueRenderShadowMap)
		{
			_queueRenderShadowMap = false;
			if (_renderShadowMapInUpdate)
			{
				RenderShadowMap();
			}
		}
		UpdateSettings();
		UpdateLightMatrices();
	}

	private void FixedUpdate()
	{
		if (useCurves)
		{
			if (Application.isEditor)
			{
				UpdateFalloffCurve();
			}
		}
		else
		{
			SafeDestroy(_fallOffTexture);
		}
		if (_queueRenderShadowMap)
		{
			_queueRenderShadowMap = false;
		}
		UpdateSettings();
		UpdateLightMatrices();
	}

	private void UpdateFalloffCurve()
	{
		Color[] array = new Color[128];
		for (int i = 0; i < 128; i++)
		{
			array[i] = lightGradient.Evaluate((float)i / 128f);
			array[i].a *= fallOffCurve.Evaluate((float)i / 128f);
		}
		FallOffTexture.SetPixels(array);
		FallOffTexture.Apply();
	}

	private bool CameraHasBeenUpdated()
	{
		bool flag = false;
		flag |= _meshFilter == null || _meshFilter.sharedMesh == null;
		flag |= spotRange != _prevFar;
		flag |= spotNear != _prevNear;
		flag |= spotAngle != _prevFov;
		flag |= cam.orthographicSize != _prevOrthoSize;
		flag |= cam.orthographic != _prevIsOrtho;
		flag |= pointLightRadius != _prevPointLightRadius;
		flag |= orthoSize != _prevOrtho;
		flag |= aspect != _prevOrthoAspect;
		flag |= _prevSlices != slices;
		flag |= _prevShadowMode != shadowMode;
		flag |= _prevLightType != lightType;
		flag |= _prevRenderFullShadows != renderFullShadows;
		if (!Application.isPlaying)
		{
			flag |= _prevBoundsCentreOffset != _boundsCentreOffset;
		}
		return flag;
	}

	private void UpdateSettings()
	{
		_cameraHasBeenUpdated = CameraHasBeenUpdated();
		if (_cameraHasBeenUpdated)
		{
			if (_prevLightType != lightType)
			{
				CreateMaterials();
			}
			pointLightRadius = Mathf.Max(0.001f, pointLightRadius);
			orthoSize = Mathf.Max(0.001f, orthoSize);
			cam.ResetProjectionMatrix();
			cam.projectionMatrix = CalculateProjectionMatrix();
			switch (lightType)
			{
			case LightTypes.Point:
			case LightTypes.Area:
			case LightTypes.Orthographic:
				cam.orthographic = true;
				break;
			case LightTypes.Spot:
				cam.orthographic = false;
				break;
			}
			if ((shadowMode == ShadowMode.None || shadowMode == ShadowMode.Baked) && _depthTexture != null)
			{
				SafeDestroy(_depthTexture);
			}
		}
		_prevSlices = slices;
		_prevFov = spotAngle;
		_prevNear = Mathf.Max(0.01f, spotNear);
		_prevFar = spotRange;
		_prevIsOrtho = cam.orthographic;
		_prevOrthoSize = orthoSize;
		_prevShadowMode = shadowMode;
		_prevLightType = lightType;
		_prevPointLightRadius = pointLightRadius;
		_prevRenderFullShadows = renderFullShadows;
		_prevOrtho = orthoSize;
		_prevOrthoAspect = aspect;
		if (!Application.isPlaying)
		{
			_prevBoundsCentreOffset = _boundsCentreOffset;
		}
	}

	private void UpdateLightMatrices()
	{
		_localToWorldMatrix = CachedTransform.localToWorldMatrix;
		_worldToCamera = cam.worldToCameraMatrix;
		switch (lightType)
		{
		case LightTypes.Spot:
			_rotation = Matrix4x4.TRS(Vector3.zero, Quaternion.Euler(_angle.x, _angle.y, _angle.z), Vector3.one);
			break;
		case LightTypes.Point:
		{
			Vector3 vector = CachedTransform.position * 180f * worldScrollAmount;
			_rotation = Matrix4x4.TRS(Vector3.zero, CachedTransform.rotation * Quaternion.Euler(_angle.x + vector.x, _angle.y + vector.y, _angle.z + vector.z), Vector3.one);
			break;
		}
		case LightTypes.Area:
			_rotation = Matrix4x4.TRS(_angle, Quaternion.identity, Vector3.one);
			break;
		case LightTypes.Orthographic:
			_rotation = Matrix4x4.TRS(_angle, Quaternion.identity, Vector3.one);
			break;
		}
		_angle += noiseSpeed * Time.deltaTime;
		RebuildMesh();
	}

	private void UpdateViewMatrices(Camera targetCamera)
	{
		_viewWorldToCameraMatrixCached = targetCamera.worldToCameraMatrix;
		_viewCameraToWorldMatrixCached = targetCamera.cameraToWorldMatrix;
		switch (lightType)
		{
		case LightTypes.Spot:
			_viewWorldLight = _worldToCamera * _viewCameraToWorldMatrixCached;
			break;
		case LightTypes.Point:
			_localRotation = Matrix4x4.TRS(Vector3.zero, CachedTransform.rotation, Vector3.one);
			_viewWorldLight = Matrix4x4.TRS(-CachedTransform.position, Quaternion.identity, Vector3.one) * _viewCameraToWorldMatrixCached;
			break;
		case LightTypes.Area:
		case LightTypes.Orthographic:
			_localRotation = Matrix4x4.TRS(Vector3.zero, CachedTransform.rotation, Vector3.one);
			_viewWorldLight = _worldToCamera * _viewCameraToWorldMatrixCached;
			break;
		}
	}

	private void RebuildMesh()
	{
		CalculateMinMax(out _minBounds, out _maxBounds, _cameraHasBeenUpdated);
		if (!_cameraHasBeenUpdated)
		{
			return;
		}
		_projectionMatrixCached = CalculateProjectionMatrix();
		if (Application.isPlaying)
		{
			if (!_builtMesh)
			{
				_builtMesh = true;
				BuildMesh(manualPositioning: false, slices, _minBounds, _maxBounds);
			}
		}
		else
		{
			BuildMesh(manualPositioning: false, slices, _minBounds, _maxBounds);
		}
	}

	private void SetShaderPropertiesBlock(MaterialPropertyBlock propertyBlock)
	{
		propertyBlock.SetVector(_idNoiseOffset, _angle);
		propertyBlock.SetVector(_idMinBounds, _minBounds);
		propertyBlock.SetVector(_idMaxBounds, _maxBounds);
		propertyBlock.SetMatrix(_idProjection, _projectionMatrixCached);
		propertyBlock.SetMatrix(_idViewWorldLight, _viewWorldLight);
		propertyBlock.SetMatrix(_idLocalRotation, _localRotation);
		propertyBlock.SetMatrix(_idRotation, _rotation);
		propertyBlock.SetColor(_idColorTint, colorTint);
		propertyBlock.SetFloat(_idLightMultiplier, lightMultiplier);
		propertyBlock.SetVector("_WorldPos", (CachedTransform.position + CachedTransform.forward) * worldScrollAmount);
		Material lightMaterial = LightMaterial;
		if (useSoftBlend)
		{
			lightMaterial.EnableKeyword("_SOFTBLEND_ON");
		}
		else
		{
			lightMaterial.DisableKeyword("_SOFTBLEND_ON");
		}
		if (useDithering)
		{
			propertyBlock.SetFloat(_idJitterAmount, ditherAmount);
			propertyBlock.SetTexture(_idDitherTex, DitherTexture);
			lightMaterial.EnableKeyword("_DITHER_ON");
		}
		else
		{
			lightMaterial.DisableKeyword("_DITHER_ON");
		}
		if (useCurves)
		{
			propertyBlock.SetTexture(_idFallOffTex, FallOffTexture);
			lightMaterial.EnableKeyword("_CURVE_ON");
		}
		else
		{
			lightMaterial.DisableKeyword("_CURVE_ON");
		}
		switch (lightType)
		{
		case LightTypes.Spot:
		case LightTypes.Point:
		case LightTypes.Orthographic:
			propertyBlock.SetFloat(_idSpotExponent, spotExponent);
			propertyBlock.SetFloat(_idConstantAttenuation, constantAttenuation);
			propertyBlock.SetFloat(_idLinearAttenuation, linearAttenuation);
			propertyBlock.SetFloat(_idQuadraticAttenuation, quadraticAttenuation);
			break;
		case LightTypes.Area:
		{
			Vector4 value = volumeTextureOffset;
			value.w = volumeTextureScale;
			propertyBlock.SetVector(_idVolumeOffset, value);
			propertyBlock.SetFloat(_idVolumeParams, shapeValue);
			switch (volumeShape)
			{
			case VolumeShape.Cube:
				lightMaterial.EnableKeyword("_SHAPE_CUBE");
				lightMaterial.DisableKeyword("_SHAPE_SPHERE");
				lightMaterial.DisableKeyword("_SHAPE_ROUNDED_CUBE");
				lightMaterial.DisableKeyword("_SHAPE_CYLINDER");
				break;
			case VolumeShape.Sphere:
				lightMaterial.EnableKeyword("_SHAPE_SPHERE");
				lightMaterial.DisableKeyword("_SHAPE_CUBE");
				lightMaterial.DisableKeyword("_SHAPE_ROUNDED_CUBE");
				lightMaterial.DisableKeyword("_SHAPE_CYLINDER");
				break;
			case VolumeShape.RoundedCube:
				lightMaterial.EnableKeyword("_SHAPE_ROUNDED_CUBE");
				lightMaterial.DisableKeyword("_SHAPE_CUBE");
				lightMaterial.DisableKeyword("_SHAPE_SPHERE");
				lightMaterial.DisableKeyword("_SHAPE_CYLINDER");
				break;
			case VolumeShape.Cylinder:
				lightMaterial.EnableKeyword("_SHAPE_CYLINDER");
				lightMaterial.DisableKeyword("_SHAPE_CUBE");
				lightMaterial.DisableKeyword("_SHAPE_SPHERE");
				lightMaterial.DisableKeyword("_SHAPE_ROUNDED_CUBE");
				break;
			}
			break;
		}
		}
		switch (lightType)
		{
		case LightTypes.Area:
			propertyBlock.SetTexture("_MainTex", (areaVolume != null) ? areaVolume : EmptyTexture3D);
			break;
		case LightTypes.Point:
			propertyBlock.SetTexture("_LightColorEmission", (pointEmission != null) ? pointEmission : EmptyCubemap);
			propertyBlock.SetTexture("_NoiseTex", (pointNoise != null) ? pointNoise : EmptyCubemap);
			propertyBlock.SetTexture("_ShadowTexture", (pointShadow != null) ? pointShadow : EmptyCubemap);
			break;
		case LightTypes.Spot:
		case LightTypes.Orthographic:
			propertyBlock.SetTexture("_LightColorEmission", (spotEmission != null) ? spotEmission : EmptyTexture2D);
			propertyBlock.SetTexture("_NoiseTex", (spotNoise != null) ? spotNoise : EmptyTexture2D);
			propertyBlock.SetTexture("_ShadowTexture", (spotShadow != null) ? spotShadow : EmptyTexture2D);
			break;
		}
		bool flag = false;
		cam.targetTexture = null;
		switch (shadowMode)
		{
		case ShadowMode.Realtime:
			if (_depthTexture == null)
			{
				CreateDepthTexture(lightType);
			}
			propertyBlock.SetTexture("_ShadowTexture", _depthTexture);
			lightMaterial.EnableKeyword("_SHADOW_ON");
			flag = renderFullShadows;
			break;
		case ShadowMode.Baked:
			lightMaterial.EnableKeyword("_SHADOW_ON");
			flag = false;
			break;
		case ShadowMode.None:
			lightMaterial.DisableKeyword("_SHADOW_ON");
			flag = false;
			break;
		}
		if (flag)
		{
			lightMaterial.EnableKeyword("_SHADOW_EXP");
		}
		else
		{
			lightMaterial.DisableKeyword("_SHADOW_EXP");
		}
		float farClipPlane = cam.farClipPlane;
		float nearClipPlane = cam.nearClipPlane;
		float fieldOfView = cam.fieldOfView;
		farClipPlane = spotRange;
		nearClipPlane = Mathf.Max(0.01f, spotNear);
		fieldOfView = spotAngle;
		cam.farClipPlane = farClipPlane;
		if (lightType == LightTypes.Point || lightType == LightTypes.Area)
		{
			nearClipPlane = 0f - pointLightRadius;
			farClipPlane = pointLightRadius;
		}
		switch (lightType)
		{
		case LightTypes.Point:
		case LightTypes.Area:
			propertyBlock.SetVector(_idLightParams, new Vector4(nearClipPlane, farClipPlane, aspect, pointLightRadius));
			break;
		case LightTypes.Orthographic:
			propertyBlock.SetVector(_idLightParams, new Vector4(nearClipPlane, farClipPlane, aspect, orthoSize));
			break;
		default:
			propertyBlock.SetVector(_idLightParams, new Vector4(nearClipPlane, farClipPlane, aspect, fieldOfView * 0.5f * ((float)Math.PI / 180f)));
			break;
		}
	}

	private void SafeDestroy(UnityEngine.Object obj, bool forceImmediate = false)
	{
		if (obj != null)
		{
			if (Application.isPlaying && !forceImmediate)
			{
				UnityEngine.Object.Destroy(obj);
			}
			else
			{
				UnityEngine.Object.DestroyImmediate(obj, allowDestroyingAssets: true);
			}
		}
		obj = null;
	}
}
[ExecuteInEditMode]
public class VLightManager : MonoBehaviour
{
	public const string VOLUMETRIC_LIGHT_LAYER_NAME = "vlight";

	public Camera targetCamera;

	public float maxDistance = 50f;

	private static VLightManager _instance;

	private Matrix4x4 _projection;

	private Matrix4x4 _cameraToWorld;

	private Matrix4x4 _worldToCamera;

	private List<VLight> _vLights = new List<VLight>();

	public static VLightManager Instance
	{
		get
		{
			if (_instance == null)
			{
				_instance = UnityEngine.Object.FindObjectOfType(typeof(VLightManager)) as VLightManager;
				if (_instance == null)
				{
					_instance = new GameObject("Volume Light Manager").AddComponent<VLightManager>();
				}
			}
			return _instance;
		}
	}

	public Matrix4x4 ViewProjection => _projection;

	public Matrix4x4 ViewCameraToWorldMatrix => _cameraToWorld;

	public Matrix4x4 ViewWorldToCameraMatrix => _worldToCamera;

	public List<VLight> VLights
	{
		get
		{
			return _vLights;
		}
		set
		{
			_vLights = value;
		}
	}

	public void UpdateViewCamera(Camera viewCam)
	{
		if (!(viewCam == null))
		{
			_cameraToWorld = viewCam.cameraToWorldMatrix;
			_worldToCamera = viewCam.worldToCameraMatrix;
			_projection = viewCam.projectionMatrix;
		}
	}

	private void Update()
	{
		if (Application.isPlaying)
		{
			Camera camera = ((Camera.current != null) ? Camera.current : ((!(targetCamera != null)) ? Camera.main : targetCamera));
			_ = camera == null;
		}
	}

	private void Start()
	{
		_vLights.Clear();
		VLight[] collection = UnityEngine.Object.FindObjectsOfType(typeof(VLight)) as VLight[];
		_vLights.AddRange(collection);
	}

	private void Enabled()
	{
		_vLights.Clear();
		VLight[] collection = UnityEngine.Object.FindObjectsOfType(typeof(VLight)) as VLight[];
		_vLights.AddRange(collection);
	}
}
public class BedRemoteController : MonoBehaviour
{
	public static BedRemoteController Instance;

	public List<YireeBedController> yireeBeds;

	public GameObject touweixia;

	public GameObject shenshui;

	public GameObject guanying;

	public GameObject touweishang;

	public GameObject lingya;

	public GameObject toushang;

	public GameObject weishang;

	public GameObject yuedu;

	public GameObject touxia;

	public GameObject xiuxian;

	public GameObject weixia;

	public GameObject rightHand;

	public Transform arrowTra;

	public bool isShowCurtainsTip = true;

	public bool isShowLightTip = true;

	private List<HighlightEffect> keys;

	private Ray ray;

	private RaycastHit hit;

	private YireeBedController controller;

	private bool isLongPressHead;

	private bool isLongPressTail;

	private int curIndex;

	private bool isSwich = true;

	private void Awake()
	{
		Instance = this;
	}

	private void Start()
	{
		ray = default(Ray);
		hit = default(RaycastHit);
		keys = new List<HighlightEffect>();
		keys.Add(xiuxian.GetComponent<HighlightEffect>());
		keys.Add(yuedu.GetComponent<HighlightEffect>());
		keys.Add(toushang.GetComponent<HighlightEffect>());
		keys.Add(touxia.GetComponent<HighlightEffect>());
		keys.Add(touweishang.GetComponent<HighlightEffect>());
		keys.Add(guanying.GetComponent<HighlightEffect>());
		keys.Add(touweixia.GetComponent<HighlightEffect>());
		keys.Add(weishang.GetComponent<HighlightEffect>());
		keys.Add(weixia.GetComponent<HighlightEffect>());
		keys.Add(lingya.GetComponent<HighlightEffect>());
		keys.Add(shenshui.GetComponent<HighlightEffect>());
		curIndex = 0;
		keys[0].enabled = true;
	}

	private void Update()
	{
		if (isSwich)
		{
			if (Input.GetKeyDown(KeyCode.LeftArrow) || (Controller.UPvr_GetAxis2D(0).x < -0.2f && CheckAngle(Controller.UPvr_GetAxis2D(0).normalized, Vector2.left)))
			{
				isSwich = false;
				keys[curIndex].enabled = false;
				curIndex--;
				if (curIndex < 0)
				{
					curIndex = keys.Count - 1;
				}
				keys[curIndex].enabled = true;
			}
			else if (Input.GetKeyDown(KeyCode.RightArrow) || (Controller.UPvr_GetAxis2D(0).x > 0.2f && CheckAngle(Controller.UPvr_GetAxis2D(0).normalized, Vector2.right)))
			{
				isSwich = false;
				keys[curIndex].enabled = false;
				curIndex++;
				if (curIndex > keys.Count - 1)
				{
					curIndex = 0;
				}
				keys[curIndex].enabled = true;
			}
			else if (Input.GetKeyDown(KeyCode.UpArrow) || (Controller.UPvr_GetAxis2D(0).y > 0.2f && CheckAngle(Controller.UPvr_GetAxis2D(0).normalized, Vector2.up)))
			{
				isSwich = false;
				keys[curIndex].enabled = false;
				if (curIndex == 0)
				{
					curIndex = 9;
				}
				else if (curIndex == 1)
				{
					curIndex = 10;
				}
				else if (curIndex == 2)
				{
					curIndex = 0;
				}
				else if (curIndex == 3)
				{
					curIndex = 1;
				}
				else if (curIndex == 4)
				{
					curIndex = 2;
				}
				else if (curIndex == 5)
				{
					curIndex = 3;
				}
				else if (curIndex == 6)
				{
					curIndex = 3;
				}
				else if (curIndex == 7)
				{
					curIndex = 4;
				}
				else if (curIndex == 8)
				{
					curIndex = 6;
				}
				else if (curIndex == 9)
				{
					curIndex = 7;
				}
				else if (curIndex == 10)
				{
					curIndex = 8;
				}
				keys[curIndex].enabled = true;
			}
			else if (Input.GetKeyDown(KeyCode.DownArrow) || (Controller.UPvr_GetAxis2D(0).y < -0.2f && CheckAngle(Controller.UPvr_GetAxis2D(0).normalized, Vector2.down)))
			{
				isSwich = false;
				keys[curIndex].enabled = false;
				if (curIndex == 9)
				{
					curIndex = 0;
				}
				else if (curIndex == 10)
				{
					curIndex = 1;
				}
				else if (curIndex == 0)
				{
					curIndex = 2;
				}
				else if (curIndex == 1)
				{
					curIndex = 3;
				}
				else if (curIndex == 2)
				{
					curIndex = 4;
				}
				else if (curIndex == 3)
				{
					curIndex = 6;
				}
				else if (curIndex == 4)
				{
					curIndex = 7;
				}
				else if (curIndex == 5)
				{
					curIndex = 7;
				}
				else if (curIndex == 6)
				{
					curIndex = 8;
				}
				else if (curIndex == 7)
				{
					curIndex = 9;
				}
				else if (curIndex == 8)
				{
					curIndex = 10;
				}
				keys[curIndex].enabled = true;
			}
		}
		else if (Input.GetKeyUp(KeyCode.LeftArrow) || Input.GetKeyUp(KeyCode.RightArrow) || Input.GetKeyUp(KeyCode.UpArrow) || Input.GetKeyUp(KeyCode.DownArrow) || (Controller.UPvr_GetAxis2D(0).x > -0.2f && Controller.UPvr_GetAxis2D(0).x < 0.2f && Controller.UPvr_GetAxis2D(0).y < 0.2f && Controller.UPvr_GetAxis2D(0).y > -0.2f))
		{
			isSwich = true;
		}
		if (Controller.UPvr_GetKeyDown(0, Pvr_KeyCode.TOUCHPAD) || Input.GetKeyDown(KeyCode.Space))
		{
			if (controller == null)
			{
				SetNearestBed();
			}
			switch (curIndex)
			{
			case 0:
				controller.ChangeToXiuXian();
				break;
			case 1:
				controller.ChangeToYueDu();
				break;
			case 2:
				isLongPressHead = true;
				controller.ChangeHead();
				break;
			case 3:
				isLongPressHead = true;
				controller.ChangeHead(isBack: true);
				break;
			case 4:
				isLongPressHead = true;
				isLongPressTail = true;
				controller.ChangeHead();
				controller.ChangeTail();
				break;
			case 5:
				controller.ChangeToGuanYing();
				break;
			case 6:
				isLongPressHead = true;
				isLongPressTail = true;
				controller.ChangeHead(isBack: true);
				controller.ChangeTail(isBack: true);
				break;
			case 7:
				isLongPressTail = true;
				controller.ChangeTail();
				break;
			case 8:
				isLongPressTail = true;
				controller.ChangeTail(isBack: true);
				break;
			case 9:
				controller.ChangeToLingYa();
				break;
			case 10:
				controller.ChangeToShenShui();
				break;
			}
		}
		else if ((isLongPressHead || isLongPressTail) && (Controller.UPvr_GetKeyUp(0, Pvr_KeyCode.TOUCHPAD) || Input.GetKeyUp(KeyCode.Space)))
		{
			if (isLongPressHead)
			{
				isLongPressHead = false;
				controller.StopHead();
			}
			if (isLongPressTail)
			{
				isLongPressTail = false;
				controller.StopTail();
			}
		}
	}

	public void SetNearestBed()
	{
		controller = GetNearestBed();
		arrowTra.position = new Vector3(controller.transform.position.x, arrowTra.position.y, controller.transform.position.z);
	}

	private YireeBedController GetNearestBed()
	{
		YireeBedController yireeBedController = yireeBeds[0];
		for (int i = 1; i < yireeBeds.Count; i++)
		{
			if (Vector3.Distance(yireeBeds[i].transform.position, base.transform.position) < Vector3.Distance(yireeBedController.transform.position, base.transform.position))
			{
				yireeBedController = yireeBeds[i];
			}
		}
		return yireeBedController;
	}

	private bool CheckAngle(Vector2 normal, Vector2 vector)
	{
		if (Vector2.Angle(normal, vector) < 45f)
		{
			return true;
		}
		return false;
	}
}
public class YireeBedController : MonoBehaviour
{
	public Animator headBedAni;

	public Animator tailBedAni;

	private float curHeadFrame;

	private float curTailFrame;

	private float totalTime = 2.958f;

	private float[] headAnisFrame = new float[5] { 380f, 399f, 404f, 437f, 451f };

	private float[] tailAnisFrame = new float[5] { 460f, 488f, 496f, 513f, 531f };

	private bool IsHeadAnimator;

	private bool IsTailAnimator;

	private float bedSpeed = 0.25f;

	private bool isHeadBack;

	private bool isTailBack;

	private float currentTime;

	private void Start()
	{
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.Alpha1))
		{
			ChangeToXiuXian();
		}
		if (Input.GetKeyDown(KeyCode.Alpha2))
		{
			ChangeToYueDu();
		}
		if (Input.GetKeyDown(KeyCode.Alpha3))
		{
			ChangeToGuanYing();
		}
		if (Input.GetKeyDown(KeyCode.Alpha4))
		{
			ChangeToLingYa();
		}
		if (Input.GetKeyDown(KeyCode.Alpha5))
		{
			ChangeToShenShui();
		}
		if (Input.GetKeyDown(KeyCode.Alpha6))
		{
			ChangeToZhiHan();
		}
		if (Input.GetKeyDown(KeyCode.O))
		{
			ChangeHead();
		}
		else if (Input.GetKeyUp(KeyCode.O))
		{
			StopHead();
		}
		if (Input.GetKeyDown(KeyCode.P))
		{
			ChangeHead(isBack: true);
		}
		else if (Input.GetKeyUp(KeyCode.P))
		{
			StopHead();
		}
		if (Input.GetKeyDown(KeyCode.K))
		{
			ChangeTail();
		}
		else if (Input.GetKeyUp(KeyCode.K))
		{
			StopTail();
		}
		if (Input.GetKeyDown(KeyCode.L))
		{
			ChangeTail(isBack: true);
		}
		else if (Input.GetKeyUp(KeyCode.L))
		{
			StopTail();
		}
	}

	public void ChangeHead(bool isBack = false)
	{
		if (!IsHeadAnimator)
		{
			IsHeadAnimator = true;
			headBedAni.speed = bedSpeed;
			headBedAni.Play(isBack ? "ziyouback" : "ziyou", 0, isBack ? (1f - curHeadFrame) : curHeadFrame);
			isHeadBack = isBack;
		}
	}

	public void StopHead()
	{
		IsHeadAnimator = false;
		curHeadFrame = GetCurAnimatorFrame(headBedAni);
		if (isHeadBack)
		{
			curHeadFrame = 1f - curHeadFrame;
		}
		headBedAni.speed = 0f;
	}

	public void ChangeTail(bool isBack = false)
	{
		if (!IsTailAnimator)
		{
			IsTailAnimator = true;
			tailBedAni.speed = bedSpeed;
			tailBedAni.Play(isBack ? "ziyouback" : "ziyou", 0, isBack ? (1f - curTailFrame) : curTailFrame);
			isTailBack = isBack;
		}
	}

	public void StopTail()
	{
		IsTailAnimator = false;
		curTailFrame = GetCurAnimatorFrame(tailBedAni);
		if (isTailBack)
		{
			curTailFrame = 1f - curTailFrame;
		}
		tailBedAni.speed = 0f;
	}

	public void ChangeToXiuXian()
	{
		if (!IsHeadAnimator && !IsTailAnimator)
		{
			if (curHeadFrame > 0f)
			{
				PlayHeadBedAni(0f);
			}
			float num = (tailAnisFrame[2] - tailAnisFrame[0]) / (tailAnisFrame[tailAnisFrame.Length - 1] - tailAnisFrame[0]);
			if (curTailFrame != num)
			{
				PlayTailBedAni(num);
			}
		}
	}

	public void ChangeToYueDu()
	{
		if (!IsHeadAnimator && !IsTailAnimator)
		{
			float num = 1f;
			if (curHeadFrame != num)
			{
				PlayHeadBedAni(num);
			}
			float num2 = 1f;
			if (curTailFrame != num2)
			{
				PlayTailBedAni(num2);
			}
		}
	}

	public void ChangeToGuanYing()
	{
		if (!IsHeadAnimator && !IsTailAnimator)
		{
			float num = (headAnisFrame[3] - headAnisFrame[0]) / (headAnisFrame[headAnisFrame.Length - 1] - headAnisFrame[0]);
			if (curHeadFrame != num)
			{
				PlayHeadBedAni(num);
			}
			float num2 = (tailAnisFrame[1] - tailAnisFrame[0]) / (tailAnisFrame[tailAnisFrame.Length - 1] - tailAnisFrame[0]);
			if (curTailFrame != num2)
			{
				PlayTailBedAni(num2);
			}
		}
	}

	public void ChangeToLingYa()
	{
		if (!IsHeadAnimator && !IsTailAnimator)
		{
			float num = (headAnisFrame[1] - headAnisFrame[0]) / (headAnisFrame[headAnisFrame.Length - 1] - headAnisFrame[0]);
			if (curHeadFrame != num)
			{
				PlayHeadBedAni(num);
			}
			float num2 = (tailAnisFrame[3] - tailAnisFrame[0]) / (tailAnisFrame[tailAnisFrame.Length - 1] - tailAnisFrame[0]);
			if (curTailFrame != num2)
			{
				PlayTailBedAni(num2);
			}
		}
	}

	public void ChangeToShenShui()
	{
		if (!IsHeadAnimator && !IsTailAnimator)
		{
			float num = 0f;
			if (curHeadFrame != num)
			{
				PlayHeadBedAni(num);
			}
			float num2 = 0f;
			if (curTailFrame != num2)
			{
				PlayTailBedAni(num2);
			}
		}
	}

	public void ChangeToZhiHan()
	{
		if (!IsHeadAnimator && !IsTailAnimator)
		{
			float num = (headAnisFrame[2] - headAnisFrame[0]) / (headAnisFrame[headAnisFrame.Length - 1] - headAnisFrame[0]);
			if (curHeadFrame != num)
			{
				PlayHeadBedAni(num);
			}
			float num2 = 0f;
			if (curTailFrame != num2)
			{
				PlayTailBedAni(num2);
			}
		}
	}

	public void DelayHander(float time, Action action)
	{
		StartCoroutine(Wait(time, action));
	}

	private IEnumerator Wait(float time, Action action)
	{
		yield return new WaitForSeconds(time);
		action?.Invoke();
	}

	private void PlayHeadBedAni(float target)
	{
		IsHeadAnimator = true;
		headBedAni.speed = bedSpeed;
		headBedAni.Play((target > curHeadFrame) ? "ziyou" : "ziyouback", 0, (target > curHeadFrame) ? curHeadFrame : (1f - curHeadFrame));
		float time = Mathf.Abs(target - curHeadFrame) * totalTime / bedSpeed;
		DelayHander(time, delegate
		{
			headBedAni.speed = 0f;
			IsHeadAnimator = false;
			curHeadFrame = target;
		});
	}

	private void PlayTailBedAni(float target)
	{
		IsTailAnimator = true;
		tailBedAni.speed = bedSpeed;
		tailBedAni.Play((target > curTailFrame) ? "ziyou" : "ziyouback", 0, (target > curTailFrame) ? curTailFrame : (1f - curTailFrame));
		float time = Mathf.Abs(target - curTailFrame) * totalTime / bedSpeed;
		DelayHander(time, delegate
		{
			tailBedAni.speed = 0f;
			IsTailAnimator = false;
			curTailFrame = target;
		});
	}

	private float GetCurAnimatorFrame(Animator ani)
	{
		if (ani.GetCurrentAnimatorClipInfo(0).Length == 0)
		{
			return 0f;
		}
		currentTime = ani.GetCurrentAnimatorStateInfo(0).normalizedTime;
		if (currentTime >= 1f)
		{
			return 1f;
		}
		float length = ani.GetCurrentAnimatorClipInfo(0)[0].clip.length;
		float frameRate = ani.GetCurrentAnimatorClipInfo(0)[0].clip.frameRate;
		float num = length / (1f / frameRate);
		return (float)(int)(Mathf.Floor(num * currentTime) % num) / num;
	}
}
public class YireeBedController_old : MonoBehaviour
{
	public Animator headBedAni;

	public Animator tailBedAni;

	private int curHeadIndex;

	private int curTailIndex;

	private string[] headAnis = new string[5] { "pingtang", "lingya", "zhihan", "guanying", "yuedu" };

	private string[] headbackAnis = new string[5] { "pingtang", "lingyaback", "zhihanback", "guanyingback", "yueduback" };

	private float[] headAnisTime = new float[5] { 0f, 0.792f, 0.208f, 1.375f, 0.583f };

	private float[] headAnisFrame = new float[5] { 380f, 399f, 404f, 437f, 451f };

	private string[] tailAnis = new string[5] { "pingtang", "guanying", "xiuxian", "lingya", "yuedu" };

	private string[] tailbackAnis = new string[5] { "pingtang", "guanyingback", "xiuxianback", "lingyaback", "yueduback" };

	private float[] tailAnisTime = new float[5] { 0f, 1.167f, 0.333f, 0.708f, 0.75f };

	private float[] tailAnisFrame = new float[5] { 460f, 488f, 496f, 513f, 531f };

	private bool isHeadAnimator;

	private bool isTailAnimator;

	private float currentTime;

	private void Start()
	{
		curHeadIndex = 0;
		curTailIndex = 0;
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.Alpha1))
		{
			ChangeToXiuXian();
		}
		if (Input.GetKeyDown(KeyCode.Alpha2))
		{
			ChangeToYueDu();
		}
		if (Input.GetKeyDown(KeyCode.Alpha3))
		{
			ChangeToGuanYing();
		}
		if (Input.GetKeyDown(KeyCode.Alpha4))
		{
			ChangeToLingYa();
		}
		if (Input.GetKeyDown(KeyCode.Alpha5))
		{
			ChangeToShenShui();
		}
		if (Input.GetKeyDown(KeyCode.Alpha6))
		{
			ChangeToZhiHan();
		}
		if (Input.GetKeyDown(KeyCode.P))
		{
			headBedAni.speed = 0f;
			tailBedAni.speed = 0f;
		}
		if (Input.GetKeyDown(KeyCode.Space))
		{
			headBedAni.speed = 1f;
			tailBedAni.speed = 1f;
		}
	}

	public void ChangeHeadDown()
	{
		headBedAni.speed = 1f;
		headBedAni.SetTrigger("ziyou");
	}

	public void ChangeHeadUp()
	{
		headBedAni.speed = 1f;
		headBedAni.SetTrigger("ziyouback");
	}

	public void ChangeHeadStop()
	{
		headBedAni.speed = 0f;
	}

	public void ChangeTailDown()
	{
		tailBedAni.speed = 1f;
		tailBedAni.SetTrigger("ziyou");
	}

	public void ChangeTailUp()
	{
		tailBedAni.speed = 1f;
		tailBedAni.SetTrigger("ziyouback");
	}

	public void ChangeTailStop()
	{
		tailBedAni.speed = 0f;
	}

	public void ChangeToXiuXian()
	{
		if (!isHeadAnimator && !isTailAnimator)
		{
			isHeadAnimator = true;
			isTailAnimator = true;
			if (curHeadIndex > 0)
			{
				BackPlayHeadBedAni(0);
			}
			if (curTailIndex < 2)
			{
				PlayTailBedAni(2);
			}
			else if (curTailIndex > 2)
			{
				BackPlayTailBedAni(2);
			}
		}
	}

	public void ChangeToYueDu()
	{
		if (!isHeadAnimator && !isTailAnimator)
		{
			isHeadAnimator = true;
			isTailAnimator = true;
			if (curHeadIndex < 4)
			{
				PlayHeadBedAni(4);
			}
			if (curTailIndex < 4)
			{
				PlayTailBedAni(4);
			}
		}
	}

	public void ChangeToGuanYing()
	{
		if (!isHeadAnimator && !isTailAnimator)
		{
			isHeadAnimator = true;
			isTailAnimator = true;
			if (curHeadIndex < 3)
			{
				PlayHeadBedAni(3);
			}
			else if (curHeadIndex > 3)
			{
				BackPlayHeadBedAni(3);
			}
			if (curTailIndex < 1)
			{
				PlayTailBedAni(1);
			}
			else if (curTailIndex > 1)
			{
				BackPlayTailBedAni(1);
			}
		}
	}

	public void ChangeToLingYa()
	{
		if (!isHeadAnimator && !isTailAnimator)
		{
			isHeadAnimator = true;
			isTailAnimator = true;
			if (curHeadIndex < 1)
			{
				PlayHeadBedAni(1);
			}
			else if (curHeadIndex > 1)
			{
				BackPlayHeadBedAni(1);
			}
			if (curTailIndex < 3)
			{
				PlayTailBedAni(3);
			}
			else if (curTailIndex > 3)
			{
				BackPlayTailBedAni(3);
			}
		}
	}

	public void ChangeToShenShui()
	{
		if (!isHeadAnimator && !isTailAnimator)
		{
			isHeadAnimator = true;
			isTailAnimator = true;
			if (curHeadIndex > 0)
			{
				BackPlayHeadBedAni(0);
			}
			if (curTailIndex > 0)
			{
				BackPlayTailBedAni(0);
			}
		}
	}

	public void ChangeToZhiHan()
	{
		if (!isHeadAnimator && !isTailAnimator)
		{
			isHeadAnimator = true;
			isTailAnimator = true;
			if (curHeadIndex < 2)
			{
				PlayHeadBedAni(2);
			}
			else if (curHeadIndex > 2)
			{
				BackPlayHeadBedAni(2);
			}
			if (curTailIndex > 0)
			{
				BackPlayTailBedAni(0);
			}
		}
	}

	public void DelayHander(float time, Action action)
	{
		StartCoroutine(Wait(time, action));
	}

	private IEnumerator Wait(float time, Action action)
	{
		yield return new WaitForSeconds(time);
		action?.Invoke();
	}

	private void PlayHeadBedAni(int target)
	{
		if (curHeadIndex < target)
		{
			curHeadIndex++;
			headBedAni.SetTrigger(headAnis[curHeadIndex]);
			DelayHander(headAnisTime[curHeadIndex], delegate
			{
				PlayHeadBedAni(target);
			});
		}
		else
		{
			isHeadAnimator = false;
		}
	}

	private void BackPlayHeadBedAni(int target)
	{
		headBedAni.SetTrigger(headbackAnis[curHeadIndex]);
		DelayHander(headAnisTime[curHeadIndex], delegate
		{
			if (curHeadIndex > target)
			{
				curHeadIndex--;
				BackPlayHeadBedAni(target);
			}
			else
			{
				isHeadAnimator = false;
			}
		});
	}

	private void PlayTailBedAni(int target)
	{
		if (curTailIndex < target)
		{
			curTailIndex++;
			tailBedAni.SetTrigger(tailAnis[curTailIndex]);
			DelayHander(tailAnisTime[curTailIndex], delegate
			{
				PlayTailBedAni(target);
			});
		}
		else
		{
			isTailAnimator = false;
		}
	}

	private void BackPlayTailBedAni(int target)
	{
		tailBedAni.SetTrigger(tailbackAnis[curTailIndex]);
		DelayHander(tailAnisTime[curTailIndex], delegate
		{
			if (curTailIndex > target)
			{
				curTailIndex--;
				BackPlayTailBedAni(target);
			}
			else
			{
				isTailAnimator = false;
			}
		});
	}

	private void PlayAnimatorFromFrame()
	{
		currentTime = headBedAni.GetCurrentAnimatorStateInfo(0).normalizedTime;
		float length = headBedAni.GetCurrentAnimatorClipInfo(0)[0].clip.length;
		float frameRate = headBedAni.GetCurrentAnimatorClipInfo(0)[0].clip.frameRate;
		float num = length / (1f / frameRate);
		int num2 = (int)(Mathf.Floor(num * currentTime) % num);
		UnityEngine.Debug.Log(" Frame: " + num2 + "/" + num);
		float num3 = (float)num2 / num;
		if (num3 >= 0f && num3 < 1f)
		{
			OnPlayAnimatorFromFrame(headBedAni.GetCurrentAnimatorClipInfo(0)[0].clip.name, num3);
		}
	}

	public void OnPlayAnimatorFromFrame(string stateName, float frame)
	{
		UnityEngine.Debug.Log(stateName);
		headBedAni.speed = 0.5f;
		headBedAni.Play("ziyou", 0, frame);
	}

	public void OnPlayBackAnimatorFromFrame(string stateName, float frame)
	{
		headBedAni.speed = 0.5f;
		headBedAni.Play("ziyouback", 0, frame);
	}
}
public class YireeCurtainsController : MonoBehaviour
{
	public Animator leftCurtainsAni;

	public Animator rightCurtainsAni;

	private Transform canvasTra;

	private HighlightEffect highlight;

	private float curFrame;

	private bool IsAnimator;

	private float speed = 0.25f;

	private bool IsBack;

	private Ray ray;

	private RaycastHit hit;

	private bool isSelect;

	private float currentTime;

	private void Start()
	{
		canvasTra = base.transform.Find("Canvas");
		highlight = base.transform.GetComponentInChildren<HighlightEffect>();
	}

	private void Update()
	{
		ray.direction = BedRemoteController.Instance.rightHand.transform.forward;
		ray.origin = BedRemoteController.Instance.rightHand.transform.position;
		if (Physics.Raycast(ray, out hit, 10f, 1 << LayerMask.NameToLayer("Keys")))
		{
			if (hit.transform.Equals(base.transform))
			{
				if (BedRemoteController.Instance.isShowCurtainsTip)
				{
					canvasTra.gameObject.SetActive(value: true);
				}
				highlight.enabled = true;
			}
		}
		else if (highlight.enabled)
		{
			canvasTra.gameObject.SetActive(value: false);
			highlight.enabled = false;
		}
		if (Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.A) || Input.GetKeyDown(KeyCode.F1))
		{
			ray.direction = BedRemoteController.Instance.rightHand.transform.forward;
			ray.origin = BedRemoteController.Instance.rightHand.transform.position;
			if (Physics.Raycast(ray, out hit, 10f, 1 << LayerMask.NameToLayer("Keys")) && hit.transform.Equals(base.transform))
			{
				isSelect = true;
				BedRemoteController.Instance.isShowCurtainsTip = false;
				ChangeCurtains();
			}
		}
		else if (isSelect && (Controller.UPvr_GetKeyUp(1, Pvr_KeyCode.A) || Input.GetKeyUp(KeyCode.F1)))
		{
			isSelect = false;
			StopHead();
		}
		if (Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.B) || Input.GetKeyDown(KeyCode.F2))
		{
			ray.direction = BedRemoteController.Instance.rightHand.transform.forward;
			ray.origin = BedRemoteController.Instance.rightHand.transform.position;
			if (Physics.Raycast(ray, out hit, 10f, 1 << LayerMask.NameToLayer("Keys")) && hit.transform.Equals(base.transform))
			{
				isSelect = true;
				BedRemoteController.Instance.isShowCurtainsTip = false;
				ChangeCurtains(isBack: true);
			}
		}
		else if (isSelect && (Controller.UPvr_GetKeyUp(1, Pvr_KeyCode.B) || Input.GetKeyUp(KeyCode.F2)))
		{
			isSelect = false;
			StopHead();
		}
	}

	public void ChangeCurtains(bool isBack = false)
	{
		if (!IsAnimator)
		{
			IsAnimator = true;
			leftCurtainsAni.speed = speed;
			rightCurtainsAni.speed = speed;
			leftCurtainsAni.Play(isBack ? "Close" : "Open", 0, isBack ? (1f - curFrame) : curFrame);
			rightCurtainsAni.Play(isBack ? "Close" : "Open", 0, isBack ? (1f - curFrame) : curFrame);
			IsBack = isBack;
		}
	}

	public void StopHead()
	{
		IsAnimator = false;
		curFrame = GetCurAnimatorFrame(leftCurtainsAni);
		if (IsBack)
		{
			curFrame = 1f - curFrame;
		}
		leftCurtainsAni.speed = 0f;
		rightCurtainsAni.speed = 0f;
	}

	private float GetCurAnimatorFrame(Animator ani)
	{
		if (ani.GetCurrentAnimatorClipInfo(0).Length == 0)
		{
			return 0f;
		}
		currentTime = ani.GetCurrentAnimatorStateInfo(0).normalizedTime;
		if (currentTime >= 1f)
		{
			return 1f;
		}
		float length = ani.GetCurrentAnimatorClipInfo(0)[0].clip.length;
		float frameRate = ani.GetCurrentAnimatorClipInfo(0)[0].clip.frameRate;
		float num = length / (1f / frameRate);
		return (float)(int)(Mathf.Floor(num * currentTime) % num) / num;
	}
}
public class YireeLightController : MonoBehaviour
{
	public Light m_light;

	private Transform canvasTra;

	private Ray ray;

	private RaycastHit hit;

	private void Start()
	{
		canvasTra = base.transform.Find("Canvas");
	}

	private void Update()
	{
		if (BedRemoteController.Instance.isShowLightTip)
		{
			ray.direction = BedRemoteController.Instance.rightHand.transform.forward;
			ray.origin = BedRemoteController.Instance.rightHand.transform.position;
			if (Physics.Raycast(ray, out hit, 10f, 1 << LayerMask.NameToLayer("Keys")))
			{
				if (hit.transform.Equals(base.transform))
				{
					canvasTra.gameObject.SetActive(value: true);
				}
			}
			else if (canvasTra.gameObject.activeSelf)
			{
				canvasTra.gameObject.SetActive(value: false);
			}
		}
		else if (canvasTra.gameObject.activeSelf)
		{
			canvasTra.gameObject.SetActive(value: false);
		}
		if (Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.TRIGGER))
		{
			ray.direction = BedRemoteController.Instance.rightHand.transform.forward;
			ray.origin = BedRemoteController.Instance.rightHand.transform.position;
			if (Physics.Raycast(ray, out hit, 10f, 1 << LayerMask.NameToLayer("Keys")) && hit.transform.Equals(base.transform))
			{
				BedRemoteController.Instance.isShowLightTip = false;
				m_light.enabled = !m_light.enabled;
			}
		}
	}
}
public class YireeTVController : MonoBehaviour
{
	public VideoPlayer videoPlayer;

	private Ray ray;

	private RaycastHit hit;

	private bool isPlaying;

	private void Start()
	{
	}

	private void Update()
	{
		if (!Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.TRIGGER))
		{
			return;
		}
		ray.direction = BedRemoteController.Instance.rightHand.transform.forward;
		ray.origin = BedRemoteController.Instance.rightHand.transform.position;
		if (Physics.Raycast(ray, out hit, 10f, 1 << LayerMask.NameToLayer("Keys")) && hit.transform.Equals(base.transform))
		{
			if (isPlaying)
			{
				videoPlayer.Pause();
			}
			else
			{
				videoPlayer.Play();
			}
			isPlaying = !isPlaying;
		}
	}
}
public class SimpleGPUInstancingExample : MonoBehaviour
{
	public Transform Prefab;

	public Material InstancedMaterial;

	private void Awake()
	{
		InstancedMaterial.enableInstancing = true;
		float num = 4f;
		for (int i = 0; i < 1000; i++)
		{
			Transform obj = UnityEngine.Object.Instantiate(Prefab, new Vector3(UnityEngine.Random.Range(0f - num, num), num + UnityEngine.Random.Range(0f - num, num), UnityEngine.Random.Range(0f - num, num)), Quaternion.identity);
			MaterialPropertyBlock materialPropertyBlock = new MaterialPropertyBlock();
			Color value = new Color(UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(0f, 1f));
			materialPropertyBlock.SetColor("_Color", value);
			obj.GetComponent<MeshRenderer>().SetPropertyBlock(materialPropertyBlock);
		}
	}
}
public class SimpleMoveExample : MonoBehaviour
{
	private Vector3 m_previous;

	private Vector3 m_target;

	private Vector3 m_originalPosition;

	public Vector3 BoundingVolume = new Vector3(3f, 1f, 3f);

	public float Speed = 10f;

	private void Start()
	{
		m_originalPosition = base.transform.position;
		m_previous = base.transform.position;
		m_target = base.transform.position;
	}

	private void Update()
	{
		base.transform.position = Vector3.Slerp(m_previous, m_target, Time.deltaTime * Speed);
		m_previous = base.transform.position;
		if (Vector3.Distance(m_target, base.transform.position) < 0.1f)
		{
			m_target = base.transform.position + UnityEngine.Random.onUnitSphere * UnityEngine.Random.Range(0.7f, 4f);
			m_target.Set(Mathf.Clamp(m_target.x, m_originalPosition.x - BoundingVolume.x, m_originalPosition.x + BoundingVolume.x), Mathf.Clamp(m_target.y, m_originalPosition.y - BoundingVolume.y, m_originalPosition.y + BoundingVolume.y), Mathf.Clamp(m_target.z, m_originalPosition.z - BoundingVolume.z, m_originalPosition.z + BoundingVolume.z));
		}
	}
}
public class Smear : MonoBehaviour
{
	private Queue<Vector3> m_recentPositions = new Queue<Vector3>();

	public int FramesBufferSize;

	public Renderer Renderer;

	private Material m_instancedMaterial;

	private Material InstancedMaterial
	{
		get
		{
			return m_instancedMaterial;
		}
		set
		{
			m_instancedMaterial = value;
		}
	}

	private void Start()
	{
		InstancedMaterial = Renderer.material;
	}

	private void LateUpdate()
	{
		if (m_recentPositions.Count > FramesBufferSize)
		{
			InstancedMaterial.SetVector("_PrevPosition", m_recentPositions.Dequeue());
		}
		InstancedMaterial.SetVector("_Position", base.transform.position);
		m_recentPositions.Enqueue(base.transform.position);
	}
}
[ExecuteInEditMode]
public class PostProcessExample : MonoBehaviour
{
	public Material PostProcessMat;

	private void Awake()
	{
		if (PostProcessMat == null)
		{
			base.enabled = false;
		}
		else
		{
			PostProcessMat.mainTexture = PostProcessMat.mainTexture;
		}
	}

	private void OnRenderImage(RenderTexture src, RenderTexture dest)
	{
		Graphics.Blit(src, dest, PostProcessMat);
	}
}
[ExecuteInEditMode]
public class SpriteMaskController : MonoBehaviour
{
	private SpriteRenderer m_spriteRenderer;

	private Vector4 m_uvs;

	private void OnEnable()
	{
		m_spriteRenderer = GetComponent<SpriteRenderer>();
		m_uvs = DataUtility.GetInnerUV(m_spriteRenderer.sprite);
		m_spriteRenderer.sharedMaterial.SetVector("_CustomUVS", m_uvs);
	}
}
[AddComponentMenu("Camera-Control/Smooth Mouse Orbit - Unluck Software")]
public class SmoothCameraOrbit : MonoBehaviour
{
	public Transform target;

	public Vector3 targetOffset;

	public float distance = 5f;

	public float maxDistance = 20f;

	public float minDistance = 0.6f;

	public float xSpeed = 200f;

	public float ySpeed = 200f;

	public int yMinLimit = -80;

	public int yMaxLimit = 80;

	public int zoomRate = 40;

	public float panSpeed = 0.3f;

	public float zoomDampening = 5f;

	public float autoRotate = 1f;

	private float xDeg;

	private float yDeg;

	private float currentDistance;

	private float desiredDistance;

	private Quaternion currentRotation;

	private Quaternion desiredRotation;

	private Quaternion rotation;

	private Vector3 position;

	private float idleTimer;

	private float idleSmooth;

	private void Start()
	{
		Init();
	}

	private void OnEnable()
	{
		Init();
	}

	public void Init()
	{
		if (!target)
		{
			GameObject gameObject = new GameObject("Cam Target");
			gameObject.transform.position = base.transform.position + base.transform.forward * distance;
			target = gameObject.transform;
		}
		currentDistance = distance;
		desiredDistance = distance;
		position = base.transform.position;
		rotation = base.transform.rotation;
		currentRotation = base.transform.rotation;
		desiredRotation = base.transform.rotation;
		xDeg = Vector3.Angle(Vector3.right, base.transform.right);
		yDeg = Vector3.Angle(Vector3.up, base.transform.up);
		position = target.position - (rotation * Vector3.forward * currentDistance + targetOffset);
	}

	private void LateUpdate()
	{
		if (Input.GetMouseButton(2) && Input.GetKey(KeyCode.LeftAlt) && Input.GetKey(KeyCode.LeftControl))
		{
			desiredDistance -= Input.GetAxis("Mouse Y") * Time.deltaTime * (float)zoomRate * 0.125f * Mathf.Abs(desiredDistance);
		}
		else if (Input.GetMouseButton(0))
		{
			xDeg += Input.GetAxis("Mouse X") * xSpeed * 0.02f;
			yDeg -= Input.GetAxis("Mouse Y") * ySpeed * 0.02f;
			yDeg = ClampAngle(yDeg, yMinLimit, yMaxLimit);
			desiredRotation = Quaternion.Euler(yDeg, xDeg, 0f);
			currentRotation = base.transform.rotation;
			rotation = Quaternion.Lerp(currentRotation, desiredRotation, Time.deltaTime * zoomDampening);
			base.transform.rotation = rotation;
			idleTimer = 0f;
			idleSmooth = 0f;
		}
		else
		{
			idleTimer += Time.deltaTime;
			if (idleTimer > autoRotate && autoRotate > 0f)
			{
				idleSmooth += (Time.deltaTime + idleSmooth) * 0.005f;
				idleSmooth = Mathf.Clamp(idleSmooth, 0f, 1f);
				xDeg += xSpeed * 0.001f * idleSmooth;
			}
			yDeg = ClampAngle(yDeg, yMinLimit, yMaxLimit);
			desiredRotation = Quaternion.Euler(yDeg, xDeg, 0f);
			currentRotation = base.transform.rotation;
			rotation = Quaternion.Lerp(currentRotation, desiredRotation, Time.deltaTime * zoomDampening * 2f);
			base.transform.rotation = rotation;
		}
		desiredDistance -= Input.GetAxis("Mouse ScrollWheel") * Time.deltaTime * (float)zoomRate * Mathf.Abs(desiredDistance);
		desiredDistance = Mathf.Clamp(desiredDistance, minDistance, maxDistance);
		currentDistance = Mathf.Lerp(currentDistance, desiredDistance, Time.deltaTime * zoomDampening);
		position = target.position - (rotation * Vector3.forward * currentDistance + targetOffset);
		base.transform.position = position;
	}

	private static float ClampAngle(float angle, float min, float max)
	{
		if (angle < -360f)
		{
			angle += 360f;
		}
		if (angle > 360f)
		{
			angle -= 360f;
		}
		return Mathf.Clamp(angle, min, max);
	}
}
[AddComponentMenu("Camera-Control/Mouse Look")]
public class MouseLook : MonoBehaviour
{
	public enum RotationAxes
	{
		MouseXAndY,
		MouseX,
		MouseY
	}

	public RotationAxes axes;

	public float sensitivityX = 15f;

	public float sensitivityY = 15f;

	public float minimumX = -360f;

	public float maximumX = 360f;

	public float minimumY = -60f;

	public float maximumY = 60f;

	private float rotationX;

	private float rotationY;

	private Quaternion originalRotation;

	private void Update()
	{
		if (axes == RotationAxes.MouseXAndY)
		{
			rotationX += Input.GetAxis("Mouse X") * sensitivityX;
			rotationY += Input.GetAxis("Mouse Y") * sensitivityY;
			rotationX = ClampAngle(rotationX, minimumX, maximumX);
			rotationY = ClampAngle(rotationY, minimumY, maximumY);
			Quaternion quaternion = Quaternion.AngleAxis(rotationX, Vector3.up);
			Quaternion quaternion2 = Quaternion.AngleAxis(rotationY, Vector3.left);
			base.transform.localRotation = originalRotation * quaternion * quaternion2;
		}
		else if (axes == RotationAxes.MouseX)
		{
			rotationX += Input.GetAxis("Mouse X") * sensitivityX;
			rotationX = ClampAngle(rotationX, minimumX, maximumX);
			Quaternion quaternion3 = Quaternion.AngleAxis(rotationX, Vector3.up);
			base.transform.localRotation = originalRotation * quaternion3;
		}
		else
		{
			rotationY += Input.GetAxis("Mouse Y") * sensitivityY;
			rotationY = ClampAngle(rotationY, minimumY, maximumY);
			Quaternion quaternion4 = Quaternion.AngleAxis(rotationY, Vector3.left);
			base.transform.localRotation = originalRotation * quaternion4;
		}
	}

	private void Start()
	{
		if ((bool)GetComponent<Rigidbody>())
		{
			GetComponent<Rigidbody>().freezeRotation = true;
		}
		originalRotation = base.transform.localRotation;
	}

	public static float ClampAngle(float angle, float min, float max)
	{
		if (angle < -360f)
		{
			angle += 360f;
		}
		if (angle > 360f)
		{
			angle -= 360f;
		}
		return Mathf.Clamp(angle, min, max);
	}
}
public class YuanYuZhouController : MonoBehaviour
{
	public GameObject weiaixin;

	public GameObject weiaizhi;

	public GameObject gymCenter;

	public GameObject yiree;

	public GameObject art;

	public GameObject rightHand;

	public GameObject operationTip;

	public GameObject handTip;

	public GameObject deliveryTip;

	public Button nextTipBtn;

	public Button closeTipBtn;

	private Ray ray;

	private RaycastHit hit;

	private void Start()
	{
		base.transform.position = Load.lastPostion;
		Load.InitVersion();
		ray = default(Ray);
		hit = default(RaycastHit);
		InitTip();
	}

	private void Update()
	{
		if (!Controller.UPvr_GetKeyDown(Controller.UPvr_GetMainHandNess(), Pvr_KeyCode.TRIGGER) && !Input.GetMouseButtonDown(0))
		{
			return;
		}
		ray.direction = rightHand.transform.forward;
		ray.origin = rightHand.transform.position;
		if (Physics.Raycast(ray, out hit, 15f, 1 << LayerMask.NameToLayer("Keys")))
		{
			if (hit.transform.gameObject.Equals(weiaixin))
			{
				Load.lastPostion = base.transform.position;
				Load.LoadScene2(ScenesHelper.WeiAiXinCenterScene);
			}
			else if (hit.transform.gameObject.Equals(weiaizhi))
			{
				Load.lastPostion = base.transform.position;
				Load.LoadScene2(ScenesHelper.WeiAiZhiCenterScene);
			}
			else if (hit.transform.gameObject.Equals(gymCenter))
			{
				Load.lastPostion = base.transform.position;
				Load.LoadScene2(ScenesHelper.Sports_GymCenterScene);
			}
			else if (hit.transform.gameObject.Equals(yiree))
			{
				Load.lastPostion = base.transform.position;
				Load.LoadScene2(ScenesHelper.YireeBedCenterScene);
			}
			else if (hit.transform.gameObject.Equals(art))
			{
				Load.lastPostion = base.transform.position;
				Load.LoadScene2(ScenesHelper.ChineseBrushScene);
			}
		}
	}

	private void InitTip()
	{
		if (PlayerPrefs.HasKey("OperationTip_IsShowed"))
		{
			operationTip.SetActive(value: false);
			return;
		}
		operationTip.SetActive(value: true);
		handTip.SetActive(value: true);
		deliveryTip.SetActive(value: false);
		nextTipBtn.gameObject.SetActive(value: true);
		closeTipBtn.gameObject.SetActive(value: false);
		nextTipBtn.onClick.AddListener(NextTipBtnHander);
		closeTipBtn.onClick.AddListener(CloseTipBtnHander);
		PlayerPrefs.SetInt("OperationTip_IsShowed", 1);
	}

	private void NextTipBtnHander()
	{
		handTip.SetActive(value: false);
		deliveryTip.SetActive(value: true);
		nextTipBtn.gameObject.SetActive(value: false);
		closeTipBtn.gameObject.SetActive(value: true);
	}

	private void CloseTipBtnHander()
	{
		operationTip.SetActive(value: false);
	}
}
namespace TFHC_Shader_Samples
{
	public class highlightAnimated : MonoBehaviour
	{
		private Material mat;

		private void Start()
		{
			mat = GetComponent<Renderer>().material;
		}

		private void OnMouseEnter()
		{
			switchhighlighted(highlighted: true);
		}

		private void OnMouseExit()
		{
			switchhighlighted(highlighted: false);
		}

		private void switchhighlighted(bool highlighted)
		{
			mat.SetFloat("_Highlighted", highlighted ? 1f : 0f);
		}
	}
}
namespace TFHC_ForceShield_Shader_Sample
{
	public class ForceShieldDestroyBall : MonoBehaviour
	{
		public float lifetime = 5f;

		private void Start()
		{
			UnityEngine.Object.Destroy(base.gameObject, lifetime);
		}
	}
	public class ForceShieldImpactDetection : MonoBehaviour
	{
		private float hitTime;

		private Material mat;

		private void Start()
		{
			mat = GetComponent<Renderer>().material;
		}

		private void Update()
		{
			if (hitTime > 0f)
			{
				hitTime -= Time.deltaTime * 1000f;
				if (hitTime < 0f)
				{
					hitTime = 0f;
				}
				mat.SetFloat("_HitTime", hitTime);
			}
		}

		private void OnCollisionEnter(UnityEngine.Collision collision)
		{
			ContactPoint[] contacts = collision.contacts;
			foreach (ContactPoint contactPoint in contacts)
			{
				mat.SetVector("_HitPosition", base.transform.InverseTransformPoint(contactPoint.point));
				hitTime = 500f;
				mat.SetFloat("_HitTime", hitTime);
			}
		}
	}
	public class ForceShieldShootBall : MonoBehaviour
	{
		public Rigidbody bullet;

		public Transform origshoot;

		public float speed = 1000f;

		private float distance = 10f;

		private void Update()
		{
			if (Input.GetButtonDown("Fire1"))
			{
				Vector3 position = new Vector3(Input.mousePosition.x, Input.mousePosition.y, distance);
				position = Camera.main.ScreenToWorldPoint(position);
				Rigidbody rigidbody = UnityEngine.Object.Instantiate(bullet, base.transform.position, Quaternion.identity);
				rigidbody.transform.LookAt(position);
				rigidbody.AddForce(rigidbody.transform.forward * speed);
			}
		}
	}
}
namespace SciFiArsenal
{
	public class SciFiRotation : MonoBehaviour
	{
		public enum spaceEnum
		{
			Local,
			World
		}

		[Header("Rotate axises by degrees per second")]
		public Vector3 rotateVector = Vector3.zero;

		public spaceEnum rotateSpace;

		private void Start()
		{
		}

		private void Update()
		{
			if (rotateSpace == spaceEnum.Local)
			{
				base.transform.Rotate(rotateVector * Time.deltaTime);
			}
			if (rotateSpace == spaceEnum.World)
			{
				base.transform.Rotate(rotateVector * Time.deltaTime, Space.World);
			}
		}
	}
}
namespace WordFormation
{
	public class WordFormationLevel
	{
		public int LevelID;

		public string LevelName;

		public int InitialNum;

		public float LimitTime;

		public int BaseScore;

		public int ChallengeNum;

		public float LightTime;

		public float CoolingTime;

		public int IsAddNum;

		public int IsReduceTime;

		public int IsIdiom;

		public int UpshiftRequire;

		public int UpshiftGrade;

		public int DownshiftRequire;

		public int DownshiftGrade;
	}
	public class WordFormationStrength
	{
		public int StrengthID;

		public int StrengthGrade;

		public float ScoreAddition;

		public int AddNum;

		public float TimeReduce;

		public float IdiomPro;

		public int IdiomNum;
	}
	public class WordLibrial
	{
		public string Keyword;

		public int LevelLimit;

		public int Position;
	}
	public class IdiomWord
	{
		public string Idiom;
	}
	public class CheckpointManager
	{
		public static Dictionary<int, WordFormationLevel> LevelDataDic = new Dictionary<int, WordFormationLevel>();

		public static Dictionary<int, WordFormationStrength> StrengthDataDic = new Dictionary<int, WordFormationStrength>();

		public static List<WordLibrial> WordTableDatas = new List<WordLibrial>();

		public static List<WordLibrial> FirstWordTableDatas = new List<WordLibrial>();

		public static List<WordLibrial> EndWordTableDatas = new List<WordLibrial>();

		public static List<WordLibrial> IdiomTableDatas = new List<WordLibrial>();

		public static List<string> IdiomLibraryDatas = new List<string>();

		public static int curLevelID;

		public static int curStrengthID;

		public static float gameDuration;

		public static float gameDurationed;

		public static int curScore;

		public static string startLevel;

		public static string minLevel;

		public static string maxLevel;

		public static int allPass;

		public static int perfectNum;

		public static int continuateMaxNum;

		public static int timeOutNum;

		public static int totalSubject;

		public static int answerSubject;

		public static List<float> answersFrequency;

		public static int containWordNum;

		public static int containWordTotal;

		public static int firstWordNum;

		public static int firstWordTotal;

		public static int lastWordNum;

		public static int lastWordTotal;

		public static int idiomWordNum;

		public static int idiomWordTotal;

		public static bool IsStartGame = false;

		public static bool IsPlayGame = false;

		public static bool IsShowAgain = false;

		public static int IsReverse = 0;

		private static int curErrorNum;

		private static int curHitIndex;

		private static string curRightKeys;

		private static bool curIsRightSubject = true;

		private static List<string> curMemoryNums = new List<string>();

		private static List<bool> curSubjectRight = new List<bool>();

		public static WordFormationLevel CurLevel => LevelDataDic[curLevelID];

		public static WordFormationStrength CurStrength => StrengthDataDic[curStrengthID];

		public static int GetScore => (int)((float)CurLevel.BaseScore * (1f + CurStrength.ScoreAddition));

		public static int GetWordNum => CurLevel.InitialNum + ((CurLevel.IsAddNum != 0) ? CurStrength.AddNum : 0);

		public static float GetLightTime => CurLevel.LightTime - ((CurLevel.IsReduceTime == 0) ? 0f : CurStrength.TimeReduce);

		public static string GetCurLevel => LevelDataDic[curLevelID].LevelName + "-" + StrengthDataDic[curStrengthID].StrengthGrade;

		public static void StartTheLevel(CourseDetail.Data data)
		{
			if (data != null)
			{
				if (data.game_data == null)
				{
					string text = data.level + "-" + data.strength;
					InitData(data.level, data.strength, data.play_time, data.already_play_time, data.point, 0, 0, 0, 0, 0, 0, new List<float>(), 0, 0, 0, 0, 0, 0, 0, 0, text, text, text);
				}
				else
				{
					GameRecordData gameRecordData = J_LitJson.JsonMapper.ToObject<GameRecordData>(data.game_data);
					InitData(data.level, data.strength, data.play_time, data.already_play_time, data.point, gameRecordData.AllPass, gameRecordData.PerfectNum, gameRecordData.ContinuateMaxNum, gameRecordData.TimeOutNum, gameRecordData.TotalSubject, gameRecordData.AnswerSubject, gameRecordData.AnswersFrequency, gameRecordData.ContaintWordNum, gameRecordData.ContainWordTotal, gameRecordData.FirstWordNum, gameRecordData.FirstWordTotal, gameRecordData.LastWordNum, gameRecordData.LastWordTotal, gameRecordData.IdiomWordNum, gameRecordData.IdiomWordTotal, gameRecordData.InitLevel, gameRecordData.MaxLevel, gameRecordData.MinLevel);
				}
			}
			else
			{
				string text2 = LoadManager.LevelID + "-" + LoadManager.StrengthID;
				InitData(LoadManager.LevelID, LoadManager.StrengthID, LoadManager.Duration, 0, 0, 0, 0, 0, 0, 0, 0, new List<float>(), 0, 0, 0, 0, 0, 0, 0, 0, text2, text2, text2);
			}
			IsStartGame = true;
			UIController.Instance.StartGame();
			PlayerController.Instance.IsShowVivePointers(isShow: false);
			StartTheCheckpoint();
		}

		private static void InitData(int level, int strength, int duration, int durationed, int score, int allpass, int perfect, int continuate, int timeout, int totalSub, int answerSub, List<float> answersFre, int containNum, int containTotal, int firstNum, int firstTotal, int lastNum, int lastTotal, int idiomNum, int idiomTotal, string start, string max, string min)
		{
			curLevelID = level;
			curStrengthID = strength;
			gameDuration = duration;
			gameDurationed = durationed;
			curScore = score;
			allPass = allpass;
			perfectNum = perfect;
			continuateMaxNum = continuate;
			timeOutNum = timeout;
			totalSubject = totalSub;
			answerSubject = answerSub;
			answersFrequency = answersFre;
			containWordNum = containNum;
			containWordTotal = containTotal;
			firstWordNum = firstNum;
			firstWordTotal = firstTotal;
			lastWordNum = lastNum;
			lastWordTotal = lastTotal;
			idiomWordNum = idiomNum;
			idiomWordTotal = idiomTotal;
			startLevel = start;
			maxLevel = max;
			minLevel = min;
		}

		public static void StartTheCheckpoint()
		{
			curErrorNum = 0;
			curMemoryNums.Clear();
			curSubjectRight.Clear();
			WordsBirthController.Instance.StartCreateWords();
		}

		public static void OverTheGame()
		{
			IsPlayGame = false;
			IsStartGame = false;
			PlayerController.Instance.StopAllCoroutines();
			WordsBirthController.Instance.ClearWords();
			UIController.Instance.OverTheGame();
		}

		public static void ResetTheGame()
		{
			IsPlayGame = false;
			IsStartGame = false;
			PlayerController.Instance.StopAllCoroutines();
			WordsBirthController.Instance.ClearWords();
		}

		public static string GetInitChallengeLevel()
		{
			string[] array = startLevel.Split('-');
			return LevelDataDic[int.Parse(array[0])].LevelName + "-" + StrengthDataDic[int.Parse(array[1])].StrengthGrade;
		}

		public static string GetMaxChallengeLevel()
		{
			string[] array = maxLevel.Split('-');
			return LevelDataDic[int.Parse(array[0])].LevelName + "-" + StrengthDataDic[int.Parse(array[1])].StrengthGrade;
		}

		public static string GetMinChallengeLevel()
		{
			string[] array = minLevel.Split('-');
			return LevelDataDic[int.Parse(array[0])].LevelName + "-" + StrengthDataDic[int.Parse(array[1])].StrengthGrade;
		}

		public static void AddStrength(int upshift)
		{
			curStrengthID += upshift;
			if (curStrengthID > 9)
			{
				if (LoadManager.IsLocalOperate && curLevelID >= LoadManager.MaxLevelID)
				{
					curStrengthID = 9;
				}
				else if (curLevelID >= LevelDataDic.Count - 1)
				{
					curStrengthID = 9;
				}
				else
				{
					curStrengthID -= 10;
					curLevelID++;
				}
			}
			SetMaxLevel();
			UIController.Instance.LevelTxt.text = GetCurLevel;
			LoadManager.SubmitLevelRecord(curLevelID, curStrengthID, UIController.Instance.GetUseDuration(), curScore, J_LitJson.JsonMapper.ToJson(GetGameRecord()));
		}

		public static void ReduceStrength(int downshift)
		{
			curStrengthID -= downshift;
			if (curStrengthID < 0)
			{
				if (curLevelID <= 0)
				{
					curStrengthID = 0;
				}
				else
				{
					curStrengthID += 10;
					curLevelID--;
				}
			}
			SetMinLevel();
			UIController.Instance.LevelTxt.text = GetCurLevel;
			LoadManager.SubmitLevelRecord(curLevelID, curStrengthID, UIController.Instance.GetUseDuration(), curScore, J_LitJson.JsonMapper.ToJson(GetGameRecord()));
		}

		private static void SetMaxLevel()
		{
			string[] array = maxLevel.Split('-');
			int num = int.Parse(array[0]);
			int num2 = int.Parse(array[1]);
			if (curLevelID == num)
			{
				if (curStrengthID > num2)
				{
					maxLevel = curLevelID + "-" + curStrengthID;
				}
			}
			else if (curLevelID > num)
			{
				maxLevel = curLevelID + "-" + curStrengthID;
			}
		}

		private static void SetMinLevel()
		{
			string[] array = minLevel.Split('-');
			int num = int.Parse(array[0]);
			int num2 = int.Parse(array[1]);
			if (curLevelID == num)
			{
				if (curStrengthID < num2)
				{
					minLevel = curLevelID + "-" + curStrengthID;
				}
			}
			else if (curLevelID < num)
			{
				minLevel = curLevelID + "-" + curStrengthID;
			}
		}

		public static void AddScore(int score)
		{
			curScore += score;
			UIController.Instance.CurScoreTxt.text = curScore.ToString();
		}

		public static void SetChanglleNum(int missMun)
		{
			int num = CurLevel.ChallengeNum - missMun;
			UIController.Instance.ChanglleNumTxt.text = ((num == 0) ? 1 : num).ToString();
		}

		public static void SetChanglleTime(float catchTimer)
		{
			UIController.Instance.ChanglleTimeTxt.text = Mathf.Ceil(catchTimer).ToString();
		}

		public static GameRecordData GetGameRecord()
		{
			return new GameRecordData
			{
				InitLevel = minLevel,
				MaxLevel = maxLevel,
				MinLevel = minLevel,
				AllPass = allPass,
				PerfectNum = perfectNum,
				ContinuateMaxNum = continuateMaxNum,
				TimeOutNum = timeOutNum,
				TotalSubject = totalSubject,
				AnswerSubject = answerSubject,
				AnswersFrequency = answersFrequency,
				ContaintWordNum = containWordNum,
				ContainWordTotal = containWordTotal,
				FirstWordNum = firstWordNum,
				FirstWordTotal = firstWordTotal,
				LastWordNum = lastWordNum,
				LastWordTotal = lastWordTotal,
				IdiomWordNum = idiomWordNum,
				IdiomWordTotal = idiomWordTotal
			};
		}
	}
	public class GameRecordData
	{
		public string InitLevel;

		public string MaxLevel;

		public string MinLevel;

		public int AllPass;

		public int PerfectNum;

		public int ContinuateMaxNum;

		public int TimeOutNum;

		public int TotalSubject;

		public int AnswerSubject;

		public List<float> AnswersFrequency;

		public int ContaintWordNum;

		public int ContainWordTotal;

		public int FirstWordNum;

		public int FirstWordTotal;

		public int LastWordNum;

		public int LastWordTotal;

		public int IdiomWordNum;

		public int IdiomWordTotal;
	}
	public class PlayerController : MonoBehaviour
	{
		public static PlayerController Instance;

		public Pvr_ControllerModuleInit pvr_ControllerModuleInit;

		public GameObject light;

		public GameObject head;

		public BatteryTipController batteryTipController;

		private bool lastVivePointersIsShow;

		private void Awake()
		{
			Instance = this;
		}

		private void Start()
		{
			Time.fixedDeltaTime = 0.02f;
		}

		private void Update()
		{
		}

		public void InitData()
		{
			List<WordFormationLevel> list = CsvMapper.ToObjectList<WordFormationLevel>(LoadManager.CsvRead("WordFormationLevel"));
			CheckpointManager.LevelDataDic.Clear();
			foreach (WordFormationLevel item in list)
			{
				CheckpointManager.LevelDataDic.Add(item.LevelID, item);
			}
			List<WordFormationStrength> list2 = CsvMapper.ToObjectList<WordFormationStrength>(LoadManager.CsvRead("WordFormationStrength"));
			CheckpointManager.StrengthDataDic.Clear();
			foreach (WordFormationStrength item2 in list2)
			{
				CheckpointManager.StrengthDataDic.Add(item2.StrengthID, item2);
			}
			CheckpointManager.WordTableDatas = CsvMapper.ToObjectList<WordLibrial>(LoadManager.CsvRead("WordTable"));
			CheckpointManager.FirstWordTableDatas = CheckpointManager.WordTableDatas.FindAll((WordLibrial x) => x.Position == 0 || x.Position == 1);
			CheckpointManager.EndWordTableDatas = CheckpointManager.WordTableDatas.FindAll((WordLibrial x) => x.Position == 0 || x.Position == 2);
			CheckpointManager.IdiomTableDatas = CsvMapper.ToObjectList<WordLibrial>(LoadManager.CsvRead("IdiomTable"));
			foreach (IdiomWord item3 in CsvMapper.ToObjectList<IdiomWord>(LoadManager.CsvRead("IdiomLibrary")))
			{
				CheckpointManager.IdiomLibraryDatas.Add(item3.Idiom);
			}
			ShowLight(isShow: false);
		}

		public void ShowLight(bool isShow = true)
		{
			light.SetActive(isShow);
		}

		public void IsShowVivePointers(bool isShow)
		{
			lastVivePointersIsShow = pvr_ControllerModuleInit.GetModuleState();
			pvr_ControllerModuleInit.ForceHideOrShow(isShow);
		}

		public void ResetShowVivePointers()
		{
			pvr_ControllerModuleInit.ForceHideOrShow(lastVivePointersIsShow);
		}

		public void DelayHander(float time, Action action)
		{
			StartCoroutine(Wait(time, action));
		}

		private IEnumerator Wait(float time, Action action)
		{
			yield return new WaitForSeconds(time);
			action?.Invoke();
		}
	}
	public class UIController : MonoBehaviour
	{
		public static UIController Instance;

		public GameObject StaticCanvas;

		[Header("开始界面")]
		public GameObject StartGamePanel;

		public ToggleGroup toggleGroup;

		public Button startGameBtn;

		public Button exitBtn;

		public AudioSource bgAudioSource;

		[Header("游戏界面")]
		public GameObject ScorePanel;

		public Text CurScoreTxt;

		public Text LevelTxt;

		public Text TotalTimeTxt;

		public Text ChanglleNumTxt;

		public Text ChanglleTimeTxt;

		[Header("结算界面")]
		public GameObject PassAllCheckpointPanel;

		public TextMeshProUGUI ScoreTxt;

		public Text TrainingDurationTxt;

		public Text InitChallengeLevelTxt;

		public Text MaxChallengeLevelTxt;

		public Text MinChallengeLevelTxt;

		public Text AllPassTxt;

		public Text PerfectNumTxt;

		public Text ContinuateMaxNumTxt;

		public Text TimeOutNumTxt;

		public Text TotalSubjectTxt;

		public Text AnswerSubjectTxt;

		public Text AnswerFrequencyTxt;

		public Text ContainWordAccuracyTxt;

		public Text FirstWordAccuracyTxt;

		public Text LastWordAccuracyTxt;

		public Text IdiomWordAccuracyTxt;

		public Button passAllReturnBtn;

		[Header("暂停界面")]
		public GameObject SuspendPanel;

		public Button suspendReturnStartBtn;

		public Button suspendReturnBtn;

		[Header("退出提示界面")]
		public GameObject ExitTipPanel;

		public Button defineBtn;

		public Button cancelBtn;

		public AudioSource audioSource;

		public AudioClip[] audioClips;

		public bool isStartTime;

		private float surplusGameDuration;

		private int curErrorTimes;

		private float checkTime;

		private void Awake()
		{
			Instance = this;
		}

		private void Start()
		{
			ScorePanel.SetActive(value: false);
			PassAllCheckpointPanel.SetActive(value: false);
			startGameBtn.onClick.AddListener(StartGameBtnHander);
			exitBtn.onClick.AddListener(ExitBtnHander);
			passAllReturnBtn.onClick.AddListener(PassAllBtnHander);
			suspendReturnStartBtn.onClick.AddListener(SuspendReturnStartBtnHander);
			suspendReturnBtn.onClick.AddListener(SuspendReturnBtnHander);
			defineBtn.onClick.AddListener(DefineBtnHander);
			cancelBtn.onClick.AddListener(CancelBtnHander);
			for (int i = 0; i < toggleGroup.transform.childCount; i++)
			{
				int index = i;
				Toggle component = toggleGroup.transform.GetChild(i).GetComponent<Toggle>();
				component.onValueChanged.AddListener(delegate(bool value)
				{
					if (value)
					{
						LoadManager.LevelID = index;
					}
				});
				if (LoadManager.LevelID == index)
				{
					component.isOn = true;
				}
			}
			PlayerController.Instance.InitData();
			if (LoadManager.IsLocalOperate)
			{
				StartGamePanel.SetActive(value: true);
				return;
			}
			StartGamePanel.SetActive(value: false);
			StartGameBtnHander(LoadManager.course);
		}

		private void Update()
		{
			if (CheckpointManager.IsStartGame)
			{
				surplusGameDuration -= Time.deltaTime;
				TotalTimeTxt.text = LoadManager.TimeConversion((int)surplusGameDuration);
				if (surplusGameDuration <= 0f)
				{
					CheckpointManager.OverTheGame();
				}
			}
			if (IsCanSuspend() && Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.APP))
			{
				PlayerController.Instance.IsShowVivePointers(isShow: true);
				IsStartTime(isStart: false);
				StaticCanvas.SetActive(value: true);
				SuspendPanel.SetActive(value: true);
				Time.timeScale = 0f;
			}
		}

		public void StartGame()
		{
			StaticCanvas.SetActive(value: false);
			ScorePanel.SetActive(value: true);
			curErrorTimes = 0;
			surplusGameDuration = CheckpointManager.gameDuration - CheckpointManager.gameDurationed;
			CurScoreTxt.text = CheckpointManager.curScore.ToString();
			LevelTxt.text = CheckpointManager.GetCurLevel;
			TotalTimeTxt.text = LoadManager.TimeConversion((int)surplusGameDuration);
			ChanglleTimeTxt.text = CheckpointManager.CurLevel.LimitTime.ToString();
		}

		public void IsStartTime(bool isStart = true)
		{
			isStartTime = isStart;
		}

		public void ErrorAnswer()
		{
			curErrorTimes++;
		}

		public int GetUseDuration(bool isComplete = false)
		{
			float num = CheckpointManager.gameDuration - surplusGameDuration;
			num = (isComplete ? CheckpointManager.gameDuration : num);
			return (int)num;
		}

		public void OverTheGame()
		{
			IsStartTime(isStart: false);
			PlayAudioSound(4);
			PlayerController.Instance.IsShowVivePointers(isShow: true);
			StaticCanvas.SetActive(value: true);
			ScorePanel.SetActive(value: false);
			PassAllCheckpointPanel.SetActive(value: true);
			ScoreTxt.text = CheckpointManager.curScore.ToString();
			TrainingDurationTxt.text = LoadManager.TimeConversion((int)CheckpointManager.gameDuration);
			InitChallengeLevelTxt.text = CheckpointManager.GetInitChallengeLevel();
			MaxChallengeLevelTxt.text = CheckpointManager.GetMaxChallengeLevel();
			MinChallengeLevelTxt.text = CheckpointManager.GetMinChallengeLevel();
			AllPassTxt.text = CheckpointManager.allPass.ToString();
			PerfectNumTxt.text = CheckpointManager.perfectNum.ToString();
			ContinuateMaxNumTxt.text = CheckpointManager.continuateMaxNum.ToString();
			TimeOutNumTxt.text = CheckpointManager.timeOutNum.ToString();
			TotalSubjectTxt.text = CheckpointManager.totalSubject.ToString();
			AnswerSubjectTxt.text = CheckpointManager.answerSubject.ToString();
			AnswerFrequencyTxt.text = GetAnswerFrequency(CheckpointManager.answersFrequency);
			ContainWordAccuracyTxt.text = ((CheckpointManager.containWordTotal == 0) ? "0%" : (Math.Round((float)CheckpointManager.containWordNum / (float)CheckpointManager.containWordTotal, 4) * 100.0 + "%"));
			FirstWordAccuracyTxt.text = ((CheckpointManager.firstWordTotal == 0) ? "0%" : (Math.Round((float)CheckpointManager.firstWordNum / (float)CheckpointManager.firstWordTotal, 4) * 100.0 + "%"));
			LastWordAccuracyTxt.text = ((CheckpointManager.lastWordTotal == 0) ? "0%" : (Math.Round((float)CheckpointManager.lastWordNum / (float)CheckpointManager.lastWordTotal, 4) * 100.0 + "%"));
			IdiomWordAccuracyTxt.text = ((CheckpointManager.idiomWordTotal == 0) ? "0%" : (Math.Round((float)CheckpointManager.idiomWordNum / (float)CheckpointManager.idiomWordTotal, 4) * 100.0 + "%"));
		}

		public void PlayAudioSound(int index)
		{
			if (audioSource.isPlaying)
			{
				audioSource.Stop();
			}
			audioSource.clip = audioClips[index];
			audioSource.Play();
		}

		public float GetCurRemainingTime()
		{
			return surplusGameDuration;
		}

		public void CheckBattery(Action continueAction)
		{
			if (PlayerController.Instance.batteryTipController.CheckBattery(continueAction))
			{
				SuspendGame(suspend: true);
			}
		}

		public void SuspendGame(bool suspend)
		{
			PlayerController.Instance.IsShowVivePointers(suspend);
			IsStartTime(!suspend);
			StaticCanvas.SetActive(suspend);
			Time.timeScale = ((!suspend) ? 1 : 0);
		}

		private void StartGameBtnHander()
		{
			StartGameBtnHander(null);
		}

		private void StartGameBtnHander(CourseDetail.Data data)
		{
			StartGamePanel.SetActive(value: false);
			bgAudioSource.Play();
			CheckpointManager.StartTheLevel(data);
		}

		private void ExitBtnHander()
		{
			ScenesHelper.LoadScene(ScenesHelper.WeiAiZhiCenterScene);
		}

		private void PassAllBtnHander()
		{
			if (LoadManager.IsLocalOperate)
			{
				StartGamePanel.SetActive(value: true);
				PassAllCheckpointPanel.SetActive(value: false);
			}
			else
			{
				LoadManager.SubmitEndRecord(isComplete: true, isLogout: false, GetUseDuration(isComplete: true), CheckpointManager.curScore, J_LitJson.JsonMapper.ToJson(CheckpointManager.GetGameRecord()));
			}
		}

		private void SuspendReturnStartBtnHander()
		{
			if (LoadManager.IsLocalOperate)
			{
				CheckpointManager.ResetTheGame();
				StaticCanvas.SetActive(value: true);
				StartGamePanel.SetActive(value: true);
				SuspendPanel.SetActive(value: false);
				ScorePanel.SetActive(value: false);
				Time.timeScale = 1f;
			}
			else
			{
				ExitTipPanel.SetActive(value: true);
			}
		}

		private void SuspendReturnBtnHander()
		{
			PlayerController.Instance.ResetShowVivePointers();
			StaticCanvas.SetActive(value: false);
			SuspendPanel.SetActive(value: false);
			Time.timeScale = 1f;
		}

		private void DefineBtnHander()
		{
			Time.timeScale = 1f;
			LoadManager.SubmitEndRecord(isComplete: false, isLogout: false, GetUseDuration(), CheckpointManager.curScore, J_LitJson.JsonMapper.ToJson(CheckpointManager.GetGameRecord()));
		}

		private void CancelBtnHander()
		{
			ExitTipPanel.SetActive(value: false);
		}

		private bool IsCanSuspend()
		{
			if (PassAllCheckpointPanel.activeSelf)
			{
				return false;
			}
			if (CheckpointManager.IsStartGame)
			{
				return true;
			}
			return false;
		}

		private string GetAnswerFrequency(List<float> answersFrequency)
		{
			if (answersFrequency.Count == 0)
			{
				return "0";
			}
			float num = 0f;
			for (int i = 0; i < answersFrequency.Count; i++)
			{
				num += answersFrequency[i];
			}
			num /= (float)answersFrequency.Count;
			return Math.Round(num, 2).ToString();
		}
	}
	public class WordController : MonoBehaviour
	{
		public WordLibrial keyWord;

		public WordType wordType;

		public Text pinyinTxt;

		public Text keyWordTxt;

		private bool IsFly;

		private float _max_radius_length;

		private float _radius_length;

		private float _init_angle_speed;

		private float _angle_speed;

		private float temp_angle;

		private Vector3 _pos_new;

		private Vector3 _center_pos;

		private FlyStatus flyStatus;

		private float flyOutTime = 4f;

		private float flyInTime = 4f;

		private float startHeight;

		private float endHeight;

		public FlyStatus FlyStatus => flyStatus;

		private void Start()
		{
		}

		private void Update()
		{
			if (!IsFly)
			{
				return;
			}
			if (FlyStatus == FlyStatus.FlyOut)
			{
				temp_angle += 180f / flyOutTime * Time.deltaTime;
				_pos_new.x = _center_pos.x + Mathf.Cos(temp_angle * ((float)Math.PI / 180f)) * _radius_length;
				_pos_new.z = _center_pos.z + Mathf.Sin(temp_angle * ((float)Math.PI / 180f)) * _radius_length;
				_pos_new.y += startHeight / flyOutTime * Time.deltaTime;
				_radius_length += _max_radius_length / flyOutTime * Time.deltaTime;
				base.transform.localPosition = _pos_new;
				if (_radius_length >= _max_radius_length)
				{
					flyStatus = FlyStatus.Fly;
				}
			}
			else if (FlyStatus == FlyStatus.FlyIn)
			{
				temp_angle += 180f / flyInTime * Time.deltaTime;
				_pos_new.x = _center_pos.x + Mathf.Cos(temp_angle * ((float)Math.PI / 180f)) * _radius_length;
				_pos_new.z = _center_pos.z + Mathf.Sin(temp_angle * ((float)Math.PI / 180f)) * _radius_length;
				_pos_new.y += endHeight / flyInTime * Time.deltaTime;
				_radius_length -= _max_radius_length / flyInTime * Time.deltaTime;
				base.transform.localPosition = _pos_new;
				if (_radius_length <= 0f)
				{
					flyStatus = FlyStatus.Static;
					UnityEngine.Object.Destroy(base.gameObject);
				}
			}
			else if (FlyStatus == FlyStatus.Fly)
			{
				temp_angle += _angle_speed * Time.deltaTime;
				_pos_new.x = _center_pos.x + Mathf.Cos(temp_angle * ((float)Math.PI / 180f)) * _radius_length;
				_pos_new.y = base.transform.localPosition.y;
				_pos_new.z = _center_pos.z + Mathf.Sin(temp_angle * ((float)Math.PI / 180f)) * _radius_length;
				base.transform.localPosition = _pos_new;
			}
			base.transform.LookAt(base.transform.parent);
		}

		public void Init(float radius, float startRadius, float startAngle, float angle_speed, float outTime, float inTime, float startH, float endH)
		{
			IsFly = true;
			flyStatus = FlyStatus.FlyOut;
			_radius_length = startRadius;
			temp_angle = startAngle;
			_max_radius_length = radius;
			_angle_speed = (_init_angle_speed = angle_speed);
			flyOutTime = outTime;
			flyInTime = inTime;
			_center_pos = Vector3.zero;
			_pos_new.y = base.transform.localPosition.y - startH;
			startHeight = startH;
			endHeight = endH;
		}

		public void SetSpeedScale(float angle_speed_scale)
		{
			_angle_speed *= angle_speed_scale;
		}

		public void ResetSpeed()
		{
			_angle_speed = _init_angle_speed;
		}

		public void DestroyWord()
		{
			flyStatus = FlyStatus.FlyIn;
		}
	}
	public enum FlyStatus
	{
		Static,
		FlyOut,
		Fly,
		FlyIn
	}
	public enum WordType
	{
		Triangle,
		Square,
		Circular,
		Star
	}
	public class WordsBirthController : MonoBehaviour
	{
		public static WordsBirthController Instance;

		public AliyunVoice aliyunVoice;

		public List<GameObject> prefabs;

		public Text pinyinText;

		public Text recText;

		public GameObject m_objShengBo;

		public Image batteryImg;

		public GameObject batterying;

		public GameObject subjecting;

		private RectTransform tempContainer_Bo;

		private List<WordController> waitCreateWords = new List<WordController>();

		private List<WordController> allWords = new List<WordController>();

		private float challengeTimer;

		private int curMissNum;

		private int continuateNum;

		private bool isCooling;

		private string lastKeyword;

		private string lastIdiom;

		private float lightTime;

		private float coolingTime;

		private bool isFlyOutting = true;

		private int curAnswerSubject;

		private float cur_speed_scale;

		private bool isIdentifying;

		private float recognition_Time = 5f;

		private float recognitionTimer;

		private float radius = 2.5f;

		private float startRadius = -0.5f;

		private float angle_speed = 30f;

		private float answer_speed_scale = 0.1f;

		private float blind_area_scale = 2f;

		private float flyOutTime = 3f;

		private float flyInTime = 3f;

		private float startHeight = 1f;

		private float endHeight = 1f;

		public bool IsPerfectPass
		{
			get
			{
				if (curMissNum == 0)
				{
					return true;
				}
				return false;
			}
		}

		private void Awake()
		{
			Instance = this;
		}

		private void Start()
		{
			tempContainer_Bo = m_objShengBo.transform.Find("GameObject").GetComponent<RectTransform>();
			aliyunVoice.RecCallbackAction = OnRecCallback;
			aliyunVoice.VolumnCallbackAction = OnVolumnCallback;
			m_objShengBo.SetActive(value: false);
		}

		private void Update()
		{
			if (!CheckpointManager.IsStartGame)
			{
				return;
			}
			if (!isFlyOutting)
			{
				challengeTimer -= Time.deltaTime;
				CheckpointManager.SetChanglleTime(challengeTimer);
				if (challengeTimer <= 0f)
				{
					CheckpointManager.timeOutNum++;
					EndAnswer();
					DestroyWords();
					FielTheGroup();
				}
				if (!isCooling)
				{
					if (Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.TRIGGER) || Input.GetKeyDown(KeyCode.Space))
					{
						StartAnswer();
					}
					else if (Controller.UPvr_GetKeyUp(1, Pvr_KeyCode.TRIGGER) || Input.GetKeyUp(KeyCode.Space))
					{
						EndAnswer();
					}
					else if (Controller.UPvr_GetKey(1, Pvr_KeyCode.TRIGGER) || Input.GetKey(KeyCode.Space))
					{
						if (!m_objShengBo.activeSelf)
						{
							return;
						}
						lightTime -= Time.deltaTime;
						SetBattery(lightTime / CheckpointManager.GetLightTime);
						if (lightTime <= 0f)
						{
							EndAnswer();
						}
					}
				}
				else if (Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.TRIGGER) || Input.GetKeyDown(KeyCode.Space))
				{
					if (!batterying.activeSelf)
					{
						batterying.SetActive(value: true);
					}
				}
				else if ((Controller.UPvr_GetKeyUp(1, Pvr_KeyCode.TRIGGER) || Input.GetKeyUp(KeyCode.Space)) && batterying.activeSelf)
				{
					batterying.SetActive(value: false);
				}
				if (!Controller.UPvr_GetKey(1, Pvr_KeyCode.TRIGGER) && !Input.GetKey(KeyCode.Space))
				{
					Vector3 forward = PlayerController.Instance.head.transform.forward;
					bool flag = false;
					for (int i = 0; i < allWords.Count; i++)
					{
						if (Mathf.Acos(Vector3.Dot(forward, (allWords[i].transform.position - PlayerController.Instance.head.transform.position).normalized)) * 57.29578f < 30f)
						{
							flag = true;
							break;
						}
					}
					if (flag && cur_speed_scale != 1f)
					{
						ResetWordsSpeed();
					}
					else if (!flag && cur_speed_scale != blind_area_scale)
					{
						SetWordsSpeed(blind_area_scale);
					}
				}
			}
			else if (Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.TRIGGER) || Input.GetKeyDown(KeyCode.Space))
			{
				if (!subjecting.activeSelf)
				{
					subjecting.SetActive(value: true);
				}
			}
			else if ((Controller.UPvr_GetKeyUp(1, Pvr_KeyCode.TRIGGER) || Input.GetKeyUp(KeyCode.Space)) && subjecting.activeSelf)
			{
				subjecting.SetActive(value: false);
			}
			if (isCooling)
			{
				coolingTime -= Time.deltaTime;
				SetBattery((CheckpointManager.CurLevel.CoolingTime - coolingTime) / CheckpointManager.CurLevel.CoolingTime);
				if (coolingTime <= 0f)
				{
					lightTime = CheckpointManager.GetLightTime;
					isCooling = false;
					if (batterying.activeSelf)
					{
						batterying.SetActive(value: false);
					}
				}
			}
			else if (CheckpointManager.GetLightTime > lightTime && (isFlyOutting || (!Controller.UPvr_GetKey(1, Pvr_KeyCode.TRIGGER) && !Input.GetKey(KeyCode.Space))))
			{
				float num = lightTime / CheckpointManager.GetLightTime * CheckpointManager.CurLevel.CoolingTime * 2f;
				num += Time.deltaTime;
				lightTime = num / (CheckpointManager.CurLevel.CoolingTime * 2f) * CheckpointManager.GetLightTime;
				SetBattery(lightTime / CheckpointManager.GetLightTime);
			}
			if (isIdentifying)
			{
				recognitionTimer -= Time.deltaTime;
				if (recognitionTimer <= 0f)
				{
					isIdentifying = false;
					recText.gameObject.SetActive(value: false);
				}
			}
		}

		public void StartCreateWords()
		{
			lightTime = CheckpointManager.GetLightTime;
			CreateWordsToCheck(isCheck: false);
		}

		public void ClearWords()
		{
			EndAnswer();
			recText.gameObject.SetActive(value: false);
			waitCreateWords.Clear();
			DestroyWords();
		}

		public void CreateWordsToCheck(bool isCheck = true)
		{
			challengeTimer = CheckpointManager.CurLevel.LimitTime;
			CheckpointManager.SetChanglleTime(challengeTimer);
			if (isCheck)
			{
				UIController.Instance.CheckBattery(delegate
				{
					UIController.Instance.SuspendGame(suspend: false);
					CreateWords();
				});
			}
			else
			{
				CreateWords();
			}
		}

		private void CreateWords()
		{
			isFlyOutting = true;
			curMissNum = 0;
			curAnswerSubject = 0;
			CheckpointManager.SetChanglleNum(curMissNum);
			isCooling = false;
			for (int i = 0; i < CheckpointManager.GetWordNum; i++)
			{
				UnityEngine.Random.InitState(Guid.NewGuid().GetHashCode());
				int num = ((CheckpointManager.CurLevel.IsIdiom != 0) ? UnityEngine.Random.Range(0, 4) : UnityEngine.Random.Range(0, 3));
				WordController component = UnityEngine.Object.Instantiate(prefabs[num], base.transform).GetComponent<WordController>();
				component.wordType = (WordType)Enum.ToObject(typeof(WordType), num);
				waitCreateWords.Add(component);
			}
			CheckpointManager.totalSubject += CheckpointManager.GetWordNum;
			float num2 = 360f / (float)waitCreateWords.Count;
			for (int j = 0; j < waitCreateWords.Count; j++)
			{
				CreateWord(waitCreateWords[j], num2 * (float)j);
			}
			waitCreateWords.Clear();
			if (waitCreateWords.Count != 0)
			{
				return;
			}
			PlayerController.Instance.DelayHander(flyOutTime, delegate
			{
				isFlyOutting = false;
				if (subjecting.activeSelf)
				{
					subjecting.SetActive(value: false);
				}
			});
		}

		private void CreateWord(WordController word, float angle_int)
		{
			allWords.Add(word);
			switch (word.wordType)
			{
			case WordType.Triangle:
				CheckpointManager.containWordTotal++;
				word.keyWord = RandomRange(lastKeyword, CheckpointManager.curLevelID, CheckpointManager.WordTableDatas);
				break;
			case WordType.Square:
				CheckpointManager.firstWordTotal++;
				word.keyWord = RandomRange(lastKeyword, CheckpointManager.curLevelID, CheckpointManager.FirstWordTableDatas);
				break;
			case WordType.Circular:
				CheckpointManager.lastWordTotal++;
				word.keyWord = RandomRange(lastKeyword, CheckpointManager.curLevelID, CheckpointManager.EndWordTableDatas);
				break;
			case WordType.Star:
				CheckpointManager.idiomWordTotal++;
				word.keyWord = RandomRange(lastIdiom, CheckpointManager.curLevelID, CheckpointManager.IdiomTableDatas);
				break;
			}
			lastKeyword = word.keyWord.Keyword;
			word.pinyinTxt.text = Pinyin.GetPinyin(word.keyWord.Keyword);
			word.keyWordTxt.text = word.keyWord.Keyword;
			word.gameObject.SetActive(value: true);
			word.Init(radius, startRadius, angle_int, angle_speed, flyOutTime, flyInTime, startHeight, endHeight);
		}

		private void StartAnswer()
		{
			if (aliyunVoice.StartRec())
			{
				coolingTime = CheckpointManager.CurLevel.CoolingTime;
				PlayerController.Instance.ShowLight();
				SetWordsSpeed(answer_speed_scale);
				m_objShengBo.SetActive(value: true);
				recText.gameObject.SetActive(value: true);
				recText.text = string.Empty;
				pinyinText.text = string.Empty;
				isIdentifying = true;
				recognitionTimer = recognition_Time;
			}
		}

		private void EndAnswer()
		{
			if (m_objShengBo.activeSelf)
			{
				aliyunVoice.StopRec();
				PlayerController.Instance.ShowLight(isShow: false);
				ResetWordsSpeed();
				m_objShengBo.SetActive(value: false);
				if (lightTime <= 0f)
				{
					isCooling = true;
				}
			}
		}

		private void OnRecCallback(string msg)
		{
			if (!CheckpointManager.IsStartGame || isFlyOutting)
			{
				return;
			}
			VoiceResult voiceResult = LitJson.JsonMapper.ToObject<VoiceResult>(msg);
			if (voiceResult.payload.result.Length < 2)
			{
				return;
			}
			List<WordController> list = new List<WordController>();
			Vector3 forward = PlayerController.Instance.light.transform.forward;
			for (int i = 0; i < allWords.Count; i++)
			{
				if (allWords[i].FlyStatus == FlyStatus.Fly && Mathf.Acos(Vector3.Dot(forward, (allWords[i].transform.position - PlayerController.Instance.light.transform.position).normalized)) * 57.29578f < 15f)
				{
					list.Add(allWords[i]);
				}
			}
			bool right = false;
			for (int j = 0; j < list.Count; j++)
			{
				if (list[j].wordType == WordType.Triangle && voiceResult.payload.result.Contains(list[j].keyWord.Keyword))
				{
					right = true;
					AnswerRight(list[j], voiceResult.payload.result);
					break;
				}
				if (list[j].wordType == WordType.Square && voiceResult.payload.result[0].Equals(list[j].keyWord.Keyword[0]))
				{
					right = true;
					AnswerRight(list[j], voiceResult.payload.result);
					break;
				}
				if (list[j].wordType == WordType.Circular && voiceResult.payload.result[voiceResult.payload.result.Length - 1].Equals(list[j].keyWord.Keyword[0]))
				{
					right = true;
					AnswerRight(list[j], voiceResult.payload.result);
					break;
				}
				if (list[j].wordType == WordType.Star && CheckpointManager.IdiomLibraryDatas.Contains(voiceResult.payload.result))
				{
					right = true;
					AnswerRight(list[j], voiceResult.payload.result);
					break;
				}
			}
			curAnswerSubject++;
			CheckpointManager.answerSubject++;
			StartCoroutine(DealResult(right));
		}

		private void AnswerRight(WordController word, string result)
		{
			pinyinText.text = Pinyin.GetPinyin(result);
			recText.text = result;
			allWords.Remove(word);
			GameObject blast = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("Prefabs/Blast"));
			blast.transform.position = word.transform.position;
			GameObject light = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("Prefabs/Lightning"));
			light.transform.position = word.transform.position;
			light.transform.forward = (PlayerController.Instance.light.transform.position - word.transform.position).normalized;
			switch (word.wordType)
			{
			case WordType.Triangle:
				CheckpointManager.containWordNum++;
				break;
			case WordType.Square:
				CheckpointManager.firstWordNum++;
				break;
			case WordType.Circular:
				CheckpointManager.lastWordNum++;
				break;
			case WordType.Star:
				CheckpointManager.idiomWordNum++;
				break;
			}
			UnityEngine.Object.Destroy(word.gameObject);
			PlayerController.Instance.DelayHander(1f, delegate
			{
				UnityEngine.Object.Destroy(blast);
				UnityEngine.Object.Destroy(light);
			});
		}

		public void OnVolumnCallback(float val)
		{
			for (int num = tempContainer_Bo.childCount - 1; num > 0; num--)
			{
				tempContainer_Bo.GetChild(num).localScale = tempContainer_Bo.GetChild(num - 1).localScale;
			}
			tempContainer_Bo.GetChild(0).localScale = new Vector3(1f, (val + 80f) / 80f, 1f);
		}

		private IEnumerator DealResult(bool right)
		{
			yield return null;
			if (right)
			{
				Controller.UPvr_VibrateNeo2Controller(0.5f, 50, Pvr_ControllerManager.controllerlink.mainHandID);
				UIController.Instance.PlayAudioSound(0);
				if (allWords.Count == 0)
				{
					isFlyOutting = true;
					EndAnswer();
					CheckpointManager.answersFrequency.Add((float)curAnswerSubject / (CheckpointManager.CurLevel.LimitTime - challengeTimer));
					PassTheGroup();
				}
				yield break;
			}
			UIController.Instance.PlayAudioSound(1);
			continuateNum = 0;
			curMissNum++;
			CheckpointManager.SetChanglleNum(curMissNum);
			if (curMissNum >= CheckpointManager.CurLevel.ChallengeNum)
			{
				isFlyOutting = true;
				EndAnswer();
				DestroyWords();
				CheckpointManager.answersFrequency.Add((float)curAnswerSubject / CheckpointManager.CurLevel.LimitTime);
				FielTheGroup();
			}
		}

		private void PassTheGroup()
		{
			CheckpointManager.allPass++;
			int num = ((!IsPerfectPass) ? 1 : 2);
			if (IsPerfectPass)
			{
				CheckpointManager.perfectNum++;
				continuateNum++;
				if (continuateNum > CheckpointManager.continuateMaxNum)
				{
					CheckpointManager.continuateMaxNum = continuateNum;
				}
			}
			else
			{
				continuateNum = 0;
			}
			CheckpointManager.AddScore(CheckpointManager.GetScore * num);
			UIController.Instance.PlayAudioSound((num == 1) ? 2 : 3);
			CheckpointManager.AddStrength(CheckpointManager.CurLevel.UpshiftGrade * num);
			CreateWordsToCheck();
		}

		private void FielTheGroup()
		{
			CheckpointManager.SetChanglleTime(0f);
			CheckpointManager.ReduceStrength(CheckpointManager.CurLevel.DownshiftGrade);
			CreateWordsToCheck();
		}

		private void SetBattery(float value)
		{
			batteryImg.fillAmount = value;
		}

		private void SetWordsSpeed(float speed_scale)
		{
			cur_speed_scale = speed_scale;
			for (int i = 0; i < allWords.Count; i++)
			{
				allWords[i].SetSpeedScale(speed_scale);
			}
		}

		private void ResetWordsSpeed()
		{
			cur_speed_scale = 1f;
			for (int i = 0; i < allWords.Count; i++)
			{
				allWords[i].ResetSpeed();
			}
		}

		private void DestroyWords()
		{
			for (int i = 0; i < allWords.Count; i++)
			{
				allWords[i].DestroyWord();
			}
			allWords.Clear();
		}

		private WordLibrial RandomRange(string key, int limit, List<WordLibrial> librials)
		{
			List<WordLibrial> librials2 = librials.FindAll((WordLibrial c) => c.LevelLimit <= limit);
			return RandomRange(key, librials2);
		}

		private WordLibrial RandomRange(string key, List<WordLibrial> librials)
		{
			UnityEngine.Random.InitState(Guid.NewGuid().GetHashCode());
			int index = UnityEngine.Random.Range(0, librials.Count);
			if (librials[index].Keyword == key)
			{
				return RandomRange(key, librials);
			}
			return librials[index];
		}
	}
	public class VoiceResult
	{
		public Payload payload;
	}
	public class Payload
	{
		public string result;
	}
}
namespace VLights
{
	public static class VLightShaderUtil
	{
		public const string POST_SHADER_NAME = "Hidden/V-Light/Post";

		public const string DEPTH_SHADER_NAME = "V-Light/Volumetric Light Depth";

		public const string INTERLEAVED_SHADER_NAME = "V-Light/Volumetric Light Depth";

		public const string DOWNSCALEDEPTH_SHADER_NAME = "Hidden/V-Light/Downscale Depth";
	}
}
namespace com.brian.vlights
{
	public class ShaderLibrary : ScriptableObject
	{
		[SerializeField]
		private Shader[] _shaders;
	}
}
namespace PickUpBall
{
	public class BallBirthController : MonoBehaviour
	{
		public static BallBirthController Instance;

		public List<Texture> halfColorTexture = new List<Texture>();

		public List<Texture> numTexture = new List<Texture>();

		public List<Color> bombColor = new List<Color>();

		public List<string> bombColorName = new List<string>();

		private Transform curMapTra;

		private int lastRandom = 1000;

		private string curMapID;

		private Transform curStartPoint;

		private int curBombColor;

		private Image curBombImage;

		private TextMeshProUGUI countDownTxt;

		private bool isStartCount;

		private float countDownTime = 3f;

		private Text intervalTxt;

		private Text ballNumTxt;

		private Text bombTxt;

		private Text colorTxt;

		private List<BallController> allBallItems = new List<BallController>();

		private List<BallController> waitBallItems = new List<BallController>();

		private float createInterval;

		private int curPickBallNum;

		private int curMissNum;

		private int continuateNum;

		public bool IsPerfectPass
		{
			get
			{
				if (curMissNum == 0)
				{
					return true;
				}
				return false;
			}
		}

		private void Awake()
		{
			Instance = this;
		}

		private void Start()
		{
		}

		private void Update()
		{
			if (!CheckpointManager.IsStartGame)
			{
				return;
			}
			if (isStartCount)
			{
				countDownTime -= Time.deltaTime;
				countDownTxt.text = Mathf.Ceil(countDownTime).ToString();
				if (countDownTime <= 0f)
				{
					isStartCount = false;
					countDownTxt.gameObject.SetActive(value: false);
				}
			}
			else
			{
				createInterval -= Time.deltaTime;
				if (createInterval <= 0f && waitBallItems.Count > 0)
				{
					createInterval = CheckpointManager.GetIntervalTime;
					int index = UnityEngine.Random.Range(0, waitBallItems.Count);
					CreateBall(waitBallItems[index]);
				}
			}
		}

		public void IsShowMap(bool isShow)
		{
			if ((bool)curMapTra)
			{
				curMapTra.gameObject.SetActive(isShow);
			}
		}

		public void CreateMapToCheck(bool isCheck = true)
		{
			if (isCheck)
			{
				UIController.Instance.CheckBattery(delegate
				{
					UIController.Instance.SuspendGame(suspend: false);
					CreateMap();
				});
			}
			else
			{
				CreateMap();
			}
		}

		public void CreateMap()
		{
			createInterval = 0f;
			countDownTime = 3f;
			lastRandom = MyMath.RandomRange(0, CheckpointManager.CurPickUpBallLevel.Range.Count, lastRandom);
			curMapID = CheckpointManager.CurPickUpBallLevel.Range[lastRandom];
			NetPocketController.Instance.isNetPocket = false;
			CreateMap(curMapID);
		}

		public void DestroyBall(GameObject ball, bool isPickUp)
		{
			BallController component = ball.GetComponent<BallController>();
			if (isPickUp)
			{
				if (CheckpointManager.CurPickUpBallLevel.IsAddBomb == 1 && curBombColor == component.color)
				{
					NetPocketController.Instance.PlayParticle(isRight: false);
					UIController.Instance.PlayAudioSound(1);
					curMissNum++;
					CheckpointManager.SetChanglleNum(curMissNum);
					CheckpointManager.pickBombNum++;
					if (curMissNum >= CheckpointManager.CurPickUpBallLevel.ChallengeNum)
					{
						CheckpointManager.ReduceStrength(CheckpointManager.CurPickUpBallLevel.DownshiftGrade);
						ClearMap();
						CreateMapToCheck();
						return;
					}
				}
				else
				{
					Controller.UPvr_VibrateNeo2Controller(0.5f, 50, Pvr_ControllerManager.controllerlink.mainHandID);
					NetPocketController.Instance.PlayParticle();
					UIController.Instance.PlayAudioSound(0);
					CheckpointManager.pickBallNum++;
					curPickBallNum++;
					ballNumTxt.text = curPickBallNum + "/" + CheckpointManager.GetBallNum;
				}
			}
			else if (CheckpointManager.CurPickUpBallLevel.IsAddBomb == 1 && curBombColor == component.color)
			{
				UIController.Instance.PlayAudioSound(0);
			}
			else
			{
				UIController.Instance.PlayAudioSound(1);
				curMissNum++;
				CheckpointManager.SetChanglleNum(curMissNum);
				if (curMissNum >= CheckpointManager.CurPickUpBallLevel.ChallengeNum)
				{
					CheckpointManager.ReduceStrength(CheckpointManager.CurPickUpBallLevel.DownshiftGrade);
					ClearMap();
					CreateMapToCheck();
					return;
				}
			}
			allBallItems.Remove(component);
			UnityEngine.Object.Destroy(ball);
			if (allBallItems.Count == 0 && waitBallItems.Count == 0)
			{
				PassTheMap();
				UnityEngine.Object.Destroy(curMapTra.gameObject);
				CreateMapToCheck();
			}
		}

		private void CreateMap(string mapID)
		{
			curMissNum = 0;
			curPickBallNum = 0;
			CheckpointManager.SetChanglleNum(curMissNum);
			GameObject gameObject = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("Prefabs/Maps/M" + mapID), base.transform);
			curMapTra = gameObject.transform;
			curMapTra.localPosition = Vector3.zero;
			curStartPoint = curMapTra.Find("StartPoint");
			curBombImage = curMapTra.Find("Canvas/BallColor").GetComponent<Image>();
			countDownTxt = curMapTra.Find("Canvas/CountDownTxt").GetComponent<TextMeshProUGUI>();
			intervalTxt = curMapTra.Find("Canvas/IntervalTxt").GetComponent<Text>();
			ballNumTxt = curMapTra.Find("Canvas/BallNumTxt").GetComponent<Text>();
			bombTxt = curMapTra.Find("Canvas/BombTxt").GetComponent<Text>();
			colorTxt = curMapTra.Find("Canvas/ColorTxt").GetComponent<Text>();
			isStartCount = true;
			countDownTxt.gameObject.SetActive(value: true);
			intervalTxt.text = CheckpointManager.GetIntervalTime + "秒";
			ballNumTxt.text = "0/" + CheckpointManager.GetBallNum;
			CreatBalls();
		}

		private void CreatBalls()
		{
			ShowBomb(-1);
			if (CheckpointManager.CurPickUpBallLevel.IsAddBomb == 1)
			{
				curBombColor = UnityEngine.Random.Range(0, halfColorTexture.Count);
				for (int i = 0; (float)i < CheckpointManager.GetBombNum; i++)
				{
					BallController ballController = new BallController();
					ballController.isHalf = UnityEngine.Random.Range(0, 2);
					ballController.color = curBombColor;
					ballController.number = UnityEngine.Random.Range(0, numTexture.Count);
					waitBallItems.Add(ballController);
				}
				ShowBomb(curBombColor);
			}
			for (int j = 0; (float)j < CheckpointManager.GetBallNum; j++)
			{
				BallController ballController2 = new BallController();
				ballController2.isHalf = UnityEngine.Random.Range(0, 2);
				if (CheckpointManager.CurPickUpBallLevel.IsAddBomb == 0)
				{
					ballController2.color = UnityEngine.Random.Range(0, halfColorTexture.Count);
					ballController2.number = UnityEngine.Random.Range(0, numTexture.Count);
				}
				else
				{
					ballController2.color = MyMath.RandomRange(0, halfColorTexture.Count, curBombColor);
					ballController2.number = UnityEngine.Random.Range(0, numTexture.Count);
				}
				waitBallItems.Add(ballController2);
			}
		}

		private void CreateBall(BallController item)
		{
			waitBallItems.Remove(item);
			GameObject obj = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("Prefabs/AllBall"), curMapTra);
			Material material = obj.GetComponent<Renderer>().material;
			material.SetTexture("_MainTex", halfColorTexture[item.color]);
			material.SetTexture("_DetailAlbedoMap", numTexture[item.number]);
			obj.transform.localPosition = curStartPoint.localPosition;
			obj.GetComponent<Rigidbody>().AddForce(-curStartPoint.right * UnityEngine.Random.Range(40, 81));
			BallController component = obj.GetComponent<BallController>();
			component.isHalf = item.isHalf;
			component.color = item.color;
			component.number = item.number;
			allBallItems.Add(component);
			if (CheckpointManager.CurPickUpBallLevel.IsAddBomb == 1 && curBombColor == item.color)
			{
				CheckpointManager.totalBombNum++;
			}
			else
			{
				CheckpointManager.totalBallNum++;
			}
		}

		private void PassTheMap()
		{
			CheckpointManager.allPass++;
			int num = ((!IsPerfectPass) ? 1 : 2);
			if (IsPerfectPass)
			{
				CheckpointManager.perfectNum++;
				continuateNum++;
				if (continuateNum > CheckpointManager.continuateMaxNum)
				{
					CheckpointManager.continuateMaxNum = continuateNum;
				}
			}
			else
			{
				continuateNum = 0;
			}
			int score = CheckpointManager.GetScore * num;
			UIController.Instance.PlayAudioSound((num == 1) ? 2 : 3);
			CheckpointManager.AddScore(score);
			CheckpointManager.AddStrength(CheckpointManager.CurPickUpBallLevel.UpshiftGrade * num);
		}

		private void ShowBomb(int bomb)
		{
			if (bomb == -1)
			{
				curBombImage.gameObject.SetActive(value: false);
				bombTxt.gameObject.SetActive(value: false);
				colorTxt.gameObject.SetActive(value: false);
			}
			else
			{
				curBombImage.gameObject.SetActive(value: true);
				bombTxt.gameObject.SetActive(value: true);
				colorTxt.gameObject.SetActive(value: true);
				curBombImage.color = bombColor[bomb];
				colorTxt.text = bombColorName[bomb];
			}
		}

		public void ClearMap()
		{
			waitBallItems.Clear();
			foreach (BallController allBallItem in allBallItems)
			{
				UnityEngine.Object.Destroy(allBallItem.gameObject);
			}
			allBallItems.Clear();
			UnityEngine.Object.Destroy(curMapTra.gameObject);
		}
	}
	public class BallController : MonoBehaviour
	{
		public int isHalf;

		public int color;

		public int number;

		private Vector3 newGravity = Physics.gravity;

		private Vector3 compensate = Vector3.zero;

		private Rigidbody rig;

		private BounceItem lastItem;

		private int theSameTime;

		private void Start()
		{
			rig = GetComponent<Rigidbody>();
		}

		private void Update()
		{
			_ = rig.velocity.y;
			_ = 0f;
		}

		public void SetGravity(Vector3 val)
		{
			rig.useGravity = true;
			if (!(newGravity == val))
			{
				newGravity = val;
				compensate = -(Physics.gravity - val);
			}
		}

		private void FixedUpdate()
		{
			if (!rig.isKinematic && !rig.IsSleeping())
			{
				_ = compensate != Vector3.zero;
			}
		}

		private void OnCollisionEnter(UnityEngine.Collision collision)
		{
			BounceItem component = collision.transform.GetComponent<BounceItem>();
			if ((bool)component)
			{
				if ((bool)component.Ani)
				{
					if (lastItem == component)
					{
						theSameTime++;
						if (theSameTime == 20)
						{
							rig.mass *= 10f;
						}
					}
					else
					{
						lastItem = component;
						theSameTime = 1;
					}
				}
				ContactPoint contactPoint = collision.contacts[0];
				rig.AddForce(contactPoint.normal * component.force);
			}
			else if (collision.collider.name.Equals("WorldFloor"))
			{
				BallBirthController.Instance.DestroyBall(base.gameObject, isPickUp: false);
			}
		}

		private void OnTriggerEnter(Collider other)
		{
			if (other.name.Equals("CheckPoint") && NetPocketController.Instance.isNetPocket)
			{
				BallBirthController.Instance.DestroyBall(base.gameObject, isPickUp: true);
			}
		}
	}
	public class BounceItem : MonoBehaviour
	{
		public float force = 500f;

		private Animator ani;

		private bool isPlay;

		private float timer = 0.1f;

		public Animator Ani => ani;

		private void Start()
		{
			ani = GetComponent<Animator>();
		}

		private void Update()
		{
			if (isPlay)
			{
				timer -= Time.deltaTime;
				if (timer <= 0f)
				{
					isPlay = false;
					timer = 0.1f;
				}
			}
		}

		private void OnCollisionEnter(UnityEngine.Collision collision)
		{
			if ((bool)collision.transform.GetComponent<BallController>() && (bool)ani)
			{
				isPlay = true;
				ani.SetTrigger("PlayAni");
			}
		}
	}
	public class PickUpBallLevel
	{
		public int LevelID;

		public string LevelName;

		public List<string> Range;

		public float InitialNum;

		public int BaseScore;

		public int ChallengeNum;

		public float LunchNum;

		public float LunchInterval;

		public int IsAddBall;

		public int IsAddBomb;

		public int ShortenInterval;

		public int UpshiftRequire;

		public int UpshiftGrade;

		public int DownshiftRequire;

		public int DownshiftGrade;
	}
	public class PickUpBallStrength
	{
		public int StrengthID;

		public int StrengthGrade;

		public float ScoreAddition;

		public int NumAddition;

		public int BombNumber;

		public float ShortenInterval;
	}
	public class CheckpointManager
	{
		public static Dictionary<int, PickUpBallLevel> LevelDataDic = new Dictionary<int, PickUpBallLevel>();

		public static Dictionary<int, PickUpBallStrength> StrengthDataDic = new Dictionary<int, PickUpBallStrength>();

		public static int curLevelID;

		public static int curStrengthID;

		public static float gameDuration;

		public static float gameDurationed;

		public static int curScore;

		public static string startLevel;

		public static string minLevel;

		public static string maxLevel;

		public static int allPass;

		public static int perfectNum;

		public static int continuateMaxNum;

		public static int totalBallNum;

		public static int pickBallNum;

		public static int totalBombNum;

		public static int pickBombNum;

		public static bool IsStartGame = false;

		public static PickUpBallLevel CurPickUpBallLevel => LevelDataDic[curLevelID];

		public static PickUpBallStrength CurPickUpBallStrength => StrengthDataDic[curStrengthID];

		public static int GetScore => (int)((float)CurPickUpBallLevel.BaseScore * (1f + CurPickUpBallStrength.ScoreAddition));

		public static float GetBallNum
		{
			get
			{
				if (CurPickUpBallLevel.IsAddBall != 0)
				{
					return CurPickUpBallLevel.InitialNum + (float)CurPickUpBallStrength.NumAddition;
				}
				return CurPickUpBallLevel.InitialNum;
			}
		}

		public static float GetBombNum => (CurPickUpBallLevel.IsAddBomb != 0) ? CurPickUpBallStrength.BombNumber : 0;

		public static float GetIntervalTime
		{
			get
			{
				if (CurPickUpBallLevel.ShortenInterval != 0)
				{
					return (float)Math.Round(CurPickUpBallLevel.LunchInterval * (1f - CurPickUpBallStrength.ShortenInterval), 2);
				}
				return CurPickUpBallLevel.LunchInterval;
			}
		}

		public static string GetCurLevel => LevelDataDic[curLevelID].LevelName + "-" + StrengthDataDic[curStrengthID].StrengthGrade;

		public static void StartTheLevel(CourseDetail.Data data)
		{
			if (data != null)
			{
				if (data.game_data == null)
				{
					string text = data.level + "-" + data.strength;
					InitData(data.level, data.strength, data.play_time, data.already_play_time, data.point, 0, 0, 0, 0, 0, 0, 0, text, text, text);
				}
				else
				{
					GameRecordData gameRecordData = J_LitJson.JsonMapper.ToObject<GameRecordData>(data.game_data);
					InitData(data.level, data.strength, data.play_time, data.already_play_time, data.point, gameRecordData.AllPass, gameRecordData.PerfectNum, gameRecordData.ContinuateMaxNum, gameRecordData.PickBallNum, gameRecordData.TotalBallNum, gameRecordData.PickBombNum, gameRecordData.TotalBombNum, gameRecordData.InitLevel, gameRecordData.MaxLevel, gameRecordData.MinLevel);
				}
			}
			else
			{
				string text2 = LoadManager.LevelID + "-" + LoadManager.StrengthID;
				InitData(LoadManager.LevelID, LoadManager.StrengthID, LoadManager.Duration, 0, 0, 0, 0, 0, 0, 0, 0, 0, text2, text2, text2);
			}
			IsStartGame = true;
			PlayerController.Instance.IsShowVivePointers(isShow: false);
			BallBirthController.Instance.CreateMapToCheck(isCheck: false);
			UIController.Instance.StartGame();
		}

		private static void InitData(int level, int strength, int duration, int durationed, int score, int allpass, int perfect, int continuate, int pickball, int totalball, int pickbomb, int totalbomb, string start, string max, string min)
		{
			curLevelID = level;
			curStrengthID = strength;
			gameDuration = duration;
			gameDurationed = durationed;
			curScore = score;
			allPass = allpass;
			perfectNum = perfect;
			continuateMaxNum = continuate;
			pickBallNum = pickball;
			totalBallNum = totalball;
			pickBombNum = pickbomb;
			totalBombNum = totalbomb;
			startLevel = start;
			maxLevel = max;
			minLevel = min;
		}

		public static void OverTheGame()
		{
			IsStartGame = false;
			PlayerController.Instance.StopAllCoroutines();
			BallBirthController.Instance.ClearMap();
			UIController.Instance.OverTheGame();
			PlayerController.Instance.IsShowVivePointers(isShow: true);
		}

		public static void ResetTheGame()
		{
			IsStartGame = false;
			PlayerController.Instance.StopAllCoroutines();
			BallBirthController.Instance.ClearMap();
			PlayerController.Instance.IsShowVivePointers(isShow: true);
		}

		public static string GetInitChallengeLevel()
		{
			string[] array = startLevel.Split('-');
			return LevelDataDic[int.Parse(array[0])].LevelName + "-" + StrengthDataDic[int.Parse(array[1])].StrengthGrade;
		}

		public static string GetMaxChallengeLevel()
		{
			string[] array = maxLevel.Split('-');
			return LevelDataDic[int.Parse(array[0])].LevelName + "-" + StrengthDataDic[int.Parse(array[1])].StrengthGrade;
		}

		public static string GetMinChallengeLevel()
		{
			string[] array = minLevel.Split('-');
			return LevelDataDic[int.Parse(array[0])].LevelName + "-" + StrengthDataDic[int.Parse(array[1])].StrengthGrade;
		}

		public static void AddStrength(int upshift)
		{
			curStrengthID += upshift;
			if (curStrengthID > 9)
			{
				if (LoadManager.IsLocalOperate && curLevelID >= LoadManager.MaxLevelID)
				{
					curStrengthID = 9;
				}
				else if (curLevelID >= LevelDataDic.Count - 1)
				{
					curStrengthID = 9;
				}
				else
				{
					curStrengthID -= 10;
					curLevelID++;
				}
			}
			SetMaxLevel();
			UIController.Instance.LevelTxt.text = GetCurLevel;
			LoadManager.SubmitLevelRecord(curLevelID, curStrengthID, UIController.Instance.GetUseDuration(), curScore, J_LitJson.JsonMapper.ToJson(GetGameRecord()));
		}

		public static void ReduceStrength(int downshift)
		{
			curStrengthID -= downshift;
			if (curStrengthID < 0)
			{
				if (curLevelID <= 0)
				{
					curStrengthID = 0;
				}
				else
				{
					curStrengthID += 10;
					curLevelID--;
				}
			}
			SetMinLevel();
			UIController.Instance.LevelTxt.text = GetCurLevel;
			LoadManager.SubmitLevelRecord(curLevelID, curStrengthID, UIController.Instance.GetUseDuration(), curScore, J_LitJson.JsonMapper.ToJson(GetGameRecord()));
		}

		private static void SetMaxLevel()
		{
			string[] array = maxLevel.Split('-');
			int num = int.Parse(array[0]);
			int num2 = int.Parse(array[1]);
			if (curLevelID == num)
			{
				if (curStrengthID > num2)
				{
					maxLevel = curLevelID + "-" + curStrengthID;
				}
			}
			else if (curLevelID > num)
			{
				maxLevel = curLevelID + "-" + curStrengthID;
			}
		}

		private static void SetMinLevel()
		{
			string[] array = minLevel.Split('-');
			int num = int.Parse(array[0]);
			int num2 = int.Parse(array[1]);
			if (curLevelID == num)
			{
				if (curStrengthID < num2)
				{
					minLevel = curLevelID + "-" + curStrengthID;
				}
			}
			else if (curLevelID < num)
			{
				minLevel = curLevelID + "-" + curStrengthID;
			}
		}

		public static void AddScore(int score)
		{
			curScore += score;
			UIController.Instance.CurScoreTxt.text = curScore.ToString();
		}

		public static void SetChanglleNum(int missMun)
		{
			int num = CurPickUpBallLevel.ChallengeNum - missMun;
			UIController.Instance.ChanglleNumTxt.text = ((num == 0) ? 1 : num).ToString();
		}

		public static GameRecordData GetGameRecord()
		{
			return new GameRecordData
			{
				InitLevel = minLevel,
				MaxLevel = maxLevel,
				MinLevel = minLevel,
				AllPass = allPass,
				PerfectNum = perfectNum,
				ContinuateMaxNum = continuateMaxNum,
				TotalBallNum = totalBallNum,
				PickBallNum = pickBallNum,
				PickBombNum = pickBombNum,
				TotalBombNum = totalBombNum
			};
		}
	}
	public class GameRecordData
	{
		public string InitLevel;

		public string MaxLevel;

		public string MinLevel;

		public int AllPass;

		public int PerfectNum;

		public int ContinuateMaxNum;

		public int TotalBallNum;

		public int PickBallNum;

		public int PickBombNum;

		public int TotalBombNum;
	}
	public class NetPocketController : MonoBehaviour
	{
		public static NetPocketController Instance;

		public ParticleSystem particleRight;

		public ParticleSystem particleError;

		public Material matNetPocket;

		public bool isNetPocket;

		private void Awake()
		{
			Instance = this;
		}

		private void Start()
		{
		}

		private void Update()
		{
		}

		public void PlayParticle(bool isRight = true)
		{
			if (isRight)
			{
				particleRight.Play();
			}
			else
			{
				particleError.Play();
			}
		}

		private void OnTriggerStay(Collider other)
		{
			if (other.name.Equals("PickupArea"))
			{
				isNetPocket = true;
			}
			else if (!other.GetComponent<BallController>())
			{
				matNetPocket.color = new Color(matNetPocket.color.r, matNetPocket.color.g, matNetPocket.color.b, 0f);
			}
		}

		private void OnTriggerExit(Collider other)
		{
			if (other.name.Equals("PickupArea"))
			{
				isNetPocket = false;
			}
			else if (!other.GetComponent<BallController>())
			{
				matNetPocket.color = new Color(matNetPocket.color.r, matNetPocket.color.g, matNetPocket.color.b, 1f);
			}
		}
	}
	public class PlayerController : MonoBehaviour
	{
		public static PlayerController Instance;

		public GameObject wangDou;

		public Pvr_ControllerModuleInit pvr_ControllerModuleInit;

		public BatteryTipController batteryTipController;

		private bool lastVivePointersIsShow;

		private void Awake()
		{
			Instance = this;
		}

		private void Start()
		{
			Time.fixedDeltaTime = 0.01f;
		}

		private void Update()
		{
		}

		public void InitData()
		{
			IsShowVivePointers(LoadManager.IsLocalOperate);
			List<PickUpBallLevel> list = CsvMapper.ToObjectList<PickUpBallLevel>(LoadManager.CsvRead("PickUpBallLevel"));
			CheckpointManager.LevelDataDic.Clear();
			foreach (PickUpBallLevel item in list)
			{
				CheckpointManager.LevelDataDic.Add(item.LevelID, item);
			}
			List<PickUpBallStrength> list2 = CsvMapper.ToObjectList<PickUpBallStrength>(LoadManager.CsvRead("PickUpBallStrength"));
			CheckpointManager.StrengthDataDic.Clear();
			foreach (PickUpBallStrength item2 in list2)
			{
				CheckpointManager.StrengthDataDic.Add(item2.StrengthID, item2);
			}
		}

		public void IsShowVivePointers(bool isShow)
		{
			lastVivePointersIsShow = pvr_ControllerModuleInit.GetModuleState();
			pvr_ControllerModuleInit.ForceHideOrShow(isShow);
			wangDou.SetActive(!isShow);
		}

		public void ResetShowVivePointers()
		{
			pvr_ControllerModuleInit.ForceHideOrShow(lastVivePointersIsShow);
			wangDou.SetActive(!lastVivePointersIsShow);
		}

		public void DelayHander(float time, Action action)
		{
			StartCoroutine(Wait(time, action));
		}

		private IEnumerator Wait(float time, Action action)
		{
			yield return new WaitForSeconds(time);
			action?.Invoke();
		}
	}
	public class TipsUIController : MonoBehaviour
	{
		private void Start()
		{
		}

		private void Update()
		{
		}
	}
	public class UIController : MonoBehaviour
	{
		public static UIController Instance;

		[Header("开始界面")]
		public GameObject StartGamePanel;

		public ToggleGroup toggleGroup;

		public Button startGameBtn;

		public Button settingsBtn;

		public Button exitBtn;

		public AudioSource bgAudioSource;

		[Header("游戏界面")]
		public GameObject ScorePanel;

		public Text CurScoreTxt;

		public Text LevelTxt;

		public Text TotalTimeTxt;

		public Text ChanglleNumTxt;

		[Header("结算界面")]
		public GameObject PassAllCheckpointPanel;

		public TextMeshProUGUI ScoreTxt;

		public Text TrainingDurationTxt;

		public Text InitChallengeLevelTxt;

		public Text MaxChallengeLevelTxt;

		public Text MinChallengeLevelTxt;

		public Text AllPassTxt;

		public Text PerfectNumTxt;

		public Text ContinuateMaxNumTxt;

		public Text TotalBallNumTxt;

		public Text PickUpAccuracyTxt;

		public Text TotalBombNumTxt;

		public Text RecognitionRateTxt;

		public Button passAllReturnBtn;

		[Header("暂停界面")]
		public GameObject SuspendPanel;

		public Button suspendReturnStartBtn;

		public Button suspendReturnBtn;

		[Header("退出提示界面")]
		public GameObject ExitTipPanel;

		public Button defineBtn;

		public Button cancelBtn;

		public AudioSource audioSource;

		public AudioClip[] audioClips;

		private float surplusGameDuration;

		private bool isStartTime;

		private float checkTime;

		private void Awake()
		{
			Instance = this;
		}

		private void Start()
		{
			ScorePanel.SetActive(value: false);
			PassAllCheckpointPanel.SetActive(value: false);
			startGameBtn.onClick.AddListener(StartGameBtnHander);
			exitBtn.onClick.AddListener(ExitBtnHander);
			passAllReturnBtn.onClick.AddListener(PassAllBtnHander);
			suspendReturnStartBtn.onClick.AddListener(SuspendReturnStartBtnHander);
			suspendReturnBtn.onClick.AddListener(SuspendReturnBtnHander);
			defineBtn.onClick.AddListener(DefineBtnHander);
			cancelBtn.onClick.AddListener(CancelBtnHander);
			for (int i = 0; i < toggleGroup.transform.childCount; i++)
			{
				int index = i;
				Toggle component = toggleGroup.transform.GetChild(i).GetComponent<Toggle>();
				component.onValueChanged.AddListener(delegate(bool value)
				{
					if (value)
					{
						LoadManager.LevelID = index;
					}
				});
				if (LoadManager.LevelID == index)
				{
					component.isOn = true;
				}
			}
			PlayerController.Instance.InitData();
			if (LoadManager.IsLocalOperate)
			{
				StartGamePanel.SetActive(value: true);
				return;
			}
			StartGamePanel.SetActive(value: false);
			StartGameBtnHander(LoadManager.course);
		}

		private void Update()
		{
			if (CheckpointManager.IsStartGame)
			{
				surplusGameDuration -= Time.deltaTime;
				TotalTimeTxt.text = LoadManager.TimeConversion((int)surplusGameDuration);
				if (surplusGameDuration <= 0f)
				{
					CheckpointManager.OverTheGame();
				}
			}
			if (IsCanSuspend() && Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.APP))
			{
				IsStartTime(isStart: false);
				PlayerController.Instance.IsShowVivePointers(isShow: true);
				BallBirthController.Instance.IsShowMap(isShow: false);
				SuspendPanel.SetActive(value: true);
				Time.timeScale = 0f;
			}
		}

		public void IsStartTime(bool isStart = true)
		{
			isStartTime = isStart;
		}

		public void StartGame()
		{
			ScorePanel.SetActive(value: true);
			surplusGameDuration = CheckpointManager.gameDuration - CheckpointManager.gameDurationed;
			CurScoreTxt.text = CheckpointManager.curScore.ToString();
			LevelTxt.text = CheckpointManager.GetCurLevel;
			TotalTimeTxt.text = LoadManager.TimeConversion((int)surplusGameDuration);
		}

		public void OverTheGame()
		{
			PlayerController.Instance.IsShowVivePointers(isShow: true);
			PlayAudioSound(4);
			PassAllCheckpointPanel.SetActive(value: true);
			ScorePanel.SetActive(value: false);
			ScoreTxt.text = CheckpointManager.curScore.ToString();
			TrainingDurationTxt.text = LoadManager.TimeConversion((int)CheckpointManager.gameDuration);
			InitChallengeLevelTxt.text = CheckpointManager.GetInitChallengeLevel();
			MaxChallengeLevelTxt.text = CheckpointManager.GetMaxChallengeLevel();
			MinChallengeLevelTxt.text = CheckpointManager.GetMinChallengeLevel();
			AllPassTxt.text = CheckpointManager.allPass.ToString();
			PerfectNumTxt.text = CheckpointManager.perfectNum.ToString();
			ContinuateMaxNumTxt.text = CheckpointManager.continuateMaxNum.ToString();
			TotalBallNumTxt.text = CheckpointManager.totalBallNum.ToString();
			PickUpAccuracyTxt.text = Math.Round((float)CheckpointManager.pickBallNum / (float)CheckpointManager.totalBallNum, 4) * 100.0 + "%";
			TotalBombNumTxt.text = CheckpointManager.totalBombNum.ToString();
			RecognitionRateTxt.text = ((CheckpointManager.totalBombNum == 0) ? "0.00%" : (Math.Round(1f - (float)CheckpointManager.pickBombNum / (float)CheckpointManager.totalBombNum, 4) * 100.0 + "%"));
		}

		public int GetUseDuration(bool isComplete = false)
		{
			float num = CheckpointManager.gameDuration - surplusGameDuration;
			num = (isComplete ? CheckpointManager.gameDuration : num);
			return (int)num;
		}

		public void PlayAudioSound(int index)
		{
			if (audioSource.isPlaying)
			{
				audioSource.Stop();
			}
			audioSource.clip = audioClips[index];
			audioSource.Play();
		}

		public void CheckBattery(Action continueAction)
		{
			if (PlayerController.Instance.batteryTipController.CheckBattery(continueAction))
			{
				SuspendGame(suspend: true);
			}
		}

		public void SuspendGame(bool suspend)
		{
			IsStartTime(!suspend);
			PlayerController.Instance.IsShowVivePointers(suspend);
			BallBirthController.Instance.IsShowMap(!suspend);
			Time.timeScale = ((!suspend) ? 1 : 0);
		}

		private void StartGameBtnHander()
		{
			StartGameBtnHander(null);
		}

		private void StartGameBtnHander(CourseDetail.Data data)
		{
			StartGamePanel.SetActive(value: false);
			bgAudioSource.Play();
			CheckpointManager.StartTheLevel(data);
		}

		private void ExitBtnHander()
		{
			ScenesHelper.LoadScene(ScenesHelper.WeiAiZhiCenterScene);
		}

		private void PassAllBtnHander()
		{
			if (LoadManager.IsLocalOperate)
			{
				StartGamePanel.SetActive(value: true);
				PassAllCheckpointPanel.SetActive(value: false);
			}
			else
			{
				LoadManager.SubmitEndRecord(isComplete: true, isLogout: false, GetUseDuration(isComplete: true), CheckpointManager.curScore, J_LitJson.JsonMapper.ToJson(CheckpointManager.GetGameRecord()));
			}
		}

		private void SuspendReturnStartBtnHander()
		{
			if (LoadManager.IsLocalOperate)
			{
				BallBirthController.Instance.IsShowMap(isShow: true);
				CheckpointManager.ResetTheGame();
				StartGamePanel.SetActive(value: true);
				SuspendPanel.SetActive(value: false);
				ScorePanel.SetActive(value: false);
				Time.timeScale = 1f;
			}
			else
			{
				ExitTipPanel.SetActive(value: true);
			}
		}

		private void SuspendReturnBtnHander()
		{
			IsStartTime();
			BallBirthController.Instance.IsShowMap(isShow: true);
			PlayerController.Instance.IsShowVivePointers(isShow: false);
			SuspendPanel.SetActive(value: false);
			Time.timeScale = 1f;
		}

		private void DefineBtnHander()
		{
			Time.timeScale = 1f;
			LoadManager.SubmitEndRecord(isComplete: false, isLogout: false, GetUseDuration(), CheckpointManager.curScore, J_LitJson.JsonMapper.ToJson(CheckpointManager.GetGameRecord()));
		}

		private void CancelBtnHander()
		{
			ExitTipPanel.SetActive(value: false);
		}

		private bool IsCanSuspend()
		{
			if (PassAllCheckpointPanel.activeSelf)
			{
				return false;
			}
			if (CheckpointManager.IsStartGame)
			{
				return true;
			}
			return false;
		}
	}
}
namespace PerfectFill
{
	public class LevelData
	{
		public int Levelid;

		public string LevelName;

		public List<int> CheckpointArray;

		public int NextLevelid;
	}
	public class CheckpointData
	{
		public int CheckpointID;

		public string MapID;

		public float ChallengeTime;

		public int TimeThreshold;

		public int TimeScore;

		public int MissLimitTimes;

		public int NoMissScore;
	}
	public class PerfectFillLevel
	{
		public int LevelID;

		public string LevelName;

		public List<string> Range;

		public float InitialView;

		public int BaseScore;

		public int IsTimeReduce;

		public int UpshiftRequire;

		public int UpshiftGrade;

		public int DownshiftRequire;

		public int DownshiftGrade;
	}
	public class PerfectFillStrength
	{
		public int StrengthID;

		public int StrengthGrade;

		public float ScoreAddition;

		public float TimeReduce;

		public float ViewReduce;
	}
	public class PerfectFillMap
	{
		public int MapID;

		public int LimitTime;
	}
	public class CheckpointManager
	{
		public static Dictionary<int, PerfectFillLevel> LevelDataDic = new Dictionary<int, PerfectFillLevel>();

		public static Dictionary<int, PerfectFillStrength> StrengthDataDic = new Dictionary<int, PerfectFillStrength>();

		public static Dictionary<int, PerfectFillMap> MapDataDic = new Dictionary<int, PerfectFillMap>();

		public static Dictionary<int, Dictionary<int, List<string>>> MapIDDataDic = new Dictionary<int, Dictionary<int, List<string>>>();

		public static List<GameRecordData> gameRecordDatas = new List<GameRecordData>();

		public static int curLevelID;

		public static int curStrengthID;

		public static int curMapID;

		public static float gameDuration;

		public static float gameDurationed;

		public static int curScore;

		public static string startLevel;

		public static string minLevel;

		public static string maxLevel;

		public static int allPass;

		public static int timeOutNum;

		public static int totalMoveNum;

		public static List<float> efficiency;

		public static int allCheckpoints;

		public static bool IsStartGame = false;

		public static PerfectFillLevel CurFillLevel => LevelDataDic[curLevelID];

		public static PerfectFillStrength CurFillStrength => StrengthDataDic[curStrengthID];

		public static PerfectFillMap CurFillMap => MapDataDic[curMapID];

		public static int GetScore => (int)((float)CurFillLevel.BaseScore * (1f + CurFillStrength.ScoreAddition));

		public static string GetCurLevel => LevelDataDic[curLevelID].LevelName + "-" + StrengthDataDic[curStrengthID].StrengthGrade;

		public static void StartTheLevel(CourseDetail.Data data)
		{
			if (data != null)
			{
				if (data.game_data == null)
				{
					string text = data.level + "-" + data.strength;
					InitData(data.level, data.strength, data.play_time, data.already_play_time, data.point, 0, 0, 0, new List<float>(), 0, text, text, text);
				}
				else
				{
					GameRecordData gameRecordData = J_LitJson.JsonMapper.ToObject<GameRecordData>(data.game_data);
					InitData(data.level, data.strength, data.play_time, data.already_play_time, data.point, gameRecordData.AllPass, gameRecordData.TimeOutNum, gameRecordData.TotalMoveNum, gameRecordData.Efficiency, gameRecordData.AllCheckpoints, gameRecordData.InitLevel, gameRecordData.MaxLevel, gameRecordData.MinLevel);
				}
			}
			else
			{
				string text2 = LoadManager.LevelID + "-" + LoadManager.StrengthID;
				InitData(LoadManager.LevelID, LoadManager.StrengthID, LoadManager.Duration, 0, 0, 0, 0, 0, new List<float>(), 0, text2, text2, text2);
			}
			IsStartGame = true;
			RoomRootController.Instance.CreateMapToCheck(isCheck: false);
			UIController.Instance.StartGame();
		}

		private static void InitData(int level, int strength, int duration, int durationed, int score, int allpass, int timeout, int totalmove, List<float> efficien, int allCheck, string start, string max, string min)
		{
			curLevelID = level;
			curStrengthID = strength;
			gameDuration = duration;
			gameDurationed = durationed;
			curScore = score;
			allPass = allpass;
			timeOutNum = timeout;
			totalMoveNum = totalmove;
			efficiency = efficien;
			allCheckpoints = allCheck;
			startLevel = start;
			maxLevel = max;
			minLevel = min;
		}

		public static void OverTheGame()
		{
			IsStartGame = false;
			RoomRootController.Instance.ClearMap();
			PlayerController.Instance.StopAllCoroutines();
			UIController.Instance.OverTheGame();
		}

		public static void ResetTheGame()
		{
			IsStartGame = false;
			RoomRootController.Instance.ClearMap();
			PlayerController.Instance.StopAllCoroutines();
		}

		public static string GetInitChallengeLevel()
		{
			string[] array = startLevel.Split('-');
			return LevelDataDic[int.Parse(array[0])].LevelName + "-" + StrengthDataDic[int.Parse(array[1])].StrengthGrade;
		}

		public static string GetMaxChallengeLevel()
		{
			string[] array = maxLevel.Split('-');
			return LevelDataDic[int.Parse(array[0])].LevelName + "-" + StrengthDataDic[int.Parse(array[1])].StrengthGrade;
		}

		public static string GetMinChallengeLevel()
		{
			string[] array = minLevel.Split('-');
			return LevelDataDic[int.Parse(array[0])].LevelName + "-" + StrengthDataDic[int.Parse(array[1])].StrengthGrade;
		}

		public static void AddStrength(int upshift)
		{
			curStrengthID += upshift;
			if (curStrengthID > 9)
			{
				if (LoadManager.IsLocalOperate && curLevelID >= LoadManager.MaxLevelID)
				{
					curStrengthID = 9;
				}
				else if (curLevelID >= LevelDataDic.Count - 1)
				{
					curStrengthID = 9;
				}
				else
				{
					curStrengthID -= 10;
					curLevelID++;
				}
			}
			SetMaxLevel();
			UIController.Instance.LevelTxt.text = GetCurLevel;
			LoadManager.SubmitLevelRecord(curLevelID, curStrengthID, UIController.Instance.GetUseDuration(), curScore, J_LitJson.JsonMapper.ToJson(GetGameRecord()));
		}

		public static void ReduceStrength(int downshift)
		{
			curStrengthID -= downshift;
			if (curStrengthID < 0)
			{
				if (curLevelID <= 0)
				{
					curStrengthID = 0;
				}
				else
				{
					curStrengthID += 10;
					curLevelID--;
				}
			}
			SetMinLevel();
			UIController.Instance.LevelTxt.text = GetCurLevel;
			LoadManager.SubmitLevelRecord(curLevelID, curStrengthID, UIController.Instance.GetUseDuration(), curScore, J_LitJson.JsonMapper.ToJson(GetGameRecord()));
		}

		private static void SetMaxLevel()
		{
			string[] array = maxLevel.Split('-');
			int num = int.Parse(array[0]);
			int num2 = int.Parse(array[1]);
			if (curLevelID == num)
			{
				if (curStrengthID > num2)
				{
					maxLevel = curLevelID + "-" + curStrengthID;
				}
			}
			else if (curLevelID > num)
			{
				maxLevel = curLevelID + "-" + curStrengthID;
			}
		}

		private static void SetMinLevel()
		{
			string[] array = minLevel.Split('-');
			int num = int.Parse(array[0]);
			int num2 = int.Parse(array[1]);
			if (curLevelID == num)
			{
				if (curStrengthID < num2)
				{
					minLevel = curLevelID + "-" + curStrengthID;
				}
			}
			else if (curLevelID < num)
			{
				minLevel = curLevelID + "-" + curStrengthID;
			}
		}

		public static void AddScore(int score)
		{
			curScore += score;
			UIController.Instance.CurScoreTxt.text = curScore.ToString();
		}

		public static void SetChanglleTime(float catchTimer)
		{
			UIController.Instance.ChanglleTimeTxt.text = Mathf.Ceil(catchTimer).ToString();
		}

		public static GameRecordData GetGameRecord()
		{
			return new GameRecordData
			{
				InitLevel = minLevel,
				MaxLevel = maxLevel,
				MinLevel = minLevel,
				AllPass = allPass,
				TimeOutNum = timeOutNum,
				TotalMoveNum = totalMoveNum,
				Efficiency = efficiency,
				AllCheckpoints = allCheckpoints
			};
		}
	}
	public class FloorController : MonoBehaviour
	{
		public FloorType floorType;

		public Vector2 matrix;

		public bool isWalked;

		private void Start()
		{
		}

		private void Update()
		{
		}
	}
	public class GameRecordData
	{
		public string InitLevel;

		public string MaxLevel;

		public string MinLevel;

		public int AllPass;

		public int TimeOutNum;

		public int TotalMoveNum;

		public List<float> Efficiency;

		public int AllCheckpoints;
	}
	public class PerfectFillDetail
	{
		public int row;

		public int column;

		public List<PerfectFillItem> bombDisposalItems = new List<PerfectFillItem>();
	}
	public class PerfectFillItem
	{
		public WallType leftWallType;

		public WallType upWallType;

		public PersonType personType;

		public FloorType floorType;
	}
	public class PersonController : MonoBehaviour
	{
		public float speed = 0.5f;

		public Action moveComplete;

		public bool isAni;

		public GameObject fxObj;

		public Vector2 curMatrix;

		public PersonType personType;

		public List<Vector2> walkTheWays;

		public List<GameObject> walkTheWaysFx;

		private HighlightEffect selectEffect;

		private Animation anima;

		private bool isMove;

		private Vector3 endPos;

		private void Start()
		{
			selectEffect = GetComponent<HighlightEffect>();
			anima = GetComponent<Animation>();
		}

		private void Update()
		{
			if (isMove)
			{
				base.transform.position = Vector3.MoveTowards(base.transform.position, endPos, speed * Time.deltaTime);
				if (base.transform.position == endPos)
				{
					isMove = false;
					moveComplete?.Invoke();
				}
			}
		}

		public void Move(Vector3 end, Action complete)
		{
			SetForward(end - base.transform.position);
			anima.Play("Jump");
			endPos = end;
			moveComplete = complete;
			isMove = true;
		}

		public void StopMove()
		{
			isMove = false;
			anima.Play("Idle");
		}

		public void SetForward(Vector3 forward)
		{
			base.transform.forward = forward;
			Vector3 localEulerAngles = new Vector3(0f, base.transform.localEulerAngles.y, 0f);
			base.transform.localEulerAngles = localEulerAngles;
		}

		public void Selected(bool isselect)
		{
			if (selectEffect.enabled != isselect)
			{
				selectEffect.enabled = isselect;
			}
		}
	}
	public class PlayerController : MonoBehaviour
	{
		public static PlayerController Instance;

		public GameObject rightHand;

		public BatteryTipController batteryTipController;

		private Ray ray;

		private RaycastHit hit;

		private void Awake()
		{
			Instance = this;
			ray = default(Ray);
			hit = default(RaycastHit);
		}

		private void Start()
		{
			Time.fixedDeltaTime = 0.02f;
		}

		private void Update()
		{
			if (CheckpointManager.IsStartGame && (Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.TRIGGER) || Input.GetKeyDown(KeyCode.Space)))
			{
				ray.direction = rightHand.transform.forward;
				ray.origin = rightHand.transform.position;
				if (Physics.Raycast(ray, out hit, 100f, 1 << LayerMask.NameToLayer("Keys")))
				{
					RoomRootController.Instance.SelectCat(hit.transform);
				}
			}
		}

		public void InitData()
		{
			List<PerfectFillLevel> list = CsvMapper.ToObjectList<PerfectFillLevel>(LoadManager.CsvRead("PerfectFillLevel"));
			CheckpointManager.LevelDataDic.Clear();
			CheckpointManager.MapIDDataDic.Clear();
			foreach (PerfectFillLevel item in list)
			{
				CheckpointManager.LevelDataDic.Add(item.LevelID, item);
				Dictionary<int, List<string>> dictionary = new Dictionary<int, List<string>>();
				CheckpointManager.MapIDDataDic.Add(item.LevelID, dictionary);
				for (int i = 0; i < item.Range.Count; i++)
				{
					string[] source = item.Range[i].TrimStart('(').TrimEnd(')').Split('/');
					dictionary.Add(i, source.ToList());
				}
			}
			List<PerfectFillStrength> list2 = CsvMapper.ToObjectList<PerfectFillStrength>(LoadManager.CsvRead("PerfectFillStrength"));
			CheckpointManager.StrengthDataDic.Clear();
			foreach (PerfectFillStrength item2 in list2)
			{
				CheckpointManager.StrengthDataDic.Add(item2.StrengthID, item2);
			}
			List<PerfectFillMap> list3 = CsvMapper.ToObjectList<PerfectFillMap>(LoadManager.CsvRead("PerfectFillMap"));
			CheckpointManager.MapDataDic.Clear();
			foreach (PerfectFillMap item3 in list3)
			{
				CheckpointManager.MapDataDic.Add(item3.MapID, item3);
			}
		}

		public void DelayHander(float time, Action action)
		{
			StartCoroutine(Wait(time, action));
		}

		private IEnumerator Wait(float time, Action action)
		{
			yield return new WaitForSeconds(time);
			action?.Invoke();
		}
	}
	public class RoomEditItem : MonoBehaviour
	{
		public GameObject bg;

		public Button leftWallBtn;

		private Image leftWallImg;

		public Button upWallBtn;

		private Image upWallImg;

		public Button floorBtn;

		public Button personBtn;

		private Image personImg;

		public Text leftWallTxt;

		public Text upWallTxt;

		public Text floorTxt;

		public Text personTxt;

		public WallType leftWallType;

		public WallType upWallType;

		public PersonType personType;

		public FloorType floorType;

		public Vector2 matrix;

		public Action<bool, Vector2> setRoomAction;

		public Image LeftWallImg
		{
			get
			{
				if (leftWallImg == null)
				{
					leftWallImg = leftWallBtn.GetComponent<Image>();
				}
				return leftWallImg;
			}
		}

		public Image UpWallImg
		{
			get
			{
				if (upWallImg == null)
				{
					upWallImg = upWallBtn.GetComponent<Image>();
				}
				return upWallImg;
			}
		}

		public Image PersonImg
		{
			get
			{
				if (personImg == null)
				{
					personImg = personBtn.GetComponent<Image>();
				}
				return personImg;
			}
		}

		private void Start()
		{
			leftWallBtn.onClick.AddListener(LeftWallBtnHander);
			upWallBtn.onClick.AddListener(UpWallBtnHander);
			floorBtn.onClick.AddListener(FloorBtnHander);
			personBtn.onClick.AddListener(PersonBtnHander);
		}

		public void InitItem()
		{
			SetWall(0, WallType.None);
			SetWall(1, WallType.None);
			SetFloor(FloorType.Normal);
			SetPerson(PersonType.None);
		}

		public void SetWall(int dir, WallType wallType)
		{
			if (dir == 0)
			{
				leftWallType = wallType;
				if (leftWallType == WallType.None)
				{
					leftWallTxt.text = "无";
					LeftWallImg.color = Color.white;
				}
				else if (leftWallType == WallType.Wall)
				{
					leftWallTxt.text = "墙";
					LeftWallImg.color = Color.black;
				}
			}
			else
			{
				upWallType = wallType;
				if (upWallType == WallType.None)
				{
					upWallTxt.text = "无";
					UpWallImg.color = Color.white;
				}
				else if (upWallType == WallType.Wall)
				{
					upWallTxt.text = "墙";
					UpWallImg.color = Color.black;
				}
			}
		}

		private void LeftWallBtnHander()
		{
			int num = Convert.ToInt32(leftWallType);
			string[] names = Enum.GetNames(leftWallType.GetType());
			int wallType = (num + 1) % names.Length;
			SetWall(0, (WallType)wallType);
		}

		private void UpWallBtnHander()
		{
			int num = Convert.ToInt32(upWallType);
			string[] names = Enum.GetNames(upWallType.GetType());
			int wallType = (num + 1) % names.Length;
			SetWall(1, (WallType)wallType);
		}

		public void SetFloor(FloorType type)
		{
			floorType = type;
			if (floorType == FloorType.Normal)
			{
				floorTxt.text = "地板";
				IsActive(active: true);
				setRoomAction?.Invoke(arg1: true, matrix);
			}
			else if (floorType == FloorType.None)
			{
				floorTxt.text = "无";
				IsActive(active: false);
				setRoomAction?.Invoke(arg1: false, matrix);
			}
		}

		private void FloorBtnHander()
		{
			if (floorType == FloorType.Normal)
			{
				SetFloor(FloorType.None);
			}
			else if (floorType == FloorType.None)
			{
				SetFloor(FloorType.Normal);
			}
		}

		private void IsActive(bool active)
		{
			bg.SetActive(active);
			personBtn.gameObject.SetActive(active);
		}

		public void SetPerson(PersonType type)
		{
			personType = type;
			if (personType == PersonType.None)
			{
				personTxt.text = "无";
				PersonImg.color = Color.white;
			}
			else if (personType == PersonType.Yellow)
			{
				personTxt.text = "黄";
				PersonImg.color = Color.yellow;
			}
			else if (personType == PersonType.Green)
			{
				personTxt.text = "绿";
				PersonImg.color = Color.green;
			}
			else if (personType == PersonType.Blue)
			{
				personTxt.text = "蓝";
				PersonImg.color = Color.blue;
			}
			else if (personType == PersonType.Red)
			{
				personTxt.text = "红";
				PersonImg.color = Color.red;
			}
			else if (personType == PersonType.Purple)
			{
				personTxt.text = "紫";
				PersonImg.color = new Color(0.5882353f, 0f, 1f);
			}
		}

		private void PersonBtnHander()
		{
			if (personType == PersonType.None)
			{
				SetPerson(PersonType.Yellow);
			}
			else if (personType == PersonType.Yellow)
			{
				SetPerson(PersonType.Green);
			}
			else if (personType == PersonType.Green)
			{
				SetPerson(PersonType.Blue);
			}
			else if (personType == PersonType.Blue)
			{
				SetPerson(PersonType.Red);
			}
			else if (personType == PersonType.Red)
			{
				SetPerson(PersonType.Purple);
			}
			else if (personType == PersonType.Purple)
			{
				SetPerson(PersonType.None);
			}
		}

		private void Update()
		{
		}
	}
	public enum WallType
	{
		None,
		Wall
	}
	public enum FloorType
	{
		Normal,
		None
	}
	public enum PersonType
	{
		None,
		Yellow,
		Green,
		Blue,
		Red,
		Purple
	}
	public class RoomEditManager : MonoBehaviour
	{
		public static RoomEditManager Instance;

		public GridLayoutGroup gridLayoutGroup;

		public GameObject template;

		public InputField fileNameInput;

		public InputField rowInput;

		public InputField columnInput;

		public Button createBtn;

		public Button clearBtn;

		public Button openFileBtn;

		public Button saveFileBtn;

		private PerfectFillDetail bombDisposalDetail;

		private void Awake()
		{
			Instance = this;
		}

		private void Start()
		{
			createBtn.onClick.AddListener(CreateBtnHander);
			clearBtn.onClick.AddListener(ClearBtnHander);
			openFileBtn.onClick.AddListener(OpenBtnHander);
			saveFileBtn.onClick.AddListener(SaveBtnHander);
			clearBtn.gameObject.SetActive(value: false);
		}

		private void ClearBtnHander()
		{
			foreach (Transform item in gridLayoutGroup.transform)
			{
				UnityEngine.Object.Destroy(item.gameObject);
			}
			clearBtn.gameObject.SetActive(value: false);
			createBtn.gameObject.SetActive(value: true);
		}

		private void CreateBtnHander()
		{
			if (string.IsNullOrEmpty(rowInput.text) || string.IsNullOrEmpty(columnInput.text))
			{
				return;
			}
			int num = int.Parse(rowInput.text);
			int num2 = int.Parse(columnInput.text);
			if (num < 1 || num > 20 || num2 < 1 || num2 > 20)
			{
				return;
			}
			ClearBtnHander();
			clearBtn.gameObject.SetActive(value: true);
			createBtn.gameObject.SetActive(value: false);
			gridLayoutGroup.constraintCount = int.Parse(columnInput.text);
			for (int i = 0; i < num; i++)
			{
				for (int j = 0; j < num2; j++)
				{
					GameObject obj = UnityEngine.Object.Instantiate(template, gridLayoutGroup.transform);
					obj.SetActive(value: true);
					RoomEditItem component = obj.GetComponent<RoomEditItem>();
					component.InitItem();
					component.matrix = new Vector2(j, i);
					component.setRoomAction = SetRoomCallBack;
					if (j == 0)
					{
						component.leftWallBtn.gameObject.SetActive(value: false);
					}
					if (i == 0)
					{
						component.upWallBtn.gameObject.SetActive(value: false);
					}
				}
			}
		}

		private void OpenBtnHander()
		{
			string path = Application.dataPath + "/PerfectFill/Resources/PerfectFillData/" + fileNameInput.text + ".json";
			if (!string.IsNullOrEmpty(fileNameInput.text) && File.Exists(path))
			{
				InitBombDisposalDetail(File.ReadAllText(path));
			}
		}

		private void SaveBtnHander()
		{
			if (ReadBombDisposalDetail())
			{
				string path = Application.dataPath + "/PerfectFill/Resources/PerfectFillData/" + fileNameInput.text + ".json";
				if (!string.IsNullOrEmpty(fileNameInput.text))
				{
					File.WriteAllText(path, J_LitJson.JsonMapper.ToJson(bombDisposalDetail));
				}
			}
		}

		private bool ReadBombDisposalDetail()
		{
			if (gridLayoutGroup.transform.childCount == 0)
			{
				return false;
			}
			bombDisposalDetail = new PerfectFillDetail();
			bombDisposalDetail.column = gridLayoutGroup.constraintCount;
			bombDisposalDetail.row = gridLayoutGroup.transform.childCount / gridLayoutGroup.constraintCount;
			foreach (Transform item in gridLayoutGroup.transform)
			{
				RoomEditItem component = item.GetComponent<RoomEditItem>();
				PerfectFillItem perfectFillItem = new PerfectFillItem();
				perfectFillItem.leftWallType = component.leftWallType;
				perfectFillItem.upWallType = component.upWallType;
				perfectFillItem.floorType = component.floorType;
				if (perfectFillItem.floorType == FloorType.None)
				{
					perfectFillItem.personType = PersonType.None;
				}
				else
				{
					perfectFillItem.personType = component.personType;
				}
				bombDisposalDetail.bombDisposalItems.Add(perfectFillItem);
			}
			return true;
		}

		private void InitBombDisposalDetail(string json)
		{
			ClearBtnHander();
			clearBtn.gameObject.SetActive(value: true);
			createBtn.gameObject.SetActive(value: false);
			bombDisposalDetail = J_LitJson.JsonMapper.ToObject<PerfectFillDetail>(json);
			gridLayoutGroup.constraintCount = bombDisposalDetail.column;
			int num = 0;
			for (int i = 0; i < bombDisposalDetail.row; i++)
			{
				for (int j = 0; j < bombDisposalDetail.column; j++)
				{
					GameObject obj = UnityEngine.Object.Instantiate(template, gridLayoutGroup.transform);
					obj.SetActive(value: true);
					RoomEditItem component = obj.GetComponent<RoomEditItem>();
					component.SetWall(0, bombDisposalDetail.bombDisposalItems[num].leftWallType);
					component.SetWall(1, bombDisposalDetail.bombDisposalItems[num].upWallType);
					component.SetFloor(bombDisposalDetail.bombDisposalItems[num].floorType);
					component.upWallBtn.gameObject.SetActive(bombDisposalDetail.bombDisposalItems[num].floorType != FloorType.None);
					component.leftWallBtn.gameObject.SetActive(bombDisposalDetail.bombDisposalItems[num].floorType != FloorType.None);
					component.SetPerson(bombDisposalDetail.bombDisposalItems[num].personType);
					component.matrix = new Vector2(j, i);
					component.setRoomAction = SetRoomCallBack;
					if (j == 0)
					{
						component.leftWallBtn.gameObject.SetActive(value: false);
					}
					if (i == 0)
					{
						component.upWallBtn.gameObject.SetActive(value: false);
					}
					num++;
				}
			}
			foreach (Transform item in gridLayoutGroup.transform)
			{
				RoomEditItem component2 = item.GetComponent<RoomEditItem>();
				SetRoomCallBack(component2.floorType != FloorType.None, component2.matrix);
			}
		}

		private void SetRoomCallBack(bool isActive, Vector2 matrix)
		{
			RoomEditItem roomEditItem = FindRoomEditItem(matrix);
			if (matrix.y > 0f)
			{
				RoomEditItem roomEditItem2 = FindRoomEditItem(new Vector2(matrix.x, matrix.y - 1f));
				RoomEditItem roomEditItem3 = FindRoomEditItem(new Vector2(matrix.x, matrix.y + 1f));
				if (isActive)
				{
					if (roomEditItem2.floorType == FloorType.Normal)
					{
						roomEditItem.upWallBtn.gameObject.SetActive(value: true);
					}
					if ((bool)roomEditItem3)
					{
						if (roomEditItem3.floorType == FloorType.Normal)
						{
							roomEditItem3.upWallBtn.gameObject.SetActive(value: true);
						}
						else
						{
							roomEditItem3.SetWall(1, WallType.None);
							roomEditItem3.upWallBtn.gameObject.SetActive(value: false);
						}
					}
				}
				else
				{
					roomEditItem.SetWall(1, WallType.None);
					roomEditItem.upWallBtn.gameObject.SetActive(value: false);
					if ((bool)roomEditItem3)
					{
						roomEditItem3.SetWall(1, WallType.None);
						roomEditItem3.upWallBtn.gameObject.SetActive(value: false);
					}
				}
			}
			if (!(matrix.x > 0f))
			{
				return;
			}
			RoomEditItem roomEditItem4 = FindRoomEditItem(new Vector2(matrix.x - 1f, matrix.y));
			RoomEditItem roomEditItem5 = FindRoomEditItem(new Vector2(matrix.x + 1f, matrix.y));
			if (isActive)
			{
				roomEditItem.leftWallBtn.gameObject.SetActive(value: true);
			}
			if (!isActive && roomEditItem4.floorType == FloorType.Normal)
			{
				roomEditItem.SetWall(0, WallType.None);
				roomEditItem.leftWallBtn.gameObject.SetActive(value: false);
			}
			if ((bool)roomEditItem5 && !isActive && roomEditItem5.floorType == FloorType.Normal)
			{
				roomEditItem5.SetWall(0, WallType.None);
				roomEditItem5.leftWallBtn.gameObject.SetActive(value: false);
			}
			else if ((bool)roomEditItem5 && isActive && roomEditItem5.floorType == FloorType.Normal)
			{
				roomEditItem5.leftWallBtn.gameObject.SetActive(value: true);
			}
			if (isActive)
			{
				if (roomEditItem4.floorType == FloorType.Normal)
				{
					roomEditItem.leftWallBtn.gameObject.SetActive(value: true);
				}
				if ((bool)roomEditItem5)
				{
					if (roomEditItem5.floorType == FloorType.Normal)
					{
						roomEditItem5.leftWallBtn.gameObject.SetActive(value: true);
						return;
					}
					roomEditItem5.SetWall(0, WallType.None);
					roomEditItem5.leftWallBtn.gameObject.SetActive(value: false);
				}
			}
			else
			{
				roomEditItem.SetWall(0, WallType.None);
				roomEditItem.leftWallBtn.gameObject.SetActive(value: false);
				if ((bool)roomEditItem5)
				{
					roomEditItem5.SetWall(0, WallType.None);
					roomEditItem5.leftWallBtn.gameObject.SetActive(value: false);
				}
			}
		}

		private RoomEditItem FindRoomEditItem(Vector2 matrix)
		{
			int constraintCount = gridLayoutGroup.constraintCount;
			int num = gridLayoutGroup.transform.childCount / gridLayoutGroup.constraintCount;
			if (matrix.y >= (float)num)
			{
				return null;
			}
			if (matrix.x >= (float)constraintCount)
			{
				return null;
			}
			return gridLayoutGroup.transform.GetChild((int)(matrix.y * (float)constraintCount + matrix.x)).GetComponent<RoomEditItem>();
		}

		private void Update()
		{
			if (Input.GetAxis("Mouse ScrollWheel") != 0f)
			{
				Vector3 localScale = gridLayoutGroup.transform.localScale;
				localScale.x += Input.GetAxis("Mouse ScrollWheel");
				localScale.y += Input.GetAxis("Mouse ScrollWheel");
				gridLayoutGroup.transform.localScale = localScale;
			}
		}
	}
	public class RoomRootController : MonoBehaviour
	{
		public static RoomRootController Instance;

		public float size = 2f;

		public Transform root;

		public Transform floorParent;

		public Transform wallParent;

		public Transform personParent;

		public AudioSource audioSource;

		public AudioClip[] audioClips;

		private PerfectFillDetail detail;

		private List<PersonController> personList;

		private PersonController personController;

		private List<FloorController> floorList;

		private bool isRun;

		private float challengeTimer;

		private int lastRandom = 1000;

		public List<PersonController> PersonList
		{
			get
			{
				if (personList == null)
				{
					personList = new List<PersonController>();
				}
				return personList;
			}
		}

		public List<FloorController> FloorList
		{
			get
			{
				if (floorList == null)
				{
					floorList = new List<FloorController>();
				}
				return floorList;
			}
		}

		private void Awake()
		{
			Instance = this;
		}

		private void Start()
		{
		}

		private void Update()
		{
			if (CheckpointManager.IsStartGame && !isRun && (bool)personController)
			{
				if (Input.GetKey(KeyCode.LeftArrow) || (Controller.UPvr_GetAxis2D(1).x < 0f && CheckAngle(Controller.UPvr_GetAxis2D(1).normalized, Vector2.left)))
				{
					Move(Vector3.left);
				}
				else if (Input.GetKey(KeyCode.RightArrow) || (Controller.UPvr_GetAxis2D(1).x > 0f && CheckAngle(Controller.UPvr_GetAxis2D(1).normalized, Vector2.right)))
				{
					Move(Vector3.right);
				}
				else if (Input.GetKey(KeyCode.UpArrow) || (Controller.UPvr_GetAxis2D(1).y > 0f && CheckAngle(Controller.UPvr_GetAxis2D(1).normalized, Vector2.up)))
				{
					Move(Vector3.forward);
				}
				else if (Input.GetKey(KeyCode.DownArrow) || (Controller.UPvr_GetAxis2D(1).y < 0f && CheckAngle(Controller.UPvr_GetAxis2D(1).normalized, Vector2.down)))
				{
					Move(Vector3.back);
				}
			}
			if (!UIController.Instance.isStartTime)
			{
				return;
			}
			challengeTimer -= Time.deltaTime;
			CheckpointManager.SetChanglleTime(challengeTimer);
			if (challengeTimer <= 0f)
			{
				personController?.StopMove();
				CheckpointManager.SetChanglleTime(0f);
				UIController.Instance.IsStartTime(isStart: false);
				UIController.Instance.PlayAudioSound(1);
				CheckpointManager.timeOutNum++;
				CheckpointManager.ReduceStrength(CheckpointManager.CurFillLevel.DownshiftGrade);
				PlayerController.Instance.StopAllCoroutines();
				PlayerController.Instance.DelayHander(1.5f, delegate
				{
					ClearMap();
					CreateMapToCheck();
				});
			}
		}

		public void CreateMapToCheck(bool isCheck = true)
		{
			List<string> list = CheckpointManager.MapIDDataDic[CheckpointManager.curLevelID][CheckpointManager.curStrengthID];
			lastRandom = MyMath.RandomRange(0, list.Count, lastRandom);
			CheckpointManager.curMapID = int.Parse(list[lastRandom]);
			challengeTimer = CheckpointManager.CurFillMap.LimitTime;
			CheckpointManager.SetChanglleTime(challengeTimer);
			if (isCheck)
			{
				UIController.Instance.CheckBattery(delegate
				{
					UIController.Instance.SuspendGame(suspend: false);
					CreateMap(CheckpointManager.curMapID);
				});
			}
			else
			{
				CreateMap(CheckpointManager.curMapID);
			}
		}

		private void CreateMap(int mapID)
		{
			UIController.Instance.IsStartTime();
			PersonList.Clear();
			FloorList.Clear();
			CheckpointManager.allCheckpoints++;
			string text = Resources.Load<TextAsset>("PerfectFillData/E" + mapID).text;
			detail = J_LitJson.JsonMapper.ToObject<PerfectFillDetail>(text);
			float num = ((detail.column % 2 == 0) ? ((float)(-detail.column / 2) * size + size / 2f) : ((float)(-detail.column / 2) * size));
			float num2 = ((detail.row % 2 == 0) ? ((float)(detail.row / 2) * size - size / 2f) : ((float)(detail.row / 2) * size));
			for (int i = 0; i < detail.row; i++)
			{
				for (int j = 0; j < detail.column; j++)
				{
					PerfectFillItem perfectFillItem = FindPerfectFillItem(i, j);
					if (perfectFillItem.floorType != FloorType.None)
					{
						string text2 = perfectFillItem.floorType.ToString();
						GameObject obj = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("PerfectFillPrefabs/" + text2), floorParent.transform);
						float x = num + (float)j * size;
						float z = num2 - (float)i * size;
						obj.transform.localPosition = new Vector3(x, 0f, z);
						FloorController component = obj.GetComponent<FloorController>();
						component.floorType = perfectFillItem.floorType;
						component.matrix = new Vector2(j, i);
						FloorList.Add(component);
					}
					if (perfectFillItem.upWallType != 0)
					{
						string text3 = perfectFillItem.upWallType.ToString();
						GameObject obj2 = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("PerfectFillPrefabs/" + text3), wallParent.transform);
						float x2 = num + (float)j * size;
						float z2 = num2 - (float)i * size + size * 0.5f;
						obj2.transform.localPosition = new Vector3(x2, 0f, z2);
						obj2.transform.localEulerAngles = Vector3.zero;
						obj2.GetComponent<WallController>().matrix = new Vector3(j, i, 1f);
					}
					if (perfectFillItem.leftWallType != 0)
					{
						string text4 = perfectFillItem.leftWallType.ToString();
						GameObject obj3 = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("PerfectFillPrefabs/" + text4), wallParent.transform);
						float x3 = num + (float)j * size - size * 0.5f;
						float z3 = num2 - (float)i * size;
						obj3.transform.localPosition = new Vector3(x3, 0f, z3);
						obj3.transform.localEulerAngles = new Vector3(0f, 90f, 0f);
						obj3.GetComponent<WallController>().matrix = new Vector3(j, i, 0f);
					}
					if (perfectFillItem.personType != 0)
					{
						string text5 = perfectFillItem.personType.ToString();
						GameObject gameObject = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("PerfectFillPrefabs/Cat_" + text5), personParent.transform);
						float x4 = num + (float)j * size;
						float z4 = num2 - (float)i * size;
						PersonController person = gameObject.GetComponent<PersonController>();
						person.walkTheWays = new List<Vector2>();
						person.walkTheWaysFx = new List<GameObject>();
						person.personType = perfectFillItem.personType;
						person.curMatrix = new Vector2(j, i);
						gameObject.transform.localPosition = new Vector3(x4, 0f, z4);
						GameObject gameObject2 = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("PerfectFillPrefabs/FX_" + text5), personParent.transform);
						gameObject2.transform.localPosition = new Vector3(x4, 0f, z4);
						PersonList.Add(person);
						new List<Vector2>().Add(person.curMatrix);
						person.walkTheWays.Add(person.curMatrix);
						person.walkTheWaysFx.Add(gameObject2);
						FloorList.Find((FloorController c) => c.matrix == person.curMatrix).isWalked = true;
					}
				}
			}
		}

		public void ClearMap()
		{
			isRun = false;
			foreach (PersonController person in personList)
			{
				person.walkTheWays.Clear();
				person.walkTheWaysFx.Clear();
			}
			personList.Clear();
			foreach (Transform item in floorParent)
			{
				UnityEngine.Object.Destroy(item.gameObject);
			}
			foreach (Transform item2 in wallParent)
			{
				UnityEngine.Object.Destroy(item2.gameObject);
			}
			foreach (Transform item3 in personParent)
			{
				UnityEngine.Object.Destroy(item3.gameObject);
			}
			personController = null;
		}

		public void SelectCat(Transform cat)
		{
			if (isRun)
			{
				return;
			}
			audioSource.clip = audioClips[1];
			audioSource.Play();
			foreach (PersonController person in personList)
			{
				person.Selected(isselect: false);
			}
			personController = cat.GetComponent<PersonController>();
			personController.Selected(isselect: true);
		}

		public void PassTheMap()
		{
			float item = (float)Math.Round((float)CheckpointManager.CurFillMap.LimitTime / challengeTimer, 2);
			CheckpointManager.efficiency.Add(item);
			CheckpointManager.allPass++;
			CheckpointManager.AddScore(CheckpointManager.GetScore);
			UIController.Instance.PlayAudioSound(2);
			CheckpointManager.AddStrength(CheckpointManager.CurFillLevel.UpshiftGrade);
		}

		public void ResStartMap()
		{
			ClearMap();
			CreateMap(CheckpointManager.curMapID);
		}

		public void Move(Vector3 pos)
		{
			Vector2 matrix = personController.curMatrix;
			if (pos == Vector3.left)
			{
				matrix.x -= 1f;
			}
			else if (pos == Vector3.right)
			{
				matrix.x += 1f;
			}
			else if (pos == Vector3.forward)
			{
				matrix.y -= 1f;
			}
			else if (pos == Vector3.back)
			{
				matrix.y += 1f;
			}
			if (matrix.x < 0f || matrix.x > (float)(detail.column - 1) || matrix.y < 0f || matrix.y > (float)(detail.row - 1) || FindPerfectFillItem((int)matrix.y, (int)matrix.x).floorType == FloorType.None)
			{
				return;
			}
			FloorController controller = null;
			foreach (Transform item in floorParent)
			{
				controller = item.GetComponent<FloorController>();
				if (controller.matrix == matrix)
				{
					break;
				}
			}
			if (controller == null || AdjoinIsWall(personController.curMatrix, matrix) || OtherIsWalked(personController, matrix))
			{
				return;
			}
			if (SelfIsWalked(personController, matrix))
			{
				if (!(personController.walkTheWays[personController.walkTheWays.Count - 2] == matrix))
				{
					return;
				}
				isRun = true;
				audioSource.clip = audioClips[0];
				audioSource.Play();
				CheckpointManager.totalMoveNum++;
				personController.Move(controller.transform.position, delegate
				{
					FloorList.Find((FloorController x) => x.matrix == personController.curMatrix).isWalked = false;
					personController.walkTheWays.RemoveAt(personController.walkTheWays.Count - 1);
					UnityEngine.Object.Destroy(personController.walkTheWaysFx[personController.walkTheWaysFx.Count - 1]);
					personController.walkTheWaysFx.RemoveAt(personController.walkTheWaysFx.Count - 1);
					personController.curMatrix = matrix;
					personController.StopMove();
					isRun = false;
					if (AllIsWalked())
					{
						PassTheGame();
					}
				});
				return;
			}
			isRun = true;
			audioSource.clip = audioClips[0];
			audioSource.Play();
			CheckpointManager.totalMoveNum++;
			personController.Move(controller.transform.position, delegate
			{
				GameObject gameObject = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("PerfectFillPrefabs/FX_" + personController.personType), personParent.transform);
				gameObject.transform.localPosition = new Vector3(controller.transform.localPosition.x, 0f, controller.transform.localPosition.z);
				personController.walkTheWays.Add(matrix);
				personController.walkTheWaysFx.Add(gameObject);
				personController.curMatrix = matrix;
				personController.StopMove();
				FloorList.Find((FloorController x) => x.matrix == matrix).isWalked = true;
				isRun = false;
				if (AllIsWalked())
				{
					PassTheGame();
				}
			});
		}

		private void PassTheGame()
		{
			UIController.Instance.IsStartTime(isStart: false);
			PlayerController.Instance.DelayHander(1f, delegate
			{
				PassTheMap();
				ClearMap();
				CreateMapToCheck();
			});
		}

		private bool OtherIsWalked(PersonController person, Vector2 matrix)
		{
			foreach (PersonController person2 in PersonList)
			{
				if (person2 != person && person2.walkTheWays.Contains(matrix))
				{
					return true;
				}
			}
			return false;
		}

		private bool SelfIsWalked(PersonController person, Vector2 matrix)
		{
			if (person.walkTheWays.Contains(matrix))
			{
				return true;
			}
			return false;
		}

		private bool AdjoinIsWall(Vector2 from, Vector2 to)
		{
			Vector3 vector = ((from.x - to.x > 0f) ? new Vector3(from.x, from.y, 0f) : ((from.x - to.x < 0f) ? new Vector3(to.x, to.y, 0f) : ((!(from.y - to.y < 0f)) ? new Vector3(from.x, from.y, 1f) : new Vector3(to.x, to.y, 1f))));
			foreach (Transform item in wallParent)
			{
				if (item.GetComponent<WallController>().matrix == vector)
				{
					Controller.UPvr_VibrateNeo2Controller(0.5f, 50, Pvr_ControllerManager.controllerlink.mainHandID);
					return true;
				}
			}
			return false;
		}

		private bool AllIsWalked()
		{
			if (FloorList.FindAll((FloorController x) => !x.isWalked).Count > 0)
			{
				return false;
			}
			return true;
		}

		private PerfectFillItem FindPerfectFillItem(int row, int column)
		{
			int num = row * detail.column + column;
			for (int i = 0; i < detail.bombDisposalItems.Count; i++)
			{
				if (i == num)
				{
					return detail.bombDisposalItems[num];
				}
			}
			return null;
		}

		private bool CheckAngle(Vector2 normal, Vector2 vector)
		{
			if (Vector2.Angle(normal, vector) < 45f)
			{
				return true;
			}
			return false;
		}
	}
	public class UIController : MonoBehaviour
	{
		public static UIController Instance;

		public GameObject StaticCanvas;

		[Header("开始界面")]
		public GameObject StartGamePanel;

		public ToggleGroup toggleGroup;

		public Button startGameBtn;

		public Button settingsBtn;

		public Button tipsBtn;

		public Button exitBtn;

		public AudioSource bgAudioSource;

		[Header("游戏界面")]
		public GameObject ScorePanel;

		public Text CurScoreTxt;

		public Text LevelTxt;

		public Text TotalTimeTxt;

		public Text ChanglleTimeTxt;

		[Header("结算界面")]
		public GameObject PassAllCheckpointPanel;

		public TextMeshProUGUI ScoreTxt;

		public Text TrainingDurationTxt;

		public Text InitChallengeLevelTxt;

		public Text MaxChallengeLevelTxt;

		public Text MinChallengeLevelTxt;

		public Text AllPassTxt;

		public Text TimeOutNumTxt;

		public Text AverageMoveTimeTxt;

		public Text TotalMoveNumTxt;

		public Button passAllReturnBtn;

		[Header("暂停界面")]
		public GameObject SuspendPanel;

		public Button continueBtn;

		public Button resStartBtn;

		public Button suspendReturnBtn;

		[Header("退出提示界面")]
		public GameObject ExitTipPanel;

		public Button defineBtn;

		public Button cancelBtn;

		public AudioSource audioSource;

		public AudioClip[] audioClips;

		public bool isStartTime;

		private float surplusGameDuration;

		private void Awake()
		{
			Instance = this;
		}

		private void Start()
		{
			ScorePanel.SetActive(value: false);
			PassAllCheckpointPanel.SetActive(value: false);
			startGameBtn.onClick.AddListener(StartGameBtnHander);
			exitBtn.onClick.AddListener(ExitBtnHander);
			passAllReturnBtn.onClick.AddListener(PassAllBtnHander);
			continueBtn.onClick.AddListener(ContinueBtnBtnHander);
			resStartBtn.onClick.AddListener(ResStartBtnHander);
			suspendReturnBtn.onClick.AddListener(SuspendReturnStartBtnHander);
			defineBtn.onClick.AddListener(DefineBtnHander);
			cancelBtn.onClick.AddListener(CancelBtnHander);
			for (int i = 0; i < toggleGroup.transform.childCount; i++)
			{
				int index = i;
				Toggle component = toggleGroup.transform.GetChild(i).GetComponent<Toggle>();
				component.onValueChanged.AddListener(delegate(bool value)
				{
					if (value)
					{
						LoadManager.LevelID = index;
					}
				});
				if (LoadManager.LevelID == index)
				{
					component.isOn = true;
				}
			}
			PlayerController.Instance.InitData();
			if (LoadManager.IsLocalOperate)
			{
				StartGamePanel.SetActive(value: true);
				return;
			}
			StartGamePanel.SetActive(value: false);
			StartGameBtnHander(LoadManager.course);
		}

		private void Update()
		{
			if (CheckpointManager.IsStartGame)
			{
				surplusGameDuration -= Time.deltaTime;
				TotalTimeTxt.text = LoadManager.TimeConversion((int)surplusGameDuration);
				if (surplusGameDuration <= 0f)
				{
					CheckpointManager.OverTheGame();
				}
			}
			if (IsCanSuspend() && Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.APP))
			{
				IsStartTime(isStart: false);
				StaticCanvas.SetActive(value: true);
				SuspendPanel.SetActive(value: true);
				Time.timeScale = 0f;
			}
		}

		public void StartGame()
		{
			StaticCanvas.SetActive(value: false);
			ScorePanel.SetActive(value: true);
			surplusGameDuration = CheckpointManager.gameDuration - CheckpointManager.gameDurationed;
			CurScoreTxt.text = CheckpointManager.curScore.ToString();
			LevelTxt.text = CheckpointManager.GetCurLevel;
			TotalTimeTxt.text = LoadManager.TimeConversion((int)surplusGameDuration);
			ChanglleTimeTxt.text = CheckpointManager.CurFillMap.LimitTime.ToString();
		}

		public void IsStartTime(bool isStart = true)
		{
			isStartTime = isStart;
		}

		public int GetUseDuration(bool isComplete = false)
		{
			float num = CheckpointManager.gameDuration - surplusGameDuration;
			num = (isComplete ? CheckpointManager.gameDuration : num);
			return (int)num;
		}

		public void OverTheGame()
		{
			IsStartTime(isStart: false);
			PlayAudioSound(4);
			StaticCanvas.SetActive(value: true);
			ScorePanel.SetActive(value: false);
			PassAllCheckpointPanel.SetActive(value: true);
			ScoreTxt.text = CheckpointManager.curScore.ToString();
			TrainingDurationTxt.text = LoadManager.TimeConversion((int)CheckpointManager.gameDuration);
			InitChallengeLevelTxt.text = CheckpointManager.GetInitChallengeLevel();
			MaxChallengeLevelTxt.text = CheckpointManager.GetMaxChallengeLevel();
			MinChallengeLevelTxt.text = CheckpointManager.GetMinChallengeLevel();
			AllPassTxt.text = CheckpointManager.allPass.ToString();
			TimeOutNumTxt.text = CheckpointManager.timeOutNum.ToString();
			AverageMoveTimeTxt.text = ((CheckpointManager.totalMoveNum == 0) ? (CheckpointManager.gameDuration + "秒") : (Math.Round(CheckpointManager.gameDuration / (float)CheckpointManager.totalMoveNum, 2) + "秒"));
			TotalMoveNumTxt.text = CheckpointManager.totalMoveNum.ToString();
		}

		public void PlayAudioSound(int index)
		{
			if (audioSource.isPlaying)
			{
				audioSource.Stop();
			}
			audioSource.clip = audioClips[index];
			audioSource.Play();
		}

		public void CheckBattery(Action continueAction)
		{
			if (PlayerController.Instance.batteryTipController.CheckBattery(continueAction))
			{
				SuspendGame(suspend: true);
			}
		}

		public void SuspendGame(bool suspend)
		{
			IsStartTime(!suspend);
			StaticCanvas.SetActive(suspend);
			Time.timeScale = ((!suspend) ? 1 : 0);
		}

		private void StartGameBtnHander()
		{
			StartGameBtnHander(null);
		}

		private void StartGameBtnHander(CourseDetail.Data data)
		{
			StartGamePanel.SetActive(value: false);
			bgAudioSource.Play();
			CheckpointManager.StartTheLevel(data);
		}

		private void ExitBtnHander()
		{
			ScenesHelper.LoadScene(ScenesHelper.WeiAiZhiCenterScene);
		}

		private void PassAllBtnHander()
		{
			if (LoadManager.IsLocalOperate)
			{
				StartGamePanel.SetActive(value: true);
				PassAllCheckpointPanel.SetActive(value: false);
			}
			else
			{
				LoadManager.SubmitEndRecord(isComplete: true, isLogout: false, GetUseDuration(isComplete: true), CheckpointManager.curScore, J_LitJson.JsonMapper.ToJson(CheckpointManager.GetGameRecord()));
			}
		}

		private void SuspendReturnStartBtnHander()
		{
			if (LoadManager.IsLocalOperate)
			{
				CheckpointManager.ResetTheGame();
				StaticCanvas.SetActive(value: true);
				StartGamePanel.SetActive(value: true);
				SuspendPanel.SetActive(value: false);
				ScorePanel.SetActive(value: false);
				Time.timeScale = 1f;
			}
			else
			{
				ExitTipPanel.SetActive(value: true);
			}
		}

		private void ResStartBtnHander()
		{
			IsStartTime();
			StaticCanvas.SetActive(value: false);
			SuspendPanel.SetActive(value: false);
			Time.timeScale = 1f;
			RoomRootController.Instance.ResStartMap();
		}

		private void ContinueBtnBtnHander()
		{
			IsStartTime();
			StaticCanvas.SetActive(value: false);
			SuspendPanel.SetActive(value: false);
			Time.timeScale = 1f;
		}

		private void DefineBtnHander()
		{
			Time.timeScale = 1f;
			LoadManager.SubmitEndRecord(isComplete: false, isLogout: false, GetUseDuration(), CheckpointManager.curScore, J_LitJson.JsonMapper.ToJson(CheckpointManager.GetGameRecord()));
		}

		private void CancelBtnHander()
		{
			ExitTipPanel.SetActive(value: false);
		}

		private bool IsCanSuspend()
		{
			if (PassAllCheckpointPanel.activeSelf)
			{
				return false;
			}
			if (CheckpointManager.IsStartGame)
			{
				return true;
			}
			return false;
		}
	}
	public class WallController : MonoBehaviour
	{
		public Vector3 matrix;

		private void Start()
		{
		}

		private void Update()
		{
		}
	}
}
namespace LetterShotHand
{
	public class LevelData
	{
		public int Levelid;

		public string LevelName;

		public List<int> CheckpointArray;

		public int NextLevelid;
	}
	public class CheckpointData
	{
		public int CheckpointID;

		public float ChallengeTime;

		public int IsTips;

		public int RandomKeyPostion;

		public int IsReverse;

		public List<int> Library;

		public int AgainNeedTime;

		public int TimeThreshold;

		public int TimeScore;

		public int MissLimitTimes;

		public int NoMissScore;
	}
	public class WordDBData
	{
		public int WordId;

		public string Eng;

		public string Chs;

		public int Len;
	}
	public class ShotHandLevel
	{
		public int LevelID;

		public string LevelName;

		public List<string> SubjectRange;

		public int InitialNum;

		public float LimitTime;

		public int BaseScore;

		public int ChallengeNum;

		public int IsWordsAdd;

		public int IsReverse;

		public int IsInterfere;

		public int UpshiftRequire;

		public int UpshiftGrade;

		public int DownshiftRequire;

		public int DownshiftGrade;
	}
	public class ShotHandStrength
	{
		public int StrengthID;

		public int StrengthGrade;

		public float ScoreAddition;

		public float WordsAddition;

		public float InterfereNum;
	}
	public class CheckpointManager
	{
		public static Dictionary<int, ShotHandLevel> LevelDataDic = new Dictionary<int, ShotHandLevel>();

		public static Dictionary<int, ShotHandStrength> StrengthDataDic = new Dictionary<int, ShotHandStrength>();

		public static List<WordDBData> WordDBDatas = new List<WordDBData>();

		public static List<GameRecordData> gameRecordDatas = new List<GameRecordData>();

		public static int curLevelID;

		public static int curStrengthID;

		public static float gameDuration;

		public static float gameDurationed;

		public static int curScore;

		public static string startLevel;

		public static string minLevel;

		public static string maxLevel;

		public static int allPass;

		public static int perfectNum;

		public static int continuateMaxNum;

		public static int timeOutNum;

		public static int hitNum;

		public static int passNumLevel;

		public static int allNumLevel;

		public static int passLetterLevel;

		public static int allLetterLevel;

		public static int passGraphsLevel;

		public static int allGraphsLevel;

		public static bool IsStartGame = false;

		public static bool IsPlayGame = false;

		public static bool IsShowAgain = false;

		public static int IsReverse = 0;

		private static string curLevelType;

		private static int continuateNum = 0;

		private static int curErrorNum;

		private static int curHitIndex;

		private static string curRightKeys;

		private static bool curIsRightSubject = true;

		private static List<string> curMemoryNums = new List<string>();

		private static List<bool> curSubjectRight = new List<bool>();

		private static char[] number_Chars = new char[10] { '1', '2', '3', '4', '5', '6', '7', '8', '9', '0' };

		private static char[] letter_Chars = new char[26]
		{
			'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J',
			'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T',
			'U', 'V', 'W', 'X', 'Y', 'Z'
		};

		private static char[] pattern_Chars = new char[10] { '★', '✿', '◀', '☎', '●', '♣', '♦', '♬', '■', '♥' };

		private static int lastRandom = 1000;

		public static ShotHandLevel CurShotHandLevel => LevelDataDic[curLevelID];

		public static ShotHandStrength CurShotHandStrength => StrengthDataDic[curStrengthID];

		public static int GetScore => (int)((float)CurShotHandLevel.BaseScore * (1f + CurShotHandStrength.ScoreAddition));

		public static float GetWordsNum
		{
			get
			{
				if (CurShotHandLevel.IsWordsAdd != 0)
				{
					return (float)CurShotHandLevel.InitialNum + CurShotHandStrength.WordsAddition;
				}
				return CurShotHandLevel.InitialNum;
			}
		}

		public static float GetInterfereNum
		{
			get
			{
				if (CurShotHandLevel.IsInterfere != 0)
				{
					return CurShotHandStrength.InterfereNum;
				}
				return 0f;
			}
		}

		public static string GetCurLevel => LevelDataDic[curLevelID].LevelName + "-" + StrengthDataDic[curStrengthID].StrengthGrade;

		public static void StartTheLevel(CourseDetail.Data data)
		{
			if (data != null)
			{
				if (data.game_data == null)
				{
					string text = data.level + "-" + data.strength;
					InitData(data.level, data.strength, data.play_time, data.already_play_time, data.point, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, text, text, text);
				}
				else
				{
					GameRecordData gameRecordData = J_LitJson.JsonMapper.ToObject<GameRecordData>(data.game_data);
					InitData(data.level, data.strength, data.play_time, data.already_play_time, data.point, gameRecordData.AllPass, gameRecordData.PerfectNum, gameRecordData.ContinuateMaxNum, gameRecordData.TimeOutNum, gameRecordData.HitNum, gameRecordData.PassNumLevel, gameRecordData.AllNumLevel, gameRecordData.PassLetterLevel, gameRecordData.AllLetterLevel, gameRecordData.PassGraphsLevel, gameRecordData.AllGraphsLevel, gameRecordData.InitLevel, gameRecordData.MaxLevel, gameRecordData.MinLevel);
				}
			}
			else
			{
				string text2 = LoadManager.LevelID + "-" + LoadManager.StrengthID;
				InitData(LoadManager.LevelID, LoadManager.StrengthID, LoadManager.Duration, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, text2, text2, text2);
			}
			IsStartGame = true;
			UIController.Instance.StartGame();
			PlayerController.Instance.IsShowVivePointers(isShow: false);
			StartTheCheckpoint();
		}

		private static void InitData(int level, int strength, int duration, int durationed, int score, int allpass, int perfect, int continuate, int timeout, int hitnum, int passnum, int allnum, int passletter, int allletter, int passgraph, int allgraph, string start, string max, string min)
		{
			curLevelID = level;
			curStrengthID = strength;
			gameDuration = duration;
			gameDurationed = durationed;
			curScore = score;
			allPass = allpass;
			perfectNum = perfect;
			continuateMaxNum = continuate;
			timeOutNum = timeout;
			hitNum = hitnum;
			passNumLevel = passnum;
			allNumLevel = allnum;
			passLetterLevel = passletter;
			allLetterLevel = allletter;
			passGraphsLevel = passgraph;
			allGraphsLevel = allgraph;
			startLevel = start;
			maxLevel = max;
			minLevel = min;
		}

		public static void StartTheCheckpoint()
		{
			curErrorNum = 0;
			SetChanglleNum(curErrorNum);
			curMemoryNums.Clear();
			curSubjectRight.Clear();
			List<char> list = new List<char>();
			lastRandom = MyMath.RandomRange(0, CurShotHandLevel.SubjectRange.Count, lastRandom);
			curLevelType = CurShotHandLevel.SubjectRange[lastRandom];
			switch (curLevelType)
			{
			case "number":
				allNumLevel++;
				list.AddRange(number_Chars.ToList());
				break;
			case "letter":
				allLetterLevel++;
				list.AddRange(letter_Chars.ToList());
				break;
			case "graph":
				allGraphsLevel++;
				list.AddRange(pattern_Chars.ToList());
				break;
			}
			for (int i = 0; (float)i < GetWordsNum; i++)
			{
				curMemoryNums.Add(MyMath.Random_char(list, 1, Sleep: true));
			}
			IsReverse = ((CurShotHandLevel.IsReverse != 0) ? UnityEngine.Random.Range(0, 2) : 0);
			TipsUIController.Instance.Countdown(delegate
			{
				if (IsStartGame)
				{
					LetterKeyboardController.Instance.AutoPlay(curMemoryNums, delegate
					{
						TipsUIController.Instance.ShowStartTips(curMemoryNums, IsReverse, delegate
						{
							IsPlayGame = true;
							PlayerController.Instance.IsShowVivePointers(isShow: true);
							TipsUIController.Instance.HideKeys();
							UIController.Instance.IsStartTime();
							curHitIndex = 0;
							curRightKeys = curMemoryNums[curHitIndex];
						});
					});
				}
			});
		}

		public static void HitInputAgain()
		{
			TipsUIController.Instance.HideKeys();
			curHitIndex = 0;
			curRightKeys = curMemoryNums[curHitIndex];
			curSubjectRight.Clear();
		}

		public static void HitDelete()
		{
			if (curHitIndex > 0)
			{
				TipsUIController.Instance.ReduceKeys();
				curHitIndex--;
				curRightKeys = curMemoryNums[curHitIndex];
				curSubjectRight.RemoveAt(curSubjectRight.Count - 1);
			}
		}

		public static void HitShowAgain()
		{
			IsShowAgain = true;
			HitInputAgain();
			LetterKeyboardController.Instance.AgainAutoPlay(delegate
			{
				IsShowAgain = false;
				TipsUIController.Instance.HideKeys();
				curHitIndex = 0;
				curRightKeys = curMemoryNums[curHitIndex];
			});
		}

		public static void StopShowAgain()
		{
			LetterKeyboardController.Instance.StopAutoPlay();
			IsShowAgain = false;
			if (CurShotHandLevel.IsReverse == 1)
			{
				curMemoryNums.Reverse();
			}
			TipsUIController.Instance.HideKeys();
			curHitIndex = 0;
			curRightKeys = curMemoryNums[curHitIndex];
		}

		public static void HitKeys(string keys)
		{
			hitNum++;
			curHitIndex++;
			if (keys == curRightKeys)
			{
				curSubjectRight.Add(item: true);
				TipsUIController.Instance.HitRight(keys);
				UnityEngine.Debug.Log("敲对: " + keys + " " + curRightKeys);
			}
			else
			{
				curSubjectRight.Add(item: false);
				TipsUIController.Instance.HitError(keys);
				UnityEngine.Debug.LogError("敲错: " + keys + " " + curRightKeys);
			}
			if (curMemoryNums.Count - 1 >= curHitIndex)
			{
				curRightKeys = curMemoryNums[curHitIndex];
			}
			if (curHitIndex < curMemoryNums.Count)
			{
				return;
			}
			UIController.Instance.IsStartTime(isStart: false);
			IsPlayGame = false;
			PlayerController.Instance.IsShowVivePointers(isShow: false);
			LetterKeyboardController.Instance.ResetKeysImage();
			curIsRightSubject = true;
			foreach (bool item in curSubjectRight)
			{
				if (!item)
				{
					curIsRightSubject = false;
				}
			}
			if (curIsRightSubject)
			{
				allPass++;
				int num = ((curErrorNum != 0) ? 1 : 2);
				if (curErrorNum == 0)
				{
					perfectNum++;
					continuateNum++;
					if (continuateNum > continuateMaxNum)
					{
						continuateMaxNum = continuateNum;
					}
				}
				else
				{
					continuateNum = 0;
				}
				AddScore(GetScore * num);
				int upshift = CurShotHandLevel.UpshiftGrade * num;
				switch (curLevelType)
				{
				case "number":
					passNumLevel++;
					break;
				case "letter":
					passLetterLevel++;
					break;
				case "graph":
					passGraphsLevel++;
					break;
				}
				AddStrength(upshift);
				UIController.Instance.PlayAudioSound((num == 1) ? 2 : 3);
				TipsUIController.Instance.ShowResultTips(result: true, delegate
				{
					PlayerController.Instance.DelayHander(1f, StartTheNextSubject);
				});
				return;
			}
			UIController.Instance.PlayAudioSound(1);
			continuateNum = 0;
			curErrorNum++;
			SetChanglleNum(curErrorNum);
			UIController.Instance.ErrorAnswer();
			TipsUIController.Instance.ShowResultTips(result: false, delegate
			{
				if (curErrorNum >= CurShotHandLevel.ChallengeNum)
				{
					TheNextSubject();
				}
				else
				{
					PlayerController.Instance.DelayHander(0.2f, AgainTheSubject);
				}
			});
		}

		public static void OverTheGame()
		{
			IsPlayGame = false;
			IsStartGame = false;
			LetterKeyboardController.Instance.Clear();
			PlayerController.Instance.StopAllCoroutines();
			UIController.Instance.OverTheGame();
		}

		public static void ResetTheGame()
		{
			IsPlayGame = false;
			IsStartGame = false;
			LetterKeyboardController.Instance.Clear();
			PlayerController.Instance.StopAllCoroutines();
		}

		public static void TheNextSubject()
		{
			if (IsShowAgain)
			{
				StopShowAgain();
			}
			LetterKeyboardController.Instance.ErrorShow(curMemoryNums, delegate
			{
				continuateNum = 0;
				ReduceStrength(CurShotHandLevel.DownshiftGrade);
				PlayerController.Instance.DelayHander(1f, StartTheNextSubject);
			});
		}

		private static void StartTheNextSubject()
		{
			UIController.Instance.CheckBattery(delegate
			{
				UIController.Instance.SuspendGame(suspend: false);
				curErrorNum = 0;
				SetChanglleNum(curErrorNum);
				curMemoryNums.Clear();
				curSubjectRight.Clear();
				IsPlayGame = false;
				List<char> list = new List<char>();
				lastRandom = MyMath.RandomRange(0, CurShotHandLevel.SubjectRange.Count, lastRandom);
				curLevelType = CurShotHandLevel.SubjectRange[lastRandom];
				switch (curLevelType)
				{
				case "number":
					allNumLevel++;
					list.AddRange(number_Chars.ToList());
					break;
				case "letter":
					allLetterLevel++;
					list.AddRange(letter_Chars.ToList());
					break;
				case "graph":
					allGraphsLevel++;
					list.AddRange(pattern_Chars.ToList());
					break;
				}
				for (int i = 0; (float)i < GetWordsNum; i++)
				{
					curMemoryNums.Add(MyMath.Random_char(list, 1, Sleep: true));
				}
				IsReverse = ((CurShotHandLevel.IsReverse != 0) ? UnityEngine.Random.Range(0, 2) : 0);
				PlayerController.Instance.IsShowVivePointers(isShow: false);
				TipsUIController.Instance.NotCountdown(delegate
				{
					if (IsStartGame)
					{
						LetterKeyboardController.Instance.AutoPlay(curMemoryNums, delegate
						{
							TipsUIController.Instance.ShowStartTips(curMemoryNums, IsReverse, delegate
							{
								IsPlayGame = true;
								PlayerController.Instance.IsShowVivePointers(isShow: true);
								TipsUIController.Instance.HideKeys();
								UIController.Instance.IsStartTime();
								curHitIndex = 0;
								curRightKeys = curMemoryNums[curHitIndex];
							});
						});
					}
				});
			});
		}

		private static void AgainTheSubject()
		{
			IsPlayGame = false;
			TipsUIController.Instance.NotCountdown(delegate
			{
				if (IsStartGame)
				{
					PlayerController.Instance.DelayHander(0.5f, delegate
					{
						IsPlayGame = true;
						curSubjectRight.Clear();
						PlayerController.Instance.IsShowVivePointers(isShow: true);
						TipsUIController.Instance.HideKeys();
						UIController.Instance.IsStartTime();
						curHitIndex = 0;
						curRightKeys = curMemoryNums[curHitIndex];
					});
				}
			});
		}

		public static string GetInitChallengeLevel()
		{
			string[] array = startLevel.Split('-');
			return LevelDataDic[int.Parse(array[0])].LevelName + "-" + StrengthDataDic[int.Parse(array[1])].StrengthGrade;
		}

		public static string GetMaxChallengeLevel()
		{
			string[] array = maxLevel.Split('-');
			return LevelDataDic[int.Parse(array[0])].LevelName + "-" + StrengthDataDic[int.Parse(array[1])].StrengthGrade;
		}

		public static string GetMinChallengeLevel()
		{
			string[] array = minLevel.Split('-');
			return LevelDataDic[int.Parse(array[0])].LevelName + "-" + StrengthDataDic[int.Parse(array[1])].StrengthGrade;
		}

		public static void AddStrength(int upshift)
		{
			curStrengthID += upshift;
			if (curStrengthID > 9)
			{
				if (LoadManager.IsLocalOperate && curLevelID >= LoadManager.MaxLevelID)
				{
					curStrengthID = 9;
				}
				else if (curLevelID >= LevelDataDic.Count - 1)
				{
					curStrengthID = 9;
				}
				else
				{
					curStrengthID -= 10;
					curLevelID++;
				}
			}
			SetMaxLevel();
			UIController.Instance.LevelTxt.text = GetCurLevel;
			LoadManager.SubmitLevelRecord(curLevelID, curStrengthID, UIController.Instance.GetUseDuration(), curScore, J_LitJson.JsonMapper.ToJson(GetGameRecord()));
		}

		public static void ReduceStrength(int downshift)
		{
			curStrengthID -= downshift;
			if (curStrengthID < 0)
			{
				if (curLevelID <= 0)
				{
					curStrengthID = 0;
				}
				else
				{
					curStrengthID += 10;
					curLevelID--;
				}
			}
			SetMinLevel();
			UIController.Instance.LevelTxt.text = GetCurLevel;
			LoadManager.SubmitLevelRecord(curLevelID, curStrengthID, UIController.Instance.GetUseDuration(), curScore, J_LitJson.JsonMapper.ToJson(GetGameRecord()));
		}

		private static void SetMaxLevel()
		{
			string[] array = maxLevel.Split('-');
			int num = int.Parse(array[0]);
			int num2 = int.Parse(array[1]);
			if (curLevelID == num)
			{
				if (curStrengthID > num2)
				{
					maxLevel = curLevelID + "-" + curStrengthID;
				}
			}
			else if (curLevelID > num)
			{
				maxLevel = curLevelID + "-" + curStrengthID;
			}
		}

		private static void SetMinLevel()
		{
			string[] array = minLevel.Split('-');
			int num = int.Parse(array[0]);
			int num2 = int.Parse(array[1]);
			if (curLevelID == num)
			{
				if (curStrengthID < num2)
				{
					minLevel = curLevelID + "-" + curStrengthID;
				}
			}
			else if (curLevelID < num)
			{
				minLevel = curLevelID + "-" + curStrengthID;
			}
		}

		public static void AddScore(int score)
		{
			curScore += score;
			UIController.Instance.CurScoreTxt.text = curScore.ToString();
		}

		public static void SetChanglleNum(int missMun)
		{
			int num = CurShotHandLevel.ChallengeNum - missMun;
			UIController.Instance.ChanglleNumTxt.text = ((num == 0) ? 1 : num).ToString();
		}

		public static void SetChanglleTime(float catchTimer)
		{
			UIController.Instance.ChanglleTimeTxt.text = Mathf.Ceil(catchTimer).ToString();
		}

		public static GameRecordData GetGameRecord()
		{
			return new GameRecordData
			{
				InitLevel = minLevel,
				MaxLevel = maxLevel,
				MinLevel = minLevel,
				AllPass = allPass,
				PerfectNum = perfectNum,
				ContinuateMaxNum = continuateMaxNum,
				TimeOutNum = timeOutNum,
				HitNum = hitNum,
				PassNumLevel = passNumLevel,
				AllNumLevel = allNumLevel,
				PassLetterLevel = passLetterLevel,
				AllLetterLevel = allLetterLevel,
				PassGraphsLevel = passGraphsLevel,
				AllGraphsLevel = allGraphsLevel
			};
		}
	}
	public class GameRecordData
	{
		public string InitLevel;

		public string MaxLevel;

		public string MinLevel;

		public int AllPass;

		public int PerfectNum;

		public int ContinuateMaxNum;

		public int TimeOutNum;

		public int HitNum;

		public int PassNumLevel;

		public int AllNumLevel;

		public int PassLetterLevel;

		public int AllLetterLevel;

		public int PassGraphsLevel;

		public int AllGraphsLevel;
	}
	public class KeysController : MonoBehaviour, IPointerEnterHandler, IEventSystemHandler, IPointerExitHandler
	{
		public Sprite normalSprite;

		public Sprite highlightSprite;

		private Button keysBtn;

		private Image keysImage;

		private AudioSource audioSource;

		private Vector3 initialPos;

		private void Start()
		{
			initialPos = base.transform.localPosition;
			keysBtn = GetComponent<Button>();
			keysImage = GetComponent<Image>();
			audioSource = GetComponent<AudioSource>();
			keysBtn.onClick.AddListener(KeysBtnHander);
		}

		private void Update()
		{
		}

		public void ResetPostion()
		{
			if (!(initialPos == base.transform.localPosition))
			{
				base.transform.DOLocalMove(initialPos, 0.25f);
			}
		}

		public void MovePostion(Vector3 localPos)
		{
			if (!(localPos == base.transform.localPosition))
			{
				base.transform.DOLocalMove(localPos, 0.25f);
			}
		}

		public void PlayKeysAudio()
		{
			audioSource.Play();
			base.transform.DOLocalMoveZ(20f, 0.25f);
			PlayerController.Instance.DelayHander(0.25f, delegate
			{
				base.transform.DOLocalMoveZ(initialPos.z, 0.25f);
			});
		}

		private void KeysBtnHander()
		{
			if (CheckpointManager.IsPlayGame)
			{
				if (CheckpointManager.IsShowAgain)
				{
					CheckpointManager.StopShowAgain();
				}
				audioSource.Play();
				base.transform.DOLocalMoveZ(20f, 0.25f);
				PlayerController.Instance.DelayHander(0.25f, delegate
				{
					base.transform.DOLocalMoveZ(initialPos.z, 0.25f);
				});
				CheckpointManager.HitKeys(base.transform.name.Replace("Keys_", ""));
			}
		}

		public void OnPointerEnter(PointerEventData eventData)
		{
			keysImage.sprite = highlightSprite;
		}

		public void OnPointerExit(PointerEventData eventData)
		{
			keysImage.sprite = normalSprite;
		}

		public void ResetKeysImage()
		{
			keysImage.sprite = normalSprite;
		}
	}
	public class KeysHighlight : MonoBehaviour, IPointerEnterHandler, IEventSystemHandler, IPointerExitHandler
	{
		public Sprite normalSprite;

		public Sprite highlightSprite;

		private Image keysImage;

		private void Start()
		{
			keysImage = GetComponent<Image>();
		}

		private void Update()
		{
		}

		public void OnPointerEnter(PointerEventData eventData)
		{
			keysImage.sprite = highlightSprite;
		}

		public void OnPointerExit(PointerEventData eventData)
		{
			keysImage.sprite = normalSprite;
		}
	}
	public class LetterKeyboardController : MonoBehaviour
	{
		public static LetterKeyboardController Instance;

		public List<KeysController> randomKeys;

		public float interval = 1f;

		public GameObject hlightTemplate;

		public GameObject hlineTemplate;

		public GameObject lightTemplate;

		public GameObject lineTemplate;

		private Action playEndAction;

		private KeysController[] keysControllers;

		private bool isAutoPlay;

		private float timer;

		private int autoPlayIndex;

		private List<string> curKeys = new List<string>();

		private float challengeTimer;

		private List<KeysController> errorShowKeys;

		private Dictionary<string, GameObject> hlightDic = new Dictionary<string, GameObject>();

		private List<GameObject> hlines = new List<GameObject>();

		private Dictionary<string, GameObject> lightDic = new Dictionary<string, GameObject>();

		private List<GameObject> lines = new List<GameObject>();

		private Action errorShowAction;

		public void Clear()
		{
			isAutoPlay = false;
			timer = interval;
		}

		private void Awake()
		{
			Instance = this;
		}

		private void Start()
		{
		}

		private void Update()
		{
			if (isAutoPlay)
			{
				if (!CheckpointManager.IsStartGame)
				{
					isAutoPlay = false;
					CheckpointManager.OverTheGame();
					return;
				}
				timer -= Time.deltaTime;
				if (timer <= 0f)
				{
					timer = interval;
					autoPlayIndex++;
					if (autoPlayIndex >= curKeys.Count)
					{
						isAutoPlay = false;
						playEndAction?.Invoke();
						return;
					}
					AutoPlay();
				}
			}
			if (!UIController.Instance.isStartTime)
			{
				return;
			}
			challengeTimer -= Time.deltaTime;
			CheckpointManager.SetChanglleTime(challengeTimer);
			if (challengeTimer <= 0f)
			{
				CheckpointManager.IsPlayGame = false;
				UIController.Instance.IsStartTime(isStart: false);
				UIController.Instance.PlayAudioSound(1);
				CheckpointManager.timeOutNum++;
				TipsUIController.Instance.ShowTimeTips(delegate
				{
					CheckpointManager.TheNextSubject();
				});
			}
		}

		public void RandomKeysPostion(int randomKeyPostion)
		{
			List<int> list = new List<int>();
			for (int i = 0; i < randomKeys.Count; i++)
			{
				list.Add(i);
			}
			for (int j = 0; j < randomKeys.Count; j++)
			{
				int index = UnityEngine.Random.Range(0, list.Count);
				if (randomKeyPostion == 1)
				{
					randomKeys[j].MovePostion(randomKeys[list[index]].transform.localPosition);
				}
				else
				{
					randomKeys[j].ResetPostion();
				}
				list.RemoveAt(index);
			}
		}

		public void AutoPlay(List<string> keys, Action action)
		{
			challengeTimer = CheckpointManager.CurShotHandLevel.LimitTime;
			CheckpointManager.SetChanglleTime(challengeTimer);
			playEndAction = action;
			keysControllers = GetComponentsInChildren<KeysController>();
			autoPlayIndex = 0;
			curKeys.Clear();
			foreach (string key in keys)
			{
				curKeys.Add(key);
			}
			for (int i = 0; (float)i < CheckpointManager.GetInterfereNum; i++)
			{
				RandomInsert();
			}
			isAutoPlay = true;
			timer = interval;
			AutoPlay();
		}

		public void AgainAutoPlay(Action action)
		{
			playEndAction = action;
			keysControllers = GetComponentsInChildren<KeysController>();
			autoPlayIndex = 0;
			isAutoPlay = true;
			timer = interval;
			AutoPlay();
		}

		public void StopAutoPlay()
		{
			isAutoPlay = false;
			StopAllCoroutines();
		}

		public void ResetKeysImage()
		{
			KeysController[] array = keysControllers;
			foreach (KeysController keysController in array)
			{
				if (keysController.gameObject.activeSelf)
				{
					keysController.ResetKeysImage();
				}
			}
		}

		public void ErrorShow(List<string> keys, Action action)
		{
			errorShowKeys = new List<KeysController>();
			errorShowAction = action;
			for (int i = 0; i < keys.Count; i++)
			{
				KeysController[] array = keysControllers;
				foreach (KeysController keysController in array)
				{
					if (keysController.name.Replace("Keys_", "").Equals(keys[i]))
					{
						errorShowKeys.Add(keysController);
						break;
					}
				}
			}
			TipsUIController.Instance.HideKeys();
			CreateLight(0);
		}

		private void CreateLight(int index)
		{
			TipsUIController.Instance.AddShowKeys(errorShowKeys[index].name.Replace("Keys_", ""));
			GameObject hlight;
			GameObject light;
			if (FindIsExistKeys(index) && hlightDic.ContainsKey(errorShowKeys[index].name))
			{
				hlight = hlightDic[errorShowKeys[index].name];
				light = lightDic[errorShowKeys[index].name];
				light.SetActive(value: false);
				PlayerController.Instance.DelayHander(0.5f, delegate
				{
					hlight.SetActive(value: false);
				});
			}
			else
			{
				hlight = UnityEngine.Object.Instantiate(hlightTemplate, base.transform);
				light = UnityEngine.Object.Instantiate(lightTemplate, base.transform);
				hlightDic.Add(errorShowKeys[index].name, hlight);
				lightDic.Add(errorShowKeys[index].name, light);
			}
			hlight.SetActive(value: true);
			hlight.transform.localPosition = errorShowKeys[index].transform.localPosition;
			light.transform.SetAsFirstSibling();
			light.transform.localPosition = errorShowKeys[index].transform.localPosition;
			if (errorShowKeys.Count - 1 > index)
			{
				GameObject hline = UnityEngine.Object.Instantiate(hlineTemplate, base.transform);
				hlines.Add(hline);
				hline.SetActive(value: true);
				hline.transform.localPosition = errorShowKeys[index].transform.localPosition;
				float angle = MyMath.DotToAngle(Vector3.right, (errorShowKeys[index + 1].transform.localPosition - errorShowKeys[index].transform.localPosition).normalized, Vector3.forward);
				hline.transform.localEulerAngles = new Vector3(0f, 0f, angle);
				Vector2 size = hline.GetComponent<RectTransform>().sizeDelta;
				size.x = Vector3.Distance(errorShowKeys[index + 1].transform.localPosition, errorShowKeys[index].transform.localPosition);
				hline.GetComponent<RectTransform>().DOSizeDelta(size, 1f);
				PlayerController.Instance.DelayHander(1f, delegate
				{
					GameObject gameObject = UnityEngine.Object.Instantiate(lineTemplate, base.transform);
					lines.Add(gameObject);
					gameObject.SetActive(value: true);
					gameObject.transform.localPosition = errorShowKeys[index].transform.localPosition;
					gameObject.transform.localEulerAngles = new Vector3(0f, 0f, angle);
					gameObject.GetComponent<RectTransform>().sizeDelta = size;
					hlight.SetActive(value: false);
					hline.SetActive(value: false);
					light.SetActive(value: true);
					CreateLight(index + 1);
				});
				return;
			}
			PlayerController.Instance.DelayHander(1f, delegate
			{
				light.SetActive(value: true);
				hlight.SetActive(value: false);
				PlayerController.Instance.DelayHander(0.5f, delegate
				{
					ClearErrorShow();
					errorShowAction?.Invoke();
				});
			});
		}

		private void ClearErrorShow()
		{
			foreach (GameObject value in hlightDic.Values)
			{
				UnityEngine.Object.Destroy(value);
			}
			foreach (GameObject value2 in lightDic.Values)
			{
				UnityEngine.Object.Destroy(value2);
			}
			foreach (GameObject hline in hlines)
			{
				UnityEngine.Object.Destroy(hline);
			}
			foreach (GameObject line in lines)
			{
				UnityEngine.Object.Destroy(line);
			}
			hlightDic.Clear();
			lightDic.Clear();
			hlines.Clear();
			lines.Clear();
		}

		private bool FindIsExistKeys(int index)
		{
			for (int i = 0; i < index; i++)
			{
				if (errorShowKeys[i].name == errorShowKeys[index].name)
				{
					return true;
				}
			}
			return false;
		}

		private void RandomInsert()
		{
			string item = MyMath.Chinese_char(1, Sleep: true);
			int index = UnityEngine.Random.Range(0, curKeys.Count);
			curKeys.Insert(index, item);
		}

		private void AutoPlay()
		{
			bool flag = false;
			KeysController[] array = keysControllers;
			foreach (KeysController keysController in array)
			{
				if (keysController.gameObject.activeSelf && keysController.name.Replace("Keys_", "").Equals(curKeys[autoPlayIndex]))
				{
					flag = true;
					StartCoroutine(PlayKeysAudio(keysController));
				}
			}
			if (!flag)
			{
				StartCoroutine(PlayKeysAudio(curKeys[autoPlayIndex]));
			}
		}

		private IEnumerator PlayKeysAudio(KeysController keys)
		{
			yield return new WaitForSeconds(0.25f);
			keys.PlayKeysAudio();
			TipsUIController.Instance.AddShowKeys(keys.name.Replace("Keys_", ""));
		}

		private IEnumerator PlayKeysAudio(string key)
		{
			yield return new WaitForSeconds(0.25f);
			TipsUIController.Instance.AddShowKeys(key);
		}
	}
	public class PlayerController : MonoBehaviour
	{
		public static PlayerController Instance;

		public Pvr_ControllerModuleInit pvr_ControllerModuleInit;

		public GameObject letterKeyboardObj;

		public BatteryTipController batteryTipController;

		private bool lastVivePointersIsShow;

		private void Awake()
		{
			Instance = this;
		}

		private void Start()
		{
			Time.fixedDeltaTime = 0.02f;
		}

		private void Update()
		{
		}

		public void InitData()
		{
			List<ShotHandLevel> list = CsvMapper.ToObjectList<ShotHandLevel>(LoadManager.CsvRead("ShotHandLevel"));
			CheckpointManager.LevelDataDic.Clear();
			foreach (ShotHandLevel item in list)
			{
				CheckpointManager.LevelDataDic.Add(item.LevelID, item);
			}
			List<ShotHandStrength> list2 = CsvMapper.ToObjectList<ShotHandStrength>(LoadManager.CsvRead("ShotHandStrength"));
			CheckpointManager.StrengthDataDic.Clear();
			foreach (ShotHandStrength item2 in list2)
			{
				CheckpointManager.StrengthDataDic.Add(item2.StrengthID, item2);
			}
		}

		public void IsShowKeyBoard(bool isShow)
		{
			letterKeyboardObj.SetActive(isShow);
		}

		public void IsShowVivePointers(bool isShow)
		{
			lastVivePointersIsShow = pvr_ControllerModuleInit.GetModuleState();
			pvr_ControllerModuleInit.ForceHideOrShow(isShow);
		}

		public void ResetShowVivePointers()
		{
			pvr_ControllerModuleInit.ForceHideOrShow(lastVivePointersIsShow);
		}

		public void DelayHander(float time, Action action)
		{
			StartCoroutine(Wait(time, action));
		}

		private IEnumerator Wait(float time, Action action)
		{
			yield return new WaitForSeconds(time);
			action?.Invoke();
		}
	}
	public class ShowTipsUIController : MonoBehaviour
	{
		public static ShowTipsUIController Instance;

		public GameObject ShowTipsPanel;

		public GameObject letterKeyboard;

		public Text timeTxt;

		public Text tipsTxt;

		public Button continueBtn;

		public Button cancelBtn;

		private Action<bool> resultAction;

		private void Awake()
		{
			Instance = this;
		}

		private void Start()
		{
			continueBtn.onClick.AddListener(ContinueBtnHander);
			cancelBtn.onClick.AddListener(CancelBtnHander);
		}

		private void Update()
		{
		}

		public void ShowTipsUI(float time, Action<bool> action)
		{
			timeTxt.text = time + "秒挑战时间，";
			ShowTipsPanel.SetActive(value: true);
			letterKeyboard.SetActive(value: false);
			resultAction = action;
			UIController.Instance.IsStartTime(isStart: false);
			Time.timeScale = 0f;
			if (UIController.Instance.GetCurRemainingTime() - time <= 0f)
			{
				tipsTxt.gameObject.SetActive(value: true);
				continueBtn.interactable = false;
			}
			else
			{
				tipsTxt.gameObject.SetActive(value: false);
				continueBtn.interactable = true;
			}
		}

		private void ContinueBtnHander()
		{
			Time.timeScale = 1f;
			letterKeyboard.SetActive(value: true);
			ShowTipsPanel.SetActive(value: false);
			resultAction?.Invoke(obj: true);
		}

		private void CancelBtnHander()
		{
			Time.timeScale = 1f;
			letterKeyboard.SetActive(value: true);
			ShowTipsPanel.SetActive(value: false);
			resultAction?.Invoke(obj: false);
		}
	}
	public class TipsUIController : MonoBehaviour
	{
		public static TipsUIController Instance;

		public Text memoryNumText;

		public Text orderText;

		public Image orderImage;

		public Text tipsText;

		public Sprite[] orderSprite;

		public Color[] orderColor;

		public string[] orderWord = new string[2] { "正向记忆", "反向记忆" };

		public Button showAgainBtn;

		public Button showInputBtn;

		public Button deleteBtn;

		public AudioSource audioSource;

		public AudioClip showStartClip;

		public AudioClip countDownClip;

		public AudioClip startClip;

		public AudioClip rightClip;

		public AudioClip errorClip;

		public AudioClip errorTipsClip;

		private bool isStartCountdown;

		private float countdownTime = 1f;

		private float countdownAllTime = 3f;

		private Action timeOverAction;

		private bool isTips;

		private Vector3 initialPos;

		private void Awake()
		{
			Instance = this;
		}

		private void Start()
		{
			showAgainBtn.onClick.AddListener(ShowAgainBtnHander);
			showInputBtn.onClick.AddListener(ShowInputBtnHander);
			deleteBtn.onClick.AddListener(DeleteBtnHander);
			initialPos = base.transform.localPosition;
		}

		private void Update()
		{
			if (!isStartCountdown)
			{
				return;
			}
			if (!CheckpointManager.IsStartGame)
			{
				isStartCountdown = false;
				audioSource.Stop();
				CheckpointManager.OverTheGame();
				return;
			}
			countdownTime -= Time.deltaTime;
			if (countdownTime <= 0f)
			{
				countdownAllTime -= 1f;
				if (countdownAllTime <= 0f)
				{
					isStartCountdown = false;
					tipsText.text = string.Empty;
					timeOverAction?.Invoke();
				}
				else
				{
					tipsText.text = countdownAllTime.ToString();
					countdownTime = 1f;
				}
			}
		}

		public void Countdown(Action action)
		{
			audioSource.clip = showStartClip;
			audioSource.Play();
			memoryNumText.text = "记忆数量：" + CheckpointManager.GetWordsNum;
			memoryNumText.color = orderColor[CheckpointManager.IsReverse];
			orderText.text = orderWord[CheckpointManager.IsReverse];
			orderText.color = orderColor[CheckpointManager.IsReverse];
			orderImage.sprite = orderSprite[CheckpointManager.IsReverse];
			tipsText.text = "开始训练";
			tipsText.color = orderColor[CheckpointManager.IsReverse];
			PlayerController.Instance.DelayHander(showStartClip.length + 1f, delegate
			{
				audioSource.clip = countDownClip;
				audioSource.Play();
				isStartCountdown = true;
				countdownTime = 1f;
				countdownAllTime = 3f;
				tipsText.text = countdownAllTime.ToString();
				timeOverAction = action;
			});
		}

		public void NotCountdown(Action action)
		{
			tipsText.text = "";
			tipsText.color = orderColor[CheckpointManager.IsReverse];
			PlayerController.Instance.DelayHander(1f, delegate
			{
				memoryNumText.text = "记忆数量：" + CheckpointManager.GetWordsNum;
				memoryNumText.color = orderColor[CheckpointManager.IsReverse];
				orderText.text = orderWord[CheckpointManager.IsReverse];
				orderText.color = orderColor[CheckpointManager.IsReverse];
				orderImage.sprite = orderSprite[CheckpointManager.IsReverse];
				action?.Invoke();
			});
		}

		public void IsShowTips(int tips)
		{
			tipsText.text = string.Empty;
			if (tips == 0)
			{
				isTips = false;
			}
			else
			{
				isTips = true;
			}
		}

		public void ShowAllKeys(List<string> keys)
		{
			tipsText.text = string.Empty;
			for (int i = 0; i < keys.Count; i++)
			{
				tipsText.text += keys[i];
			}
		}

		public void AddShowKeys(string keys)
		{
			tipsText.text += keys;
		}

		public void ReduceKeys()
		{
			if (!string.IsNullOrEmpty(tipsText.text))
			{
				tipsText.text = tipsText.text.Substring(0, tipsText.text.Length - 1);
			}
		}

		public void HideKeys()
		{
			tipsText.text = string.Empty;
		}

		public void ShowResultTips(bool result, Action action)
		{
			if (result)
			{
				audioSource.clip = rightClip;
				audioSource.Play();
				PlayerController.Instance.DelayHander(rightClip.length, delegate
				{
					tipsText.text = "回答正确";
					PlayerController.Instance.DelayHander(1f, delegate
					{
						action?.Invoke();
					});
				});
				return;
			}
			audioSource.clip = errorClip;
			audioSource.Play();
			PlayerController.Instance.DelayHander(errorClip.length + 0.5f, delegate
			{
				tipsText.text = "回答错误，请再次尝试";
				audioSource.clip = errorTipsClip;
				audioSource.Play();
				PlayerController.Instance.DelayHander(errorTipsClip.length + 0.5f, delegate
				{
					action?.Invoke();
				});
			});
		}

		public void ShowTimeTips(Action action)
		{
			tipsText.text = "回答超时";
			audioSource.clip = errorClip;
			audioSource.Play();
			PlayerController.Instance.DelayHander(errorClip.length + 0.5f, delegate
			{
				action?.Invoke();
			});
		}

		public void ShowStartTips(List<string> memoryNums, int showType, Action action)
		{
			audioSource.clip = startClip;
			audioSource.Play();
			PlayerController.Instance.DelayHander(startClip.length, delegate
			{
				action?.Invoke();
			});
			if (showType == 1)
			{
				memoryNums.Reverse();
			}
		}

		public void HitRight(string keys)
		{
			tipsText.text += keys;
		}

		public void HitError(string keys)
		{
			tipsText.text += keys;
		}

		private void ShowAgainBtnHander()
		{
			if (CheckpointManager.IsPlayGame)
			{
				CheckpointManager.HitShowAgain();
			}
		}

		private void ShowInputBtnHander()
		{
			if (CheckpointManager.IsPlayGame)
			{
				CheckpointManager.HitInputAgain();
			}
		}

		private void DeleteBtnHander()
		{
			if (CheckpointManager.IsPlayGame)
			{
				CheckpointManager.HitDelete();
			}
		}
	}
	public class UIController : MonoBehaviour
	{
		public static UIController Instance;

		public GameObject StaticCanvas;

		[Header("开始界面")]
		public GameObject StartGamePanel;

		public ToggleGroup toggleGroup;

		public Button startGameBtn;

		public Button settingsBtn;

		public Button tipsBtn;

		public Button exitBtn;

		public AudioSource bgAudioSource;

		[Header("游戏界面")]
		public GameObject ScorePanel;

		public Text CurScoreTxt;

		public Text LevelTxt;

		public Text TotalTimeTxt;

		public Text ChanglleNumTxt;

		public Text ChanglleTimeTxt;

		[Header("结算界面")]
		public GameObject PassAllCheckpointPanel;

		public TextMeshProUGUI ScoreTxt;

		public Text TrainingDurationTxt;

		public Text InitChallengeLevelTxt;

		public Text MaxChallengeLevelTxt;

		public Text MinChallengeLevelTxt;

		public Text AllPassTxt;

		public Text PerfectNumTxt;

		public Text ContinuateMaxNumTxt;

		public Text TimeOutNumTxt;

		public Text InputTimeTxt;

		public Text MemoryAccuracyTxt;

		public Text NumberAccuracyTxt;

		public Text GraphsAccuracyTxt;

		public Text LetterAccuracyTxt;

		public Button passAllReturnBtn;

		[Header("暂停界面")]
		public GameObject SuspendPanel;

		public Button suspendReturnStartBtn;

		public Button suspendReturnBtn;

		[Header("退出提示界面")]
		public GameObject ExitTipPanel;

		public Button defineBtn;

		public Button cancelBtn;

		public AudioSource audioSource;

		public AudioClip[] audioClips;

		public bool isStartTime;

		private float surplusGameDuration;

		private int curErrorTimes;

		private float checkTime;

		private void Awake()
		{
			Instance = this;
		}

		private void Start()
		{
			ScorePanel.SetActive(value: false);
			PassAllCheckpointPanel.SetActive(value: false);
			startGameBtn.onClick.AddListener(StartGameBtnHander);
			exitBtn.onClick.AddListener(ExitBtnHander);
			passAllReturnBtn.onClick.AddListener(PassAllBtnHander);
			suspendReturnStartBtn.onClick.AddListener(SuspendReturnStartBtnHander);
			suspendReturnBtn.onClick.AddListener(SuspendReturnBtnHander);
			defineBtn.onClick.AddListener(DefineBtnHander);
			cancelBtn.onClick.AddListener(CancelBtnHander);
			for (int i = 0; i < toggleGroup.transform.childCount; i++)
			{
				int index = i;
				Toggle component = toggleGroup.transform.GetChild(i).GetComponent<Toggle>();
				component.onValueChanged.AddListener(delegate(bool value)
				{
					if (value)
					{
						LoadManager.LevelID = index;
					}
				});
				if (LoadManager.LevelID == index)
				{
					component.isOn = true;
				}
			}
			PlayerController.Instance.InitData();
			if (LoadManager.IsLocalOperate)
			{
				StartGamePanel.SetActive(value: true);
				return;
			}
			StartGamePanel.SetActive(value: false);
			StartGameBtnHander(LoadManager.course);
		}

		private void Update()
		{
			if (CheckpointManager.IsStartGame)
			{
				surplusGameDuration -= Time.deltaTime;
				TotalTimeTxt.text = LoadManager.TimeConversion((int)surplusGameDuration);
				if (surplusGameDuration <= 0f)
				{
					CheckpointManager.OverTheGame();
				}
			}
			if (IsCanSuspend() && Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.APP))
			{
				PlayerController.Instance.IsShowVivePointers(isShow: true);
				PlayerController.Instance.IsShowKeyBoard(isShow: false);
				IsStartTime(isStart: false);
				StaticCanvas.SetActive(value: true);
				SuspendPanel.SetActive(value: true);
				Time.timeScale = 0f;
			}
		}

		public void StartGame()
		{
			PlayerController.Instance.IsShowKeyBoard(isShow: true);
			StaticCanvas.SetActive(value: false);
			ScorePanel.SetActive(value: true);
			curErrorTimes = 0;
			surplusGameDuration = CheckpointManager.gameDuration - CheckpointManager.gameDurationed;
			CurScoreTxt.text = CheckpointManager.curScore.ToString();
			LevelTxt.text = CheckpointManager.GetCurLevel;
			TotalTimeTxt.text = LoadManager.TimeConversion((int)surplusGameDuration);
			CheckpointManager.SetChanglleNum(0);
			ChanglleTimeTxt.text = CheckpointManager.CurShotHandLevel.LimitTime.ToString();
		}

		public void IsStartTime(bool isStart = true)
		{
			isStartTime = isStart;
		}

		public void ErrorAnswer()
		{
			curErrorTimes++;
		}

		public int GetUseDuration(bool isComplete = false)
		{
			float num = CheckpointManager.gameDuration - surplusGameDuration;
			num = (isComplete ? CheckpointManager.gameDuration : num);
			return (int)num;
		}

		public void OverTheGame()
		{
			IsStartTime(isStart: false);
			PlayAudioSound(4);
			PlayerController.Instance.IsShowVivePointers(isShow: true);
			PlayerController.Instance.IsShowKeyBoard(isShow: false);
			StaticCanvas.SetActive(value: true);
			ScorePanel.SetActive(value: false);
			PassAllCheckpointPanel.SetActive(value: true);
			ScoreTxt.text = CheckpointManager.curScore.ToString();
			TrainingDurationTxt.text = LoadManager.TimeConversion((int)CheckpointManager.gameDuration);
			InitChallengeLevelTxt.text = CheckpointManager.GetInitChallengeLevel();
			MaxChallengeLevelTxt.text = CheckpointManager.GetMaxChallengeLevel();
			MinChallengeLevelTxt.text = CheckpointManager.GetMinChallengeLevel();
			AllPassTxt.text = CheckpointManager.allPass.ToString();
			PerfectNumTxt.text = CheckpointManager.perfectNum.ToString();
			ContinuateMaxNumTxt.text = CheckpointManager.continuateMaxNum.ToString();
			TimeOutNumTxt.text = CheckpointManager.timeOutNum.ToString();
			InputTimeTxt.text = ((CheckpointManager.hitNum == 0) ? (CheckpointManager.gameDuration + "秒") : (Math.Round(CheckpointManager.gameDuration / (float)CheckpointManager.hitNum, 2) + "秒"));
			int num = CheckpointManager.allNumLevel + CheckpointManager.allLetterLevel + CheckpointManager.allGraphsLevel;
			MemoryAccuracyTxt.text = ((num == 0) ? "0%" : (Math.Round((float)CheckpointManager.allPass / (float)num, 4) * 100.0 + "%"));
			NumberAccuracyTxt.text = ((CheckpointManager.allNumLevel == 0) ? "0%" : (Math.Round((float)CheckpointManager.passNumLevel / (float)CheckpointManager.allNumLevel, 4) * 100.0 + "%"));
			GraphsAccuracyTxt.text = ((CheckpointManager.allLetterLevel == 0) ? "0%" : (Math.Round((float)CheckpointManager.passLetterLevel / (float)CheckpointManager.allLetterLevel, 4) * 100.0 + "%"));
			LetterAccuracyTxt.text = ((CheckpointManager.allGraphsLevel == 0) ? "0%" : (Math.Round((float)CheckpointManager.passGraphsLevel / (float)CheckpointManager.allGraphsLevel, 4) * 100.0 + "%"));
		}

		public void PlayAudioSound(int index)
		{
			if (audioSource.isPlaying)
			{
				audioSource.Stop();
			}
			audioSource.clip = audioClips[index];
			audioSource.Play();
		}

		public float GetCurRemainingTime()
		{
			return surplusGameDuration;
		}

		public void CheckBattery(Action continueAction)
		{
			if (PlayerController.Instance.batteryTipController.CheckBattery(continueAction))
			{
				SuspendGame(suspend: true);
			}
		}

		public void SuspendGame(bool suspend)
		{
			PlayerController.Instance.IsShowVivePointers(suspend);
			PlayerController.Instance.IsShowKeyBoard(!suspend);
			StaticCanvas.SetActive(suspend);
			Time.timeScale = ((!suspend) ? 1 : 0);
		}

		private void StartGameBtnHander()
		{
			StartGameBtnHander(null);
		}

		private void StartGameBtnHander(CourseDetail.Data data)
		{
			StartGamePanel.SetActive(value: false);
			bgAudioSource.Play();
			CheckpointManager.StartTheLevel(data);
		}

		private void ExitBtnHander()
		{
			ScenesHelper.LoadScene(ScenesHelper.WeiAiZhiCenterScene);
		}

		private void PassAllBtnHander()
		{
			if (LoadManager.IsLocalOperate)
			{
				StartGamePanel.SetActive(value: true);
				PassAllCheckpointPanel.SetActive(value: false);
			}
			else
			{
				LoadManager.SubmitEndRecord(isComplete: true, isLogout: false, GetUseDuration(isComplete: true), CheckpointManager.curScore, J_LitJson.JsonMapper.ToJson(CheckpointManager.GetGameRecord()));
			}
		}

		private void SuspendReturnStartBtnHander()
		{
			if (LoadManager.IsLocalOperate)
			{
				CheckpointManager.ResetTheGame();
				StaticCanvas.SetActive(value: true);
				StartGamePanel.SetActive(value: true);
				SuspendPanel.SetActive(value: false);
				ScorePanel.SetActive(value: false);
				Time.timeScale = 1f;
			}
			else
			{
				ExitTipPanel.SetActive(value: true);
			}
		}

		private void SuspendReturnBtnHander()
		{
			PlayerController.Instance.ResetShowVivePointers();
			PlayerController.Instance.IsShowKeyBoard(isShow: true);
			StaticCanvas.SetActive(value: false);
			SuspendPanel.SetActive(value: false);
			Time.timeScale = 1f;
		}

		private void DefineBtnHander()
		{
			Time.timeScale = 1f;
			LoadManager.SubmitEndRecord(isComplete: false, isLogout: false, GetUseDuration(), CheckpointManager.curScore, J_LitJson.JsonMapper.ToJson(CheckpointManager.GetGameRecord()));
		}

		private void CancelBtnHander()
		{
			ExitTipPanel.SetActive(value: false);
		}

		private bool IsCanSuspend()
		{
			if (PassAllCheckpointPanel.activeSelf)
			{
				return false;
			}
			if (CheckpointManager.IsStartGame)
			{
				return true;
			}
			return false;
		}
	}
}
namespace CRCI_FruitCut
{
	public class GameManager18_QSG_ADHD : MonoBehaviour
	{
		public static GameManager18_QSG_ADHD Inst;

		public Transform m_vCubeBornPos_left;

		public Transform m_vCubeBornPos_right;

		[Header("params")]
		public Vector3 vBornDelayPos = new Vector3(0.2f, 0.2f, 0f);

		public Vector3 vBornDelayPos_bomb = new Vector3(0.2f, 0f, 0f);

		[Header("objects")]
		public GameObject vrPlayer;

		public GameObject headCam;

		public Pvr_ControllerModuleInit pvr_ControllerModuleInitLeft;

		public Pvr_ControllerModuleInit pvr_ControllerModuleInitRight;

		public GameObject[] listVROriHandModels;

		public GameObject m_SwordYellow;

		public GameObject m_SwordRed;

		public GameObject m_objCubeYellow;

		public GameObject m_objCubeRed;

		public AudioSource m_audioHit;

		public AudioSource m_audioHit02;

		public AudioSource m_audioWrongSword;

		public AudioSource m_audioWrongDir;

		public ParticleSystem m_psRight;

		public ParticleSystem m_psRight02;

		public ParticleSystem m_psWrong;

		public ParticleSystem m_psWrong02;

		public ParticleSystem m_psWrongDirPoint;

		public List<UnityEngine.Object> m_listFruitsItems;

		public List<UnityEngine.Object> m_listVegetablesItems;

		public List<UnityEngine.Object> m_listBombs;

		[Header("Level")]
		public int m_iScore;

		private float fLeftTime;

		private int fHighestScore;

		private int _rightComboCount;

		private int missCount;

		private int _maxRightComboCount;

		private int m_MaxRightComboCount_InLevel;

		[Header("UI")]
		public Text m_txtHighestScore;

		public Text m_txtLevelTargetScore;

		public Image m_imgTimeLeftProgress;

		public Text m_txtTimeLeft;

		public Text m_txtScore;

		public Text m_txtAddScore;

		public Text m_txtCurLevel;

		public GameObject objScorePanle;

		public GameObject objComboPanle;

		public TMP_Text m_txtComboCount;

		public TMP_Text m_txtComboCountScorePlus;

		public TMP_Text m_txtScoreJumpAdd;

		public BatteryTipController batteryTipController;

		private int curRightNum;

		private int curErrorNum;

		private List<GameObject> curGroupObjects = new List<GameObject>();

		private int continuateNum;

		private bool hasStartCount;

		private GameObject objCubesContainer;

		private int m_iComboAddScore;

		private int curCreateFruitNum;

		private int curCreateStoneNum;

		private bool curGroup;

		private bool lastIsStone;

		private Tweener scoreTwener;

		public float surplusGameDuration => fLeftTime;

		private int iRightComboCount
		{
			get
			{
				return _rightComboCount;
			}
			set
			{
				_rightComboCount = value;
				if (value > m_MaxRightComboCount)
				{
					m_MaxRightComboCount = value;
				}
			}
		}

		private int m_MaxRightComboCount
		{
			get
			{
				return _maxRightComboCount;
			}
			set
			{
				_maxRightComboCount = value;
				if (value > m_MaxRightComboCount_InLevel)
				{
					m_MaxRightComboCount_InLevel = value;
				}
			}
		}

		private void Awake()
		{
			Inst = this;
			fHighestScore = PlayerPrefs.GetInt("adhd_qsw_HighestScore");
			m_SwordRed.gameObject.SetActive(value: false);
			m_SwordYellow.gameObject.SetActive(value: false);
			m_txtHighestScore.text = string.Concat(fHighestScore);
			m_txtLevelTargetScore.text = "";
			m_txtCurLevel.text = "";
			m_imgTimeLeftProgress.fillAmount = 1f;
			m_txtTimeLeft.text = "";
			m_txtScore.text = "";
			objScorePanle.SetActive(value: false);
			objComboPanle.SetActive(value: false);
			m_txtScoreJumpAdd.gameObject.SetActive(value: false);
		}

		private void Start()
		{
			Time.fixedDeltaTime = 0.02f;
		}

		public void InitData()
		{
			m_SwordYellow.gameObject.SetActive(value: false);
			m_SwordRed.gameObject.SetActive(value: false);
			m_objCubeYellow.SetActive(value: false);
			m_objCubeRed.SetActive(value: false);
			List<FruitCutLevel> list = CsvMapper.ToObjectList<FruitCutLevel>(LoadManager.CsvRead("FruitCutLevel"));
			QSG_GameDataManager.LevelDataDic.Clear();
			foreach (FruitCutLevel item in list)
			{
				QSG_GameDataManager.LevelDataDic.Add(item.LevelID, item);
			}
			List<FruitCutStrength> list2 = CsvMapper.ToObjectList<FruitCutStrength>(LoadManager.CsvRead("FruitCutStrength"));
			QSG_GameDataManager.StrengthDataDic.Clear();
			foreach (FruitCutStrength item2 in list2)
			{
				QSG_GameDataManager.StrengthDataDic.Add(item2.StrengthID, item2);
			}
		}

		public void StartTheGame()
		{
			objScorePanle.SetActive(value: true);
			StopAllCoroutines();
			if (objCubesContainer != null)
			{
				UnityEngine.Object.Destroy(objCubesContainer.gameObject);
				objCubesContainer = null;
			}
			m_iScore = 0;
			m_txtScore.text = string.Concat(m_iScore);
			m_txtHighestScore.text = string.Concat(fHighestScore);
			m_imgTimeLeftProgress.fillAmount = 1f;
			m_txtTimeLeft.text = "";
			objComboPanle.SetActive(value: false);
			m_txtScoreJumpAdd.gameObject.SetActive(value: false);
			missCount = 0;
			iRightComboCount = 0;
			m_MaxRightComboCount = 0;
			ShowHandRays(isshow: false);
			hasStartCount = false;
			curCreateFruitNum = QSG_GameDataManager.GetFruitNum;
			curCreateStoneNum = QSG_GameDataManager.GetStoneNum;
			StartCoroutine(yiledBornCubes());
			StartCoroutine(yieldTimeCountDown());
		}

		private IEnumerator yieldTimeCountDown()
		{
			hasStartCount = true;
			fLeftTime = QSG_GameDataManager.gameDuration - QSG_GameDataManager.gameDurationed;
			while (fLeftTime > 0f)
			{
				fLeftTime -= 1f;
				m_txtTimeLeft.text = string.Concat(Mathf.FloorToInt(fLeftTime));
				if (fLeftTime <= 0f)
				{
					fLeftTime = 0f;
				}
				m_imgTimeLeftProgress.fillAmount = fLeftTime / QSG_GameDataManager.gameDuration;
				QSG_MainMenuUICtrl.Inst.TotalTimeTxt.text = LoadManager.TimeConversion((int)fLeftTime);
				yield return new WaitForSeconds(1f);
			}
			OnFinishBorns();
			QSG_GameDataManager.OverTheGame();
		}

		public void ShowHandRays(bool isshow)
		{
			if (isshow)
			{
				m_psRight.gameObject.SetActive(value: false);
				m_psRight02.gameObject.SetActive(value: false);
				m_psWrong.gameObject.SetActive(value: false);
				m_psWrong02.gameObject.SetActive(value: false);
				GameObject[] array = listVROriHandModels;
				for (int i = 0; i < array.Length; i++)
				{
					array[i].SetActive(value: true);
				}
				pvr_ControllerModuleInitLeft.ForceHideOrShow(state: true);
				pvr_ControllerModuleInitRight.ForceHideOrShow(state: true);
				m_SwordRed.gameObject.SetActive(value: false);
				m_SwordYellow.gameObject.SetActive(value: false);
				if ((bool)objCubesContainer)
				{
					objCubesContainer.SetActive(value: false);
				}
			}
			else
			{
				m_psRight.gameObject.SetActive(value: true);
				m_psRight02.gameObject.SetActive(value: true);
				m_psWrong.gameObject.SetActive(value: true);
				m_psWrong02.gameObject.SetActive(value: true);
				GameObject[] array = listVROriHandModels;
				for (int i = 0; i < array.Length; i++)
				{
					array[i].SetActive(value: false);
				}
				pvr_ControllerModuleInitLeft.ForceHideOrShow(state: false);
				pvr_ControllerModuleInitRight.ForceHideOrShow(state: false);
				m_SwordRed.gameObject.SetActive(value: true);
				m_SwordYellow.SetActive(value: true);
				if ((bool)objCubesContainer)
				{
					objCubesContainer.SetActive(value: true);
				}
			}
		}

		private IEnumerator yiledBornCubes()
		{
			objCubesContainer = new GameObject("objCubesContainer");
			while (true)
			{
				curGroup = false;
				int num = CreateFruitOrStone();
				string text = "0";
				string text2 = "0";
				string text3 = "0";
				if (num == 0)
				{
					lastIsStone = true;
					text3 = "1";
					curCreateStoneNum--;
				}
				else
				{
					curCreateFruitNum--;
					lastIsStone = false;
					if (curCreateFruitNum > 1)
					{
						switch (UnityEngine.Random.Range(0, 3))
						{
						case 0:
							curCreateFruitNum--;
							text = UnityEngine.Random.Range(1, 5).ToString();
							text2 = MyMath.RandomRange(1, 5, int.Parse(text)).ToString();
							break;
						case 1:
							text = UnityEngine.Random.Range(1, 5).ToString();
							break;
						default:
							text2 = UnityEngine.Random.Range(1, 5).ToString();
							break;
						}
					}
					else if (UnityEngine.Random.Range(1, 3) == 1)
					{
						text = UnityEngine.Random.Range(1, 5).ToString();
					}
					else
					{
						text2 = UnityEngine.Random.Range(1, 5).ToString();
					}
				}
				int num2 = UnityEngine.Random.Range(0, 2);
				UnityEngine.Random.InitState(Guid.NewGuid().GetHashCode());
				bool flag = UnityEngine.Random.Range(0, 2) == 0;
				if (text != "0")
				{
					QSG_GameDataManager.totalFruitNum++;
					Coroutine coroutineMove3 = null;
					GameObject tempCubeleft = UnityEngine.Object.Instantiate(m_objCubeYellow);
					curGroupObjects.Add(tempCubeleft);
					tempCubeleft.transform.SetParent(objCubesContainer.transform);
					tempCubeleft.SetActive(value: true);
					Vector3 vector = ((num2 == 0) ? m_vCubeBornPos_left.position : m_vCubeBornPos_right.position);
					tempCubeleft.transform.position = vector + new Vector3(UnityEngine.Random.Range(0f - vBornDelayPos.x, vBornDelayPos.x), UnityEngine.Random.Range(0f - vBornDelayPos.y, vBornDelayPos.y), flag ? UnityEngine.Random.Range(0f, 1f) : 0f);
					switch (text)
					{
					case "1":
						tempCubeleft.transform.Rotate(0f, 0f, 0f);
						break;
					case "2":
						tempCubeleft.transform.Rotate(0f, 0f, 90f);
						break;
					case "3":
						tempCubeleft.transform.Rotate(0f, 0f, 180f);
						break;
					case "4":
						tempCubeleft.transform.Rotate(0f, 0f, 270f);
						break;
					}
					GameObject obj = UnityEngine.Object.Instantiate(m_listVegetablesItems[UnityEngine.Random.Range(0, m_listVegetablesItems.Count)]) as GameObject;
					obj.transform.SetParent(tempCubeleft.transform);
					obj.gameObject.SetActive(value: true);
					obj.transform.localPosition = Vector3.zero;
					obj.transform.localEulerAngles = Vector3.zero;
					obj.transform.localScale = Vector3.one;
					tempCubeleft.GetComponentInChildren<OnColliderEvent>().m_actionsOnCollisionEnter.AddListener(delegate(UnityEngine.Collision collision)
					{
						if (!hasStartCount)
						{
							StartCoroutine(yieldTimeCountDown());
						}
						if (collision.gameObject.transform.IsChildOf(m_SwordYellow.transform))
						{
							_ = m_SwordYellow.gameObject.GetComponent<Rigidbody>().velocity;
							if (collision.relativeVelocity.magnitude > 1f && Vector3.Dot(collision.relativeVelocity.normalized, tempCubeleft.transform.up) < -0.5f)
							{
								iRightComboCount += 1;
								if (iRightComboCount >= 3)
								{
									m_txtComboCount.text = string.Concat(m_iComboAddScore);
									if (m_iComboAddScore > 0)
									{
										objComboPanle.gameObject.SetActive(value: true);
									}
									shakeComboScore();
									TextMeshPro textMeshPro2 = UnityEngine.Object.Instantiate(m_txtScoreJumpAdd) as TextMeshPro;
									textMeshPro2.transform.SetParent(objCubesContainer.transform);
									textMeshPro2.transform.position = tempCubeleft.transform.position;
									textMeshPro2.text = iRightComboCount + " Hits";
									textMeshPro2.gameObject.SetActive(value: true);
									textMeshPro2.transform.DOMoveY(textMeshPro2.transform.position.y + 0.7f, 1f);
									textMeshPro2.DOFade(0f, 1f);
									StartCoroutine(yiledDestroyObj(textMeshPro2.gameObject, 1f));
								}
								m_psRight.transform.eulerAngles = new Vector3(tempCubeleft.transform.eulerAngles.x, tempCubeleft.transform.eulerAngles.y, tempCubeleft.transform.eulerAngles.z + 90f);
								m_psRight.transform.position = tempCubeleft.transform.position;
								m_psRight.Play();
								m_audioHit.Play();
								RightCut(tempCubeleft);
								QSG_GameDataManager.cutFruitNum++;
								Controller.UPvr_VibrateNeo2Controller(0.5f, 50, 0);
							}
							else
							{
								m_audioWrongSword.Play();
								m_psWrong.transform.position = tempCubeleft.transform.position;
								m_psWrong.Play();
								MissCut(tempCubeleft);
							}
						}
						else if (collision.gameObject.transform.IsChildOf(m_SwordRed.transform))
						{
							m_audioWrongSword.Play();
							m_psWrong.transform.position = tempCubeleft.transform.position;
							m_psWrong.Play();
							MissCut(tempCubeleft);
						}
						else
						{
							MissCut(tempCubeleft);
						}
						if (coroutineMove3 != null)
						{
							StopCoroutine(coroutineMove3);
						}
						coroutineMove3 = null;
					});
					coroutineMove3 = StartCoroutine(yieldMoveObj(tempCubeleft));
				}
				if (text2 != "0")
				{
					QSG_GameDataManager.totalFruitNum++;
					Coroutine coroutineMove2 = null;
					GameObject tempCuberight = UnityEngine.Object.Instantiate(m_objCubeRed);
					curGroupObjects.Add(tempCuberight);
					tempCuberight.transform.SetParent(objCubesContainer.transform);
					tempCuberight.SetActive(value: true);
					Vector3 vector2 = ((num2 == 0) ? m_vCubeBornPos_right.position : m_vCubeBornPos_left.position);
					tempCuberight.transform.position = vector2 + new Vector3(UnityEngine.Random.Range(0f - vBornDelayPos.x, vBornDelayPos.x), UnityEngine.Random.Range(0f - vBornDelayPos.y, vBornDelayPos.y), flag ? 0f : UnityEngine.Random.Range(0f, 1f));
					switch (text2)
					{
					case "1":
						tempCuberight.transform.Rotate(0f, 0f, 0f);
						break;
					case "2":
						tempCuberight.transform.Rotate(0f, 0f, 90f);
						break;
					case "3":
						tempCuberight.transform.Rotate(0f, 0f, 180f);
						break;
					case "4":
						tempCuberight.transform.Rotate(0f, 0f, 270f);
						break;
					}
					GameObject obj2 = UnityEngine.Object.Instantiate(m_listFruitsItems[UnityEngine.Random.Range(0, m_listFruitsItems.Count)]) as GameObject;
					obj2.transform.SetParent(tempCuberight.transform);
					obj2.gameObject.SetActive(value: true);
					obj2.transform.localPosition = Vector3.zero;
					obj2.transform.localEulerAngles = Vector3.zero;
					obj2.transform.localScale = Vector3.one;
					tempCuberight.GetComponentInChildren<OnColliderEvent>().m_actionsOnCollisionEnter.AddListener(delegate(UnityEngine.Collision collision)
					{
						if (!hasStartCount)
						{
							StartCoroutine(yieldTimeCountDown());
						}
						if (collision.gameObject.transform.IsChildOf(m_SwordRed.transform))
						{
							Vector3 velocity = m_SwordRed.gameObject.GetComponent<Rigidbody>().velocity;
							if (collision.relativeVelocity.magnitude > 1f && Vector3.Dot(collision.relativeVelocity.normalized, tempCuberight.transform.up) < -0.5f)
							{
								iRightComboCount += 1;
								if (iRightComboCount >= 3)
								{
									m_txtComboCount.text = string.Concat(m_iComboAddScore);
									if (m_iComboAddScore > 0)
									{
										objComboPanle.gameObject.SetActive(value: true);
									}
									shakeComboScore();
									TextMeshPro textMeshPro = UnityEngine.Object.Instantiate(m_txtScoreJumpAdd) as TextMeshPro;
									textMeshPro.transform.SetParent(objCubesContainer.transform);
									textMeshPro.transform.position = tempCuberight.transform.position;
									textMeshPro.text = iRightComboCount + " Hits";
									textMeshPro.gameObject.SetActive(value: true);
									textMeshPro.transform.DOMoveY(textMeshPro.transform.position.y + 0.7f, 1f);
									textMeshPro.DOFade(0f, 1f);
									StartCoroutine(yiledDestroyObj(textMeshPro.gameObject, 1f));
								}
								m_psRight02.transform.eulerAngles = new Vector3(tempCuberight.transform.eulerAngles.x, tempCuberight.transform.eulerAngles.y, tempCuberight.transform.eulerAngles.z + 90f);
								m_psRight02.transform.position = tempCuberight.transform.position;
								m_psRight02.Play();
								m_audioHit02.Play();
								RightCut(tempCuberight);
								QSG_GameDataManager.cutFruitNum++;
								Controller.UPvr_VibrateNeo2Controller(0.5f, 50, 1);
							}
							else
							{
								m_audioWrongSword.Play();
								m_psWrong02.transform.position = tempCuberight.transform.position;
								m_psWrong02.Play();
								UnityEngine.Debug.LogWarning("--wrong dir" + velocity);
								MissCut(tempCuberight);
							}
							if (coroutineMove2 != null)
							{
								StopCoroutine(coroutineMove2);
							}
							coroutineMove2 = null;
						}
						else if (collision.gameObject.transform.IsChildOf(m_SwordYellow.transform))
						{
							m_audioWrongSword.Play();
							m_psWrong02.transform.position = tempCuberight.transform.position;
							m_psWrong02.Play();
							UnityEngine.Debug.LogWarning("--wrong sword");
							MissCut(tempCuberight);
							if (coroutineMove2 != null)
							{
								StopCoroutine(coroutineMove2);
							}
							coroutineMove2 = null;
						}
						else
						{
							MissCut(tempCuberight);
							if (coroutineMove2 != null)
							{
								StopCoroutine(coroutineMove2);
							}
							coroutineMove2 = null;
						}
					});
					coroutineMove2 = StartCoroutine(yieldMoveObj(tempCuberight));
				}
				if (text3 != "0")
				{
					QSG_GameDataManager.totalStoneNum++;
					Coroutine coroutineMove = null;
					GameObject tempCubestone = UnityEngine.Object.Instantiate(m_objCubeRed);
					curGroupObjects.Add(tempCubestone);
					tempCubestone.transform.SetParent(objCubesContainer.transform);
					tempCubestone.SetActive(value: true);
					Vector3 position = headCam.transform.position;
					position.z = m_vCubeBornPos_left.position.z;
					tempCubestone.transform.position = position;
					GameObject obj3 = UnityEngine.Object.Instantiate(m_listBombs[UnityEngine.Random.Range(0, m_listBombs.Count)]) as GameObject;
					tempCubestone.transform.Find("Arrow").gameObject.SetActive(value: false);
					obj3.transform.SetParent(tempCubestone.transform);
					obj3.gameObject.SetActive(value: true);
					obj3.transform.localPosition = Vector3.zero;
					obj3.transform.localEulerAngles = Vector3.zero;
					obj3.transform.localScale = Vector3.one;
					tempCubestone.GetComponentInChildren<OnColliderEvent>().m_actionsOnCollisionEnter.AddListener(delegate
					{
						if (!hasStartCount)
						{
							StartCoroutine(yieldTimeCountDown());
						}
						UnityEngine.Debug.LogWarning("--bomb");
						headCam.transform.parent.transform.DOShakeRotation(0.3f, 25f).OnComplete(delegate
						{
							headCam.transform.parent.transform.eulerAngles = Vector3.zero;
						});
						m_audioWrongSword.Play();
						_AddOneHeadHitCount();
						MissCut(tempCubestone);
						if (coroutineMove != null)
						{
							StopCoroutine(coroutineMove);
						}
						coroutineMove = null;
					});
					coroutineMove = StartCoroutine(yieldMoveObj_Bomb(tempCubestone));
				}
				if (curCreateStoneNum == 0 && curCreateFruitNum == 0)
				{
					yield return new WaitUntil(OnFinishGroup);
				}
				else
				{
					yield return new WaitForSeconds(QSG_GameDataManager.CurFruitCutLevel.Interval);
				}
			}
		}

		private int CreateFruitOrStone()
		{
			int result;
			if (curCreateStoneNum > 0 && curCreateFruitNum > 0)
			{
				result = UnityEngine.Random.Range(0, 2);
				if (curCreateStoneNum * 2 >= curCreateFruitNum)
				{
					result = 0;
					if (lastIsStone)
					{
						UnityEngine.Debug.Log("Recurring stones:" + QSG_GameDataManager.GetCurLevel);
					}
				}
				else if (lastIsStone)
				{
					result = 1;
				}
			}
			else if (curCreateFruitNum == 0)
			{
				if (lastIsStone)
				{
					UnityEngine.Debug.Log("Recurring stones:" + QSG_GameDataManager.GetCurLevel);
				}
				result = 0;
			}
			else
			{
				result = 1;
			}
			return result;
		}

		private void shakeComboScore()
		{
			if (scoreTwener != null)
			{
				scoreTwener.Kill();
				scoreTwener = null;
			}
			scoreTwener = objComboPanle.transform.DOShakeScale(1f, 0.25f).OnComplete(delegate
			{
				objComboPanle.transform.localScale = Vector3.one * 0.15f;
			});
		}

		private void _AddOneHeadHitCount()
		{
		}

		private IEnumerator yieldMoveObj(GameObject obj)
		{
			while (true)
			{
				yield return new WaitForEndOfFrame();
				if (!(obj != null))
				{
					break;
				}
				obj.transform.position -= Vector3.forward * Time.deltaTime * QSG_GameDataManager.GetSpeed;
				if (obj.transform.position.z < -1f)
				{
					MissCut(obj);
					if (!hasStartCount)
					{
						StartCoroutine(yieldTimeCountDown());
					}
					break;
				}
			}
		}

		private IEnumerator yieldMoveObj_Bomb(GameObject obj)
		{
			while (true)
			{
				yield return new WaitForEndOfFrame();
				if (obj != null)
				{
					obj.transform.position -= Vector3.forward * Time.deltaTime * QSG_GameDataManager.GetSpeed;
					if (obj.transform.position.z < headCam.transform.position.z - 1f)
					{
						RightCut(obj);
						QSG_GameDataManager.noHitNum++;
						break;
					}
					continue;
				}
				break;
			}
		}

		private IEnumerator yiledDestroyObj(GameObject obj, float second)
		{
			yield return new WaitForSeconds(second);
			if (obj != null)
			{
				UnityEngine.Object.Destroy(obj);
			}
		}

		private void RightCut(GameObject tempCube)
		{
			if (curGroupObjects.Contains(tempCube))
			{
				curGroupObjects.Remove(tempCube);
			}
			UnityEngine.Object.Destroy(tempCube);
			for (int num = curGroupObjects.Count - 1; num >= 0; num--)
			{
				if (curGroupObjects[num] == null)
				{
					curGroupObjects.RemoveAt(num);
				}
			}
			if (curCreateStoneNum == 0 && curCreateFruitNum == 0 && curGroupObjects.Count == 0)
			{
				GroupEnd();
			}
		}

		private void MissCut(GameObject tempCube)
		{
			continuateNum = 0;
			if (curGroupObjects.Contains(tempCube))
			{
				curGroupObjects.Remove(tempCube);
			}
			UnityEngine.Object.Destroy(tempCube);
			objComboPanle.gameObject.SetActive(value: false);
			if (m_iComboAddScore > 0)
			{
				m_txtAddScore.text = "+" + m_iComboAddScore;
				m_txtAddScore.GetComponent<Animator>().SetTrigger("Scale");
			}
			iRightComboCount = 0;
			m_iComboAddScore = 0;
			missCount++;
			QSG_GameDataManager.SetChanglleNum(missCount);
			for (int num = curGroupObjects.Count - 1; num >= 0; num--)
			{
				if (curGroupObjects[num] == null)
				{
					curGroupObjects.RemoveAt(num);
				}
			}
			if (missCount >= QSG_GameDataManager.CurFruitCutLevel.ChallengeNum)
			{
				foreach (GameObject curGroupObject in curGroupObjects)
				{
					UnityEngine.Object.Destroy(curGroupObject);
				}
				curGroupObjects.Clear();
				missCount = 0;
				QSG_GameDataManager.SetChanglleNum(missCount);
				curRightNum = 0;
				curErrorNum++;
				if (curErrorNum >= QSG_GameDataManager.CurFruitCutLevel.DownshiftRequire)
				{
					curErrorNum = 0;
					QSG_GameDataManager.ReduceStrength(QSG_GameDataManager.CurFruitCutLevel.DownshiftGrade);
					QSG_MainMenuUICtrl.Inst.CheckBattery(delegate
					{
						QSG_MainMenuUICtrl.Inst.SuspendGame(suspend: false);
					});
				}
				GroupEnd(isEnd: true);
				curCreateFruitNum = QSG_GameDataManager.GetFruitNum;
				curCreateStoneNum = QSG_GameDataManager.GetStoneNum;
			}
			else if (curCreateStoneNum == 0 && curCreateFruitNum == 0 && curGroupObjects.Count == 0)
			{
				GroupEnd();
			}
		}

		private void GroupEnd()
		{
			curErrorNum = 0;
			curRightNum++;
			QSG_GameDataManager.allPass++;
			int num = ((missCount != 0) ? 1 : 2);
			if (missCount == 0)
			{
				QSG_GameDataManager.perfectNum++;
				continuateNum++;
				if (continuateNum > QSG_GameDataManager.continuateMaxNum)
				{
					QSG_GameDataManager.continuateMaxNum = continuateNum;
				}
			}
			else
			{
				continuateNum = 0;
			}
			if (curRightNum >= QSG_GameDataManager.CurFruitCutLevel.UpshiftRequire)
			{
				curRightNum = 0;
				QSG_GameDataManager.AddScore(QSG_GameDataManager.GetScore * num);
				int upshift = QSG_GameDataManager.CurFruitCutLevel.UpshiftGrade * num;
				QSG_MainMenuUICtrl.Inst.PlayAudioSound((num != 1) ? 1 : 0);
				QSG_GameDataManager.AddStrength(upshift);
				QSG_MainMenuUICtrl.Inst.CheckBattery(delegate
				{
					QSG_MainMenuUICtrl.Inst.SuspendGame(suspend: false);
				});
			}
			missCount = 0;
			QSG_GameDataManager.SetChanglleNum(missCount);
			curCreateFruitNum = QSG_GameDataManager.GetFruitNum;
			curCreateStoneNum = QSG_GameDataManager.GetStoneNum;
			GroupEnd(isEnd: true);
		}

		private void GroupEnd(bool isEnd)
		{
			curGroup = isEnd;
		}

		private bool OnFinishGroup()
		{
			return curGroup;
		}

		private void OnFinishBorns()
		{
			StopAllCoroutines();
			if (objCubesContainer != null)
			{
				UnityEngine.Object.Destroy(objCubesContainer.gameObject);
				objCubesContainer = null;
			}
			m_psRight.Stop();
			m_psRight02.Stop();
			m_psWrong.Stop();
			m_psWrong02.Stop();
		}

		private void realAddScore(int iScoreaadd)
		{
			m_iScore += iScoreaadd;
			m_txtScore.text = string.Concat(m_iScore);
		}

		private void OnDrawGizmos()
		{
			if (m_vCubeBornPos_left != null)
			{
				Gizmos.DrawWireCube(m_vCubeBornPos_left.position, new Vector3(vBornDelayPos.x * 2f, vBornDelayPos.y * 2f, 0.1f));
			}
			if (m_vCubeBornPos_right != null)
			{
				Gizmos.DrawWireCube(m_vCubeBornPos_right.position, new Vector3(vBornDelayPos.x * 2f, vBornDelayPos.y * 2f, 0.1f));
			}
		}
	}
	public class GameRecordData
	{
		public string InitLevel;

		public string MaxLevel;

		public string MinLevel;

		public int AllPass;

		public int PerfectNum;

		public int ContinuateMaxNum;

		public int CutFruitNum;

		public int TotalFruitNum;

		public int NoHitNum;

		public int TotalStoneNum;
	}
	public class M_fruitCut_LevelData
	{
		public string Levelid;

		public string LevelName;

		public string CheckpointArray;

		public string NextLevelid;

		public int _GetCheckPointCount()
		{
			return CheckpointArray.Split(',').Length;
		}

		public string _GetCheckPointID(int icheckpointIndex)
		{
			string[] array = CheckpointArray.Split(',');
			if (icheckpointIndex >= 0 && icheckpointIndex < CheckpointArray.Length)
			{
				return array[icheckpointIndex];
			}
			return null;
		}

		public int _GetCheckPointIndex(string icheckpointID)
		{
			return CheckpointArray.Split(',').ToList().IndexOf(icheckpointID);
		}
	}
	public class M_fruitCut_CheckpointData
	{
		public string CheckpointID;

		public float LevelTime;

		public int TargetScore;

		public int EachItemScore;

		public float ItemFlySpeed;

		public string ItemdataID;

		public float ItemDealyBornTime;

		public int ItemDealyLastRow;

		public int BombDamge;

		public int TimeThreshold;

		public int TimeScore;

		public int MissLimitTimes;

		public int NoMissScore;
	}
	public class SaveData_Level
	{
		public class clevel
		{
			public int level;

			public float progress;
		}

		public List<clevel> data = new List<clevel>();
	}
	public class FruitCutLevel
	{
		public int LevelID;

		public string LevelName;

		public int InitialNum;

		public float Interval;

		public float InitialSpeed;

		public int BaseScore;

		public int ChallengeNum;

		public int IsNumAdd;

		public int IsSpeedAdd;

		public int IsStone;

		public int UpshiftRequire;

		public int UpshiftGrade;

		public int DownshiftRequire;

		public int DownshiftGrade;
	}
	public class FruitCutStrength
	{
		public int StrengthID;

		public int StrengthGrade;

		public float ScoreAddition;

		public int FruitAddition;

		public float SpeedAddition;

		public int StoneNumber;
	}
	public class OnColliderEvent : MonoBehaviour
	{
		[Serializable]
		public class collisionEvent : UnityEvent<UnityEngine.Collision>
		{
		}

		public class triggerEvent : UnityEvent<Collider>
		{
		}

		public collisionEvent m_actionsOnCollisionEnter = new collisionEvent();

		public collisionEvent m_actionsOnCollisionExit = new collisionEvent();

		public triggerEvent m_actionsOnTriggerEnter = new triggerEvent();

		public triggerEvent m_actionsOnTriggerExit = new triggerEvent();

		private void OnCollisionEnter(UnityEngine.Collision collision)
		{
			UnityEngine.Debug.Log("--collid:" + collision.gameObject.name);
			if (m_actionsOnCollisionEnter != null)
			{
				m_actionsOnCollisionEnter.Invoke(collision);
			}
		}

		private void OnCollisionExit(UnityEngine.Collision collision)
		{
			if (m_actionsOnCollisionExit != null)
			{
				m_actionsOnCollisionExit.Invoke(collision);
			}
		}

		private void OnTriggerEnter(Collider other)
		{
			if (m_actionsOnTriggerEnter != null)
			{
				m_actionsOnTriggerEnter.Invoke(other);
			}
		}

		private void OnTriggerExit(Collider other)
		{
			if (m_actionsOnTriggerExit != null)
			{
				m_actionsOnTriggerExit.Invoke(other);
			}
		}
	}
	public class QSG_GameDataManager
	{
		private static string datasFolder;

		public static SaveData_Level SaveData_Level;

		public static Dictionary<int, FruitCutLevel> LevelDataDic = new Dictionary<int, FruitCutLevel>();

		public static Dictionary<int, FruitCutStrength> StrengthDataDic = new Dictionary<int, FruitCutStrength>();

		public static int curLevelID;

		public static int curStrengthID;

		public static float gameDuration;

		public static float gameDurationed;

		public static int curScore;

		public static string startLevel;

		public static string minLevel;

		public static string maxLevel;

		public static int allPass;

		public static int perfectNum;

		public static int continuateMaxNum;

		public static int totalFruitNum;

		public static int cutFruitNum;

		public static int totalStoneNum;

		public static int noHitNum;

		public static bool IsStartGame = false;

		private static string dataFile_QSG_Level => datasFolder + "/QSG_LevelDatas.json";

		public static FruitCutLevel CurFruitCutLevel => LevelDataDic[curLevelID];

		public static FruitCutStrength CurFruitCutStrength => StrengthDataDic[curStrengthID];

		public static int GetScore => (int)((float)CurFruitCutLevel.BaseScore * (1f + CurFruitCutStrength.ScoreAddition));

		public static int GetFruitNum
		{
			get
			{
				if (CurFruitCutLevel.IsNumAdd != 0)
				{
					return CurFruitCutLevel.InitialNum + CurFruitCutStrength.FruitAddition;
				}
				return CurFruitCutLevel.InitialNum;
			}
		}

		public static float GetSpeed
		{
			get
			{
				if (CurFruitCutLevel.IsSpeedAdd != 0)
				{
					return CurFruitCutLevel.InitialSpeed * (1f + CurFruitCutStrength.SpeedAddition);
				}
				return CurFruitCutLevel.InitialSpeed;
			}
		}

		public static int GetStoneNum
		{
			get
			{
				if (CurFruitCutLevel.IsStone != 0)
				{
					return CurFruitCutStrength.StoneNumber;
				}
				return 0;
			}
		}

		public static string GetCurLevel => LevelDataDic[curLevelID].LevelName + "-" + StrengthDataDic[curStrengthID].StrengthGrade;

		public static void StartTheLevel(CourseDetail.Data data)
		{
			if (data != null)
			{
				if (data.game_data == null)
				{
					string text = data.level + "-" + data.strength;
					InitData(data.level, data.strength, data.play_time, data.already_play_time, data.point, 0, 0, 0, 0, 0, 0, 0, text, text, text);
				}
				else
				{
					GameRecordData gameRecordData = J_LitJson.JsonMapper.ToObject<GameRecordData>(data.game_data);
					InitData(data.level, data.strength, data.play_time, data.already_play_time, data.point, gameRecordData.AllPass, gameRecordData.PerfectNum, gameRecordData.ContinuateMaxNum, gameRecordData.CutFruitNum, gameRecordData.TotalFruitNum, gameRecordData.NoHitNum, gameRecordData.TotalStoneNum, gameRecordData.InitLevel, gameRecordData.MaxLevel, gameRecordData.MinLevel);
				}
			}
			else
			{
				string text2 = LoadManager.LevelID + "-" + LoadManager.StrengthID;
				InitData(LoadManager.LevelID, LoadManager.StrengthID, LoadManager.Duration, 0, 0, 0, 0, 0, 0, 0, 0, 0, text2, text2, text2);
			}
			GameManager18_QSG_ADHD.Inst.StartTheGame();
		}

		private static void InitData(int level, int strength, int duration, int durationed, int score, int allpass, int perfect, int continuate, int cutfruit, int totalfruit, int nohit, int totalstone, string start, string max, string min)
		{
			curLevelID = level;
			curStrengthID = strength;
			gameDuration = duration;
			gameDurationed = durationed;
			curScore = score;
			allPass = allpass;
			perfectNum = perfect;
			continuateMaxNum = continuate;
			cutFruitNum = cutfruit;
			totalFruitNum = totalfruit;
			noHitNum = nohit;
			totalStoneNum = totalstone;
			startLevel = start;
			maxLevel = max;
			minLevel = min;
		}

		public static void OverTheGame()
		{
			IsStartGame = false;
			QSG_MainMenuUICtrl.Inst.J_ShowFinalUI();
		}

		public static string GetInitChallengeLevel()
		{
			string[] array = startLevel.Split('-');
			return LevelDataDic[int.Parse(array[0])].LevelName + "-" + StrengthDataDic[int.Parse(array[1])].StrengthGrade;
		}

		public static string GetMaxChallengeLevel()
		{
			string[] array = maxLevel.Split('-');
			return LevelDataDic[int.Parse(array[0])].LevelName + "-" + StrengthDataDic[int.Parse(array[1])].StrengthGrade;
		}

		public static string GetMinChallengeLevel()
		{
			string[] array = minLevel.Split('-');
			return LevelDataDic[int.Parse(array[0])].LevelName + "-" + StrengthDataDic[int.Parse(array[1])].StrengthGrade;
		}

		public static void AddStrength(int upshift)
		{
			curStrengthID += upshift;
			if (curStrengthID > 9)
			{
				if (LoadManager.IsLocalOperate && curLevelID >= LoadManager.MaxLevelID)
				{
					curStrengthID = 9;
				}
				else if (curLevelID >= LevelDataDic.Count - 1)
				{
					curStrengthID = 9;
				}
				else
				{
					curStrengthID -= 10;
					curLevelID++;
				}
			}
			SetMaxLevel();
			QSG_MainMenuUICtrl.Inst.LevelTxt.text = GetCurLevel;
			LoadManager.SubmitLevelRecord(curLevelID, curStrengthID, QSG_MainMenuUICtrl.Inst.GetUseDuration(), curScore, J_LitJson.JsonMapper.ToJson(GetGameRecord()));
		}

		public static void ReduceStrength(int downshift)
		{
			curStrengthID -= downshift;
			if (curStrengthID < 0)
			{
				if (curLevelID <= 0)
				{
					curStrengthID = 0;
				}
				else
				{
					curStrengthID += 10;
					curLevelID--;
				}
			}
			SetMinLevel();
			QSG_MainMenuUICtrl.Inst.LevelTxt.text = GetCurLevel;
			LoadManager.SubmitLevelRecord(curLevelID, curStrengthID, QSG_MainMenuUICtrl.Inst.GetUseDuration(), curScore, J_LitJson.JsonMapper.ToJson(GetGameRecord()));
		}

		private static void SetMaxLevel()
		{
			string[] array = maxLevel.Split('-');
			int num = int.Parse(array[0]);
			int num2 = int.Parse(array[1]);
			if (curLevelID == num)
			{
				if (curStrengthID > num2)
				{
					maxLevel = curLevelID + "-" + curStrengthID;
				}
			}
			else if (curLevelID > num)
			{
				maxLevel = curLevelID + "-" + curStrengthID;
			}
		}

		private static void SetMinLevel()
		{
			string[] array = minLevel.Split('-');
			int num = int.Parse(array[0]);
			int num2 = int.Parse(array[1]);
			if (curLevelID == num)
			{
				if (curStrengthID < num2)
				{
					minLevel = curLevelID + "-" + curStrengthID;
				}
			}
			else if (curLevelID < num)
			{
				minLevel = curLevelID + "-" + curStrengthID;
			}
		}

		public static void AddScore(int score)
		{
			curScore += score;
			QSG_MainMenuUICtrl.Inst.CurScoreTxt.text = curScore.ToString();
		}

		public static void SetChanglleNum(int missMun)
		{
			int num = CurFruitCutLevel.ChallengeNum - missMun;
			QSG_MainMenuUICtrl.Inst.ChanglleNumTxt.text = ((num == 0) ? 1 : num).ToString();
		}

		public static void J_SaveLevelData(string levelid, bool isComplete, int iProgress)
		{
			SaveData_Level.clevel clevel = null;
			for (int i = 0; i < SaveData_Level.data.Count; i++)
			{
				if (levelid == SaveData_Level.data[i].level.ToString())
				{
					clevel = SaveData_Level.data[i];
					break;
				}
			}
			if (clevel == null)
			{
				clevel = new SaveData_Level.clevel();
				clevel.level = int.Parse(levelid);
				SaveData_Level.data.Add(clevel);
			}
			if ((float)iProgress > clevel.progress)
			{
				clevel.progress = iProgress;
			}
			if (LoadManager.IsLocalOperate)
			{
				File.WriteAllText(dataFile_QSG_Level, J_LitJson.JsonMapper.ToJson(SaveData_Level));
				return;
			}
			string url = UrlUtils.baseUrl_adhd + UrlUtils.progress;
			WWWForm wWWForm = new WWWForm();
			wWWForm.AddField("deviceuniqueID", LoadManager.deviceUniqueIdentifier);
			wWWForm.AddField("game", "fruit");
			wWWForm.AddField("level", int.Parse(levelid));
			wWWForm.AddField("progress", iProgress);
			UnityWebRequestHelper.Instance.Post(url, wWWForm, delegate(RequestStatus status, string result)
			{
				if (status == RequestStatus.fail)
				{
					int value = int.Parse(J_LitJson.JsonMapper.ToObject(result)["code"].ToString());
					new int[4] { 401, 3001, 3002, 3004 }.Contains(value);
				}
			}, isToken: true);
		}

		public static void SaveCheckpointRecord(int level, int cpid, int pass, int checkpoint_time, int consume_time, int no_avoid_freq, int deduct_time, int best_combo, int total_points, int time_threshold, int time_score, int time_remain, int miss_limit_times, int no_miss_score, int miss_times)
		{
			if (LoadManager.IsLocalOperate)
			{
				return;
			}
			string url = UrlUtils.baseUrl_adhd + UrlUtils.recordFruit;
			WWWForm wWWForm = new WWWForm();
			wWWForm.AddField("deviceuniqueID", LoadManager.deviceUniqueIdentifier);
			wWWForm.AddField("level", level);
			wWWForm.AddField("cpid", cpid);
			wWWForm.AddField("cpindex", GetCheckpointIndex(level, cpid));
			wWWForm.AddField("pass", pass);
			wWWForm.AddField("checkpoint_time", checkpoint_time);
			wWWForm.AddField("consume_time", consume_time);
			wWWForm.AddField("no_avoid_freq", no_avoid_freq);
			wWWForm.AddField("deduct_time", deduct_time);
			wWWForm.AddField("best_combo", best_combo);
			wWWForm.AddField("consume_record", J_LitJson.JsonMapper.ToJson(new CustomRecordData()));
			wWWForm.AddField("total_points", total_points);
			wWWForm.AddField("time_threshold", time_threshold);
			wWWForm.AddField("time_score", time_score);
			wWWForm.AddField("time_remain", time_remain);
			wWWForm.AddField("miss_limit_times", miss_limit_times);
			wWWForm.AddField("no_miss_score", no_miss_score);
			wWWForm.AddField("miss_times", miss_times);
			UnityWebRequestHelper.Instance.Post(url, wWWForm, delegate(RequestStatus status, string result)
			{
				if (status == RequestStatus.fail)
				{
					int value = int.Parse(J_LitJson.JsonMapper.ToObject(result)["code"].ToString());
					new int[4] { 401, 3001, 3002, 3004 }.Contains(value);
				}
			}, isToken: true);
		}

		private static int GetCheckpointIndex(int levelId, int checkpointId)
		{
			return 0;
		}

		public static GameRecordData GetGameRecord()
		{
			return new GameRecordData
			{
				InitLevel = minLevel,
				MaxLevel = maxLevel,
				MinLevel = minLevel,
				AllPass = allPass,
				PerfectNum = perfectNum,
				ContinuateMaxNum = continuateMaxNum,
				CutFruitNum = cutFruitNum,
				TotalFruitNum = totalFruitNum,
				NoHitNum = noHitNum,
				TotalStoneNum = totalStoneNum
			};
		}
	}
	public class qsg_item_LevelSelection : MonoBehaviour
	{
		public Image m_imgProgress;

		public TextMeshProUGUI m_txtpro_Progress;

		public GameObject m_objSucceed;

		public TextMeshProUGUI m_txtpro_LevelName;

		public GameObject m_objLock;

		public Button m_btnSelect;
	}
	public class QSG_MainMenuUICtrl : MonoBehaviour
	{
		[Serializable]
		public class cpanelSucceedUI
		{
			public TextMeshProUGUI ScoreTxt;

			public Text TrainingDurationTxt;

			public Text InitChallengeLevelTxt;

			public Text MaxChallengeLevelTxt;

			public Text MinChallengeLevelTxt;

			public Text AllPassTxt;

			public Text PerfectNumTxt;

			public Text ContinuateMaxNumTxt;

			public Text TotalFruitNumTxt;

			public Text CorrectRateTxt;

			public Text TotalStoneNumTxt;

			public Text StoneEvadeTxt;

			public Button m_btnCancle;
		}

		[Serializable]
		public class cpanelSuppendUI
		{
			public Button m_btnContinuePlay;

			public Button m_btnReturn;
		}

		[Header("测试模式")]
		[Tooltip("测试模式，打开所有关卡，发布时请隐藏")]
		public bool isTestEditorMode;

		public static QSG_MainMenuUICtrl Inst;

		[Header("StartGame UI Panel")]
		public GameObject m_panelStartGame;

		public ToggleGroup toggleGroup;

		public Button m_btnStart;

		public Button m_btnExit;

		public AudioSource bgAudioSource;

		[Header("游戏界面")]
		public GameObject ScorePanel;

		public Text CurScoreTxt;

		public Text LevelTxt;

		public Text TotalTimeTxt;

		public Text ChanglleNumTxt;

		[Header("Succeed UI Panel")]
		public GameObject m_panelSucceed;

		public cpanelSucceedUI m_panelSucceedUI;

		[Header("Suppend UI Panel")]
		public GameObject m_panelGameSusppend;

		public cpanelSuppendUI m_panelSuppendUI;

		[Header("退出提示界面")]
		public GameObject ExitTipPanel;

		public Button defineBtn;

		public Button cancelBtn;

		public AudioSource audioSource;

		public AudioClip[] audioClips;

		private float checkTime;

		private float fChcekTimer;

		private void Start()
		{
			Inst = this;
			ScorePanel.SetActive(value: false);
			m_btnStart.onClick.AddListener(J_StartGame);
			m_btnExit.onClick.AddListener(J_QuitScene);
			m_panelSucceedUI.m_btnCancle.onClick.AddListener(CancelBtnHander);
			m_panelSuppendUI.m_btnContinuePlay.onClick.AddListener(delegate
			{
				PauseGame(isPause: false);
			});
			m_panelSuppendUI.m_btnReturn.onClick.AddListener(SuspendReturnStartBtnHander);
			defineBtn.onClick.AddListener(DefineBtnHander);
			cancelBtn.onClick.AddListener(CancelTipBtnHander);
			for (int i = 0; i < toggleGroup.transform.childCount; i++)
			{
				int index = i;
				Toggle component = toggleGroup.transform.GetChild(i).GetComponent<Toggle>();
				component.onValueChanged.AddListener(delegate(bool value)
				{
					if (value)
					{
						LoadManager.LevelID = index;
					}
				});
				if (LoadManager.LevelID == index)
				{
					component.isOn = true;
				}
			}
			GameManager18_QSG_ADHD.Inst.InitData();
			if (LoadManager.IsLocalOperate)
			{
				m_panelStartGame.SetActive(value: true);
				return;
			}
			m_panelStartGame.SetActive(value: false);
			J_StartGame(LoadManager.course);
		}

		private void CancelBtnHander()
		{
			if (LoadManager.IsLocalOperate)
			{
				bgAudioSource.Stop();
				m_panelStartGame.SetActive(value: true);
				m_panelSucceed.SetActive(value: false);
			}
			else
			{
				LoadManager.SubmitEndRecord(isComplete: true, isLogout: false, GetUseDuration(isComplete: true), QSG_GameDataManager.curScore, J_LitJson.JsonMapper.ToJson(QSG_GameDataManager.GetGameRecord()));
			}
		}

		private void _CloseAllUIPanel()
		{
			m_panelStartGame.SetActive(value: false);
			m_panelSucceed.SetActive(value: false);
			m_panelGameSusppend.SetActive(value: false);
		}

		private void Update()
		{
			if (Time.timeScale == 1f && !Inst.m_panelGameSusppend.activeInHierarchy && Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.APP))
			{
				UnityEngine.Debug.Log(1);
				PauseGame(isPause: true);
			}
		}

		public void PauseGame(bool isPause)
		{
			if (isPause)
			{
				Time.timeScale = 0f;
				GameManager18_QSG_ADHD.Inst.ShowHandRays(isshow: true);
				m_panelGameSusppend.SetActive(value: true);
			}
			else
			{
				GameManager18_QSG_ADHD.Inst.ShowHandRays(isshow: false);
				m_panelGameSusppend.SetActive(value: false);
				Time.timeScale = 1f;
			}
		}

		private void FixedUpdate()
		{
		}

		public void J_ShowFinalUI()
		{
			PlayAudioSound(2);
			GameManager18_QSG_ADHD.Inst.ShowHandRays(isshow: true);
			m_panelSucceed.SetActive(value: true);
			ScorePanel.SetActive(value: false);
			m_panelSucceedUI.ScoreTxt.text = QSG_GameDataManager.curScore.ToString();
			m_panelSucceedUI.TrainingDurationTxt.text = LoadManager.TimeConversion((int)QSG_GameDataManager.gameDuration);
			m_panelSucceedUI.InitChallengeLevelTxt.text = QSG_GameDataManager.GetInitChallengeLevel();
			m_panelSucceedUI.MaxChallengeLevelTxt.text = QSG_GameDataManager.GetMaxChallengeLevel();
			m_panelSucceedUI.MinChallengeLevelTxt.text = QSG_GameDataManager.GetMinChallengeLevel();
			m_panelSucceedUI.AllPassTxt.text = QSG_GameDataManager.allPass.ToString();
			m_panelSucceedUI.PerfectNumTxt.text = QSG_GameDataManager.perfectNum.ToString();
			m_panelSucceedUI.ContinuateMaxNumTxt.text = QSG_GameDataManager.continuateMaxNum.ToString();
			m_panelSucceedUI.TotalFruitNumTxt.text = QSG_GameDataManager.totalFruitNum.ToString();
			m_panelSucceedUI.CorrectRateTxt.text = Math.Round((float)QSG_GameDataManager.cutFruitNum / (float)QSG_GameDataManager.totalFruitNum, 4) * 100.0 + "%";
			m_panelSucceedUI.TotalStoneNumTxt.text = QSG_GameDataManager.totalStoneNum.ToString();
			m_panelSucceedUI.StoneEvadeTxt.text = ((QSG_GameDataManager.totalStoneNum == 0) ? "0.00%" : (Math.Round((float)QSG_GameDataManager.noHitNum / (float)QSG_GameDataManager.totalStoneNum, 4) * 100.0 + "%"));
		}

		public void PlayAudioSound(int index)
		{
			if (audioSource.isPlaying)
			{
				audioSource.Stop();
			}
			audioSource.clip = audioClips[index];
			audioSource.Play();
		}

		public void J_StartGame()
		{
			J_StartGame(null);
		}

		public void J_StartGame(CourseDetail.Data data)
		{
			Time.timeScale = 1f;
			bgAudioSource.Play();
			ScorePanel.SetActive(value: true);
			m_panelStartGame.SetActive(value: false);
			QSG_GameDataManager.SetChanglleNum(0);
			QSG_GameDataManager.StartTheLevel(data);
			CurScoreTxt.text = QSG_GameDataManager.curScore.ToString();
			LevelTxt.text = QSG_GameDataManager.GetCurLevel;
			TotalTimeTxt.text = LoadManager.TimeConversion((int)(QSG_GameDataManager.gameDuration - QSG_GameDataManager.gameDurationed));
		}

		public void J_QuitScene()
		{
			Time.timeScale = 1f;
			ScorePanel.SetActive(value: false);
			SceneManager.LoadScene(ScenesHelper.WeiAiZhiCenterScene);
		}

		public int GetUseDuration(bool isComplete = false)
		{
			float num = QSG_GameDataManager.gameDuration - GameManager18_QSG_ADHD.Inst.surplusGameDuration;
			num = (isComplete ? QSG_GameDataManager.gameDuration : num);
			return (int)num;
		}

		public void SuspendReturnStartBtnHander()
		{
			if (LoadManager.IsLocalOperate)
			{
				Time.timeScale = 1f;
				m_panelStartGame.SetActive(value: true);
				m_panelGameSusppend.SetActive(value: false);
				ScorePanel.SetActive(value: false);
			}
			else
			{
				ExitTipPanel.SetActive(value: true);
			}
		}

		public void CheckBattery(Action continueAction)
		{
			if (GameManager18_QSG_ADHD.Inst.batteryTipController.CheckBattery(continueAction))
			{
				SuspendGame(suspend: true);
			}
		}

		public void SuspendGame(bool suspend)
		{
			GameManager18_QSG_ADHD.Inst.ShowHandRays(suspend);
			Time.timeScale = ((!suspend) ? 1 : 0);
		}

		private void DefineBtnHander()
		{
			Time.timeScale = 1f;
			LoadManager.SubmitEndRecord(isComplete: false, isLogout: false, GetUseDuration(), QSG_GameDataManager.curScore, J_LitJson.JsonMapper.ToJson(QSG_GameDataManager.GetGameRecord()));
		}

		private void CancelTipBtnHander()
		{
			ExitTipPanel.SetActive(value: false);
		}
	}
}
namespace EyeTrain
{
	public class DolphinController : MonoBehaviour
	{
		public Animation ani;

		public ParticleSystem chu;

		public ParticleSystem ru;

		private float timer;

		private void Start()
		{
			timer = UnityEngine.Random.Range(5f, 20f);
		}

		private void Update()
		{
			timer -= Time.deltaTime;
			if (timer <= 0f)
			{
				PlayAnimation();
				timer = UnityEngine.Random.Range(5f, 20f);
			}
		}

		private void PlayAnimation()
		{
			ani.Play();
			chu.Play();
			DelayHander(1.1f, delegate
			{
				ru.Play();
			});
		}

		private void DelayHander(float time, Action action)
		{
			StartCoroutine(Wait(time, action));
		}

		private IEnumerator Wait(float time, Action action)
		{
			yield return new WaitForSeconds(time);
			action?.Invoke();
		}
	}
	public class EyeBallItem : MonoBehaviour
	{
		public Image eyeImg;

		public Sprite[] sprites;

		public Vector3 moveDir;

		public Direction direction;

		private void Start()
		{
		}

		private void Update()
		{
		}

		public void SetDirection(Direction dir)
		{
			direction = dir;
			eyeImg.sprite = sprites[Convert.ToInt32(dir)];
		}

		public void SetMoveDir(int index)
		{
			switch (index)
			{
			case 0:
				moveDir = new Vector3(1f, 1f, 1f);
				break;
			case 1:
				moveDir = new Vector3(1f, 1f, -1f);
				break;
			case 2:
				moveDir = new Vector3(-1f, 1f, -1f);
				break;
			case 3:
				moveDir = new Vector3(-1f, 1f, 1f);
				break;
			case 4:
				moveDir = new Vector3(1f, -1f, 1f);
				break;
			case 5:
				moveDir = new Vector3(1f, -1f, -1f);
				break;
			case 6:
				moveDir = new Vector3(-1f, -1f, -1f);
				break;
			case 7:
				moveDir = new Vector3(-1f, -1f, 1f);
				break;
			}
		}
	}
	public enum Direction
	{
		Up,
		Down,
		Left,
		Right
	}
	public class EyeTrainController : MonoBehaviour
	{
		public static EyeTrainController Instance;

		public GameObject rightHand;

		public GameObject ball_center;

		public ParticleSystem sparks;

		public ParticleSystem sparks_small;

		public List<GameObject> balls;

		public Transform ballRoot;

		public float fBallRaidus = 0.5f;

		public Vector3 vlimitAreaSize = new Vector3(5f, 5f, 5f);

		public float xy_speed = 1f;

		public AudioSource audioSource;

		public AudioClip[] audioClips;

		private List<EyeBallItem> listBalls;

		private Direction curDirection;

		private int rightNum;

		private bool isTraining;

		private Ray ray;

		private RaycastHit hit;

		private bool isCheckBall;

		private float timer;

		private void Awake()
		{
			Instance = this;
		}

		private void Start()
		{
			listBalls = new List<EyeBallItem>();
		}

		private void Update()
		{
			if (!UIController.Instance.isStart)
			{
				Vector2 vector = Controller.UPvr_GetAxis2D(1);
				if (vector.y == 0f || ((double)ballRoot.position.x > -9.6 && vector.y > 0f) || ((double)ballRoot.position.x < -19.6 && vector.y < 0f))
				{
					return;
				}
				ballRoot.position = new Vector3(ballRoot.position.x + vector.y * 2f * Time.deltaTime, ballRoot.position.y, ballRoot.position.z);
			}
			if (isTraining)
			{
				if (!isCheckBall)
				{
					timer -= Time.deltaTime;
					if (timer <= 0f)
					{
						isCheckBall = true;
					}
				}
				if (Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.TRIGGER) || Input.GetKeyDown(KeyCode.Space))
				{
					ray.direction = rightHand.transform.forward;
					ray.origin = rightHand.transform.position;
					if (Physics.Raycast(ray, out hit, 100f, 1 << LayerMask.NameToLayer("Keys")))
					{
						EyeBallItem component = hit.transform.parent.GetComponent<EyeBallItem>();
						if (component.direction == curDirection)
						{
							rightNum--;
							audioSource.clip = audioClips[0];
							audioSource.Play();
							if (rightNum != 0)
							{
								ClearBall(component);
								return;
							}
							isTraining = false;
							ClearBalls();
							ball_center.SetActive(value: true);
							DelayHander(1f, delegate
							{
								StartEyeTrain();
							});
						}
						else
						{
							audioSource.clip = audioClips[1];
							audioSource.Play();
							Controller.UPvr_VibrateNeo2Controller(0.5f, 50, Pvr_ControllerManager.controllerlink.mainHandID);
						}
					}
				}
			}
			Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.APP);
		}

		public void StartEyeTrain()
		{
			isCheckBall = false;
			timer = 2f;
			ball_center.SetActive(value: false);
			sparks.Play();
			audioSource.clip = audioClips[0];
			audioSource.Play();
			int num = (int)(curDirection = (Direction)UnityEngine.Random.Range(0, 4));
			UIController.Instance.SetDirection(curDirection);
			rightNum = 0;
			for (int i = 0; i < 8; i++)
			{
				int index = UnityEngine.Random.Range(0, 3);
				GameObject obj = UnityEngine.Object.Instantiate(balls[index], ballRoot);
				obj.transform.localPosition = Vector3.zero;
				obj.SetActive(value: true);
				EyeBallItem component = obj.GetComponent<EyeBallItem>();
				listBalls.Add(component);
				int num2 = ((rightNum >= 3) ? RandomRange(num) : ((rightNum != 0 || i != 7) ? RandomRange(4) : num));
				component.SetDirection((Direction)num2);
				component.SetMoveDir(i);
				if (num2 == num)
				{
					rightNum++;
				}
			}
			isTraining = true;
		}

		public void ClearBall(EyeBallItem item)
		{
			GameObject par = UnityEngine.Object.Instantiate(sparks_small.gameObject);
			par.transform.position = item.transform.position;
			par.GetComponent<ParticleSystem>().Play();
			listBalls.Remove(item);
			UnityEngine.Object.Destroy(item.gameObject);
			DelayHander(1f, delegate
			{
				UnityEngine.Object.Destroy(par);
			});
		}

		public void ClearBalls()
		{
			List<GameObject> sps = new List<GameObject>();
			foreach (EyeBallItem listBall in listBalls)
			{
				GameObject gameObject = UnityEngine.Object.Instantiate(sparks_small.gameObject);
				gameObject.transform.position = listBall.transform.position;
				sps.Add(gameObject);
				gameObject.GetComponent<ParticleSystem>().Play();
				UnityEngine.Object.Destroy(listBall.gameObject);
			}
			listBalls.Clear();
			DelayHander(1f, delegate
			{
				foreach (GameObject item in sps)
				{
					UnityEngine.Object.Destroy(item.gameObject);
				}
				sps.Clear();
			});
		}

		private int RandomRange(int not)
		{
			int num = UnityEngine.Random.Range(0, 3);
			if (num == not)
			{
				return RandomRange(not);
			}
			return num;
		}

		private void LateUpdate()
		{
			if (!isTraining)
			{
				return;
			}
			foreach (EyeBallItem listBall in listBalls)
			{
				Vector3 localPosition = listBall.gameObject.transform.localPosition;
				listBall.gameObject.transform.localScale = Vector3.MoveTowards(listBall.gameObject.transform.localScale, Vector3.one * fBallRaidus * 2f, 0.05f);
				if (Mathf.Abs(listBall.transform.localPosition.x) + fBallRaidus >= vlimitAreaSize.x)
				{
					listBall.moveDir.x = 0f - listBall.moveDir.x;
				}
				if (Mathf.Abs(listBall.transform.localPosition.y) + fBallRaidus >= vlimitAreaSize.y)
				{
					listBall.moveDir.y = 0f - listBall.moveDir.y;
				}
				if (Mathf.Abs(listBall.transform.localPosition.z) + fBallRaidus >= vlimitAreaSize.z)
				{
					listBall.moveDir.z = 0f - listBall.moveDir.z;
				}
				if (isCheckBall)
				{
					foreach (EyeBallItem listBall2 in listBalls)
					{
						if (listBall2 != listBall)
						{
							Vector3 localPosition2 = listBall2.transform.localPosition;
							Vector3 localPosition3 = listBall.transform.localPosition;
							Vector3 vector = localPosition3 - localPosition2;
							if (Vector3.Distance(localPosition2, localPosition3) <= fBallRaidus * 2f)
							{
								listBall.moveDir = vector.normalized;
								listBall2.moveDir = -listBall.moveDir;
								break;
							}
						}
					}
				}
				Vector3 vector2 = listBall.moveDir * xy_speed;
				localPosition += vector2 * Time.deltaTime;
				listBall.transform.localPosition = localPosition;
			}
		}

		public void DelayHander(float time, Action action)
		{
			StartCoroutine(Wait(time, action));
		}

		private IEnumerator Wait(float time, Action action)
		{
			yield return new WaitForSeconds(time);
			action?.Invoke();
		}
	}
	public class UIController : MonoBehaviour
	{
		public static UIController Instance;

		public GameObject canvasObj;

		public Button startBtn;

		public Text countDownTxt;

		public RectTransform eyeImg;

		public bool isStart;

		public float timer = 120f;

		private void Awake()
		{
			Instance = this;
		}

		private void Start()
		{
			startBtn.onClick.AddListener(StartBtnHander);
		}

		private void Update()
		{
			if (Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.APP))
			{
				ScenesHelper.LoadScene(ScenesHelper.WeiAiZhiCenterScene);
			}
			if (isStart)
			{
				timer -= Time.deltaTime;
				countDownTxt.text = LoadManager.TimeConversion((int)timer);
				if (timer <= 0f)
				{
					isStart = false;
					canvasObj.SetActive(value: true);
					countDownTxt.gameObject.SetActive(value: false);
					eyeImg.gameObject.SetActive(value: false);
					EyeTrainController.Instance.ClearBalls();
				}
			}
		}

		public void SetDirection(Direction dir)
		{
			switch (dir)
			{
			case Direction.Up:
				eyeImg.localEulerAngles = new Vector3(0f, 0f, 90f);
				break;
			case Direction.Down:
				eyeImg.localEulerAngles = new Vector3(0f, 0f, 270f);
				break;
			case Direction.Left:
				eyeImg.localEulerAngles = new Vector3(0f, 0f, 180f);
				break;
			case Direction.Right:
				eyeImg.localEulerAngles = new Vector3(0f, 0f, 0f);
				break;
			}
		}

		private void StartBtnHander()
		{
			isStart = true;
			timer = 120f;
			canvasObj.SetActive(value: false);
			countDownTxt.gameObject.SetActive(value: true);
			eyeImg.gameObject.SetActive(value: true);
			EyeTrainController.Instance.StartEyeTrain();
		}

		private void ExitBtnHander()
		{
		}
	}
}
namespace ElectricRing
{
	public class BraceletController : MonoBehaviour
	{
		public static BraceletController Instance;

		public Transform countDownTra;

		public Text countDownTxt;

		public RigidbodyOffsetMove rigidbodyMove;

		public ParticleSystem sparkParticle;

		public MeshRenderer[] childsTra;

		public Transform centerTra;

		public GetPathProcess getPathProcess;

		private bool isFollowToHand;

		private Vector3 offsetPos;

		private int continuateNum;

		public float radius = 1f;

		private float maxDis = 0.03f;

		private float checkTimer = 0.1f;

		private void Awake()
		{
			Instance = this;
		}

		private void Start()
		{
		}

		private void Update()
		{
			if (isFollowToHand)
			{
				checkTimer -= Time.deltaTime;
				if (checkTimer <= 0f)
				{
					checkTimer = 0.1f;
					SetBraceletColor();
				}
				return;
			}
			if (Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.Right))
			{
				Pvr_UnitySDKSensor.Instance.ResetUnitySDKSensor();
			}
			Vector2 vector = Controller.UPvr_GetAxis2D(1);
			if (vector.y > 0f)
			{
				RingRootController.Instance.transform.position += Vector3.up * Time.deltaTime * 0.1f;
				base.transform.position += Vector3.up * Time.deltaTime * 0.1f;
			}
			else if (vector.y < 0f)
			{
				RingRootController.Instance.transform.position -= Vector3.up * Time.deltaTime * 0.1f;
				base.transform.position -= Vector3.up * Time.deltaTime * 0.1f;
			}
		}

		public void OnPipeGrabbed()
		{
			if (isFollowToHand)
			{
				return;
			}
			isFollowToHand = true;
			RingRootController.Instance.handAnimator.SetBool("isGrabbing", value: true);
			countDownTra.gameObject.SetActive(value: true);
			RingRootController.Instance.SetCountDownPos(countDownTra);
			countDownTxt.text = "3";
			PlayerController.Instance.DelayHander(1f, delegate
			{
				countDownTxt.text = "2";
				PlayerController.Instance.DelayHander(1f, delegate
				{
					countDownTxt.text = "1";
					PlayerController.Instance.DelayHander(1f, delegate
					{
						countDownTra.gameObject.SetActive(value: false);
						RingRootController.Instance.handAnimator.SetBool("isGrabbing", value: false);
						RingRootController.Instance.handAnimator.gameObject.SetActive(value: false);
						offsetPos = RingRootController.Instance.rightHand.transform.position - base.transform.position;
						rigidbodyMove.StartFollow(offsetPos);
						UIController.Instance.IsStartTime();
					});
				});
			});
		}

		public void OnReleaseGrabbed()
		{
			countDownTra.gameObject.SetActive(value: false);
			isFollowToHand = false;
			rigidbodyMove.StopFollow();
			RingRootController.Instance.handAnimator.SetBool("isGrabbing", value: false);
		}

		public int GetProcess()
		{
			return (int)(getPathProcess.GetProjectionSample(base.transform.position) * 100f);
		}

		private void OnCollisionEnter(UnityEngine.Collision collision)
		{
			if (!isFollowToHand || !RingRootController.Instance.CheckIsInsulation(collision.transform))
			{
				return;
			}
			isFollowToHand = false;
			CheckpointManager.IsPlayGame = false;
			RingRootController.Instance.handAnimator.gameObject.SetActive(value: true);
			sparkParticle.gameObject.SetActive(value: true);
			sparkParticle.Play();
			UIController.Instance.PlayAudioSound(1);
			rigidbodyMove.StopFollow();
			RingRootController.Instance.AddStaminas();
			PlayerController.Instance.DelayHander(1f, delegate
			{
				continuateNum = 0;
				sparkParticle.gameObject.SetActive(value: false);
				if (RingRootController.Instance.IsChallengeFail)
				{
					RingRootController.Instance.SetStaminas();
					CheckpointManager.ReduceStrength(CheckpointManager.CurElectricLevel.DownshiftGrade);
					RingRootController.Instance.ChallengeFinish();
				}
				else
				{
					RingRootController.Instance.ResetBraceletPos();
				}
				InitBraceletColor();
			});
			_ = ref collision.contacts[0];
			UIController.Instance.ErrorAnswer(0f);
			Controller.UPvr_VibrateNeo2Controller(0.5f, 50, Pvr_ControllerManager.controllerlink.mainHandID);
		}

		private void OnTriggerEnter(Collider other)
		{
			if (!isFollowToHand)
			{
				return;
			}
			if (RingRootController.Instance.CheckIsCheckPoint(other.transform))
			{
				RingRootController.Instance.ArriveCheckPoint(other.transform);
			}
			else
			{
				if (!RingRootController.Instance.CheckIsFinsh(other.transform))
				{
					return;
				}
				isFollowToHand = false;
				CheckpointManager.IsPlayGame = false;
				CheckpointManager.allPass++;
				int num = ((!RingRootController.Instance.IsPerfectPass) ? 1 : 2);
				if (RingRootController.Instance.IsPerfectPass)
				{
					CheckpointManager.perfectNum++;
					continuateNum++;
					if (continuateNum > CheckpointManager.continuateMaxNum)
					{
						CheckpointManager.continuateMaxNum = continuateNum;
					}
				}
				else
				{
					continuateNum = 0;
				}
				CheckpointManager.AddScore(CheckpointManager.GetScore * num);
				int upshift = CheckpointManager.CurElectricLevel.UpshiftGrade * num;
				RingRootController.Instance.AddStaminas(isEnd: true);
				RingRootController.Instance.SetStaminas();
				CheckpointManager.AddStrength(upshift);
				RingRootController.Instance.endParticle.gameObject.SetActive(value: true);
				RingRootController.Instance.endParticle.Play();
				UIController.Instance.PlayAudioSound((num == 1) ? 2 : 3);
				UIController.Instance.IsStartTime(isStart: false);
				PlayerController.Instance.DelayHander(1f, delegate
				{
					RingRootController.Instance.ChallengeFinish();
				});
			}
		}

		private void SetBraceletColor()
		{
			MeshRenderer[] array = childsTra;
			foreach (MeshRenderer meshRenderer in array)
			{
				if (Physics.Linecast(meshRenderer.transform.position, centerTra.position, out var hitInfo, 1))
				{
					if (hitInfo.distance > radius)
					{
						meshRenderer.material.color = new Color(meshRenderer.material.color.r, 1f, meshRenderer.material.color.b);
					}
					else
					{
						meshRenderer.material.color = new Color(meshRenderer.material.color.r, hitInfo.distance / radius, meshRenderer.material.color.b);
					}
				}
				else
				{
					meshRenderer.material.color = new Color(meshRenderer.material.color.r, 1f, meshRenderer.material.color.b);
				}
			}
		}

		private void InitBraceletColor()
		{
			MeshRenderer[] array = childsTra;
			foreach (MeshRenderer meshRenderer in array)
			{
				meshRenderer.material.color = new Color(meshRenderer.material.color.r, 1f, meshRenderer.material.color.b);
			}
		}
	}
	public class LevelData
	{
		public int Levelid;

		public string LevelName;

		public List<int> CheckpointArray;

		public int NextLevelid;
	}
	public class CheckpointData
	{
		public int CheckpointID;

		public string MazeName;

		public float ChallengeTime;

		public int PunishTime;

		public int TimeThreshold;

		public int TimeScore;

		public int MissLimitTimes;

		public int NoMissScore;
	}
	public class ElectricLevel
	{
		public int LevelID;

		public string LevelName;

		public List<int> RandomLevel;

		public int BaseScore;

		public int ChallengeNum;

		public int TimeReduction;

		public int HandChange;

		public int HorizontalFlip;

		public int VerticalFlip;

		public int UpshiftRequire;

		public int UpshiftGrade;

		public int DownshiftRequire;

		public int DownshiftGrade;
	}
	public class ElectricStrength
	{
		public int StrengthID;

		public int StrengthGrade;

		public float ScoreAddition;

		public float TimeReduction;

		public float HandChange;
	}
	public class ElectricMap
	{
		public int MapID;

		public int LimitTime;
	}
	public class CheckpointManager
	{
		public static Dictionary<int, ElectricLevel> LevelDataDic = new Dictionary<int, ElectricLevel>();

		public static Dictionary<int, ElectricStrength> StrengthDataDic = new Dictionary<int, ElectricStrength>();

		public static Dictionary<int, ElectricMap> MapDataDic = new Dictionary<int, ElectricMap>();

		public static List<GameRecordData> gameRecordDatas = new List<GameRecordData>();

		public static int curLevelID;

		public static int curStrengthID;

		public static int curMapID;

		public static float gameDuration;

		public static float gameDurationed;

		public static int curScore;

		public static string startLevel;

		public static string minLevel;

		public static string maxLevel;

		public static int allPass;

		public static int perfectNum;

		public static int continuateMaxNum;

		public static int timeOutNum;

		public static int touchEdgeNum;

		public static int touchMachineNum;

		public static List<int> staminas;

		public static bool IsStartGame = false;

		public static bool IsPlayGame = false;

		public static ElectricLevel CurElectricLevel => LevelDataDic[curLevelID];

		public static ElectricStrength CurElectricStrength => StrengthDataDic[curStrengthID];

		public static ElectricMap CurElectricMap => MapDataDic[curMapID];

		public static int GetScore => (int)((float)CurElectricLevel.BaseScore * (1f + CurElectricStrength.ScoreAddition));

		public static float GetTime => (float)CurElectricMap.LimitTime * (1f - CurElectricStrength.TimeReduction);

		public static float GetChangeValue
		{
			get
			{
				if (CurElectricLevel.HandChange != 0)
				{
					return 1f - CurElectricStrength.HandChange;
				}
				return 1f;
			}
		}

		public static string GetCurLevel => LevelDataDic[curLevelID].LevelName + "-" + StrengthDataDic[curStrengthID].StrengthGrade;

		public static void StartTheLevel(CourseDetail.Data data)
		{
			if (data != null)
			{
				if (data.game_data == null)
				{
					string text = data.level + "-" + data.strength;
					InitData(data.level, data.strength, data.play_time, data.already_play_time, data.point, 0, 0, 0, 0, 0, 0, new List<int>(), text, text, text);
				}
				else
				{
					GameRecordData gameRecordData = J_LitJson.JsonMapper.ToObject<GameRecordData>(data.game_data);
					InitData(data.level, data.strength, data.play_time, data.already_play_time, data.point, gameRecordData.AllPass, gameRecordData.PerfectNum, gameRecordData.ContinuateMaxNum, gameRecordData.TimeOutNum, gameRecordData.TouchEdgeNum, gameRecordData.TouchMachineNum, gameRecordData.Staminas, gameRecordData.InitLevel, gameRecordData.MaxLevel, gameRecordData.MinLevel);
				}
			}
			else
			{
				string text2 = LoadManager.LevelID + "-" + LoadManager.StrengthID;
				InitData(LoadManager.LevelID, LoadManager.StrengthID, LoadManager.Duration, 0, 0, 0, 0, 0, 0, 0, 0, new List<int>(), text2, text2, text2);
			}
			IsStartGame = true;
			RingRootController.Instance.CreateElectricRing();
			UIController.Instance.StartGame();
			PlayerController.Instance.IsShowVivePointers(isShow: false);
		}

		private static void InitData(int level, int strength, int duration, int durationed, int score, int allpass, int perfect, int continuate, int timeout, int touchedge, int touchmachine, List<int> stam, string start, string max, string min)
		{
			curLevelID = level;
			curStrengthID = strength;
			gameDuration = duration;
			gameDurationed = durationed;
			curScore = score;
			allPass = allpass;
			perfectNum = perfect;
			continuateMaxNum = continuate;
			timeOutNum = timeout;
			touchEdgeNum = touchedge;
			touchMachineNum = touchmachine;
			staminas = stam;
			startLevel = start;
			maxLevel = max;
			minLevel = min;
		}

		public static void OverTheGame()
		{
			IsPlayGame = false;
			IsStartGame = false;
			BraceletController.Instance.OnReleaseGrabbed();
			RingRootController.Instance.DestroyElectricRing();
			PlayerController.Instance.StopAllCoroutines();
			UIController.Instance.OverTheGame();
		}

		public static void ResetTheGame()
		{
			IsPlayGame = false;
			IsStartGame = false;
			BraceletController.Instance.OnReleaseGrabbed();
			RingRootController.Instance.DestroyElectricRing();
			PlayerController.Instance.StopAllCoroutines();
		}

		public static string GetInitChallengeLevel()
		{
			string[] array = startLevel.Split('-');
			return LevelDataDic[int.Parse(array[0])].LevelName + "-" + StrengthDataDic[int.Parse(array[1])].StrengthGrade;
		}

		public static string GetMaxChallengeLevel()
		{
			string[] array = maxLevel.Split('-');
			return LevelDataDic[int.Parse(array[0])].LevelName + "-" + StrengthDataDic[int.Parse(array[1])].StrengthGrade;
		}

		public static string GetMinChallengeLevel()
		{
			string[] array = minLevel.Split('-');
			return LevelDataDic[int.Parse(array[0])].LevelName + "-" + StrengthDataDic[int.Parse(array[1])].StrengthGrade;
		}

		public static void AddStrength(int upshift)
		{
			curStrengthID += upshift;
			if (curStrengthID > 9)
			{
				if (LoadManager.IsLocalOperate && curLevelID >= LoadManager.MaxLevelID)
				{
					curStrengthID = 9;
				}
				else if (curLevelID >= LevelDataDic.Count - 1)
				{
					curStrengthID = 9;
				}
				else
				{
					curStrengthID -= 10;
					curLevelID++;
				}
			}
			SetMaxLevel();
			UIController.Instance.LevelTxt.text = GetCurLevel;
			LoadManager.SubmitLevelRecord(curLevelID, curStrengthID, UIController.Instance.GetUseDuration(), curScore, J_LitJson.JsonMapper.ToJson(GetGameRecord()));
		}

		public static void ReduceStrength(int downshift)
		{
			curStrengthID -= downshift;
			if (curStrengthID < 0)
			{
				if (curLevelID <= 0)
				{
					curStrengthID = 0;
				}
				else
				{
					curStrengthID += 10;
					curLevelID--;
				}
			}
			SetMinLevel();
			UIController.Instance.LevelTxt.text = GetCurLevel;
			LoadManager.SubmitLevelRecord(curLevelID, curStrengthID, UIController.Instance.GetUseDuration(), curScore, J_LitJson.JsonMapper.ToJson(GetGameRecord()));
		}

		private static void SetMaxLevel()
		{
			string[] array = maxLevel.Split('-');
			int num = int.Parse(array[0]);
			int num2 = int.Parse(array[1]);
			if (curLevelID == num)
			{
				if (curStrengthID > num2)
				{
					maxLevel = curLevelID + "-" + curStrengthID;
				}
			}
			else if (curLevelID > num)
			{
				maxLevel = curLevelID + "-" + curStrengthID;
			}
		}

		private static void SetMinLevel()
		{
			string[] array = minLevel.Split('-');
			int num = int.Parse(array[0]);
			int num2 = int.Parse(array[1]);
			if (curLevelID == num)
			{
				if (curStrengthID < num2)
				{
					minLevel = curLevelID + "-" + curStrengthID;
				}
			}
			else if (curLevelID < num)
			{
				minLevel = curLevelID + "-" + curStrengthID;
			}
		}

		public static void AddScore(int score)
		{
			curScore += score;
			UIController.Instance.CurScoreTxt.text = curScore.ToString();
		}

		public static void SetChanglleNum(int missMun)
		{
			int num = CurElectricLevel.ChallengeNum - missMun;
			UIController.Instance.ChanglleNumTxt.text = ((num == 0) ? 1 : num).ToString();
		}

		public static void SetChanglleTime(float catchTimer)
		{
			UIController.Instance.ChanglleTimeTxt.text = Mathf.Ceil(catchTimer).ToString();
		}

		public static GameRecordData GetGameRecord()
		{
			return new GameRecordData
			{
				InitLevel = minLevel,
				MaxLevel = maxLevel,
				MinLevel = minLevel,
				AllPass = allPass,
				PerfectNum = perfectNum,
				ContinuateMaxNum = continuateMaxNum,
				TimeOutNum = timeOutNum,
				TouchEdgeNum = touchEdgeNum,
				TouchMachineNum = touchMachineNum,
				Staminas = staminas
			};
		}
	}
	public class CustomRecordData
	{
		public List<float> errorProcess;
	}
	public class GameRecordData
	{
		public string InitLevel;

		public string MaxLevel;

		public string MinLevel;

		public int AllPass;

		public int PerfectNum;

		public int ContinuateMaxNum;

		public int TimeOutNum;

		public int TouchEdgeNum;

		public int TouchMachineNum;

		public List<int> Staminas;
	}
	public class PlayerController : MonoBehaviour
	{
		public static PlayerController Instance;

		public GameObject ring;

		public Pvr_ControllerModuleInit pvr_ControllerModuleInit;

		public BatteryTipController batteryTipController;

		private bool lastVivePointersIsShow;

		private void Awake()
		{
			Instance = this;
		}

		private void Start()
		{
			Time.fixedDeltaTime = 0.01f;
		}

		private void Update()
		{
		}

		public void InitData()
		{
			List<ElectricLevel> list = CsvMapper.ToObjectList<ElectricLevel>(LoadManager.CsvRead("ElectricRingLevel"));
			CheckpointManager.LevelDataDic.Clear();
			foreach (ElectricLevel item in list)
			{
				CheckpointManager.LevelDataDic.Add(item.LevelID, item);
			}
			List<ElectricStrength> list2 = CsvMapper.ToObjectList<ElectricStrength>(LoadManager.CsvRead("ElectricRingStrength"));
			CheckpointManager.StrengthDataDic.Clear();
			foreach (ElectricStrength item2 in list2)
			{
				CheckpointManager.StrengthDataDic.Add(item2.StrengthID, item2);
			}
			List<ElectricMap> list3 = CsvMapper.ToObjectList<ElectricMap>(LoadManager.CsvRead("ElectricRingMap"));
			CheckpointManager.MapDataDic.Clear();
			foreach (ElectricMap item3 in list3)
			{
				CheckpointManager.MapDataDic.Add(item3.MapID, item3);
			}
		}

		public void IsShowVivePointers(bool isShow)
		{
			lastVivePointersIsShow = pvr_ControllerModuleInit.GetModuleState();
			pvr_ControllerModuleInit.ForceHideOrShow(isShow);
			ring.SetActive(!isShow);
		}

		public void ResetShowVivePointers()
		{
			pvr_ControllerModuleInit.ForceHideOrShow(lastVivePointersIsShow);
			ring.SetActive(!lastVivePointersIsShow);
		}

		public void DelayHander(float time, Action action)
		{
			StartCoroutine(Wait(time, action));
		}

		private IEnumerator Wait(float time, Action action)
		{
			yield return new WaitForSeconds(time);
			action?.Invoke();
		}
	}
	public class RingRootController : MonoBehaviour
	{
		public static RingRootController Instance;

		public BraceletController braceletController;

		public GameObject rightHand;

		public Animator handAnimator;

		public Transform handleTra;

		public ParticleSystem endParticle;

		public Material metalBallMat;

		public Material metalLineMat;

		public Material insulationMat;

		private Transform startPoint;

		private Transform endPoint;

		private Transform insulationTra;

		private Transform uninsulatedTra;

		private Transform machineTra;

		private Transform ballTra;

		private Transform cubeTra;

		private Transform checkPointTra;

		private Spline splineTra;

		private GameObject electricRing;

		private Transform firstCheckPoint;

		private Transform secondCheckPoint;

		private int curCheckNum;

		private float challengeTimer;

		private int curMissNum;

		private int lastRandom = 1000;

		private List<int> curStaminas;

		public int CurCheckNum => curCheckNum;

		public bool IsChallengeFail
		{
			get
			{
				curMissNum++;
				CheckpointManager.SetChanglleNum(curMissNum);
				return curMissNum >= CheckpointManager.CurElectricLevel.ChallengeNum;
			}
		}

		public bool IsPerfectPass
		{
			get
			{
				if (curMissNum == 0)
				{
					return true;
				}
				return false;
			}
		}

		public List<int> CurStaminas
		{
			get
			{
				if (curStaminas == null)
				{
					curStaminas = new List<int>();
				}
				return curStaminas;
			}
		}

		private void Awake()
		{
			Instance = this;
		}

		private void Start()
		{
		}

		private void Update()
		{
			if (CheckpointManager.IsStartGame && CheckpointManager.IsPlayGame && Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.TRIGGER) && Vector3.Distance(handleTra.position, rightHand.transform.position) < 0.2f)
			{
				BraceletController.Instance.OnPipeGrabbed();
			}
			if (UIController.Instance.isStartTime)
			{
				challengeTimer -= Time.deltaTime;
				CheckpointManager.SetChanglleTime(challengeTimer);
				if (challengeTimer <= 0f)
				{
					UIController.Instance.PlayAudioSound(1);
					CheckpointManager.timeOutNum++;
					UIController.Instance.IsStartTime(isStart: false);
					AddStaminas();
					SetStaminas();
					CheckpointManager.ReduceStrength(CheckpointManager.CurElectricLevel.DownshiftGrade);
					ChallengeFinish();
				}
			}
		}

		public void CreateElectricRing()
		{
			CurStaminas.Clear();
			List<int> randomLevel = CheckpointManager.CurElectricLevel.RandomLevel;
			lastRandom = MyMath.RandomRange(0, randomLevel.Count, lastRandom);
			CheckpointManager.curMapID = randomLevel[lastRandom];
			challengeTimer = CheckpointManager.GetTime;
			CheckpointManager.SetChanglleTime(challengeTimer);
			curMissNum = 0;
			CheckpointManager.SetChanglleNum(curMissNum);
			braceletController.gameObject.SetActive(value: true);
			electricRing = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("Prefabs/VR线环/E" + CheckpointManager.curMapID), base.transform);
			electricRing.transform.localPosition = Vector3.zero;
			int num = 0;
			int num2 = 0;
			if (CheckpointManager.CurElectricLevel.HorizontalFlip == 1 && UnityEngine.Random.Range(0, 2) == 1)
			{
				num2 = 180;
			}
			if (CheckpointManager.CurElectricLevel.VerticalFlip == 1 && UnityEngine.Random.Range(0, 2) == 1)
			{
				num = 180;
			}
			electricRing.transform.localEulerAngles = new Vector3(num, num2, 0f);
			startPoint = electricRing.transform.Find("StartPoint");
			startPoint.localEulerAngles = new Vector3(num, num2, startPoint.localEulerAngles.z);
			endPoint = electricRing.transform.Find("EndPoint");
			endParticle.transform.position = endPoint.position;
			insulationTra = electricRing.transform.Find("Insulation");
			HighlightEffect[] componentsInChildren = electricRing.GetComponentsInChildren<HighlightEffect>();
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				componentsInChildren[i].enabled = false;
			}
			if ((bool)insulationTra)
			{
				foreach (Transform item in insulationTra)
				{
					item.gameObject.AddComponent<MeshCollider>();
					item.GetComponent<Renderer>().material = insulationMat;
				}
			}
			uninsulatedTra = electricRing.transform.Find("Uninsulated");
			if ((bool)uninsulatedTra)
			{
				foreach (Transform item2 in uninsulatedTra)
				{
					item2.gameObject.AddComponent<MeshCollider>();
					item2.GetComponent<Renderer>().material = metalLineMat;
				}
			}
			machineTra = electricRing.transform.Find("Machine");
			if ((bool)machineTra)
			{
				foreach (Transform item3 in machineTra)
				{
					item3.gameObject.AddComponent<MeshCollider>();
					item3.GetComponent<Renderer>().material = metalBallMat;
				}
			}
			ballTra = electricRing.transform.Find("Ball");
			if ((bool)ballTra)
			{
				foreach (Transform item4 in ballTra)
				{
					item4.gameObject.AddComponent<SphereCollider>();
					item4.GetComponent<Renderer>().material = metalBallMat;
				}
			}
			cubeTra = electricRing.transform.Find("Cube");
			if ((bool)cubeTra)
			{
				foreach (Transform item5 in cubeTra)
				{
					item5.gameObject.AddComponent<BoxCollider>();
					item5.GetComponent<Renderer>().material = metalBallMat;
				}
			}
			curCheckNum = 0;
			checkPointTra = electricRing.transform.Find("CheckPoint");
			if ((bool)checkPointTra)
			{
				foreach (Transform item6 in checkPointTra)
				{
					item6.localEulerAngles = new Vector3(num, num2, 0f);
					MeshRenderer component = item6.GetComponent<MeshRenderer>();
					if ((bool)component)
					{
						component.enabled = false;
					}
					curCheckNum++;
				}
				curCheckNum++;
			}
			splineTra = electricRing.GetComponentInChildren<Spline>();
			braceletController.transform.position = startPoint.position;
			braceletController.transform.eulerAngles = startPoint.eulerAngles;
			braceletController.transform.localScale = new Vector3(1f, CheckpointManager.GetChangeValue, CheckpointManager.GetChangeValue);
			braceletController.getPathProcess.SetSpline(splineTra);
			firstCheckPoint = null;
			secondCheckPoint = null;
			handAnimator.gameObject.SetActive(value: true);
			CheckpointManager.IsPlayGame = true;
		}

		public void DestroyElectricRing()
		{
			braceletController.gameObject.SetActive(value: false);
			UnityEngine.Object.Destroy(electricRing);
			electricRing = null;
		}

		public void ChallengeFinish()
		{
			braceletController.OnReleaseGrabbed();
			DestroyElectricRing();
			PlayerController.Instance.DelayHander(1f, delegate
			{
				UIController.Instance.CheckBattery(delegate
				{
					UIController.Instance.SuspendGame(suspend: false);
					CreateElectricRing();
				});
			});
		}

		public bool CheckIsInsulation(Transform child)
		{
			if ((bool)uninsulatedTra && child.IsChildOf(uninsulatedTra))
			{
				CheckpointManager.touchEdgeNum++;
				return true;
			}
			if ((bool)ballTra && child.IsChildOf(ballTra))
			{
				CheckpointManager.touchEdgeNum++;
				return true;
			}
			if ((bool)cubeTra && child.IsChildOf(cubeTra))
			{
				CheckpointManager.touchMachineNum++;
				return true;
			}
			if ((bool)machineTra && child.IsChildOf(machineTra))
			{
				CheckpointManager.touchMachineNum++;
				return true;
			}
			return false;
		}

		public bool CheckIsCheckPoint(Transform child)
		{
			if (!checkPointTra)
			{
				return false;
			}
			if (child.IsChildOf(checkPointTra))
			{
				return true;
			}
			return false;
		}

		public bool CheckIsFinsh(Transform child)
		{
			if (child.IsChildOf(endPoint))
			{
				return true;
			}
			return false;
		}

		public void ResetBraceletPos()
		{
			if (firstCheckPoint == null && secondCheckPoint == null)
			{
				braceletController.transform.position = startPoint.position;
				braceletController.transform.eulerAngles = startPoint.eulerAngles;
			}
			else if ((bool)firstCheckPoint && secondCheckPoint == null)
			{
				braceletController.transform.position = firstCheckPoint.position;
				braceletController.transform.eulerAngles = firstCheckPoint.eulerAngles;
			}
			else if ((bool)firstCheckPoint && (bool)secondCheckPoint)
			{
				braceletController.transform.position = secondCheckPoint.position;
				braceletController.transform.eulerAngles = secondCheckPoint.eulerAngles;
			}
			CheckpointManager.IsPlayGame = true;
		}

		public void ArriveCheckPoint(Transform check)
		{
			if (firstCheckPoint == null)
			{
				firstCheckPoint = check;
			}
			else if (firstCheckPoint != check && secondCheckPoint == null)
			{
				secondCheckPoint = check;
			}
		}

		public void SetCountDownPos(Transform countdown)
		{
			if (firstCheckPoint == null && secondCheckPoint == null)
			{
				countdown.position = startPoint.position + new Vector3(0f, 0.075f, -0.03f);
			}
			else if ((bool)firstCheckPoint && secondCheckPoint == null)
			{
				countdown.position = firstCheckPoint.position + new Vector3(0f, 0.075f, -0.03f);
			}
			else if ((bool)firstCheckPoint && (bool)secondCheckPoint)
			{
				countdown.position = secondCheckPoint.position + new Vector3(0f, 0.075f, -0.03f);
			}
			countdown.eulerAngles = Vector3.zero;
		}

		public int PassCheckNum()
		{
			if ((bool)firstCheckPoint && (bool)secondCheckPoint)
			{
				return 2;
			}
			if ((bool)firstCheckPoint && secondCheckPoint == null)
			{
				return 1;
			}
			if (firstCheckPoint == null && (bool)secondCheckPoint)
			{
				return 1;
			}
			return 0;
		}

		public float GetPassProgress()
		{
			return (float)PassCheckNum() / (float)curCheckNum;
		}

		public void AddStaminas(bool isEnd = false)
		{
			if (isEnd)
			{
				CurStaminas.Add(100);
			}
			else
			{
				CurStaminas.Add(braceletController.GetProcess());
			}
		}

		public void SetStaminas()
		{
			CheckpointManager.staminas.Add(MyMath.GetAverage(CurStaminas));
		}
	}
	public class UIController : MonoBehaviour
	{
		public static UIController Instance;

		public GameObject StaticCanvas;

		[Header("开始界面")]
		public GameObject StartGamePanel;

		public ToggleGroup toggleGroup;

		public Button startGameBtn;

		public Button settingsBtn;

		public Button tipsBtn;

		public Button exitBtn;

		public AudioSource bgAudioSource;

		[Header("游戏界面")]
		public GameObject ScorePanel;

		public Text CurScoreTxt;

		public Text LevelTxt;

		public Text TotalTimeTxt;

		public Text ChanglleNumTxt;

		public Text ChanglleTimeTxt;

		[Header("结算界面")]
		public GameObject PassAllCheckpointPanel;

		public TextMeshProUGUI ScoreTxt;

		public Text TrainingDurationTxt;

		public Text InitChallengeLevelTxt;

		public Text MaxChallengeLevelTxt;

		public Text MinChallengeLevelTxt;

		public Text AllPassTxt;

		public Text PerfectNumTxt;

		public Text ContinuateMaxNumTxt;

		public Text TimeOutNumTxt;

		public Text TouchEdgeNumTxt;

		public Text TouchMachineNumTxt;

		public Button passAllReturnBtn;

		[Header("暂停界面")]
		public GameObject SuspendPanel;

		public Button suspendReturnStartBtn;

		public Button suspendReturnBtn;

		[Header("退出提示界面")]
		public GameObject ExitTipPanel;

		public Button defineBtn;

		public Button cancelBtn;

		public AudioSource audioSource;

		public AudioClip[] audioClips;

		public bool isStartTime;

		private int curErrorTimes;

		private List<float> curErrorProcess;

		private float surplusGameDuration;

		private void Awake()
		{
			Instance = this;
		}

		private void Start()
		{
			ScorePanel.SetActive(value: false);
			StartGamePanel.SetActive(value: true);
			PassAllCheckpointPanel.SetActive(value: false);
			startGameBtn.onClick.AddListener(StartGameBtnHander);
			exitBtn.onClick.AddListener(ExitBtnHander);
			passAllReturnBtn.onClick.AddListener(PassAllBtnHander);
			suspendReturnStartBtn.onClick.AddListener(SuspendReturnStartBtnHander);
			suspendReturnBtn.onClick.AddListener(SuspendReturnBtnHander);
			defineBtn.onClick.AddListener(DefineBtnHander);
			cancelBtn.onClick.AddListener(CancelBtnHander);
			for (int i = 0; i < toggleGroup.transform.childCount; i++)
			{
				int index = i;
				Toggle component = toggleGroup.transform.GetChild(i).GetComponent<Toggle>();
				component.onValueChanged.AddListener(delegate(bool value)
				{
					if (value)
					{
						LoadManager.LevelID = index;
					}
				});
				if (LoadManager.LevelID == index)
				{
					component.isOn = true;
				}
			}
			PlayerController.Instance.InitData();
			if (LoadManager.IsLocalOperate)
			{
				StartGamePanel.SetActive(value: true);
				return;
			}
			StartGamePanel.SetActive(value: false);
			StartGameBtnHander(LoadManager.course);
		}

		private void Update()
		{
			if (CheckpointManager.IsStartGame)
			{
				surplusGameDuration -= Time.deltaTime;
				TotalTimeTxt.text = LoadManager.TimeConversion((int)surplusGameDuration);
				if (surplusGameDuration <= 0f)
				{
					RingRootController.Instance.handAnimator.gameObject.SetActive(value: true);
					PlayerController.Instance.IsShowVivePointers(isShow: true);
					CheckpointManager.OverTheGame();
				}
			}
			if (IsCanSuspend() && Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.APP))
			{
				RingRootController.Instance.handAnimator.gameObject.SetActive(value: true);
				PlayerController.Instance.IsShowVivePointers(isShow: true);
				IsStartTime(isStart: false);
				StaticCanvas.SetActive(value: true);
				SuspendPanel.SetActive(value: true);
				Time.timeScale = 0f;
			}
		}

		public void StartGame()
		{
			StaticCanvas.SetActive(value: false);
			ScorePanel.SetActive(value: true);
			surplusGameDuration = CheckpointManager.gameDuration - CheckpointManager.gameDurationed;
			curErrorTimes = 0;
			curErrorProcess = new List<float>();
			CurScoreTxt.text = CheckpointManager.curScore.ToString();
			LevelTxt.text = CheckpointManager.GetCurLevel;
			TotalTimeTxt.text = LoadManager.TimeConversion((int)surplusGameDuration);
			CheckpointManager.SetChanglleNum(0);
			ChanglleTimeTxt.text = CheckpointManager.CurElectricMap.LimitTime.ToString();
		}

		public void IsStartTime(bool isStart = true)
		{
			isStartTime = isStart;
		}

		public void ErrorAnswer(float process)
		{
			IsStartTime(isStart: false);
			curErrorTimes++;
			curErrorProcess.Add(process);
		}

		public int GetUseDuration(bool isComplete = false)
		{
			float num = CheckpointManager.gameDuration - surplusGameDuration;
			num = (isComplete ? CheckpointManager.gameDuration : num);
			return (int)num;
		}

		public void OverTheGame()
		{
			PlayerController.Instance.IsShowVivePointers(isShow: true);
			IsStartTime(isStart: false);
			PlayAudioSound(4);
			StaticCanvas.SetActive(value: true);
			ScorePanel.SetActive(value: false);
			PassAllCheckpointPanel.SetActive(value: true);
			ScoreTxt.text = CheckpointManager.curScore.ToString();
			TrainingDurationTxt.text = LoadManager.TimeConversion((int)CheckpointManager.gameDuration);
			InitChallengeLevelTxt.text = CheckpointManager.GetInitChallengeLevel();
			MaxChallengeLevelTxt.text = CheckpointManager.GetMaxChallengeLevel();
			MinChallengeLevelTxt.text = CheckpointManager.GetMinChallengeLevel();
			AllPassTxt.text = CheckpointManager.allPass.ToString();
			PerfectNumTxt.text = CheckpointManager.perfectNum.ToString();
			ContinuateMaxNumTxt.text = CheckpointManager.continuateMaxNum.ToString();
			TimeOutNumTxt.text = CheckpointManager.timeOutNum.ToString();
			TouchEdgeNumTxt.text = CheckpointManager.touchEdgeNum.ToString();
			TouchMachineNumTxt.text = CheckpointManager.touchMachineNum.ToString();
		}

		public void PlayAudioSound(int index)
		{
			if (audioSource.isPlaying)
			{
				audioSource.Stop();
			}
			audioSource.clip = audioClips[index];
			audioSource.Play();
		}

		public void CheckBattery(Action continueAction)
		{
			if (PlayerController.Instance.batteryTipController.CheckBattery(continueAction))
			{
				SuspendGame(suspend: true);
			}
		}

		public void SuspendGame(bool suspend)
		{
			RingRootController.Instance.handAnimator.gameObject.SetActive(suspend);
			PlayerController.Instance.IsShowVivePointers(suspend);
			if (suspend)
			{
				IsStartTime(isStart: false);
			}
			StaticCanvas.SetActive(suspend);
			Time.timeScale = ((!suspend) ? 1 : 0);
		}

		private void StartGameBtnHander()
		{
			StartGameBtnHander(null);
		}

		private void StartGameBtnHander(CourseDetail.Data data)
		{
			StartGamePanel.SetActive(value: false);
			bgAudioSource.Play();
			CheckpointManager.StartTheLevel(data);
		}

		private void ExitBtnHander()
		{
			ScenesHelper.LoadScene(ScenesHelper.WeiAiZhiCenterScene);
		}

		private void PassAllBtnHander()
		{
			if (LoadManager.IsLocalOperate)
			{
				StartGamePanel.SetActive(value: true);
				PassAllCheckpointPanel.SetActive(value: false);
			}
			else
			{
				LoadManager.SubmitEndRecord(isComplete: true, isLogout: false, GetUseDuration(isComplete: true), CheckpointManager.curScore, J_LitJson.JsonMapper.ToJson(CheckpointManager.GetGameRecord()));
			}
		}

		private void SuspendReturnStartBtnHander()
		{
			if (LoadManager.IsLocalOperate)
			{
				CheckpointManager.ResetTheGame();
				StaticCanvas.SetActive(value: true);
				StartGamePanel.SetActive(value: true);
				SuspendPanel.SetActive(value: false);
				ScorePanel.SetActive(value: false);
				Time.timeScale = 1f;
			}
			else
			{
				ExitTipPanel.SetActive(value: true);
			}
		}

		private void SuspendReturnBtnHander()
		{
			PlayerController.Instance.ResetShowVivePointers();
			StaticCanvas.SetActive(value: false);
			SuspendPanel.SetActive(value: false);
			Time.timeScale = 1f;
		}

		private void DefineBtnHander()
		{
			Time.timeScale = 1f;
			LoadManager.SubmitEndRecord(isComplete: false, isLogout: false, GetUseDuration(), CheckpointManager.curScore, J_LitJson.JsonMapper.ToJson(CheckpointManager.GetGameRecord()));
		}

		private void CancelBtnHander()
		{
			ExitTipPanel.SetActive(value: false);
		}

		private bool IsCanSuspend()
		{
			if (PassAllCheckpointPanel.activeSelf)
			{
				return false;
			}
			if (CheckpointManager.IsStartGame)
			{
				return true;
			}
			return false;
		}
	}
}
namespace ElectricClub
{
	public class BraceletController : MonoBehaviour
	{
		public static BraceletController Instance;

		public Transform countDownTra;

		public Text countDownTxt;

		public RigidbodyOffsetMove rigidbodyMove;

		public ParticleSystem sparkParticle;

		public GetPathProcess getPathProcess;

		private bool isFollowToHand;

		private Vector3 offsetPos;

		private int continuateNum;

		private void Awake()
		{
			Instance = this;
		}

		private void Start()
		{
		}

		private void Update()
		{
			if (!isFollowToHand)
			{
				if (Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.Right))
				{
					Pvr_UnitySDKSensor.Instance.ResetUnitySDKSensor();
				}
				Vector2 vector = Controller.UPvr_GetAxis2D(1);
				if (vector.y > 0f)
				{
					RingRootController.Instance.transform.position += Vector3.up * Time.deltaTime * 0.1f;
					base.transform.position += Vector3.up * Time.deltaTime * 0.1f;
				}
				else if (vector.y < 0f)
				{
					RingRootController.Instance.transform.position -= Vector3.up * Time.deltaTime * 0.1f;
					base.transform.position -= Vector3.up * Time.deltaTime * 0.1f;
				}
			}
		}

		public void OnPipeGrabbed()
		{
			if (isFollowToHand)
			{
				return;
			}
			isFollowToHand = true;
			RingRootController.Instance.handAnimator.SetBool("isGrabbing", value: true);
			countDownTra.gameObject.SetActive(value: true);
			RingRootController.Instance.SetCountDownPos(countDownTra);
			countDownTxt.text = "3";
			PlayerController.Instance.DelayHander(1f, delegate
			{
				countDownTxt.text = "2";
				PlayerController.Instance.DelayHander(1f, delegate
				{
					countDownTxt.text = "1";
					PlayerController.Instance.DelayHander(1f, delegate
					{
						countDownTra.gameObject.SetActive(value: false);
						RingRootController.Instance.handAnimator.SetBool("isGrabbing", value: false);
						RingRootController.Instance.handAnimator.gameObject.SetActive(value: false);
						offsetPos = RingRootController.Instance.rightHand.transform.position - base.transform.position;
						rigidbodyMove.StartFollow(offsetPos);
						UIController.Instance.IsStartTime();
					});
				});
			});
		}

		public void OnReleaseGrabbed()
		{
			countDownTra.gameObject.SetActive(value: false);
			isFollowToHand = false;
			rigidbodyMove.StopFollow();
			RingRootController.Instance.handAnimator.SetBool("isGrabbing", value: false);
		}

		public int GetProcess()
		{
			return (int)(getPathProcess.GetProjectionSample(base.transform.position) * 100f);
		}

		private void OnCollisionEnter(UnityEngine.Collision collision)
		{
			if (!isFollowToHand || !RingRootController.Instance.CheckIsInsulation(collision.transform))
			{
				return;
			}
			isFollowToHand = false;
			CheckpointManager.IsPlayGame = false;
			RingRootController.Instance.handAnimator.gameObject.SetActive(value: true);
			sparkParticle.gameObject.SetActive(value: true);
			sparkParticle.Play();
			UIController.Instance.PlayAudioSound(1);
			rigidbodyMove.StopFollow();
			RingRootController.Instance.AddStaminas();
			PlayerController.Instance.DelayHander(1f, delegate
			{
				continuateNum = 0;
				sparkParticle.gameObject.SetActive(value: false);
				if (RingRootController.Instance.IsChallengeFail)
				{
					RingRootController.Instance.SetStaminas();
					CheckpointManager.ReduceStrength(CheckpointManager.CurElectricLevel.DownshiftGrade);
					RingRootController.Instance.ChallengeFinish();
				}
				else
				{
					RingRootController.Instance.ResetBraceletPos();
				}
			});
			ContactPoint contactPoint = collision.contacts[0];
			UIController.Instance.ErrorAnswer(RingRootController.Instance.GetPostionProportion(contactPoint.point));
			Controller.UPvr_VibrateNeo2Controller(0.5f, 50, Pvr_ControllerManager.controllerlink.mainHandID);
		}

		private void OnTriggerEnter(Collider other)
		{
			if (!isFollowToHand)
			{
				return;
			}
			if (RingRootController.Instance.CheckIsCheckPoint(other.transform))
			{
				RingRootController.Instance.ArriveCheckPoint(other.transform);
			}
			else
			{
				if (!RingRootController.Instance.CheckIsFinsh(other.transform))
				{
					return;
				}
				isFollowToHand = false;
				CheckpointManager.IsPlayGame = false;
				CheckpointManager.allPass++;
				int num = ((!RingRootController.Instance.IsPerfectPass) ? 1 : 2);
				if (RingRootController.Instance.IsPerfectPass)
				{
					CheckpointManager.perfectNum++;
					continuateNum++;
					if (continuateNum > CheckpointManager.continuateMaxNum)
					{
						CheckpointManager.continuateMaxNum = continuateNum;
					}
				}
				else
				{
					continuateNum = 0;
				}
				CheckpointManager.AddScore(CheckpointManager.GetScore * num);
				int upshift = CheckpointManager.CurElectricLevel.UpshiftGrade * num;
				RingRootController.Instance.AddStaminas(isEnd: true);
				RingRootController.Instance.SetStaminas();
				CheckpointManager.AddStrength(upshift);
				RingRootController.Instance.endParticle.gameObject.SetActive(value: true);
				RingRootController.Instance.endParticle.Play();
				UIController.Instance.PlayAudioSound((num == 1) ? 2 : 3);
				UIController.Instance.IsStartTime(isStart: false);
				PlayerController.Instance.DelayHander(1f, delegate
				{
					RingRootController.Instance.ChallengeFinish();
				});
			}
		}
	}
	public class LevelData
	{
		public int Levelid;

		public string LevelName;

		public List<int> CheckpointArray;

		public int NextLevelid;
	}
	public class CheckpointData
	{
		public int CheckpointID;

		public string MazeName;

		public float ChallengeTime;

		public int PunishTime;

		public int TimeThreshold;

		public int TimeScore;

		public int MissLimitTimes;

		public int NoMissScore;
	}
	public class ElectricLevel
	{
		public int LevelID;

		public string LevelName;

		public List<int> RandomLevel;

		public int BaseScore;

		public int ChallengeNum;

		public int TimeReduction;

		public int HandChange;

		public int HorizontalFlip;

		public int VerticalFlip;

		public int UpshiftRequire;

		public int UpshiftGrade;

		public int DownshiftRequire;

		public int DownshiftGrade;
	}
	public class ElectricStrength
	{
		public int StrengthID;

		public int StrengthGrade;

		public float ScoreAddition;

		public float TimeReduction;

		public float HandChange;
	}
	public class ElectricMap
	{
		public int MapID;

		public int LimitTime;
	}
	public class CheckpointManager
	{
		public static Dictionary<int, ElectricLevel> LevelDataDic = new Dictionary<int, ElectricLevel>();

		public static Dictionary<int, ElectricStrength> StrengthDataDic = new Dictionary<int, ElectricStrength>();

		public static Dictionary<int, ElectricMap> MapDataDic = new Dictionary<int, ElectricMap>();

		public static List<GameRecordData> gameRecordDatas = new List<GameRecordData>();

		public static int curLevelID;

		public static int curStrengthID;

		public static int curMapID;

		public static float gameDuration;

		public static float gameDurationed;

		public static int curScore;

		public static string startLevel;

		public static string minLevel;

		public static string maxLevel;

		public static int allPass;

		public static int perfectNum;

		public static int continuateMaxNum;

		public static int timeOutNum;

		public static int touchEdgeNum;

		public static int touchMachineNum;

		public static List<int> staminas;

		public static bool IsStartGame = false;

		public static bool IsPlayGame = false;

		public static ElectricLevel CurElectricLevel => LevelDataDic[curLevelID];

		public static ElectricStrength CurElectricStrength => StrengthDataDic[curStrengthID];

		public static ElectricMap CurElectricMap => MapDataDic[curMapID];

		public static int GetScore => (int)((float)CurElectricLevel.BaseScore * (1f + CurElectricStrength.ScoreAddition));

		public static float GetTime => (float)CurElectricMap.LimitTime * (1f - CurElectricStrength.TimeReduction);

		public static float GetChangeValue
		{
			get
			{
				if (CurElectricLevel.HandChange != 0)
				{
					return 1f + CurElectricStrength.HandChange;
				}
				return 1f;
			}
		}

		public static string GetCurLevel => LevelDataDic[curLevelID].LevelName + "-" + StrengthDataDic[curStrengthID].StrengthGrade;

		public static void StartTheLevel(CourseDetail.Data data)
		{
			if (data != null)
			{
				if (data.game_data == null)
				{
					string text = data.level + "-" + data.strength;
					InitData(data.level, data.strength, data.play_time, data.already_play_time, data.point, 0, 0, 0, 0, 0, 0, new List<int>(), text, text, text);
				}
				else
				{
					GameRecordData gameRecordData = J_LitJson.JsonMapper.ToObject<GameRecordData>(data.game_data);
					InitData(data.level, data.strength, data.play_time, data.already_play_time, data.point, gameRecordData.AllPass, gameRecordData.PerfectNum, gameRecordData.ContinuateMaxNum, gameRecordData.TimeOutNum, gameRecordData.TouchEdgeNum, gameRecordData.TouchMachineNum, gameRecordData.Staminas, gameRecordData.InitLevel, gameRecordData.MaxLevel, gameRecordData.MinLevel);
				}
			}
			else
			{
				string text2 = LoadManager.LevelID + "-" + LoadManager.StrengthID;
				InitData(LoadManager.LevelID, LoadManager.StrengthID, LoadManager.Duration, 0, 0, 0, 0, 0, 0, 0, 0, new List<int>(), text2, text2, text2);
			}
			IsStartGame = true;
			RingRootController.Instance.CreateElectricRing();
			UIController.Instance.StartGame();
			PlayerController.Instance.IsShowVivePointers(isShow: false);
		}

		private static void InitData(int level, int strength, int duration, int durationed, int score, int allpass, int perfect, int continuate, int timeout, int touchedge, int touchmachine, List<int> stam, string start, string max, string min)
		{
			curLevelID = level;
			curStrengthID = strength;
			gameDuration = duration;
			gameDurationed = durationed;
			curScore = score;
			allPass = allpass;
			perfectNum = perfect;
			continuateMaxNum = continuate;
			timeOutNum = timeout;
			touchEdgeNum = touchedge;
			touchMachineNum = touchmachine;
			staminas = stam;
			startLevel = start;
			maxLevel = max;
			minLevel = min;
		}

		public static void OverTheGame()
		{
			IsPlayGame = false;
			IsStartGame = false;
			BraceletController.Instance.OnReleaseGrabbed();
			RingRootController.Instance.DestroyElectricRing();
			PlayerController.Instance.StopAllCoroutines();
			UIController.Instance.OverTheGame();
		}

		public static void ResetTheGame()
		{
			IsPlayGame = false;
			IsStartGame = false;
			BraceletController.Instance.OnReleaseGrabbed();
			RingRootController.Instance.DestroyElectricRing();
			PlayerController.Instance.StopAllCoroutines();
		}

		public static string GetInitChallengeLevel()
		{
			string[] array = startLevel.Split('-');
			return LevelDataDic[int.Parse(array[0])].LevelName + "-" + StrengthDataDic[int.Parse(array[1])].StrengthGrade;
		}

		public static string GetMaxChallengeLevel()
		{
			string[] array = maxLevel.Split('-');
			return LevelDataDic[int.Parse(array[0])].LevelName + "-" + StrengthDataDic[int.Parse(array[1])].StrengthGrade;
		}

		public static string GetMinChallengeLevel()
		{
			string[] array = minLevel.Split('-');
			return LevelDataDic[int.Parse(array[0])].LevelName + "-" + StrengthDataDic[int.Parse(array[1])].StrengthGrade;
		}

		public static void AddStrength(int upshift)
		{
			curStrengthID += upshift;
			if (curStrengthID > 9)
			{
				if (LoadManager.IsLocalOperate && curLevelID >= LoadManager.MaxLevelID)
				{
					curStrengthID = 9;
				}
				else if (curLevelID >= LevelDataDic.Count - 1)
				{
					curStrengthID = 9;
				}
				else
				{
					curStrengthID -= 10;
					curLevelID++;
				}
			}
			SetMaxLevel();
			UIController.Instance.LevelTxt.text = GetCurLevel;
			LoadManager.SubmitLevelRecord(curLevelID, curStrengthID, UIController.Instance.GetUseDuration(), curScore, J_LitJson.JsonMapper.ToJson(GetGameRecord()));
		}

		public static void ReduceStrength(int downshift)
		{
			curStrengthID -= downshift;
			if (curStrengthID < 0)
			{
				if (curLevelID <= 0)
				{
					curStrengthID = 0;
				}
				else
				{
					curStrengthID += 10;
					curLevelID--;
				}
			}
			SetMinLevel();
			UIController.Instance.LevelTxt.text = GetCurLevel;
			LoadManager.SubmitLevelRecord(curLevelID, curStrengthID, UIController.Instance.GetUseDuration(), curScore, J_LitJson.JsonMapper.ToJson(GetGameRecord()));
		}

		private static void SetMaxLevel()
		{
			string[] array = maxLevel.Split('-');
			int num = int.Parse(array[0]);
			int num2 = int.Parse(array[1]);
			if (curLevelID == num)
			{
				if (curStrengthID > num2)
				{
					maxLevel = curLevelID + "-" + curStrengthID;
				}
			}
			else if (curLevelID > num)
			{
				maxLevel = curLevelID + "-" + curStrengthID;
			}
		}

		private static void SetMinLevel()
		{
			string[] array = minLevel.Split('-');
			int num = int.Parse(array[0]);
			int num2 = int.Parse(array[1]);
			if (curLevelID == num)
			{
				if (curStrengthID < num2)
				{
					minLevel = curLevelID + "-" + curStrengthID;
				}
			}
			else if (curLevelID < num)
			{
				minLevel = curLevelID + "-" + curStrengthID;
			}
		}

		public static void AddScore(int score)
		{
			curScore += score;
			UIController.Instance.CurScoreTxt.text = curScore.ToString();
		}

		public static void SetChanglleNum(int missMun)
		{
			int num = CurElectricLevel.ChallengeNum - missMun;
			UIController.Instance.ChanglleNumTxt.text = ((num == 0) ? 1 : num).ToString();
		}

		public static void SetChanglleTime(float catchTimer)
		{
			UIController.Instance.ChanglleTimeTxt.text = Mathf.Ceil(catchTimer).ToString();
		}

		public static GameRecordData GetGameRecord()
		{
			return new GameRecordData
			{
				InitLevel = minLevel,
				MaxLevel = maxLevel,
				MinLevel = minLevel,
				AllPass = allPass,
				PerfectNum = perfectNum,
				ContinuateMaxNum = continuateMaxNum,
				TimeOutNum = timeOutNum,
				TouchEdgeNum = touchEdgeNum,
				TouchMachineNum = touchMachineNum,
				Staminas = staminas
			};
		}
	}
	public class CustomRecordData
	{
		public List<string> ErrorPoint;
	}
	public class GameRecordData
	{
		public string InitLevel;

		public string MaxLevel;

		public string MinLevel;

		public int AllPass;

		public int PerfectNum;

		public int ContinuateMaxNum;

		public int TimeOutNum;

		public int TouchEdgeNum;

		public int TouchMachineNum;

		public List<int> Staminas;
	}
	public class PlayerController : MonoBehaviour
	{
		public static PlayerController Instance;

		public GameObject club;

		public Pvr_ControllerModuleInit pvr_ControllerModuleInit;

		public BatteryTipController batteryTipController;

		private bool lastVivePointersIsShow;

		private void Awake()
		{
			Instance = this;
		}

		private void Start()
		{
			Time.fixedDeltaTime = 0.01f;
		}

		private void Update()
		{
		}

		public void InitData()
		{
			List<ElectricLevel> list = CsvMapper.ToObjectList<ElectricLevel>(LoadManager.CsvRead("ElectricClubLevel"));
			CheckpointManager.LevelDataDic.Clear();
			foreach (ElectricLevel item in list)
			{
				CheckpointManager.LevelDataDic.Add(item.LevelID, item);
			}
			List<ElectricStrength> list2 = CsvMapper.ToObjectList<ElectricStrength>(LoadManager.CsvRead("ElectricClubStrength"));
			CheckpointManager.StrengthDataDic.Clear();
			foreach (ElectricStrength item2 in list2)
			{
				CheckpointManager.StrengthDataDic.Add(item2.StrengthID, item2);
			}
			List<ElectricMap> list3 = CsvMapper.ToObjectList<ElectricMap>(LoadManager.CsvRead("ElectricClubMap"));
			CheckpointManager.MapDataDic.Clear();
			foreach (ElectricMap item3 in list3)
			{
				CheckpointManager.MapDataDic.Add(item3.MapID, item3);
			}
		}

		public void IsShowVivePointers(bool isShow)
		{
			lastVivePointersIsShow = pvr_ControllerModuleInit.GetModuleState();
			pvr_ControllerModuleInit.ForceHideOrShow(isShow);
			club.SetActive(!isShow);
		}

		public void ResetShowVivePointers()
		{
			pvr_ControllerModuleInit.ForceHideOrShow(lastVivePointersIsShow);
			club.SetActive(!lastVivePointersIsShow);
		}

		public void DelayHander(float time, Action action)
		{
			StartCoroutine(Wait(time, action));
		}

		private IEnumerator Wait(float time, Action action)
		{
			yield return new WaitForSeconds(time);
			action?.Invoke();
		}
	}
	public class RingRootController : MonoBehaviour
	{
		public static RingRootController Instance;

		public BraceletController braceletController;

		public GameObject rightHand;

		public Animator handAnimator;

		public Transform handleTra;

		public ParticleSystem endParticle;

		public Material metalBallMat;

		public Material metalLineMat;

		public Material insulationMat;

		private Transform startPoint;

		private Transform endPoint;

		private Transform insulationTra;

		private Transform uninsulatedTra;

		private Transform cubeTra;

		private Transform machineTra;

		private Transform checkPointTra;

		private Transform copyingTra;

		private Transform lowerLeftTra;

		private Transform topRightTra;

		private Spline splineTra;

		private GameObject electricRing;

		private Transform firstCheckPoint;

		private Transform secondCheckPoint;

		private int curCheckNum;

		private float challengeTimer;

		private int curMissNum;

		private int lastRandom = 1000;

		private List<int> curStaminas;

		public int CurCheckNum => curCheckNum;

		public bool IsChallengeFail
		{
			get
			{
				curMissNum++;
				CheckpointManager.SetChanglleNum(curMissNum);
				return curMissNum >= CheckpointManager.CurElectricLevel.ChallengeNum;
			}
		}

		public bool IsPerfectPass
		{
			get
			{
				if (curMissNum == 0)
				{
					return true;
				}
				return false;
			}
		}

		public List<int> CurStaminas
		{
			get
			{
				if (curStaminas == null)
				{
					curStaminas = new List<int>();
				}
				return curStaminas;
			}
		}

		private void Awake()
		{
			Instance = this;
		}

		private void Start()
		{
		}

		private void Update()
		{
			if (CheckpointManager.IsStartGame && CheckpointManager.IsPlayGame && Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.TRIGGER) && Vector3.Distance(handleTra.position, rightHand.transform.position) < 0.2f)
			{
				BraceletController.Instance.OnPipeGrabbed();
			}
			if (UIController.Instance.isStartTime)
			{
				challengeTimer -= Time.deltaTime;
				CheckpointManager.SetChanglleTime(challengeTimer);
				if (challengeTimer <= 0f)
				{
					CheckpointManager.SetChanglleTime(0f);
					UIController.Instance.PlayAudioSound(1);
					CheckpointManager.timeOutNum++;
					UIController.Instance.IsStartTime(isStart: false);
					AddStaminas();
					SetStaminas();
					CheckpointManager.ReduceStrength(CheckpointManager.CurElectricLevel.DownshiftGrade);
					ChallengeFinish();
				}
			}
		}

		public void CreateElectricRing()
		{
			CurStaminas.Clear();
			List<int> randomLevel = CheckpointManager.CurElectricLevel.RandomLevel;
			lastRandom = MyMath.RandomRange(0, randomLevel.Count, lastRandom);
			CheckpointManager.curMapID = randomLevel[lastRandom];
			challengeTimer = CheckpointManager.GetTime;
			CheckpointManager.SetChanglleTime(challengeTimer);
			curMissNum = 0;
			CheckpointManager.SetChanglleNum(curMissNum);
			braceletController.gameObject.SetActive(value: true);
			electricRing = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("Prefabs/VR电流棒/E" + CheckpointManager.curMapID), base.transform);
			electricRing.transform.localPosition = Vector3.zero;
			int num = 0;
			int num2 = 0;
			if (CheckpointManager.CurElectricLevel.HorizontalFlip == 1 && UnityEngine.Random.Range(0, 2) == 1)
			{
				num2 = 180;
			}
			if (CheckpointManager.CurElectricLevel.VerticalFlip == 1 && UnityEngine.Random.Range(0, 2) == 1)
			{
				num = 180;
			}
			electricRing.transform.localEulerAngles = new Vector3(num, num2, 0f);
			startPoint = electricRing.transform.Find("StartPoint");
			startPoint.localEulerAngles = new Vector3(num, num2, startPoint.localEulerAngles.z);
			endPoint = electricRing.transform.Find("EndPoint");
			endParticle.transform.position = endPoint.position;
			insulationTra = electricRing.transform.Find("Insulation");
			HighlightEffect[] componentsInChildren = electricRing.GetComponentsInChildren<HighlightEffect>();
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				componentsInChildren[i].enabled = false;
			}
			if ((bool)insulationTra)
			{
				foreach (Transform item in insulationTra)
				{
					item.gameObject.AddComponent<MeshCollider>();
					item.GetComponent<Renderer>().material = insulationMat;
				}
			}
			uninsulatedTra = electricRing.transform.Find("Uninsulated");
			if ((bool)uninsulatedTra)
			{
				foreach (Transform item2 in uninsulatedTra)
				{
					item2.gameObject.AddComponent<MeshCollider>();
					item2.GetComponent<Renderer>().material = metalLineMat;
				}
			}
			machineTra = electricRing.transform.Find("Machine");
			if ((bool)machineTra)
			{
				foreach (Transform item3 in machineTra)
				{
					item3.gameObject.AddComponent<MeshCollider>();
					item3.GetComponent<Renderer>().material = metalBallMat;
				}
			}
			cubeTra = electricRing.transform.Find("Cube");
			if ((bool)cubeTra)
			{
				foreach (Transform item4 in cubeTra)
				{
					item4.gameObject.AddComponent<BoxCollider>();
					item4.GetComponent<Renderer>().material = metalBallMat;
				}
			}
			curCheckNum = 0;
			checkPointTra = electricRing.transform.Find("CheckPoint");
			if ((bool)checkPointTra)
			{
				foreach (Transform item5 in checkPointTra)
				{
					item5.localEulerAngles = new Vector3(num, num2, item5.localEulerAngles.z);
					MeshRenderer component = item5.GetComponent<MeshRenderer>();
					if ((bool)component)
					{
						component.enabled = false;
					}
					curCheckNum++;
				}
				curCheckNum++;
			}
			copyingTra = electricRing.transform.Find("Copying");
			if ((bool)copyingTra)
			{
				lowerLeftTra = copyingTra.transform.Find("LowerLeft");
				topRightTra = copyingTra.transform.Find("TopRight");
			}
			splineTra = electricRing.GetComponentInChildren<Spline>();
			braceletController.transform.position = startPoint.position;
			braceletController.transform.eulerAngles = startPoint.eulerAngles;
			braceletController.transform.localScale = new Vector3(CheckpointManager.GetChangeValue, CheckpointManager.GetChangeValue, 1f);
			braceletController.getPathProcess.SetSpline(splineTra);
			firstCheckPoint = null;
			secondCheckPoint = null;
			handAnimator.gameObject.SetActive(value: true);
			CheckpointManager.IsPlayGame = true;
		}

		public void DestroyElectricRing()
		{
			braceletController.gameObject.SetActive(value: false);
			UnityEngine.Object.Destroy(electricRing);
			electricRing = null;
		}

		public void ChallengeFinish()
		{
			braceletController.OnReleaseGrabbed();
			DestroyElectricRing();
			PlayerController.Instance.DelayHander(1f, delegate
			{
				UIController.Instance.CheckBattery(delegate
				{
					UIController.Instance.SuspendGame(suspend: false);
					CreateElectricRing();
				});
			});
		}

		public bool CheckIsInsulation(Transform child)
		{
			if ((bool)uninsulatedTra && child.IsChildOf(uninsulatedTra))
			{
				CheckpointManager.touchEdgeNum++;
				return true;
			}
			if ((bool)cubeTra && child.IsChildOf(cubeTra))
			{
				CheckpointManager.touchMachineNum++;
				return true;
			}
			if ((bool)machineTra && child.IsChildOf(machineTra))
			{
				CheckpointManager.touchMachineNum++;
				return true;
			}
			return false;
		}

		public bool CheckIsCheckPoint(Transform child)
		{
			if (!checkPointTra)
			{
				return false;
			}
			if (child.IsChildOf(checkPointTra))
			{
				return true;
			}
			return false;
		}

		public bool CheckIsFinsh(Transform child)
		{
			if (child.IsChildOf(endPoint))
			{
				return true;
			}
			return false;
		}

		public void ResetBraceletPos()
		{
			if (firstCheckPoint == null && secondCheckPoint == null)
			{
				braceletController.transform.position = startPoint.position;
				braceletController.transform.eulerAngles = startPoint.eulerAngles;
			}
			else if ((bool)firstCheckPoint && secondCheckPoint == null)
			{
				braceletController.transform.position = firstCheckPoint.position;
				braceletController.transform.eulerAngles = firstCheckPoint.eulerAngles;
			}
			else if ((bool)firstCheckPoint && (bool)secondCheckPoint)
			{
				braceletController.transform.position = secondCheckPoint.position;
				braceletController.transform.eulerAngles = secondCheckPoint.eulerAngles;
			}
			CheckpointManager.IsPlayGame = true;
		}

		public void ArriveCheckPoint(Transform check)
		{
			if (firstCheckPoint == null)
			{
				firstCheckPoint = check;
			}
			else if (firstCheckPoint != check && secondCheckPoint == null)
			{
				secondCheckPoint = check;
			}
		}

		public void SetCountDownPos(Transform countdown)
		{
			if (firstCheckPoint == null && secondCheckPoint == null)
			{
				countdown.position = startPoint.position + new Vector3(0f, 0.075f, 0f);
			}
			else if ((bool)firstCheckPoint && secondCheckPoint == null)
			{
				countdown.position = firstCheckPoint.position + new Vector3(0f, 0.075f, 0f);
			}
			else if ((bool)firstCheckPoint && (bool)secondCheckPoint)
			{
				countdown.position = secondCheckPoint.position + new Vector3(0f, 0.075f, 0f);
			}
			countdown.eulerAngles = Vector3.zero;
		}

		public string GetPostionProportion(Vector3 pos)
		{
			if (copyingTra == null)
			{
				return string.Empty;
			}
			Vector3 vector = copyingTra.InverseTransformPoint(pos);
			vector.z = 0f;
			float num = Vector3.Distance(b: new Vector3(vector.x, lowerLeftTra.localPosition.y, 0f), a: lowerLeftTra.localPosition);
			float num2 = Vector3.Distance(b: new Vector3(topRightTra.localPosition.x, lowerLeftTra.localPosition.y, 0f), a: lowerLeftTra.localPosition);
			float num3 = num / num2;
			float num4 = Vector3.Distance(b: new Vector3(lowerLeftTra.localPosition.x, vector.y, 0f), a: lowerLeftTra.localPosition);
			float num5 = Vector3.Distance(b: new Vector3(lowerLeftTra.localPosition.x, topRightTra.localPosition.y, 0f), a: lowerLeftTra.localPosition);
			return string.Concat(arg2: num4 / num5, arg0: num3, arg1: "-");
		}

		public int PassCheckNum()
		{
			if ((bool)firstCheckPoint && (bool)secondCheckPoint)
			{
				return 2;
			}
			if ((bool)firstCheckPoint && secondCheckPoint == null)
			{
				return 1;
			}
			if (firstCheckPoint == null && (bool)secondCheckPoint)
			{
				return 1;
			}
			return 0;
		}

		public float GetPassProgress()
		{
			return (float)PassCheckNum() / (float)curCheckNum;
		}

		public void AddStaminas(bool isEnd = false)
		{
			if (isEnd)
			{
				CurStaminas.Add(100);
			}
			else
			{
				CurStaminas.Add(braceletController.GetProcess());
			}
		}

		public void SetStaminas()
		{
			CheckpointManager.staminas.Add(MyMath.GetAverage(CurStaminas));
		}
	}
	public class UIController : MonoBehaviour
	{
		public static UIController Instance;

		public GameObject StaticCanvas;

		[Header("开始界面")]
		public GameObject StartGamePanel;

		public ToggleGroup toggleGroup;

		public Button startGameBtn;

		public Button settingsBtn;

		public Button tipsBtn;

		public Button exitBtn;

		public AudioSource bgAudioSource;

		[Header("游戏界面")]
		public GameObject ScorePanel;

		public Text CurScoreTxt;

		public Text LevelTxt;

		public Text TotalTimeTxt;

		public Text ChanglleNumTxt;

		public Text ChanglleTimeTxt;

		[Header("结算界面")]
		public GameObject PassAllCheckpointPanel;

		public TextMeshProUGUI ScoreTxt;

		public Text TrainingDurationTxt;

		public Text InitChallengeLevelTxt;

		public Text MaxChallengeLevelTxt;

		public Text MinChallengeLevelTxt;

		public Text AllPassTxt;

		public Text PerfectNumTxt;

		public Text ContinuateMaxNumTxt;

		public Text TimeOutNumTxt;

		public Text TouchEdgeNumTxt;

		public Text TouchMachineNumTxt;

		public Button passAllReturnBtn;

		[Header("暂停界面")]
		public GameObject SuspendPanel;

		public Button suspendReturnStartBtn;

		public Button suspendReturnBtn;

		[Header("退出提示界面")]
		public GameObject ExitTipPanel;

		public Button defineBtn;

		public Button cancelBtn;

		public AudioSource audioSource;

		public AudioClip[] audioClips;

		public bool isStartTime;

		private int curErrorTimes;

		private List<string> curErrorPoints;

		private float surplusGameDuration;

		private void Awake()
		{
			Instance = this;
		}

		private void Start()
		{
			ScorePanel.SetActive(value: false);
			PassAllCheckpointPanel.SetActive(value: false);
			startGameBtn.onClick.AddListener(StartGameBtnHander);
			exitBtn.onClick.AddListener(ExitBtnHander);
			passAllReturnBtn.onClick.AddListener(PassAllBtnHander);
			suspendReturnStartBtn.onClick.AddListener(SuspendReturnStartBtnHander);
			suspendReturnBtn.onClick.AddListener(SuspendReturnBtnHander);
			defineBtn.onClick.AddListener(DefineBtnHander);
			cancelBtn.onClick.AddListener(CancelBtnHander);
			for (int i = 0; i < toggleGroup.transform.childCount; i++)
			{
				int index = i;
				Toggle component = toggleGroup.transform.GetChild(i).GetComponent<Toggle>();
				component.onValueChanged.AddListener(delegate(bool value)
				{
					if (value)
					{
						LoadManager.LevelID = index;
					}
				});
				if (LoadManager.LevelID == index)
				{
					component.isOn = true;
				}
			}
			PlayerController.Instance.InitData();
			if (LoadManager.IsLocalOperate)
			{
				StartGamePanel.SetActive(value: true);
				return;
			}
			StartGamePanel.SetActive(value: false);
			StartGameBtnHander(LoadManager.course);
		}

		private void Update()
		{
			if (CheckpointManager.IsStartGame)
			{
				surplusGameDuration -= Time.deltaTime;
				TotalTimeTxt.text = LoadManager.TimeConversion((int)surplusGameDuration);
				if (surplusGameDuration <= 0f)
				{
					RingRootController.Instance.handAnimator.gameObject.SetActive(value: true);
					PlayerController.Instance.IsShowVivePointers(isShow: true);
					CheckpointManager.OverTheGame();
				}
			}
			if (IsCanSuspend() && (Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.APP) || Input.GetKeyDown(KeyCode.Escape)))
			{
				RingRootController.Instance.handAnimator.gameObject.SetActive(value: true);
				PlayerController.Instance.IsShowVivePointers(isShow: true);
				IsStartTime(isStart: false);
				StaticCanvas.SetActive(value: true);
				SuspendPanel.SetActive(value: true);
				Time.timeScale = 0f;
			}
		}

		public void StartGame()
		{
			StaticCanvas.SetActive(value: false);
			ScorePanel.SetActive(value: true);
			surplusGameDuration = CheckpointManager.gameDuration - CheckpointManager.gameDurationed;
			curErrorTimes = 0;
			curErrorPoints = new List<string>();
			CurScoreTxt.text = CheckpointManager.curScore.ToString();
			LevelTxt.text = CheckpointManager.GetCurLevel;
			TotalTimeTxt.text = LoadManager.TimeConversion((int)surplusGameDuration);
			CheckpointManager.SetChanglleNum(0);
			ChanglleTimeTxt.text = CheckpointManager.CurElectricMap.LimitTime.ToString();
		}

		public void IsStartTime(bool isStart = true)
		{
			isStartTime = isStart;
		}

		public void ErrorAnswer(string point)
		{
			IsStartTime(isStart: false);
			curErrorTimes++;
			curErrorPoints.Add(point);
		}

		public int GetUseDuration(bool isComplete = false)
		{
			float num = CheckpointManager.gameDuration - surplusGameDuration;
			num = (isComplete ? CheckpointManager.gameDuration : num);
			return (int)num;
		}

		public void OverTheGame()
		{
			PlayerController.Instance.IsShowVivePointers(isShow: true);
			IsStartTime(isStart: false);
			PlayAudioSound(4);
			StaticCanvas.SetActive(value: true);
			ScorePanel.SetActive(value: false);
			PassAllCheckpointPanel.SetActive(value: true);
			ScoreTxt.text = CheckpointManager.curScore.ToString();
			TrainingDurationTxt.text = LoadManager.TimeConversion((int)CheckpointManager.gameDuration);
			InitChallengeLevelTxt.text = CheckpointManager.GetInitChallengeLevel();
			MaxChallengeLevelTxt.text = CheckpointManager.GetMaxChallengeLevel();
			MinChallengeLevelTxt.text = CheckpointManager.GetMinChallengeLevel();
			AllPassTxt.text = CheckpointManager.allPass.ToString();
			PerfectNumTxt.text = CheckpointManager.perfectNum.ToString();
			ContinuateMaxNumTxt.text = CheckpointManager.continuateMaxNum.ToString();
			TimeOutNumTxt.text = CheckpointManager.timeOutNum.ToString();
			TouchEdgeNumTxt.text = CheckpointManager.touchEdgeNum.ToString();
			TouchMachineNumTxt.text = CheckpointManager.touchMachineNum.ToString();
		}

		public void PlayAudioSound(int index)
		{
			if (audioSource.isPlaying)
			{
				audioSource.Stop();
			}
			audioSource.clip = audioClips[index];
			audioSource.Play();
		}

		public void CheckBattery(Action continueAction)
		{
			if (PlayerController.Instance.batteryTipController.CheckBattery(continueAction))
			{
				SuspendGame(suspend: true);
			}
		}

		public void SuspendGame(bool suspend)
		{
			RingRootController.Instance.handAnimator.gameObject.SetActive(suspend);
			PlayerController.Instance.IsShowVivePointers(suspend);
			if (suspend)
			{
				IsStartTime(isStart: false);
			}
			StaticCanvas.SetActive(suspend);
			Time.timeScale = ((!suspend) ? 1 : 0);
		}

		private void StartGameBtnHander()
		{
			StartGameBtnHander(null);
		}

		private void StartGameBtnHander(CourseDetail.Data data)
		{
			StartGamePanel.SetActive(value: false);
			bgAudioSource.Play();
			CheckpointManager.StartTheLevel(data);
		}

		private void ExitBtnHander()
		{
			ScenesHelper.LoadScene(ScenesHelper.WeiAiZhiCenterScene);
		}

		private void PassAllBtnHander()
		{
			if (LoadManager.IsLocalOperate)
			{
				StartGamePanel.SetActive(value: true);
				PassAllCheckpointPanel.SetActive(value: false);
			}
			else
			{
				LoadManager.SubmitEndRecord(isComplete: true, isLogout: false, GetUseDuration(isComplete: true), CheckpointManager.curScore, J_LitJson.JsonMapper.ToJson(CheckpointManager.GetGameRecord()));
			}
		}

		private void SuspendReturnStartBtnHander()
		{
			if (LoadManager.IsLocalOperate)
			{
				CheckpointManager.ResetTheGame();
				StaticCanvas.SetActive(value: true);
				StartGamePanel.SetActive(value: true);
				SuspendPanel.SetActive(value: false);
				ScorePanel.SetActive(value: false);
				Time.timeScale = 1f;
			}
			else
			{
				ExitTipPanel.SetActive(value: true);
			}
		}

		private void SuspendReturnBtnHander()
		{
			PlayerController.Instance.ResetShowVivePointers();
			StaticCanvas.SetActive(value: false);
			SuspendPanel.SetActive(value: false);
			Time.timeScale = 1f;
		}

		private void DefineBtnHander()
		{
			Time.timeScale = 1f;
			LoadManager.SubmitEndRecord(isComplete: false, isLogout: false, GetUseDuration(), CheckpointManager.curScore, J_LitJson.JsonMapper.ToJson(CheckpointManager.GetGameRecord()));
		}

		private void CancelBtnHander()
		{
			ExitTipPanel.SetActive(value: false);
		}

		private bool IsCanSuspend()
		{
			if (PassAllCheckpointPanel.activeSelf)
			{
				return false;
			}
			if (CheckpointManager.IsStartGame)
			{
				return true;
			}
			return false;
		}
	}
}
namespace CatchFishGame
{
	public class ArrowShake : MonoBehaviour
	{
		public float degreesPerSecond = 15f;

		public float amplitude = 0.5f;

		public float frequency = 1f;

		private Vector3 posOffset;

		private Vector3 tempPos;

		private void Start()
		{
			posOffset = base.transform.position;
		}

		private void Update()
		{
			base.transform.Rotate(new Vector3(0f, Time.deltaTime * degreesPerSecond, 0f), Space.World);
			tempPos = posOffset;
			tempPos.y += Mathf.Sin(Time.fixedTime * (float)Math.PI * frequency) * amplitude;
			base.transform.position = tempPos;
		}
	}
	public class BulletController : MonoBehaviour
	{
		public Vector3 dir;

		public float speed;

		public SkinnedMeshRenderer skinnedMesh;

		public AudioClip[] audioClips;

		public AudioSource audioSource;

		private Rigidbody rigid;

		private FishController controller;

		private float timer = 5f;

		private bool isPlayAni;

		private float aniTimer = 2f;

		private bool isTouchObj;

		private void Start()
		{
		}

		private void Update()
		{
			if (isPlayAni)
			{
				skinnedMesh.gameObject.SetActive(value: true);
				float blendShapeWeight = skinnedMesh.GetBlendShapeWeight(0);
				if (blendShapeWeight < 100f)
				{
					blendShapeWeight += Time.deltaTime * 100f;
					skinnedMesh.SetBlendShapeWeight(0, blendShapeWeight);
					if (controller != null && controller.transform.localScale.x >= 0.01f)
					{
						controller.transform.localScale -= Vector3.one * Time.deltaTime * 5f;
					}
					return;
				}
				if (controller == null)
				{
					UnityEngine.Object.Destroy(base.gameObject);
					return;
				}
				base.transform.forward = Vector3.up;
				Vector3 position = base.transform.position;
				position.y += Time.deltaTime * 4f;
				base.transform.position = position;
				if (base.transform.position.y >= 5f)
				{
					isPlayAni = false;
					UnityEngine.Object.Destroy(base.gameObject);
					UnityEngine.Object.Destroy(controller.transform.parent.gameObject);
				}
			}
			else
			{
				timer -= Time.deltaTime;
				if (timer <= 0f)
				{
					UnityEngine.Object.Destroy(base.gameObject);
				}
			}
		}

		public void Launch()
		{
			rigid = GetComponent<Rigidbody>();
			rigid.AddForce(dir * speed);
		}

		private void OnCollisionEnter(UnityEngine.Collision collision)
		{
			if (!isTouchObj && !collision.gameObject.name.Equals("Player") && CheckpointManager.IsStartGame)
			{
				isTouchObj = true;
				controller = collision.transform.GetComponent<FishController>();
				if ((bool)controller)
				{
					base.transform.forward = dir;
					Controller.UPvr_VibrateNeo2Controller(0.5f, 50, Pvr_ControllerManager.controllerlink.mainHandID);
					rigid.Sleep();
					EnterCatchAnimation();
					SwarmController.Instance.ReduceFish(controller.fishNum);
				}
				else
				{
					rigid.isKinematic = true;
					ContactPoint contactPoint = collision.contacts[0];
					rigid.Sleep();
					base.transform.forward = -contactPoint.normal;
					EnterCatchAnimation();
				}
			}
		}

		private void OnTriggerEnter(Collider other)
		{
		}

		private void EnterCatchAnimation()
		{
			isPlayAni = true;
		}
	}
	public class LevelData
	{
		public int Levelid;

		public string LevelName;

		public List<int> CheckpointArray;

		public int NextLevelid;
	}
	public class CheckpointData
	{
		public int CheckpointID;

		public float Oxygen;

		public float TargetNum;

		public float MaxFishNum;

		public float TargetLimitNum;

		public int FontColor;

		public int TimeThreshold;

		public int TimeScore;

		public int MissLimitTimes;

		public int NoMissScore;
	}
	public class CatchFishLevel
	{
		public int LevelID;

		public string LevelName;

		public List<int> FigureRange;

		public float LimitTime;

		public int BaseScore;

		public int ChallengeNum;

		public int FishNumber;

		public float FishSpeed;

		public int RightFish;

		public int FigureColor;

		public List<int> FishType;

		public int FigureSize;

		public List<int> FourRulesType;

		public int UpshiftRequire;

		public int UpshiftGrade;

		public int DownshiftRequire;

		public int DownshiftGrade;

		public float Probability;
	}
	public class CatchFishStrength
	{
		public int StrengthID;

		public int StrengthGrade;

		public float ScoreAddition;

		public float SpeedAddition;

		public float FishNumAddition;

		public float Probability;
	}
	public class CheckpointManager
	{
		public static Dictionary<int, CatchFishLevel> LevelDataDic = new Dictionary<int, CatchFishLevel>();

		public static Dictionary<int, CatchFishStrength> StrengthDataDic = new Dictionary<int, CatchFishStrength>();

		public static List<ColorData> colorDatas = new List<ColorData>();

		public static List<GameRecordData> gameRecordDatas = new List<GameRecordData>();

		public static int curLevelID;

		public static int curStrengthID;

		public static float gameDuration;

		public static float gameDurationed;

		public static int curCatchScore;

		public static int curAllShootNum;

		public static int needCatchTotal;

		public static int selfControl;

		public static int curShootNum;

		public static int allCatchNum;

		public static float theBestCatch;

		public static string startLevel;

		public static string minLevel;

		public static string maxLevel;

		public static int allPass;

		public static int perfectNum;

		public static int continuateMaxNum;

		public static int timeOutNum;

		public static bool IsStartGame = false;

		public static CatchFishLevel CurCatchFishLevel => LevelDataDic[curLevelID];

		public static CatchFishStrength CurCatchFishStrength => StrengthDataDic[curStrengthID];

		public static int GetFishScore => (int)((float)CurCatchFishLevel.BaseScore * (1f + CurCatchFishStrength.ScoreAddition));

		public static float GetFishSpeed => CurCatchFishLevel.FishSpeed * (1f + CurCatchFishStrength.SpeedAddition);

		public static int GetFishNumber => (int)((float)CurCatchFishLevel.FishNumber * (1f + CurCatchFishStrength.FishNumAddition));

		public static int GetRangeMin => CurCatchFishLevel.FigureRange[0];

		public static int GetRangeMax => CurCatchFishLevel.FigureRange[1];

		public static float GetProbability => CurCatchFishLevel.Probability * CurCatchFishStrength.Probability;

		public static string GetCurLevel => LevelDataDic[curLevelID].LevelName + "-" + StrengthDataDic[curStrengthID].StrengthGrade;

		public static int GetFourRulesType
		{
			get
			{
				if (LoadManager.userData == null)
				{
					return CurCatchFishLevel.FourRulesType[0];
				}
				int course_many_time = LoadManager.userData.data.course_many_time;
				course_many_time = ((course_many_time < CurCatchFishLevel.FourRulesType.Count) ? (course_many_time - 1) : (CurCatchFishLevel.FourRulesType.Count - 1));
				return CurCatchFishLevel.FourRulesType[course_many_time];
			}
		}

		public static void StartTheLevel(CourseDetail.Data data)
		{
			if (data != null)
			{
				if (data.game_data == null)
				{
					string text = data.level + "-" + data.strength;
					InitData(data.level, data.strength, data.play_time, data.already_play_time, data.point, 0, 0, 0, 0, 0, 0, 60f, 0, 0, text, text, text);
				}
				else
				{
					GameRecordData gameRecordData = J_LitJson.JsonMapper.ToObject<GameRecordData>(data.game_data);
					InitData(data.level, data.strength, data.play_time, data.already_play_time, data.point, gameRecordData.AllShootNum, gameRecordData.CatchTotal, gameRecordData.AllPass, gameRecordData.PerfectNum, gameRecordData.ContinuateMaxNum, gameRecordData.TimeOutNum, gameRecordData.TheBestCatch, gameRecordData.NeedCatchTotal, gameRecordData.SelfControl, gameRecordData.InitLevel, gameRecordData.MaxLevel, gameRecordData.MinLevel);
				}
			}
			else
			{
				string text2 = LoadManager.LevelID + "-" + LoadManager.StrengthID;
				InitData(LoadManager.LevelID, LoadManager.StrengthID, LoadManager.Duration, 0, 0, 0, 0, 0, 0, 0, 0, 60f, 0, 0, text2, text2, text2);
			}
			UIController.Instance.mainCanvas.SetActive(value: false);
			SwarmController.Instance.CreatFishs();
		}

		private static void InitData(int level, int strength, int duration, int durationed, int score, int allshoot, int catchnum, int allpass, int perfect, int continuate, int timeout, float thebest, int need, int control, string start, string max, string min)
		{
			curLevelID = level;
			curStrengthID = strength;
			gameDuration = duration;
			gameDurationed = durationed;
			curCatchScore = score;
			curAllShootNum = allshoot;
			allCatchNum = catchnum;
			allPass = allpass;
			perfectNum = perfect;
			continuateMaxNum = continuate;
			timeOutNum = timeout;
			theBestCatch = thebest;
			needCatchTotal = need;
			selfControl = control;
			startLevel = start;
			maxLevel = max;
			minLevel = min;
			curShootNum = 0;
		}

		public static void OverTheGame()
		{
			IsStartGame = false;
			UIController.Instance.mainCanvas.SetActive(value: true);
			UIController.Instance.OverTheGame();
			SwarmController.Instance.Init();
		}

		public static void ResetTheGame()
		{
			IsStartGame = false;
			SwarmController.Instance.Init();
		}

		public static string GetInitChallengeLevel()
		{
			string[] array = startLevel.Split('-');
			return LevelDataDic[int.Parse(array[0])].LevelName + "-" + StrengthDataDic[int.Parse(array[1])].StrengthGrade;
		}

		public static string GetMaxChallengeLevel()
		{
			string[] array = maxLevel.Split('-');
			return LevelDataDic[int.Parse(array[0])].LevelName + "-" + StrengthDataDic[int.Parse(array[1])].StrengthGrade;
		}

		public static string GetMinChallengeLevel()
		{
			string[] array = minLevel.Split('-');
			return LevelDataDic[int.Parse(array[0])].LevelName + "-" + StrengthDataDic[int.Parse(array[1])].StrengthGrade;
		}

		public static void AddStrength(int upshift)
		{
			curStrengthID += upshift;
			if (curStrengthID > 9)
			{
				if (LoadManager.IsLocalOperate && curLevelID >= LoadManager.MaxLevelID)
				{
					curStrengthID = 9;
				}
				else if (curLevelID >= LevelDataDic.Count - 1)
				{
					curStrengthID = 9;
				}
				else
				{
					curStrengthID -= 10;
					curLevelID++;
				}
			}
			SetMaxLevel();
			UIController.Instance.LevelTxt.text = GetCurLevel;
			LoadManager.SubmitLevelRecord(curLevelID, curStrengthID, UIController.Instance.GetUseDuration(), curCatchScore, J_LitJson.JsonMapper.ToJson(GetGameRecord()));
		}

		public static void ReduceStrength(int downshift)
		{
			curStrengthID -= downshift;
			if (curStrengthID < 0)
			{
				if (curLevelID <= 0)
				{
					curStrengthID = 0;
				}
				else
				{
					curStrengthID += 10;
					curLevelID--;
				}
			}
			SetMinLevel();
			UIController.Instance.LevelTxt.text = GetCurLevel;
			LoadManager.SubmitLevelRecord(curLevelID, curStrengthID, UIController.Instance.GetUseDuration(), curCatchScore, J_LitJson.JsonMapper.ToJson(GetGameRecord()));
		}

		private static void SetMaxLevel()
		{
			string[] array = maxLevel.Split('-');
			int num = int.Parse(array[0]);
			int num2 = int.Parse(array[1]);
			if (curLevelID == num)
			{
				if (curStrengthID > num2)
				{
					maxLevel = curLevelID + "-" + curStrengthID;
				}
			}
			else if (curLevelID > num)
			{
				maxLevel = curLevelID + "-" + curStrengthID;
			}
		}

		private static void SetMinLevel()
		{
			string[] array = minLevel.Split('-');
			int num = int.Parse(array[0]);
			int num2 = int.Parse(array[1]);
			if (curLevelID == num)
			{
				if (curStrengthID < num2)
				{
					minLevel = curLevelID + "-" + curStrengthID;
				}
			}
			else if (curLevelID < num)
			{
				minLevel = curLevelID + "-" + curStrengthID;
			}
		}

		public static void AddScore(int score)
		{
			curCatchScore += score;
			UIController.Instance.CurScoreTxt.text = curCatchScore.ToString();
		}

		public static void AddShootNum()
		{
			curShootNum++;
			curAllShootNum++;
			int num = CurCatchFishLevel.ChallengeNum - curShootNum;
			UIController.Instance.ChanglleNumTxt.text = num.ToString();
		}

		public static void SetChanglleTime(float catchTimer)
		{
			UIController.Instance.ChanglleTimeTxt.text = Mathf.Ceil(catchTimer).ToString();
		}

		public static GameRecordData GetGameRecord()
		{
			return new GameRecordData
			{
				InitLevel = minLevel,
				MaxLevel = maxLevel,
				MinLevel = minLevel,
				AllPass = allPass,
				PerfectNum = perfectNum,
				ContinuateMaxNum = continuateMaxNum,
				TimeOutNum = timeOutNum,
				CatchTotal = allCatchNum,
				TheBestCatch = theBestCatch,
				AllShootNum = curAllShootNum,
				NeedCatchTotal = needCatchTotal,
				SelfControl = selfControl
			};
		}
	}
	public class ColorList
	{
		public List<ColorData> Data;
	}
	public class ColorData
	{
		public int ID;

		public int FontColorR;

		public int FontColorG;

		public int FontColorB;

		public int OutLineColorR;

		public int OutLineColorG;

		public int OutLineColorB;
	}
	public class EnviromentsController : MonoBehaviour
	{
		public static EnviromentsController Instance;

		private void Awake()
		{
			Instance = this;
			base.gameObject.SetActive(value: false);
		}

		private void Start()
		{
		}

		private void Update()
		{
		}

		public void SetEnviromentsAngle(float angle)
		{
			base.transform.eulerAngles = new Vector3(0f, angle, 0f);
		}

		public void SetEnviromentsActive(bool isShow)
		{
			base.gameObject.SetActive(isShow);
		}
	}
	public class FishController : MonoBehaviour
	{
		public Transform numText;

		public TextMeshPro textMesh;

		public int fishNum;

		[Pvr_EnumFlags]
		public TrajectoryType trajectoryType;

		private List<string> trajectoryList = new List<string>();

		private TrajectoryType curTrajectoryType;

		private Vector3 startPos;

		private Vector3 endPos;

		private void Start()
		{
		}

		private void Update()
		{
			numText.LookAt(PlayerController.Instance.transform);
		}

		public float SetFish(float exclude)
		{
			string[] names = Enum.GetNames(trajectoryType.GetType());
			for (int i = 0; i < names.Length; i++)
			{
				TrajectoryType type = (TrajectoryType)Enum.Parse(typeof(TrajectoryType), names[i]);
				if (IsSelectEnumType(type))
				{
					trajectoryList.Add(names[i]);
				}
			}
			float num = MyMath.RandomRange(SwarmController.Instance.minHeight, SwarmController.Instance.maxHeight, exclude, 1f);
			UnityEngine.Random.InitState(Guid.NewGuid().GetHashCode());
			int index = UnityEngine.Random.Range(0, trajectoryList.Count);
			UnityEngine.Random.InitState(Guid.NewGuid().GetHashCode());
			int num2 = UnityEngine.Random.Range(0, 2);
			Vector3 position = ((num2 == 0) ? SwarmController.Instance.leftBirthPlace.localPosition : SwarmController.Instance.rightBirthPlace.localPosition);
			position.y = num;
			startPos = SwarmController.Instance.leftBirthPlace.parent.TransformPoint(position);
			base.transform.parent.position = startPos;
			curTrajectoryType = (TrajectoryType)Enum.Parse(typeof(TrajectoryType), (trajectoryList.Count == 0) ? TrajectoryType.TransverseLine.ToString() : trajectoryList[index]);
			switch (curTrajectoryType)
			{
			case TrajectoryType.TransverseLine:
				SetTransverseLineEndPos(num2, num);
				Move2D.createMove_Line(base.gameObject, base.transform.parent.InverseTransformPoint(endPos), SetMoveTimeBySpeed(startPos, endPos, CheckpointManager.GetFishSpeed)).OverMove += OverMove;
				break;
			case TrajectoryType.TransverseCurve:
				SetTransverseLineEndPos(num2, num);
				Move2D.createMove_CurveFloat(base.gameObject, base.transform.parent.InverseTransformPoint(endPos), 3, SetMoveTimeBySpeed(startPos, endPos, CheckpointManager.GetFishSpeed), 1f).OverMove += OverMove;
				break;
			case TrajectoryType.HalfWayDiversionLine:
			{
				SetHalfWayDiversionLineEndPos(num2, num);
				float num3 = UnityEngine.Random.Range(0.3f, 0.7f);
				Move2D_Line.createMove_LineChange(base.gameObject, base.transform.parent.InverseTransformPoint(endPos), SetMoveTimeBySpeed(startPos, endPos, CheckpointManager.GetFishSpeed), num3).OverMove += OverMove;
				break;
			}
			case TrajectoryType.ObliqueLine:
				SetHalfWayDiversionLineEndPos(num2, num);
				Move2D.createMove_Line(base.gameObject, base.transform.parent.InverseTransformPoint(endPos), SetMoveTimeBySpeed(startPos, endPos, CheckpointManager.GetFishSpeed)).OverMove += OverMove;
				break;
			case TrajectoryType.ObliqueCurve:
				SetHalfWayDiversionLineEndPos(num2, num);
				Move2D.createMove_CurveFloat(base.gameObject, base.transform.parent.InverseTransformPoint(endPos), 3, SetMoveTimeBySpeed(startPos, endPos, CheckpointManager.GetFishSpeed), 1f).OverMove += OverMove;
				break;
			case TrajectoryType.HalfWayBackCurve:
			{
				Vector3 end = SetHalfWayBackCurveEndPos(num2, num);
				float num3 = UnityEngine.Random.Range(0.3f, 0.5f);
				float num4 = Vector3.Distance(SwarmController.Instance.leftBirthPlace.localPosition, SwarmController.Instance.rightBirthPlace.localPosition) * num3;
				num4 = ((num2 == 0) ? num4 : (0f - num4));
				Move2D_X.createMove_CurveUpDown(base.gameObject, base.transform.parent.InverseTransformPoint(endPos), SetMoveTimeBySpeed(startPos, end, CheckpointManager.GetFishSpeed), num4).OverMove += OverMove;
				break;
			}
			}
			return num;
		}

		private void SetTransverseLineEndPos(int left_right, float h)
		{
			Vector3 position = ((left_right == 1) ? SwarmController.Instance.leftBirthPlace.localPosition : SwarmController.Instance.rightBirthPlace.localPosition);
			position.y = h;
			endPos = SwarmController.Instance.leftBirthPlace.parent.TransformPoint(position);
		}

		private void SetHalfWayDiversionLineEndPos(int left_right, float h)
		{
			UnityEngine.Random.InitState(Guid.NewGuid().GetHashCode());
			float y = MyMath.RandomRange(SwarmController.Instance.minHeight, SwarmController.Instance.maxHeight, h, (SwarmController.Instance.maxHeight - SwarmController.Instance.minHeight) / 3f);
			Vector3 position = ((left_right == 1) ? SwarmController.Instance.leftBirthPlace.localPosition : SwarmController.Instance.rightBirthPlace.localPosition);
			position.y = y;
			endPos = SwarmController.Instance.leftBirthPlace.parent.TransformPoint(position);
		}

		private Vector3 SetHalfWayBackCurveEndPos(int left_right, float h)
		{
			UnityEngine.Random.InitState(Guid.NewGuid().GetHashCode());
			float y = MyMath.RandomRange(SwarmController.Instance.minHeight, SwarmController.Instance.maxHeight, h, (SwarmController.Instance.maxHeight - SwarmController.Instance.minHeight) / 2f);
			Vector3 position = ((left_right == 0) ? SwarmController.Instance.leftBirthPlace.localPosition : SwarmController.Instance.rightBirthPlace.localPosition);
			position.y = y;
			endPos = SwarmController.Instance.leftBirthPlace.parent.TransformPoint(position);
			Vector3 position2 = ((left_right == 1) ? SwarmController.Instance.leftBirthPlace.localPosition : SwarmController.Instance.rightBirthPlace.localPosition);
			position2.y = y;
			return SwarmController.Instance.leftBirthPlace.parent.TransformPoint(position2);
		}

		private float SetMoveTimeBySpeed(Vector3 start, Vector3 end, float sp)
		{
			return Vector3.Distance(start, end) / sp;
		}

		public void SetFishNum(int num, ColorData data)
		{
			fishNum = num;
			textMesh.text = num.ToString();
			textMesh.color = new Color(data.FontColorR, data.FontColorG, data.FontColorB);
			textMesh.outlineColor = new Color(data.OutLineColorR, data.OutLineColorG, data.OutLineColorB);
		}

		public bool IsSelectEnumType(TrajectoryType type)
		{
			int num = 1 << (int)type;
			if (((uint)trajectoryType & (uint)num) == (uint)num)
			{
				return true;
			}
			return false;
		}

		private void OverMove(GameObject gObj)
		{
			SwarmController.Instance.SystemReduceFish(fishNum);
			UnityEngine.Object.Destroy(base.transform.parent.gameObject);
		}

		private void MoveTime(GameObject gObj, Move2D.RunTimeEventArgs rte)
		{
			UnityEngine.Debug.Log("还有" + (rte.totalTime - rte.runTime) + "秒结束");
		}
	}
	public enum TrajectoryType
	{
		TransverseLine,
		TransverseCurve,
		HalfWayDiversionLine,
		ObliqueLine,
		ObliqueCurve,
		HalfWayBackCurve
	}
	public class GameRecordData
	{
		public string InitLevel;

		public string MaxLevel;

		public string MinLevel;

		public int AllPass;

		public int PerfectNum;

		public int ContinuateMaxNum;

		public int TimeOutNum;

		public int CatchTotal;

		public float TheBestCatch;

		public int AllShootNum;

		public int NeedCatchTotal;

		public int SelfControl;
	}
	public class HandController : MonoBehaviour
	{
		public Animator animCtrl;

		public Animator gunAni;

		public Transform gunClip;

		public Transform launchPort;

		public AudioSource audioShot;

		public AudioSource audioReload;

		public AudioClip[] audioClips;

		public ParticleSystem particle;

		private bool isPlayClip;

		private void Start()
		{
		}

		private void Update()
		{
			animCtrl.SetBool("isGrabbing", value: true);
			if (isPlayClip)
			{
				gunClip.transform.Rotate(Vector3.forward, 1f);
			}
		}

		public void PlayAudioSource(int index)
		{
			if (!audioShot.isPlaying)
			{
				audioShot.clip = audioClips[0];
				audioShot.Play();
			}
		}

		public void PlayGunAni()
		{
			particle.Play();
			audioShot.clip = audioClips[2];
			audioShot.Play();
			isPlayClip = true;
			StartCoroutine(WatiGunAdudioEnd());
		}

		private IEnumerator WatiGunAdudioEnd()
		{
			yield return new WaitForSeconds(1f);
			isPlayClip = false;
			audioReload.clip = audioClips[1];
			audioReload.Play();
		}

		private IEnumerator WatiGunAniEnd()
		{
			yield return new WaitForSeconds(1.5f);
			gunAni.Play("None");
		}
	}
	public class PlayerController : MonoBehaviour
	{
		public static PlayerController Instance;

		public GameObject rightHand;

		public GameObject gunModel;

		public GameObject VivePointers;

		public HandController handController;

		public GameObject swichQuad;

		private Material swichMat;

		public ParticleSystem swichParticleSystem;

		public BatteryTipController batteryTipController;

		private GameObject bullet;

		private float fillingTime;

		private bool isLaunch = true;

		private float swichTimer = 0.5f;

		private bool isSwiching;

		private bool firstProcess;

		private bool secondProcess;

		private bool thirdProcess;

		private Action firstAction;

		private Action aniAction;

		private void Awake()
		{
			Instance = this;
		}

		private void Start()
		{
			Time.fixedDeltaTime = 0.02f;
		}

		private void Update()
		{
			if (CheckpointManager.IsStartGame)
			{
				if (isLaunch)
				{
					if (Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.TRIGGER) || Input.GetKeyDown(KeyCode.Space))
					{
						bullet = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("Prefabs/Bullet"));
						bullet.transform.position = handController.launchPort.position;
						bullet.transform.forward = rightHand.transform.forward;
						BulletController component = bullet.GetComponent<BulletController>();
						component.dir = rightHand.transform.forward;
						component.Launch();
						isLaunch = false;
						handController.PlayGunAni();
						CheckpointManager.AddShootNum();
						fillingTime = PropManager.Instance.fillingTime;
					}
				}
				else
				{
					if (Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.TRIGGER))
					{
						CheckpointManager.selfControl++;
						handController.PlayAudioSource(0);
						TipController.Instance.ShowTipText();
					}
					if ((fillingTime -= Time.deltaTime) <= 0f)
					{
						isLaunch = true;
						fillingTime = PropManager.Instance.fillingTime;
						if (CheckpointManager.curShootNum >= CheckpointManager.CurCatchFishLevel.ChallengeNum)
						{
							SwarmController.Instance.DownshiftRequire();
							SwarmController.Instance.CreateTargetFish();
						}
					}
				}
			}
			if (!isSwiching)
			{
				return;
			}
			if (firstProcess)
			{
				swichQuad.SetActive(value: true);
				swichTimer -= Time.deltaTime;
				Color color = swichMat.color;
				color.a += Time.deltaTime / 0.5f;
				swichMat.color = color;
				if (swichTimer <= 0f)
				{
					swichTimer = 0.5f;
					secondProcess = true;
					firstProcess = false;
					firstAction?.Invoke();
				}
			}
			if (secondProcess)
			{
				swichTimer -= Time.deltaTime;
				if (swichTimer <= 0f)
				{
					swichTimer = 0.5f;
					thirdProcess = true;
					secondProcess = false;
				}
			}
			if (thirdProcess)
			{
				swichTimer -= Time.deltaTime;
				Color color2 = swichMat.color;
				color2.a -= Time.deltaTime / 0.5f;
				swichMat.color = color2;
				if (swichTimer <= 0f)
				{
					swichTimer = 0.5f;
					thirdProcess = false;
					isSwiching = false;
					rightHand.SetActive(value: true);
					swichQuad.SetActive(value: false);
					aniAction?.Invoke();
				}
			}
		}

		public void InitData()
		{
			List<CatchFishLevel> list = CsvMapper.ToObjectList<CatchFishLevel>(LoadManager.CsvRead("CatchFishLevel"));
			CheckpointManager.LevelDataDic.Clear();
			foreach (CatchFishLevel item in list)
			{
				CheckpointManager.LevelDataDic.Add(item.LevelID, item);
			}
			List<CatchFishStrength> list2 = CsvMapper.ToObjectList<CatchFishStrength>(LoadManager.CsvRead("CatchFishStrength"));
			CheckpointManager.StrengthDataDic.Clear();
			foreach (CatchFishStrength item2 in list2)
			{
				CheckpointManager.StrengthDataDic.Add(item2.StrengthID, item2);
			}
			ColorList colorList = J_LitJson.JsonMapper.ToObject<ColorList>(LoadManager.JsonRead("ColorList"));
			CheckpointManager.colorDatas.Clear();
			foreach (ColorData datum in colorList.Data)
			{
				CheckpointManager.colorDatas.Add(datum);
			}
			swichMat = swichQuad.GetComponent<MeshRenderer>().material;
		}

		public void SwichSceneAnimation(Action firstAction = null, Action action = null)
		{
			isLaunch = true;
			fillingTime = PropManager.Instance.fillingTime;
			rightHand.SetActive(value: false);
			isSwiching = true;
			firstProcess = true;
			secondProcess = false;
			thirdProcess = false;
			Color color = swichMat.color;
			color.a = 0f;
			swichMat.color = color;
			this.firstAction = firstAction;
			aniAction = action;
		}

		public void DelayHander(float time, Action action)
		{
			StartCoroutine(Wait(time, action));
		}

		private IEnumerator Wait(float time, Action action)
		{
			yield return new WaitForSeconds(time);
			action?.Invoke();
		}
	}
	public class PropController : MonoBehaviour
	{
		public Transform sprite;

		public Transform lookAtTra;

		public Transform tipTra;

		private float speed = 0.5f;

		private Vector3 pos;

		private bool isAni;

		private float aniTime = 1f;

		private float aniSpeed = 0.25f;

		private void Start()
		{
			lookAtTra = PlayerController.Instance.transform;
		}

		private void Update()
		{
			if (!lookAtTra)
			{
				return;
			}
			sprite.LookAt(lookAtTra);
			pos = base.transform.position;
			base.transform.position = new Vector3(pos.x, pos.y + speed * Time.deltaTime, pos.z);
			if ((bool)tipTra)
			{
				tipTra.LookAt(lookAtTra);
			}
			if (base.transform.position.y > 5f)
			{
				DestroySelf();
			}
			if (isAni)
			{
				aniTime -= Time.deltaTime;
				tipTra.position = new Vector3(tipTra.position.x, tipTra.position.y + aniSpeed * Time.deltaTime, tipTra.position.z);
				sprite.localScale *= 0.25f * Time.deltaTime;
				if (aniTime <= 0f)
				{
					DestroySelf();
				}
			}
		}

		public void DestroySelf()
		{
			if ((bool)tipTra)
			{
				isAni = true;
				tipTra.gameObject.SetActive(value: true);
			}
			else
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
			PropManager.Instance.propList.Remove(base.gameObject);
		}
	}
	public class PropManager : MonoBehaviour
	{
		public static PropManager Instance;

		public List<GameObject> propList = new List<GameObject>();

		public MeshRenderer gunMat;

		public float fillingTime = 1.5f;

		private bool isCreateQuicken = true;

		private bool isQuickening;

		private float createTime = 30f;

		private float quickenTime = 10f;

		private bool isChangeColor;

		private Color startColor = new Color(0.3529412f, 0.3529412f, 0f);

		private Color minColor = new Color(0.32156864f, 0.32156864f, 0f);

		private Color maxColor = new Color(0.7058824f, 0.7058824f, 0f);

		private float minRange = 0.4f;

		private float maxRange = 0.8f;

		private bool isCreateOxygen = true;

		private float createOxygenTime = 40f;

		private void Awake()
		{
			Instance = this;
		}

		private void Start()
		{
		}

		private void Update()
		{
			if (!isCreateQuicken)
			{
				createTime -= Time.deltaTime;
				if (isQuickening)
				{
					quickenTime -= Time.deltaTime;
					if (quickenTime <= 0f)
					{
						isQuickening = false;
						isChangeColor = false;
						gunMat.sharedMaterial.SetColor("_EmissionColor", Color.black);
						quickenTime = 10f;
					}
				}
				if (createTime <= 0f)
				{
					isCreateQuicken = true;
					createTime = 30f;
				}
			}
			if (isChangeColor)
			{
				Color color = gunMat.sharedMaterial.GetColor("_EmissionColor");
				if (quickenTime >= 3f)
				{
					if (color.r < minColor.r || color.r > maxColor.r)
					{
						minRange *= -1f;
					}
					color = new Color(color.r + minRange * Time.deltaTime, color.g + minRange * Time.deltaTime, 0f);
				}
				else
				{
					if (color.r < minColor.r || color.r > maxColor.r)
					{
						maxRange *= -1f;
					}
					color = new Color(color.r + maxRange * Time.deltaTime, color.g + maxRange * Time.deltaTime, 0f);
				}
				gunMat.sharedMaterial.SetColor("_EmissionColor", color);
			}
			if (!isCreateOxygen)
			{
				createOxygenTime -= Time.deltaTime;
				if (createOxygenTime <= 0f)
				{
					isCreateOxygen = true;
					createOxygenTime = 40f;
				}
			}
		}

		public void CreateOxygenProp()
		{
			if (isCreateQuicken)
			{
				GameObject gameObject = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("Prefabs/Oxygen"));
				gameObject.transform.position = new Vector3(base.transform.position.x + UnityEngine.Random.Range(-2f, 2f), base.transform.position.y, base.transform.position.z);
				propList.Add(gameObject);
			}
		}

		public void CreateQuickenProp()
		{
			if (isCreateQuicken)
			{
				GameObject gameObject = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("Prefabs/Quicken"));
				gameObject.transform.position = new Vector3(base.transform.position.x + UnityEngine.Random.Range(-2f, 2f), base.transform.position.y, base.transform.position.z);
				propList.Add(gameObject);
			}
		}

		public void HitOxygenProp()
		{
			isCreateOxygen = true;
			UIController.Instance.AddTime(20f);
		}

		public void HitQuickenProp()
		{
			if (!isQuickening)
			{
				isCreateQuicken = false;
				isQuickening = true;
				ChangeGunColor();
			}
		}

		public void ClearPorp()
		{
			foreach (GameObject prop in propList)
			{
				if ((bool)prop)
				{
					UnityEngine.Object.Destroy(prop);
				}
			}
			propList.Clear();
		}

		private void ChangeGunColor()
		{
			isChangeColor = true;
			gunMat.sharedMaterial.SetColor("_EmissionColor", startColor);
		}
	}
	public class SwarmController : MonoBehaviour
	{
		public static SwarmController Instance;

		public Transform leftBirthPlace;

		public Transform rightBirthPlace;

		public float minHeight = -3f;

		public float maxHeight = 4f;

		private List<int> waitCreateFishs = new List<int>();

		private List<int> allFishs = new List<int>();

		private List<FishController> allFishCons = new List<FishController>();

		private List<ColorData> colorDatas = new List<ColorData>();

		public int curTargetNum = 1000;

		public float createInterval = 1f;

		private int continuateNum;

		private int curCatchRightNum;

		private int curCatchErrorNum;

		private float timer;

		private float catchTimer;

		private float lastFishHeight;

		private void Awake()
		{
			Instance = this;
			timer = createInterval;
		}

		private void Start()
		{
		}

		private void Update()
		{
			if (!CheckpointManager.IsStartGame)
			{
				return;
			}
			if (waitCreateFishs.Count > 0)
			{
				timer -= Time.deltaTime;
				if (timer <= 0f)
				{
					timer = createInterval;
					int index = UnityEngine.Random.Range(0, waitCreateFishs.Count);
					CreatFish(waitCreateFishs[index]);
				}
			}
			catchTimer -= Time.deltaTime;
			CheckpointManager.SetChanglleTime(catchTimer);
			if (catchTimer <= 0f)
			{
				CheckpointManager.SetChanglleTime(0f);
				UIController.Instance.PlayAudioSound(1);
				CheckpointManager.timeOutNum++;
				DownshiftRequire();
				CreateTargetFish();
			}
		}

		public void Init()
		{
			waitCreateFishs.Clear();
			allFishs.Clear();
			allFishCons.Clear();
			for (int num = base.transform.childCount; num > 0; num--)
			{
				UnityEngine.Object.Destroy(base.transform.GetChild(num - 1).gameObject);
			}
			lastFishHeight = minHeight;
		}

		public void CreatFishs()
		{
			CreateTargetFish();
			int getFishNumber = CheckpointManager.GetFishNumber;
			CreatFishs(getFishNumber - 1);
		}

		private void CreatFishs(int total)
		{
			for (int i = 0; i < total; i++)
			{
				int num = UnityEngine.Random.Range(CheckpointManager.GetRangeMin, CheckpointManager.GetRangeMax + 1);
				if (num == curTargetNum && GetNumInList(curTargetNum, waitCreateFishs) >= CheckpointManager.CurCatchFishLevel.RightFish)
				{
					total++;
				}
				else
				{
					waitCreateFishs.Add(num);
				}
			}
		}

		private void CreatFish(int num)
		{
			waitCreateFishs.Remove(num);
			allFishs.Add(num);
			int index = UnityEngine.Random.Range(0, CheckpointManager.CurCatchFishLevel.FishType.Count);
			int num2 = CheckpointManager.CurCatchFishLevel.FishType[index];
			FishController componentInChildren = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("Prefabs/Fish" + num2), base.transform).GetComponentInChildren<FishController>();
			lastFishHeight = componentInChildren.SetFish(lastFishHeight);
			allFishCons.Add(componentInChildren);
			GetColorDatas(CheckpointManager.CurCatchFishLevel.FigureColor);
			int index2 = UnityEngine.Random.Range(0, colorDatas.Count);
			componentInChildren.SetFishNum(num, colorDatas[index2]);
		}

		public void AddFish()
		{
			if (allFishs.Contains(curTargetNum) || waitCreateFishs.Contains(curTargetNum))
			{
				if (GetNumInList(curTargetNum, allFishs) + GetNumInList(curTargetNum, waitCreateFishs) < CheckpointManager.CurCatchFishLevel.RightFish)
				{
					int num = UnityEngine.Random.Range(CheckpointManager.GetRangeMin, CheckpointManager.GetRangeMax + 1);
					CreatFish(num);
				}
				else
				{
					int num2 = MyMath.RandomRange(CheckpointManager.GetRangeMin, CheckpointManager.GetRangeMax + 1, curTargetNum);
					CreatFish(num2);
				}
			}
			else
			{
				CreatFish(curTargetNum);
			}
		}

		public void ReduceFish(int num)
		{
			allFishs.Remove(num);
			FishController item = allFishCons.Find((FishController a) => a.fishNum == num);
			allFishCons.Remove(item);
			CheckpointManager.allCatchNum++;
			if (curTargetNum == num)
			{
				curCatchErrorNum = 0;
				curCatchRightNum++;
				CheckpointManager.allPass++;
				if (CheckpointManager.theBestCatch > CheckpointManager.CurCatchFishLevel.LimitTime - catchTimer)
				{
					CheckpointManager.theBestCatch = CheckpointManager.CurCatchFishLevel.LimitTime - catchTimer;
				}
				int num2 = ((CheckpointManager.curShootNum != 1) ? 1 : 2);
				if (CheckpointManager.curShootNum == 1)
				{
					CheckpointManager.perfectNum++;
					continuateNum++;
					if (continuateNum > CheckpointManager.continuateMaxNum)
					{
						CheckpointManager.continuateMaxNum = continuateNum;
					}
				}
				else
				{
					continuateNum = 0;
				}
				CheckpointManager.AddScore(CheckpointManager.GetFishScore * num2);
				if (curCatchRightNum >= CheckpointManager.CurCatchFishLevel.UpshiftRequire)
				{
					curCatchRightNum = 0;
					CheckpointManager.AddStrength(CheckpointManager.CurCatchFishLevel.UpshiftGrade * num2);
					UIController.Instance.PlayAudioSound((num2 == 1) ? 2 : 3);
					UIController.Instance.CheckBattery(delegate
					{
						UIController.Instance.SuspendGame(suspend: false);
					});
				}
				else
				{
					UIController.Instance.PlayAudioSound(0);
				}
				CreateTargetFish();
			}
			else
			{
				UIController.Instance.PlayAudioSound(1);
				continuateNum = 0;
				if (CheckpointManager.curShootNum >= CheckpointManager.CurCatchFishLevel.ChallengeNum)
				{
					DownshiftRequire();
					CreateTargetFish();
				}
			}
			AddFish();
		}

		public void DownshiftRequire()
		{
			curCatchRightNum = 0;
			curCatchErrorNum++;
			if (curCatchErrorNum >= CheckpointManager.CurCatchFishLevel.DownshiftRequire)
			{
				curCatchErrorNum = 0;
				CheckpointManager.ReduceStrength(CheckpointManager.CurCatchFishLevel.DownshiftGrade);
				UIController.Instance.CheckBattery(delegate
				{
					UIController.Instance.SuspendGame(suspend: false);
				});
			}
		}

		public void SystemReduceFish(int num)
		{
			allFishs.Remove(num);
			FishController item = allFishCons.Find((FishController a) => a.fishNum == num);
			allFishCons.Remove(item);
			AddFish();
		}

		public void CreateTargetFish()
		{
			CheckpointManager.needCatchTotal++;
			catchTimer = CheckpointManager.CurCatchFishLevel.LimitTime;
			CheckpointManager.SetChanglleTime(catchTimer);
			curTargetNum = MyMath.RandomRange(CheckpointManager.GetRangeMin, CheckpointManager.GetRangeMax + 1, curTargetNum);
			UIController.Instance.SetTargetFish(curTargetNum);
			CheckpointManager.curShootNum = 0;
			UIController.Instance.ChanglleNumTxt.text = CheckpointManager.CurCatchFishLevel.ChallengeNum.ToString();
			if (!IsExistTarget(curTargetNum))
			{
				waitCreateFishs.Add(curTargetNum);
			}
		}

		public bool IsTargetFish(int num)
		{
			if (curTargetNum != num)
			{
				return false;
			}
			return true;
		}

		private bool IsExistTarget(int num)
		{
			bool result = false;
			for (int i = 0; i < allFishs.Count; i++)
			{
				if (allFishs[i] == num)
				{
					result = true;
				}
			}
			for (int j = 0; j < waitCreateFishs.Count; j++)
			{
				if (waitCreateFishs[j] == num)
				{
					result = true;
				}
			}
			return result;
		}

		private int GetNumInList(int num, List<int> lists)
		{
			int num2 = 0;
			for (int i = 0; i < lists.Count; i++)
			{
				if (num == lists[i])
				{
					num2++;
				}
			}
			return num2;
		}

		private void GetColorDatas(int num)
		{
			colorDatas.Clear();
			for (int i = 0; i < num; i++)
			{
				colorDatas.Add(CheckpointManager.colorDatas[i]);
			}
		}
	}
	public class TipController : MonoBehaviour
	{
		public static TipController Instance;

		public GameObject tipImage;

		public GameObject arrowImage;

		public GameObject tipText;

		public float amplitude = 0.5f;

		public float frequency = 1f;

		private Vector3 tempPos;

		private void Awake()
		{
			Instance = this;
		}

		private void Start()
		{
		}

		private void Update()
		{
			if (tipImage.activeSelf)
			{
				tempPos = arrowImage.transform.localPosition;
				tempPos.y += Mathf.Sin(Time.fixedTime * (float)Math.PI * frequency) * amplitude;
				arrowImage.transform.localPosition = tempPos;
			}
		}

		private IEnumerator WaitSecond(float time, Action action)
		{
			yield return new WaitForSeconds(time);
			action?.Invoke();
		}

		public void ShowTipText()
		{
			if (!tipText.activeSelf)
			{
				tipText.SetActive(value: true);
				PlayerController.Instance.DelayHander(1f, delegate
				{
					tipText.SetActive(value: false);
				});
			}
		}

		public void ShowTipImage()
		{
			tipImage.SetActive(value: true);
			PlayerController.Instance.DelayHander(3f, delegate
			{
				tipImage.SetActive(value: false);
			});
		}
	}
	public class UIController : MonoBehaviour
	{
		public static UIController Instance;

		public GameObject mainCanvas;

		[Header("开始界面")]
		public GameObject StartGamePanel;

		public ToggleGroup toggleGroup;

		public Button startGameBtn;

		public Button settingsBtn;

		public Button tipsBtn;

		public Button exitBtn;

		public AudioSource bgAudioSource;

		public GameObject OperationTipsPanel;

		public Button tipsReturnBtn;

		public GameObject InTheGamePanel;

		public Image oxygenImage;

		public TextMeshProUGUI numTextMesh;

		public TextMeshProUGUI progressTextMesh;

		[Header("游戏界面")]
		public GameObject ScorePanel;

		public Text CurScoreTxt;

		public Text LevelTxt;

		public Text TotalTimeTxt;

		public Text ChanglleNumTxt;

		public Text ChanglleTimeTxt;

		public Text targetTxt;

		[Header("结算界面")]
		public GameObject PassAllCheckpointPanel;

		public TextMeshProUGUI ScoreTxt;

		public Text TrainingDurationTxt;

		public Text InitChallengeLevelTxt;

		public Text MaxChallengeLevelTxt;

		public Text MinChallengeLevelTxt;

		public Text AllPassTxt;

		public Text PerfectNumTxt;

		public Text ContinuateMaxNumTxt;

		public Text TimeOutNumTxt;

		public Text CatchTotalTxt;

		public Text TheBestCatchTxt;

		public Text CorrectRateTxt;

		public Text HitRateTxt;

		public Text ErrorNumTxt;

		public Button passAllReturnBtn;

		[Header("暂停界面")]
		public GameObject SuspendPanel;

		public Button suspendReturnStartBtn;

		public Button suspendReturnBtn;

		[Header("退出提示界面")]
		public GameObject ExitTipPanel;

		public Button defineBtn;

		public Button cancelBtn;

		public AudioSource audioSource;

		public AudioClip[] audioClips;

		private float surplusGameDuration;

		private bool isStartTime;

		private void Awake()
		{
			Instance = this;
		}

		private void Start()
		{
			EnviromentsController.Instance.SetEnviromentsActive(isShow: false);
			OperationTipsPanel.SetActive(value: false);
			ScorePanel.SetActive(value: false);
			InTheGamePanel.SetActive(value: false);
			PassAllCheckpointPanel.SetActive(value: false);
			startGameBtn.onClick.AddListener(StartGameBtnHander);
			exitBtn.onClick.AddListener(ExitBtnHander);
			tipsReturnBtn.onClick.AddListener(TipsReturnBtnHander);
			passAllReturnBtn.onClick.AddListener(PassAllBtnHander);
			suspendReturnStartBtn.onClick.AddListener(SuspendReturnStartBtnHander);
			suspendReturnBtn.onClick.AddListener(SuspendReturnBtnHander);
			defineBtn.onClick.AddListener(DefineBtnHander);
			cancelBtn.onClick.AddListener(CancelBtnHander);
			for (int i = 0; i < toggleGroup.transform.childCount; i++)
			{
				int index = i;
				Toggle component = toggleGroup.transform.GetChild(i).GetComponent<Toggle>();
				component.onValueChanged.AddListener(delegate(bool value)
				{
					if (value)
					{
						LoadManager.LevelID = index;
					}
				});
				if (LoadManager.LevelID == index)
				{
					component.isOn = true;
				}
			}
			PlayerController.Instance.InitData();
			if (LoadManager.IsLocalOperate)
			{
				StartGamePanel.SetActive(value: true);
				return;
			}
			StartGamePanel.SetActive(value: false);
			StartGameBtnHander(LoadManager.course);
		}

		private void Update()
		{
			if (isStartTime)
			{
				surplusGameDuration -= Time.deltaTime;
				TotalTimeTxt.text = LoadManager.TimeConversion((int)surplusGameDuration);
				if (surplusGameDuration <= 0f)
				{
					CheckpointManager.OverTheGame();
				}
			}
			if (IsCanSuspend() && Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.APP))
			{
				mainCanvas.SetActive(value: true);
				SuspendPanel.SetActive(value: true);
				CheckpointManager.IsStartGame = false;
				Time.timeScale = 0f;
			}
			if (IsCanSuspend() && Input.GetKeyDown(KeyCode.Escape))
			{
				mainCanvas.SetActive(value: true);
				SuspendPanel.SetActive(value: true);
				CheckpointManager.IsStartGame = false;
				Time.timeScale = 0f;
			}
		}

		public void StartGame()
		{
			IsStartTime();
			surplusGameDuration = CheckpointManager.gameDuration - CheckpointManager.gameDurationed;
			ScorePanel.SetActive(value: true);
			InTheGamePanel.SetActive(value: true);
			TipController.Instance.ShowTipImage();
			CurScoreTxt.text = CheckpointManager.curCatchScore.ToString();
			LevelTxt.text = CheckpointManager.GetCurLevel;
			TotalTimeTxt.text = LoadManager.TimeConversion((int)surplusGameDuration);
			ChanglleNumTxt.text = CheckpointManager.CurCatchFishLevel.ChallengeNum.ToString();
			ChanglleTimeTxt.text = CheckpointManager.CurCatchFishLevel.LimitTime.ToString();
		}

		public void SetTargetFish(int targetFish)
		{
			if (CheckpointManager.GetFourRulesType == 0)
			{
				targetTxt.text = targetFish.ToString();
			}
			else if (CheckpointManager.GetFourRulesType == 1)
			{
				if (UnityEngine.Random.Range(0f, 1f) <= CheckpointManager.GetProbability)
				{
					int num = UnityEngine.Random.Range(0, 2);
					UnityEngine.Random.InitState(Guid.NewGuid().GetHashCode());
					if (num == 0)
					{
						int num2 = UnityEngine.Random.Range(1, targetFish);
						targetTxt.text = num2 + "+" + (targetFish - num2);
					}
					else
					{
						int num3 = UnityEngine.Random.Range(targetFish + 1, CheckpointManager.GetRangeMax * 2);
						targetTxt.text = num3 + "-" + (num3 - targetFish);
					}
				}
				else
				{
					targetTxt.text = targetFish.ToString();
				}
			}
			else if (CheckpointManager.GetFourRulesType == 2)
			{
				if (UnityEngine.Random.Range(0f, 1f) <= CheckpointManager.GetProbability)
				{
					int num4 = UnityEngine.Random.Range(0, 3);
					UnityEngine.Random.InitState(Guid.NewGuid().GetHashCode());
					switch (num4)
					{
					case 0:
					{
						int num7 = UnityEngine.Random.Range(1, targetFish);
						targetTxt.text = num7 + "+" + (targetFish - num7);
						break;
					}
					case 1:
					{
						int num6 = UnityEngine.Random.Range(targetFish + 1, CheckpointManager.GetRangeMax * 2);
						targetTxt.text = num6 + "-" + (num6 - targetFish);
						break;
					}
					default:
					{
						int num5 = MyMath.RandomGetDivisible(targetFish);
						targetTxt.text = num5 + "x" + targetFish / num5;
						break;
					}
					}
				}
				else
				{
					targetTxt.text = targetFish.ToString();
				}
			}
			else
			{
				if (CheckpointManager.GetFourRulesType != 3)
				{
					return;
				}
				if (UnityEngine.Random.Range(0f, 1f) <= CheckpointManager.GetProbability)
				{
					int num8 = UnityEngine.Random.Range(0, 4);
					UnityEngine.Random.InitState(Guid.NewGuid().GetHashCode());
					switch (num8)
					{
					case 0:
					{
						int num13 = UnityEngine.Random.Range(1, targetFish);
						targetTxt.text = num13 + "+" + (targetFish - num13);
						break;
					}
					case 1:
					{
						int num12 = UnityEngine.Random.Range(targetFish + 1, CheckpointManager.GetRangeMax * 2);
						targetTxt.text = num12 + "-" + (num12 - targetFish);
						break;
					}
					case 2:
					{
						int num11 = MyMath.RandomGetDivisible(targetFish);
						targetTxt.text = num11 + "x" + targetFish / num11;
						break;
					}
					default:
					{
						int num9 = UnityEngine.Random.Range(targetFish, CheckpointManager.GetRangeMax * 2 + 1);
						UnityEngine.Random.InitState(Guid.NewGuid().GetHashCode());
						int num10 = UnityEngine.Random.Range(1, num9 / targetFish);
						targetTxt.text = targetFish * num10 + "÷" + num10;
						break;
					}
					}
				}
				else
				{
					targetTxt.text = targetFish.ToString();
				}
			}
		}

		public void SetOxygenImage(float curTimer, float totalTime)
		{
			oxygenImage.fillAmount = curTimer / totalTime;
			if (oxygenImage.fillAmount > 0.6f)
			{
				oxygenImage.color = Color.green;
			}
			else if (oxygenImage.fillAmount > 0.2f && oxygenImage.fillAmount < 0.6f)
			{
				oxygenImage.color = Color.yellow;
			}
			else
			{
				oxygenImage.color = Color.red;
			}
		}

		public int GetUseDuration(bool isComplete = false)
		{
			float num = CheckpointManager.gameDuration - surplusGameDuration;
			num = (isComplete ? CheckpointManager.gameDuration : num);
			return (int)num;
		}

		public void OverTheGame()
		{
			IsStartTime(isStart: false);
			PlayAudioSound(4);
			ScorePanel.SetActive(value: false);
			InTheGamePanel.SetActive(value: false);
			PassAllCheckpointPanel.SetActive(value: true);
			ScoreTxt.text = CheckpointManager.curCatchScore.ToString();
			TrainingDurationTxt.text = LoadManager.TimeConversion((int)CheckpointManager.gameDuration);
			InitChallengeLevelTxt.text = CheckpointManager.GetInitChallengeLevel();
			MaxChallengeLevelTxt.text = CheckpointManager.GetMaxChallengeLevel();
			MinChallengeLevelTxt.text = CheckpointManager.GetMinChallengeLevel();
			AllPassTxt.text = CheckpointManager.allPass.ToString();
			PerfectNumTxt.text = CheckpointManager.perfectNum.ToString();
			ContinuateMaxNumTxt.text = CheckpointManager.continuateMaxNum.ToString();
			TimeOutNumTxt.text = CheckpointManager.timeOutNum.ToString();
			CatchTotalTxt.text = CheckpointManager.allCatchNum.ToString();
			TheBestCatchTxt.text = Math.Round(CheckpointManager.theBestCatch, 2) + "秒";
			CorrectRateTxt.text = ((CheckpointManager.allCatchNum == 0) ? "0%" : (Math.Round((float)CheckpointManager.allPass / (float)CheckpointManager.allCatchNum, 4) * 100.0 + "%"));
			HitRateTxt.text = ((CheckpointManager.curAllShootNum == 0) ? "0%" : (Math.Round((float)CheckpointManager.allCatchNum / (float)CheckpointManager.curAllShootNum, 4) * 100.0 + "%"));
			ErrorNumTxt.text = (CheckpointManager.curAllShootNum - CheckpointManager.allPass).ToString();
		}

		public void AddTime(float time)
		{
			surplusGameDuration += time;
		}

		public void IsStartTime(bool isStart = true)
		{
			isStartTime = isStart;
		}

		public void PlayAudioSound(int index)
		{
			if (audioSource.isPlaying)
			{
				audioSource.Stop();
			}
			audioSource.clip = audioClips[index];
			audioSource.Play();
		}

		public void CheckBattery(Action continueAction)
		{
			if (PlayerController.Instance.batteryTipController.CheckBattery(continueAction))
			{
				SuspendGame(suspend: true);
			}
		}

		public void SuspendGame(bool suspend)
		{
			IsStartTime(!suspend);
			mainCanvas.SetActive(suspend);
			CheckpointManager.IsStartGame = !suspend;
			Time.timeScale = ((!suspend) ? 1 : 0);
		}

		private void StartGameBtnHander()
		{
			StartGameBtnHander(null);
		}

		private void StartGameBtnHander(CourseDetail.Data data)
		{
			PlayerController.Instance.SwichSceneAnimation(delegate
			{
				CheckpointManager.StartTheLevel(data);
				EnviromentsController.Instance.SetEnviromentsActive(isShow: true);
			}, delegate
			{
				CheckpointManager.IsStartGame = true;
				StartGame();
				PlayerController.Instance.VivePointers.SetActive(value: true);
			});
			PlayerController.Instance.VivePointers.SetActive(value: false);
			StartGamePanel.SetActive(value: false);
			bgAudioSource.Play();
		}

		private void TipsBtnHander()
		{
			StartGamePanel.SetActive(value: false);
		}

		private void ExitBtnHander()
		{
			ScenesHelper.LoadScene(ScenesHelper.WeiAiZhiCenterScene);
		}

		private void TipsReturnBtnHander()
		{
			StartGamePanel.SetActive(value: true);
			OperationTipsPanel.SetActive(value: false);
		}

		private void PassAllBtnHander()
		{
			if (LoadManager.IsLocalOperate)
			{
				bgAudioSource.Stop();
				StartGamePanel.SetActive(value: true);
				PassAllCheckpointPanel.SetActive(value: false);
				EnviromentsController.Instance.SetEnviromentsActive(isShow: false);
			}
			else
			{
				LoadManager.SubmitEndRecord(isComplete: true, isLogout: false, GetUseDuration(isComplete: true), CheckpointManager.curCatchScore, J_LitJson.JsonMapper.ToJson(CheckpointManager.GetGameRecord()));
			}
		}

		private void SuspendReturnStartBtnHander()
		{
			if (LoadManager.IsLocalOperate)
			{
				EnviromentsController.Instance.SetEnviromentsActive(isShow: false);
				SuspendPanel.SetActive(value: false);
				ScorePanel.SetActive(value: false);
				mainCanvas.SetActive(value: true);
				StartGamePanel.SetActive(value: true);
				CheckpointManager.ResetTheGame();
				Time.timeScale = 1f;
			}
			else
			{
				ExitTipPanel.SetActive(value: true);
			}
		}

		private void SuspendReturnBtnHander()
		{
			CheckpointManager.IsStartGame = true;
			mainCanvas.SetActive(value: false);
			SuspendPanel.SetActive(value: false);
			InTheGamePanel.SetActive(value: true);
			Time.timeScale = 1f;
		}

		private void DefineBtnHander()
		{
			Time.timeScale = 1f;
			LoadManager.SubmitEndRecord(isComplete: false, isLogout: false, GetUseDuration(), CheckpointManager.curCatchScore, J_LitJson.JsonMapper.ToJson(CheckpointManager.GetGameRecord()));
		}

		private void CancelBtnHander()
		{
			ExitTipPanel.SetActive(value: false);
		}

		private bool IsCanSuspend()
		{
			if (PassAllCheckpointPanel.activeSelf || PassAllCheckpointPanel.activeSelf)
			{
				return false;
			}
			if (CheckpointManager.IsStartGame)
			{
				return true;
			}
			return false;
		}
	}
}
namespace BombDisposal
{
	public class BombDisposalDetail
	{
		public int row;

		public int column;

		public List<BombDisposalItem> bombDisposalItems = new List<BombDisposalItem>();
	}
	public class BombDisposalItem
	{
		public WallType leftWallType;

		public WallType upWallType;

		public PersonType personType;

		public FloorType floorType;
	}
	public class LevelData
	{
		public int Levelid;

		public string LevelName;

		public List<int> CheckpointArray;

		public int NextLevelid;
	}
	public class CheckpointData
	{
		public int CheckpointID;

		public string MapID;

		public float ChallengeTime;

		public int TimeThreshold;

		public int TimeScore;

		public int MissLimitTimes;

		public int NoMissScore;
	}
	public class BombDisposalLevel
	{
		public int LevelID;

		public string LevelName;

		public List<string> Range;

		public float InitialView;

		public int BaseScore;

		public int ChallengeNum;

		public int IsTimeReduce;

		public int IsViewReduce;

		public int IsRotate;

		public int UpshiftRequire;

		public int UpshiftGrade;

		public int DownshiftRequire;

		public int DownshiftGrade;
	}
	public class BombDisposalStrength
	{
		public int StrengthID;

		public int StrengthGrade;

		public float ScoreAddition;

		public float TimeReduce;

		public float ViewReduce;
	}
	public class BombDisposalMap
	{
		public int MapID;

		public int LimitTime;
	}
	public class CheckpointManager
	{
		public static Dictionary<int, BombDisposalLevel> LevelDataDic = new Dictionary<int, BombDisposalLevel>();

		public static Dictionary<int, BombDisposalStrength> StrengthDataDic = new Dictionary<int, BombDisposalStrength>();

		public static Dictionary<int, BombDisposalMap> MapDataDic = new Dictionary<int, BombDisposalMap>();

		public static Dictionary<int, Dictionary<int, List<string>>> MapIDDataDic = new Dictionary<int, Dictionary<int, List<string>>>();

		public static List<GameRecordData> gameRecordDatas = new List<GameRecordData>();

		public static int curLevelID;

		public static int curStrengthID;

		public static int curMapID;

		public static float gameDuration;

		public static float gameDurationed;

		public static int curScore;

		public static string startLevel;

		public static string minLevel;

		public static string maxLevel;

		public static int allPass;

		public static int perfectNum;

		public static int continuateMaxNum;

		public static int timeOutNum;

		public static int totalMoveNum;

		public static List<float> efficiency;

		public static int allCheckpoints;

		public static bool IsStartGame = false;

		public static BombDisposalLevel CurBombLevel => LevelDataDic[curLevelID];

		public static BombDisposalStrength CurBombStrength => StrengthDataDic[curStrengthID];

		public static BombDisposalMap CurBombMap => MapDataDic[curMapID];

		public static int GetScore => (int)((float)CurBombLevel.BaseScore * (1f + CurBombStrength.ScoreAddition));

		public static float GetBombTime
		{
			get
			{
				if (CurBombLevel.IsTimeReduce != 0)
				{
					return (float)CurBombMap.LimitTime * (1f - CurBombStrength.TimeReduce);
				}
				return CurBombMap.LimitTime;
			}
		}

		public static float GetView
		{
			get
			{
				if (CurBombLevel.IsViewReduce != 0)
				{
					return CurBombLevel.InitialView - 1f * CurBombStrength.ViewReduce;
				}
				return CurBombLevel.InitialView;
			}
		}

		public static string GetCurLevel => LevelDataDic[curLevelID].LevelName + "-" + StrengthDataDic[curStrengthID].StrengthGrade;

		public static void StartTheLevel(CourseDetail.Data data)
		{
			if (data != null)
			{
				if (data.game_data == null)
				{
					string text = data.level + "-" + data.strength;
					InitData(data.level, data.strength, data.play_time, data.already_play_time, data.point, 0, 0, 0, 0, 0, new List<float>(), 0, text, text, text);
				}
				else
				{
					GameRecordData gameRecordData = J_LitJson.JsonMapper.ToObject<GameRecordData>(data.game_data);
					InitData(data.level, data.strength, data.play_time, data.already_play_time, data.point, gameRecordData.AllPass, gameRecordData.PerfectNum, gameRecordData.ContinuateMaxNum, gameRecordData.TimeOutNum, gameRecordData.TotalMoveNum, gameRecordData.Efficiency, gameRecordData.AllCheckpoints, gameRecordData.InitLevel, gameRecordData.MaxLevel, gameRecordData.MinLevel);
				}
			}
			else
			{
				string text2 = LoadManager.LevelID + "-" + LoadManager.StrengthID;
				InitData(LoadManager.LevelID, LoadManager.StrengthID, LoadManager.Duration, 0, 0, 0, 0, 0, 0, 0, new List<float>(), 0, text2, text2, text2);
			}
			IsStartGame = true;
			RoomRootController.Instance.CreateMapToCheck(isCheck: false);
			UIController.Instance.StartGame();
		}

		private static void InitData(int level, int strength, int duration, int durationed, int score, int allpass, int perfect, int continuate, int timeout, int totalmove, List<float> efficien, int allCheck, string start, string max, string min)
		{
			curLevelID = level;
			curStrengthID = strength;
			gameDuration = duration;
			gameDurationed = durationed;
			curScore = score;
			allPass = allpass;
			perfectNum = perfect;
			continuateMaxNum = continuate;
			timeOutNum = timeout;
			totalMoveNum = totalmove;
			efficiency = efficien;
			allCheckpoints = allCheck;
			startLevel = start;
			maxLevel = max;
			minLevel = min;
		}

		public static void OverTheGame()
		{
			IsStartGame = false;
			RoomRootController.Instance.ClearMap();
			PlayerController.Instance.StopAllCoroutines();
			UIController.Instance.OverTheGame();
		}

		public static void ResetTheGame()
		{
			IsStartGame = false;
			RoomRootController.Instance.ClearMap();
			PlayerController.Instance.StopAllCoroutines();
		}

		public static string GetInitChallengeLevel()
		{
			string[] array = startLevel.Split('-');
			return LevelDataDic[int.Parse(array[0])].LevelName + "-" + StrengthDataDic[int.Parse(array[1])].StrengthGrade;
		}

		public static string GetMaxChallengeLevel()
		{
			string[] array = maxLevel.Split('-');
			return LevelDataDic[int.Parse(array[0])].LevelName + "-" + StrengthDataDic[int.Parse(array[1])].StrengthGrade;
		}

		public static string GetMinChallengeLevel()
		{
			string[] array = minLevel.Split('-');
			return LevelDataDic[int.Parse(array[0])].LevelName + "-" + StrengthDataDic[int.Parse(array[1])].StrengthGrade;
		}

		public static void AddStrength(int upshift)
		{
			curStrengthID += upshift;
			if (curStrengthID > 9)
			{
				if (LoadManager.IsLocalOperate && curLevelID >= LoadManager.MaxLevelID)
				{
					curStrengthID = 9;
				}
				else if (curLevelID >= LevelDataDic.Count - 1)
				{
					curStrengthID = 9;
				}
				else
				{
					curStrengthID -= 10;
					curLevelID++;
				}
			}
			SetMaxLevel();
			UIController.Instance.LevelTxt.text = GetCurLevel;
			LoadManager.SubmitLevelRecord(curLevelID, curStrengthID, UIController.Instance.GetUseDuration(), curScore, J_LitJson.JsonMapper.ToJson(GetGameRecord()));
		}

		public static void ReduceStrength(int downshift)
		{
			curStrengthID -= downshift;
			if (curStrengthID < 0)
			{
				if (curLevelID <= 0)
				{
					curStrengthID = 0;
				}
				else
				{
					curStrengthID += 10;
					curLevelID--;
				}
			}
			SetMinLevel();
			UIController.Instance.LevelTxt.text = GetCurLevel;
			LoadManager.SubmitLevelRecord(curLevelID, curStrengthID, UIController.Instance.GetUseDuration(), curScore, J_LitJson.JsonMapper.ToJson(GetGameRecord()));
		}

		private static void SetMaxLevel()
		{
			string[] array = maxLevel.Split('-');
			int num = int.Parse(array[0]);
			int num2 = int.Parse(array[1]);
			if (curLevelID == num)
			{
				if (curStrengthID > num2)
				{
					maxLevel = curLevelID + "-" + curStrengthID;
				}
			}
			else if (curLevelID > num)
			{
				maxLevel = curLevelID + "-" + curStrengthID;
			}
		}

		private static void SetMinLevel()
		{
			string[] array = minLevel.Split('-');
			int num = int.Parse(array[0]);
			int num2 = int.Parse(array[1]);
			if (curLevelID == num)
			{
				if (curStrengthID < num2)
				{
					minLevel = curLevelID + "-" + curStrengthID;
				}
			}
			else if (curLevelID < num)
			{
				minLevel = curLevelID + "-" + curStrengthID;
			}
		}

		public static void AddScore(int score)
		{
			curScore += score;
			UIController.Instance.CurScoreTxt.text = curScore.ToString();
		}

		public static void SetChanglleNum(int missMun)
		{
			int num = CurBombLevel.ChallengeNum - missMun;
			UIController.Instance.ChanglleNumTxt.text = ((num == 0) ? 1 : num).ToString();
		}

		public static void SetChanglleTime(float catchTimer)
		{
			UIController.Instance.ChanglleTimeTxt.text = Mathf.Ceil(catchTimer).ToString();
		}

		public static GameRecordData GetGameRecord()
		{
			return new GameRecordData
			{
				InitLevel = minLevel,
				MaxLevel = maxLevel,
				MinLevel = minLevel,
				AllPass = allPass,
				PerfectNum = perfectNum,
				ContinuateMaxNum = continuateMaxNum,
				TimeOutNum = timeOutNum,
				TotalMoveNum = totalMoveNum,
				Efficiency = efficiency,
				AllCheckpoints = allCheckpoints
			};
		}
	}
	public class DenseFogController : MonoBehaviour
	{
		public Vector2 matrix;

		private void Start()
		{
		}

		private void Update()
		{
		}
	}
	public class FloorController : MonoBehaviour
	{
		public FloorType floorType;

		public Vector2 matrix;

		public Transform[] fallTras;

		public AudioSource audioSource;

		private int isBeenHere;

		private Animation ani;

		private void Start()
		{
			ani = GetComponent<Animation>();
		}

		private void Update()
		{
		}

		public bool EnterHere()
		{
			if (isBeenHere == 0)
			{
				isBeenHere++;
				return false;
			}
			return true;
		}

		public void PlayFall()
		{
			audioSource.Play();
			ani.Play("Fall");
			PlayerController.Instance.DelayHander(5.467f, delegate
			{
				HideFallTra();
			});
		}

		private void HideFallTra()
		{
			Transform[] array = fallTras;
			foreach (Transform transform in array)
			{
				if ((bool)transform)
				{
					transform.gameObject.SetActive(value: false);
				}
			}
		}
	}
	public class GameRecordData
	{
		public string InitLevel;

		public string MaxLevel;

		public string MinLevel;

		public int AllPass;

		public int PerfectNum;

		public int ContinuateMaxNum;

		public int TimeOutNum;

		public int TotalMoveNum;

		public List<float> Efficiency;

		public int AllCheckpoints;
	}
	public class OpenDoorController : MonoBehaviour
	{
		public Vector3 matrix;

		public WallType wallType;

		public bool isOpen;

		public AudioSource audioSource;

		private Animation ani;

		private void Start()
		{
			ani = GetComponentInChildren<Animation>();
			base.transform.Find("Left").GetComponent<CRCI_FruitCut.OnColliderEvent>().m_actionsOnTriggerEnter.AddListener(delegate(Collider collision)
			{
				if (!isOpen)
				{
					PersonController component2 = collision.gameObject.GetComponent<PersonController>();
					if ((bool)component2 && component2.IsPassThrough(wallType))
					{
						isOpen = true;
						ani.Play("Hou");
						audioSource.Play();
					}
				}
			});
			base.transform.Find("Right").GetComponent<CRCI_FruitCut.OnColliderEvent>().m_actionsOnTriggerEnter.AddListener(delegate(Collider collision)
			{
				if (!isOpen)
				{
					PersonController component = collision.gameObject.GetComponent<PersonController>();
					if ((bool)component && component.IsPassThrough(wallType))
					{
						isOpen = true;
						ani.Play("Qian");
						audioSource.Play();
					}
				}
			});
		}

		private void Update()
		{
		}
	}
	public class PersonController : MonoBehaviour
	{
		public CRCI_FruitCut.OnColliderEvent onColliderEvent;

		public float speed = 0.5f;

		public Action moveComplete;

		public AudioSource audioSource;

		public AudioClip[] audioClips;

		public bool isAni;

		private Animator animator;

		private List<string> keys;

		private bool isMove;

		private Vector3 endPos;

		private void Start()
		{
			animator = GetComponent<Animator>();
			keys = new List<string>();
			onColliderEvent.m_actionsOnTriggerEnter.AddListener(delegate(Collider collider)
			{
				if (collider.name.Contains("YellowKey"))
				{
					PlayAudioSource(0, loop: false);
					keys.Add("YellowKey");
					SetSquatAni();
					UnityEngine.Object.Destroy(collider.gameObject);
					PlayerController.Instance.DelayHander(2.19f, delegate
					{
						isAni = false;
						SetIdleAni();
					});
				}
				else if (collider.name.Contains("GreyKey"))
				{
					PlayAudioSource(0, loop: false);
					keys.Add("GreyKey");
					SetSquatAni();
					UnityEngine.Object.Destroy(collider.gameObject);
					PlayerController.Instance.DelayHander(2.19f, delegate
					{
						isAni = false;
						SetIdleAni();
					});
				}
				else if (collider.name.Contains("BlueKey"))
				{
					PlayAudioSource(0, loop: false);
					keys.Add("BlueKey");
					SetSquatAni();
					UnityEngine.Object.Destroy(collider.gameObject);
					PlayerController.Instance.DelayHander(2.19f, delegate
					{
						isAni = false;
						SetIdleAni();
					});
				}
				else if (collider.name.Contains("Bomb"))
				{
					UIController.Instance.IsStartTime(isStart: false);
					PlayAudioSource(3, loop: false);
					SetSquatAni();
					UnityEngine.Object.Destroy(collider.gameObject);
					PlayerController.Instance.DelayHander(2.2f, delegate
					{
						audioSource.Stop();
						RoomRootController.Instance.PassTheMap();
						RoomRootController.Instance.ClearMap();
						RoomRootController.Instance.CreateMapToCheck();
					});
				}
			});
		}

		private void Update()
		{
			if (!isMove)
			{
				return;
			}
			base.transform.position = Vector3.MoveTowards(base.transform.position, endPos, speed * Time.deltaTime);
			if (base.transform.position == endPos)
			{
				isMove = false;
				if (audioSource.clip == audioClips[2])
				{
					audioSource.Stop();
				}
				moveComplete?.Invoke();
			}
		}

		public void Move(Vector3 end, Action complete)
		{
			PlayAudioSource(2, loop: true);
			endPos = end;
			moveComplete = complete;
			isMove = true;
		}

		public void StopMove()
		{
			isMove = false;
		}

		public bool IsPassThrough(WallType wallType)
		{
			switch (wallType)
			{
			case WallType.YellowDoor:
				if (keys.Contains("YellowKey"))
				{
					return true;
				}
				break;
			case WallType.GreyDoor:
				if (keys.Contains("GreyKey"))
				{
					return true;
				}
				break;
			case WallType.BlueDoor:
				if (keys.Contains("BlueKey"))
				{
					return true;
				}
				break;
			}
			return false;
		}

		public void SetIdleAni()
		{
			if (!isAni)
			{
				animator.SetTrigger("Idle");
			}
		}

		public void SetRunAni()
		{
			animator.SetTrigger("Run");
		}

		public void SetSquatAni()
		{
			isAni = true;
			animator.SetTrigger("Squat");
		}

		public void SetDeathAni()
		{
			PlayAudioSource(4, loop: false);
			animator.SetTrigger("Death");
		}

		public void SetFallAni()
		{
			PlayAudioSource(1, loop: false);
			animator.SetTrigger("Fall");
			float y = base.transform.localPosition.y;
			base.transform.DOLocalMoveY(y - 4f, 1.5f);
		}

		public void SetForward(Vector3 forward)
		{
			base.transform.forward = forward;
			Vector3 localEulerAngles = new Vector3(0f, base.transform.localEulerAngles.y, 0f);
			base.transform.localEulerAngles = localEulerAngles;
		}

		private void PlayAudioSource(int index, bool loop)
		{
			if (audioSource.isPlaying)
			{
				audioSource.Stop();
			}
			audioSource.clip = audioClips[index];
			audioSource.loop = loop;
			audioSource.Play();
		}
	}
	public class PlayerController : MonoBehaviour
	{
		public static PlayerController Instance;

		public GameObject rightHand;

		public BatteryTipController batteryTipController;

		private bool isWalking;

		private Ray ray;

		private RaycastHit hit;

		private void Awake()
		{
			Instance = this;
			ray = default(Ray);
			hit = default(RaycastHit);
		}

		private void Start()
		{
			Time.fixedDeltaTime = 0.02f;
		}

		private void Update()
		{
			if (CheckpointManager.IsStartGame && !isWalking && (Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.TRIGGER) || Input.GetKeyDown(KeyCode.Space)))
			{
				ray.direction = rightHand.transform.forward;
				ray.origin = rightHand.transform.position;
				if (Physics.Raycast(ray, out hit, 100f, 1 << LayerMask.NameToLayer("Keys")))
				{
					RoomRootController.Instance.HitFloor(hit.transform);
				}
			}
		}

		public void InitData()
		{
			List<BombDisposalLevel> list = CsvMapper.ToObjectList<BombDisposalLevel>(LoadManager.CsvRead("BombDisposalLevel"));
			CheckpointManager.LevelDataDic.Clear();
			CheckpointManager.MapIDDataDic.Clear();
			foreach (BombDisposalLevel item in list)
			{
				CheckpointManager.LevelDataDic.Add(item.LevelID, item);
				Dictionary<int, List<string>> dictionary = new Dictionary<int, List<string>>();
				CheckpointManager.MapIDDataDic.Add(item.LevelID, dictionary);
				for (int i = 0; i < item.Range.Count; i++)
				{
					string[] source = item.Range[i].TrimStart('(').TrimEnd(')').Split('/');
					dictionary.Add(i, source.ToList());
				}
			}
			List<BombDisposalStrength> list2 = CsvMapper.ToObjectList<BombDisposalStrength>(LoadManager.CsvRead("BombDisposalStrength"));
			CheckpointManager.StrengthDataDic.Clear();
			foreach (BombDisposalStrength item2 in list2)
			{
				CheckpointManager.StrengthDataDic.Add(item2.StrengthID, item2);
			}
			List<BombDisposalMap> list3 = CsvMapper.ToObjectList<BombDisposalMap>(LoadManager.CsvRead("BombDisposalMap"));
			CheckpointManager.MapDataDic.Clear();
			foreach (BombDisposalMap item3 in list3)
			{
				CheckpointManager.MapDataDic.Add(item3.MapID, item3);
			}
		}

		public void DelayHander(float time, Action action)
		{
			StartCoroutine(Wait(time, action));
		}

		private IEnumerator Wait(float time, Action action)
		{
			yield return new WaitForSeconds(time);
			action?.Invoke();
		}
	}
	public class RoomEditItem : MonoBehaviour
	{
		public GameObject bg;

		public Button leftWallBtn;

		public Button upWallBtn;

		public Button floorBtn;

		public Button personBtn;

		public Text leftWallTxt;

		public Text upWallTxt;

		public Text floorTxt;

		public Text personTxt;

		public WallType leftWallType;

		public WallType upWallType;

		public PersonType personType;

		public FloorType floorType;

		public Vector2 matrix;

		public Action<bool, Vector2> setRoomAction;

		private void Start()
		{
			leftWallBtn.onClick.AddListener(LeftWallBtnHander);
			upWallBtn.onClick.AddListener(UpWallBtnHander);
			floorBtn.onClick.AddListener(FloorBtnHander);
			personBtn.onClick.AddListener(PersonBtnHander);
		}

		public void SetLeftWall(WallType wallType)
		{
			leftWallType = wallType;
			if (leftWallType == WallType.Wall)
			{
				leftWallTxt.text = "墙";
			}
			else if (leftWallType == WallType.NoDoor)
			{
				leftWallTxt.text = "没门";
			}
			else if (leftWallType == WallType.YellowDoor)
			{
				leftWallTxt.text = "黄门";
			}
			else if (leftWallType == WallType.GreyDoor)
			{
				leftWallTxt.text = "灰门";
			}
			else if (leftWallType == WallType.BlueDoor)
			{
				leftWallTxt.text = "蓝门";
			}
			else if (leftWallType == WallType.Window)
			{
				leftWallTxt.text = "窗";
			}
			else if (leftWallType == WallType.NoWall)
			{
				leftWallTxt.text = "没墙";
			}
		}

		private void LeftWallBtnHander()
		{
			if (leftWallType == WallType.Wall)
			{
				SetLeftWall(WallType.NoDoor);
			}
			else if (leftWallType == WallType.NoDoor)
			{
				SetLeftWall(WallType.YellowDoor);
			}
			else if (leftWallType == WallType.YellowDoor)
			{
				SetLeftWall(WallType.GreyDoor);
			}
			else if (leftWallType == WallType.GreyDoor)
			{
				SetLeftWall(WallType.BlueDoor);
			}
			else if (leftWallType == WallType.BlueDoor)
			{
				SetLeftWall(WallType.Window);
			}
			else if (leftWallType == WallType.Window)
			{
				SetLeftWall(WallType.NoWall);
			}
			else if (leftWallType == WallType.NoWall)
			{
				SetLeftWall(WallType.Wall);
			}
		}

		public void SetUpWall(WallType wallType)
		{
			upWallType = wallType;
			if (upWallType == WallType.Wall)
			{
				upWallTxt.text = "墙";
			}
			else if (upWallType == WallType.NoDoor)
			{
				upWallTxt.text = "没门";
			}
			else if (upWallType == WallType.YellowDoor)
			{
				upWallTxt.text = "黄门";
			}
			else if (upWallType == WallType.GreyDoor)
			{
				upWallTxt.text = "灰门";
			}
			else if (upWallType == WallType.BlueDoor)
			{
				upWallTxt.text = "蓝门";
			}
			else if (upWallType == WallType.Window)
			{
				upWallTxt.text = "窗";
			}
			else if (upWallType == WallType.NoWall)
			{
				upWallTxt.text = "没墙";
			}
		}

		private void UpWallBtnHander()
		{
			if (upWallType == WallType.Wall)
			{
				SetUpWall(WallType.NoDoor);
			}
			else if (upWallType == WallType.NoDoor)
			{
				SetUpWall(WallType.YellowDoor);
			}
			else if (upWallType == WallType.YellowDoor)
			{
				SetUpWall(WallType.GreyDoor);
			}
			else if (upWallType == WallType.GreyDoor)
			{
				SetUpWall(WallType.BlueDoor);
			}
			else if (upWallType == WallType.BlueDoor)
			{
				SetUpWall(WallType.Window);
			}
			else if (upWallType == WallType.Window)
			{
				SetUpWall(WallType.NoWall);
			}
			else if (upWallType == WallType.NoWall)
			{
				SetUpWall(WallType.Wall);
			}
		}

		public void SetFloor(FloorType type)
		{
			floorType = type;
			if (floorType == FloorType.Normal)
			{
				floorTxt.text = "普通地板";
				IsActive(active: true);
				setRoomAction?.Invoke(arg1: true, matrix);
			}
			else if (floorType == FloorType.Special)
			{
				floorTxt.text = "特殊地板";
			}
			else if (floorType == FloorType.None)
			{
				floorTxt.text = "无";
				IsActive(active: false);
				setRoomAction?.Invoke(arg1: false, matrix);
			}
		}

		private void FloorBtnHander()
		{
			if (floorType == FloorType.Normal)
			{
				SetFloor(FloorType.Special);
			}
			else if (floorType == FloorType.Special)
			{
				SetFloor(FloorType.None);
			}
			else if (floorType == FloorType.None)
			{
				SetFloor(FloorType.Normal);
			}
		}

		private void IsActive(bool active)
		{
			bg.SetActive(active);
			personBtn.gameObject.SetActive(active);
		}

		public void SetPerson(PersonType type)
		{
			personType = type;
			if (personType == PersonType.None)
			{
				personTxt.text = "无";
			}
			else if (personType == PersonType.Person)
			{
				personTxt.text = "人";
			}
			else if (personType == PersonType.Bomb)
			{
				personTxt.text = "炸弹";
			}
			else if (personType == PersonType.YellowKey)
			{
				personTxt.text = "黄钥匙";
			}
			else if (personType == PersonType.GreyKey)
			{
				personTxt.text = "灰钥匙";
			}
			else if (personType == PersonType.BlueKey)
			{
				personTxt.text = "蓝钥匙";
			}
		}

		private void PersonBtnHander()
		{
			if (personType == PersonType.None)
			{
				SetPerson(PersonType.Person);
			}
			else if (personType == PersonType.Person)
			{
				SetPerson(PersonType.Bomb);
			}
			else if (personType == PersonType.Bomb)
			{
				SetPerson(PersonType.YellowKey);
			}
			else if (personType == PersonType.YellowKey)
			{
				SetPerson(PersonType.GreyKey);
			}
			else if (personType == PersonType.GreyKey)
			{
				SetPerson(PersonType.BlueKey);
			}
			else if (personType == PersonType.BlueKey)
			{
				SetPerson(PersonType.None);
			}
		}

		private void Update()
		{
		}
	}
	public enum WallType
	{
		Wall,
		NoDoor,
		YellowDoor,
		GreyDoor,
		BlueDoor,
		Window,
		NoWall
	}
	public enum FloorType
	{
		Normal,
		Special,
		None
	}
	public enum PersonType
	{
		None,
		Person,
		Bomb,
		YellowKey,
		GreyKey,
		BlueKey
	}
	public class RoomEditManager : MonoBehaviour
	{
		public static RoomEditManager Instance;

		public GridLayoutGroup gridLayoutGroup;

		public GameObject template;

		public InputField fileNameInput;

		public InputField rowInput;

		public InputField columnInput;

		public Button createBtn;

		public Button clearBtn;

		public Button openFileBtn;

		public Button saveFileBtn;

		private BombDisposalDetail bombDisposalDetail;

		private void Awake()
		{
			Instance = this;
		}

		private void Start()
		{
			createBtn.onClick.AddListener(CreateBtnHander);
			clearBtn.onClick.AddListener(ClearBtnHander);
			openFileBtn.onClick.AddListener(OpenBtnHander);
			saveFileBtn.onClick.AddListener(SaveBtnHander);
			clearBtn.gameObject.SetActive(value: false);
		}

		private void ClearBtnHander()
		{
			foreach (Transform item in gridLayoutGroup.transform)
			{
				UnityEngine.Object.Destroy(item.gameObject);
			}
			clearBtn.gameObject.SetActive(value: false);
			createBtn.gameObject.SetActive(value: true);
		}

		private void CreateBtnHander()
		{
			if (string.IsNullOrEmpty(rowInput.text) || string.IsNullOrEmpty(columnInput.text))
			{
				return;
			}
			int num = int.Parse(rowInput.text);
			int num2 = int.Parse(columnInput.text);
			if (num < 1 || num > 10 || num2 < 1 || num2 > 10)
			{
				return;
			}
			ClearBtnHander();
			clearBtn.gameObject.SetActive(value: true);
			createBtn.gameObject.SetActive(value: false);
			gridLayoutGroup.constraintCount = int.Parse(columnInput.text);
			for (int i = 0; i < num; i++)
			{
				for (int j = 0; j < num2; j++)
				{
					GameObject obj = UnityEngine.Object.Instantiate(template, gridLayoutGroup.transform);
					obj.SetActive(value: true);
					RoomEditItem component = obj.GetComponent<RoomEditItem>();
					if (i == 0)
					{
						component.SetUpWall(WallType.Window);
					}
					if (j == 0)
					{
						component.SetLeftWall(WallType.Window);
					}
					component.matrix = new Vector2(j, i);
					component.setRoomAction = SetRoomCallBack;
				}
			}
		}

		private void OpenBtnHander()
		{
			string path = Application.dataPath + "/BombDisposal/Resources/BombDisposalData/" + fileNameInput.text + ".json";
			if (!string.IsNullOrEmpty(fileNameInput.text) && File.Exists(path))
			{
				InitBombDisposalDetail(File.ReadAllText(path));
			}
		}

		private void SaveBtnHander()
		{
			if (ReadBombDisposalDetail())
			{
				string path = Application.dataPath + "/BombDisposal/Resources/BombDisposalData/" + fileNameInput.text + ".json";
				if (!string.IsNullOrEmpty(fileNameInput.text))
				{
					File.WriteAllText(path, J_LitJson.JsonMapper.ToJson(bombDisposalDetail));
				}
			}
		}

		private bool ReadBombDisposalDetail()
		{
			if (gridLayoutGroup.transform.childCount == 0)
			{
				return false;
			}
			bombDisposalDetail = new BombDisposalDetail();
			bombDisposalDetail.column = gridLayoutGroup.constraintCount;
			bombDisposalDetail.row = gridLayoutGroup.transform.childCount / gridLayoutGroup.constraintCount;
			foreach (Transform item in gridLayoutGroup.transform)
			{
				RoomEditItem component = item.GetComponent<RoomEditItem>();
				BombDisposalItem bombDisposalItem = new BombDisposalItem();
				bombDisposalItem.leftWallType = component.leftWallType;
				bombDisposalItem.upWallType = component.upWallType;
				bombDisposalItem.floorType = component.floorType;
				if (bombDisposalItem.floorType == FloorType.None)
				{
					bombDisposalItem.personType = PersonType.None;
				}
				else
				{
					bombDisposalItem.personType = component.personType;
				}
				bombDisposalDetail.bombDisposalItems.Add(bombDisposalItem);
			}
			return true;
		}

		private void InitBombDisposalDetail(string json)
		{
			ClearBtnHander();
			clearBtn.gameObject.SetActive(value: true);
			createBtn.gameObject.SetActive(value: false);
			bombDisposalDetail = J_LitJson.JsonMapper.ToObject<BombDisposalDetail>(json);
			gridLayoutGroup.constraintCount = bombDisposalDetail.column;
			int num = 0;
			for (int i = 0; i < bombDisposalDetail.row; i++)
			{
				for (int j = 0; j < bombDisposalDetail.column; j++)
				{
					GameObject obj = UnityEngine.Object.Instantiate(template, gridLayoutGroup.transform);
					obj.SetActive(value: true);
					RoomEditItem component = obj.GetComponent<RoomEditItem>();
					component.SetLeftWall(bombDisposalDetail.bombDisposalItems[num].leftWallType);
					component.SetUpWall(bombDisposalDetail.bombDisposalItems[num].upWallType);
					component.SetFloor(bombDisposalDetail.bombDisposalItems[num].floorType);
					component.SetPerson(bombDisposalDetail.bombDisposalItems[num].personType);
					component.matrix = new Vector2(j, i);
					component.setRoomAction = SetRoomCallBack;
					num++;
				}
			}
			foreach (Transform item in gridLayoutGroup.transform)
			{
				RoomEditItem component2 = item.GetComponent<RoomEditItem>();
				SetRoomCallBack(component2.floorType != FloorType.None, component2.matrix);
			}
		}

		private void SetRoomCallBack(bool isActive, Vector2 matrix)
		{
			RoomEditItem roomEditItem = FindRoomEditItem(matrix);
			if (matrix.y > 0f)
			{
				if (isActive)
				{
					roomEditItem.upWallBtn.gameObject.SetActive(value: true);
				}
				RoomEditItem roomEditItem2 = FindRoomEditItem(new Vector2(matrix.x, matrix.y - 1f));
				if (!isActive && roomEditItem2.floorType == FloorType.None)
				{
					roomEditItem.SetUpWall(WallType.NoWall);
					roomEditItem.upWallBtn.gameObject.SetActive(value: false);
				}
				RoomEditItem roomEditItem3 = FindRoomEditItem(new Vector2(matrix.x, matrix.y + 1f));
				if ((bool)roomEditItem3 && !isActive && roomEditItem3.floorType == FloorType.None)
				{
					roomEditItem3.SetUpWall(WallType.NoWall);
					roomEditItem3.upWallBtn.gameObject.SetActive(value: false);
				}
				else if ((bool)roomEditItem3 && isActive && roomEditItem3.floorType == FloorType.None)
				{
					roomEditItem3.SetUpWall(WallType.Wall);
					roomEditItem3.upWallBtn.gameObject.SetActive(value: true);
				}
			}
			else
			{
				roomEditItem.SetUpWall(isActive ? WallType.Window : WallType.NoWall);
				roomEditItem.upWallBtn.gameObject.SetActive(isActive);
			}
			if (matrix.x > 0f)
			{
				if (isActive)
				{
					roomEditItem.leftWallBtn.gameObject.SetActive(value: true);
				}
				RoomEditItem roomEditItem4 = FindRoomEditItem(new Vector2(matrix.x - 1f, matrix.y));
				if (!isActive && roomEditItem4.floorType == FloorType.None)
				{
					roomEditItem.SetLeftWall(WallType.NoWall);
					roomEditItem.leftWallBtn.gameObject.SetActive(value: false);
				}
				RoomEditItem roomEditItem5 = FindRoomEditItem(new Vector2(matrix.x + 1f, matrix.y));
				if ((bool)roomEditItem5 && !isActive && roomEditItem5.floorType == FloorType.None)
				{
					roomEditItem5.SetLeftWall(WallType.NoWall);
					roomEditItem5.leftWallBtn.gameObject.SetActive(value: false);
				}
				else if ((bool)roomEditItem5 && isActive && roomEditItem5.floorType == FloorType.None)
				{
					roomEditItem5.SetLeftWall(WallType.Wall);
					roomEditItem5.leftWallBtn.gameObject.SetActive(value: true);
				}
			}
			else
			{
				roomEditItem.SetLeftWall(isActive ? WallType.Window : WallType.NoWall);
				roomEditItem.leftWallBtn.gameObject.SetActive(isActive);
			}
		}

		private RoomEditItem FindRoomEditItem(Vector2 matrix)
		{
			int constraintCount = gridLayoutGroup.constraintCount;
			int num = gridLayoutGroup.transform.childCount / gridLayoutGroup.constraintCount;
			if (matrix.y >= (float)num)
			{
				return null;
			}
			if (matrix.x >= (float)constraintCount)
			{
				return null;
			}
			return gridLayoutGroup.transform.GetChild((int)(matrix.y * (float)constraintCount + matrix.x)).GetComponent<RoomEditItem>();
		}

		private void Update()
		{
		}
	}
	public class RoomRootController : MonoBehaviour
	{
		public static RoomRootController Instance;

		public float size = 3.3f;

		public Transform root;

		public Transform floorParent;

		public Transform wallParent;

		public Transform personParent;

		public Transform fogParent;

		private BombDisposalDetail detail;

		private PersonController personController;

		private Vector2 curPersonMatrix;

		private Transform curBomb;

		private Vector2 curBombMatrix;

		private ParticleSystem bombEffect;

		private bool isRun;

		private FowFogRenderer fogRenderer;

		private Vector3 initAngle;

		private FloorController lastController;

		private float challengeTimer;

		private int curMissNum;

		private int continuateNum;

		private int lastRandom = 1000;

		public bool IsPerfectPass
		{
			get
			{
				if (curMissNum == 0)
				{
					return true;
				}
				return false;
			}
		}

		private void Awake()
		{
			Instance = this;
		}

		private void Start()
		{
			initAngle = base.transform.eulerAngles;
		}

		private void UserInfoCallback(string userInfo)
		{
		}

		private void Update()
		{
			if (CheckpointManager.IsStartGame && !isRun)
			{
				if (Input.GetKey(KeyCode.LeftArrow) || (Controller.UPvr_GetAxis2D(1).x < 0f && CheckAngle(Controller.UPvr_GetAxis2D(1).normalized, Vector2.left)))
				{
					Move(Vector3.left);
				}
				else if (Input.GetKey(KeyCode.RightArrow) || (Controller.UPvr_GetAxis2D(1).x > 0f && CheckAngle(Controller.UPvr_GetAxis2D(1).normalized, Vector2.right)))
				{
					Move(Vector3.right);
				}
				else if (Input.GetKey(KeyCode.UpArrow) || (Controller.UPvr_GetAxis2D(1).y > 0f && CheckAngle(Controller.UPvr_GetAxis2D(1).normalized, Vector2.up)))
				{
					Move(Vector3.forward);
				}
				else if (Input.GetKey(KeyCode.DownArrow) || (Controller.UPvr_GetAxis2D(1).y < 0f && CheckAngle(Controller.UPvr_GetAxis2D(1).normalized, Vector2.down)))
				{
					Move(Vector3.back);
				}
			}
			if (!UIController.Instance.isStartTime)
			{
				return;
			}
			challengeTimer -= Time.deltaTime;
			CheckpointManager.SetChanglleTime(challengeTimer);
			if (challengeTimer <= 0f)
			{
				personController?.StopMove();
				CheckpointManager.SetChanglleTime(0f);
				UIController.Instance.IsStartTime(isStart: false);
				UIController.Instance.PlayAudioSound(1);
				CheckpointManager.timeOutNum++;
				CheckpointManager.ReduceStrength(CheckpointManager.CurBombLevel.DownshiftGrade);
				PlayerController.Instance.StopAllCoroutines();
				PlayerController.Instance.DelayHander(1.5f, delegate
				{
					ClearMap();
					CreateMapToCheck();
				});
			}
		}

		public void CreateMapToCheck(bool isCheck = true)
		{
			List<string> list = CheckpointManager.MapIDDataDic[CheckpointManager.curLevelID][CheckpointManager.curStrengthID];
			lastRandom = MyMath.RandomRange(0, list.Count, lastRandom);
			CheckpointManager.curMapID = int.Parse(list[lastRandom]);
			challengeTimer = CheckpointManager.CurBombMap.LimitTime;
			CheckpointManager.SetChanglleTime(challengeTimer);
			curMissNum = 0;
			CheckpointManager.SetChanglleNum(curMissNum);
			if (isCheck)
			{
				UIController.Instance.CheckBattery(delegate
				{
					UIController.Instance.SuspendGame(suspend: false);
					CreateMap(CheckpointManager.curMapID);
				});
			}
			else
			{
				CreateMap(CheckpointManager.curMapID);
			}
		}

		private void CreateMap(int mapID)
		{
			UIController.Instance.IsStartTime();
			CheckpointManager.allCheckpoints++;
			string text = Resources.Load<TextAsset>("BombDisposalData/E" + mapID).text;
			detail = J_LitJson.JsonMapper.ToObject<BombDisposalDetail>(text);
			float num = ((detail.column % 2 == 0) ? ((float)(-detail.column / 2) * size + size / 2f) : ((float)(-detail.column / 2) * size));
			float num2 = ((detail.row % 2 == 0) ? ((float)(detail.row / 2) * size - size / 2f) : ((float)(detail.row / 2) * size));
			for (int i = 0; i < detail.row; i++)
			{
				for (int j = 0; j < detail.column; j++)
				{
					BombDisposalItem bombDisposalItem = FindBombDisposalItem(i, j);
					if (bombDisposalItem.floorType != FloorType.None)
					{
						string text2 = bombDisposalItem.floorType.ToString();
						GameObject obj = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("Prefabs/Maps/" + text2), floorParent.transform);
						float x = num + (float)j * size;
						float z = num2 - (float)i * size;
						obj.transform.localPosition = new Vector3(x, 0f, z);
						FloorController component = obj.GetComponent<FloorController>();
						component.floorType = bombDisposalItem.floorType;
						component.matrix = new Vector2(j, i);
					}
					if (bombDisposalItem.upWallType != WallType.NoWall)
					{
						string text3 = bombDisposalItem.upWallType.ToString();
						GameObject gameObject = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("Prefabs/Maps/" + text3), wallParent.transform);
						float x2 = num + (float)j * size;
						float z2 = num2 - (float)i * size + size * 0.5f;
						gameObject.transform.localPosition = new Vector3(x2, 0f, z2);
						if (bombDisposalItem.upWallType == WallType.BlueDoor || bombDisposalItem.upWallType == WallType.GreyDoor || bombDisposalItem.upWallType == WallType.YellowDoor)
						{
							OpenDoorController component2 = gameObject.GetComponent<OpenDoorController>();
							component2.matrix = new Vector3(j, i, 1f);
							component2.wallType = bombDisposalItem.upWallType;
						}
					}
					if (bombDisposalItem.leftWallType != WallType.NoWall)
					{
						string text4 = bombDisposalItem.leftWallType.ToString();
						GameObject gameObject2 = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("Prefabs/Maps/" + text4), wallParent.transform);
						float x3 = num + (float)j * size - size * 0.5f;
						float z3 = num2 - (float)i * size;
						gameObject2.transform.localPosition = new Vector3(x3, 0f, z3);
						gameObject2.transform.localEulerAngles = new Vector3(0f, 90f, 0f);
						if (bombDisposalItem.leftWallType == WallType.BlueDoor || bombDisposalItem.leftWallType == WallType.GreyDoor || bombDisposalItem.leftWallType == WallType.YellowDoor)
						{
							OpenDoorController component3 = gameObject2.GetComponent<OpenDoorController>();
							component3.matrix = new Vector3(j, i, 0f);
							component3.wallType = bombDisposalItem.leftWallType;
						}
					}
					if (i == detail.row - 1 && bombDisposalItem.floorType != FloorType.None)
					{
						GameObject obj2 = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("Prefabs/Maps/" + WallType.Window), wallParent.transform);
						float x4 = num + (float)j * size;
						float z4 = num2 - (float)i * size - size * 0.5f;
						obj2.transform.localPosition = new Vector3(x4, 0f, z4);
					}
					if (j == detail.column - 1 && bombDisposalItem.floorType != FloorType.None)
					{
						GameObject obj3 = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("Prefabs/Maps/" + WallType.Window), wallParent.transform);
						float x5 = num + (float)j * size + size * 0.5f;
						float z5 = num2 - (float)i * size;
						obj3.transform.localPosition = new Vector3(x5, 0f, z5);
						obj3.transform.localEulerAngles = new Vector3(0f, 90f, 0f);
					}
					if (i != 0 && j != 0)
					{
						GameObject obj4 = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("Prefabs/Maps/EndPost"), wallParent.transform);
						float x6 = num + (float)j * size - size * 0.5f;
						float z6 = num2 - (float)i * size + size * 0.5f;
						obj4.transform.localPosition = new Vector3(x6, 0f, z6);
					}
					if (bombDisposalItem.personType != 0)
					{
						string text5 = bombDisposalItem.personType.ToString();
						GameObject gameObject3 = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("Prefabs/Maps/" + text5), personParent.transform);
						float x7 = num + (float)j * size;
						float z7 = num2 - (float)i * size;
						switch (bombDisposalItem.personType)
						{
						case PersonType.Person:
							personController = gameObject3.GetComponent<PersonController>();
							curPersonMatrix = new Vector2(j, i);
							gameObject3.transform.localPosition = new Vector3(x7, 0f, z7);
							break;
						case PersonType.Bomb:
							curBomb = gameObject3.transform;
							curBombMatrix = new Vector2(j, i);
							gameObject3.transform.localPosition = new Vector3(x7, 0.5f, z7);
							break;
						case PersonType.YellowKey:
							gameObject3.transform.localPosition = new Vector3(x7, 0.5f, z7);
							break;
						case PersonType.GreyKey:
							gameObject3.transform.localPosition = new Vector3(x7, 0.5f, z7);
							break;
						case PersonType.BlueKey:
							gameObject3.transform.localPosition = new Vector3(x7, 0.5f, z7);
							break;
						}
					}
				}
			}
			SetLightArea(curPersonMatrix);
			PlayerController.Instance.DelayHander(0.1f, delegate
			{
				GameObject gameObject4 = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("Prefabs/Maps/FogOfWar"), base.transform);
				gameObject4.transform.localPosition = new Vector3(0f, 1f, 0f);
				fogRenderer = gameObject4.GetComponent<FowFogRenderer>();
				int num3 = UnityEngine.Random.Range(0, 4);
				float fogSizeX = 0f;
				float fogSizeY = 0f;
				switch (num3)
				{
				case 0:
					root.localEulerAngles = Vector3.zero;
					fogSizeX = (float)detail.column / 3f * size;
					fogSizeY = (float)detail.row / 3f * size;
					break;
				case 1:
					root.localEulerAngles = new Vector3(0f, 90f, 0f);
					fogSizeX = (float)detail.row / 3f * size;
					fogSizeY = (float)detail.column / 3f * size;
					break;
				case 2:
					root.localEulerAngles = new Vector3(0f, 180f, 0f);
					fogSizeX = (float)detail.column / 3f * size;
					fogSizeY = (float)detail.row / 3f * size;
					break;
				case 3:
					root.localEulerAngles = new Vector3(0f, 270f, 0f);
					fogSizeX = (float)detail.row / 3f * size;
					fogSizeY = (float)detail.column / 3f * size;
					break;
				}
				fogRenderer.InitFowFogRenderer(fogSizeX, fogSizeY, personController.GetComponent<FowViewer>());
			});
		}

		public void ClearMap()
		{
			isRun = false;
			fogRenderer.fowManager.RemoveViewer(personController.GetComponent<FowViewer>());
			UnityEngine.Object.Destroy(fogRenderer.gameObject);
			foreach (Transform item in floorParent)
			{
				UnityEngine.Object.Destroy(item.gameObject);
			}
			foreach (Transform item2 in wallParent)
			{
				UnityEngine.Object.Destroy(item2.gameObject);
			}
			foreach (Transform item3 in personParent)
			{
				UnityEngine.Object.Destroy(item3.gameObject);
			}
			foreach (Transform item4 in fogParent)
			{
				UnityEngine.Object.Destroy(item4.gameObject);
			}
		}

		public void HitFloor(Transform floor)
		{
			if (isRun || !UIController.Instance.isStartTime || ((bool)personController && personController.isAni))
			{
				return;
			}
			FloorController controller = floor.GetComponent<FloorController>();
			if (!IsAdjoin(curPersonMatrix, controller.matrix))
			{
				return;
			}
			isRun = true;
			Vector3 personPos = personController.transform.position;
			Vector3 pos = floor.position;
			OpenDoorController doorController = GetAdjoinDoor(curPersonMatrix, controller.matrix);
			if ((bool)doorController && !doorController.isOpen)
			{
				float num = Vector3.Distance(personPos, pos);
				Vector3 vector = (pos - personPos).normalized * (num * 0.4f);
				Vector3 door = personPos + vector;
				personController.SetRunAni();
				personController.SetForward(door - personPos);
				personController.Move(door, delegate
				{
					personController.SetIdleAni();
					if (doorController.isOpen)
					{
						CheckpointManager.totalMoveNum++;
						PlayerController.Instance.DelayHander(1f, delegate
						{
							personController.SetRunAni();
							personController.SetForward(pos - personPos);
							curPersonMatrix = controller.matrix;
							SetLightArea(curPersonMatrix);
							personController.Move(pos, delegate
							{
								personController.SetIdleAni();
								isRun = false;
								if (lastController != null && lastController.floorType == FloorType.Special)
								{
									lastController.PlayFall();
								}
								if (controller.floorType == FloorType.Special && controller.EnterHere())
								{
									continuateNum = 0;
									curMissNum++;
									CheckpointManager.SetChanglleNum(curMissNum);
									UIController.Instance.PlayAudioSound(1);
									UIController.Instance.IsStartTime(isStart: false);
									if (curMissNum >= CheckpointManager.CurBombLevel.ChallengeNum)
									{
										CheckpointManager.ReduceStrength(CheckpointManager.CurBombLevel.DownshiftGrade);
										personController.SetFallAni();
										PlayerController.Instance.DelayHander(1.5f, delegate
										{
											ClearMap();
											CreateMapToCheck();
										});
									}
									else
									{
										personController.SetFallAni();
										PlayerController.Instance.DelayHander(1.5f, delegate
										{
											ClearMap();
											CreateMap(CheckpointManager.curMapID);
										});
									}
								}
								lastController = controller;
							});
						});
					}
					else
					{
						PlayerController.Instance.DelayHander(0.5f, delegate
						{
							personController.SetRunAni();
							personController.SetForward(personPos - door);
							personController.Move(personPos, delegate
							{
								personController.SetIdleAni();
								isRun = false;
							});
						});
					}
				});
				return;
			}
			CheckpointManager.totalMoveNum++;
			personController.SetRunAni();
			personController.SetForward(pos - personPos);
			curPersonMatrix = controller.matrix;
			SetLightArea(curPersonMatrix);
			personController.Move(pos, delegate
			{
				personController.SetIdleAni();
				isRun = false;
				if (lastController != null && lastController.floorType == FloorType.Special)
				{
					lastController.PlayFall();
				}
				if (controller.floorType == FloorType.Special && controller.EnterHere())
				{
					continuateNum = 0;
					curMissNum++;
					CheckpointManager.SetChanglleNum(curMissNum);
					UIController.Instance.PlayAudioSound(1);
					UIController.Instance.IsStartTime(isStart: false);
					if (curMissNum >= CheckpointManager.CurBombLevel.ChallengeNum)
					{
						CheckpointManager.ReduceStrength(CheckpointManager.CurBombLevel.DownshiftGrade);
						personController.SetFallAni();
						PlayerController.Instance.DelayHander(1.5f, delegate
						{
							ClearMap();
							CreateMapToCheck();
						});
					}
					else
					{
						personController.SetFallAni();
						PlayerController.Instance.DelayHander(1.5f, delegate
						{
							ClearMap();
							CreateMap(CheckpointManager.curMapID);
						});
					}
				}
				lastController = controller;
			});
		}

		public void PassTheMap()
		{
			float item = (float)Math.Round((float)CheckpointManager.CurBombMap.LimitTime / challengeTimer, 2);
			CheckpointManager.efficiency.Add(item);
			CheckpointManager.allPass++;
			int num = ((!IsPerfectPass) ? 1 : 2);
			if (IsPerfectPass)
			{
				CheckpointManager.perfectNum++;
				continuateNum++;
				if (continuateNum > CheckpointManager.continuateMaxNum)
				{
					CheckpointManager.continuateMaxNum = continuateNum;
				}
			}
			else
			{
				continuateNum = 0;
			}
			CheckpointManager.AddScore(CheckpointManager.GetScore * num);
			UIController.Instance.PlayAudioSound((num == 1) ? 2 : 3);
			CheckpointManager.AddStrength(CheckpointManager.CurBombLevel.UpshiftGrade * num);
		}

		public void ResStartMap()
		{
			ClearMap();
			CreateMap(CheckpointManager.curMapID);
		}

		public void PlayBombEffect(Action complete)
		{
			if (!bombEffect)
			{
				bombEffect = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("Prefabs/Maps/BombEffects"), base.transform).GetComponent<ParticleSystem>();
			}
			bombEffect.transform.position = curBomb.position;
			personController.SetDeathAni();
			UnityEngine.Object.Destroy(curBomb.gameObject);
			PlayerController.Instance.DelayHander(2f, delegate
			{
				complete?.Invoke();
			});
		}

		public void Move(Vector3 pos)
		{
			base.transform.position += pos * 0.03f;
		}

		public void ResetAngle(bool isReset)
		{
			if (isReset)
			{
				base.transform.eulerAngles = initAngle;
			}
			else
			{
				base.transform.eulerAngles = Vector3.zero;
			}
		}

		private bool IsAdjoin(Vector2 from, Vector2 to)
		{
			if (from.y == to.y && Mathf.Abs(from.x - to.x) == 1f)
			{
				if (from.x - to.x > 0f)
				{
					BombDisposalItem bombDisposalItem = FindBombDisposalItem((int)from.y, (int)from.x);
					if (bombDisposalItem.leftWallType == WallType.Wall || bombDisposalItem.leftWallType == WallType.Window)
					{
						return false;
					}
					return true;
				}
				BombDisposalItem bombDisposalItem2 = FindBombDisposalItem((int)to.y, (int)to.x);
				if (bombDisposalItem2.leftWallType == WallType.Wall || bombDisposalItem2.leftWallType == WallType.Window)
				{
					return false;
				}
				return true;
			}
			if (from.x == to.x && Mathf.Abs(from.y - to.y) == 1f)
			{
				if (from.y - to.y < 0f)
				{
					BombDisposalItem bombDisposalItem3 = FindBombDisposalItem((int)to.y, (int)to.x);
					if (bombDisposalItem3.upWallType == WallType.Wall || bombDisposalItem3.upWallType == WallType.Window)
					{
						return false;
					}
					return true;
				}
				BombDisposalItem bombDisposalItem4 = FindBombDisposalItem((int)from.y, (int)from.x);
				if (bombDisposalItem4.upWallType == WallType.Wall || bombDisposalItem4.upWallType == WallType.Window)
				{
					return false;
				}
				return true;
			}
			return false;
		}

		private OpenDoorController GetAdjoinDoor(Vector2 from, Vector2 to)
		{
			Vector3 vector = ((from.x - to.x > 0f) ? new Vector3(from.x, from.y, 0f) : ((from.x - to.x < 0f) ? new Vector3(to.x, to.y, 0f) : ((!(from.y - to.y < 0f)) ? new Vector3(from.x, from.y, 1f) : new Vector3(to.x, to.y, 1f))));
			foreach (Transform item in wallParent)
			{
				OpenDoorController component = item.GetComponent<OpenDoorController>();
				if ((bool)component && component.matrix == vector)
				{
					return component;
				}
			}
			return null;
		}

		private void SetLightArea(Vector2 matrix)
		{
		}

		private DenseFogController GetDenseFog(Vector2 matrix)
		{
			foreach (Transform item in fogParent)
			{
				DenseFogController component = item.GetComponent<DenseFogController>();
				if (component.matrix == matrix)
				{
					return component;
				}
			}
			return null;
		}

		private BombDisposalItem FindBombDisposalItem(int row, int column)
		{
			int num = row * detail.column + column;
			for (int i = 0; i < detail.bombDisposalItems.Count; i++)
			{
				if (i == num)
				{
					return detail.bombDisposalItems[num];
				}
			}
			return null;
		}

		private bool CheckAngle(Vector2 normal, Vector2 vector)
		{
			if (Vector2.Angle(normal, vector) < 45f)
			{
				return true;
			}
			return false;
		}
	}
	public class UIController : MonoBehaviour
	{
		public static UIController Instance;

		public GameObject StaticCanvas;

		[Header("开始界面")]
		public GameObject StartGamePanel;

		public ToggleGroup toggleGroup;

		public Button startGameBtn;

		public Button settingsBtn;

		public Button tipsBtn;

		public Button exitBtn;

		public AudioSource bgAudioSource;

		[Header("游戏界面")]
		public GameObject ScorePanel;

		public Text CurScoreTxt;

		public Text LevelTxt;

		public Text TotalTimeTxt;

		public Text ChanglleNumTxt;

		public Text ChanglleTimeTxt;

		[Header("结算界面")]
		public GameObject PassAllCheckpointPanel;

		public TextMeshProUGUI ScoreTxt;

		public Text TrainingDurationTxt;

		public Text InitChallengeLevelTxt;

		public Text MaxChallengeLevelTxt;

		public Text MinChallengeLevelTxt;

		public Text AllPassTxt;

		public Text PerfectNumTxt;

		public Text ContinuateMaxNumTxt;

		public Text TimeOutNumTxt;

		public Text AverageMoveTimeTxt;

		public Text TotalMoveNumTxt;

		public Button passAllReturnBtn;

		[Header("暂停界面")]
		public GameObject SuspendPanel;

		public Button suspendReturnStartBtn;

		public Button resStartBtn;

		public Button suspendReturnBtn;

		[Header("退出提示界面")]
		public GameObject ExitTipPanel;

		public Button defineBtn;

		public Button cancelBtn;

		public AudioSource audioSource;

		public AudioClip[] audioClips;

		public bool isStartTime;

		private float surplusGameDuration;

		private void Awake()
		{
			Instance = this;
		}

		private void Start()
		{
			ScorePanel.SetActive(value: false);
			PassAllCheckpointPanel.SetActive(value: false);
			startGameBtn.onClick.AddListener(StartGameBtnHander);
			exitBtn.onClick.AddListener(ExitBtnHander);
			passAllReturnBtn.onClick.AddListener(PassAllBtnHander);
			suspendReturnStartBtn.onClick.AddListener(SuspendReturnStartBtnHander);
			resStartBtn.onClick.AddListener(ResStartBtnHander);
			suspendReturnBtn.onClick.AddListener(SuspendReturnBtnHander);
			defineBtn.onClick.AddListener(DefineBtnHander);
			cancelBtn.onClick.AddListener(CancelBtnHander);
			for (int i = 0; i < toggleGroup.transform.childCount; i++)
			{
				int index = i;
				Toggle component = toggleGroup.transform.GetChild(i).GetComponent<Toggle>();
				component.onValueChanged.AddListener(delegate(bool value)
				{
					if (value)
					{
						LoadManager.LevelID = index;
					}
				});
				if (LoadManager.LevelID == index)
				{
					component.isOn = true;
				}
			}
			PlayerController.Instance.InitData();
			if (LoadManager.IsLocalOperate)
			{
				StartGamePanel.SetActive(value: true);
				return;
			}
			StartGamePanel.SetActive(value: false);
			StartGameBtnHander(LoadManager.course);
		}

		private void Update()
		{
			if (CheckpointManager.IsStartGame)
			{
				surplusGameDuration -= Time.deltaTime;
				TotalTimeTxt.text = LoadManager.TimeConversion((int)surplusGameDuration);
				if (surplusGameDuration <= 0f)
				{
					CheckpointManager.OverTheGame();
				}
			}
			if (IsCanSuspend() && Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.APP))
			{
				IsStartTime(isStart: false);
				StaticCanvas.SetActive(value: true);
				SuspendPanel.SetActive(value: true);
				Time.timeScale = 0f;
			}
		}

		public void StartGame()
		{
			StaticCanvas.SetActive(value: false);
			ScorePanel.SetActive(value: true);
			surplusGameDuration = CheckpointManager.gameDuration - CheckpointManager.gameDurationed;
			CurScoreTxt.text = CheckpointManager.curScore.ToString();
			LevelTxt.text = CheckpointManager.GetCurLevel;
			TotalTimeTxt.text = LoadManager.TimeConversion((int)surplusGameDuration);
			CheckpointManager.SetChanglleNum(0);
			ChanglleTimeTxt.text = CheckpointManager.CurBombMap.LimitTime.ToString();
		}

		public void IsStartTime(bool isStart = true)
		{
			isStartTime = isStart;
		}

		public int GetUseDuration(bool isComplete = false)
		{
			float num = CheckpointManager.gameDuration - surplusGameDuration;
			num = (isComplete ? CheckpointManager.gameDuration : num);
			return (int)num;
		}

		public void OverTheGame()
		{
			IsStartTime(isStart: false);
			PlayAudioSound(4);
			StaticCanvas.SetActive(value: true);
			ScorePanel.SetActive(value: false);
			PassAllCheckpointPanel.SetActive(value: true);
			ScoreTxt.text = CheckpointManager.curScore.ToString();
			TrainingDurationTxt.text = LoadManager.TimeConversion((int)CheckpointManager.gameDuration);
			InitChallengeLevelTxt.text = CheckpointManager.GetInitChallengeLevel();
			MaxChallengeLevelTxt.text = CheckpointManager.GetMaxChallengeLevel();
			MinChallengeLevelTxt.text = CheckpointManager.GetMinChallengeLevel();
			AllPassTxt.text = CheckpointManager.allPass.ToString();
			PerfectNumTxt.text = CheckpointManager.perfectNum.ToString();
			ContinuateMaxNumTxt.text = CheckpointManager.continuateMaxNum.ToString();
			TimeOutNumTxt.text = CheckpointManager.timeOutNum.ToString();
			AverageMoveTimeTxt.text = ((CheckpointManager.totalMoveNum == 0) ? (CheckpointManager.gameDuration + "秒") : (Math.Round(CheckpointManager.gameDuration / (float)CheckpointManager.totalMoveNum, 2) + "秒"));
			TotalMoveNumTxt.text = CheckpointManager.totalMoveNum.ToString();
		}

		public void PlayAudioSound(int index)
		{
			if (audioSource.isPlaying)
			{
				audioSource.Stop();
			}
			audioSource.clip = audioClips[index];
			audioSource.Play();
		}

		public void CheckBattery(Action continueAction)
		{
			if (PlayerController.Instance.batteryTipController.CheckBattery(continueAction))
			{
				SuspendGame(suspend: true);
			}
		}

		public void SuspendGame(bool suspend)
		{
			IsStartTime(!suspend);
			StaticCanvas.SetActive(suspend);
			Time.timeScale = ((!suspend) ? 1 : 0);
		}

		private void StartGameBtnHander()
		{
			StartGameBtnHander(null);
		}

		private void StartGameBtnHander(CourseDetail.Data data)
		{
			StartGamePanel.SetActive(value: false);
			bgAudioSource.Play();
			CheckpointManager.StartTheLevel(data);
		}

		private void ExitBtnHander()
		{
			ScenesHelper.LoadScene(ScenesHelper.WeiAiZhiCenterScene);
		}

		private void PassAllBtnHander()
		{
			if (LoadManager.IsLocalOperate)
			{
				StartGamePanel.SetActive(value: true);
				PassAllCheckpointPanel.SetActive(value: false);
			}
			else
			{
				LoadManager.SubmitEndRecord(isComplete: true, isLogout: false, GetUseDuration(isComplete: true), CheckpointManager.curScore, J_LitJson.JsonMapper.ToJson(CheckpointManager.GetGameRecord()));
			}
		}

		private void SuspendReturnStartBtnHander()
		{
			if (LoadManager.IsLocalOperate)
			{
				CheckpointManager.ResetTheGame();
				StaticCanvas.SetActive(value: true);
				StartGamePanel.SetActive(value: true);
				SuspendPanel.SetActive(value: false);
				ScorePanel.SetActive(value: false);
				Time.timeScale = 1f;
			}
			else
			{
				ExitTipPanel.SetActive(value: true);
			}
		}

		private void ResStartBtnHander()
		{
			IsStartTime();
			StaticCanvas.SetActive(value: false);
			SuspendPanel.SetActive(value: false);
			Time.timeScale = 1f;
			RoomRootController.Instance.ResStartMap();
		}

		private void SuspendReturnBtnHander()
		{
			IsStartTime();
			StaticCanvas.SetActive(value: false);
			SuspendPanel.SetActive(value: false);
			Time.timeScale = 1f;
		}

		private void DefineBtnHander()
		{
			Time.timeScale = 1f;
			LoadManager.SubmitEndRecord(isComplete: false, isLogout: false, GetUseDuration(), CheckpointManager.curScore, J_LitJson.JsonMapper.ToJson(CheckpointManager.GetGameRecord()));
		}

		private void CancelBtnHander()
		{
			ExitTipPanel.SetActive(value: false);
		}

		private bool IsCanSuspend()
		{
			if (PassAllCheckpointPanel.activeSelf)
			{
				return false;
			}
			if (CheckpointManager.IsStartGame)
			{
				return true;
			}
			return false;
		}
	}
}
namespace EpicToonFX
{
	public class ETFXButtonScript : MonoBehaviour
	{
		public GameObject Button;

		private Text MyButtonText;

		private string projectileParticleName;

		private ETFXFireProjectile effectScript;

		private ETFXProjectileScript projectileScript;

		public float buttonsX;

		public float buttonsY;

		public float buttonsSizeX;

		public float buttonsSizeY;

		public float buttonsDistance;

		private void Start()
		{
			effectScript = GameObject.Find("ETFXFireProjectile").GetComponent<ETFXFireProjectile>();
			getProjectileNames();
			MyButtonText = Button.transform.Find("Text").GetComponent<Text>();
			MyButtonText.text = projectileParticleName;
		}

		private void Update()
		{
			MyButtonText.text = projectileParticleName;
		}

		public void getProjectileNames()
		{
			projectileScript = effectScript.projectiles[effectScript.currentProjectile].GetComponent<ETFXProjectileScript>();
			projectileParticleName = projectileScript.projectileParticle.name;
		}

		public bool overButton()
		{
			Rect rect = new Rect(buttonsX, buttonsY, buttonsSizeX, buttonsSizeY);
			Rect rect2 = new Rect(buttonsX + buttonsDistance, buttonsY, buttonsSizeX, buttonsSizeY);
			if (rect.Contains(new Vector2(Input.mousePosition.x, (float)Screen.height - Input.mousePosition.y)) || rect2.Contains(new Vector2(Input.mousePosition.x, (float)Screen.height - Input.mousePosition.y)))
			{
				return true;
			}
			return false;
		}
	}
	public class ETFXFireProjectile : MonoBehaviour
	{
		[SerializeField]
		public GameObject[] projectiles;

		[Header("Missile spawns at attached game object")]
		public Transform spawnPosition;

		[HideInInspector]
		public int currentProjectile;

		public float speed = 500f;

		private ETFXButtonScript selectedProjectileButton;

		private RaycastHit hit;

		private void Start()
		{
			selectedProjectileButton = GameObject.Find("Button").GetComponent<ETFXButtonScript>();
		}

		private void Update()
		{
			if (Input.GetKeyDown(KeyCode.RightArrow))
			{
				nextEffect();
			}
			if (Input.GetKeyDown(KeyCode.D))
			{
				nextEffect();
			}
			if (Input.GetKeyDown(KeyCode.A))
			{
				previousEffect();
			}
			else if (Input.GetKeyDown(KeyCode.LeftArrow))
			{
				previousEffect();
			}
			if (Input.GetKeyDown(KeyCode.Mouse0) && !EventSystem.current.IsPointerOverGameObject() && Physics.Raycast(Camera.main.ScreenPointToRay(Input.mousePosition), out hit, 100f))
			{
				GameObject gameObject = UnityEngine.Object.Instantiate(projectiles[currentProjectile], spawnPosition.position, Quaternion.identity);
				gameObject.transform.LookAt(hit.point);
				gameObject.GetComponent<Rigidbody>().AddForce(gameObject.transform.forward * speed);
			}
			UnityEngine.Debug.DrawRay(Camera.main.ScreenPointToRay(Input.mousePosition).origin, Camera.main.ScreenPointToRay(Input.mousePosition).direction * 100f, Color.yellow);
		}

		public void nextEffect()
		{
			if (currentProjectile < projectiles.Length - 1)
			{
				currentProjectile++;
			}
			else
			{
				currentProjectile = 0;
			}
			selectedProjectileButton.getProjectileNames();
		}

		public void previousEffect()
		{
			if (currentProjectile > 0)
			{
				currentProjectile--;
			}
			else
			{
				currentProjectile = projectiles.Length - 1;
			}
			selectedProjectileButton.getProjectileNames();
		}

		public void AdjustSpeed(float newSpeed)
		{
			speed = newSpeed;
		}
	}
	public class ETFXLoopScript : MonoBehaviour
	{
		public GameObject chosenEffect;

		public float loopTimeLimit = 2f;

		[Header("Spawn without")]
		public bool spawnWithoutLight = true;

		public bool spawnWithoutSound = true;

		private void Start()
		{
			PlayEffect();
		}

		public void PlayEffect()
		{
			StartCoroutine("EffectLoop");
		}

		private IEnumerator EffectLoop()
		{
			GameObject effectPlayer = UnityEngine.Object.Instantiate(chosenEffect, base.transform.position, base.transform.rotation);
			if (spawnWithoutLight = effectPlayer.GetComponent<Light>())
			{
				effectPlayer.GetComponent<Light>().enabled = false;
			}
			if (spawnWithoutSound = effectPlayer.GetComponent<AudioSource>())
			{
				effectPlayer.GetComponent<AudioSource>().enabled = false;
			}
			yield return new WaitForSeconds(loopTimeLimit);
			UnityEngine.Object.Destroy(effectPlayer);
			PlayEffect();
		}
	}
	public class ETFXMouseOrbit : MonoBehaviour
	{
		public Transform target;

		public float distance = 5f;

		public float xSpeed = 120f;

		public float ySpeed = 120f;

		public float yMinLimit = -20f;

		public float yMaxLimit = 80f;

		public float distanceMin = 0.5f;

		public float distanceMax = 15f;

		public float smoothTime = 2f;

		private float rotationYAxis;

		private float rotationXAxis;

		private float velocityX;

		private float velocityY;

		private void Start()
		{
			Vector3 eulerAngles = base.transform.eulerAngles;
			rotationYAxis = eulerAngles.y;
			rotationXAxis = eulerAngles.x;
			if ((bool)GetComponent<Rigidbody>())
			{
				GetComponent<Rigidbody>().freezeRotation = true;
			}
		}

		private void LateUpdate()
		{
			if ((bool)target)
			{
				if (Input.GetMouseButton(1))
				{
					velocityX += xSpeed * Input.GetAxis("Mouse X") * distance * 0.02f;
					velocityY += ySpeed * Input.GetAxis("Mouse Y") * 0.02f;
				}
				rotationYAxis += velocityX;
				rotationXAxis -= velocityY;
				rotationXAxis = ClampAngle(rotationXAxis, yMinLimit, yMaxLimit);
				Quaternion quaternion = Quaternion.Euler(rotationXAxis, rotationYAxis, 0f);
				distance = Mathf.Clamp(distance - Input.GetAxis("Mouse ScrollWheel") * 5f, distanceMin, distanceMax);
				if (Physics.Linecast(target.position, base.transform.position, out var hitInfo))
				{
					distance -= hitInfo.distance;
				}
				Vector3 vector = new Vector3(0f, 0f, 0f - distance);
				Vector3 position = quaternion * vector + target.position;
				base.transform.rotation = quaternion;
				base.transform.position = position;
				velocityX = Mathf.Lerp(velocityX, 0f, Time.deltaTime * smoothTime);
				velocityY = Mathf.Lerp(velocityY, 0f, Time.deltaTime * smoothTime);
			}
		}

		public static float ClampAngle(float angle, float min, float max)
		{
			if (angle < -360f)
			{
				angle += 360f;
			}
			if (angle > 360f)
			{
				angle -= 360f;
			}
			return Mathf.Clamp(angle, min, max);
		}
	}
	public class ETFXTarget : MonoBehaviour
	{
		[Header("Effect shown on target hit")]
		public GameObject hitParticle;

		[Header("Effect shown on target respawn")]
		public GameObject respawnParticle;

		private Renderer targetRenderer;

		private Collider targetCollider;

		private void Start()
		{
			targetRenderer = GetComponent<Renderer>();
			targetCollider = GetComponent<Collider>();
		}

		private void SpawnTarget()
		{
			targetRenderer.enabled = true;
			targetCollider.enabled = true;
			UnityEngine.Object.Destroy(UnityEngine.Object.Instantiate(respawnParticle, base.transform.position, base.transform.rotation), 3.5f);
		}

		private void OnTriggerEnter(Collider col)
		{
			if (col.tag == "Missile" && (bool)hitParticle)
			{
				UnityEngine.Object.Destroy(UnityEngine.Object.Instantiate(hitParticle, base.transform.position, base.transform.rotation), 2f);
				targetRenderer.enabled = false;
				targetCollider.enabled = false;
				StartCoroutine(Respawn());
			}
		}

		private IEnumerator Respawn()
		{
			yield return new WaitForSeconds(3f);
			SpawnTarget();
		}
	}
	public class ETFXLightFade : MonoBehaviour
	{
		[Header("Seconds to dim the light")]
		public float life = 0.2f;

		public bool killAfterLife = true;

		private Light li;

		private float initIntensity;

		private void Start()
		{
			if ((bool)base.gameObject.GetComponent<Light>())
			{
				li = base.gameObject.GetComponent<Light>();
				initIntensity = li.intensity;
			}
			else
			{
				MonoBehaviour.print("No light object found on " + base.gameObject.name);
			}
		}

		private void Update()
		{
			if ((bool)base.gameObject.GetComponent<Light>())
			{
				li.intensity -= initIntensity * (Time.deltaTime / life);
				if (killAfterLife && li.intensity <= 0f)
				{
					UnityEngine.Object.Destroy(base.gameObject.GetComponent<Light>());
				}
			}
		}
	}
	public class ETFXPitchRandomizer : MonoBehaviour
	{
		public float randomPercent = 10f;

		private void Start()
		{
			base.transform.GetComponent<AudioSource>().pitch *= 1f + UnityEngine.Random.Range((0f - randomPercent) / 100f, randomPercent / 100f);
		}
	}
	public class ETFXRotation : MonoBehaviour
	{
		public enum spaceEnum
		{
			Local,
			World
		}

		[Header("Rotate axises by degrees per second")]
		public Vector3 rotateVector = Vector3.zero;

		public spaceEnum rotateSpace;

		private void Start()
		{
		}

		private void Update()
		{
			if (rotateSpace == spaceEnum.Local)
			{
				base.transform.Rotate(rotateVector * Time.deltaTime);
			}
			if (rotateSpace == spaceEnum.World)
			{
				base.transform.Rotate(rotateVector * Time.deltaTime, Space.World);
			}
		}
	}
}
namespace AncientPoetry
{
	public class AncientPoetryLevel
	{
		public int LevelID;

		public string LevelName;

		public int InitialWord;

		public int InitialSentence;

		public float LimitTime;

		public int BaseScore;

		public int ChallengeNum;

		public int HamsterNum;

		public float ResidenceTinme;

		public float Interval;

		public int IsTipAnswer;

		public int IsAddWord;

		public int IsAddHamster;

		public int IsReduceTime;

		public int UpshiftRequire;

		public int UpshiftGrade;

		public int DownshiftRequire;

		public int DownshiftGrade;
	}
	public class AncientPoetryStrength
	{
		public int StrengthID;

		public int StrengthGrade;

		public float ScoreAddition;

		public int WordAddition;

		public float ReduceTime;

		public int HamsterAddition;
	}
	public class AncientPoetryLibrary
	{
		public List<AncientPoetryItem> Library;
	}
	public class AncientPoetryItem
	{
		public string Name;

		public string Author;

		public string Content;

		public int Easy;

		public int Normal;

		public int Hard;

		public int Speical;
	}
	public class SimilarLibrary
	{
		public List<SimilarItem> Library;
	}
	public class SimilarItem
	{
		public string Word;

		public string Similar;
	}
	public class CheckpointManager
	{
		public static Dictionary<int, AncientPoetryLevel> LevelDataDic = new Dictionary<int, AncientPoetryLevel>();

		public static Dictionary<int, AncientPoetryStrength> StrengthDataDic = new Dictionary<int, AncientPoetryStrength>();

		public static AncientPoetryLibrary AncientPoetryLibrarys;

		public static SimilarLibrary SimilarLibrarys;

		public static int curLevelID;

		public static int curStrengthID;

		public static float gameDuration;

		public static float gameDurationed;

		public static int curScore;

		public static string startLevel;

		public static string minLevel;

		public static string maxLevel;

		public static int allPass;

		public static int perfectNum;

		public static int continuateMaxNum;

		public static int timeOutNum;

		public static int totalHitNum;

		public static int rightHitNum;

		public static List<float> hitInterval;

		public static bool IsStartGame = false;

		public static AncientPoetryLevel CurLevel => LevelDataDic[curLevelID];

		public static AncientPoetryStrength CurStrength => StrengthDataDic[curStrengthID];

		public static int GetScore => (int)((float)CurLevel.BaseScore * (1f + CurStrength.ScoreAddition));

		public static int GetWordNum
		{
			get
			{
				if (CurLevel.IsAddWord != 0)
				{
					return CurLevel.InitialWord + CurStrength.WordAddition;
				}
				return CurLevel.InitialWord;
			}
		}

		public static float GetHamsterNum => (CurLevel.IsAddHamster == 0) ? CurLevel.HamsterNum : (CurLevel.HamsterNum + CurStrength.HamsterAddition);

		public static float GetLimitTime
		{
			get
			{
				if (CurLevel.IsReduceTime != 0)
				{
					return CurLevel.LimitTime * (1f - CurStrength.ReduceTime);
				}
				return CurLevel.LimitTime;
			}
		}

		public static string GetCurLevel => LevelDataDic[curLevelID].LevelName + "-" + StrengthDataDic[curStrengthID].StrengthGrade;

		public static void StartTheLevel(CourseDetail.Data data)
		{
			if (data != null)
			{
				if (data.game_data == null)
				{
					string text = data.level + "-" + data.strength;
					InitData(data.level, data.strength, data.play_time, data.already_play_time, data.point, 0, 0, 0, 0, 0, 0, new List<float>(), text, text, text);
				}
				else
				{
					GameRecordData gameRecordData = J_LitJson.JsonMapper.ToObject<GameRecordData>(data.game_data);
					InitData(data.level, data.strength, data.play_time, data.already_play_time, data.point, gameRecordData.AllPass, gameRecordData.PerfectNum, gameRecordData.ContinuateMaxNum, gameRecordData.TimeOutNum, gameRecordData.TotalHitNum, gameRecordData.RightHitNum, gameRecordData.HitInterval, gameRecordData.InitLevel, gameRecordData.MaxLevel, gameRecordData.MinLevel);
				}
			}
			else
			{
				string text2 = LoadManager.LevelID + "-" + LoadManager.StrengthID;
				InitData(LoadManager.LevelID, LoadManager.StrengthID, LoadManager.Duration, 0, 0, 0, 0, 0, 0, 0, 0, new List<float>(), text2, text2, text2);
			}
			IsStartGame = true;
			HamsterBirthController.Instance.CreateAncientPoetrys();
			UIController.Instance.StartGame();
			PlayerController.Instance.IsShowVivePointers(isShow: false);
		}

		private static void InitData(int level, int strength, int duration, int durationed, int score, int allpass, int perfect, int continuate, int timeOut, int totalHit, int rightHit, List<float> interval, string start, string max, string min)
		{
			curLevelID = level;
			curStrengthID = strength;
			gameDuration = duration;
			gameDurationed = durationed;
			curScore = score;
			allPass = allpass;
			perfectNum = perfect;
			continuateMaxNum = continuate;
			timeOutNum = timeOut;
			totalHitNum = totalHit;
			rightHitNum = rightHit;
			hitInterval = interval;
			startLevel = start;
			maxLevel = max;
			minLevel = min;
		}

		public static void OverTheGame()
		{
			IsStartGame = false;
			PlayerController.Instance.StopAllCoroutines();
			HamsterBirthController.Instance.ClearAncientPoetrys();
			UIController.Instance.OverTheGame();
			PlayerController.Instance.IsShowVivePointers(isShow: true);
		}

		public static void ResetTheGame()
		{
			IsStartGame = false;
			PlayerController.Instance.StopAllCoroutines();
			HamsterBirthController.Instance.ClearAncientPoetrys();
			PlayerController.Instance.IsShowVivePointers(isShow: true);
		}

		public static string GetInitChallengeLevel()
		{
			string[] array = startLevel.Split('-');
			return LevelDataDic[int.Parse(array[0])].LevelName + "-" + StrengthDataDic[int.Parse(array[1])].StrengthGrade;
		}

		public static string GetMaxChallengeLevel()
		{
			string[] array = maxLevel.Split('-');
			return LevelDataDic[int.Parse(array[0])].LevelName + "-" + StrengthDataDic[int.Parse(array[1])].StrengthGrade;
		}

		public static string GetMinChallengeLevel()
		{
			string[] array = minLevel.Split('-');
			return LevelDataDic[int.Parse(array[0])].LevelName + "-" + StrengthDataDic[int.Parse(array[1])].StrengthGrade;
		}

		public static void AddStrength(int upshift)
		{
			curStrengthID += upshift;
			if (curStrengthID > 9)
			{
				if (LoadManager.IsLocalOperate && curLevelID >= LoadManager.MaxLevelID)
				{
					curStrengthID = 9;
				}
				else if (curLevelID >= LevelDataDic.Count - 1)
				{
					curStrengthID = 9;
				}
				else
				{
					curStrengthID -= 10;
					curLevelID++;
				}
			}
			SetMaxLevel();
			UIController.Instance.LevelTxt.text = GetCurLevel;
			LoadManager.SubmitLevelRecord(curLevelID, curStrengthID, UIController.Instance.GetUseDuration(), curScore, J_LitJson.JsonMapper.ToJson(GetGameRecord()));
		}

		public static void ReduceStrength(int downshift)
		{
			curStrengthID -= downshift;
			if (curStrengthID < 0)
			{
				if (curLevelID <= 0)
				{
					curStrengthID = 0;
				}
				else
				{
					curStrengthID += 10;
					curLevelID--;
				}
			}
			SetMinLevel();
			UIController.Instance.LevelTxt.text = GetCurLevel;
			LoadManager.SubmitLevelRecord(curLevelID, curStrengthID, UIController.Instance.GetUseDuration(), curScore, J_LitJson.JsonMapper.ToJson(GetGameRecord()));
		}

		private static void SetMaxLevel()
		{
			string[] array = maxLevel.Split('-');
			int num = int.Parse(array[0]);
			int num2 = int.Parse(array[1]);
			if (curLevelID == num)
			{
				if (curStrengthID > num2)
				{
					maxLevel = curLevelID + "-" + curStrengthID;
				}
			}
			else if (curLevelID > num)
			{
				maxLevel = curLevelID + "-" + curStrengthID;
			}
		}

		private static void SetMinLevel()
		{
			string[] array = minLevel.Split('-');
			int num = int.Parse(array[0]);
			int num2 = int.Parse(array[1]);
			if (curLevelID == num)
			{
				if (curStrengthID < num2)
				{
					minLevel = curLevelID + "-" + curStrengthID;
				}
			}
			else if (curLevelID < num)
			{
				minLevel = curLevelID + "-" + curStrengthID;
			}
		}

		public static void AddScore(int score)
		{
			curScore += score;
			UIController.Instance.CurScoreTxt.text = curScore.ToString();
		}

		public static void SetChanglleNum(int missMun)
		{
			int num = CurLevel.ChallengeNum - missMun;
			UIController.Instance.ChanglleNumTxt.text = ((num == 0) ? 1 : num).ToString();
		}

		public static void SetChanglleTime(float catchTimer)
		{
			UIController.Instance.ChanglleTimeTxt.text = Mathf.Ceil(catchTimer).ToString();
		}

		public static GameRecordData GetGameRecord()
		{
			return new GameRecordData
			{
				InitLevel = minLevel,
				MaxLevel = maxLevel,
				MinLevel = minLevel,
				AllPass = allPass,
				PerfectNum = perfectNum,
				ContinuateMaxNum = continuateMaxNum,
				TimeOutNum = timeOutNum,
				TotalHitNum = totalHitNum,
				RightHitNum = rightHitNum,
				HitInterval = hitInterval
			};
		}
	}
	public class GameRecordData
	{
		public string InitLevel;

		public string MaxLevel;

		public string MinLevel;

		public int AllPass;

		public int PerfectNum;

		public int ContinuateMaxNum;

		public int TimeOutNum;

		public int TotalHitNum;

		public int RightHitNum;

		public List<float> HitInterval;
	}
	public class HammerController : MonoBehaviour
	{
		private void Start()
		{
		}

		private void Update()
		{
		}

		public void OnCollisionEnter(UnityEngine.Collision collision)
		{
			if (collision.collider.name.Equals("DiShu"))
			{
				HamsterItem component = collision.transform.parent.GetComponent<HamsterItem>();
				if (!component.isHitting)
				{
					HamsterBirthController.Instance.HitTheHammer(component);
				}
			}
		}
	}
	public class HamsterBirthController : MonoBehaviour
	{
		public static HamsterBirthController Instance;

		public GameObject root;

		public Transform hamsterPoints;

		public Text ancientPoetryName;

		public Text ancientPoetryAuthor;

		public Transform ancientPoetry;

		public GameObject wordTemplate;

		public GameObject blanksTemplate;

		public GameObject entranceTemplate;

		private AncientPoetryItem curAncientPoetry;

		private string[] curSentence;

		private List<char> curAncientWords;

		private List<int> curSentenceIndexs;

		private Dictionary<int, List<char>> curSentenceExist;

		private List<int> curWordIndexs;

		private Dictionary<int, List<int>> curLineWordIndexs;

		private List<WordsItem> curWords;

		private List<HamsterItem> curAllHamsterItems;

		private List<HamsterItem> curHamsterItems;

		private int curHitIndex;

		private int curLineIndex;

		private Dictionary<AncientPoetryItem, int> ancientPoetryDic = new Dictionary<AncientPoetryItem, int>();

		private Dictionary<AncientPoetryItem, int> haveLearned = new Dictionary<AncientPoetryItem, int>();

		private bool isShowHamster;

		private float showInterval;

		private int notAppearNum;

		private bool isTipAnswered;

		private float tipTimes = 10f;

		private float tipTimer;

		private float challengeTimer;

		private int curMissNum;

		private int continuateNum;

		private int curHitNum;

		private float timerrrr = 0.25f;

		public bool IsPerfectPass
		{
			get
			{
				if (curMissNum == 0)
				{
					return true;
				}
				return false;
			}
		}

		private void Awake()
		{
			Instance = this;
		}

		private void Start()
		{
		}

		private void Update()
		{
			if (!CheckpointManager.IsStartGame)
			{
				return;
			}
			if (isShowHamster)
			{
				showInterval -= Time.deltaTime;
				if (showInterval <= 0f)
				{
					InitHamstersWords();
				}
				if (CheckpointManager.CurLevel.IsTipAnswer == 0 && !isTipAnswered)
				{
					tipTimer -= Time.deltaTime;
					if (tipTimer <= 0f)
					{
						isTipAnswered = true;
						curWords[curHitIndex].IsTipAnswer();
					}
				}
			}
			challengeTimer -= Time.deltaTime;
			CheckpointManager.SetChanglleTime(challengeTimer);
			if (challengeTimer <= 0f)
			{
				isShowHamster = false;
				CheckpointManager.timeOutNum++;
				FielTheGroup();
			}
			if (Input.GetKeyDown(KeyCode.Space) && curHitIndex < curWords.Count)
			{
				HamsterItem hamsterItem = curHamsterItems.Find((HamsterItem x) => x.wordTxt.text == curWords[curHitIndex].wordTxt.text);
				if ((bool)hamsterItem)
				{
					HitTheHammer(hamsterItem);
				}
			}
		}

		public void CreateAncientPoetrys()
		{
			IsShowRoot(isShow: true);
			CreateEntrances();
			CreateAncientPoetryToCheck(isCheck: false);
		}

		public void HitTheHammer(HamsterItem hamster)
		{
			Controller.UPvr_VibrateNeo2Controller(0.5f, 50, Pvr_ControllerManager.controllerlink.mainHandID);
			CheckpointManager.totalHitNum++;
			curHitNum++;
			if (hamster.wordTxt.text.Equals(curWords[curHitIndex].wordTxt.text))
			{
				isTipAnswered = false;
				tipTimer = tipTimes;
				UIController.Instance.PlayAudioSound(0);
				curWords[curHitIndex].ShowAnswer();
				curHitIndex++;
				CheckpointManager.rightHitNum++;
				if (curHitIndex >= curWords.Count)
				{
					isShowHamster = false;
				}
				else
				{
					curLineIndex = curWords[curHitIndex].lineIndex;
				}
				if (curLineIndex >= 6)
				{
					ancientPoetry.DOLocalMoveY(70 * (curLineIndex - 5), 0.25f);
				}
				hamster.RightHit(isRight: true, delegate
				{
					if (curHitIndex >= curWords.Count)
					{
						CheckpointManager.hitInterval.Add((float)curHitNum / (CheckpointManager.CurLevel.LimitTime - challengeTimer));
						ancientPoetry.localPosition = Vector3.zero;
						PassTheGroup();
					}
				});
				return;
			}
			UIController.Instance.PlayAudioSound(1);
			continuateNum = 0;
			curMissNum++;
			CheckpointManager.SetChanglleNum(curMissNum);
			if (curMissNum >= CheckpointManager.CurLevel.ChallengeNum)
			{
				isShowHamster = false;
			}
			hamster.RightHit(isRight: false, delegate
			{
				if (curMissNum >= CheckpointManager.CurLevel.ChallengeNum)
				{
					CheckpointManager.hitInterval.Add((float)curHitNum / CheckpointManager.CurLevel.LimitTime);
					FielTheGroup();
				}
			});
		}

		public void HideHamster(HamsterItem hamster)
		{
			if (curHamsterItems.Contains(hamster))
			{
				curHamsterItems.Remove(hamster);
			}
		}

		public void ClearAncientPoetrys()
		{
			HideHamsters();
			DestroyAncientPoetrys();
			DestroyHamsters();
			IsShowRoot(isShow: false);
		}

		public void IsShowRoot(bool isShow)
		{
			root.SetActive(isShow);
		}

		private void CreateAncientPoetryToCheck(bool isCheck = true)
		{
			challengeTimer = CheckpointManager.CurLevel.LimitTime;
			CheckpointManager.SetChanglleTime(challengeTimer);
			curMissNum = 0;
			CheckpointManager.SetChanglleNum(curMissNum);
			if (isCheck)
			{
				UIController.Instance.CheckBattery(delegate
				{
					UIController.Instance.SuspendGame(suspend: false);
					CreateAncientPoetry();
				});
			}
			else
			{
				CreateAncientPoetry();
			}
		}

		private void CreateAncientPoetry()
		{
			curHitNum = 0;
			ancientPoetry.localPosition = Vector3.zero;
			List<AncientPoetryItem> list = new List<AncientPoetryItem>();
			if (CheckpointManager.CurLevel.IsTipAnswer == 0)
			{
				foreach (AncientPoetryItem key in ancientPoetryDic.Keys)
				{
					if (ancientPoetryDic[key] >= 3 && (!haveLearned.ContainsKey(key) || haveLearned[key] < 2))
					{
						list.Add(key);
					}
				}
				if (list.Count == 0)
				{
					foreach (AncientPoetryItem key2 in ancientPoetryDic.Keys)
					{
						if (!haveLearned.ContainsKey(key2) || haveLearned[key2] < 2)
						{
							list.Add(key2);
						}
					}
				}
				if (list.Count == 0)
				{
					foreach (AncientPoetryItem item2 in CheckpointManager.AncientPoetryLibrarys.Library)
					{
						list.Add(item2);
					}
				}
				curAncientPoetry = RandomRange(curAncientPoetry, list);
			}
			else if (ancientPoetryDic.Count > 10)
			{
				foreach (AncientPoetryItem key3 in ancientPoetryDic.Keys)
				{
					list.Add(key3);
				}
				curAncientPoetry = RandomRange(curAncientPoetry, list);
			}
			else
			{
				curAncientPoetry = RandomRange(curAncientPoetry, CheckpointManager.AncientPoetryLibrarys.Library);
			}
			if (!ancientPoetryDic.ContainsKey(curAncientPoetry))
			{
				ancientPoetryDic.Add(curAncientPoetry, 0);
			}
			ancientPoetryDic[curAncientPoetry]++;
			curSentence = curAncientPoetry.Content.Split(',');
			curAncientWords = new List<char>();
			string[] array = curSentence;
			foreach (string text in array)
			{
				foreach (char item in text)
				{
					curAncientWords.Add(item);
				}
			}
			curSentenceIndexs = new List<int>();
			curWordIndexs = new List<int>();
			curLineWordIndexs = new Dictionary<int, List<int>>();
			for (int k = 0; k < CheckpointManager.CurLevel.InitialSentence; k++)
			{
				curSentenceIndexs.Add(RandomRange());
			}
			int sentenceExist = GetSentenceExist();
			int num = ((CheckpointManager.GetWordNum > sentenceExist) ? sentenceExist : CheckpointManager.GetWordNum);
			for (int l = 0; l < num; l++)
			{
				int num2 = RandomWords(sentenceExist);
				curWordIndexs.Add(num2);
				SetLineWordIndexs(num2);
			}
			ancientPoetryName.text = curAncientPoetry.Name;
			ancientPoetryAuthor.text = curAncientPoetry.Author;
			curWords = new List<WordsItem>();
			for (int m = 0; m < curSentence.Length; m++)
			{
				if (curSentenceIndexs.Contains(m))
				{
					for (int n = 0; n < curSentence[m].Length; n++)
					{
						WordsItem component = UnityEngine.Object.Instantiate(blanksTemplate, ancientPoetry.GetChild(m)).GetComponent<WordsItem>();
						component.wordTxt.text = curSentence[m].Substring(n, 1);
						component.pinyinTxt.text = Pinyin.GetPinyin(component.wordTxt.text);
						component.lineIndex = m;
						component.IsTipAnswer(CheckpointManager.CurLevel.IsTipAnswer == 1);
						curWords.Add(component);
					}
					continue;
				}
				for (int num3 = 0; num3 < curSentence[m].Length; num3++)
				{
					if (curLineWordIndexs.ContainsKey(m) && curLineWordIndexs[m].Contains(num3))
					{
						WordsItem component2 = UnityEngine.Object.Instantiate(blanksTemplate, ancientPoetry.GetChild(m)).GetComponent<WordsItem>();
						component2.wordTxt.text = curSentence[m].Substring(num3, 1);
						component2.pinyinTxt.text = Pinyin.GetPinyin(component2.wordTxt.text);
						component2.lineIndex = m;
						component2.IsTipAnswer(CheckpointManager.CurLevel.IsTipAnswer == 1);
						curWords.Add(component2);
					}
					else
					{
						WordsItem component3 = UnityEngine.Object.Instantiate(wordTemplate, ancientPoetry.GetChild(m)).GetComponent<WordsItem>();
						component3.wordTxt.text = curSentence[m].Substring(num3, 1);
						component3.pinyinTxt.text = Pinyin.GetPinyin(component3.wordTxt.text);
						component3.lineIndex = m;
					}
				}
			}
			curHitIndex = 0;
			curLineIndex = curWords[curHitIndex].lineIndex;
			curHamsterItems = new List<HamsterItem>();
			isTipAnswered = false;
			tipTimer = tipTimes;
			PlayerController.Instance.DelayHander(1f, delegate
			{
				isShowHamster = true;
				InitHamstersWords();
			});
		}

		private void CreateEntrances()
		{
			curAllHamsterItems = new List<HamsterItem>();
			for (int i = 0; i < hamsterPoints.childCount; i++)
			{
				HamsterItem component = UnityEngine.Object.Instantiate(entranceTemplate, hamsterPoints.GetChild(i)).GetComponent<HamsterItem>();
				component.pointIndex = i;
				curAllHamsterItems.Add(component);
			}
		}

		private void InitHamstersWords()
		{
			if (!((float)curHamsterItems.Count >= CheckpointManager.GetHamsterNum))
			{
				showInterval = CheckpointManager.CurLevel.Interval;
				int index = RandomRangeEntrance();
				HamsterItem hamsterItem = curAllHamsterItems[index];
				if (IsAppearAnswer())
				{
					hamsterItem.wordTxt.text = curWords[curHitIndex].wordTxt.text;
				}
				else
				{
					hamsterItem.wordTxt.text = GetErrorWord();
				}
				curHamsterItems.Add(hamsterItem);
				hamsterItem.ShowHamster(CheckpointManager.CurLevel.ResidenceTinme);
			}
		}

		private bool IsAppearAnswer()
		{
			if ((bool)curHamsterItems.Find((HamsterItem x) => x.wordTxt.text == curWords[curHitIndex].wordTxt.text))
			{
				return false;
			}
			if (UnityEngine.Random.Range(0f, 1f) > 0.5f || notAppearNum == 1)
			{
				notAppearNum = 0;
				return true;
			}
			notAppearNum++;
			return false;
		}

		private string GetErrorWord()
		{
			UnityEngine.Random.InitState(Guid.NewGuid().GetHashCode());
			float num = UnityEngine.Random.Range(0f, 1f);
			if (num <= 0.33f)
			{
				int i;
				for (i = 0; i < curWords.Count; i++)
				{
					if (!curHamsterItems.Find((HamsterItem x) => x.wordTxt.text == curWords[i].wordTxt.text))
					{
						return curWords[i].wordTxt.text;
					}
				}
				return RandomRangeWords();
			}
			if (num > 0.33f && num < 0.66f)
			{
				string[] array = CheckpointManager.SimilarLibrarys.Library.Find((SimilarItem x) => x.Word == curWords[curHitIndex].wordTxt.text).Similar.Split('、');
				if (array.Length == 1 && string.IsNullOrEmpty(array[0]))
				{
					return RandomRangeWords();
				}
				string text = RandomRangeSimilar(array);
				if (string.IsNullOrEmpty(text))
				{
					return RandomRangeWords();
				}
				return text;
			}
			return RandomRangeWords();
		}

		private void HideHamsters()
		{
			for (int i = 0; i < curHamsterItems.Count; i++)
			{
				curHamsterItems[i].wordTxt.text = string.Empty;
				curHamsterItems[i].HideHamster();
			}
			curHamsterItems.Clear();
		}

		private void SetLineWordIndexs(int indexLine)
		{
			foreach (int key in curSentenceExist.Keys)
			{
				int num = indexLine - curSentenceExist[key].Count;
				if (num < 0)
				{
					if (!curLineWordIndexs.ContainsKey(key))
					{
						curLineWordIndexs.Add(key, new List<int>());
					}
					curLineWordIndexs[key].Add(indexLine);
					break;
				}
				indexLine = num;
			}
		}

		private int GetSentenceExist()
		{
			int num = 0;
			curSentenceExist = new Dictionary<int, List<char>>();
			for (int i = 0; i < curSentence.Length; i++)
			{
				if (!curSentenceIndexs.Contains(i))
				{
					List<char> list = new List<char>();
					string text = curSentence[i];
					foreach (char item in text)
					{
						list.Add(item);
						num++;
					}
					curSentenceExist.Add(i, list);
				}
			}
			return num;
		}

		private void PassTheGroup()
		{
			HideHamsters();
			CheckpointManager.allPass++;
			int num = ((!IsPerfectPass) ? 1 : 2);
			if (IsPerfectPass)
			{
				CheckpointManager.perfectNum++;
				continuateNum++;
				if (continuateNum > CheckpointManager.continuateMaxNum)
				{
					CheckpointManager.continuateMaxNum = continuateNum;
				}
				if (CheckpointManager.CurLevel.IsTipAnswer == 0)
				{
					if (!haveLearned.ContainsKey(curAncientPoetry))
					{
						haveLearned.Add(curAncientPoetry, 0);
					}
					haveLearned[curAncientPoetry]++;
				}
			}
			else
			{
				continuateNum = 0;
			}
			CheckpointManager.AddScore(CheckpointManager.GetScore);
			UIController.Instance.PlayAudioSound((num == 1) ? 2 : 3);
			CheckpointManager.AddStrength(CheckpointManager.CurLevel.UpshiftGrade);
			DestroyAncientPoetrys();
			CreateAncientPoetryToCheck();
		}

		private void FielTheGroup()
		{
			HideHamsters();
			CheckpointManager.SetChanglleTime(0f);
			CheckpointManager.ReduceStrength(CheckpointManager.CurLevel.DownshiftGrade);
			DestroyAncientPoetrys();
			CreateAncientPoetryToCheck();
		}

		private void DestroyAncientPoetrys()
		{
			foreach (Transform item in ancientPoetry)
			{
				foreach (Transform item2 in item)
				{
					UnityEngine.Object.Destroy(item2.gameObject);
				}
			}
			curAncientWords.Clear();
			curSentenceIndexs.Clear();
		}

		private void DestroyHamsters()
		{
			foreach (HamsterItem curAllHamsterItem in curAllHamsterItems)
			{
				UnityEngine.Object.Destroy(curAllHamsterItem.gameObject);
			}
			curAllHamsterItems.Clear();
		}

		private int RandomWords(int count)
		{
			UnityEngine.Random.InitState(Guid.NewGuid().GetHashCode());
			int num = UnityEngine.Random.Range(0, count);
			if (curWordIndexs.Contains(num))
			{
				return RandomWords(count);
			}
			return num;
		}

		private int RandomRange()
		{
			UnityEngine.Random.InitState(Guid.NewGuid().GetHashCode());
			int num = UnityEngine.Random.Range(0, curSentence.Length);
			if (curSentenceIndexs.Contains(num))
			{
				return RandomRange();
			}
			return num;
		}

		private AncientPoetryItem RandomRange(AncientPoetryItem curAncient, List<AncientPoetryItem> librials)
		{
			if (librials.Count == 1)
			{
				return librials[0];
			}
			UnityEngine.Random.InitState(Guid.NewGuid().GetHashCode());
			int index = UnityEngine.Random.Range(0, librials.Count);
			if (librials[index] == curAncient)
			{
				return RandomRange(curAncient, librials);
			}
			return librials[index];
		}

		private int RandomRangeEntrance()
		{
			UnityEngine.Random.InitState(Guid.NewGuid().GetHashCode());
			int num = UnityEngine.Random.Range(0, curAllHamsterItems.Count);
			if (curHamsterItems.Contains(curAllHamsterItems[num]))
			{
				return RandomRangeEntrance();
			}
			return num;
		}

		private string RandomRangeSimilar(string[] similars)
		{
			List<string> list = new List<string>();
			int i;
			for (i = 0; i < similars.Length; i++)
			{
				if (!curHamsterItems.Find((HamsterItem x) => x.wordTxt.text == similars[i]))
				{
					list.Add(similars[i]);
				}
			}
			UnityEngine.Random.InitState(Guid.NewGuid().GetHashCode());
			int index = UnityEngine.Random.Range(0, list.Count);
			if (list.Count == 0)
			{
				return string.Empty;
			}
			return list[index];
		}

		private string RandomRangeWords()
		{
			UnityEngine.Random.InitState(Guid.NewGuid().GetHashCode());
			int random = UnityEngine.Random.Range(0, curAncientWords.Count);
			if (curAncientWords[random].ToString() == curWords[curHitIndex].wordTxt.text)
			{
				return RandomRangeWords();
			}
			if ((bool)curHamsterItems.Find((HamsterItem x) => x.wordTxt.text == curAncientWords[random].ToString()))
			{
				return RandomRangeWords();
			}
			return curAncientWords[random].ToString();
		}
	}
	public class HamsterItem : MonoBehaviour
	{
		public Transform hamsterTra;

		public Text wordTxt;

		public Animation ani;

		public int pointIndex;

		public ParticleSystem rightParticle;

		public ParticleSystem errorParticle;

		public bool isHitting;

		private string[] clips = new string[2] { "Idle", "Hit" };

		private Vector3 initialPos;

		private bool isShowing;

		private float timer;

		private void Start()
		{
			initialPos = hamsterTra.localPosition;
		}

		private void Update()
		{
			if (isShowing)
			{
				timer -= Time.deltaTime;
				if (timer <= 0f)
				{
					HideHamster();
				}
			}
		}

		public void ShowHamster(float showTime)
		{
			isShowing = true;
			timer = showTime;
			hamsterTra.DOLocalMoveY(0f, 0.25f);
		}

		public void HideHamster()
		{
			isShowing = false;
			hamsterTra.DOLocalMoveY(initialPos.y, 0.25f).OnComplete(delegate
			{
				PlayAnimation(isHit: false);
				HamsterBirthController.Instance.HideHamster(this);
			});
		}

		public void PlayAnimation(bool isHit = true)
		{
			if (isHit)
			{
				ani.Play(clips[1]);
			}
			else
			{
				ani.Play(clips[0]);
			}
		}

		public void RightHit(bool isRight, Action action)
		{
			isHitting = true;
			wordTxt.text = string.Empty;
			if (isRight)
			{
				rightParticle.Play();
			}
			else
			{
				errorParticle.Play();
			}
			PlayAnimation();
			PlayerController.Instance.DelayHander(0.5f, delegate
			{
				hamsterTra.DOLocalMoveY(initialPos.y, 0.25f).OnComplete(delegate
				{
					PlayAnimation(isHit: false);
					isHitting = false;
					isShowing = false;
					HamsterBirthController.Instance.HideHamster(this);
					action?.Invoke();
				});
			});
		}
	}
	public class PlayerController : MonoBehaviour
	{
		public class Lib
		{
			public List<AA> Library;
		}

		public class AA
		{
			public string Word;

			public string Similar;
		}

		public static PlayerController Instance;

		public GameObject QiChui;

		public Pvr_ControllerModuleInit pvr_ControllerModuleInit;

		public BatteryTipController batteryTipController;

		private bool lastVivePointersIsShow;

		private void Awake()
		{
			Instance = this;
		}

		private void Start()
		{
			Time.fixedDeltaTime = 0.02f;
		}

		private void Update()
		{
		}

		public void InitData()
		{
			IsShowVivePointers(LoadManager.IsLocalOperate);
			List<AncientPoetryLevel> list = CsvMapper.ToObjectList<AncientPoetryLevel>(LoadManager.CsvRead("AncientPoetryLevel"));
			CheckpointManager.LevelDataDic.Clear();
			foreach (AncientPoetryLevel item in list)
			{
				CheckpointManager.LevelDataDic.Add(item.LevelID, item);
			}
			List<AncientPoetryStrength> list2 = CsvMapper.ToObjectList<AncientPoetryStrength>(LoadManager.CsvRead("AncientPoetryStrength"));
			CheckpointManager.StrengthDataDic.Clear();
			foreach (AncientPoetryStrength item2 in list2)
			{
				CheckpointManager.StrengthDataDic.Add(item2.StrengthID, item2);
			}
			CheckpointManager.AncientPoetryLibrarys = LitJson.JsonMapper.ToObject<AncientPoetryLibrary>(LoadManager.JsonRead("AncientPoetryLibrary"));
			CheckpointManager.SimilarLibrarys = LitJson.JsonMapper.ToObject<SimilarLibrary>(LoadManager.JsonRead("SimilarLibrary"));
		}

		public void IsShowVivePointers(bool isShow)
		{
			lastVivePointersIsShow = pvr_ControllerModuleInit.GetModuleState();
			pvr_ControllerModuleInit.ForceHideOrShow(isShow);
			QiChui.SetActive(!isShow);
		}

		public void ResetShowVivePointers()
		{
			pvr_ControllerModuleInit.ForceHideOrShow(lastVivePointersIsShow);
			QiChui.SetActive(!lastVivePointersIsShow);
		}

		public void DelayHander(float time, Action action)
		{
			StartCoroutine(Wait(time, action));
		}

		private IEnumerator Wait(float time, Action action)
		{
			yield return new WaitForSeconds(time);
			action?.Invoke();
		}
	}
	public class UIController : MonoBehaviour
	{
		public static UIController Instance;

		[Header("开始界面")]
		public GameObject StartGamePanel;

		public ToggleGroup toggleGroup;

		public Button startGameBtn;

		public Button exitBtn;

		public AudioSource bgAudioSource;

		[Header("游戏界面")]
		public GameObject ScorePanel;

		public Text CurScoreTxt;

		public Text LevelTxt;

		public Text TotalTimeTxt;

		public Text ChanglleNumTxt;

		public Text ChanglleTimeTxt;

		[Header("结算界面")]
		public GameObject PassAllCheckpointPanel;

		public TextMeshProUGUI ScoreTxt;

		public Text TrainingDurationTxt;

		public Text InitChallengeLevelTxt;

		public Text MaxChallengeLevelTxt;

		public Text MinChallengeLevelTxt;

		public Text AllPassTxt;

		public Text PerfectNumTxt;

		public Text ContinuateMaxNumTxt;

		public Text TimeOutNumTxt;

		public Text TotalHitNumTxt;

		public Text HitAccuracyTxt;

		public Text HitIntervalTxt;

		public Button passAllReturnBtn;

		[Header("暂停界面")]
		public GameObject SuspendPanel;

		public Button suspendReturnStartBtn;

		public Button suspendReturnBtn;

		[Header("退出提示界面")]
		public GameObject ExitTipPanel;

		public Button defineBtn;

		public Button cancelBtn;

		public AudioSource audioSource;

		public AudioClip[] audioClips;

		private float surplusGameDuration;

		private bool isStartTime;

		private float checkTime;

		private void Awake()
		{
			Instance = this;
		}

		private void Start()
		{
			ScorePanel.SetActive(value: false);
			PassAllCheckpointPanel.SetActive(value: false);
			startGameBtn.onClick.AddListener(StartGameBtnHander);
			exitBtn.onClick.AddListener(ExitBtnHander);
			passAllReturnBtn.onClick.AddListener(PassAllBtnHander);
			suspendReturnStartBtn.onClick.AddListener(SuspendReturnStartBtnHander);
			suspendReturnBtn.onClick.AddListener(SuspendReturnBtnHander);
			defineBtn.onClick.AddListener(DefineBtnHander);
			cancelBtn.onClick.AddListener(CancelBtnHander);
			for (int i = 0; i < toggleGroup.transform.childCount; i++)
			{
				int index = i;
				Toggle component = toggleGroup.transform.GetChild(i).GetComponent<Toggle>();
				component.onValueChanged.AddListener(delegate(bool value)
				{
					if (value)
					{
						LoadManager.LevelID = index;
					}
				});
				if (LoadManager.LevelID == index)
				{
					component.isOn = true;
				}
			}
			PlayerController.Instance.InitData();
			if (LoadManager.IsLocalOperate)
			{
				StartGamePanel.SetActive(value: true);
				return;
			}
			StartGamePanel.SetActive(value: false);
			StartGameBtnHander(LoadManager.course);
		}

		private void Update()
		{
			if (CheckpointManager.IsStartGame)
			{
				surplusGameDuration -= Time.deltaTime;
				TotalTimeTxt.text = LoadManager.TimeConversion((int)surplusGameDuration);
				if (surplusGameDuration <= 0f)
				{
					CheckpointManager.OverTheGame();
				}
			}
			if (IsCanSuspend() && Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.APP))
			{
				SuspendPanel.SetActive(value: true);
				SuspendGame(suspend: true);
			}
		}

		public void IsStartTime(bool isStart = true)
		{
			isStartTime = isStart;
		}

		public void StartGame()
		{
			ScorePanel.SetActive(value: true);
			surplusGameDuration = CheckpointManager.gameDuration - CheckpointManager.gameDurationed;
			CurScoreTxt.text = CheckpointManager.curScore.ToString();
			LevelTxt.text = CheckpointManager.GetCurLevel;
			TotalTimeTxt.text = LoadManager.TimeConversion((int)surplusGameDuration);
			ChanglleTimeTxt.text = CheckpointManager.CurLevel.LimitTime.ToString();
		}

		public void OverTheGame()
		{
			PlayerController.Instance.IsShowVivePointers(isShow: true);
			PlayAudioSound(4);
			PassAllCheckpointPanel.SetActive(value: true);
			ScorePanel.SetActive(value: false);
			ScoreTxt.text = CheckpointManager.curScore.ToString();
			TrainingDurationTxt.text = LoadManager.TimeConversion((int)CheckpointManager.gameDuration);
			InitChallengeLevelTxt.text = CheckpointManager.GetInitChallengeLevel();
			MaxChallengeLevelTxt.text = CheckpointManager.GetMaxChallengeLevel();
			MinChallengeLevelTxt.text = CheckpointManager.GetMinChallengeLevel();
			AllPassTxt.text = CheckpointManager.allPass.ToString();
			PerfectNumTxt.text = CheckpointManager.perfectNum.ToString();
			ContinuateMaxNumTxt.text = CheckpointManager.continuateMaxNum.ToString();
			TimeOutNumTxt.text = CheckpointManager.timeOutNum.ToString();
			TotalHitNumTxt.text = CheckpointManager.totalHitNum.ToString();
			HitAccuracyTxt.text = ((CheckpointManager.totalHitNum == 0) ? "0%" : (Math.Round((float)CheckpointManager.rightHitNum / (float)CheckpointManager.totalHitNum, 4) * 100.0 + "%"));
			HitIntervalTxt.text = GetHitInterval(CheckpointManager.hitInterval);
		}

		public int GetUseDuration(bool isComplete = false)
		{
			float num = CheckpointManager.gameDuration - surplusGameDuration;
			num = (isComplete ? CheckpointManager.gameDuration : num);
			return (int)num;
		}

		public void PlayAudioSound(int index)
		{
			if (audioSource.isPlaying)
			{
				audioSource.Stop();
			}
			audioSource.clip = audioClips[index];
			audioSource.Play();
		}

		public void CheckBattery(Action continueAction)
		{
			if (PlayerController.Instance.batteryTipController.CheckBattery(continueAction))
			{
				SuspendGame(suspend: true);
			}
		}

		public void SuspendGame(bool suspend)
		{
			IsStartTime(!suspend);
			PlayerController.Instance.IsShowVivePointers(suspend);
			HamsterBirthController.Instance.IsShowRoot(!suspend);
			Time.timeScale = ((!suspend) ? 1 : 0);
		}

		private void StartGameBtnHander()
		{
			StartGameBtnHander(null);
		}

		private void StartGameBtnHander(CourseDetail.Data data)
		{
			StartGamePanel.SetActive(value: false);
			bgAudioSource.Play();
			CheckpointManager.StartTheLevel(data);
		}

		private void ExitBtnHander()
		{
			ScenesHelper.LoadScene(ScenesHelper.WeiAiZhiCenterScene);
		}

		private void PassAllBtnHander()
		{
			if (LoadManager.IsLocalOperate)
			{
				StartGamePanel.SetActive(value: true);
				PassAllCheckpointPanel.SetActive(value: false);
			}
			else
			{
				LoadManager.SubmitEndRecord(isComplete: true, isLogout: false, GetUseDuration(isComplete: true), CheckpointManager.curScore, J_LitJson.JsonMapper.ToJson(CheckpointManager.GetGameRecord()));
			}
		}

		private void SuspendReturnStartBtnHander()
		{
			if (LoadManager.IsLocalOperate)
			{
				HamsterBirthController.Instance.IsShowRoot(isShow: true);
				CheckpointManager.ResetTheGame();
				StartGamePanel.SetActive(value: true);
				SuspendPanel.SetActive(value: false);
				ScorePanel.SetActive(value: false);
				Time.timeScale = 1f;
			}
			else
			{
				ExitTipPanel.SetActive(value: true);
			}
		}

		private void SuspendReturnBtnHander()
		{
			SuspendPanel.SetActive(value: false);
			SuspendGame(suspend: false);
		}

		private void DefineBtnHander()
		{
			Time.timeScale = 1f;
			LoadManager.SubmitEndRecord(isComplete: false, isLogout: false, GetUseDuration(), CheckpointManager.curScore, J_LitJson.JsonMapper.ToJson(CheckpointManager.GetGameRecord()));
		}

		private void CancelBtnHander()
		{
			ExitTipPanel.SetActive(value: false);
		}

		private bool IsCanSuspend()
		{
			if (PassAllCheckpointPanel.activeSelf)
			{
				return false;
			}
			if (CheckpointManager.IsStartGame)
			{
				return true;
			}
			return false;
		}

		private string GetHitInterval(List<float> hitInterval)
		{
			if (hitInterval.Count == 0)
			{
				return "0";
			}
			float num = 0f;
			for (int i = 0; i < hitInterval.Count; i++)
			{
				num += hitInterval[i];
			}
			num /= (float)hitInterval.Count;
			return Math.Round(num, 2).ToString();
		}
	}
	public class WordsItem : MonoBehaviour
	{
		public Text wordTxt;

		public Text pinyinTxt;

		public int lineIndex;

		private void Start()
		{
		}

		private void Update()
		{
		}

		public void IsTipAnswer(bool isTip = true)
		{
			if (isTip)
			{
				wordTxt.color = new Color(wordTxt.color.r, wordTxt.color.g, wordTxt.color.b, 0.2f);
			}
			else
			{
				wordTxt.color = new Color(wordTxt.color.r, wordTxt.color.g, wordTxt.color.b, 0f);
			}
		}

		public void ShowAnswer()
		{
			wordTxt.color = new Color(wordTxt.color.r, wordTxt.color.g, wordTxt.color.b, 1f);
		}
	}
}
namespace Kino
{
	[ExecuteInEditMode]
	[RequireComponent(typeof(Camera))]
	[ImageEffectAllowedInSceneView]
	public class Bloom : MonoBehaviour
	{
		[SerializeField]
		[Tooltip("Filters out pixels under this level of brightness.")]
		private float _threshold = 0.8f;

		[SerializeField]
		[Range(0f, 1f)]
		[Tooltip("Makes transition between under/over-threshold gradual.")]
		private float _softKnee = 0.5f;

		[SerializeField]
		[Range(1f, 7f)]
		[Tooltip("Changes extent of veiling effects\nin a screen resolution-independent fashion.")]
		private float _radius = 2.5f;

		[SerializeField]
		[Tooltip("Blend factor of the result image.")]
		private float _intensity = 0.8f;

		[SerializeField]
		[Tooltip("Controls filter quality and buffer resolution.")]
		private bool _highQuality = true;

		[SerializeField]
		[Tooltip("Reduces flashing noise with an additional filter.")]
		private bool _antiFlicker = true;

		[SerializeField]
		[HideInInspector]
		private Shader _shader;

		private Material _material;

		private const int kMaxIterations = 16;

		private RenderTexture[] _blurBuffer1 = new RenderTexture[16];

		private RenderTexture[] _blurBuffer2 = new RenderTexture[16];

		public float thresholdGamma
		{
			get
			{
				return Mathf.Max(_threshold, 0f);
			}
			set
			{
				_threshold = value;
			}
		}

		public float thresholdLinear
		{
			get
			{
				return GammaToLinear(thresholdGamma);
			}
			set
			{
				_threshold = LinearToGamma(value);
			}
		}

		public float softKnee
		{
			get
			{
				return _softKnee;
			}
			set
			{
				_softKnee = value;
			}
		}

		public float radius
		{
			get
			{
				return _radius;
			}
			set
			{
				_radius = value;
			}
		}

		public float intensity
		{
			get
			{
				return Mathf.Max(_intensity, 0f);
			}
			set
			{
				_intensity = value;
			}
		}

		public bool highQuality
		{
			get
			{
				return _highQuality;
			}
			set
			{
				_highQuality = value;
			}
		}

		public bool antiFlicker
		{
			get
			{
				return _antiFlicker;
			}
			set
			{
				_antiFlicker = value;
			}
		}

		private float LinearToGamma(float x)
		{
			return Mathf.LinearToGammaSpace(x);
		}

		private float GammaToLinear(float x)
		{
			return Mathf.GammaToLinearSpace(x);
		}

		private void OnEnable()
		{
			Shader shader = (_shader ? _shader : Shader.Find("Hidden/Kino/Bloom"));
			_material = new Material(shader);
			_material.hideFlags = HideFlags.DontSave;
		}

		private void OnDisable()
		{
			UnityEngine.Object.DestroyImmediate(_material);
		}

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			bool isMobilePlatform = Application.isMobilePlatform;
			int num = source.width;
			int num2 = source.height;
			if (!_highQuality)
			{
				num /= 2;
				num2 /= 2;
			}
			RenderTextureFormat format = (isMobilePlatform ? RenderTextureFormat.Default : RenderTextureFormat.DefaultHDR);
			float num3 = Mathf.Log(num2, 2f) + _radius - 8f;
			int num4 = (int)num3;
			int num5 = Mathf.Clamp(num4, 1, 16);
			float num6 = thresholdLinear;
			_material.SetFloat("_Threshold", num6);
			float num7 = num6 * _softKnee + 1E-05f;
			Vector3 vector = new Vector3(num6 - num7, num7 * 2f, 0.25f / num7);
			_material.SetVector("_Curve", vector);
			bool flag = !_highQuality && _antiFlicker;
			_material.SetFloat("_PrefilterOffs", flag ? (-0.5f) : 0f);
			_material.SetFloat("_SampleScale", 0.5f + num3 - (float)num4);
			_material.SetFloat("_Intensity", intensity);
			RenderTexture temporary = RenderTexture.GetTemporary(num, num2, 0, format);
			int pass = (_antiFlicker ? 1 : 0);
			Graphics.Blit(source, temporary, _material, pass);
			RenderTexture renderTexture = temporary;
			for (int i = 0; i < num5; i++)
			{
				_blurBuffer1[i] = RenderTexture.GetTemporary(renderTexture.width / 2, renderTexture.height / 2, 0, format);
				pass = ((i == 0) ? (_antiFlicker ? 3 : 2) : 4);
				Graphics.Blit(renderTexture, _blurBuffer1[i], _material, pass);
				renderTexture = _blurBuffer1[i];
			}
			for (int num8 = num5 - 2; num8 >= 0; num8--)
			{
				RenderTexture renderTexture2 = _blurBuffer1[num8];
				_material.SetTexture("_BaseTex", renderTexture2);
				_blurBuffer2[num8] = RenderTexture.GetTemporary(renderTexture2.width, renderTexture2.height, 0, format);
				pass = (_highQuality ? 6 : 5);
				Graphics.Blit(renderTexture, _blurBuffer2[num8], _material, pass);
				renderTexture = _blurBuffer2[num8];
			}
			_material.SetTexture("_BaseTex", source);
			pass = (_highQuality ? 8 : 7);
			Graphics.Blit(renderTexture, destination, _material, pass);
			for (int j = 0; j < 16; j++)
			{
				if (_blurBuffer1[j] != null)
				{
					RenderTexture.ReleaseTemporary(_blurBuffer1[j]);
				}
				if (_blurBuffer2[j] != null)
				{
					RenderTexture.ReleaseTemporary(_blurBuffer2[j]);
				}
				_blurBuffer1[j] = null;
				_blurBuffer2[j] = null;
			}
			RenderTexture.ReleaseTemporary(temporary);
		}
	}
}
namespace CartoonFX
{
	[RequireComponent(typeof(ParticleSystem))]
	[DisallowMultipleComponent]
	public class CFXR_Effect : MonoBehaviour
	{
		[Serializable]
		public class CameraShake
		{
			public enum ShakeSpace
			{
				Screen,
				World
			}

			public static bool editorPreview = true;

			public bool enabled;

			[Space]
			public bool useMainCamera = true;

			public List<Camera> cameras = new List<Camera>();

			[Space]
			public float delay;

			public float duration = 1f;

			public ShakeSpace shakeSpace;

			public Vector3 shakeStrength = new Vector3(0.1f, 0.1f, 0.1f);

			public AnimationCurve shakeCurve = AnimationCurve.Linear(0f, 1f, 1f, 0f);

			[Space]
			[Range(0f, 0.1f)]
			public float shakesDelay;

			[NonSerialized]
			public bool isShaking;

			private Dictionary<Camera, Vector3> camerasPreRenderPosition = new Dictionary<Camera, Vector3>();

			private Vector3 shakeVector;

			private float delaysTimer;

			private static bool s_CallbackRegistered;

			private static List<CameraShake> s_CameraShakes = new List<CameraShake>();

			private static void OnPreRenderCamera_Static(Camera cam)
			{
				int count = s_CameraShakes.Count;
				for (int i = 0; i < count; i++)
				{
					s_CameraShakes[i].onPreRenderCamera(cam);
				}
			}

			private static void OnPostRenderCamera_Static(Camera cam)
			{
				for (int num = s_CameraShakes.Count - 1; num >= 0; num--)
				{
					s_CameraShakes[num].onPostRenderCamera(cam);
				}
			}

			private static void RegisterStaticCallback(CameraShake cameraShake)
			{
				s_CameraShakes.Add(cameraShake);
				if (!s_CallbackRegistered)
				{
					Camera.onPreRender = (Camera.CameraCallback)Delegate.Combine(Camera.onPreRender, new Camera.CameraCallback(OnPreRenderCamera_Static));
					Camera.onPostRender = (Camera.CameraCallback)Delegate.Combine(Camera.onPostRender, new Camera.CameraCallback(OnPostRenderCamera_Static));
					s_CallbackRegistered = true;
				}
			}

			private static void UnregisterStaticCallback(CameraShake cameraShake)
			{
				s_CameraShakes.Remove(cameraShake);
				if (s_CallbackRegistered && s_CameraShakes.Count == 0)
				{
					Camera.onPreRender = (Camera.CameraCallback)Delegate.Remove(Camera.onPreRender, new Camera.CameraCallback(OnPreRenderCamera_Static));
					Camera.onPostRender = (Camera.CameraCallback)Delegate.Remove(Camera.onPostRender, new Camera.CameraCallback(OnPostRenderCamera_Static));
					s_CallbackRegistered = false;
				}
			}

			private void onPreRenderCamera(Camera cam)
			{
				if (isShaking && camerasPreRenderPosition.ContainsKey(cam))
				{
					camerasPreRenderPosition[cam] = cam.transform.localPosition;
					switch (shakeSpace)
					{
					case ShakeSpace.Screen:
						cam.transform.localPosition += cam.transform.rotation * shakeVector;
						break;
					case ShakeSpace.World:
						cam.transform.localPosition += shakeVector;
						break;
					}
				}
			}

			private void onPostRenderCamera(Camera cam)
			{
				if (camerasPreRenderPosition.ContainsKey(cam))
				{
					cam.transform.localPosition = camerasPreRenderPosition[cam];
				}
			}

			public void fetchCameras()
			{
				foreach (Camera camera in cameras)
				{
					if (!(camera == null))
					{
						camerasPreRenderPosition.Remove(camera);
					}
				}
				cameras.Clear();
				if (useMainCamera && Camera.main != null)
				{
					cameras.Add(Camera.main);
				}
				foreach (Camera camera2 in cameras)
				{
					if (!(camera2 == null) && !camerasPreRenderPosition.ContainsKey(camera2))
					{
						camerasPreRenderPosition.Add(camera2, Vector3.zero);
					}
				}
			}

			public void StartShake()
			{
				if (isShaking)
				{
					StopShake();
				}
				isShaking = true;
				RegisterStaticCallback(this);
			}

			public void StopShake()
			{
				isShaking = false;
				shakeVector = Vector3.zero;
				UnregisterStaticCallback(this);
			}

			public void animate(float time)
			{
				float num = duration + delay;
				if (time < num)
				{
					if (time < delay)
					{
						return;
					}
					if (!isShaking)
					{
						StartShake();
					}
					float time2 = Mathf.Clamp01(time / num);
					if (shakesDelay > 0f)
					{
						delaysTimer += Time.deltaTime;
						if (delaysTimer < shakesDelay)
						{
							return;
						}
						while (delaysTimer >= shakesDelay)
						{
							delaysTimer -= shakesDelay;
						}
					}
					Vector3 vector = Vector3.Scale(new Vector3(UnityEngine.Random.value, UnityEngine.Random.value, UnityEngine.Random.value), shakeStrength) * ((!(UnityEngine.Random.value > 0.5f)) ? 1 : (-1));
					shakeVector = vector * shakeCurve.Evaluate(time2) * 1f;
				}
				else if (isShaking)
				{
					StopShake();
				}
			}
		}

		public enum ClearBehavior
		{
			None,
			Disable,
			Destroy
		}

		[Serializable]
		public class AnimatedLight
		{
			public static bool editorPreview = true;

			public Light light;

			public bool loop;

			public bool animateIntensity;

			public float intensityStart = 8f;

			public float intensityEnd;

			public float intensityDuration = 0.5f;

			public AnimationCurve intensityCurve = AnimationCurve.EaseInOut(0f, 1f, 1f, 0f);

			public bool perlinIntensity;

			public float perlinIntensitySpeed = 1f;

			public bool fadeIn;

			public float fadeInDuration = 0.5f;

			public bool fadeOut;

			public float fadeOutDuration = 0.5f;

			public bool animateRange;

			public float rangeStart = 8f;

			public float rangeEnd;

			public float rangeDuration = 0.5f;

			public AnimationCurve rangeCurve = AnimationCurve.EaseInOut(0f, 1f, 1f, 0f);

			public bool perlinRange;

			public float perlinRangeSpeed = 1f;

			public bool animateColor;

			public Gradient colorGradient;

			public float colorDuration = 0.5f;

			public AnimationCurve colorCurve = AnimationCurve.EaseInOut(0f, 1f, 1f, 0f);

			public bool perlinColor;

			public float perlinColorSpeed = 1f;

			public void animate(float time)
			{
				if (!(light != null))
				{
					return;
				}
				if (animateIntensity)
				{
					float time2 = (loop ? Mathf.Clamp01(time % intensityDuration / intensityDuration) : Mathf.Clamp01(time / intensityDuration));
					time2 = (perlinIntensity ? Mathf.PerlinNoise(Time.time * perlinIntensitySpeed, 0f) : intensityCurve.Evaluate(time2));
					light.intensity = Mathf.LerpUnclamped(intensityEnd, intensityStart, time2);
					if (fadeIn && time < fadeInDuration)
					{
						light.intensity *= Mathf.Clamp01(time / fadeInDuration);
					}
				}
				if (animateRange)
				{
					float time3 = (loop ? Mathf.Clamp01(time % rangeDuration / rangeDuration) : Mathf.Clamp01(time / rangeDuration));
					time3 = (perlinRange ? Mathf.PerlinNoise(Time.time * perlinRangeSpeed, 10f) : rangeCurve.Evaluate(time3));
					light.range = Mathf.LerpUnclamped(rangeEnd, rangeStart, time3);
				}
				if (animateColor)
				{
					float time4 = (loop ? Mathf.Clamp01(time % colorDuration / colorDuration) : Mathf.Clamp01(time / colorDuration));
					time4 = (perlinColor ? Mathf.PerlinNoise(Time.time * perlinColorSpeed, 0f) : colorCurve.Evaluate(time4));
					light.color = colorGradient.Evaluate(time4);
				}
			}

			public void animateFadeOut(float time)
			{
				if (fadeOut && light != null)
				{
					light.intensity *= 1f - Mathf.Clamp01(time / fadeOutDuration);
				}
			}

			public void reset()
			{
				if (light != null)
				{
					if (animateIntensity)
					{
						light.intensity = ((fadeIn || fadeOut) ? 0f : intensityEnd);
					}
					if (animateRange)
					{
						light.range = rangeEnd;
					}
					if (animateColor)
					{
						light.color = colorGradient.Evaluate(1f);
					}
				}
			}
		}

		private const float GLOBAL_CAMERA_SHAKE_MULTIPLIER = 1f;

		public static bool GlobalDisableCameraShake;

		public static bool GlobalDisableLights;

		[Tooltip("Defines an action to execute when the Particle System has completely finished playing and emitting particles.")]
		public ClearBehavior clearBehavior = ClearBehavior.Destroy;

		[Space]
		public CameraShake cameraShake;

		[Space]
		public AnimatedLight[] animatedLights;

		[Tooltip("Defines which Particle System to track to trigger light fading out.\nLeave empty if not using fading out.")]
		public ParticleSystem fadeOutReference;

		private float time;

		private ParticleSystem rootParticleSystem;

		[NonSerialized]
		private MaterialPropertyBlock materialPropertyBlock;

		[NonSerialized]
		private Renderer particleRenderer;

		private const int CHECK_EVERY_N_FRAME = 20;

		private static int GlobalStartFrameOffset;

		private int startFrameOffset;

		private bool isFadingOut;

		private float fadingOutStartTime;

		public void ResetState()
		{
			time = 0f;
			fadingOutStartTime = 0f;
			isFadingOut = false;
			if (animatedLights != null)
			{
				AnimatedLight[] array = animatedLights;
				for (int i = 0; i < array.Length; i++)
				{
					array[i].reset();
				}
			}
			if (cameraShake != null && cameraShake.enabled)
			{
				cameraShake.StopShake();
			}
		}

		private void Awake()
		{
			if (cameraShake != null && cameraShake.enabled)
			{
				cameraShake.fetchCameras();
			}
			startFrameOffset = GlobalStartFrameOffset++;
			particleRenderer = GetComponent<ParticleSystemRenderer>();
			if (particleRenderer.sharedMaterial != null && particleRenderer.sharedMaterial.IsKeywordEnabled("_CFXR_LIGHTING_WPOS_OFFSET"))
			{
				materialPropertyBlock = new MaterialPropertyBlock();
			}
		}

		private void OnEnable()
		{
			AnimatedLight[] array = animatedLights;
			foreach (AnimatedLight animatedLight in array)
			{
				if (animatedLight.light != null)
				{
					animatedLight.light.enabled = !GlobalDisableLights;
				}
			}
		}

		private void OnDisable()
		{
			ResetState();
		}

		private void Update()
		{
			time += Time.deltaTime;
			Animate(time);
			if (fadeOutReference != null && !fadeOutReference.isEmitting && (fadeOutReference.isPlaying || isFadingOut))
			{
				FadeOut(time);
			}
			if (clearBehavior != 0)
			{
				if (rootParticleSystem == null)
				{
					rootParticleSystem = GetComponent<ParticleSystem>();
				}
				if ((Time.renderedFrameCount + startFrameOffset) % 20 == 0 && !rootParticleSystem.IsAlive(withChildren: true))
				{
					if (clearBehavior == ClearBehavior.Destroy)
					{
						UnityEngine.Object.Destroy(base.gameObject);
					}
					else
					{
						base.gameObject.SetActive(value: false);
					}
				}
			}
			if (materialPropertyBlock != null)
			{
				particleRenderer.GetPropertyBlock(materialPropertyBlock);
				materialPropertyBlock.SetVector("_GameObjectWorldPosition", base.transform.position);
				particleRenderer.SetPropertyBlock(materialPropertyBlock);
			}
		}

		public void Animate(float time)
		{
			if (animatedLights != null && !GlobalDisableLights)
			{
				AnimatedLight[] array = animatedLights;
				for (int i = 0; i < array.Length; i++)
				{
					array[i].animate(time);
				}
			}
			if (cameraShake != null && cameraShake.enabled && !GlobalDisableCameraShake)
			{
				cameraShake.animate(time);
			}
		}

		public void FadeOut(float time)
		{
			if (animatedLights != null)
			{
				if (!isFadingOut)
				{
					isFadingOut = true;
					fadingOutStartTime = time;
				}
				AnimatedLight[] array = animatedLights;
				for (int i = 0; i < array.Length; i++)
				{
					array[i].animateFadeOut(time - fadingOutStartTime);
				}
			}
		}
	}
	[RequireComponent(typeof(ParticleSystem))]
	public class CFXR_ParticleText : MonoBehaviour
	{
	}
	[RequireComponent(typeof(ParticleSystem))]
	public class CFXR_ParticleText_Runtime : MonoBehaviour
	{
		[Header("Text")]
		public string text;

		public float size = 1f;

		public float letterSpacing = 0.44f;

		[Header("Colors")]
		public Color backgroundColor = new Color(0f, 0f, 0f, 1f);

		public Color color1 = new Color(1f, 1f, 1f, 1f);

		public Color color2 = new Color(0f, 0f, 1f, 1f);

		[Header("Delay")]
		public float delay = 0.05f;

		public bool cumulativeDelay;

		[Range(0f, 2f)]
		public float compensateLifetime;

		[Header("Misc")]
		public float lifetimeMultiplier = 1f;

		[Range(-90f, 90f)]
		public float rotation = -5f;

		public float sortingFudgeOffset = 0.1f;

		public CFXR_ParticleTextFontAsset font;

		private float baseLifetime;

		private float baseScaleX;

		private float baseScaleY;

		private float baseScaleZ;

		private Vector3 basePivot;

		private void Awake()
		{
			InitializeFirstParticle();
		}

		public void InitializeFirstParticle()
		{
			if (base.transform.childCount == 0)
			{
				UnityEngine.Debug.LogError("CFXR_ParticleText_Runtime requires a child with a Particle System component to act as the model for other letters.");
				return;
			}
			ParticleSystem component = base.transform.GetChild(0).GetComponent<ParticleSystem>();
			baseLifetime = component.main.startLifetime.constant;
			baseScaleX = component.main.startSizeXMultiplier;
			baseScaleY = component.main.startSizeYMultiplier;
			baseScaleZ = component.main.startSizeZMultiplier;
			basePivot = component.GetComponent<ParticleSystemRenderer>().pivot;
		}

		public void GenerateText(string text)
		{
			if (text == null || font == null || !font.IsValid())
			{
				return;
			}
			if (base.transform.childCount == 0)
			{
				UnityEngine.Debug.LogError("CFXR_ParticleText_Runtime requires a child with a Particle System component to act as the model for other letters.");
				return;
			}
			float num = 0f;
			int num2 = 0;
			for (int i = 0; i < text.Length; i++)
			{
				if (char.IsWhiteSpace(text[i]))
				{
					if (i > 0)
					{
						num += letterSpacing * size;
					}
					continue;
				}
				num2++;
				if (i > 0)
				{
					int num3 = font.CharSequence.IndexOf(text[i]);
					float num4 = font.CharSprites[num3].rect.width + font.CharKerningOffsets[num3].post + font.CharKerningOffsets[num3].pre;
					num += (num4 * 0.01f + letterSpacing) * size;
				}
			}
			int num5 = base.transform.childCount - 1;
			if (num5 < num2)
			{
				GameObject original = base.transform.GetChild(0).gameObject;
				for (int j = num5; j < num2; j++)
				{
					GameObject obj = UnityEngine.Object.Instantiate(original);
					obj.transform.SetParent(base.transform);
					obj.transform.localPosition = Vector3.zero;
					obj.transform.localRotation = Quaternion.identity;
				}
			}
			float num6 = num / 2f;
			num = 0f;
			int num7 = 0;
			for (int k = 0; k < text.Length; k++)
			{
				char c = text[k];
				if (char.IsWhiteSpace(c))
				{
					num += letterSpacing * size;
					continue;
				}
				num7++;
				int num8 = font.CharSequence.IndexOf(text[k]);
				Sprite sprite = font.CharSprites[num8];
				float num9 = size * sprite.rect.width / 50f;
				num += font.CharKerningOffsets[num8].pre * 0.01f * size;
				float num10 = (num - num6) / num9;
				float num11 = sprite.rect.width + font.CharKerningOffsets[num8].post;
				num += (num11 * 0.01f + letterSpacing) * size;
				GameObject obj2 = base.transform.GetChild(num7).gameObject;
				obj2.name = c.ToString();
				ParticleSystem component = obj2.GetComponent<ParticleSystem>();
				ParticleSystem.MainModule main = component.main;
				main.startSizeXMultiplier = baseScaleX * num9;
				main.startSizeYMultiplier = baseScaleY * num9;
				main.startSizeZMultiplier = baseScaleZ * num9;
				component.textureSheetAnimation.SetSprite(0, sprite);
				main.startRotation = (float)Math.PI / 180f * rotation;
				main.startColor = backgroundColor;
				ParticleSystem.CustomDataModule customData = component.customData;
				customData.enabled = true;
				customData.SetColor(ParticleSystemCustomData.Custom1, color1);
				customData.SetColor(ParticleSystemCustomData.Custom2, color2);
				if (cumulativeDelay)
				{
					main.startDelay = delay * (float)k;
					main.startLifetime = Mathf.LerpUnclamped(baseLifetime, baseLifetime + delay * (float)(text.Length - k), compensateLifetime);
				}
				else
				{
					main.startDelay = delay;
				}
				main.startLifetime = main.startLifetime.constant * lifetimeMultiplier;
				ParticleSystemRenderer component2 = component.GetComponent<ParticleSystemRenderer>();
				component2.enabled = true;
				component2.pivot = new Vector3(basePivot.x + num10, basePivot.y, basePivot.z);
				component2.sortingFudge += (float)k * sortingFudgeOffset;
			}
			int l = 1;
			for (int childCount = base.transform.childCount; l < childCount; l++)
			{
				base.transform.GetChild(l).gameObject.SetActive(l <= num2);
			}
			GetComponent<ParticleSystem>().Play(withChildren: true);
		}
	}
	public class CFXR_ParticleTextFontAsset : ScriptableObject
	{
		[Serializable]
		public class Kerning
		{
			public string name = "A";

			public float pre;

			public float post;
		}

		public string CharSequence = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!?-.#@$ ";

		public Sprite[] CharSprites;

		public Kerning[] CharKerningOffsets;

		private void OnValidate()
		{
			base.hideFlags = HideFlags.None;
			if (CharKerningOffsets == null || CharKerningOffsets.Length != CharSequence.Length)
			{
				CharKerningOffsets = new Kerning[CharSequence.Length];
				for (int i = 0; i < CharKerningOffsets.Length; i++)
				{
					CharKerningOffsets[i] = new Kerning
					{
						name = CharSequence[i].ToString()
					};
				}
			}
		}

		public bool IsValid()
		{
			int num;
			if (!string.IsNullOrEmpty(CharSequence) && CharSprites != null && CharSprites.Length == CharSequence.Length && CharKerningOffsets != null)
			{
				num = ((CharKerningOffsets.Length == CharSprites.Length) ? 1 : 0);
				if (num != 0)
				{
					goto IL_0060;
				}
			}
			else
			{
				num = 0;
			}
			UnityEngine.Debug.LogError($"Invalid ParticleTextFontAsset: '{base.name}'\n", this);
			goto IL_0060;
			IL_0060:
			return (byte)num != 0;
		}
	}
	public class CFXR_Demo : MonoBehaviour
	{
		public Image btnSlowMotion;

		public Text lblSlowMotion;

		public Image btnCameraRotation;

		public Text lblCameraRotation;

		public Image btnShowGround;

		public Text lblShowGround;

		public Image btnCamShake;

		public Text lblCamShake;

		public Image btnLights;

		public Text lblLights;

		public Image btnBloom;

		public Text lblBloom;

		[Space]
		public Text labelEffect;

		public Text labelIndex;

		[Space]
		public GameObject ground;

		public Collider groundCollider;

		public Transform demoCamera;

		public MonoBehaviour bloom;

		public float rotationSpeed = 10f;

		private bool slowMotion;

		private bool rotateCamera;

		private bool showGround = true;

		[NonSerialized]
		public GameObject currentEffect;

		private GameObject[] effectsList;

		private int index;

		private Vector3 camInitialPosition;

		private Quaternion camInitialRotation;

		public void NextEffect()
		{
			index++;
			WrapIndex();
			PlayAtIndex();
		}

		public void PreviousEffect()
		{
			index--;
			WrapIndex();
			PlayAtIndex();
		}

		public void ToggleSlowMo()
		{
			slowMotion = !slowMotion;
			Time.timeScale = (slowMotion ? 0.33f : 1f);
			Color white = Color.white;
			white.a = (slowMotion ? 1f : 0.33f);
			btnSlowMotion.color = white;
			lblSlowMotion.color = white;
		}

		public void ToggleCamera()
		{
			rotateCamera = !rotateCamera;
			Color white = Color.white;
			white.a = (rotateCamera ? 1f : 0.33f);
			btnCameraRotation.color = white;
			lblCameraRotation.color = white;
		}

		public void ToggleGround()
		{
			showGround = !showGround;
			ground.SetActive(showGround);
			Color white = Color.white;
			white.a = (showGround ? 1f : 0.33f);
			btnShowGround.color = white;
			lblShowGround.color = white;
		}

		public void ToggleCameraShake()
		{
			CFXR_Effect.GlobalDisableCameraShake = !CFXR_Effect.GlobalDisableCameraShake;
			Color white = Color.white;
			white.a = (CFXR_Effect.GlobalDisableCameraShake ? 0.33f : 1f);
			btnCamShake.color = white;
			lblCamShake.color = white;
		}

		public void ToggleEffectsLights()
		{
			CFXR_Effect.GlobalDisableLights = !CFXR_Effect.GlobalDisableLights;
			Color white = Color.white;
			white.a = (CFXR_Effect.GlobalDisableLights ? 0.33f : 1f);
			btnLights.color = white;
			lblLights.color = white;
		}

		public void ToggleBloom()
		{
			bloom.enabled = !bloom.enabled;
			Color white = Color.white;
			white.a = ((!bloom.enabled) ? 0.33f : 1f);
			btnBloom.color = white;
			lblBloom.color = white;
		}

		public void ResetCam()
		{
			Camera.main.transform.position = camInitialPosition;
			Camera.main.transform.rotation = camInitialRotation;
		}

		private void Awake()
		{
			camInitialPosition = Camera.main.transform.position;
			camInitialRotation = Camera.main.transform.rotation;
			List<GameObject> list = new List<GameObject>();
			for (int i = 0; i < base.transform.childCount; i++)
			{
				list.Add(base.transform.GetChild(i).gameObject);
			}
			effectsList = list.ToArray();
			PlayAtIndex();
			UpdateLabels();
		}

		private void Update()
		{
			if (rotateCamera)
			{
				demoCamera.RotateAround(Vector3.zero, Vector3.up, rotationSpeed * Time.deltaTime);
			}
			if (Input.GetKeyDown(KeyCode.Space) && currentEffect != null)
			{
				ParticleSystem component = currentEffect.GetComponent<ParticleSystem>();
				if (component == null)
				{
					return;
				}
				if (component.isEmitting)
				{
					component.Stop(withChildren: true);
				}
				else if (!currentEffect.gameObject.activeSelf)
				{
					currentEffect.SetActive(value: true);
				}
				else
				{
					component.Play(withChildren: true);
					CFXR_Effect[] componentsInChildren = currentEffect.GetComponentsInChildren<CFXR_Effect>();
					for (int i = 0; i < componentsInChildren.Length; i++)
					{
						componentsInChildren[i].ResetState();
					}
				}
			}
			if ((Input.GetKeyDown(KeyCode.Delete) || Input.GetKeyDown(KeyCode.Backspace)) && currentEffect != null)
			{
				currentEffect.SetActive(value: false);
				currentEffect.SetActive(value: true);
			}
			if (Input.GetKeyDown(KeyCode.LeftArrow))
			{
				PreviousEffect();
			}
			if (Input.GetKeyDown(KeyCode.RightArrow))
			{
				NextEffect();
			}
			if (Input.GetMouseButtonDown(0) && Physics.Raycast(demoCamera.GetComponent<Camera>().ScreenPointToRay(Input.mousePosition)) && currentEffect != null)
			{
				currentEffect.SetActive(value: false);
				currentEffect.SetActive(value: true);
			}
			if (Input.GetMouseButtonDown(1) || Input.GetMouseButtonDown(2))
			{
				ResetCam();
			}
			float axis = Input.GetAxis("Mouse ScrollWheel");
			if (axis != 0f)
			{
				Camera.main.transform.Translate(Vector3.forward * ((axis < 0f) ? (-1f) : 1f), Space.Self);
			}
		}

		public void PlayAtIndex()
		{
			if (currentEffect != null)
			{
				currentEffect.SetActive(value: false);
			}
			currentEffect = effectsList[index];
			currentEffect.SetActive(value: true);
			UpdateLabels();
		}

		private void WrapIndex()
		{
			if (index < 0)
			{
				index = effectsList.Length - 1;
			}
			if (index >= effectsList.Length)
			{
				index = 0;
			}
		}

		private void UpdateLabels()
		{
			labelEffect.text = currentEffect.name;
			labelIndex.text = $"{index + 1}/{effectsList.Length}";
		}
	}
	public class CFXR_Demo_RandomText : MonoBehaviour
	{
		public ParticleSystem partSystem;

		public CFXR_ParticleText_Runtime runtimeParticleText;

		private void OnEnable()
		{
			InvokeRepeating("SetRandomText", 0f, 1.5f);
		}

		private void OnDisable()
		{
			CancelInvoke("SetRandomText");
			partSystem.Clear(withChildren: true);
		}

		private void SetRandomText()
		{
			int num = UnityEngine.Random.Range(10, 1000);
			runtimeParticleText.size = Mathf.Lerp(0.8f, 1.3f, (float)num / 1000f);
			string text = num.ToString();
			runtimeParticleText.GenerateText(text);
			partSystem.Play(withChildren: true);
		}
	}
	public class CFXR_Demo_Rotate : MonoBehaviour
	{
		public Vector3 axis = new Vector3(0f, 1f, 0f);

		public Vector3 center;

		public float speed = 1f;

		private void Update()
		{
			base.transform.RotateAround(center, axis, speed * Time.deltaTime);
		}
	}
}
namespace Assets._xunlian.Path
{
	public class CarActor : MonoBehaviour
	{
		public PathNode CurNode;

		public PathNode NextNode;

		private int state;

		private float lastTime;

		private float standTime = 5f;

		private float moveLen;

		private Vector3 cur;

		private Vector3 next;

		private Quaternion rot;

		private void Start()
		{
			CurNode = PathNode.CarNodes[UnityEngine.Random.Range(0, PathNode.CarNodes.Count)];
			base.transform.position = CurNode.transform.position;
			Next();
		}

		private void Next()
		{
			string text = CurNode.gameObject.name;
			if (NextNode != null)
			{
				CurNode = NextNode;
			}
			do
			{
				NextNode = CurNode.Nodes[UnityEngine.Random.Range(0, CurNode.Nodes.Count)];
			}
			while (NextNode.gameObject.name == text);
			next = NextNode.Pos();
			cur = base.transform.position;
			Quaternion rotation = base.transform.rotation;
			base.transform.LookAt(next);
			rot = Quaternion.Euler(0f, base.transform.rotation.eulerAngles.y, 0f);
			base.transform.rotation = rotation;
			moveLen = Vector3.Distance(cur, next) * 0.2f;
			lastTime = Time.time;
		}

		private void Update()
		{
			float num = (Time.time - lastTime) / moveLen;
			if (num >= 1f)
			{
				Next();
				return;
			}
			if (Time.time - lastTime <= 2f)
			{
				base.transform.rotation = Quaternion.Lerp(base.transform.rotation, rot, (Time.time - lastTime) / 2f);
			}
			base.transform.position = Vector3.Lerp(cur, next, num);
		}
	}
	public class MoveActor : MonoBehaviour
	{
		public static List<Transform> acts = new List<Transform>();

		public PathNode CurNode;

		public PathNode NextNode;

		private int state;

		private float lastTime;

		private float standTime = 5f;

		private float moveLen;

		private Animator ani;

		private Vector3 cur;

		private Vector3 next;

		private Quaternion rot;

		private void Start()
		{
			ani = GetComponent<Animator>();
			CurNode = PathNode.AllNodes[UnityEngine.Random.Range(0, PathNode.AllNodes.Count)];
			base.transform.position = CurNode.transform.position;
			Next();
		}

		private void Next()
		{
			state = UnityEngine.Random.Range(0, 3);
			if (state == 0)
			{
				standTime = UnityEngine.Random.Range(1f, 10f);
				ani.Play("idle1");
			}
			else
			{
				if (NextNode != null)
				{
					CurNode = NextNode;
				}
				NextNode = CurNode.Nodes[UnityEngine.Random.Range(0, CurNode.Nodes.Count)];
				next = NextNode.Pos();
				cur = base.transform.position;
				Quaternion rotation = base.transform.rotation;
				base.transform.LookAt(next);
				rot = Quaternion.Euler(0f, base.transform.rotation.eulerAngles.y, 0f);
				base.transform.rotation = rotation;
				moveLen = Vector3.Distance(cur, next) * 1.6f;
				ani.Play("walk");
			}
			lastTime = Time.time;
		}

		private void Update()
		{
			if (state == 0)
			{
				if (Time.time - lastTime > standTime)
				{
					Next();
				}
				return;
			}
			float num = (Time.time - lastTime) / moveLen;
			if (num >= 1f)
			{
				Next();
				return;
			}
			if (Time.time - lastTime <= 1f)
			{
				base.transform.rotation = Quaternion.Lerp(base.transform.rotation, rot, (Time.time - lastTime) / 1f);
			}
			base.transform.position = Vector3.Lerp(cur, next, num);
		}
	}
}
namespace LT_Task
{
	public class C_TaskCharactor : MonoBehaviour
	{
		public string taskID;

		public GameObject canavsWords;

		public Text m_txtWords;

		public AudioSource audioSource;

		public Animator talkAnimCtrl;

		private bool hasStartTask;

		public UnityEvent eventOnStartRecTask;

		private void Awake()
		{
			canavsWords.SetActive(value: false);
			talkAnimCtrl.enabled = false;
		}

		public void J_OnClickCharactor()
		{
			if (hasStartTask)
			{
				return;
			}
			Task task = TaskManager.FindSpeechTask(J_MapEnterance.Inst.m_MapName);
			if (task != null)
			{
				if (Vector3.Distance(WaveVRHead.Inst.headCam.position, base.transform.position) > 2.5f)
				{
					m_txtWords.text = "你好，请走进些";
					canavsWords.SetActive(value: true);
					return;
				}
				hasStartTask = true;
				string speechSentence = GoodsDataManager.Inst.GetSpeechSentence(task.goodsGroup);
				m_txtWords.text = speechSentence;
				BaiduWordToVoiceBase.J_GetAudio(speechSentence, delegate(AudioClip audioclip)
				{
					if (audioclip != null)
					{
						audioSource.clip = audioclip;
						audioSource.Play();
						talkAnimCtrl.enabled = true;
						Invoke("disableTalk", audioclip.length);
					}
					else
					{
						StartRec();
					}
				}, 5);
			}
			else
			{
				m_txtWords.text = "你好";
			}
			canavsWords.SetActive(value: true);
		}

		private void disableTalk()
		{
			talkAnimCtrl.enabled = false;
			StartRec();
		}

		private void StartRec()
		{
			eventOnStartRecTask.Invoke();
		}

		public void TaskFinish()
		{
			m_txtWords.text = "恭喜完成";
			TaskArgs taskArgs = new TaskArgs();
			taskArgs.taskType = eTaskType.Talk;
			taskArgs.taskID = taskID;
			TaskManager.Inst.CheackTask(taskArgs);
		}
	}
	public class C_TaskGoodItem : MonoBehaviour
	{
		public string itemID;

		public GameObject canvasUI;

		public RawImage m_imgIcon;

		public Text m_txtTitle;

		public Text m_txtAmount;

		public Text m_txtUnit;

		private int m_iAmount;

		private Gooditem itemInfo;

		private DateTime lastHideTime;

		public GameObject m_PS;

		private void Awake()
		{
			itemInfo = GoodsDataManager.Inst.GetGoodItemInfo(itemID);
			canvasUI.SetActive(value: false);
			m_iAmount = 1;
			m_txtTitle.text = itemInfo.id;
			m_imgIcon.texture = itemInfo.texIcon;
			m_txtUnit.text = itemInfo.unit;
			m_txtAmount.text = m_iAmount.ToString();
		}

		public void J_ShowBuyUI()
		{
			if (!((DateTime.Now - lastHideTime).TotalMilliseconds < 200.0))
			{
				canvasUI.SetActive(value: true);
			}
		}

		public void J_HideBuyUI()
		{
			canvasUI.SetActive(value: false);
			lastHideTime = DateTime.Now;
		}

		public void OnAmountValueChange(float fValue)
		{
			m_iAmount = (int)fValue;
			m_txtAmount.text = m_iAmount.ToString();
		}

		public void J_BuyGood()
		{
			J_HideBuyUI();
			LT_BagManager.J_AddGood(itemInfo, m_iAmount);
			try
			{
				if (m_PS != null)
				{
					StartCoroutine(PlayParticleToHandWatch());
				}
			}
			catch
			{
			}
		}

		private IEnumerator PlayParticleToHandWatch()
		{
			m_PS.transform.position = base.transform.position;
			m_PS.transform.localScale = Vector3.one;
			m_PS.SetActive(value: true);
			while (m_PS.transform.localScale.x > 0.11f)
			{
				m_PS.transform.position = Vector3.SlerpUnclamped(m_PS.transform.position, C_HandPadMenu.Inst.watchModelOriginal.transform.position, Time.deltaTime * 4f);
				m_PS.transform.localScale = Vector3.SlerpUnclamped(m_PS.transform.localScale, Vector3.one * 0.1f, Time.deltaTime * 4f);
				yield return null;
			}
			m_PS.SetActive(value: false);
		}
	}
	public class C_TaskSport : MonoBehaviour
	{
		public string mapTaskID;

		private float fTimer;

		private void Start()
		{
			Task task = TaskManager.FindSportTask(mapTaskID);
			if (task != null)
			{
				UnityEngine.Debug.LogWarning($"--任务目标，{task.map} 运动 {task.level}分钟");
				float time = (float)task.level * 60f;
				StartCoroutine(yieldTimer(time, delegate
				{
					TaskArgs args = new TaskArgs
					{
						taskType = eTaskType.Sport,
						taskID = mapTaskID
					};
					TaskManager.Inst.CheackTask(args);
				}));
			}
		}

		private IEnumerator yieldTimer(float time, Action actionOnTimeReach)
		{
			fTimer = 0f;
			float _fTimer = time;
			while (_fTimer > 0f)
			{
				_fTimer -= 1f;
				yield return new WaitForSeconds(1f);
			}
			actionOnTimeReach?.Invoke();
		}
	}
	public class GoodsDataManager
	{
		private static GoodsDataManager _inst;

		public Dictionary<string, Gooditem> m_dicAllGoods = new Dictionary<string, Gooditem>();

		public Dictionary<string, Speech> m_dicAllSpeech = new Dictionary<string, Speech>();

		public static GoodsDataManager Inst
		{
			get
			{
				if (_inst == null)
				{
					_inst = new GoodsDataManager();
				}
				return _inst;
			}
		}

		private GoodsDataManager()
		{
			UnityEngine.Debug.Log("--init datas");
			m_dicAllGoods = new Dictionary<string, Gooditem>();
			foreach (Good item in J_LitJson.JsonMapper.ToObject<List<Good>>(Resources.Load<TextAsset>("goods").text))
			{
				foreach (Gooditem item2 in item.items)
				{
					item2.group = item.group;
					if (m_dicAllGoods.ContainsKey(item2.id))
					{
						UnityEngine.Debug.LogError("--exist same item id:" + item2.id);
					}
					else
					{
						m_dicAllGoods.Add(item2.id, item2);
					}
				}
			}
			foreach (Speech item3 in J_LitJson.JsonMapper.ToObject<List<Speech>>(Resources.Load<TextAsset>("speech").text))
			{
				if (m_dicAllSpeech.ContainsKey(item3.group))
				{
					UnityEngine.Debug.LogError("--exist same group:" + item3.group);
				}
				else
				{
					m_dicAllSpeech.Add(item3.group, item3);
				}
			}
		}

		public Gooditem GetGoodItemInfo(string itemid)
		{
			if (m_dicAllGoods.ContainsKey(itemid))
			{
				Gooditem gooditem = m_dicAllGoods[itemid];
				if (gooditem.texIcon == null)
				{
					gooditem.texIcon = (Texture)ResourcesDataManager.TryGetObject("Textures/" + gooditem.icon);
				}
				return gooditem;
			}
			UnityEngine.Debug.LogError("--please set item " + itemid);
			return new Gooditem();
		}

		public List<Gooditem> GetGoodItems(string itemGroup)
		{
			return m_dicAllGoods.Values.Where((Gooditem obj) => obj.group == itemGroup).ToList();
		}

		public string GetSpeechSentence(string groupName)
		{
			string result = "你好，请在一分钟内尽量描述自己当前的心情";
			if (m_dicAllSpeech.ContainsKey(groupName))
			{
				List<string> sentences = m_dicAllSpeech[groupName].sentences;
				if (sentences.Count > 0)
				{
					result = sentences[UnityEngine.Random.Range(0, sentences.Count)];
				}
				else
				{
					UnityEngine.Debug.LogError("-- EMPTY speech group sententces :" + groupName);
				}
			}
			else
			{
				UnityEngine.Debug.LogError("--no speech group " + groupName);
			}
			return result;
		}
	}
	public class Task
	{
		public string taskID;

		public int type;

		public string taskName;

		public string description;

		public List<TaskCondition> taskConditions = new List<TaskCondition>();

		public int level;

		public int taskRewards;

		public string goodsGroup;

		public string map;

		public bool isComplete;
	}
	public class Good
	{
		public string group;

		public string map;

		public List<Gooditem> items;
	}
	public class Gooditem
	{
		public string id;

		public string unit;

		public string icon;

		public Texture texIcon;

		public string group;
	}
	public class Speech
	{
		public string group;

		public string map;

		public List<string> sentences;
	}
	public class TaskCondition
	{
		public bool isFinish;

		public event Func<TaskArgs, bool> funcCondition;

		public bool CheckCondition(TaskArgs args)
		{
			if (this.funcCondition != null)
			{
				return this.funcCondition(args);
			}
			return false;
		}
	}
	public class TaskArgs
	{
		public eTaskType taskType;

		public string taskID;

		public string itemId;

		public int amount;
	}
	public enum eTaskType
	{
		BuyGood = 1,
		Talk,
		Sport
	}
	public class TaskDataManager
	{
		public static TaskDataManager _inst;

		public Dictionary<string, Task> m_dicAllTasks = new Dictionary<string, Task>();

		public static TaskDataManager Inst
		{
			get
			{
				if (_inst == null)
				{
					_inst = new TaskDataManager();
				}
				return _inst;
			}
		}

		public TaskDataManager()
		{
			foreach (Task item in J_LitJson.JsonMapper.ToObject<List<Task>>(Resources.Load<TextAsset>("Task Definition").text))
			{
				if (m_dicAllTasks.ContainsKey(item.taskID))
				{
					UnityEngine.Debug.LogError("--exit task id:" + item.taskID);
				}
				else
				{
					m_dicAllTasks.Add(item.taskID, item);
				}
			}
		}

		public static void SetTaskParams(ref Task task, int ilevel)
		{
			task.level = ilevel;
			switch ((eTaskType)task.type)
			{
			case eTaskType.BuyGood:
			{
				List<Gooditem> goodItems = GoodsDataManager.Inst.GetGoodItems(task.goodsGroup);
				task.description = "请前往" + task.map + "购买";
				int num = ilevel / 2 + 1;
				if (num > goodItems.Count)
				{
					UnityEngine.Debug.LogWarning("--物品种类不足");
					num = goodItems.Count;
				}
				List<Gooditem> list = goodItems.OrderBy((Gooditem c) => Guid.NewGuid()).Take(num).ToList();
				bool flag = ilevel % 2 == 0;
				for (int i = 0; i < list.Count; i++)
				{
					TaskCondition tc = new TaskCondition();
					Gooditem gooditem = list[i];
					tc.isFinish = false;
					string itemID = gooditem.id;
					int nowAmount = 0;
					int targetAmount = (flag ? 1 : UnityEngine.Random.Range(2, 9));
					Task task2 = task;
					task2.description = task2.description + gooditem.id + targetAmount + gooditem.unit;
					if (i < list.Count - 1)
					{
						task.description += "、";
					}
					tc.funcCondition += delegate(TaskArgs args)
					{
						if (itemID == args.itemId)
						{
							nowAmount += args.amount;
							if (nowAmount < 0)
							{
								nowAmount = 0;
							}
							UnityEngine.Debug.LogWarning("购买" + itemID + " " + nowAmount + "/" + targetAmount);
							if (nowAmount >= targetAmount)
							{
								nowAmount = targetAmount;
								tc.isFinish = true;
							}
							else
							{
								tc.isFinish = false;
							}
							return true;
						}
						return false;
					};
					task.taskConditions.Add(tc);
					UnityEngine.Debug.LogWarning($"--任务目标，购买物品 {gooditem.id} ,共 {targetAmount} {gooditem.unit} :");
				}
				break;
			}
			case eTaskType.Talk:
			{
				TaskCondition tc2 = new TaskCondition();
				tc2.isFinish = false;
				string taskid = task.taskID;
				task.description = "请到" + task.map + "找到店员完成一次言语任务";
				tc2.funcCondition += delegate(TaskArgs args)
				{
					if (taskid == args.taskID)
					{
						if (tc2.isFinish)
						{
							UnityEngine.Debug.LogWarning("--已经完成过了");
							return false;
						}
						tc2.isFinish = true;
						UnityEngine.Debug.LogWarning(args.taskID + tc2.isFinish);
						return true;
					}
					return false;
				};
				task.taskConditions.Add(tc2);
				UnityEngine.Debug.LogWarning($"--任务目标，前往{task.map} 言语");
				break;
			}
			case eTaskType.Sport:
			{
				TaskCondition tc3 = new TaskCondition();
				tc3.isFinish = false;
				string taskid2 = task.taskID;
				task.description = "请到运动馆参加" + task.taskName + " " + task.level + "分钟";
				tc3.funcCondition += delegate(TaskArgs args)
				{
					if (taskid2 == args.taskID)
					{
						if (tc3.isFinish)
						{
							UnityEngine.Debug.LogWarning("--已经完成过了");
							return false;
						}
						tc3.isFinish = true;
						UnityEngine.Debug.LogWarning(args.taskID + tc3.isFinish);
						return true;
					}
					return false;
				};
				task.taskConditions.Add(tc3);
				UnityEngine.Debug.LogWarning($"--任务目标，前往{task.map} 运动 {task.level}分钟");
				break;
			}
			default:
				UnityEngine.Debug.LogError("--unkonw Task Type");
				break;
			}
		}

		public Task GetTaskByID(string id)
		{
			if (m_dicAllTasks.TryGetValue(id, out var value))
			{
				return value;
			}
			return null;
		}
	}
}
namespace J_VRHandMenu
{
	public class C_HandPadMenu : MonoBehaviour
	{
		[Serializable]
		public class MainOptionsDefine : cMenuPanel
		{
			public GameObject panelMainOption;

			[Header("背包")]
			public Button m_btnBag;

			public BagDefine m_Bag;

			[Header("任务列表")]
			public Button m_btnTaskList;

			public TaskListDefine m_TaskList;

			[Header("设置")]
			public Button m_btnSetting;

			public SettingDefine m_Setting;

			private int iSelectedIndex;

			private List<Button> listItems = new List<Button>();

			public void Init()
			{
				m_Bag.Init();
				m_btnBag.onClick.AddListener(delegate
				{
					iSelectedIndex = 0;
					panelMainOption.gameObject.SetActive(value: false);
					MenuPanelManager.ShowPanel(m_Bag);
				});
				m_TaskList.Init();
				m_btnTaskList.onClick.AddListener(delegate
				{
					iSelectedIndex = 1;
					panelMainOption.gameObject.SetActive(value: false);
					MenuPanelManager.ShowPanel(m_TaskList);
				});
				m_Setting.Init();
				m_btnSetting.onClick.AddListener(delegate
				{
					iSelectedIndex = 2;
					panelMainOption.gameObject.SetActive(value: false);
					MenuPanelManager.ShowPanel(m_Setting);
				});
				listItems.Add(m_btnBag);
				listItems.Add(m_btnTaskList);
				listItems.Add(m_btnSetting);
			}

			public void Open()
			{
				panelMainOption.SetActive(value: true);
				listItems[iSelectedIndex].Select();
			}

			public void OnHandKeyEvent(eHandKeyEvent keyEvent)
			{
				switch (keyEvent)
				{
				case eHandKeyEvent.UP:
				case eHandKeyEvent.LEFT:
					if (--iSelectedIndex < 0)
					{
						iSelectedIndex = listItems.Count - 1;
					}
					listItems[iSelectedIndex].Select();
					break;
				case eHandKeyEvent.DOWN:
				case eHandKeyEvent.RIGHT:
					if (++iSelectedIndex > listItems.Count - 1)
					{
						iSelectedIndex = 0;
					}
					listItems[iSelectedIndex].Select();
					break;
				case eHandKeyEvent.Comfirm:
					listItems[iSelectedIndex].onClick.Invoke();
					break;
				case eHandKeyEvent.Menu:
					MenuPanelManager.ClosePanel(this);
					break;
				}
			}

			public void OnFocus()
			{
				panelMainOption.gameObject.SetActive(value: true);
				listItems[iSelectedIndex].Select();
			}

			public void Close()
			{
				Inst.DoMenuUIAnim(isShow: false, delegate
				{
					m_isHandMenuOn = false;
					Inst.original.SetActive(value: false);
					WaveVRHead.Inst.J_OnHandMenuChange(isOn: false);
				});
			}
		}

		[Serializable]
		public class BagDefine : cMenuPanel
		{
			[Serializable]
			public class btnDefine
			{
				public string itemid;

				public Button btn;

				public Gooditem itemInfo;

				public int iAmount;
			}

			[Serializable]
			public class bagItemOptionDefine : cMenuPanel
			{
				public GameObject panelContent;

				public RawImage ItemTexture;

				public Text itemName;

				public Text txtAmount;

				public Button btnItemSell;

				public Button btnCloseItemOption;

				private Action actionOnSell;

				private Action actionOnCancle;

				private int iSelectedIndex;

				private List<Button> listItems = new List<Button>();

				public void Init()
				{
					panelContent.SetActive(value: false);
					btnItemSell.onClick.AddListener(SellItem);
					btnCloseItemOption.onClick.AddListener(CloseOption);
					panelContent.SetActive(value: false);
					listItems.Add(btnItemSell);
					listItems.Add(btnCloseItemOption);
				}

				private void SellItem()
				{
					MenuPanelManager.ClosePanel(this);
					if (actionOnSell != null)
					{
						actionOnSell();
					}
				}

				private void CloseOption()
				{
					MenuPanelManager.ClosePanel(this);
					if (actionOnCancle != null)
					{
						actionOnCancle();
					}
				}

				public void SetOptionsInfo(btnDefine item, Action actionOnSell, Action actionOnCancle)
				{
					panelContent.transform.position = item.btn.transform.position;
					ItemTexture.texture = item.itemInfo.texIcon;
					itemName.text = item.itemInfo.id ?? "";
					txtAmount.text = item.iAmount + item.itemInfo.unit;
					this.actionOnSell = actionOnSell;
					this.actionOnCancle = actionOnCancle;
				}

				public void Open()
				{
					panelContent.SetActive(value: true);
					iSelectedIndex = 0;
					listItems[iSelectedIndex].Select();
				}

				public void Close()
				{
					panelContent.SetActive(value: false);
				}

				public void OnHandKeyEvent(eHandKeyEvent keyEvent)
				{
					switch (keyEvent)
					{
					case eHandKeyEvent.UP:
					case eHandKeyEvent.LEFT:
						if (--iSelectedIndex < 0)
						{
							iSelectedIndex = listItems.Count - 1;
						}
						listItems[iSelectedIndex].Select();
						break;
					case eHandKeyEvent.DOWN:
					case eHandKeyEvent.RIGHT:
						if (++iSelectedIndex > listItems.Count - 1)
						{
							iSelectedIndex = 0;
						}
						listItems[iSelectedIndex].Select();
						break;
					case eHandKeyEvent.Comfirm:
						listItems[iSelectedIndex].onClick.Invoke();
						break;
					case eHandKeyEvent.Menu:
						MenuPanelManager.ClosePanel(this);
						break;
					}
				}

				public void OnFocus()
				{
				}
			}

			public GameObject panelContent;

			public Button prefabBtn;

			private Scrollbar scrollCtrl;

			private List<btnDefine> listItems = new List<btnDefine>();

			[Header("物品选项")]
			public bagItemOptionDefine bagItemOption;

			public Text TextEmptyTip;

			private int iSelectedIndex;

			private int iColumnNum = 4;

			private Coroutine enumerator;

			public void Init()
			{
				Transform parent = prefabBtn.transform.parent;
				prefabBtn.gameObject.SetActive(value: false);
				for (int num = parent.childCount - 1; num >= 0; num--)
				{
					if (!(prefabBtn.transform == parent.GetChild(num)))
					{
						UnityEngine.Object.Destroy(parent.GetChild(num).gameObject);
					}
				}
				bagItemOption.Init();
				scrollCtrl = panelContent.GetComponentInChildren<Scrollbar>();
				panelContent.SetActive(value: false);
				LT_BagManager.onGoodChange = (Action)Delegate.Combine(LT_BagManager.onGoodChange, new Action(J_RefreshUI));
			}

			public void J_RefreshUI()
			{
				UnityEngine.Debug.LogWarning("--refresh背包 UI");
				foreach (LT_BagManager.Item listBagGood in LT_BagManager.m_listBagGoods)
				{
					btnDefine targetBagItem = null;
					for (int i = 0; i < listItems.Count; i++)
					{
						if (listItems[i].itemid == listBagGood.id)
						{
							targetBagItem = listItems[i];
							break;
						}
					}
					if (listBagGood.iAmount <= 0)
					{
						UnityEngine.Object.Destroy(targetBagItem.btn.gameObject);
						listItems.Remove(targetBagItem);
						continue;
					}
					if (prefabBtn == null)
					{
						prefabBtn = Resources.Load<Button>("prefabBtn");
					}
					if ((targetBagItem == null || targetBagItem.btn == null) && prefabBtn != null)
					{
						GameObject gameObject = UnityEngine.Object.Instantiate(prefabBtn.gameObject);
						gameObject.transform.SetParent(prefabBtn.transform.parent);
						gameObject.transform.localPosition = Vector3.zero;
						gameObject.transform.localEulerAngles = Vector3.zero;
						gameObject.transform.localScale = Vector3.one;
						gameObject.gameObject.SetActive(value: true);
						targetBagItem = new btnDefine();
						targetBagItem.itemid = listBagGood.id;
						targetBagItem.itemInfo = listBagGood.iteminfo;
						targetBagItem.btn = gameObject.GetComponent<Button>();
						targetBagItem.btn.onClick.AddListener(delegate
						{
							ShowItemOption(targetBagItem);
						});
						listItems.Add(targetBagItem);
					}
					targetBagItem.iAmount = listBagGood.iAmount;
					targetBagItem.btn.GetComponentInChildren<Text>().text = targetBagItem.iAmount + targetBagItem.itemInfo.unit;
					targetBagItem.btn.GetComponentInChildren<RawImage>().texture = targetBagItem.itemInfo.texIcon;
				}
			}

			private void ShowItemOption(btnDefine item)
			{
				iSelectedIndex = listItems.IndexOf(item);
				bagItemOption.SetOptionsInfo(item, delegate
				{
					LT_BagManager.J_RemoveGood(item.itemInfo, item.iAmount);
					if (iSelectedIndex > listItems.Count - 1)
					{
						iSelectedIndex--;
					}
					if (iSelectedIndex >= 0)
					{
						listItems[iSelectedIndex].btn.Select();
					}
				}, delegate
				{
					if (iSelectedIndex >= 0)
					{
						listItems[iSelectedIndex].btn.Select();
					}
				});
				MenuPanelManager.ShowPanel(bagItemOption);
			}

			public void Open()
			{
				panelContent.SetActive(value: true);
				if (listItems.Count > 0)
				{
					listItems[0].btn.Select();
					TextEmptyTip.gameObject.SetActive(value: false);
				}
				else
				{
					TextEmptyTip.gameObject.SetActive(value: true);
				}
			}

			public void Close()
			{
				panelContent.SetActive(value: false);
			}

			public void OnHandKeyEvent(eHandKeyEvent keyEvent)
			{
				switch (keyEvent)
				{
				case eHandKeyEvent.UP:
					if ((iSelectedIndex -= iColumnNum) < 0)
					{
						iSelectedIndex = 0;
					}
					if (iSelectedIndex >= 0)
					{
						listItems[iSelectedIndex].btn.Select();
					}
					break;
				case eHandKeyEvent.DOWN:
					if ((iSelectedIndex += iColumnNum) > listItems.Count - 1)
					{
						iSelectedIndex = listItems.Count - 1;
					}
					if (iSelectedIndex >= 0)
					{
						listItems[iSelectedIndex].btn.Select();
					}
					break;
				case eHandKeyEvent.LEFT:
					if (--iSelectedIndex < 0)
					{
						iSelectedIndex = 0;
					}
					if (iSelectedIndex >= 0)
					{
						listItems[iSelectedIndex].btn.Select();
					}
					break;
				case eHandKeyEvent.RIGHT:
					if (++iSelectedIndex > listItems.Count - 1)
					{
						iSelectedIndex = listItems.Count - 1;
					}
					if (iSelectedIndex >= 0)
					{
						listItems[iSelectedIndex].btn.Select();
					}
					break;
				case eHandKeyEvent.Comfirm:
					if (iSelectedIndex >= 0)
					{
						listItems[iSelectedIndex].btn.onClick.Invoke();
					}
					break;
				case eHandKeyEvent.Menu:
					MenuPanelManager.ClosePanel(this);
					break;
				}
				if (enumerator != null)
				{
					Inst.StopCoroutine(enumerator);
				}
				enumerator = Inst.StartCoroutine(scrolltoview(1f - (float)Mathf.FloorToInt(iSelectedIndex / iColumnNum) * 1f / (float)(listItems.Count / iColumnNum - 1)));
			}

			private IEnumerator scrolltoview(float value)
			{
				float diff = value - scrollCtrl.value;
				if (diff != 0f)
				{
					float step = 15f;
					int i = 0;
					while ((float)i < step)
					{
						scrollCtrl.value += diff / step;
						yield return new WaitForFixedUpdate();
						int num = i + 1;
						i = num;
					}
				}
			}

			public void OnFocus()
			{
				if (listItems.Count > 0 && iSelectedIndex >= 0)
				{
					listItems[iSelectedIndex].btn.Select();
				}
			}
		}

		[Serializable]
		public class TaskListDefine : cMenuPanel
		{
			public class btnDefine
			{
				public string id;

				public Button btn;

				public LT_Task.Task Info;
			}

			public GameObject panelContent;

			public Button prefabBtn;

			private Scrollbar scrollCtrl;

			private List<btnDefine> listItems = new List<btnDefine>();

			public Text TextEmptyTip;

			private int iSelectedIndex;

			private Coroutine enumerator;

			public void Init()
			{
				Transform parent = prefabBtn.transform.parent;
				prefabBtn.gameObject.SetActive(value: false);
				for (int num = parent.childCount - 1; num >= 0; num--)
				{
					if (!(prefabBtn.transform == parent.GetChild(num)))
					{
						UnityEngine.Object.Destroy(parent.GetChild(num).gameObject);
					}
				}
				scrollCtrl = panelContent.GetComponentInChildren<Scrollbar>();
				panelContent.SetActive(value: false);
				TaskManager.onChange = (Action)Delegate.Combine(TaskManager.onChange, new Action(J_RefreshUI));
			}

			public void J_RefreshUI()
			{
				UnityEngine.Debug.LogWarning("--refresh任务列表 UI");
				int num = 1;
				foreach (LT_Task.Task value in TaskManager.m_listTasks.Values)
				{
					btnDefine btnDefine = null;
					for (int i = 0; i < listItems.Count; i++)
					{
						if (listItems[i].id == value.taskID)
						{
							btnDefine = listItems[i];
							break;
						}
					}
					if (prefabBtn == null)
					{
						prefabBtn = Resources.Load<Button>("prefabBtn");
					}
					if ((btnDefine == null || btnDefine.btn == null) && prefabBtn != null)
					{
						GameObject gameObject = UnityEngine.Object.Instantiate(prefabBtn.gameObject);
						gameObject.transform.SetParent(prefabBtn.transform.parent);
						gameObject.transform.localPosition = Vector3.zero;
						gameObject.transform.localEulerAngles = Vector3.zero;
						gameObject.transform.localScale = Vector3.one;
						gameObject.gameObject.SetActive(value: true);
						btnDefine = new btnDefine();
						btnDefine.id = value.taskID;
						btnDefine.Info = value;
						btnDefine.btn = gameObject.GetComponent<Button>();
						listItems.Add(btnDefine);
					}
					btnDefine.btn.transform.Find("TextDes").GetComponent<Text>().text = num + "、" + btnDefine.Info.description;
					Text component = btnDefine.btn.transform.Find("TextComplete").GetComponent<Text>();
					if (value.isComplete)
					{
						component.text = "完成";
						component.color = Color.green;
					}
					else
					{
						component.text = "未完成";
						component.color = Color.yellow;
					}
					num++;
				}
			}

			public void Open()
			{
				panelContent.SetActive(value: true);
				if (listItems.Count > 0)
				{
					listItems[0].btn.Select();
					TextEmptyTip.gameObject.SetActive(value: false);
				}
				else
				{
					TextEmptyTip.gameObject.SetActive(value: true);
				}
			}

			public void Close()
			{
				panelContent.SetActive(value: false);
			}

			public void OnFocus()
			{
			}

			public void OnHandKeyEvent(eHandKeyEvent keyEvent)
			{
				switch (keyEvent)
				{
				case eHandKeyEvent.UP:
				case eHandKeyEvent.LEFT:
					if (--iSelectedIndex < 0)
					{
						iSelectedIndex = listItems.Count - 1;
					}
					listItems[iSelectedIndex].btn.Select();
					if (enumerator != null)
					{
						Inst.StopCoroutine(enumerator);
					}
					enumerator = Inst.StartCoroutine(scrolltoview(1f - (float)iSelectedIndex * 1f / (float)(listItems.Count - 1)));
					break;
				case eHandKeyEvent.DOWN:
				case eHandKeyEvent.RIGHT:
					if (++iSelectedIndex > listItems.Count - 1)
					{
						iSelectedIndex = 0;
					}
					listItems[iSelectedIndex].btn.Select();
					if (enumerator != null)
					{
						Inst.StopCoroutine(enumerator);
					}
					enumerator = Inst.StartCoroutine(scrolltoview(1f - (float)iSelectedIndex * 1f / (float)(listItems.Count - 1)));
					break;
				case eHandKeyEvent.Menu:
					MenuPanelManager.ClosePanel(this);
					break;
				case eHandKeyEvent.Comfirm:
					break;
				}
			}

			private IEnumerator scrolltoview(float value)
			{
				float diff = value - scrollCtrl.value;
				if (diff != 0f)
				{
					float step = 15f;
					int i = 0;
					while ((float)i < step)
					{
						scrollCtrl.value += diff / step;
						yield return new WaitForFixedUpdate();
						int num = i + 1;
						i = num;
					}
				}
			}
		}

		[Serializable]
		public class SettingDefine : cMenuPanel
		{
			public GameObject panelContent;

			public List<Button> listItems;

			private int iSelectedIndex;

			public void Init()
			{
				panelContent.SetActive(value: false);
			}

			public void Open()
			{
				panelContent.SetActive(value: true);
				if (listItems.Count > 0)
				{
					listItems[0].Select();
				}
			}

			public void Close()
			{
				panelContent.SetActive(value: false);
			}

			public void OnFocus()
			{
			}

			public void OnHandKeyEvent(eHandKeyEvent keyEvent)
			{
				switch (keyEvent)
				{
				case eHandKeyEvent.UP:
				case eHandKeyEvent.LEFT:
					if (--iSelectedIndex < 0)
					{
						iSelectedIndex = listItems.Count - 1;
					}
					listItems[iSelectedIndex].Select();
					break;
				case eHandKeyEvent.DOWN:
				case eHandKeyEvent.RIGHT:
					if (++iSelectedIndex > listItems.Count - 1)
					{
						iSelectedIndex = 0;
					}
					listItems[iSelectedIndex].Select();
					break;
				case eHandKeyEvent.Comfirm:
					listItems[iSelectedIndex].onClick.Invoke();
					break;
				case eHandKeyEvent.Menu:
					MenuPanelManager.ClosePanel(this);
					break;
				}
			}
		}

		public static C_HandPadMenu Inst;

		public static bool m_isHandMenuOn;

		public GameObject original;

		public Transform watchModelOriginal;

		public MainOptionsDefine mainOptions;

		public AudioSource audioDIDI;

		public GameObject objtipDDI;

		private bool isWatchingTiping;

		private Tweener tweener;

		private bool gui0;

		private bool ispadtrydown;

		private void Start()
		{
			Inst = this;
			mainOptions.Init();
			objtipDDI.SetActive(value: false);
			TaskManager.onMissionComplete = (Action)Delegate.Combine(TaskManager.onMissionComplete, new Action(J_WatchTipDIDI));
			base.gameObject.SetActive(value: false);
		}

		private void J_WatchTipDIDI()
		{
			audioDIDI.Play();
			objtipDDI.SetActive(value: true);
		}

		private void DoMenuUIAnim(bool isShow, Action callback)
		{
			if (tweener != null)
			{
				tweener.Kill();
			}
			if (isShow)
			{
				tweener = original.transform.DOScale(1f, 0.6f).OnComplete(delegate
				{
					callback();
				});
			}
			else
			{
				tweener = original.transform.DOScale(0f, 0.6f).OnComplete(delegate
				{
					callback();
				});
			}
		}

		private void Update22()
		{
			if (!m_isHandMenuOn)
			{
				if (Controller.UPvr_GetKeyUp(Pvr_ControllerManager.controllerlink.mainHandID, Pvr_KeyCode.APP))
				{
					m_isHandMenuOn = true;
					WaveVRHead.Inst.J_OnHandMenuChange(isOn: true);
					original.SetActive(value: true);
					DoMenuUIAnim(isShow: true, null);
					MenuPanelManager.ShowPanel(mainOptions);
					if (objtipDDI.activeInHierarchy)
					{
						mainOptions.m_btnTaskList.onClick.Invoke();
						objtipDDI.gameObject.SetActive(value: false);
					}
				}
				return;
			}
			ispadtrydown = false;
			Vector2 vector = Controller.UPvr_GetAxis2D(Pvr_ControllerManager.controllerlink.mainHandID);
			float num = 0.75f;
			int num2 = 0;
			if (Math.Abs(vector.x) >= num)
			{
				if (gui0)
				{
					num2 = ((vector.x > 0f) ? 4 : 3);
				}
				gui0 = false;
			}
			else if (Math.Abs(vector.y) >= num)
			{
				if (gui0)
				{
					num2 = ((vector.y > 0f) ? 1 : 2);
				}
				gui0 = false;
			}
			else
			{
				gui0 = true;
			}
			if (num2 == 1 || Input.GetKeyUp(KeyCode.UpArrow))
			{
				ispadtrydown = true;
				MenuPanelManager.SendKeyEvent(eHandKeyEvent.UP);
			}
			if (num2 == 2 || Input.GetKeyUp(KeyCode.DownArrow))
			{
				ispadtrydown = true;
				MenuPanelManager.SendKeyEvent(eHandKeyEvent.DOWN);
			}
			if (num2 == 3 || Input.GetKeyUp(KeyCode.LeftArrow))
			{
				ispadtrydown = true;
				MenuPanelManager.SendKeyEvent(eHandKeyEvent.LEFT);
			}
			if (num2 == 4 || Input.GetKeyUp(KeyCode.RightArrow))
			{
				ispadtrydown = true;
				MenuPanelManager.SendKeyEvent(eHandKeyEvent.RIGHT);
			}
			if (Controller.UPvr_GetKeyDown(Pvr_ControllerManager.controllerlink.mainHandID, Pvr_KeyCode.X) || Input.GetKeyUp(KeyCode.A))
			{
				MenuPanelManager.SendKeyEvent(eHandKeyEvent.Comfirm);
			}
			if (Controller.UPvr_GetKeyDown(Pvr_ControllerManager.controllerlink.mainHandID, Pvr_KeyCode.APP) || Input.GetKeyUp(KeyCode.Escape))
			{
				MenuPanelManager.SendKeyEvent(eHandKeyEvent.Menu);
			}
		}

		public void J_QuitAPP()
		{
			UnityEngine.Object.Destroy(WaveVRHead.Inst.gameObject);
			WaveVRHead.Inst = null;
			SceneManager.LoadScene("2_MainStart");
		}
	}
	public static class MenuPanelManager
	{
		private static List<cMenuPanel> showedPanels = new List<cMenuPanel>();

		public static void ShowPanel(cMenuPanel panel)
		{
			showedPanels.Add(panel);
			panel.Open();
			panel.OnFocus();
		}

		public static void ClosePanel(cMenuPanel panel)
		{
			panel.Close();
			showedPanels.Remove(panel);
			if (showedPanels.Count > 0)
			{
				showedPanels[showedPanels.Count - 1].OnFocus();
			}
		}

		public static void SendKeyEvent(eHandKeyEvent keyEvent)
		{
			if (showedPanels.Count > 0)
			{
				showedPanels[showedPanels.Count - 1].OnHandKeyEvent(keyEvent);
			}
		}
	}
	public interface cMenuPanel
	{
		void OnFocus();

		void Open();

		void Close();

		void OnHandKeyEvent(eHandKeyEvent keyEvent);
	}
	public enum eHandKeyEvent
	{
		UP,
		DOWN,
		LEFT,
		RIGHT,
		Comfirm,
		Menu
	}
}
namespace Valve.VR.InteractionSystem
{
	public class VelocityEstimator : MonoBehaviour
	{
		[Tooltip("How many frames to average over for computing velocity")]
		public int velocityAverageFrames = 5;

		[Tooltip("How many frames to average over for computing angular velocity")]
		public int angularVelocityAverageFrames = 11;

		public bool estimateOnAwake;

		private Coroutine routine;

		private int sampleCount;

		private Vector3[] velocitySamples;

		private Vector3[] angularVelocitySamples;

		public void BeginEstimatingVelocity()
		{
			FinishEstimatingVelocity();
			routine = StartCoroutine(EstimateVelocityCoroutine());
		}

		public void FinishEstimatingVelocity()
		{
			if (routine != null)
			{
				StopCoroutine(routine);
				routine = null;
			}
		}

		public Vector3 GetVelocityEstimate()
		{
			Vector3 zero = Vector3.zero;
			int num = Mathf.Min(sampleCount, velocitySamples.Length);
			if (num != 0)
			{
				for (int i = 0; i < num; i++)
				{
					zero += velocitySamples[i];
				}
				zero *= 1f / (float)num;
			}
			return zero;
		}

		public Vector3 GetAngularVelocityEstimate()
		{
			Vector3 zero = Vector3.zero;
			int num = Mathf.Min(sampleCount, angularVelocitySamples.Length);
			if (num != 0)
			{
				for (int i = 0; i < num; i++)
				{
					zero += angularVelocitySamples[i];
				}
				zero *= 1f / (float)num;
			}
			return zero;
		}

		public Vector3 GetAccelerationEstimate()
		{
			Vector3 zero = Vector3.zero;
			for (int i = 2 + sampleCount - velocitySamples.Length; i < sampleCount; i++)
			{
				if (i >= 2)
				{
					int num = i - 2;
					int num2 = i - 1;
					Vector3 vector = velocitySamples[num % velocitySamples.Length];
					Vector3 vector2 = velocitySamples[num2 % velocitySamples.Length];
					zero += vector2 - vector;
				}
			}
			return zero * (1f / Time.deltaTime);
		}

		private void Awake()
		{
			velocitySamples = new Vector3[velocityAverageFrames];
			angularVelocitySamples = new Vector3[angularVelocityAverageFrames];
			if (estimateOnAwake)
			{
				BeginEstimatingVelocity();
			}
		}

		private IEnumerator EstimateVelocityCoroutine()
		{
			sampleCount = 0;
			Vector3 previousPosition = base.transform.position;
			Quaternion previousRotation = base.transform.rotation;
			while (true)
			{
				yield return new WaitForEndOfFrame();
				float num = 1f / Time.deltaTime;
				int num2 = sampleCount % velocitySamples.Length;
				int num3 = sampleCount % angularVelocitySamples.Length;
				sampleCount++;
				velocitySamples[num2] = num * (base.transform.position - previousPosition);
				Quaternion quaternion = base.transform.rotation * Quaternion.Inverse(previousRotation);
				float num4 = 2f * Mathf.Acos(Mathf.Clamp(quaternion.w, -1f, 1f));
				if (num4 > (float)Math.PI)
				{
					num4 -= (float)Math.PI * 2f;
				}
				Vector3 vector = new Vector3(quaternion.x, quaternion.y, quaternion.z);
				if (vector.sqrMagnitude > 0f)
				{
					vector = num4 * num * vector.normalized;
				}
				angularVelocitySamples[num3] = vector;
				previousPosition = base.transform.position;
				previousRotation = base.transform.rotation;
			}
		}
	}
}
namespace VRTK.Examples
{
	public class BeamRotator : MonoBehaviour
	{
		[Tooltip("Amount of degrees to rotate around the rotation axis per second.")]
		public float degreesPerSecond = 60f;

		[Tooltip("The rotation axis to rotate the object around.")]
		public Vector3 rotationAxis = Vector3.up;

		protected virtual void OnEnable()
		{
			rotationAxis.Normalize();
		}

		protected virtual void Update()
		{
			base.transform.Rotate(rotationAxis, degreesPerSecond * Time.deltaTime);
		}
	}
}
namespace agora_gaming_rtc
{
	public delegate void OnJoinChannelSuccessHandler(string channelName, uint uid, int elapsed);
	public delegate void OnLeaveChannelHandler(RtcStats stats);
	public delegate void OnReJoinChannelSuccessHandler(string channelName, uint uid, int elapsed);
	public delegate void OnConnectionLostHandler();
	public delegate void OnConnectionInterruptedHandler();
	public delegate void OnRequestTokenHandler();
	public delegate void OnUserJoinedHandler(uint uid, int elapsed);
	public delegate void OnUserOfflineHandler(uint uid, USER_OFFLINE_REASON reason);
	public delegate void OnVolumeIndicationHandler(AudioVolumeInfo[] speakers, int speakerNumber, int totalVolume);
	public delegate void OnUserMutedAudioHandler(uint uid, bool muted);
	public delegate void OnSDKWarningHandler(int warn, string msg);
	public delegate void OnSDKErrorHandler(int error, string msg);
	public delegate void OnRtcStatsHandler(RtcStats stats);
	public delegate void OnAudioMixingFinishedHandler();
	public delegate void OnAudioRouteChangedHandler(AUDIO_ROUTE route);
	public delegate void OnFirstRemoteVideoDecodedHandler(uint uid, int width, int height, int elapsed);
	public delegate void OnVideoSizeChangedHandler(uint uid, int width, int height, int rotation);
	public delegate void OnClientRoleChangedHandler(CLIENT_ROLE_TYPE oldRole, CLIENT_ROLE_TYPE newRole);
	public delegate void OnUserMuteVideoHandler(uint uid, bool muted);
	public delegate void OnMicrophoneEnabledHandler(bool isEnabled);
	public delegate void OnApiExecutedHandler(int err, string api, string result);
	public delegate void OnLastmileQualityHandler(int quality);
	public delegate void OnFirstLocalAudioFrameHandler(int elapsed);
	public delegate void OnFirstRemoteAudioFrameHandler(uint userId, int elapsed);
	public delegate void OnAudioQualityHandler(uint userId, int quality, ushort delay, ushort lost);
	public delegate void OnStreamInjectedStatusHandler(string url, uint userId, int status);
	public delegate void OnStreamUnpublishedHandler(string url);
	public delegate void OnStreamPublishedHandler(string url, int error);
	public delegate void OnStreamMessageErrorHandler(uint userId, int streamId, int code, int missed, int cached);
	public delegate void OnStreamMessageHandler(uint userId, int streamId, byte[] data, int length);
	public delegate void OnConnectionBannedHandler();
	public delegate void OnConnectionStateChangedHandler(CONNECTION_STATE_TYPE state, CONNECTION_CHANGED_REASON_TYPE reason);
	public delegate void OnTokenPrivilegeWillExpireHandler(string token);
	public delegate void OnActiveSpeakerHandler(uint uid);
	public delegate void OnVideoStoppedHandler();
	public delegate void OnFirstLocalVideoFrameHandler(int width, int height, int elapsed);
	public delegate void OnFirstRemoteVideoFrameHandler(uint uid, int width, int height, int elapsed);
	public delegate void OnUserEnableVideoHandler(uint uid, bool enabled);
	public delegate void OnUserEnableLocalVideoHandler(uint uid, bool enabled);
	public delegate void OnRemoteVideoStateChangedHandler(uint uid, REMOTE_VIDEO_STATE state, REMOTE_VIDEO_STATE_REASON reason, int elapsed);
	public delegate void OnLocalPublishFallbackToAudioOnlyHandler(bool isFallbackOrRecover);
	public delegate void OnRemoteSubscribeFallbackToAudioOnlyHandler(uint uid, bool isFallbackOrRecover);
	public delegate void OnNetworkQualityHandler(uint uid, int txQuality, int rxQuality);
	public delegate void OnLocalVideoStatsHandler(LocalVideoStats localVideoStats);
	public delegate void OnRemoteVideoStatsHandler(RemoteVideoStats remoteVideoStats);
	public delegate void OnRemoteAudioStatsHandler(RemoteAudioStats remoteAudioStats);
	public delegate void OnAudioDeviceStateChangedHandler(string deviceId, int deviceType, int deviceState);
	public delegate void OnCameraReadyHandler();
	public delegate void OnCameraFocusAreaChangedHandler(int x, int y, int width, int height);
	public delegate void OnCameraExposureAreaChangedHandler(int x, int y, int width, int height);
	public delegate void OnRemoteAudioMixingBeginHandler();
	public delegate void OnRemoteAudioMixingEndHandler();
	public delegate void OnAudioEffectFinishedHandler(int soundId);
	public delegate void OnVideoDeviceStateChangedHandler(string deviceId, int deviceType, int deviceState);
	public delegate void OnRemoteVideoTransportStatsHandler(uint uid, ushort delay, ushort lost, ushort rxKBitRate);
	public delegate void OnRemoteAudioTransportStatsHandler(uint uid, ushort delay, ushort lost, ushort rxKBitRate);
	public delegate void OnTranscodingUpdatedHandler();
	public delegate void OnAudioDeviceVolumeChangedHandler(MEDIA_DEVICE_TYPE deviceType, int volume, bool muted);
	public delegate void OnMediaEngineStartCallSuccessHandler();
	public delegate void OnMediaEngineLoadSuccessHandler();
	public delegate void OnAudioMixingStateChangedHandler(AUDIO_MIXING_STATE_TYPE state, AUDIO_MIXING_ERROR_TYPE errorCode);
	public delegate void OnFirstRemoteAudioDecodedHandler(uint uid, int elapsed);
	public delegate void OnLocalVideoStateChangedHandler(LOCAL_VIDEO_STREAM_STATE localVideoState, LOCAL_VIDEO_STREAM_ERROR error);
	public delegate void OnRtmpStreamingStateChangedHandler(string url, RTMP_STREAM_PUBLISH_STATE state, RTMP_STREAM_PUBLISH_ERROR errCode);
	public delegate void OnNetworkTypeChangedHandler(NETWORK_TYPE type);
	public delegate void OnLastmileProbeResultHandler(LastmileProbeResult result);
	public delegate void OnLocalUserRegisteredHandler(uint uid, string userAccount);
	public delegate void OnUserInfoUpdatedHandler(uint uid, UserInfo userInfo);
	public delegate void OnLocalAudioStateChangedHandler(LOCAL_AUDIO_STREAM_STATE state, LOCAL_AUDIO_STREAM_ERROR error);
	public delegate void OnRemoteAudioStateChangedHandler(uint uid, REMOTE_AUDIO_STATE state, REMOTE_AUDIO_STATE_REASON reason, int elapsed);
	public delegate void OnLocalAudioStatsHandler(LocalAudioStats localAudioStats);
	public delegate void OnChannelMediaRelayStateChangedHandler(CHANNEL_MEDIA_RELAY_STATE state, CHANNEL_MEDIA_RELAY_ERROR code);
	public delegate void OnChannelMediaRelayEventHandler(CHANNEL_MEDIA_RELAY_EVENT events);
	public delegate void OnFacePositionChangedHandler(int imageWidth, int imageHeight, Rectangle vecRectangle, int vecDistance, int numFaces);
	public sealed class AgoraChannel : IRtcEngineNative
	{
		private static Dictionary<string, AgoraChannel> _channelDictionary = new Dictionary<string, AgoraChannel>();

		private static Dictionary<string, AgoraCallbackObject> _AgoraCallbackObjectDictionary = new Dictionary<string, AgoraCallbackObject>();

		private IntPtr _channelHandler = IntPtr.Zero;

		private string _channelId;

		private string agoraChannelCallbackName = "agoraChannelGameObject";

		private IRtcEngine _rtcEngine;

		public ChannelOnWarningHandler ChannelOnWarning;

		public ChannelOnErrorHandler ChannelOnError;

		public ChannelOnJoinChannelSuccessHandler ChannelOnJoinChannelSuccess;

		public ChannelOnReJoinChannelSuccessHandler ChannelOnReJoinChannelSuccess;

		public ChannelOnLeaveChannelHandler ChannelOnLeaveChannel;

		public ChannelOnClientRoleChangedHandler ChannelOnClientRoleChanged;

		public ChannelOnUserJoinedHandler ChannelOnUserJoined;

		public ChannelOnUserOffLineHandler ChannelOnUserOffLine;

		public ChannelOnConnectionLostHandler ChannelOnConnectionLost;

		public ChannelOnRequestTokenHandler ChannelOnRequestToken;

		public ChannelOnTokenPrivilegeWillExpireHandler ChannelOnTokenPrivilegeWillExpire;

		public ChannelOnRtcStatsHandler ChannelOnRtcStats;

		public ChannelOnNetworkQualityHandler ChannelOnNetworkQuality;

		public ChannelOnRemoteVideoStatsHandler ChannelOnRemoteVideoStats;

		public ChannelOnRemoteAudioStatsHandler ChannelOnRemoteAudioStats;

		public ChannelOnRemoteAudioStateChangedHandler ChannelOnRemoteAudioStateChanged;

		public ChannelOnActiveSpeakerHandler ChannelOnActiveSpeaker;

		public ChannelOnVideoSizeChangedHandler ChannelOnVideoSizeChanged;

		public ChannelOnRemoteVideoStateChangedHandler ChannelOnRemoteVideoStateChanged;

		public ChannelOnStreamMessageHandler ChannelOnStreamMessage;

		public ChannelOnStreamMessageErrorHandler ChannelOnStreamMessageError;

		public ChannelOnMediaRelayStateChangedHandler ChannelOnMediaRelayStateChanged;

		public ChannelOnMediaRelayEventHandler ChannelOnMediaRelayEvent;

		public ChannelOnRtmpStreamingStateChangedHandler ChannelOnRtmpStreamingStateChanged;

		public ChannelOnTranscodingUpdatedHandler ChannelOnTranscodingUpdated;

		public ChannelOnStreamInjectedStatusHandler ChannelOnStreamInjectedStatus;

		public ChannelOnRemoteSubscribeFallbackToAudioOnlyHandler ChannelOnRemoteSubscribeFallbackToAudioOnly;

		public ChannelOnConnectionStateChangedHandler ChannelOnConnectionStateChanged;

		public ChannelOnLocalPublishFallbackToAudioOnlyHandler ChannelOnLocalPublishFallbackToAudioOnly;

		public static AgoraChannel CreateChannel(IRtcEngine rtcEngine, string channelId)
		{
			if (_channelDictionary.ContainsKey(channelId))
			{
				return _channelDictionary[channelId];
			}
			return new AgoraChannel(rtcEngine, channelId);
		}

		public AgoraChannel(IRtcEngine rtcEngine, string channelId)
		{
			_channelId = channelId;
			InitGameObject(agoraChannelCallbackName + channelId, channelId);
			_rtcEngine = rtcEngine;
			CreateChannelNative(channelId);
			_channelDictionary.Add(_channelId, this);
			initChannelEvent();
		}

		private void InitGameObject(string objectName, string channelId)
		{
			DeInitGameObject(objectName, channelId);
			AgoraCallbackObject value = new AgoraCallbackObject(objectName);
			_AgoraCallbackObjectDictionary.Add(channelId, value);
		}

		private void DeInitGameObject(string objectName, string channelId)
		{
			if (_AgoraCallbackObjectDictionary.ContainsKey(channelId))
			{
				AgoraCallbackObject agoraCallbackObject = _AgoraCallbackObjectDictionary[channelId];
				if (agoraCallbackObject != null)
				{
					agoraCallbackObject.Release();
					_AgoraCallbackObjectDictionary.Remove(channelId);
					agoraCallbackObject = null;
				}
			}
		}

		private int CreateChannelNative(string channelId)
		{
			if (_rtcEngine == null)
			{
				return -7;
			}
			_channelHandler = IRtcEngineNative.createChannel(channelId);
			return 0;
		}

		public int ReleaseChannel()
		{
			if (_rtcEngine == null)
			{
				return -7;
			}
			int result = IRtcEngineNative.ReleaseChannel(_channelHandler);
			if (_channelDictionary.ContainsKey(_channelId))
			{
				_channelDictionary.Remove(_channelId);
			}
			_channelHandler = IntPtr.Zero;
			DeInitGameObject(agoraChannelCallbackName + _channelId, _channelId);
			ReleaseCallback();
			return result;
		}

		private void ReleaseCallback()
		{
			_rtcEngine = null;
			_channelId = null;
			ChannelOnWarning = null;
			ChannelOnError = null;
			ChannelOnJoinChannelSuccess = null;
			ChannelOnReJoinChannelSuccess = null;
			ChannelOnLeaveChannel = null;
			ChannelOnClientRoleChanged = null;
			ChannelOnUserJoined = null;
			ChannelOnUserOffLine = null;
			ChannelOnConnectionLost = null;
			ChannelOnRequestToken = null;
			ChannelOnTokenPrivilegeWillExpire = null;
			ChannelOnRtcStats = null;
			ChannelOnNetworkQuality = null;
			ChannelOnRemoteVideoStats = null;
			ChannelOnRemoteAudioStats = null;
			ChannelOnRemoteAudioStateChanged = null;
			ChannelOnActiveSpeaker = null;
			ChannelOnVideoSizeChanged = null;
			ChannelOnRemoteVideoStateChanged = null;
			ChannelOnStreamMessage = null;
			ChannelOnStreamMessageError = null;
			ChannelOnMediaRelayStateChanged = null;
			ChannelOnMediaRelayEvent = null;
			ChannelOnRtmpStreamingStateChanged = null;
			ChannelOnTranscodingUpdated = null;
			ChannelOnStreamInjectedStatus = null;
			ChannelOnRemoteSubscribeFallbackToAudioOnly = null;
			ChannelOnConnectionStateChanged = null;
			ChannelOnLocalPublishFallbackToAudioOnly = null;
		}

		public static int Release()
		{
			_channelDictionary.Clear();
			return 0;
		}

		public int JoinChannel(string token, string info, uint uid, ChannelMediaOptions channelMediaOptions)
		{
			if (_rtcEngine == null)
			{
				return -7;
			}
			return IRtcEngineNative.joinChannel2(_channelHandler, token, info, uid, channelMediaOptions.autoSubscribeAudio, channelMediaOptions.autoSubscribeVideo);
		}

		public int JoinChannelWithUserAccount(string token, string userAccount, ChannelMediaOptions channelMediaOptions)
		{
			if (_rtcEngine == null)
			{
				return -7;
			}
			return IRtcEngineNative.joinChannelWithUserAccount2(_channelHandler, token, userAccount, channelMediaOptions.autoSubscribeAudio, channelMediaOptions.autoSubscribeVideo);
		}

		public int LeaveChannel()
		{
			if (_rtcEngine == null)
			{
				return -7;
			}
			return IRtcEngineNative.leaveChannel2(_channelHandler);
		}

		public int Publish()
		{
			if (_rtcEngine == null)
			{
				return -7;
			}
			return IRtcEngineNative.publish(_channelHandler);
		}

		public int Unpublish()
		{
			if (_rtcEngine == null)
			{
				return -7;
			}
			return IRtcEngineNative.unpublish(_channelHandler);
		}

		public string ChannelId()
		{
			if (_rtcEngine == null)
			{
				return string.Concat(ERROR_CODE.ERROR_NOT_INIT_ENGINE);
			}
			return Marshal.PtrToStringAnsi(IRtcEngineNative.channelId(_channelHandler));
		}

		public string GetCallId()
		{
			if (_rtcEngine == null)
			{
				return string.Concat(ERROR_CODE.ERROR_NOT_INIT_ENGINE);
			}
			string result = "";
			IntPtr callId = IRtcEngineNative.getCallId2(_channelHandler);
			if (callId != IntPtr.Zero)
			{
				result = Marshal.PtrToStringAnsi(callId);
				IRtcEngineNative.freeObject(callId);
			}
			return result;
		}

		public int RenewToken(string token)
		{
			if (_rtcEngine == null)
			{
				return -7;
			}
			return IRtcEngineNative.renewToken2(_channelHandler, token);
		}

		public int SetEncryptionSecret(string secret)
		{
			if (_rtcEngine == null)
			{
				return -7;
			}
			return IRtcEngineNative.setEncryptionSecret2(_channelHandler, secret);
		}

		public int SetEncryptionMode(string encryptionMode)
		{
			if (_rtcEngine == null)
			{
				return -7;
			}
			return IRtcEngineNative.setEncryptionMode2(_channelHandler, encryptionMode);
		}

		public int SetClientRole(CLIENT_ROLE_TYPE role)
		{
			if (_rtcEngine == null)
			{
				return -7;
			}
			return IRtcEngineNative.setClientRole2(_channelHandler, (int)role);
		}

		public int SetRemoteUserPriority(uint uid, PRIORITY_TYPE userPriority)
		{
			if (_rtcEngine == null)
			{
				return -7;
			}
			return IRtcEngineNative.setRemoteUserPriority2(_channelHandler, uid, (int)userPriority);
		}

		public int SetRemoteVoicePosition(uint uid, double pan, double gain)
		{
			if (_rtcEngine == null)
			{
				return -7;
			}
			return IRtcEngineNative.setRemoteVoicePosition2(_channelHandler, uid, pan, gain);
		}

		public int SetRemoteRenderMode(uint userId, int renderMode, int mirrorMode)
		{
			if (_rtcEngine == null)
			{
				return -7;
			}
			return IRtcEngineNative.setRemoteRenderMode2(_channelHandler, userId, renderMode, mirrorMode);
		}

		public int SetDefaultMuteAllRemoteAudioStreams(bool mute)
		{
			if (_rtcEngine == null)
			{
				return -7;
			}
			return IRtcEngineNative.setDefaultMuteAllRemoteAudioStreams2(_channelHandler, mute);
		}

		public int SetDefaultMuteAllRemoteVideoStreams(bool mute)
		{
			if (_rtcEngine == null)
			{
				return -7;
			}
			return IRtcEngineNative.setDefaultMuteAllRemoteVideoStreams2(_channelHandler, mute);
		}

		public int MuteAllRemoteAudioStreams(bool mute)
		{
			if (_rtcEngine == null)
			{
				return -7;
			}
			return IRtcEngineNative.muteAllRemoteAudioStreams2(_channelHandler, mute);
		}

		public int AdjustUserPlaybackSignalVolume(uint userId, int volume)
		{
			if (_rtcEngine == null)
			{
				return -7;
			}
			return IRtcEngineNative.adjustUserPlaybackSignalVolume2(_channelHandler, userId, volume);
		}

		public int MuteRemoteAudioStream(uint userId, bool mute)
		{
			if (_rtcEngine == null)
			{
				return -7;
			}
			return IRtcEngineNative.muteRemoteAudioStream2(_channelHandler, userId, mute);
		}

		public int MuteAllRemoteVideoStreams(bool mute)
		{
			if (_rtcEngine == null)
			{
				return -7;
			}
			return IRtcEngineNative.muteAllRemoteVideoStreams2(_channelHandler, mute);
		}

		public int MuteRemoteVideoStream(uint userId, bool mute)
		{
			if (_rtcEngine == null)
			{
				return -7;
			}
			return IRtcEngineNative.muteRemoteVideoStream2(_channelHandler, userId, mute);
		}

		public int SetRemoteVideoStreamType(uint userId, REMOTE_VIDEO_STREAM_TYPE streamType)
		{
			if (_rtcEngine == null)
			{
				return -7;
			}
			return IRtcEngineNative.setRemoteVideoStreamType2(_channelHandler, userId, (int)streamType);
		}

		public int SetRemoteDefaultVideoStreamType(REMOTE_VIDEO_STREAM_TYPE streamType)
		{
			if (_rtcEngine == null)
			{
				return -7;
			}
			return IRtcEngineNative.setRemoteDefaultVideoStreamType2(_channelHandler, (int)streamType);
		}

		public int CreateDataStream(bool reliable, bool ordered)
		{
			if (_rtcEngine == null)
			{
				return -7;
			}
			return IRtcEngineNative.createDataStream2(_channelHandler, reliable, ordered);
		}

		public int SendStreamMessage(int streamId, string data, long length)
		{
			if (_rtcEngine == null)
			{
				return -7;
			}
			return IRtcEngineNative.sendStreamMessage2(_channelHandler, streamId, data, length);
		}

		public int AddPublishStreamUrl(string url, bool transcodingEnabled)
		{
			if (_rtcEngine == null)
			{
				return -7;
			}
			return IRtcEngineNative.addPublishStreamUrl2(_channelHandler, url, transcodingEnabled);
		}

		public int RemovePublishStreamUrl(string url)
		{
			if (_rtcEngine == null)
			{
				return -7;
			}
			return IRtcEngineNative.removePublishStreamUrl2(_channelHandler, url);
		}

		public int SetLiveTranscoding(LiveTranscoding liveTranscoding)
		{
			if (_rtcEngine == null)
			{
				return -7;
			}
			string text = "";
			if (liveTranscoding.userCount != 0 && liveTranscoding.transcodingUsers != null)
			{
				for (int i = 0; i < liveTranscoding.userCount; i++)
				{
					text += liveTranscoding.transcodingUsers[i].uid;
					text += "\t";
					text += liveTranscoding.transcodingUsers[i].x;
					text += "\t";
					text += liveTranscoding.transcodingUsers[i].y;
					text += "\t";
					text += liveTranscoding.transcodingUsers[i].width;
					text += "\t";
					text += liveTranscoding.transcodingUsers[i].height;
					text += "\t";
					text += liveTranscoding.transcodingUsers[i].zOrder;
					text += "\t";
					text += liveTranscoding.transcodingUsers[i].alpha;
					text += "\t";
					text += liveTranscoding.transcodingUsers[i].audioChannel;
					text += "\t";
				}
			}
			return IRtcEngineNative.setLiveTranscoding2(_channelHandler, liveTranscoding.width, liveTranscoding.height, liveTranscoding.videoBitrate, liveTranscoding.videoFramerate, liveTranscoding.lowLatency, liveTranscoding.videoGop, (int)liveTranscoding.videoCodecProfile, liveTranscoding.backgroundColor, liveTranscoding.userCount, text.ToString(), liveTranscoding.transcodingExtraInfo, liveTranscoding.metadata, liveTranscoding.watermark.url, liveTranscoding.watermark.x, liveTranscoding.watermark.y, liveTranscoding.watermark.width, liveTranscoding.watermark.height, liveTranscoding.backgroundImage.url, liveTranscoding.backgroundImage.x, liveTranscoding.backgroundImage.y, liveTranscoding.backgroundImage.width, liveTranscoding.backgroundImage.height, (int)liveTranscoding.audioSampleRate, liveTranscoding.audioBitrate, liveTranscoding.audioChannels, (int)liveTranscoding.audioCodecProfile);
		}

		public int AddInjectStreamUrl(string url, InjectStreamConfig config)
		{
			if (_rtcEngine == null)
			{
				return -7;
			}
			return IRtcEngineNative.addInjectStreamUrl2(_channelHandler, url, config.width, config.height, config.videoGop, config.videoFramerate, config.videoBitrate, (int)config.audioSampleRate, config.audioBitrate, config.audioChannels);
		}

		public int RemoveInjectStreamUrl(string url)
		{
			if (_rtcEngine == null)
			{
				return -7;
			}
			return IRtcEngineNative.removeInjectStreamUrl2(_channelHandler, url);
		}

		public int StartChannelMediaRelay(ChannelMediaRelayConfiguration channelMediaRelayConfiguration)
		{
			if (_rtcEngine == null)
			{
				return -7;
			}
			return IRtcEngineNative.startChannelMediaRelay2(_channelHandler, channelMediaRelayConfiguration.srcInfo.channelName, channelMediaRelayConfiguration.srcInfo.token, channelMediaRelayConfiguration.srcInfo.uid, channelMediaRelayConfiguration.destInfos.channelName, channelMediaRelayConfiguration.destInfos.token, channelMediaRelayConfiguration.destInfos.uid, channelMediaRelayConfiguration.destCount);
		}

		public int UpdateChannelMediaRelay(ChannelMediaRelayConfiguration channelMediaRelayConfiguration)
		{
			if (_rtcEngine == null)
			{
				return -7;
			}
			return IRtcEngineNative.updateChannelMediaRelay2(_channelHandler, channelMediaRelayConfiguration.srcInfo.channelName, channelMediaRelayConfiguration.srcInfo.token, channelMediaRelayConfiguration.srcInfo.uid, channelMediaRelayConfiguration.destInfos.channelName, channelMediaRelayConfiguration.destInfos.token, channelMediaRelayConfiguration.destInfos.uid, channelMediaRelayConfiguration.destCount);
		}

		public int StopChannelMediaRelay()
		{
			if (_rtcEngine == null)
			{
				return -7;
			}
			return IRtcEngineNative.stopChannelMediaRelay2(_channelHandler);
		}

		public CONNECTION_STATE_TYPE GetConnectionState()
		{
			if (_rtcEngine == null)
			{
				return CONNECTION_STATE_TYPE.CONNECTION_STATE_FAILED;
			}
			return (CONNECTION_STATE_TYPE)IRtcEngineNative.getConnectionState2(_channelHandler);
		}

		[MonoPInvokeCallback(typeof(ChannelOnWarningHandler))]
		private static void OnWarningCallback(string channelId, int warn, string message)
		{
			AgoraChannel channel = null;
			if (!_channelDictionary.ContainsKey(channelId))
			{
				return;
			}
			channel = _channelDictionary[channelId];
			if (channel == null || channel.ChannelOnWarning == null || _AgoraCallbackObjectDictionary[channelId] == null)
			{
				return;
			}
			AgoraCallbackQueue callbackQueue = _AgoraCallbackObjectDictionary[channelId]._CallbackQueue;
			if (!(callbackQueue != null))
			{
				return;
			}
			callbackQueue.EnQueue(delegate
			{
				if (_channelDictionary.ContainsKey(channelId))
				{
					AgoraChannel agoraChannel = _channelDictionary[channelId];
					if (agoraChannel != null && channel.ChannelOnWarning != null)
					{
						agoraChannel.ChannelOnWarning(channelId, warn, message);
					}
				}
			});
		}

		[MonoPInvokeCallback(typeof(ChannelOnErrorHandler))]
		private static void OnErrorCallback(string channelId, int err, string message)
		{
			AgoraChannel channel = null;
			if (!_channelDictionary.ContainsKey(channelId))
			{
				return;
			}
			channel = _channelDictionary[channelId];
			if (channel == null || channel.ChannelOnError == null || _AgoraCallbackObjectDictionary[channelId] == null)
			{
				return;
			}
			AgoraCallbackQueue callbackQueue = _AgoraCallbackObjectDictionary[channelId]._CallbackQueue;
			if (!(callbackQueue != null))
			{
				return;
			}
			callbackQueue.EnQueue(delegate
			{
				if (_channelDictionary.ContainsKey(channelId))
				{
					AgoraChannel agoraChannel = _channelDictionary[channelId];
					if (agoraChannel != null && channel.ChannelOnError != null)
					{
						agoraChannel.ChannelOnError(channelId, err, message);
					}
				}
			});
		}

		[MonoPInvokeCallback(typeof(ChannelOnJoinChannelSuccessHandler))]
		private static void OnJoinChannelSuccessCallback(string channelId, uint uid, int elapsed)
		{
			AgoraChannel channel = null;
			if (!_channelDictionary.ContainsKey(channelId))
			{
				return;
			}
			channel = _channelDictionary[channelId];
			if (channel == null || channel.ChannelOnJoinChannelSuccess == null || _AgoraCallbackObjectDictionary[channelId] == null)
			{
				return;
			}
			AgoraCallbackQueue callbackQueue = _AgoraCallbackObjectDictionary[channelId]._CallbackQueue;
			if (!(callbackQueue != null))
			{
				return;
			}
			callbackQueue.EnQueue(delegate
			{
				if (_channelDictionary.ContainsKey(channelId))
				{
					AgoraChannel agoraChannel = _channelDictionary[channelId];
					if (agoraChannel != null && channel.ChannelOnJoinChannelSuccess != null)
					{
						agoraChannel.ChannelOnJoinChannelSuccess(channelId, uid, elapsed);
					}
				}
			});
		}

		[MonoPInvokeCallback(typeof(ChannelOnReJoinChannelSuccessHandler))]
		private static void OnReJoinChannelSuccessCallback(string channelId, uint uid, int elapsed)
		{
			AgoraChannel channel = null;
			if (!_channelDictionary.ContainsKey(channelId))
			{
				return;
			}
			channel = _channelDictionary[channelId];
			if (channel == null || channel.ChannelOnReJoinChannelSuccess == null || _AgoraCallbackObjectDictionary[channelId] == null)
			{
				return;
			}
			AgoraCallbackQueue callbackQueue = _AgoraCallbackObjectDictionary[channelId]._CallbackQueue;
			if (!(callbackQueue != null))
			{
				return;
			}
			callbackQueue.EnQueue(delegate
			{
				if (_channelDictionary.ContainsKey(channelId))
				{
					AgoraChannel agoraChannel = _channelDictionary[channelId];
					if (agoraChannel != null && channel.ChannelOnReJoinChannelSuccess != null)
					{
						agoraChannel.ChannelOnJoinChannelSuccess(channelId, uid, elapsed);
					}
				}
			});
		}

		[MonoPInvokeCallback(typeof(ChannelEngineEventOnLeaveChannelHandler))]
		private static void OnLeaveChannelCallback(string channelId, uint duration, uint txBytes, uint rxBytes, uint txAudioBytes, uint txVideoBytes, uint rxAudioBytes, uint rxVideoBytes, ushort txKBitRate, ushort rxKBitRate, ushort rxAudioKBitRate, ushort txAudioKBitRate, ushort rxVideoKBitRate, ushort txVideoKBitRate, ushort lastmileDelay, ushort txPacketLossRate, ushort rxPacketLossRate, uint userCount, double cpuAppUsage, double cpuTotalUsage, int gatewayRtt, double memoryAppUsageRatio, double memoryTotalUsageRatio, int memoryAppUsageInKbytes)
		{
			AgoraChannel channel = null;
			if (!_channelDictionary.ContainsKey(channelId))
			{
				return;
			}
			channel = _channelDictionary[channelId];
			if (channel == null || channel.ChannelOnLeaveChannel == null || _AgoraCallbackObjectDictionary[channelId] == null)
			{
				return;
			}
			AgoraCallbackQueue callbackQueue = _AgoraCallbackObjectDictionary[channelId]._CallbackQueue;
			if (!(callbackQueue != null))
			{
				return;
			}
			callbackQueue.EnQueue(delegate
			{
				if (_channelDictionary.ContainsKey(channelId))
				{
					AgoraChannel agoraChannel = _channelDictionary[channelId];
					if (agoraChannel != null && channel.ChannelOnLeaveChannel != null)
					{
						RtcStats rtcStats = default(RtcStats);
						rtcStats.duration = duration;
						rtcStats.txBytes = txBytes;
						rtcStats.rxBytes = rxBytes;
						rtcStats.txAudioBytes = txAudioBytes;
						rtcStats.txVideoBytes = txVideoBytes;
						rtcStats.rxAudioBytes = rxAudioBytes;
						rtcStats.rxVideoBytes = rxVideoBytes;
						rtcStats.txKBitRate = txKBitRate;
						rtcStats.rxKBitRate = rxKBitRate;
						rtcStats.rxAudioKBitRate = rxAudioKBitRate;
						rtcStats.txAudioKBitRate = txAudioKBitRate;
						rtcStats.rxVideoKBitRate = rxVideoKBitRate;
						rtcStats.txVideoKBitRate = txVideoKBitRate;
						rtcStats.lastmileDelay = lastmileDelay;
						rtcStats.txPacketLossRate = txPacketLossRate;
						rtcStats.rxPacketLossRate = rxPacketLossRate;
						rtcStats.userCount = userCount;
						rtcStats.cpuAppUsage = cpuAppUsage;
						rtcStats.cpuTotalUsage = cpuTotalUsage;
						rtcStats.gatewayRtt = gatewayRtt;
						rtcStats.memoryAppUsageRatio = memoryAppUsageRatio;
						rtcStats.memoryTotalUsageRatio = memoryTotalUsageRatio;
						rtcStats.memoryAppUsageInKbytes = memoryAppUsageInKbytes;
						agoraChannel.ChannelOnLeaveChannel(channelId, rtcStats);
					}
				}
			});
		}

		[MonoPInvokeCallback(typeof(ChannelOnClientRoleChangedHandler))]
		private static void OnClientRoleChangedCallback(string channelId, CLIENT_ROLE_TYPE oldRole, CLIENT_ROLE_TYPE newRole)
		{
			AgoraChannel channel = null;
			if (!_channelDictionary.ContainsKey(channelId))
			{
				return;
			}
			channel = _channelDictionary[channelId];
			if (channel == null || channel.ChannelOnClientRoleChanged == null || _AgoraCallbackObjectDictionary[channelId] == null)
			{
				return;
			}
			AgoraCallbackQueue callbackQueue = _AgoraCallbackObjectDictionary[channelId]._CallbackQueue;
			if (!(callbackQueue != null))
			{
				return;
			}
			callbackQueue.EnQueue(delegate
			{
				if (_channelDictionary.ContainsKey(channelId))
				{
					AgoraChannel agoraChannel = _channelDictionary[channelId];
					if (agoraChannel != null && channel.ChannelOnClientRoleChanged != null)
					{
						agoraChannel.ChannelOnClientRoleChanged(channelId, oldRole, newRole);
					}
				}
			});
		}

		[MonoPInvokeCallback(typeof(ChannelOnUserJoinedHandler))]
		private static void OnUserJoinedCallback(string channelId, uint uid, int elapsed)
		{
			AgoraChannel channel = null;
			if (!_channelDictionary.ContainsKey(channelId))
			{
				return;
			}
			channel = _channelDictionary[channelId];
			if (channel == null || channel.ChannelOnUserJoined == null || _AgoraCallbackObjectDictionary[channelId] == null)
			{
				return;
			}
			AgoraCallbackQueue callbackQueue = _AgoraCallbackObjectDictionary[channelId]._CallbackQueue;
			if (!(callbackQueue != null))
			{
				return;
			}
			callbackQueue.EnQueue(delegate
			{
				if (_channelDictionary.ContainsKey(channelId))
				{
					AgoraChannel agoraChannel = _channelDictionary[channelId];
					if (agoraChannel != null && channel.ChannelOnUserJoined != null)
					{
						agoraChannel.ChannelOnUserJoined(channelId, uid, elapsed);
					}
				}
			});
		}

		[MonoPInvokeCallback(typeof(ChannelOnUserOffLineHandler))]
		private static void OnUserOffLineCallback(string channelId, uint uid, USER_OFFLINE_REASON reason)
		{
			AgoraChannel channel = null;
			if (!_channelDictionary.ContainsKey(channelId))
			{
				return;
			}
			channel = _channelDictionary[channelId];
			if (channel == null || channel.ChannelOnUserOffLine == null || _AgoraCallbackObjectDictionary[channelId] == null)
			{
				return;
			}
			AgoraCallbackQueue callbackQueue = _AgoraCallbackObjectDictionary[channelId]._CallbackQueue;
			if (!(callbackQueue != null))
			{
				return;
			}
			callbackQueue.EnQueue(delegate
			{
				if (_channelDictionary.ContainsKey(channelId))
				{
					AgoraChannel agoraChannel = _channelDictionary[channelId];
					if (agoraChannel != null && channel.ChannelOnUserOffLine != null)
					{
						agoraChannel.ChannelOnUserOffLine(channelId, uid, reason);
					}
				}
			});
		}

		[MonoPInvokeCallback(typeof(ChannelOnConnectionLostHandler))]
		private static void OnConnectionLostCallback(string channelId)
		{
			AgoraChannel channel = null;
			if (!_channelDictionary.ContainsKey(channelId))
			{
				return;
			}
			channel = _channelDictionary[channelId];
			if (channel == null || channel.ChannelOnConnectionLost == null || _AgoraCallbackObjectDictionary[channelId] == null)
			{
				return;
			}
			AgoraCallbackQueue callbackQueue = _AgoraCallbackObjectDictionary[channelId]._CallbackQueue;
			if (!(callbackQueue != null))
			{
				return;
			}
			callbackQueue.EnQueue(delegate
			{
				if (_channelDictionary.ContainsKey(channelId))
				{
					AgoraChannel agoraChannel = _channelDictionary[channelId];
					if (agoraChannel != null && channel.ChannelOnConnectionLost != null)
					{
						agoraChannel.ChannelOnConnectionLost(channelId);
					}
				}
			});
		}

		[MonoPInvokeCallback(typeof(ChannelOnRequestTokenHandler))]
		private static void OnRequestTokenCallback(string channelId)
		{
			AgoraChannel channel = null;
			if (!_channelDictionary.ContainsKey(channelId))
			{
				return;
			}
			channel = _channelDictionary[channelId];
			if (channel == null || channel.ChannelOnRequestToken == null || _AgoraCallbackObjectDictionary[channelId] == null)
			{
				return;
			}
			AgoraCallbackQueue callbackQueue = _AgoraCallbackObjectDictionary[channelId]._CallbackQueue;
			if (!(callbackQueue != null))
			{
				return;
			}
			callbackQueue.EnQueue(delegate
			{
				if (_channelDictionary.ContainsKey(channelId))
				{
					AgoraChannel agoraChannel = _channelDictionary[channelId];
					if (agoraChannel != null && channel.ChannelOnRequestToken != null)
					{
						agoraChannel.ChannelOnRequestToken(channelId);
					}
				}
			});
		}

		[MonoPInvokeCallback(typeof(ChannelOnTokenPrivilegeWillExpireHandler))]
		private static void OnTokenPrivilegeWillExpireCallback(string channelId, string token)
		{
			AgoraChannel channel = null;
			if (!_channelDictionary.ContainsKey(channelId))
			{
				return;
			}
			channel = _channelDictionary[channelId];
			if (channel == null || channel.ChannelOnTokenPrivilegeWillExpire == null || _AgoraCallbackObjectDictionary[channelId] == null)
			{
				return;
			}
			AgoraCallbackQueue callbackQueue = _AgoraCallbackObjectDictionary[channelId]._CallbackQueue;
			if (!(callbackQueue != null))
			{
				return;
			}
			callbackQueue.EnQueue(delegate
			{
				if (_channelDictionary.ContainsKey(channelId))
				{
					AgoraChannel agoraChannel = _channelDictionary[channelId];
					if (agoraChannel != null && channel.ChannelOnTokenPrivilegeWillExpire != null)
					{
						agoraChannel.ChannelOnTokenPrivilegeWillExpire(channelId, token);
					}
				}
			});
		}

		[MonoPInvokeCallback(typeof(ChannelEngineEventOnRtcStatsHandler))]
		private static void OnRtcStatsCallback(string channelId, uint duration, uint txBytes, uint rxBytes, uint txAudioBytes, uint txVideoBytes, uint rxAudioBytes, uint rxVideoBytes, ushort txKBitRate, ushort rxKBitRate, ushort rxAudioKBitRate, ushort txAudioKBitRate, ushort rxVideoKBitRate, ushort txVideoKBitRate, ushort lastmileDelay, ushort txPacketLossRate, ushort rxPacketLossRate, uint userCount, double cpuAppUsage, double cpuTotalUsage, int gatewayRtt, double memoryAppUsageRatio, double memoryTotalUsageRatio, int memoryAppUsageInKbytes)
		{
			AgoraChannel channel = null;
			if (!_channelDictionary.ContainsKey(channelId))
			{
				return;
			}
			channel = _channelDictionary[channelId];
			if (channel == null || channel.ChannelOnRtcStats == null || _AgoraCallbackObjectDictionary[channelId] == null)
			{
				return;
			}
			AgoraCallbackQueue callbackQueue = _AgoraCallbackObjectDictionary[channelId]._CallbackQueue;
			if (!(callbackQueue != null))
			{
				return;
			}
			callbackQueue.EnQueue(delegate
			{
				if (_channelDictionary.ContainsKey(channelId))
				{
					AgoraChannel agoraChannel = _channelDictionary[channelId];
					if (agoraChannel != null && channel.ChannelOnRtcStats != null)
					{
						RtcStats rtcStats = default(RtcStats);
						rtcStats.duration = duration;
						rtcStats.txBytes = txBytes;
						rtcStats.rxBytes = rxBytes;
						rtcStats.txAudioBytes = txAudioBytes;
						rtcStats.txVideoBytes = txVideoBytes;
						rtcStats.rxAudioBytes = rxAudioBytes;
						rtcStats.rxVideoBytes = rxVideoBytes;
						rtcStats.txKBitRate = txKBitRate;
						rtcStats.rxKBitRate = rxKBitRate;
						rtcStats.rxAudioKBitRate = rxAudioKBitRate;
						rtcStats.txAudioKBitRate = txAudioKBitRate;
						rtcStats.rxVideoKBitRate = rxVideoKBitRate;
						rtcStats.txVideoKBitRate = txVideoKBitRate;
						rtcStats.lastmileDelay = lastmileDelay;
						rtcStats.txPacketLossRate = txPacketLossRate;
						rtcStats.rxPacketLossRate = rxPacketLossRate;
						rtcStats.userCount = userCount;
						rtcStats.cpuAppUsage = cpuAppUsage;
						rtcStats.cpuTotalUsage = cpuTotalUsage;
						rtcStats.gatewayRtt = gatewayRtt;
						rtcStats.memoryAppUsageRatio = memoryAppUsageRatio;
						rtcStats.memoryTotalUsageRatio = memoryTotalUsageRatio;
						rtcStats.memoryAppUsageInKbytes = memoryAppUsageInKbytes;
						agoraChannel.ChannelOnRtcStats(channelId, rtcStats);
					}
				}
			});
		}

		[MonoPInvokeCallback(typeof(ChannelOnNetworkQualityHandler))]
		private static void OnNetworkQualityCallback(string channelId, uint uid, int txQuality, int rxQuality)
		{
			AgoraChannel channel = null;
			if (!_channelDictionary.ContainsKey(channelId))
			{
				return;
			}
			channel = _channelDictionary[channelId];
			if (channel == null || channel.ChannelOnNetworkQuality == null || _AgoraCallbackObjectDictionary[channelId] == null)
			{
				return;
			}
			AgoraCallbackQueue callbackQueue = _AgoraCallbackObjectDictionary[channelId]._CallbackQueue;
			if (!(callbackQueue != null))
			{
				return;
			}
			callbackQueue.EnQueue(delegate
			{
				if (_channelDictionary.ContainsKey(channelId))
				{
					AgoraChannel agoraChannel = _channelDictionary[channelId];
					if (agoraChannel != null && channel.ChannelOnNetworkQuality != null)
					{
						agoraChannel.ChannelOnNetworkQuality(channelId, uid, txQuality, rxQuality);
					}
				}
			});
		}

		[MonoPInvokeCallback(typeof(ChannelEngineEventOnRemoteVideoStatsHandler))]
		private static void OnRemoteVideoStatsCallback(string channelId, uint uid, int delay, int width, int height, int receivedBitrate, int decoderOutputFrameRate, int rendererOutputFrameRate, int packetLossRate, int rxStreamType, int totalFrozenTime, int frozenRate, int totalActiveTime)
		{
			AgoraChannel channel = null;
			if (!_channelDictionary.ContainsKey(channelId))
			{
				return;
			}
			channel = _channelDictionary[channelId];
			if (channel == null || channel.ChannelOnRemoteVideoStats == null || _AgoraCallbackObjectDictionary[channelId] == null)
			{
				return;
			}
			AgoraCallbackQueue callbackQueue = _AgoraCallbackObjectDictionary[channelId]._CallbackQueue;
			if (!(callbackQueue != null))
			{
				return;
			}
			callbackQueue.EnQueue(delegate
			{
				if (_channelDictionary.ContainsKey(channelId))
				{
					AgoraChannel agoraChannel = _channelDictionary[channelId];
					if (agoraChannel != null && channel.ChannelOnRemoteVideoStats != null)
					{
						RemoteVideoStats remoteVideoStats = default(RemoteVideoStats);
						remoteVideoStats.uid = uid;
						remoteVideoStats.delay = delay;
						remoteVideoStats.width = width;
						remoteVideoStats.height = height;
						remoteVideoStats.receivedBitrate = receivedBitrate;
						remoteVideoStats.decoderOutputFrameRate = decoderOutputFrameRate;
						remoteVideoStats.rendererOutputFrameRate = rendererOutputFrameRate;
						remoteVideoStats.packetLossRate = packetLossRate;
						remoteVideoStats.rxStreamType = (REMOTE_VIDEO_STREAM_TYPE)rxStreamType;
						remoteVideoStats.totalFrozenTime = totalFrozenTime;
						remoteVideoStats.frozenRate = frozenRate;
						remoteVideoStats.totalActiveTime = totalActiveTime;
						agoraChannel.ChannelOnRemoteVideoStats(channelId, remoteVideoStats);
					}
				}
			});
		}

		[MonoPInvokeCallback(typeof(ChannelOnRemoteAudioStatsHandler))]
		private static void OnRemoteAudioStatsCallback(string channelId, uint uid, int quality, int networkTransportDelay, int jitterBufferDelay, int audioLossRate, int numChannels, int receivedSampleRate, int receivedBitrate, int totalFrozenTime, int frozenRate, int totalActiveTime)
		{
			AgoraChannel channel = null;
			if (!_channelDictionary.ContainsKey(channelId))
			{
				return;
			}
			channel = _channelDictionary[channelId];
			if (channel == null || channel.ChannelOnRemoteAudioStats == null || _AgoraCallbackObjectDictionary[channelId] == null)
			{
				return;
			}
			AgoraCallbackQueue callbackQueue = _AgoraCallbackObjectDictionary[channelId]._CallbackQueue;
			if (!(callbackQueue != null))
			{
				return;
			}
			callbackQueue.EnQueue(delegate
			{
				if (_channelDictionary.ContainsKey(channelId))
				{
					AgoraChannel agoraChannel = _channelDictionary[channelId];
					if (agoraChannel != null && channel.ChannelOnRemoteAudioStats != null)
					{
						RemoteAudioStats remoteAudioStats = default(RemoteAudioStats);
						remoteAudioStats.uid = uid;
						remoteAudioStats.quality = quality;
						remoteAudioStats.networkTransportDelay = networkTransportDelay;
						remoteAudioStats.jitterBufferDelay = jitterBufferDelay;
						remoteAudioStats.audioLossRate = audioLossRate;
						remoteAudioStats.numChannels = numChannels;
						remoteAudioStats.receivedSampleRate = receivedSampleRate;
						remoteAudioStats.receivedBitrate = receivedBitrate;
						remoteAudioStats.totalFrozenTime = totalFrozenTime;
						remoteAudioStats.frozenRate = frozenRate;
						remoteAudioStats.totalActiveTime = totalActiveTime;
						agoraChannel.ChannelOnRemoteAudioStats(channelId, remoteAudioStats);
					}
				}
			});
		}

		[MonoPInvokeCallback(typeof(ChannelOnRemoteAudioStateChangedHandler))]
		private static void OnRemoteAudioStatChangedCallback(string channelId, uint uid, REMOTE_AUDIO_STATE state, REMOTE_AUDIO_STATE_REASON reason, int elapsed)
		{
			AgoraChannel channel = null;
			if (!_channelDictionary.ContainsKey(channelId))
			{
				return;
			}
			channel = _channelDictionary[channelId];
			if (channel == null || channel.ChannelOnRemoteAudioStateChanged == null || _AgoraCallbackObjectDictionary[channelId] == null)
			{
				return;
			}
			AgoraCallbackQueue callbackQueue = _AgoraCallbackObjectDictionary[channelId]._CallbackQueue;
			if (!(callbackQueue != null))
			{
				return;
			}
			callbackQueue.EnQueue(delegate
			{
				if (_channelDictionary.ContainsKey(channelId))
				{
					AgoraChannel agoraChannel = _channelDictionary[channelId];
					if (agoraChannel != null && channel.ChannelOnRemoteAudioStateChanged != null)
					{
						agoraChannel.ChannelOnRemoteAudioStateChanged(channelId, uid, state, reason, elapsed);
					}
				}
			});
		}

		[MonoPInvokeCallback(typeof(ChannelOnActiveSpeakerHandler))]
		private static void OnActiveSpeakerCallback(string channelId, uint uid)
		{
			AgoraChannel channel = null;
			if (!_channelDictionary.ContainsKey(channelId))
			{
				return;
			}
			channel = _channelDictionary[channelId];
			if (channel == null || channel.ChannelOnActiveSpeaker == null || _AgoraCallbackObjectDictionary[channelId] == null)
			{
				return;
			}
			AgoraCallbackQueue callbackQueue = _AgoraCallbackObjectDictionary[channelId]._CallbackQueue;
			if (!(callbackQueue != null))
			{
				return;
			}
			callbackQueue.EnQueue(delegate
			{
				if (_channelDictionary.ContainsKey(channelId))
				{
					AgoraChannel agoraChannel = _channelDictionary[channelId];
					if (agoraChannel != null && channel.ChannelOnActiveSpeaker != null)
					{
						agoraChannel.ChannelOnActiveSpeaker(channelId, uid);
					}
				}
			});
		}

		[MonoPInvokeCallback(typeof(ChannelOnVideoSizeChangedHandler))]
		private static void OnVideoSizeChangedCallback(string channelId, uint uid, int width, int height, int rotation)
		{
			AgoraChannel channel = null;
			if (!_channelDictionary.ContainsKey(channelId))
			{
				return;
			}
			channel = _channelDictionary[channelId];
			if (channel == null || channel.ChannelOnVideoSizeChanged == null || _AgoraCallbackObjectDictionary[channelId] == null)
			{
				return;
			}
			AgoraCallbackQueue callbackQueue = _AgoraCallbackObjectDictionary[channelId]._CallbackQueue;
			if (!(callbackQueue != null))
			{
				return;
			}
			callbackQueue.EnQueue(delegate
			{
				if (_channelDictionary.ContainsKey(channelId))
				{
					AgoraChannel agoraChannel = _channelDictionary[channelId];
					if (agoraChannel != null && channel.ChannelOnVideoSizeChanged != null)
					{
						agoraChannel.ChannelOnVideoSizeChanged(channelId, uid, width, height, rotation);
					}
				}
			});
		}

		[MonoPInvokeCallback(typeof(ChannelOnRemoteVideoStateChangedHandler))]
		private static void OnRemoteVideoStateChangedCallback(string channelId, uint uid, REMOTE_VIDEO_STATE state, REMOTE_VIDEO_STATE_REASON reason, int elapsed)
		{
			AgoraChannel channel = null;
			if (!_channelDictionary.ContainsKey(channelId))
			{
				return;
			}
			channel = _channelDictionary[channelId];
			if (channel == null || channel.ChannelOnRemoteVideoStateChanged == null || _AgoraCallbackObjectDictionary[channelId] == null)
			{
				return;
			}
			AgoraCallbackQueue callbackQueue = _AgoraCallbackObjectDictionary[channelId]._CallbackQueue;
			if (!(callbackQueue != null))
			{
				return;
			}
			callbackQueue.EnQueue(delegate
			{
				if (_channelDictionary.ContainsKey(channelId))
				{
					AgoraChannel agoraChannel = _channelDictionary[channelId];
					if (agoraChannel != null && channel.ChannelOnRemoteVideoStateChanged != null)
					{
						agoraChannel.ChannelOnRemoteVideoStateChanged(channelId, uid, state, reason, elapsed);
					}
				}
			});
		}

		[MonoPInvokeCallback(typeof(ChannelOnStreamMessageHandler))]
		private static void OnStreamMessageCallback(string channelId, uint uid, int streamId, string data, int length)
		{
			AgoraChannel channel = null;
			if (!_channelDictionary.ContainsKey(channelId))
			{
				return;
			}
			channel = _channelDictionary[channelId];
			if (channel == null || channel.ChannelOnStreamMessage == null || _AgoraCallbackObjectDictionary[channelId] == null)
			{
				return;
			}
			AgoraCallbackQueue callbackQueue = _AgoraCallbackObjectDictionary[channelId]._CallbackQueue;
			if (!(callbackQueue != null))
			{
				return;
			}
			callbackQueue.EnQueue(delegate
			{
				if (_channelDictionary.ContainsKey(channelId))
				{
					AgoraChannel agoraChannel = _channelDictionary[channelId];
					if (agoraChannel != null && channel.ChannelOnStreamMessage != null)
					{
						agoraChannel.ChannelOnStreamMessage(channelId, uid, streamId, data, length);
					}
				}
			});
		}

		[MonoPInvokeCallback(typeof(ChannelOnStreamMessageErrorHandler))]
		private static void OnStreamMessageErrorCallback(string channelId, uint uid, int streamId, int code, int missed, int cached)
		{
			AgoraChannel channel = null;
			if (!_channelDictionary.ContainsKey(channelId))
			{
				return;
			}
			channel = _channelDictionary[channelId];
			if (channel == null || channel.ChannelOnStreamMessageError == null || _AgoraCallbackObjectDictionary[channelId] == null)
			{
				return;
			}
			AgoraCallbackQueue callbackQueue = _AgoraCallbackObjectDictionary[channelId]._CallbackQueue;
			if (!(callbackQueue != null))
			{
				return;
			}
			callbackQueue.EnQueue(delegate
			{
				if (_channelDictionary.ContainsKey(channelId))
				{
					AgoraChannel agoraChannel = _channelDictionary[channelId];
					if (agoraChannel != null && channel.ChannelOnStreamMessageError != null)
					{
						agoraChannel.ChannelOnStreamMessageError(channelId, uid, streamId, code, missed, cached);
					}
				}
			});
		}

		[MonoPInvokeCallback(typeof(ChannelOnMediaRelayStateChangedHandler))]
		private static void OnMediaRelayStateChangedCallback(string channelId, CHANNEL_MEDIA_RELAY_STATE state, CHANNEL_MEDIA_RELAY_ERROR code)
		{
			AgoraChannel channel = null;
			if (!_channelDictionary.ContainsKey(channelId))
			{
				return;
			}
			channel = _channelDictionary[channelId];
			if (channel == null || channel.ChannelOnMediaRelayStateChanged == null || _AgoraCallbackObjectDictionary[channelId] == null)
			{
				return;
			}
			AgoraCallbackQueue callbackQueue = _AgoraCallbackObjectDictionary[channelId]._CallbackQueue;
			if (!(callbackQueue != null))
			{
				return;
			}
			callbackQueue.EnQueue(delegate
			{
				if (_channelDictionary.ContainsKey(channelId))
				{
					AgoraChannel agoraChannel = _channelDictionary[channelId];
					if (agoraChannel != null && channel.ChannelOnMediaRelayStateChanged != null)
					{
						agoraChannel.ChannelOnMediaRelayStateChanged(channelId, state, code);
					}
				}
			});
		}

		[MonoPInvokeCallback(typeof(ChannelOnMediaRelayEventHandler))]
		private static void OnMediaRelayEventCallback(string channelId, CHANNEL_MEDIA_RELAY_EVENT code)
		{
			AgoraChannel channel = null;
			if (!_channelDictionary.ContainsKey(channelId))
			{
				return;
			}
			channel = _channelDictionary[channelId];
			if (channel == null || channel.ChannelOnMediaRelayEvent == null || _AgoraCallbackObjectDictionary[channelId] == null)
			{
				return;
			}
			AgoraCallbackQueue callbackQueue = _AgoraCallbackObjectDictionary[channelId]._CallbackQueue;
			if (!(callbackQueue != null))
			{
				return;
			}
			callbackQueue.EnQueue(delegate
			{
				if (_channelDictionary.ContainsKey(channelId))
				{
					AgoraChannel agoraChannel = _channelDictionary[channelId];
					if (agoraChannel != null && channel.ChannelOnMediaRelayEvent != null)
					{
						agoraChannel.ChannelOnMediaRelayEvent(channelId, code);
					}
				}
			});
		}

		[MonoPInvokeCallback(typeof(ChannelOnRtmpStreamingStateChangedHandler))]
		private static void OnRtmpStreamingStateChangedCallback(string channelId, string url, RTMP_STREAM_PUBLISH_STATE state, RTMP_STREAM_PUBLISH_ERROR errCode)
		{
			AgoraChannel channel = null;
			if (!_channelDictionary.ContainsKey(channelId))
			{
				return;
			}
			channel = _channelDictionary[channelId];
			if (channel == null || channel.ChannelOnRtmpStreamingStateChanged == null || _AgoraCallbackObjectDictionary[channelId] == null)
			{
				return;
			}
			AgoraCallbackQueue callbackQueue = _AgoraCallbackObjectDictionary[channelId]._CallbackQueue;
			if (!(callbackQueue != null))
			{
				return;
			}
			callbackQueue.EnQueue(delegate
			{
				if (_channelDictionary.ContainsKey(channelId))
				{
					AgoraChannel agoraChannel = _channelDictionary[channelId];
					if (agoraChannel != null && channel.ChannelOnRtmpStreamingStateChanged != null)
					{
						agoraChannel.ChannelOnRtmpStreamingStateChanged(channelId, url, state, errCode);
					}
				}
			});
		}

		[MonoPInvokeCallback(typeof(ChannelOnTranscodingUpdatedHandler))]
		private static void OnTranscodingUpdatedCallback(string channelId)
		{
			AgoraChannel channel = null;
			if (!_channelDictionary.ContainsKey(channelId))
			{
				return;
			}
			channel = _channelDictionary[channelId];
			if (channel == null || channel.ChannelOnTranscodingUpdated == null || _AgoraCallbackObjectDictionary[channelId] == null)
			{
				return;
			}
			AgoraCallbackQueue callbackQueue = _AgoraCallbackObjectDictionary[channelId]._CallbackQueue;
			if (!(callbackQueue != null))
			{
				return;
			}
			callbackQueue.EnQueue(delegate
			{
				if (_channelDictionary.ContainsKey(channelId))
				{
					AgoraChannel agoraChannel = _channelDictionary[channelId];
					if (agoraChannel != null && channel.ChannelOnTranscodingUpdated != null)
					{
						agoraChannel.ChannelOnTranscodingUpdated(channelId);
					}
				}
			});
		}

		[MonoPInvokeCallback(typeof(ChannelOnStreamInjectedStatusHandler))]
		private static void OnStreamInjectedStatusCallback(string channelId, string url, uint uid, int status)
		{
			AgoraChannel channel = null;
			if (!_channelDictionary.ContainsKey(channelId))
			{
				return;
			}
			channel = _channelDictionary[channelId];
			if (channel == null || channel.ChannelOnStreamInjectedStatus == null || _AgoraCallbackObjectDictionary[channelId] == null)
			{
				return;
			}
			AgoraCallbackQueue callbackQueue = _AgoraCallbackObjectDictionary[channelId]._CallbackQueue;
			if (!(callbackQueue != null))
			{
				return;
			}
			callbackQueue.EnQueue(delegate
			{
				if (_channelDictionary.ContainsKey(channelId))
				{
					AgoraChannel agoraChannel = _channelDictionary[channelId];
					if (agoraChannel != null && channel.ChannelOnStreamInjectedStatus != null)
					{
						agoraChannel.ChannelOnStreamInjectedStatus(channelId, url, uid, status);
					}
				}
			});
		}

		[MonoPInvokeCallback(typeof(ChannelOnRemoteSubscribeFallbackToAudioOnlyHandler))]
		private static void OnRemoteSubscribeFallbackToAudioOnlyCallback(string channelId, uint uid, bool isFallbackOrRecover)
		{
			AgoraChannel channel = null;
			if (!_channelDictionary.ContainsKey(channelId))
			{
				return;
			}
			channel = _channelDictionary[channelId];
			if (channel == null || channel.ChannelOnRemoteSubscribeFallbackToAudioOnly == null || _AgoraCallbackObjectDictionary[channelId] == null)
			{
				return;
			}
			AgoraCallbackQueue callbackQueue = _AgoraCallbackObjectDictionary[channelId]._CallbackQueue;
			if (!(callbackQueue != null))
			{
				return;
			}
			callbackQueue.EnQueue(delegate
			{
				if (_channelDictionary.ContainsKey(channelId))
				{
					AgoraChannel agoraChannel = _channelDictionary[channelId];
					if (agoraChannel != null && channel.ChannelOnRemoteSubscribeFallbackToAudioOnly != null)
					{
						agoraChannel.ChannelOnRemoteSubscribeFallbackToAudioOnly(channelId, uid, isFallbackOrRecover);
					}
				}
			});
		}

		[MonoPInvokeCallback(typeof(ChannelOnConnectionStateChangedHandler))]
		private static void OnConnectionStateChangedCallback(string channelId, CONNECTION_STATE_TYPE state, CONNECTION_CHANGED_REASON_TYPE reason)
		{
			AgoraChannel channel = null;
			if (!_channelDictionary.ContainsKey(channelId))
			{
				return;
			}
			channel = _channelDictionary[channelId];
			if (channel == null || channel.ChannelOnConnectionStateChanged == null || _AgoraCallbackObjectDictionary[channelId] == null)
			{
				return;
			}
			AgoraCallbackQueue callbackQueue = _AgoraCallbackObjectDictionary[channelId]._CallbackQueue;
			if (!(callbackQueue != null))
			{
				return;
			}
			callbackQueue.EnQueue(delegate
			{
				if (_channelDictionary.ContainsKey(channelId))
				{
					AgoraChannel agoraChannel = _channelDictionary[channelId];
					if (agoraChannel != null && channel.ChannelOnConnectionStateChanged != null)
					{
						agoraChannel.ChannelOnConnectionStateChanged(channelId, state, reason);
					}
				}
			});
		}

		[MonoPInvokeCallback(typeof(ChannelOnLocalPublishFallbackToAudioOnlyHandler))]
		private static void OnLocalPublishFallbackToAudioOnlyCallback(string channelId, bool isFallbackOrRecover)
		{
			AgoraChannel channel = null;
			if (!_channelDictionary.ContainsKey(channelId))
			{
				return;
			}
			channel = _channelDictionary[channelId];
			if (channel == null || channel.ChannelOnLocalPublishFallbackToAudioOnly == null || _AgoraCallbackObjectDictionary[channelId] == null)
			{
				return;
			}
			AgoraCallbackQueue callbackQueue = _AgoraCallbackObjectDictionary[channelId]._CallbackQueue;
			if (!(callbackQueue != null))
			{
				return;
			}
			callbackQueue.EnQueue(delegate
			{
				if (_channelDictionary.ContainsKey(channelId))
				{
					AgoraChannel agoraChannel = _channelDictionary[channelId];
					if (agoraChannel != null && channel.ChannelOnLocalPublishFallbackToAudioOnly != null)
					{
						agoraChannel.ChannelOnLocalPublishFallbackToAudioOnly(channelId, isFallbackOrRecover);
					}
				}
			});
		}

		private void initChannelEvent()
		{
			IRtcEngineNative.initChannelEventCallback(_channelHandler, OnWarningCallback, OnErrorCallback, OnJoinChannelSuccessCallback, OnReJoinChannelSuccessCallback, OnLeaveChannelCallback, OnClientRoleChangedCallback, OnUserJoinedCallback, OnUserOffLineCallback, OnConnectionLostCallback, OnRequestTokenCallback, OnTokenPrivilegeWillExpireCallback, OnRtcStatsCallback, OnNetworkQualityCallback, OnRemoteVideoStatsCallback, OnRemoteAudioStatsCallback, OnRemoteAudioStatChangedCallback, OnActiveSpeakerCallback, OnVideoSizeChangedCallback, OnRemoteVideoStateChangedCallback, OnStreamMessageCallback, OnStreamMessageErrorCallback, OnMediaRelayStateChangedCallback, OnMediaRelayEventCallback, OnRtmpStreamingStateChangedCallback, OnTranscodingUpdatedCallback, OnStreamInjectedStatusCallback, OnRemoteSubscribeFallbackToAudioOnlyCallback, OnConnectionStateChangedCallback, OnLocalPublishFallbackToAudioOnlyCallback);
		}
	}
	public delegate void ChannelOnWarningHandler(string channelId, int warn, string message);
	public delegate void ChannelOnErrorHandler(string channelId, int err, string message);
	public delegate void ChannelOnJoinChannelSuccessHandler(string channelId, uint uid, int elapsed);
	public delegate void ChannelOnReJoinChannelSuccessHandler(string channelId, uint uid, int elapsed);
	public delegate void ChannelOnLeaveChannelHandler(string channelId, RtcStats rtcStats);
	public delegate void ChannelOnClientRoleChangedHandler(string channelId, CLIENT_ROLE_TYPE oldRole, CLIENT_ROLE_TYPE newRole);
	public delegate void ChannelOnUserJoinedHandler(string channelId, uint uid, int elapsed);
	public delegate void ChannelOnUserOffLineHandler(string channelId, uint uid, USER_OFFLINE_REASON reason);
	public delegate void ChannelOnConnectionLostHandler(string channelId);
	public delegate void ChannelOnRequestTokenHandler(string channelId);
	public delegate void ChannelOnTokenPrivilegeWillExpireHandler(string channelId, string token);
	public delegate void ChannelOnRtcStatsHandler(string channelId, RtcStats rtcStats);
	public delegate void ChannelOnNetworkQualityHandler(string channelId, uint uid, int txQuality, int rxQuality);
	public delegate void ChannelOnRemoteVideoStatsHandler(string channelId, RemoteVideoStats remoteVideoStats);
	public delegate void ChannelOnRemoteAudioStatsHandler(string channelId, RemoteAudioStats remoteAudioStats);
	public delegate void ChannelOnRemoteAudioStateChangedHandler(string channelId, uint uid, REMOTE_AUDIO_STATE state, REMOTE_AUDIO_STATE_REASON reason, int elapsed);
	public delegate void ChannelOnActiveSpeakerHandler(string channelId, uint uid);
	public delegate void ChannelOnVideoSizeChangedHandler(string channelId, uint uid, int width, int height, int rotation);
	public delegate void ChannelOnRemoteVideoStateChangedHandler(string channelId, uint uid, REMOTE_VIDEO_STATE state, REMOTE_VIDEO_STATE_REASON reason, int elapsed);
	public delegate void ChannelOnStreamMessageHandler(string channelId, uint uid, int streamId, string data, int length);
	public delegate void ChannelOnStreamMessageErrorHandler(string channelId, uint uid, int streamId, int code, int missed, int cached);
	public delegate void ChannelOnMediaRelayStateChangedHandler(string channelId, CHANNEL_MEDIA_RELAY_STATE state, CHANNEL_MEDIA_RELAY_ERROR code);
	public delegate void ChannelOnMediaRelayEventHandler(string channelId, CHANNEL_MEDIA_RELAY_EVENT events);
	public delegate void ChannelOnRtmpStreamingStateChangedHandler(string channelId, string url, RTMP_STREAM_PUBLISH_STATE state, RTMP_STREAM_PUBLISH_ERROR errCode);
	public delegate void ChannelOnTranscodingUpdatedHandler(string channelId);
	public delegate void ChannelOnStreamInjectedStatusHandler(string channelId, string url, uint uid, int status);
	public delegate void ChannelOnRemoteSubscribeFallbackToAudioOnlyHandler(string channelId, uint uid, bool isFallbackOrRecover);
	public delegate void ChannelOnConnectionStateChangedHandler(string channelId, CONNECTION_STATE_TYPE state, CONNECTION_CHANGED_REASON_TYPE reason);
	public delegate void ChannelOnLocalPublishFallbackToAudioOnlyHandler(string channelId, bool isFallbackOrRecover);
	public enum VIDEO_RENDER_MODE
	{
		RENDER_RAWDATA = 100,
		REDNER_OPENGL_ES2,
		RENDER_UNITY_LOW_LEVEL_INTERFACE
	}
	public enum ERROR_CODE
	{
		ERROR_NOT_INIT_ENGINE = -7,
		ERROR_OK = 0,
		ERROR_INVALID_ARGUMENT = -2,
		ERROR_NO_DEVICE_PLUGIN = -100
	}
	public enum REMOTE_VIDEO_STREAM_TYPE
	{
		REMOTE_VIDEO_STREAM_HIGH,
		REMOTE_VIDEO_STREAM_LOW
	}
	public enum REMOTE_VIDEO_STATE
	{
		REMOTE_VIDEO_STATE_STOPPED,
		REMOTE_VIDEO_STATE_STARTING,
		REMOTE_VIDEO_STATE_DECODING,
		REMOTE_VIDEO_STATE_FROZEN,
		REMOTE_VIDEO_STATE_FAILED
	}
	public enum USER_OFFLINE_REASON
	{
		QUIT,
		DROPPED,
		BECOME_AUDIENCE
	}
	public enum LOG_FILTER
	{
		OFF = 0,
		DEBUG = 2063,
		INFO = 15,
		WARNING = 14,
		ERROR = 12,
		CRITICAL = 8
	}
	public enum CHANNEL_PROFILE
	{
		CHANNEL_PROFILE_COMMUNICATION,
		CHANNEL_PROFILE_LIVE_BROADCASTING,
		CHANNEL_PROFILE_GAME
	}
	public enum CLIENT_ROLE_TYPE
	{
		CLIENT_ROLE_BROADCASTER = 1,
		CLIENT_ROLE_AUDIENCE
	}
	public enum AUDIO_RECORDING_QUALITY_TYPE
	{
		AUDIO_RECORDING_QUALITY_LOW,
		AUDIO_RECORDING_QUALITY_MEDIUM,
		AUDIO_RECORDING_QUALITY_HIGH
	}
	public enum AUDIO_ROUTE
	{
		AUDIO_ROUTE_DEFAULT = -1,
		AUDIO_ROUTE_HEADSET,
		AUDIO_ROUTE_EARPIECE,
		AUDIO_ROUTE_HEADSET_NO_MIC,
		AUDIO_ROUTE_SPEAKERPHONE,
		AUDIO_ROUTE_LOUDSPEAKER,
		AUDIO_ROUTE_BLUETOOTH
	}
	public enum CONNECTION_STATE_TYPE
	{
		CONNECTION_STATE_DISCONNECTED = 1,
		CONNECTION_STATE_CONNECTING,
		CONNECTION_STATE_CONNECTED,
		CONNECTION_STATE_RECONNECTING,
		CONNECTION_STATE_FAILED
	}
	public enum CONNECTION_CHANGED_REASON_TYPE
	{
		CONNECTION_CHANGED_CONNECTING,
		CONNECTION_CHANGED_JOIN_SUCCESS,
		CONNECTION_CHANGED_INTERRUPTED,
		CONNECTION_CHANGED_BANNED_BY_SERVER,
		CONNECTION_CHANGED_JOIN_FAILED,
		CONNECTION_CHANGED_LEAVE_CHANNEL,
		CONNECTION_CHANGED_INVALID_APP_ID,
		CONNECTION_CHANGED_INVALID_CHANNEL_NAME,
		CONNECTION_CHANGED_INVALID_TOKEN,
		CONNECTION_CHANGED_TOKEN_EXPIRED,
		CONNECTION_CHANGED_REJECTED_BY_SERVER,
		CONNECTION_CHANGED_SETTING_PROXY_SERVER,
		CONNECTION_CHANGED_RENEW_TOKEN,
		CONNECTION_CHANGED_CLIENT_IP_ADDRESS_CHANGED,
		CONNECTION_CHANGED_KEEP_ALIVE_TIMEOUT
	}
	public enum STREAM_FALLBACK_OPTIONS
	{
		STREAM_FALLBACK_OPTION_DISABLED,
		STREAM_FALLBACK_OPTION_VIDEO_STREAM_LOW,
		STREAM_FALLBACK_OPTION_AUDIO_ONLY
	}
	public enum VideoContentHint
	{
		CONTENT_HINT_NONE,
		CONTENT_HINT_MOTION,
		CONTENT_HINT_DETAILS
	}
	public enum REMOTE_VIDEO_STATE_REASON
	{
		REMOTE_VIDEO_STATE_REASON_INTERNAL,
		REMOTE_VIDEO_STATE_REASON_NETWORK_CONGESTION,
		REMOTE_VIDEO_STATE_REASON_NETWORK_RECOVERY,
		REMOTE_VIDEO_STATE_REASON_LOCAL_MUTED,
		REMOTE_VIDEO_STATE_REASON_LOCAL_UNMUTED,
		REMOTE_VIDEO_STATE_REASON_REMOTE_MUTED,
		REMOTE_VIDEO_STATE_REASON_REMOTE_UNMUTED,
		REMOTE_VIDEO_STATE_REASON_REMOTE_OFFLINE,
		REMOTE_VIDEO_STATE_REASON_AUDIO_FALLBACK,
		REMOTE_VIDEO_STATE_REASON_AUDIO_FALLBACK_RECOVERY
	}
	public enum LOCAL_VIDEO_STREAM_STATE
	{
		LOCAL_VIDEO_STREAM_STATE_STOPPED,
		LOCAL_VIDEO_STREAM_STATE_CAPTURING,
		LOCAL_VIDEO_STREAM_STATE_ENCODING,
		LOCAL_VIDEO_STREAM_STATE_FAILED
	}
	public enum LOCAL_VIDEO_STREAM_ERROR
	{
		LOCAL_VIDEO_STREAM_ERROR_OK,
		LOCAL_VIDEO_STREAM_ERROR_FAILURE,
		LOCAL_VIDEO_STREAM_ERROR_DEVICE_NO_PERMISSION,
		LOCAL_VIDEO_STREAM_ERROR_DEVICE_BUSY,
		LOCAL_VIDEO_STREAM_ERROR_CAPTURE_FAILURE,
		LOCAL_VIDEO_STREAM_ERROR_ENCODE_FAILURE
	}
	public enum MEDIA_DEVICE_TYPE
	{
		UNKNOWN_AUDIO_DEVICE = -1,
		AUDIO_PLAYOUT_DEVICE,
		AUDIO_RECORDING_DEVICE,
		VIDEO_RENDER_DEVICE,
		VIDEO_CAPTURE_DEVICE,
		AUDIO_APPLICATION_PLAYOUT_DEVICE
	}
	public enum RAW_AUDIO_FRAME_OP_MODE_TYPE
	{
		RAW_AUDIO_FRAME_OP_MODE_READ_ONLY,
		RAW_AUDIO_FRAME_OP_MODE_WRITE_ONLY,
		RAW_AUDIO_FRAME_OP_MODE_READ_WRITE
	}
	public enum AUDIO_PROFILE_TYPE
	{
		AUDIO_PROFILE_DEFAULT,
		AUDIO_PROFILE_SPEECH_STANDARD,
		AUDIO_PROFILE_MUSIC_STANDARD,
		AUDIO_PROFILE_MUSIC_STANDARD_STEREO,
		AUDIO_PROFILE_MUSIC_HIGH_QUALITY,
		AUDIO_PROFILE_MUSIC_HIGH_QUALITY_STEREO,
		AUDIO_PROFILE_IOT,
		AUDIO_PROFILE_NUM
	}
	public enum AUDIO_SCENARIO_TYPE
	{
		AUDIO_SCENARIO_DEFAULT,
		AUDIO_SCENARIO_CHATROOM_ENTERTAINMENT,
		AUDIO_SCENARIO_EDUCATION,
		AUDIO_SCENARIO_GAME_STREAMING,
		AUDIO_SCENARIO_SHOWROOM,
		AUDIO_SCENARIO_CHATROOM_GAMING,
		AUDIO_SCENARIO_IOT,
		AUDIO_SCENARIO_NUM
	}
	public enum VIDEO_CODEC_PROFILE_TYPE
	{
		VIDEO_CODEC_PROFILE_BASELINE = 66,
		VIDEO_CODEC_PROFILE_MAIN = 77,
		VIDEO_CODEC_PROFILE_HIGH = 100
	}
	public enum AUDIO_SAMPLE_RATE_TYPE
	{
		AUDIO_SAMPLE_RATE_32000 = 32000,
		AUDIO_SAMPLE_RATE_44100 = 44100,
		AUDIO_SAMPLE_RATE_48000 = 48000
	}
	public enum AUDIO_MIXING_STATE_TYPE
	{
		AUDIO_MIXING_STATE_PLAYING = 710,
		AUDIO_MIXING_STATE_PAUSED = 711,
		AUDIO_MIXING_STATE_STOPPED = 713,
		AUDIO_MIXING_STATE_FAILED = 714
	}
	public enum AUDIO_MIXING_ERROR_TYPE
	{
		AUDIO_MIXING_ERROR_CAN_NOT_OPEN = 701,
		AUDIO_MIXING_ERROR_TOO_FREQUENT_CALL = 702,
		AUDIO_MIXING_ERROR_INTERRUPTED_EOF = 703,
		AUDIO_MIXING_ERROR_OK = 0
	}
	public enum RTMP_STREAM_PUBLISH_STATE
	{
		RTMP_STREAM_PUBLISH_STATE_IDLE,
		RTMP_STREAM_PUBLISH_STATE_CONNECTING,
		RTMP_STREAM_PUBLISH_STATE_RUNNING,
		RTMP_STREAM_PUBLISH_STATE_RECOVERING,
		RTMP_STREAM_PUBLISH_STATE_FAILURE
	}
	public enum RTMP_STREAM_PUBLISH_ERROR
	{
		RTMP_STREAM_PUBLISH_ERROR_OK,
		RTMP_STREAM_PUBLISH_ERROR_INVALID_ARGUMENT,
		RTMP_STREAM_PUBLISH_ERROR_ENCRYPTED_STREAM_NOT_ALLOWED,
		RTMP_STREAM_PUBLISH_ERROR_CONNECTION_TIMEOUT,
		RTMP_STREAM_PUBLISH_ERROR_INTERNAL_SERVER_ERROR,
		RTMP_STREAM_PUBLISH_ERROR_RTMP_SERVER_ERROR,
		RTMP_STREAM_PUBLISH_ERROR_TOO_OFTEN,
		RTMP_STREAM_PUBLISH_ERROR_REACH_LIMIT,
		RTMP_STREAM_PUBLISH_ERROR_NOT_AUTHORIZED,
		RTMP_STREAM_PUBLISH_ERROR_STREAM_NOT_FOUND,
		RTMP_STREAM_PUBLISH_ERROR_FORMAT_NOT_SUPPORTED
	}
	public enum NETWORK_TYPE
	{
		NETWORK_TYPE_UNKNOWN = -1,
		NETWORK_TYPE_DISCONNECTED,
		NETWORK_TYPE_LAN,
		NETWORK_TYPE_WIFI,
		NETWORK_TYPE_MOBILE_2G,
		NETWORK_TYPE_MOBILE_3G,
		NETWORK_TYPE_MOBILE_4G
	}
	public enum VOICE_CHANGER_PRESET
	{
		VOICE_CHANGER_OFF = 0,
		VOICE_CHANGER_OLDMAN = 1,
		VOICE_CHANGER_BABYBOY = 2,
		VOICE_CHANGER_BABYGIRL = 3,
		VOICE_CHANGER_ZHUBAJIE = 4,
		VOICE_CHANGER_ETHEREAL = 5,
		VOICE_CHANGER_HULK = 6,
		VOICE_BEAUTY_VIGOROUS = 1048577,
		VOICE_BEAUTY_DEEP = 1048578,
		VOICE_BEAUTY_MELLOW = 1048579,
		VOICE_BEAUTY_FALSETTO = 1048580,
		VOICE_BEAUTY_FULL = 1048581,
		VOICE_BEAUTY_CLEAR = 1048582,
		VOICE_BEAUTY_RESOUNDING = 1048583,
		VOICE_BEAUTY_RINGING = 1048584,
		VOICE_BEAUTY_SPACIAL = 1048585,
		GENERAL_BEAUTY_VOICE_MALE_MAGNETIC = 2097153,
		GENERAL_BEAUTY_VOICE_FEMALE_FRESH = 2097154,
		GENERAL_BEAUTY_VOICE_FEMALE_VITALITY = 2097155
	}
	public enum AUDIO_REVERB_PRESET
	{
		AUDIO_REVERB_OFF = 0,
		AUDIO_REVERB_FX_KTV = 1048577,
		AUDIO_REVERB_FX_VOCAL_CONCERT = 1048578,
		AUDIO_REVERB_FX_UNCLE = 1048579,
		AUDIO_REVERB_FX_SISTER = 1048580,
		AUDIO_REVERB_FX_STUDIO = 1048581,
		AUDIO_REVERB_FX_POPULAR = 1048582,
		AUDIO_REVERB_FX_RNB = 1048583,
		AUDIO_REVERB_FX_PHONOGRAPH = 1048584,
		AUDIO_REVERB_POPULAR = 1,
		AUDIO_REVERB_RNB = 2,
		AUDIO_REVERB_ROCK = 3,
		AUDIO_REVERB_HIPHOP = 4,
		AUDIO_REVERB_VOCAL_CONCERT = 5,
		AUDIO_REVERB_KTV = 6,
		AUDIO_REVERB_STUDIO = 7,
		AUDIO_VIRTUAL_STEREO = 2097153
	}
	public enum AUDIO_EQUALIZATION_BAND_FREQUENCY
	{
		AUDIO_EQUALIZATION_BAND_31,
		AUDIO_EQUALIZATION_BAND_62,
		AUDIO_EQUALIZATION_BAND_125,
		AUDIO_EQUALIZATION_BAND_250,
		AUDIO_EQUALIZATION_BAND_500,
		AUDIO_EQUALIZATION_BAND_1K,
		AUDIO_EQUALIZATION_BAND_2K,
		AUDIO_EQUALIZATION_BAND_4K,
		AUDIO_EQUALIZATION_BAND_8K,
		AUDIO_EQUALIZATION_BAND_16K
	}
	public enum QUALITY_ADAPT_INDICATION
	{
		ADAPT_NONE,
		ADAPT_UP_BANDWIDTH,
		ADAPT_DOWN_BANDWIDTH
	}
	public enum AUDIO_REVERB_TYPE
	{
		AUDIO_REVERB_DRY_LEVEL,
		AUDIO_REVERB_WET_LEVEL,
		AUDIO_REVERB_ROOM_SIZE,
		AUDIO_REVERB_WET_DELAY,
		AUDIO_REVERB_STRENGTH
	}
	public enum AUDIO_CODEC_PROFILE_TYPE
	{
		AUDIO_CODEC_PROFILE_LC_AAC,
		AUDIO_CODEC_PROFILE_HE_AAC
	}
	public enum VIDEO_CODEC_TYPE
	{
		VIDEO_CODEC_VP8 = 1,
		VIDEO_CODEC_H264,
		VIDEO_CODEC_EVP,
		VIDEO_CODEC_E264
	}
	public enum AREA_CODE : uint
	{
		AREA_CODE_CN = 1u,
		AREA_CODE_NA = 2u,
		AREA_CODE_EUR = 4u,
		AREA_CODE_AS = 8u,
		AREA_CODE_GLOBAL = uint.MaxValue
	}
	public struct RtcEngineConfig
	{
		public string appId { get; set; }

		public AREA_CODE areaCode { get; set; }

		public RtcEngineConfig(string mAppId, AREA_CODE mAreaCode = AREA_CODE.AREA_CODE_GLOBAL)
		{
			appId = mAppId;
			areaCode = mAreaCode;
		}
	}
	public struct RtcStats
	{
		public uint duration;

		public uint txBytes;

		public uint rxBytes;

		public uint txAudioBytes;

		public uint txVideoBytes;

		public uint rxAudioBytes;

		public uint rxVideoBytes;

		public uint txKBitRate;

		public uint rxKBitRate;

		public uint rxAudioKBitRate;

		public uint txAudioKBitRate;

		public uint rxVideoKBitRate;

		public uint txVideoKBitRate;

		public ushort lastmileDelay;

		public ushort txPacketLossRate;

		public ushort rxPacketLossRate;

		public uint userCount;

		public double cpuAppUsage;

		public double cpuTotalUsage;

		public int gatewayRtt;

		public double memoryAppUsageRatio;

		public double memoryTotalUsageRatio;

		public int memoryAppUsageInKbytes;
	}
	public struct AudioVolumeInfo
	{
		public uint uid;

		public uint volume;

		public uint vad;

		public string channelId;
	}
	public struct ChannelMediaOptions
	{
		public bool autoSubscribeAudio;

		public bool autoSubscribeVideo;

		public ChannelMediaOptions(bool _autoSubscribeAudio = true, bool _autoSubscribeVideo = false)
		{
			autoSubscribeAudio = _autoSubscribeAudio;
			autoSubscribeVideo = _autoSubscribeVideo;
		}
	}
	public struct LocalVideoStats
	{
		public int sentBitrate;

		public int sentFrameRate;

		public int encoderOutputFrameRate;

		public int rendererOutputFrameRate;

		public int targetBitrate;

		public int targetFrameRate;

		public QUALITY_ADAPT_INDICATION qualityAdaptIndication;

		public int encodedBitrate;

		public int encodedFrameWidth;

		public int encodedFrameHeight;

		public int encodedFrameCount;

		public VIDEO_CODEC_TYPE codecType;
	}
	public struct RemoteVideoStats
	{
		public uint uid;

		public int delay;

		public int width;

		public int height;

		public int receivedBitrate;

		public int decoderOutputFrameRate;

		public int rendererOutputFrameRate;

		public int packetLossRate;

		public REMOTE_VIDEO_STREAM_TYPE rxStreamType;

		public int totalFrozenTime;

		public int frozenRate;

		public int totalActiveTime;
	}
	public struct UserInfo
	{
		public uint uid;

		public string userAccount;
	}
	public struct RemoteAudioStats
	{
		public uint uid;

		public int quality;

		public int networkTransportDelay;

		public int jitterBufferDelay;

		public int audioLossRate;

		public int numChannels;

		public int receivedSampleRate;

		public int receivedBitrate;

		public int totalFrozenTime;

		public int frozenRate;

		public int totalActiveTime;
	}
	public struct WatermarkOptions
	{
		public bool visibleInPreview;

		public Rectangle positionInLandscapeMode;

		public Rectangle positionInPortraitMode;
	}
	public struct LocalAudioStats
	{
		public int numChannels;

		public int sentSampleRate;

		public int sentBitrate;
	}
	public struct VideoEncoderConfiguration
	{
		public VideoDimensions dimensions;

		public FRAME_RATE frameRate;

		public int minFrameRate;

		public int bitrate;

		public int minBitrate;

		public ORIENTATION_MODE orientationMode;

		public DEGRADATION_PREFERENCE degradationPreference;

		public VIDEO_MIRROR_MODE_TYPE mirrorMode;
	}
	public struct VideoDimensions
	{
		public int width;

		public int height;
	}
	public struct TranscodingUser
	{
		public uint uid;

		public int x;

		public int y;

		public int width;

		public int height;

		public int zOrder;

		public double alpha;

		public int audioChannel;
	}
	public struct RtcImage
	{
		public string url;

		public int x;

		public int y;

		public int width;

		public int height;
	}
	public struct LiveTranscoding
	{
		public int width;

		public int height;

		public int videoBitrate;

		public int videoFramerate;

		public bool lowLatency;

		public int videoGop;

		public VIDEO_CODEC_PROFILE_TYPE videoCodecProfile;

		public uint backgroundColor;

		public uint userCount;

		public TranscodingUser[] transcodingUsers;

		public string transcodingExtraInfo;

		public string metadata;

		public RtcImage watermark;

		public RtcImage backgroundImage;

		public AUDIO_SAMPLE_RATE_TYPE audioSampleRate;

		public int audioBitrate;

		public int audioChannels;

		public AUDIO_CODEC_PROFILE_TYPE audioCodecProfile;
	}
	public enum FRAME_RATE
	{
		FRAME_RATE_FPS_1 = 1,
		FRAME_RATE_FPS_7 = 7,
		FRAME_RATE_FPS_10 = 10,
		FRAME_RATE_FPS_15 = 15,
		FRAME_RATE_FPS_24 = 24,
		FRAME_RATE_FPS_30 = 30,
		FRAME_RATE_FPS_60 = 60
	}
	public enum ORIENTATION_MODE
	{
		ORIENTATION_MODE_ADAPTIVE,
		ORIENTATION_MODE_FIXED_LANDSCAPE,
		ORIENTATION_MODE_FIXED_PORTRAIT
	}
	public enum DEGRADATION_PREFERENCE
	{
		MAINTAIN_QUALITY,
		MAINTAIN_FRAMERATE,
		MAINTAIN_BALANCED
	}
	public struct ExternalVideoFrame
	{
		public enum VIDEO_BUFFER_TYPE
		{
			VIDEO_BUFFER_RAW_DATA = 1
		}

		public enum VIDEO_PIXEL_FORMAT
		{
			VIDEO_PIXEL_UNKNOWN = 0,
			VIDEO_PIXEL_I420 = 1,
			VIDEO_PIXEL_BGRA = 2,
			VIDEO_PIXEL_NV21 = 3,
			VIDEO_PIXEL_RGBA = 4,
			VIDEO_PIXEL_IMC2 = 5,
			VIDEO_PIXEL_ARGB = 7,
			VIDEO_PIXEL_NV12 = 8,
			VIDEO_PIXEL_I422 = 16
		}

		public VIDEO_BUFFER_TYPE type;

		public VIDEO_PIXEL_FORMAT format;

		public byte[] buffer;

		public int stride;

		public int height;

		public int cropLeft;

		public int cropTop;

		public int cropRight;

		public int cropBottom;

		public int rotation;

		public long timestamp;
	}
	public enum VIDEO_FRAME_TYPE
	{
		FRAME_TYPE_YUV420,
		FRAME_TYPE_RGBA
	}
	public enum VIDEO_MIRROR_MODE_TYPE
	{
		VIDEO_MIRROR_MODE_AUTO,
		VIDEO_MIRROR_MODE_ENABLED,
		VIDEO_MIRROR_MODE_DISABLED
	}
	public struct VideoFrame
	{
		public VIDEO_FRAME_TYPE type;

		public int width;

		public int height;

		public int yStride;

		public byte[] buffer;

		public int rotation;

		public long renderTimeMs;

		public int avsync_type;
	}
	public enum AUDIO_FRAME_TYPE
	{
		FRAME_TYPE_PCM16
	}
	public struct AudioFrame
	{
		public AUDIO_FRAME_TYPE type;

		public int samples;

		public int bytesPerSample;

		public int channels;

		public int samplesPerSec;

		public byte[] buffer;

		public long renderTimeMs;

		public int avsync_type;
	}
	public enum MEDIA_SOURCE_TYPE
	{
		AUDIO_PLAYOUT_SOURCE,
		AUDIO_RECORDING_SOURCE
	}
	public enum LASTMILE_PROBE_RESULT_STATE
	{
		LASTMILE_PROBE_RESULT_COMPLETE = 1,
		LASTMILE_PROBE_RESULT_INCOMPLETE_NO_BWE,
		LASTMILE_PROBE_RESULT_UNAVAILABLE
	}
	public struct LastmileProbeOneWayResult
	{
		public uint packetLossRate;

		public uint jitter;

		public uint availableBandwidth;
	}
	public struct LastmileProbeResult
	{
		public LASTMILE_PROBE_RESULT_STATE state;

		public LastmileProbeOneWayResult uplinkReport;

		public LastmileProbeOneWayResult downlinkReport;

		public uint rtt;
	}
	public enum CAMERA_DIRECTION
	{
		CAMERA_REAR,
		CAMERA_FRONT
	}
	public struct CameraCapturerConfiguration
	{
		public CAPTURER_OUTPUT_PREFERENCE preference;

		public CAMERA_DIRECTION cameraDirection;
	}
	public enum CAPTURER_OUTPUT_PREFERENCE
	{
		CAPTURER_OUTPUT_PREFERENCE_AUTO,
		CAPTURER_OUTPUT_PREFERENCE_PERFORMANCE,
		CAPTURER_OUTPUT_PREFERENCE_PREVIEW
	}
	public enum QUALITY_TYPE
	{
		QUALITY_UNKNOWN,
		QUALITY_EXCELLENT,
		QUALITY_GOOD,
		QUALITY_POOR,
		QUALITY_BAD,
		QUALITY_VBAD,
		QUALITY_DOWN,
		QUALITY_UNSUPPORTED,
		QUALITY_DETECTING
	}
	public enum MEDIA_DEVICE_STATE_TYPE
	{
		MEDIA_DEVICE_STATE_ACTIVE = 1,
		MEDIA_DEVICE_STATE_DISABLED = 2,
		MEDIA_DEVICE_STATE_NOT_PRESENT = 4,
		MEDIA_DEVICE_STATE_UNPLUGGED = 8
	}
	public enum INJECT_STREAM_STATUS
	{
		INJECT_STREAM_STATUS_START_SUCCESS,
		INJECT_STREAM_STATUS_START_ALREADY_EXISTS,
		INJECT_STREAM_STATUS_START_UNAUTHORIZED,
		INJECT_STREAM_STATUS_START_TIMEDOUT,
		INJECT_STREAM_STATUS_START_FAILED,
		INJECT_STREAM_STATUS_STOP_SUCCESS,
		INJECT_STREAM_STATUS_STOP_NOT_FOUND,
		INJECT_STREAM_STATUS_STOP_UNAUTHORIZED,
		INJECT_STREAM_STATUS_STOP_TIMEDOUT,
		INJECT_STREAM_STATUS_STOP_FAILED,
		INJECT_STREAM_STATUS_BROKEN
	}
	public enum PRIORITY_TYPE
	{
		PRIORITY_HIGH = 50,
		PRIORITY_NORMAL = 100
	}
	public struct LastmileProbeConfig
	{
		public bool probeUplink;

		public bool probeDownlink;

		public uint expectedUplinkBitrate;

		public uint expectedDownlinkBitrate;
	}
	public struct PublisherConfiguration
	{
		public int width;

		public int height;

		public int framerate;

		public int bitrate;

		public int defaultLayout;

		public int lifecycle;

		public bool owner;

		public int injectStreamWidth;

		public int injectStreamHeight;

		public string injectStreamUrl;

		public string publishUrl;

		public string rawStreamUrl;

		public string extraInfo;
	}
	public struct Packet
	{
		public IntPtr buffer;

		public IntPtr size;
	}
	public enum LOCAL_AUDIO_STREAM_STATE
	{
		LOCAL_AUDIO_STREAM_STATE_STOPPED,
		LOCAL_AUDIO_STREAM_STATE_RECORDING,
		LOCAL_AUDIO_STREAM_STATE_ENCODING,
		LOCAL_AUDIO_STREAM_STATE_FAILED
	}
	public enum LOCAL_AUDIO_STREAM_ERROR
	{
		LOCAL_AUDIO_STREAM_ERROR_OK,
		LOCAL_AUDIO_STREAM_ERROR_FAILURE,
		LOCAL_AUDIO_STREAM_ERROR_DEVICE_NO_PERMISSION,
		LOCAL_AUDIO_STREAM_ERROR_DEVICE_BUSY,
		LOCAL_AUDIO_STREAM_ERROR_RECORD_FAILURE,
		LOCAL_AUDIO_STREAM_ERROR_ENCODE_FAILURE
	}
	public enum REMOTE_AUDIO_STATE
	{
		REMOTE_AUDIO_STATE_STOPPED,
		REMOTE_AUDIO_STATE_STARTING,
		REMOTE_AUDIO_STATE_DECODING,
		REMOTE_AUDIO_STATE_FROZEN,
		REMOTE_AUDIO_STATE_FAILED
	}
	public enum REMOTE_AUDIO_STATE_REASON
	{
		REMOTE_AUDIO_REASON_INTERNAL,
		REMOTE_AUDIO_REASON_NETWORK_CONGESTION,
		REMOTE_AUDIO_REASON_NETWORK_RECOVERY,
		REMOTE_AUDIO_REASON_LOCAL_MUTED,
		REMOTE_AUDIO_REASON_LOCAL_UNMUTED,
		REMOTE_AUDIO_REASON_REMOTE_MUTED,
		REMOTE_AUDIO_REASON_REMOTE_UNMUTED,
		REMOTE_AUDIO_REASON_REMOTE_OFFLINE
	}
	public struct BeautyOptions
	{
		public enum LIGHTENING_CONTRAST_LEVEL
		{
			LIGHTENING_CONTRAST_LOW,
			LIGHTENING_CONTRAST_NORMAL,
			LIGHTENING_CONTRAST_HIGH
		}

		public LIGHTENING_CONTRAST_LEVEL lighteningContrastLevel;

		public float lighteningLevel;

		public float smoothnessLevel;

		public float rednessLevel;
	}
	public struct Rectangle
	{
		public int x;

		public int y;

		public int width;

		public int height;
	}
	public struct ScreenCaptureParameters
	{
		public VideoDimensions dimensions;

		public int frameRate;

		public int bitrate;

		public bool captureMouseCursor;
	}
	public struct InjectStreamConfig
	{
		public int width;

		public int height;

		public int videoGop;

		public int videoFramerate;

		public int videoBitrate;

		public AUDIO_SAMPLE_RATE_TYPE audioSampleRate;

		public int audioBitrate;

		public int audioChannels;
	}
	public enum AUDIO_SESSION_OPERATION_RESTRICTION
	{
		AUDIO_SESSION_OPERATION_RESTRICTION_NONE = 0,
		AUDIO_SESSION_OPERATION_RESTRICTION_SET_CATEGORY = 1,
		AUDIO_SESSION_OPERATION_RESTRICTION_CONFIGURE_SESSION = 2,
		AUDIO_SESSION_OPERATION_RESTRICTION_DEACTIVATE_SESSION = 4,
		AUDIO_SESSION_OPERATION_RESTRICTION_ALL = 0x80
	}
	public struct ChannelMediaRelayConfiguration
	{
		public ChannelMediaInfo srcInfo;

		public ChannelMediaInfo destInfos;

		public int destCount;
	}
	public struct ChannelMediaInfo
	{
		public string channelName;

		public string token;

		public uint uid;
	}
	public enum CHANNEL_MEDIA_RELAY_EVENT
	{
		RELAY_EVENT_NETWORK_DISCONNECTED,
		RELAY_EVENT_NETWORK_CONNECTED,
		RELAY_EVENT_PACKET_JOINED_SRC_CHANNEL,
		RELAY_EVENT_PACKET_JOINED_DEST_CHANNEL,
		RELAY_EVENT_PACKET_SENT_TO_DEST_CHANNEL,
		RELAY_EVENT_PACKET_RECEIVED_VIDEO_FROM_SRC,
		RELAY_EVENT_PACKET_RECEIVED_AUDIO_FROM_SRC,
		RELAY_EVENT_PACKET_UPDATE_DEST_CHANNEL,
		RELAY_EVENT_PACKET_UPDATE_DEST_CHANNEL_REFUSED,
		RELAY_EVENT_PACKET_UPDATE_DEST_CHANNEL_NOT_CHANGE,
		RELAY_EVENT_PACKET_UPDATE_DEST_CHANNEL_IS_NULL,
		RELAY_EVENT_VIDEO_PROFILE_UPDATE
	}
	public enum CHANNEL_MEDIA_RELAY_STATE
	{
		RELAY_STATE_IDLE,
		RELAY_STATE_CONNECTING,
		RELAY_STATE_RUNNING,
		RELAY_STATE_FAILURE
	}
	public enum VIDEO_PROFILE_TYPE
	{
		VIDEO_PROFILE_LANDSCAPE_120P = 0,
		VIDEO_PROFILE_LANDSCAPE_120P_3 = 2,
		VIDEO_PROFILE_LANDSCAPE_180P = 10,
		VIDEO_PROFILE_LANDSCAPE_180P_3 = 12,
		VIDEO_PROFILE_LANDSCAPE_180P_4 = 13,
		VIDEO_PROFILE_LANDSCAPE_240P = 20,
		VIDEO_PROFILE_LANDSCAPE_240P_3 = 22,
		VIDEO_PROFILE_LANDSCAPE_240P_4 = 23,
		VIDEO_PROFILE_LANDSCAPE_360P = 30,
		VIDEO_PROFILE_LANDSCAPE_360P_3 = 32,
		VIDEO_PROFILE_LANDSCAPE_360P_4 = 33,
		VIDEO_PROFILE_LANDSCAPE_360P_6 = 35,
		VIDEO_PROFILE_LANDSCAPE_360P_7 = 36,
		VIDEO_PROFILE_LANDSCAPE_360P_8 = 37,
		VIDEO_PROFILE_LANDSCAPE_360P_9 = 38,
		VIDEO_PROFILE_LANDSCAPE_360P_10 = 39,
		VIDEO_PROFILE_LANDSCAPE_360P_11 = 100,
		VIDEO_PROFILE_LANDSCAPE_480P = 40,
		VIDEO_PROFILE_LANDSCAPE_480P_3 = 42,
		VIDEO_PROFILE_LANDSCAPE_480P_4 = 43,
		VIDEO_PROFILE_LANDSCAPE_480P_6 = 45,
		VIDEO_PROFILE_LANDSCAPE_480P_8 = 47,
		VIDEO_PROFILE_LANDSCAPE_480P_9 = 48,
		VIDEO_PROFILE_LANDSCAPE_480P_10 = 49,
		VIDEO_PROFILE_LANDSCAPE_720P = 50,
		VIDEO_PROFILE_LANDSCAPE_720P_3 = 52,
		VIDEO_PROFILE_LANDSCAPE_720P_5 = 54,
		VIDEO_PROFILE_LANDSCAPE_720P_6 = 55,
		VIDEO_PROFILE_LANDSCAPE_1080P = 60,
		VIDEO_PROFILE_LANDSCAPE_1080P_3 = 62,
		VIDEO_PROFILE_LANDSCAPE_1080P_5 = 64,
		VIDEO_PROFILE_LANDSCAPE_1440P = 66,
		VIDEO_PROFILE_LANDSCAPE_1440P_2 = 67,
		VIDEO_PROFILE_LANDSCAPE_4K = 70,
		VIDEO_PROFILE_LANDSCAPE_4K_3 = 72,
		VIDEO_PROFILE_PORTRAIT_120P = 1000,
		VIDEO_PROFILE_PORTRAIT_120P_3 = 1002,
		VIDEO_PROFILE_PORTRAIT_180P = 1010,
		VIDEO_PROFILE_PORTRAIT_180P_3 = 1012,
		VIDEO_PROFILE_PORTRAIT_180P_4 = 1013,
		VIDEO_PROFILE_PORTRAIT_240P = 1020,
		VIDEO_PROFILE_PORTRAIT_240P_3 = 1022,
		VIDEO_PROFILE_PORTRAIT_240P_4 = 1023,
		VIDEO_PROFILE_PORTRAIT_360P = 1030,
		VIDEO_PROFILE_PORTRAIT_360P_3 = 1032,
		VIDEO_PROFILE_PORTRAIT_360P_4 = 1033,
		VIDEO_PROFILE_PORTRAIT_360P_6 = 1035,
		VIDEO_PROFILE_PORTRAIT_360P_7 = 1036,
		VIDEO_PROFILE_PORTRAIT_360P_8 = 1037,
		VIDEO_PROFILE_PORTRAIT_360P_9 = 1038,
		VIDEO_PROFILE_PORTRAIT_360P_10 = 1039,
		VIDEO_PROFILE_PORTRAIT_360P_11 = 1100,
		VIDEO_PROFILE_PORTRAIT_480P = 1040,
		VIDEO_PROFILE_PORTRAIT_480P_3 = 1042,
		VIDEO_PROFILE_PORTRAIT_480P_4 = 1043,
		VIDEO_PROFILE_PORTRAIT_480P_6 = 1045,
		VIDEO_PROFILE_PORTRAIT_480P_8 = 1047,
		VIDEO_PROFILE_PORTRAIT_480P_9 = 1048,
		VIDEO_PROFILE_PORTRAIT_480P_10 = 1049,
		VIDEO_PROFILE_PORTRAIT_720P = 1050,
		VIDEO_PROFILE_PORTRAIT_720P_3 = 1052,
		VIDEO_PROFILE_PORTRAIT_720P_5 = 1054,
		VIDEO_PROFILE_PORTRAIT_720P_6 = 1055,
		VIDEO_PROFILE_PORTRAIT_1080P = 1060,
		VIDEO_PROFILE_PORTRAIT_1080P_3 = 1062,
		VIDEO_PROFILE_PORTRAIT_1080P_5 = 1064,
		VIDEO_PROFILE_PORTRAIT_1440P = 1066,
		VIDEO_PROFILE_PORTRAIT_1440P_2 = 1067,
		VIDEO_PROFILE_PORTRAIT_4K = 1070,
		VIDEO_PROFILE_PORTRAIT_4K_3 = 1072,
		VIDEO_PROFILE_DEFAULT = 30
	}
	public enum CHANNEL_MEDIA_RELAY_ERROR
	{
		RELAY_OK,
		RELAY_ERROR_SERVER_ERROR_RESPONSE,
		RELAY_ERROR_SERVER_NO_RESPONSE,
		RELAY_ERROR_NO_RESOURCE_AVAILABLE,
		RELAY_ERROR_FAILED_JOIN_SRC,
		RELAY_ERROR_FAILED_JOIN_DEST,
		RELAY_ERROR_FAILED_PACKET_RECEIVED_FROM_SRC,
		RELAY_ERROR_FAILED_PACKET_SENT_TO_DEST,
		RELAY_ERROR_SERVER_CONNECTION_LOST,
		RELAY_ERROR_INTERNAL_ERROR,
		RELAY_ERROR_SRC_TOKEN_EXPIRED,
		RELAY_ERROR_DEST_TOKEN_EXPIRED
	}
	public enum METADATA_TYPE
	{
		UNKNOWN_METADATA = -1,
		VIDEO_METADATA
	}
	public struct Metadata
	{
		public uint uid;

		public uint size;

		public byte[] buffer;

		public long timeStampMs;
	}
	public struct VideoCanvas
	{
		public int hwnd;

		public RENDER_MODE_TYPE renderMode;

		public uint uid;

		public IntPtr priv;
	}
	public enum RENDER_MODE_TYPE
	{
		RENDER_MODE_HIDDEN = 1,
		RENDER_MODE_FIT,
		RENDER_MODE_ADAPTIVE
	}
	public sealed class IRtcEngine : IRtcEngineNative
	{
		public OnJoinChannelSuccessHandler OnJoinChannelSuccess;

		public OnReJoinChannelSuccessHandler OnReJoinChannelSuccess;

		public OnConnectionLostHandler OnConnectionLost;

		public OnConnectionInterruptedHandler OnConnectionInterrupted;

		public OnRequestTokenHandler OnRequestToken;

		public OnUserJoinedHandler OnUserJoined;

		public OnUserOfflineHandler OnUserOffline;

		public OnLeaveChannelHandler OnLeaveChannel;

		public OnVolumeIndicationHandler OnVolumeIndication;

		public OnUserMutedAudioHandler OnUserMutedAudio;

		public OnSDKWarningHandler OnWarning;

		public OnSDKErrorHandler OnError;

		public OnRtcStatsHandler OnRtcStats;

		public OnAudioMixingFinishedHandler OnAudioMixingFinished;

		public OnAudioRouteChangedHandler OnAudioRouteChanged;

		public OnFirstRemoteVideoDecodedHandler OnFirstRemoteVideoDecoded;

		public OnVideoSizeChangedHandler OnVideoSizeChanged;

		public OnClientRoleChangedHandler OnClientRoleChanged;

		public OnUserMuteVideoHandler OnUserMuteVideo;

		public OnMicrophoneEnabledHandler OnMicrophoneEnabled;

		public OnFirstRemoteAudioFrameHandler OnFirstRemoteAudioFrame;

		public OnFirstLocalAudioFrameHandler OnFirstLocalAudioFrame;

		public OnApiExecutedHandler OnApiExecuted;

		public OnLastmileQualityHandler OnLastmileQuality;

		public OnAudioQualityHandler OnAudioQuality;

		public OnStreamInjectedStatusHandler OnStreamInjectedStatus;

		public OnStreamUnpublishedHandler OnStreamUnpublished;

		public OnStreamPublishedHandler OnStreamPublished;

		public OnStreamMessageErrorHandler OnStreamMessageError;

		public OnStreamMessageHandler OnStreamMessage;

		public OnConnectionBannedHandler OnConnectionBanned;

		public OnConnectionStateChangedHandler OnConnectionStateChanged;

		public OnTokenPrivilegeWillExpireHandler OnTokenPrivilegeWillExpire;

		public OnActiveSpeakerHandler OnActiveSpeaker;

		public OnVideoStoppedHandler OnVideoStopped;

		public OnFirstLocalVideoFrameHandler OnFirstLocalVideoFrame;

		public OnFirstRemoteVideoFrameHandler OnFirstRemoteVideoFrame;

		public OnUserEnableVideoHandler OnUserEnableVideo;

		public OnUserEnableLocalVideoHandler OnUserEnableLocalVideo;

		public OnRemoteVideoStateChangedHandler OnRemoteVideoStateChanged;

		public OnLocalPublishFallbackToAudioOnlyHandler OnLocalPublishFallbackToAudioOnly;

		public OnRemoteSubscribeFallbackToAudioOnlyHandler OnRemoteSubscribeFallbackToAudioOnly;

		public OnNetworkQualityHandler OnNetworkQuality;

		public OnLocalVideoStatsHandler OnLocalVideoStats;

		public OnRemoteVideoStatsHandler OnRemoteVideoStats;

		public OnRemoteAudioStatsHandler OnRemoteAudioStats;

		public OnAudioDeviceStateChangedHandler OnAudioDeviceStateChanged;

		public OnCameraReadyHandler OnCameraReady;

		public OnCameraFocusAreaChangedHandler OnCameraFocusAreaChanged;

		public OnCameraExposureAreaChangedHandler OnCameraExposureAreaChanged;

		public OnRemoteAudioMixingBeginHandler OnRemoteAudioMixingBegin;

		public OnRemoteAudioMixingEndHandler OnRemoteAudioMixingEnd;

		public OnAudioEffectFinishedHandler OnAudioEffectFinished;

		public OnVideoDeviceStateChangedHandler OnVideoDeviceStateChanged;

		public OnRemoteVideoTransportStatsHandler OnRemoteVideoTransportStats;

		public OnRemoteAudioTransportStatsHandler OnRemoteAudioTransportStats;

		public OnTranscodingUpdatedHandler OnTranscodingUpdated;

		public OnAudioDeviceVolumeChangedHandler OnAudioDeviceVolumeChanged;

		public OnMediaEngineStartCallSuccessHandler OnMediaEngineStartCallSuccess;

		public OnMediaEngineLoadSuccessHandler OnMediaEngineLoadSuccess;

		public OnAudioMixingStateChangedHandler OnAudioMixingStateChanged;

		public OnFirstRemoteAudioDecodedHandler OnFirstRemoteAudioDecoded;

		public OnLocalVideoStateChangedHandler OnLocalVideoStateChanged;

		public OnRtmpStreamingStateChangedHandler OnRtmpStreamingStateChanged;

		public OnNetworkTypeChangedHandler OnNetworkTypeChanged;

		public OnLastmileProbeResultHandler OnLastmileProbeResult;

		public OnLocalUserRegisteredHandler OnLocalUserRegistered;

		public OnUserInfoUpdatedHandler OnUserInfoUpdated;

		public OnLocalAudioStateChangedHandler OnLocalAudioStateChanged;

		public OnRemoteAudioStateChangedHandler OnRemoteAudioStateChanged;

		public OnLocalAudioStatsHandler OnLocalAudioStats;

		public OnChannelMediaRelayEventHandler OnChannelMediaRelayEvent;

		public OnChannelMediaRelayStateChangedHandler OnChannelMediaRelayStateChanged;

		public OnFacePositionChangedHandler OnFacePositionChanged;

		private readonly AudioEffectManagerImpl mAudioEffectM;

		private readonly AudioRecordingDeviceManager audioRecordingDeviceManager;

		private readonly AudioPlaybackDeviceManager audioPlaybackDeviceManager;

		private readonly VideoDeviceManager videoDeviceManager;

		private readonly AudioRawDataManager audioRawDataManager;

		private readonly VideoRawDataManager videoRawDataManager;

		private readonly VideoRender videoRender;

		private const string agoraGameObjectName = "agora_engine_CallBackGamObject";

		private AgoraCallbackObject _AgoraCallbackObject;

		private static IRtcEngine instance;

		private IRtcEngine(string appId)
		{
			InitGameObject();
			InitEngineCallback();
			IRtcEngineNative.createEngine(appId);
			mAudioEffectM = AudioEffectManagerImpl.GetInstance(this);
			audioRecordingDeviceManager = AudioRecordingDeviceManager.GetInstance(this);
			audioPlaybackDeviceManager = AudioPlaybackDeviceManager.GetInstance(this);
			videoDeviceManager = VideoDeviceManager.GetInstance(this);
			audioRawDataManager = AudioRawDataManager.GetInstance(this);
			videoRawDataManager = VideoRawDataManager.GetInstance(this);
			videoRender = VideoRender.GetInstance(this);
		}

		private IRtcEngine(RtcEngineConfig engineConfig)
		{
			InitGameObject();
			InitEngineCallback();
			IRtcEngineNative.createEngine2(engineConfig.appId, (uint)engineConfig.areaCode);
			mAudioEffectM = AudioEffectManagerImpl.GetInstance(this);
			audioRecordingDeviceManager = AudioRecordingDeviceManager.GetInstance(this);
			audioPlaybackDeviceManager = AudioPlaybackDeviceManager.GetInstance(this);
			videoDeviceManager = VideoDeviceManager.GetInstance(this);
			audioRawDataManager = AudioRawDataManager.GetInstance(this);
			videoRawDataManager = VideoRawDataManager.GetInstance(this);
			videoRender = VideoRender.GetInstance(this);
		}

		private void InitGameObject()
		{
			_AgoraCallbackObject = new AgoraCallbackObject("agora_engine_CallBackGamObject");
		}

		private void DeInitGameObject()
		{
			_AgoraCallbackObject.Release();
			_AgoraCallbackObject = null;
		}

		public string doFormat(string format, params object[] args)
		{
			return string.Format(CultureInfo.InvariantCulture, format, args);
		}

		public static string GetSdkVersion()
		{
			return Marshal.PtrToStringAnsi(IRtcEngineNative.getSdkVersion());
		}

		public int SetChannelProfile(CHANNEL_PROFILE profile)
		{
			return IRtcEngineNative.setChannelProfile((int)profile);
		}

		public int SetClientRole(CLIENT_ROLE_TYPE role)
		{
			return IRtcEngineNative.setClientRole((int)role);
		}

		public int SetLogFilter(LOG_FILTER filter)
		{
			return IRtcEngineNative.setLogFilter((uint)filter);
		}

		public int SetLogFile(string filePath)
		{
			return IRtcEngineNative.setLogFile(filePath);
		}

		public int SetDefaultEngineSettings()
		{
			return IRtcEngineNative.setDefaultEngineSettings();
		}

		public int JoinChannel(string channelName, string info = "", uint uid = 0u)
		{
			return JoinChannelByKey(null, channelName, info, uid);
		}

		public int JoinChannelByKey(string channelKey, string channelName, string info = "", uint uid = 0u)
		{
			return IRtcEngineNative.joinChannel(channelKey, channelName, info, uid);
		}

		public int RenewToken(string token)
		{
			return IRtcEngineNative.renewToken(token);
		}

		public int LeaveChannel()
		{
			return IRtcEngineNative.leaveChannel();
		}

		public void Pause()
		{
			UnityEngine.Debug.Log("Pause engine");
			DisableAudio();
			DisableVideo();
		}

		public void Resume()
		{
			UnityEngine.Debug.Log("Resume engine");
			EnableAudio();
			EnableVideo();
		}

		public int SetParameters(string parameters)
		{
			return IRtcEngineNative.setParameters(parameters);
		}

		public int SetParameter(string parameter, int value)
		{
			return IRtcEngineNative.setParameters(doFormat("{{\"{0}\": {1}}}", parameter, value));
		}

		public int SetParameter(string parameter, double value)
		{
			return IRtcEngineNative.setParameters(doFormat("{{\"{0}\": {1}}}", parameter, value));
		}

		public int SetParameter(string parameter, bool value)
		{
			string text = (value ? "true" : "false");
			return IRtcEngineNative.setParameters(doFormat("{{\"{0}\": {1}}}", parameter, text));
		}

		public string GetCallId()
		{
			string result = null;
			IntPtr callId = IRtcEngineNative.getCallId();
			if (callId != IntPtr.Zero)
			{
				result = Marshal.PtrToStringAnsi(callId);
				IRtcEngineNative.freeObject(callId);
			}
			return result;
		}

		public int Rate(string callId, int rating, string desc = "")
		{
			return IRtcEngineNative.rate(callId, rating, desc);
		}

		public int Complain(string callId, string desc = "")
		{
			return IRtcEngineNative.complain(callId, desc);
		}

		public int EnableAudio()
		{
			return IRtcEngineNative.enableAudio();
		}

		public int DisableAudio()
		{
			return IRtcEngineNative.disableAudio();
		}

		public int MuteLocalAudioStream(bool mute)
		{
			return IRtcEngineNative.muteLocalAudioStream(mute);
		}

		public int MuteAllRemoteAudioStreams(bool mute)
		{
			return IRtcEngineNative.muteAllRemoteAudioStreams(mute);
		}

		public int MuteRemoteAudioStream(uint uid, bool mute)
		{
			return IRtcEngineNative.muteRemoteAudioStream(uid, mute);
		}

		public int SetEnableSpeakerphone(bool speakerphone)
		{
			return IRtcEngineNative.setEnableSpeakerphone(speakerphone);
		}

		public int SetDefaultAudioRouteToSpeakerphone(bool speakerphone)
		{
			return IRtcEngineNative.setDefaultAudioRoutetoSpeakerphone(speakerphone);
		}

		public bool IsSpeakerphoneEnabled()
		{
			return IRtcEngineNative.isSpeakerphoneEnabled();
		}

		public int SwitchCamera()
		{
			return IRtcEngineNative.switchCamera();
		}

		public int SetVideoProfile(VIDEO_PROFILE_TYPE profile, bool swapWidthAndHeight = false)
		{
			return IRtcEngineNative.setVideoProfile((int)profile, swapWidthAndHeight);
		}

		public int MuteLocalVideoStream(bool mute)
		{
			return IRtcEngineNative.muteLocalVideoStream(mute);
		}

		public int MuteAllRemoteVideoStreams(bool mute)
		{
			return IRtcEngineNative.muteAllRemoteVideoStreams(mute);
		}

		public int MuteRemoteVideoStream(uint uid, bool mute)
		{
			return IRtcEngineNative.muteRemoteVideoStream(uid, mute);
		}

		public int EnableDualStreamMode(bool enabled)
		{
			return IRtcEngineNative.enableDualStreamMode(enabled);
		}

		public int SetEncryptionMode(string encryptionMode)
		{
			return IRtcEngineNative.setEncryptionMode(encryptionMode);
		}

		public int SetEncryptionSecret(string secret)
		{
			return IRtcEngineNative.setEncryptionSecret(secret);
		}

		public int CreateDataStream(bool reliable, bool ordered)
		{
			return IRtcEngineNative.createDataStream(reliable, ordered);
		}

		public int SendStreamMessage(int streamId, byte[] data)
		{
			return IRtcEngineNative.sendStreamMessage(streamId, data, data.Length);
		}

		public int SetSpeakerphoneVolume(int volume)
		{
			return IRtcEngineNative.setSpeakerphoneVolume(volume);
		}

		public int SetVideoQualityParameters(bool preferFrameRateOverImageQuality)
		{
			return IRtcEngineNative.setVideoQualityParameters(preferFrameRateOverImageQuality);
		}

		public int StartEchoTest()
		{
			return IRtcEngineNative.startEchoTest();
		}

		public int StartEchoTest(int intervalInSeconds)
		{
			return IRtcEngineNative.startEchoTest2(intervalInSeconds);
		}

		public int StopEchoTest()
		{
			return IRtcEngineNative.stopEchoTest();
		}

		public int StartLastmileProbeTest(LastmileProbeConfig lastmileProbeConfig)
		{
			return IRtcEngineNative.startLastmileProbeTest(lastmileProbeConfig.probeUplink, lastmileProbeConfig.probeDownlink, lastmileProbeConfig.expectedUplinkBitrate, lastmileProbeConfig.expectedDownlinkBitrate);
		}

		public int StopLastmileProbeTest()
		{
			return IRtcEngineNative.stopLastmileProbeTest();
		}

		public int AddVideoWatermark(RtcImage rtcImage)
		{
			return IRtcEngineNative.addVideoWatermark(rtcImage.url, rtcImage.x, rtcImage.y, rtcImage.width, rtcImage.height);
		}

		public int AddVideoWatermark(string watermarkUrl, WatermarkOptions watermarkOptions)
		{
			return IRtcEngineNative.addVideoWatermark2(watermarkUrl, watermarkOptions.visibleInPreview, watermarkOptions.positionInLandscapeMode.x, watermarkOptions.positionInLandscapeMode.y, watermarkOptions.positionInLandscapeMode.width, watermarkOptions.positionInLandscapeMode.height, watermarkOptions.positionInPortraitMode.x, watermarkOptions.positionInPortraitMode.y, watermarkOptions.positionInPortraitMode.width, watermarkOptions.positionInPortraitMode.height);
		}

		public int ClearVideoWatermarks()
		{
			return IRtcEngineNative.clearVideoWatermarks();
		}

		public int SetRemoteVideoStreamType(uint uid, REMOTE_VIDEO_STREAM_TYPE streamType)
		{
			return IRtcEngineNative.setRemoteVideoStreamType(uid, (int)streamType);
		}

		public int SetMixedAudioFrameParameters(int sampleRate, int samplesPerCall)
		{
			return IRtcEngineNative.setMixedAudioFrameParameters(sampleRate, samplesPerCall);
		}

		public int SetAudioMixingPosition(int pos)
		{
			return IRtcEngineNative.setAudioMixingPosition(pos);
		}

		public int EnableAudioVolumeIndication(int interval, int smooth, bool report_vad = false)
		{
			return IRtcEngineNative.enableAudioVolumeIndication(interval, smooth, report_vad);
		}

		public int AdjustRecordingSignalVolume(int volume)
		{
			return IRtcEngineNative.adjustRecordingSignalVolume(volume);
		}

		public int AdjustPlaybackSignalVolume(int volume)
		{
			return IRtcEngineNative.adjustPlaybackSignalVolume(volume);
		}

		public int StartAudioMixing(string filePath, bool loopback, bool replace, int cycle)
		{
			return IRtcEngineNative.startAudioMixing(filePath, loopback, replace, cycle);
		}

		public int StopAudioMixing()
		{
			return IRtcEngineNative.stopAudioMixing();
		}

		public int PauseAudioMixing()
		{
			return IRtcEngineNative.pauseAudioMixing();
		}

		public int ResumeAudioMixing()
		{
			return IRtcEngineNative.resumeAudioMixing();
		}

		public int AdjustAudioMixingVolume(int volume)
		{
			return IRtcEngineNative.adjustAudioMixingVolume(volume);
		}

		public int GetAudioMixingDuration()
		{
			return IRtcEngineNative.getAudioMixingDuration();
		}

		public int GetAudioMixingCurrentPosition()
		{
			return IRtcEngineNative.getAudioMixingCurrentPosition();
		}

		public int StartAudioRecording(string filePath, AUDIO_RECORDING_QUALITY_TYPE quality)
		{
			return IRtcEngineNative.startAudioRecording(filePath, (int)quality);
		}

		public int StartAudioRecording(string filePath, int sampleRate, AUDIO_RECORDING_QUALITY_TYPE quality)
		{
			return IRtcEngineNative.startAudioRecording2(filePath, sampleRate, (int)quality);
		}

		public int StopAudioRecording()
		{
			return IRtcEngineNative.stopAudioRecording();
		}

		public IAudioEffectManager GetAudioEffectManager()
		{
			return mAudioEffectM;
		}

		public IAudioRecordingDeviceManager GetAudioRecordingDeviceManager()
		{
			return audioRecordingDeviceManager;
		}

		public IAudioPlaybackDeviceManager GetAudioPlaybackDeviceManager()
		{
			return audioPlaybackDeviceManager;
		}

		public IVideoDeviceManager GetVideoDeviceManager()
		{
			return videoDeviceManager;
		}

		public IAudioRawDataManager GetAudioRawDataManager()
		{
			return audioRawDataManager;
		}

		public IVideoRawDataManager GetVideoRawDataManager()
		{
			return videoRawDataManager;
		}

		public IVideoRender GetVideoRender()
		{
			return videoRender;
		}

		public int EnableVideo()
		{
			return IRtcEngineNative.enableVideo();
		}

		public int DisableVideo()
		{
			return IRtcEngineNative.disableVideo();
		}

		public int EnableLocalVideo(bool enabled)
		{
			return IRtcEngineNative.enableLocalVideo(enabled);
		}

		public int EnableLocalAudio(bool enabled)
		{
			return IRtcEngineNative.enableLocalAudio(enabled);
		}

		public int StartPreview()
		{
			return IRtcEngineNative.startPreview();
		}

		public int StopPreview()
		{
			return IRtcEngineNative.stopPreview();
		}

		public int EnableVideoObserver()
		{
			return IRtcEngineNative.enableVideoObserver();
		}

		public int DisableVideoObserver()
		{
			return IRtcEngineNative.disableVideoObserver();
		}

		public int SetDefaultMuteAllRemoteAudioStreams(bool mute)
		{
			return IRtcEngineNative.setDefaultMuteAllRemoteAudioStreams(mute);
		}

		public int SetDefaultMuteAllRemoteVideoStreams(bool mute)
		{
			return IRtcEngineNative.setDefaultMuteAllRemoteVideoStreams(mute);
		}

		public int EnableLastmileTest()
		{
			return IRtcEngineNative.enableLastmileTest();
		}

		public int DisableLastmileTest()
		{
			return IRtcEngineNative.disableLastmileTest();
		}

		public CONNECTION_STATE_TYPE GetConnectionState()
		{
			return (CONNECTION_STATE_TYPE)IRtcEngineNative.getConnectionState();
		}

		public int SetAudioProfile(AUDIO_PROFILE_TYPE audioProfile, AUDIO_SCENARIO_TYPE scenario)
		{
			return IRtcEngineNative.setAudioProfile((int)audioProfile, (int)scenario);
		}

		public int SetVideoEncoderConfiguration(VideoEncoderConfiguration configuration)
		{
			return IRtcEngineNative.setVideoEncoderConfiguration(configuration.dimensions.width, configuration.dimensions.height, (int)configuration.frameRate, configuration.minFrameRate, configuration.bitrate, configuration.minBitrate, (int)configuration.orientationMode, (int)configuration.degradationPreference, (int)configuration.mirrorMode);
		}

		public int AdjustAudioMixingPlayoutVolume(int volume)
		{
			return IRtcEngineNative.adjustAudioMixingPlayoutVolume(volume);
		}

		public int AdjustAudioMixingPublishVolume(int volume)
		{
			return IRtcEngineNative.adjustAudioMixingPublishVolume(volume);
		}

		public int SetVolumeOfEffect(int soundId, int volume)
		{
			return IRtcEngineNative.setVolumeOfEffect(soundId, volume);
		}

		public int SetRecordingAudioFrameParameters(int sampleRate, int channel, RAW_AUDIO_FRAME_OP_MODE_TYPE mode, int samplesPerCall)
		{
			return IRtcEngineNative.setRecordingAudioFrameParameters(sampleRate, channel, (int)mode, samplesPerCall);
		}

		public int SetPlaybackAudioFrameParameters(int sampleRate, int channel, RAW_AUDIO_FRAME_OP_MODE_TYPE mode, int samplesPerCall)
		{
			return IRtcEngineNative.setPlaybackAudioFrameParameters(sampleRate, channel, (int)mode, samplesPerCall);
		}

		public int SetLocalPublishFallbackOption(STREAM_FALLBACK_OPTIONS option)
		{
			return IRtcEngineNative.setLocalPublishFallbackOption((int)option);
		}

		public int SetRemoteSubscribeFallbackOption(STREAM_FALLBACK_OPTIONS option)
		{
			return IRtcEngineNative.setRemoteSubscribeFallbackOption((int)option);
		}

		public int SetRemoteDefaultVideoStreamType(REMOTE_VIDEO_STREAM_TYPE remoteVideoStreamType)
		{
			return IRtcEngineNative.setRemoteDefaultVideoStreamType((int)remoteVideoStreamType);
		}

		public int AddPublishStreamUrl(string url, bool transcodingEnabled)
		{
			return IRtcEngineNative.addPublishStreamUrl(url, transcodingEnabled);
		}

		public int RemovePublishStreamUrl(string url)
		{
			return IRtcEngineNative.removePublishStreamUrl(url);
		}

		public static string GetErrorDescription(int code)
		{
			return Marshal.PtrToStringAnsi(IRtcEngineNative.getErrorDescription(code));
		}

		public int EnableWebSdkInteroperability(bool enabled)
		{
			return IRtcEngineNative.enableWebSdkInteroperability(enabled);
		}

		public int SetLiveTranscoding(LiveTranscoding transcoding)
		{
			string text = "";
			if (transcoding.userCount != 0 && transcoding.transcodingUsers != null)
			{
				for (int i = 0; i < transcoding.userCount; i++)
				{
					text += transcoding.transcodingUsers[i].uid;
					text += "\t";
					text += transcoding.transcodingUsers[i].x;
					text += "\t";
					text += transcoding.transcodingUsers[i].y;
					text += "\t";
					text += transcoding.transcodingUsers[i].width;
					text += "\t";
					text += transcoding.transcodingUsers[i].height;
					text += "\t";
					text += transcoding.transcodingUsers[i].zOrder;
					text += "\t";
					text += transcoding.transcodingUsers[i].alpha;
					text += "\t";
					text += transcoding.transcodingUsers[i].audioChannel;
					text += "\t";
				}
			}
			UnityEngine.Debug.Log("transcodingUserInfo  " + text);
			return IRtcEngineNative.setLiveTranscoding(transcoding.width, transcoding.height, transcoding.videoBitrate, transcoding.videoFramerate, transcoding.lowLatency, transcoding.videoGop, (int)transcoding.videoCodecProfile, transcoding.backgroundColor, transcoding.userCount, text, transcoding.transcodingExtraInfo, transcoding.metadata, transcoding.watermark.url, transcoding.watermark.x, transcoding.watermark.y, transcoding.watermark.width, transcoding.watermark.height, transcoding.backgroundImage.url, transcoding.backgroundImage.x, transcoding.backgroundImage.y, transcoding.backgroundImage.width, transcoding.backgroundImage.height, (int)transcoding.audioSampleRate, transcoding.audioBitrate, transcoding.audioChannels, (int)transcoding.audioCodecProfile);
		}

		public int PushVideoFrame(ExternalVideoFrame externalVideoFrame)
		{
			return IRtcEngineNative.pushVideoFrame((int)externalVideoFrame.type, (int)externalVideoFrame.format, externalVideoFrame.buffer, externalVideoFrame.stride, externalVideoFrame.height, externalVideoFrame.cropLeft, externalVideoFrame.cropTop, externalVideoFrame.cropRight, externalVideoFrame.cropBottom, externalVideoFrame.rotation, externalVideoFrame.timestamp);
		}

		public int SetExternalVideoSource(bool enable, bool useTexture = false)
		{
			return IRtcEngineNative.setExternalVideoSource(enable, useTexture);
		}

		public int SetExternalAudioSource(bool enabled, int sampleRate, int channels)
		{
			return IRtcEngineNative.setExternalAudioSource(enabled, sampleRate, channels);
		}

		public int PushAudioFrame(AudioFrame audioFrame)
		{
			return IRtcEngineNative.pushAudioFrame_((int)audioFrame.type, audioFrame.samples, audioFrame.bytesPerSample, audioFrame.channels, audioFrame.samplesPerSec, audioFrame.buffer, audioFrame.renderTimeMs, audioFrame.avsync_type);
		}

		public int GetAudioMixingPlayoutVolume()
		{
			return IRtcEngineNative.getAudioMixingPlayoutVolume();
		}

		public int GetAudioMixingPublishVolume()
		{
			return IRtcEngineNative.getAudioMixingPublishVolume();
		}

		public int EnableSoundPositionIndication(bool enabled)
		{
			return IRtcEngineNative.enableSoundPositionIndication(enabled);
		}

		public int SetLocalVoiceChanger(VOICE_CHANGER_PRESET voiceChanger)
		{
			return IRtcEngineNative.setLocalVoiceChanger((int)voiceChanger);
		}

		public int SetLocalVoiceReverbPreset(AUDIO_REVERB_PRESET audioReverbPreset)
		{
			return IRtcEngineNative.setLocalVoiceReverbPreset((int)audioReverbPreset);
		}

		public int SetLocalVoicePitch(double pitch)
		{
			return IRtcEngineNative.setLocalVoicePitch(pitch);
		}

		public int SetLocalVoiceEqualization(AUDIO_EQUALIZATION_BAND_FREQUENCY bandFrequency, int bandGain)
		{
			return IRtcEngineNative.setLocalVoiceEqualization((int)bandFrequency, bandGain);
		}

		public int SetLocalVoiceReverb(AUDIO_REVERB_TYPE reverbKey, int value)
		{
			return IRtcEngineNative.setLocalVoiceReverb((int)reverbKey, value);
		}

		public int SetCameraCapturerConfiguration(CameraCapturerConfiguration cameraCaptureConfiguration)
		{
			return IRtcEngineNative.setCameraCapturerConfiguration((int)cameraCaptureConfiguration.preference, (int)cameraCaptureConfiguration.cameraDirection);
		}

		public int SetRemoteUserPriority(uint uid, PRIORITY_TYPE userPriority)
		{
			return IRtcEngineNative.setRemoteUserPriority(uid, (int)userPriority);
		}

		public int SetLogFileSize(uint fileSizeInKBytes)
		{
			return IRtcEngineNative.setLogFileSize(fileSizeInKBytes);
		}

		public int SetExternalAudioSink(bool enabled, int sampleRate, int channels)
		{
			return IRtcEngineNative.setExternalAudioSink(enabled, sampleRate, channels);
		}

		public int RegisterLocalUserAccount(string appId, string userAccount)
		{
			return IRtcEngineNative.registerLocalUserAccount(appId, userAccount);
		}

		public int JoinChannelWithUserAccount(string token, string channelId, string userAccount)
		{
			return IRtcEngineNative.joinChannelWithUserAccount(token, channelId, userAccount);
		}

		public UserInfo GetUserInfoByUserAccount(string account)
		{
			int userInfoByUserAccount = IRtcEngineNative.getUserInfoByUserAccount(account);
			UserInfo result = default(UserInfo);
			result.userAccount = account;
			result.uid = (uint)userInfoByUserAccount;
			return result;
		}

		public UserInfo GetUserInfoByUid(uint uid)
		{
			IntPtr userInfoByUid = IRtcEngineNative.getUserInfoByUid(uid);
			UserInfo result = default(UserInfo);
			result.uid = uid;
			if (userInfoByUid != IntPtr.Zero)
			{
				result.userAccount = Marshal.PtrToStringAnsi(userInfoByUid);
				IRtcEngineNative.freeObject(userInfoByUid);
			}
			return result;
		}

		public int SetBeautyEffectOptions(bool enabled, BeautyOptions beautyOptions)
		{
			return IRtcEngineNative.setBeautyEffectOptions(enabled, (int)beautyOptions.lighteningContrastLevel, beautyOptions.lighteningLevel, beautyOptions.smoothnessLevel, beautyOptions.rednessLevel);
		}

		public int StartScreenCaptureByDisplayId(uint displayId, Rectangle rectangle, ScreenCaptureParameters screenCaptureParameters)
		{
			return IRtcEngineNative.startScreenCaptureByDisplayId(displayId, rectangle.x, rectangle.y, rectangle.width, rectangle.height, screenCaptureParameters.dimensions.width, screenCaptureParameters.dimensions.height, screenCaptureParameters.frameRate, screenCaptureParameters.bitrate, screenCaptureParameters.captureMouseCursor);
		}

		public int StartScreenCaptureByScreenRect(Rectangle screenRectangle, Rectangle regionRectangle, ScreenCaptureParameters screenCaptureParameters)
		{
			return IRtcEngineNative.startScreenCaptureByScreenRect(screenRectangle.x, screenRectangle.y, screenRectangle.width, screenRectangle.height, regionRectangle.x, regionRectangle.y, regionRectangle.width, regionRectangle.height, screenCaptureParameters.dimensions.width, screenCaptureParameters.dimensions.height, screenCaptureParameters.frameRate, screenCaptureParameters.bitrate, screenCaptureParameters.captureMouseCursor);
		}

		public int SetScreenCaptureContentHint(VideoContentHint videoContentHint)
		{
			return IRtcEngineNative.setScreenCaptureContentHint((int)videoContentHint);
		}

		public int UpdateScreenCaptureParameters(ScreenCaptureParameters screenCaptureParameters)
		{
			return IRtcEngineNative.updateScreenCaptureParameters(screenCaptureParameters.dimensions.width, screenCaptureParameters.dimensions.height, screenCaptureParameters.frameRate, screenCaptureParameters.bitrate, screenCaptureParameters.captureMouseCursor);
		}

		public int UpdateScreenCaptureRegion(Rectangle rectangle)
		{
			return IRtcEngineNative.updateScreenCaptureRegion(rectangle.x, rectangle.y, rectangle.width, rectangle.height);
		}

		public int StopScreenCapture()
		{
			return IRtcEngineNative.stopScreenCapture();
		}

		public int AddInjectStreamUrl(string url, InjectStreamConfig streamConfig)
		{
			return IRtcEngineNative.addInjectStreamUrl(url, streamConfig.width, streamConfig.height, streamConfig.videoGop, streamConfig.videoFramerate, streamConfig.videoBitrate, (int)streamConfig.audioSampleRate, streamConfig.audioBitrate, streamConfig.audioChannels);
		}

		public int RemoveInjectStreamUrl(string url)
		{
			return IRtcEngineNative.removeInjectStreamUrl(url);
		}

		public int EnableLoopbackRecording(bool enabled, string deviceName)
		{
			return IRtcEngineNative.enableLoopbackRecording(enabled, deviceName);
		}

		public int SetAudioSessionOperationRestriction(AUDIO_SESSION_OPERATION_RESTRICTION restriction)
		{
			return IRtcEngineNative.setAudioSessionOperationRestriction((int)restriction);
		}

		public int StartChannelMediaRelay(ChannelMediaRelayConfiguration mediaRelayConfiguration)
		{
			return IRtcEngineNative.startChannelMediaRelay(mediaRelayConfiguration.srcInfo.channelName, mediaRelayConfiguration.srcInfo.token, mediaRelayConfiguration.srcInfo.uid, mediaRelayConfiguration.destInfos.channelName, mediaRelayConfiguration.destInfos.token, mediaRelayConfiguration.destInfos.uid, mediaRelayConfiguration.destCount);
		}

		public int UpdateChannelMediaRelay(ChannelMediaRelayConfiguration mediaRelayConfiguration)
		{
			return IRtcEngineNative.updateChannelMediaRelay(mediaRelayConfiguration.srcInfo.channelName, mediaRelayConfiguration.srcInfo.token, mediaRelayConfiguration.srcInfo.uid, mediaRelayConfiguration.destInfos.channelName, mediaRelayConfiguration.destInfos.token, mediaRelayConfiguration.destInfos.uid, mediaRelayConfiguration.destCount);
		}

		public int StopChannelMediaRelay()
		{
			return IRtcEngineNative.stopChannelMediaRelay();
		}

		public int SwitchChannel(string token, string channelId)
		{
			return IRtcEngineNative.switchChannel(token, channelId);
		}

		public int SetMultiChannelWant(bool multiChannelWant)
		{
			return IRtcEngineNative.setMultiChannelWant(multiChannelWant);
		}

		public int SetMirrorApplied(bool wheatherApply)
		{
			return IRtcEngineNative.setMirrorApplied(wheatherApply);
		}

		public int SetInEarMonitoringVolume(int volume)
		{
			return IRtcEngineNative.setInEarMonitoringVolume(volume);
		}

		public int StartScreenCaptureByWindowId(int windowId, Rectangle regionRect, ScreenCaptureParameters screenCaptureParameters)
		{
			return IRtcEngineNative.startScreenCaptureByWindowId(windowId, regionRect.x, regionRect.y, regionRect.width, regionRect.height, screenCaptureParameters.dimensions.width, screenCaptureParameters.dimensions.height, screenCaptureParameters.frameRate, screenCaptureParameters.bitrate, screenCaptureParameters.captureMouseCursor);
		}

		public int EnableInEarMonitoring(bool enabled)
		{
			return IRtcEngineNative.enableInEarMonitoring(enabled);
		}

		public int AdjustUserPlaybackSignalVolume(uint uid, int volume)
		{
			return IRtcEngineNative.adjustUserPlaybackSignalVolume(uid, volume);
		}

		public AgoraChannel CreateChannel(string channelId)
		{
			return AgoraChannel.CreateChannel(this, channelId);
		}

		public int EnableFaceDetection(bool enable)
		{
			return IRtcEngineNative.enableFaceDetection(enable);
		}

		public int SetAudioMixingPitch(int pitch)
		{
			return IRtcEngineNative.setAudioMixingPitch(pitch);
		}

		public static IRtcEngine GetEngine(string appId)
		{
			if (instance == null)
			{
				instance = new IRtcEngine(appId);
			}
			return instance;
		}

		public static IRtcEngine GetEngine(RtcEngineConfig engineConfig)
		{
			if (instance == null)
			{
				instance = new IRtcEngine(engineConfig);
			}
			return instance;
		}

		public static IRtcEngine getEngine(string appId)
		{
			return GetEngine(appId);
		}

		public static void Destroy()
		{
			if (instance != null)
			{
				AudioEffectManagerImpl audioEffectManagerImpl = (AudioEffectManagerImpl)instance.GetAudioEffectManager();
				if (audioEffectManagerImpl != null)
				{
					audioEffectManagerImpl.SetEngine(null);
					AudioEffectManagerImpl.ReleaseInstance();
				}
				AudioRecordingDeviceManager audioRecordingDeviceManager = (AudioRecordingDeviceManager)instance.GetAudioRecordingDeviceManager();
				if (audioRecordingDeviceManager != null)
				{
					audioRecordingDeviceManager.SetEngine(null);
					AudioRecordingDeviceManager.ReleaseInstance();
				}
				AudioPlaybackDeviceManager audioPlaybackDeviceManager = (AudioPlaybackDeviceManager)instance.GetAudioPlaybackDeviceManager();
				if (audioPlaybackDeviceManager != null)
				{
					audioPlaybackDeviceManager.SetEngine(null);
					AudioPlaybackDeviceManager.ReleaseInstance();
				}
				VideoDeviceManager videoDeviceManager = (VideoDeviceManager)instance.GetVideoDeviceManager();
				if (videoDeviceManager != null)
				{
					videoDeviceManager.SetEngine(null);
					VideoDeviceManager.ReleaseInstance();
				}
				AudioRawDataManager audioRawDataManager = (AudioRawDataManager)instance.GetAudioRawDataManager();
				if (audioRawDataManager != null)
				{
					audioRawDataManager.SetEngine(null);
					AudioRawDataManager.ReleaseInstance();
				}
				VideoRawDataManager videoRawDataManager = (VideoRawDataManager)instance.GetVideoRawDataManager();
				if (videoRawDataManager != null)
				{
					videoRawDataManager.SetEngine(null);
					VideoRawDataManager.ReleaseInstance();
				}
				VideoRender videoRender = (VideoRender)instance.GetVideoRender();
				if (videoRender != null)
				{
					videoRender.SetEngine(null);
					VideoRender.ReleaseInstance();
				}
			}
			IRtcEngineNative.deleteEngine();
			AgoraChannel.Release();
			if (instance != null)
			{
				instance.DeInitGameObject();
			}
			instance = null;
			GC.Collect();
		}

		public static IRtcEngine QueryEngine()
		{
			return instance;
		}

		[MonoPInvokeCallback(typeof(OnJoinChannelSuccessHandler))]
		private static void OnJoinChannelSuccessCallback(string channel, uint uid, int elapsed)
		{
			if (instance == null || instance.OnJoinChannelSuccess == null || instance._AgoraCallbackObject == null)
			{
				return;
			}
			instance._AgoraCallbackObject._CallbackQueue?.EnQueue(delegate
			{
				if (instance != null && instance.OnJoinChannelSuccess != null)
				{
					instance.OnJoinChannelSuccess(channel, uid, elapsed);
				}
			});
		}

		[MonoPInvokeCallback(typeof(EngineEventOnLeaveChannelHandler))]
		private static void OnLeaveChannelCallback(uint duration, uint txBytes, uint rxBytes, uint txAudioBytes, uint txVideoBytes, uint rxAudioBytes, uint rxVideoBytes, ushort txKBitRate, ushort rxKBitRate, ushort rxAudioKBitRate, ushort txAudioKBitRate, ushort rxVideoKBitRate, ushort txVideoKBitRate, ushort lastmileDelay, ushort txPacketLossRate, ushort rxPacketLossRate, uint userCount, double cpuAppUsage, double cpuTotalUsage, int gatewayRtt, double memoryAppUsageRatio, double memoryTotalUsageRatio, int memoryAppUsageInKbytes)
		{
			if (instance == null || instance.OnLeaveChannel == null || instance._AgoraCallbackObject == null)
			{
				return;
			}
			instance._AgoraCallbackObject._CallbackQueue?.EnQueue(delegate
			{
				if (instance != null && instance.OnLeaveChannel != null)
				{
					RtcStats stats = default(RtcStats);
					stats.duration = duration;
					stats.txBytes = txBytes;
					stats.rxBytes = rxBytes;
					stats.txAudioBytes = txAudioBytes;
					stats.txVideoBytes = txVideoBytes;
					stats.rxAudioBytes = rxAudioBytes;
					stats.rxVideoBytes = rxVideoBytes;
					stats.txKBitRate = txKBitRate;
					stats.rxKBitRate = rxKBitRate;
					stats.rxAudioKBitRate = rxAudioKBitRate;
					stats.txAudioKBitRate = txAudioKBitRate;
					stats.rxVideoKBitRate = rxVideoKBitRate;
					stats.txVideoKBitRate = txVideoKBitRate;
					stats.lastmileDelay = lastmileDelay;
					stats.txPacketLossRate = txPacketLossRate;
					stats.rxPacketLossRate = rxPacketLossRate;
					stats.userCount = userCount;
					stats.cpuAppUsage = cpuAppUsage;
					stats.cpuTotalUsage = cpuTotalUsage;
					stats.gatewayRtt = gatewayRtt;
					stats.memoryAppUsageRatio = memoryAppUsageRatio;
					stats.memoryTotalUsageRatio = memoryTotalUsageRatio;
					stats.memoryAppUsageInKbytes = memoryAppUsageInKbytes;
					instance.OnLeaveChannel(stats);
				}
			});
		}

		[MonoPInvokeCallback(typeof(OnReJoinChannelSuccessHandler))]
		private static void OnReJoinChannelSuccessCallback(string channelName, uint uid, int elapsed)
		{
			if (instance == null || instance.OnReJoinChannelSuccess == null || instance._AgoraCallbackObject == null)
			{
				return;
			}
			instance._AgoraCallbackObject._CallbackQueue?.EnQueue(delegate
			{
				if (instance != null && instance.OnReJoinChannelSuccess != null)
				{
					instance.OnReJoinChannelSuccess(channelName, uid, elapsed);
				}
			});
		}

		[MonoPInvokeCallback(typeof(OnConnectionLostHandler))]
		private static void OnConnectionLostCallback()
		{
			if (instance == null || instance.OnConnectionLost == null || instance._AgoraCallbackObject == null)
			{
				return;
			}
			instance._AgoraCallbackObject._CallbackQueue?.EnQueue(delegate
			{
				if (instance != null && instance.OnConnectionLost != null)
				{
					instance.OnConnectionLost();
				}
			});
		}

		[MonoPInvokeCallback(typeof(OnConnectionInterruptedHandler))]
		private static void OnConnectionInterruptedCallback()
		{
			if (instance == null || instance.OnConnectionInterrupted == null || instance._AgoraCallbackObject == null)
			{
				return;
			}
			instance._AgoraCallbackObject._CallbackQueue?.EnQueue(delegate
			{
				if (instance != null && instance.OnConnectionInterrupted != null)
				{
					instance.OnConnectionInterrupted();
				}
			});
		}

		[MonoPInvokeCallback(typeof(OnRequestTokenHandler))]
		private static void OnRequestTokenCallback()
		{
			if (instance == null || instance.OnRequestToken == null || instance._AgoraCallbackObject == null)
			{
				return;
			}
			instance._AgoraCallbackObject._CallbackQueue?.EnQueue(delegate
			{
				if (instance != null && instance.OnRequestToken != null)
				{
					instance.OnRequestToken();
				}
			});
		}

		[MonoPInvokeCallback(typeof(OnUserJoinedHandler))]
		private static void OnUserJoinedCallback(uint uid, int elapsed)
		{
			if (instance == null || instance.OnUserJoined == null || instance._AgoraCallbackObject == null)
			{
				return;
			}
			instance._AgoraCallbackObject._CallbackQueue?.EnQueue(delegate
			{
				if (instance != null && instance.OnUserJoined != null)
				{
					instance.OnUserJoined(uid, elapsed);
				}
			});
		}

		[MonoPInvokeCallback(typeof(EngineEventOnUserOfflineHandler))]
		private static void OnUserOfflineCallback(uint uid, int reason)
		{
			if (instance == null || instance.OnUserOffline == null || instance._AgoraCallbackObject == null)
			{
				return;
			}
			instance._AgoraCallbackObject._CallbackQueue?.EnQueue(delegate
			{
				if (instance != null && instance.OnUserOffline != null)
				{
					instance.OnUserOffline(uid, (USER_OFFLINE_REASON)reason);
				}
			});
		}

		[MonoPInvokeCallback(typeof(EngineEventOnAudioVolumeIndicationHandler))]
		private static void OnAudioVolumeIndicationCallback(string volumeInfo, int speakerNumber, int totalVolume)
		{
			if (instance == null || instance.OnVolumeIndication == null || instance._AgoraCallbackObject == null)
			{
				return;
			}
			instance._AgoraCallbackObject._CallbackQueue?.EnQueue(delegate
			{
				if (instance != null && instance.OnVolumeIndication != null)
				{
					string[] array = volumeInfo.Split('\t');
					int num = 1;
					AudioVolumeInfo[] array2 = new AudioVolumeInfo[speakerNumber];
					if (speakerNumber > 0)
					{
						for (int i = 0; i < speakerNumber; i++)
						{
							uint uid = (uint)int.Parse(array[num++]);
							uint volume = (uint)int.Parse(array[num++]);
							uint vad = (uint)int.Parse(array[num++]);
							string text = array[num++];
							array2[i].uid = uid;
							array2[i].volume = volume;
							array2[i].vad = vad;
							array2[i].channelId = text;
						}
					}
					instance.OnVolumeIndication(array2, speakerNumber, totalVolume);
				}
			});
		}

		[MonoPInvokeCallback(typeof(OnUserMutedAudioHandler))]
		private static void OnUserMuteAudioCallback(uint uid, bool muted)
		{
			if (instance == null || instance.OnUserMutedAudio == null || instance._AgoraCallbackObject == null)
			{
				return;
			}
			instance._AgoraCallbackObject._CallbackQueue?.EnQueue(delegate
			{
				if (instance != null && instance.OnUserMutedAudio != null)
				{
					instance.OnUserMutedAudio(uid, muted);
				}
			});
		}

		[MonoPInvokeCallback(typeof(OnSDKWarningHandler))]
		private static void OnSDKWarningCallback(int warn, string msg)
		{
			if (instance == null || instance.OnWarning == null || instance._AgoraCallbackObject == null)
			{
				return;
			}
			instance._AgoraCallbackObject._CallbackQueue?.EnQueue(delegate
			{
				if (instance != null && instance.OnWarning != null)
				{
					instance.OnWarning(warn, msg);
				}
			});
		}

		[MonoPInvokeCallback(typeof(OnSDKErrorHandler))]
		private static void OnSDKErrorCallback(int error, string msg)
		{
			if (instance == null || instance.OnError == null || instance._AgoraCallbackObject == null)
			{
				return;
			}
			instance._AgoraCallbackObject._CallbackQueue?.EnQueue(delegate
			{
				if (instance != null && instance.OnError != null)
				{
					instance.OnError(error, msg);
				}
			});
		}

		[MonoPInvokeCallback(typeof(EngineEventOnRtcStatsHandler))]
		private static void OnRtcStatsCallback(uint duration, uint txBytes, uint rxBytes, uint txAudioBytes, uint txVideoBytes, uint rxAudioBytes, uint rxVideoBytes, ushort txKBitRate, ushort rxKBitRate, ushort rxAudioKBitRate, ushort txAudioKBitRate, ushort rxVideoKBitRate, ushort txVideoKBitRate, ushort lastmileDelay, ushort txPacketLossRate, ushort rxPacketLossRate, uint userCount, double cpuAppUsage, double cpuTotalUsage, int gatewayRtt, double memoryAppUsageRatio, double memoryTotalUsageRatio, int memoryAppUsageInKbytes)
		{
			if (instance == null || instance.OnRtcStats == null || instance._AgoraCallbackObject == null)
			{
				return;
			}
			instance._AgoraCallbackObject._CallbackQueue?.EnQueue(delegate
			{
				if (instance != null && instance.OnRtcStats != null)
				{
					RtcStats stats = default(RtcStats);
					stats.duration = duration;
					stats.txBytes = txBytes;
					stats.rxBytes = rxBytes;
					stats.txAudioBytes = txAudioBytes;
					stats.txVideoBytes = txVideoBytes;
					stats.rxAudioBytes = rxAudioBytes;
					stats.rxVideoBytes = rxVideoBytes;
					stats.txKBitRate = txKBitRate;
					stats.rxKBitRate = rxKBitRate;
					stats.rxAudioKBitRate = rxAudioKBitRate;
					stats.txAudioKBitRate = txAudioKBitRate;
					stats.rxVideoKBitRate = rxVideoKBitRate;
					stats.txVideoKBitRate = txVideoKBitRate;
					stats.lastmileDelay = lastmileDelay;
					stats.txPacketLossRate = txPacketLossRate;
					stats.rxPacketLossRate = rxPacketLossRate;
					stats.userCount = userCount;
					stats.cpuAppUsage = cpuAppUsage;
					stats.cpuTotalUsage = cpuTotalUsage;
					stats.gatewayRtt = gatewayRtt;
					stats.memoryAppUsageRatio = memoryAppUsageRatio;
					stats.memoryTotalUsageRatio = memoryTotalUsageRatio;
					stats.memoryAppUsageInKbytes = memoryAppUsageInKbytes;
					instance.OnRtcStats(stats);
				}
			});
		}

		[MonoPInvokeCallback(typeof(OnAudioMixingFinishedHandler))]
		private static void OnAudioMixingFinishedCallback()
		{
			if (instance == null || instance.OnAudioMixingFinished == null || instance._AgoraCallbackObject == null)
			{
				return;
			}
			instance._AgoraCallbackObject._CallbackQueue?.EnQueue(delegate
			{
				if (instance != null && instance.OnAudioMixingFinished != null)
				{
					instance.OnAudioMixingFinished();
				}
			});
		}

		[MonoPInvokeCallback(typeof(EngineEventOnAudioRouteChangedHandler))]
		private static void OnAudioRouteChangedCallback(int route)
		{
			if (instance == null || instance.OnAudioRouteChanged == null || instance._AgoraCallbackObject == null)
			{
				return;
			}
			instance._AgoraCallbackObject._CallbackQueue?.EnQueue(delegate
			{
				if (instance != null && instance.OnAudioRouteChanged != null)
				{
					instance.OnAudioRouteChanged((AUDIO_ROUTE)route);
				}
			});
		}

		[MonoPInvokeCallback(typeof(OnFirstRemoteVideoDecodedHandler))]
		private static void OnFirstRemoteVideoDecodedCallback(uint uid, int width, int height, int elapsed)
		{
			if (instance == null || instance.OnFirstRemoteVideoDecoded == null || instance._AgoraCallbackObject == null)
			{
				return;
			}
			instance._AgoraCallbackObject._CallbackQueue?.EnQueue(delegate
			{
				if (instance != null && instance.OnFirstRemoteVideoDecoded != null)
				{
					instance.OnFirstRemoteVideoDecoded(uid, width, height, elapsed);
				}
			});
		}

		[MonoPInvokeCallback(typeof(OnVideoSizeChangedHandler))]
		private static void OnVideoSizeChangedCallback(uint uid, int width, int height, int rotation)
		{
			if (instance == null || instance.OnVideoSizeChanged == null || instance._AgoraCallbackObject == null)
			{
				return;
			}
			instance._AgoraCallbackObject._CallbackQueue?.EnQueue(delegate
			{
				if (instance != null && instance.OnVideoSizeChanged != null)
				{
					instance.OnVideoSizeChanged(uid, width, height, rotation);
				}
			});
		}

		[MonoPInvokeCallback(typeof(EngineEventOnClientRoleChanged))]
		private static void OnClientRoleChangedCallback(int oldRole, int newRole)
		{
			if (instance == null || instance.OnClientRoleChanged == null || instance._AgoraCallbackObject == null)
			{
				return;
			}
			instance._AgoraCallbackObject._CallbackQueue?.EnQueue(delegate
			{
				if (instance != null && instance.OnClientRoleChanged != null)
				{
					instance.OnClientRoleChanged((CLIENT_ROLE_TYPE)oldRole, (CLIENT_ROLE_TYPE)newRole);
				}
			});
		}

		[MonoPInvokeCallback(typeof(OnUserMuteVideoHandler))]
		private static void OnUserMuteVideoCallback(uint uid, bool muted)
		{
			if (instance == null || instance.OnUserMuteVideo == null || instance._AgoraCallbackObject == null)
			{
				return;
			}
			instance._AgoraCallbackObject._CallbackQueue?.EnQueue(delegate
			{
				if (instance != null && instance.OnUserMuteVideo != null)
				{
					instance.OnUserMuteVideo(uid, muted);
				}
			});
		}

		[MonoPInvokeCallback(typeof(OnMicrophoneEnabledHandler))]
		private static void OnMicrophoneEnabledCallback(bool isEnabled)
		{
			if (instance == null || instance.OnMicrophoneEnabled == null || instance._AgoraCallbackObject == null)
			{
				return;
			}
			instance._AgoraCallbackObject._CallbackQueue?.EnQueue(delegate
			{
				if (instance != null && instance.OnMicrophoneEnabled != null)
				{
					instance.OnMicrophoneEnabled(isEnabled);
				}
			});
		}

		[MonoPInvokeCallback(typeof(OnApiExecutedHandler))]
		private static void OnApiExecutedCallback(int err, string api, string result)
		{
			if (instance == null || instance.OnApiExecuted == null || instance._AgoraCallbackObject == null)
			{
				return;
			}
			instance._AgoraCallbackObject._CallbackQueue?.EnQueue(delegate
			{
				if (instance != null && instance.OnApiExecuted != null)
				{
					instance.OnApiExecuted(err, api, result);
				}
			});
		}

		[MonoPInvokeCallback(typeof(OnFirstLocalAudioFrameHandler))]
		private static void OnFirstLocalAudioFrameCallback(int elapsed)
		{
			if (instance == null || instance.OnFirstLocalAudioFrame == null || instance._AgoraCallbackObject == null)
			{
				return;
			}
			instance._AgoraCallbackObject._CallbackQueue?.EnQueue(delegate
			{
				if (instance != null && instance.OnFirstLocalAudioFrame != null)
				{
					instance.OnFirstLocalAudioFrame(elapsed);
				}
			});
		}

		[MonoPInvokeCallback(typeof(OnFirstRemoteAudioFrameHandler))]
		private static void OnFirstRemoteAudioFrameCallback(uint userId, int elapsed)
		{
			if (instance == null || instance.OnFirstRemoteAudioFrame == null || instance._AgoraCallbackObject == null)
			{
				return;
			}
			instance._AgoraCallbackObject._CallbackQueue?.EnQueue(delegate
			{
				if (instance != null && instance.OnFirstRemoteAudioFrame != null)
				{
					instance.OnFirstRemoteAudioFrame(userId, elapsed);
				}
			});
		}

		[MonoPInvokeCallback(typeof(OnLastmileQualityHandler))]
		private static void OnLastmileQualityCallback(int quality)
		{
			if (instance == null || instance.OnLastmileQuality == null || instance._AgoraCallbackObject == null)
			{
				return;
			}
			instance._AgoraCallbackObject._CallbackQueue?.EnQueue(delegate
			{
				if (instance != null && instance.OnLastmileQuality != null)
				{
					instance.OnLastmileQuality(quality);
				}
			});
		}

		[MonoPInvokeCallback(typeof(OnAudioQualityHandler))]
		private static void OnAudioQualityCallback(uint userId, int quality, ushort delay, ushort lost)
		{
			if (instance == null || instance.OnAudioQuality == null || instance._AgoraCallbackObject == null)
			{
				return;
			}
			instance._AgoraCallbackObject._CallbackQueue?.EnQueue(delegate
			{
				if (instance != null && instance.OnAudioQuality != null)
				{
					instance.OnAudioQuality(userId, quality, delay, lost);
				}
			});
		}

		[MonoPInvokeCallback(typeof(OnStreamInjectedStatusHandler))]
		private static void OnStreamInjectedStatusCallback(string url, uint userId, int status)
		{
			if (instance == null || instance.OnStreamInjectedStatus == null || instance._AgoraCallbackObject == null)
			{
				return;
			}
			instance._AgoraCallbackObject._CallbackQueue?.EnQueue(delegate
			{
				if (instance != null && instance.OnStreamInjectedStatus != null)
				{
					instance.OnStreamInjectedStatus(url, userId, status);
				}
			});
		}

		[MonoPInvokeCallback(typeof(OnStreamUnpublishedHandler))]
		private static void OnStreamUnpublishedCallback(string url)
		{
			if (instance == null || instance.OnStreamUnpublished == null || instance._AgoraCallbackObject == null)
			{
				return;
			}
			instance._AgoraCallbackObject._CallbackQueue?.EnQueue(delegate
			{
				if (instance != null && instance.OnStreamUnpublished != null)
				{
					instance.OnStreamUnpublished(url);
				}
			});
		}

		[MonoPInvokeCallback(typeof(OnStreamPublishedHandler))]
		private static void OnStreamPublishedCallback(string url, int error)
		{
			if (instance == null || instance.OnStreamPublished == null || instance._AgoraCallbackObject == null)
			{
				return;
			}
			instance._AgoraCallbackObject._CallbackQueue?.EnQueue(delegate
			{
				if (instance != null && instance.OnStreamPublished != null)
				{
					instance.OnStreamPublished(url, error);
				}
			});
		}

		[MonoPInvokeCallback(typeof(OnStreamMessageErrorHandler))]
		private static void OnStreamMessageErrorCallback(uint userId, int streamId, int code, int missed, int cached)
		{
			if (instance == null || instance.OnStreamMessageError == null || instance._AgoraCallbackObject == null)
			{
				return;
			}
			instance._AgoraCallbackObject._CallbackQueue?.EnQueue(delegate
			{
				if (instance != null && instance.OnStreamMessageError != null)
				{
					instance.OnStreamMessageError(userId, streamId, code, missed, cached);
				}
			});
		}

		[MonoPInvokeCallback(typeof(EngineEventOnStreamMessageHandler))]
		private static void OnStreamMessageCallback(uint userId, int streamId, IntPtr data, int length)
		{
			if (instance == null || instance.OnStreamMessage == null || instance._AgoraCallbackObject == null)
			{
				return;
			}
			byte[] byteBuffer = null;
			if (length > 0 && data != IntPtr.Zero)
			{
				byteBuffer = new byte[length];
				Marshal.Copy(data, byteBuffer, 0, length);
			}
			instance._AgoraCallbackObject._CallbackQueue?.EnQueue(delegate
			{
				if (instance != null && instance.OnStreamMessage != null)
				{
					instance.OnStreamMessage(userId, streamId, byteBuffer, length);
				}
			});
		}

		[MonoPInvokeCallback(typeof(OnConnectionBannedHandler))]
		private static void OnConnectionBannedCallback()
		{
			if (instance == null || instance.OnConnectionBanned == null || instance._AgoraCallbackObject == null)
			{
				return;
			}
			instance._AgoraCallbackObject._CallbackQueue?.EnQueue(delegate
			{
				if (instance != null && instance.OnConnectionBanned != null)
				{
					instance.OnConnectionBanned();
				}
			});
		}

		[MonoPInvokeCallback(typeof(EngineEventOnConnectionStateChanged))]
		private static void OnConnectionStateChangedCallback(int state, int reason)
		{
			if (instance == null || instance.OnConnectionStateChanged == null || instance._AgoraCallbackObject == null)
			{
				return;
			}
			instance._AgoraCallbackObject._CallbackQueue?.EnQueue(delegate
			{
				if (instance != null && instance.OnConnectionStateChanged != null)
				{
					instance.OnConnectionStateChanged((CONNECTION_STATE_TYPE)state, (CONNECTION_CHANGED_REASON_TYPE)reason);
				}
			});
		}

		[MonoPInvokeCallback(typeof(OnTokenPrivilegeWillExpireHandler))]
		private static void OnTokenPrivilegeWillExpireCallback(string token)
		{
			if (instance == null || instance.OnTokenPrivilegeWillExpire == null || instance._AgoraCallbackObject == null)
			{
				return;
			}
			instance._AgoraCallbackObject._CallbackQueue?.EnQueue(delegate
			{
				if (instance != null && instance.OnTokenPrivilegeWillExpire != null)
				{
					instance.OnTokenPrivilegeWillExpire(token);
				}
			});
		}

		[MonoPInvokeCallback(typeof(OnActiveSpeakerHandler))]
		private static void OnActiveSpeakerCallback(uint uid)
		{
			if (instance == null || instance.OnActiveSpeaker == null || instance._AgoraCallbackObject == null)
			{
				return;
			}
			instance._AgoraCallbackObject._CallbackQueue?.EnQueue(delegate
			{
				if (instance != null && instance.OnActiveSpeaker != null)
				{
					instance.OnActiveSpeaker(uid);
				}
			});
		}

		[MonoPInvokeCallback(typeof(OnVideoStoppedHandler))]
		private static void OnVideoStoppedCallback()
		{
			if (instance == null || instance.OnVideoStopped == null || instance._AgoraCallbackObject == null)
			{
				return;
			}
			instance._AgoraCallbackObject._CallbackQueue?.EnQueue(delegate
			{
				if (instance != null && instance.OnVideoStopped != null)
				{
					instance.OnVideoStopped();
				}
			});
		}

		[MonoPInvokeCallback(typeof(OnFirstLocalVideoFrameHandler))]
		private static void OnFirstLocalVideoFrameCallback(int width, int height, int elapsed)
		{
			if (instance == null || instance.OnFirstLocalVideoFrame == null || instance._AgoraCallbackObject == null)
			{
				return;
			}
			instance._AgoraCallbackObject._CallbackQueue?.EnQueue(delegate
			{
				if (instance != null && instance.OnFirstLocalVideoFrame != null)
				{
					instance.OnFirstLocalVideoFrame(width, height, elapsed);
				}
			});
		}

		[MonoPInvokeCallback(typeof(OnFirstRemoteVideoFrameHandler))]
		private static void OnFirstRemoteVideoFrameCallback(uint uid, int width, int height, int elapsed)
		{
			if (instance == null || instance.OnFirstRemoteVideoFrame == null || instance._AgoraCallbackObject == null)
			{
				return;
			}
			instance._AgoraCallbackObject._CallbackQueue?.EnQueue(delegate
			{
				if (instance != null && instance.OnFirstRemoteVideoFrame != null)
				{
					instance.OnFirstRemoteVideoFrame(uid, width, height, elapsed);
				}
			});
		}

		[MonoPInvokeCallback(typeof(OnUserEnableVideoHandler))]
		private static void OnUserEnableVideoCallback(uint uid, bool enabled)
		{
			if (instance == null || instance.OnUserEnableVideo == null || instance._AgoraCallbackObject == null)
			{
				return;
			}
			instance._AgoraCallbackObject._CallbackQueue?.EnQueue(delegate
			{
				if (instance != null && instance.OnUserEnableVideo != null)
				{
					instance.OnUserEnableVideo(uid, enabled);
				}
			});
		}

		[MonoPInvokeCallback(typeof(OnUserEnableLocalVideoHandler))]
		private static void OnUserEnableLocalVideoCallback(uint uid, bool enabled)
		{
			if (instance == null || instance.OnUserEnableLocalVideo == null || instance._AgoraCallbackObject == null)
			{
				return;
			}
			instance._AgoraCallbackObject._CallbackQueue?.EnQueue(delegate
			{
				if (instance != null && instance.OnUserEnableLocalVideo != null)
				{
					instance.OnUserEnableLocalVideo(uid, enabled);
				}
			});
		}

		[MonoPInvokeCallback(typeof(EngineEventOnRemoteVideoStateChanged))]
		private static void OnRemoteVideoStateChangedCallback(uint uid, int state, int reason, int elapsed)
		{
			if (instance == null || instance.OnRemoteVideoStateChanged == null || instance._AgoraCallbackObject == null)
			{
				return;
			}
			instance._AgoraCallbackObject._CallbackQueue?.EnQueue(delegate
			{
				if (instance != null && instance.OnRemoteVideoStateChanged != null)
				{
					instance.OnRemoteVideoStateChanged(uid, (REMOTE_VIDEO_STATE)state, (REMOTE_VIDEO_STATE_REASON)reason, elapsed);
				}
			});
		}

		[MonoPInvokeCallback(typeof(OnLocalPublishFallbackToAudioOnlyHandler))]
		private static void OnLocalPublishFallbackToAudioOnlyCallback(bool isFallbackOrRecover)
		{
			if (instance == null || instance.OnLocalPublishFallbackToAudioOnly == null || instance._AgoraCallbackObject == null)
			{
				return;
			}
			instance._AgoraCallbackObject._CallbackQueue?.EnQueue(delegate
			{
				if (instance != null && instance.OnLocalPublishFallbackToAudioOnly != null)
				{
					instance.OnLocalPublishFallbackToAudioOnly(isFallbackOrRecover);
				}
			});
		}

		[MonoPInvokeCallback(typeof(OnRemoteSubscribeFallbackToAudioOnlyHandler))]
		private static void OnRemoteSubscribeFallbackToAudioOnlyCallback(uint uid, bool isFallbackOrRecover)
		{
			if (instance == null || instance.OnRemoteSubscribeFallbackToAudioOnly == null || instance._AgoraCallbackObject == null)
			{
				return;
			}
			instance._AgoraCallbackObject._CallbackQueue?.EnQueue(delegate
			{
				if (instance != null && instance.OnRemoteSubscribeFallbackToAudioOnly != null)
				{
					instance.OnRemoteSubscribeFallbackToAudioOnly(uid, isFallbackOrRecover);
				}
			});
		}

		[MonoPInvokeCallback(typeof(OnNetworkQualityHandler))]
		private static void OnNetworkQualityCallback(uint uid, int txQuality, int rxQuality)
		{
			if (instance == null || instance.OnNetworkQuality == null || instance._AgoraCallbackObject == null)
			{
				return;
			}
			instance._AgoraCallbackObject._CallbackQueue?.EnQueue(delegate
			{
				if (instance != null && instance.OnNetworkQuality != null)
				{
					instance.OnNetworkQuality(uid, txQuality, rxQuality);
				}
			});
		}

		[MonoPInvokeCallback(typeof(EngineEventOnLocalVideoStatsHandler))]
		private static void OnLocalVideoStatsCallback(int sentBitrate, int sentFrameRate, int encoderOutputFrameRate, int rendererOutputFrameRate, int targetBitrate, int targetFrameRate, int qualityAdaptIndication, int encodedBitrate, int encodedFrameWidth, int encodedFrameHeight, int encodedFrameCount, int codecType)
		{
			if (instance == null || instance.OnLocalVideoStats == null || instance._AgoraCallbackObject == null)
			{
				return;
			}
			instance._AgoraCallbackObject._CallbackQueue?.EnQueue(delegate
			{
				if (instance != null && instance.OnLocalVideoStats != null)
				{
					LocalVideoStats localVideoStats = default(LocalVideoStats);
					localVideoStats.sentBitrate = sentBitrate;
					localVideoStats.sentFrameRate = sentFrameRate;
					localVideoStats.encoderOutputFrameRate = encoderOutputFrameRate;
					localVideoStats.rendererOutputFrameRate = rendererOutputFrameRate;
					localVideoStats.targetBitrate = targetBitrate;
					localVideoStats.targetFrameRate = targetFrameRate;
					localVideoStats.qualityAdaptIndication = (QUALITY_ADAPT_INDICATION)qualityAdaptIndication;
					localVideoStats.encodedBitrate = encodedBitrate;
					localVideoStats.encodedFrameWidth = encodedFrameWidth;
					localVideoStats.encodedFrameHeight = encodedFrameHeight;
					localVideoStats.encodedFrameCount = encodedFrameCount;
					localVideoStats.codecType = (VIDEO_CODEC_TYPE)codecType;
					instance.OnLocalVideoStats(localVideoStats);
				}
			});
		}

		[MonoPInvokeCallback(typeof(EngineEventOnRemoteVideoStatsHandler))]
		private static void OnRemoteVideoStatsCallback(uint uid, int delay, int width, int height, int receivedBitrate, int decoderOutputFrameRate, int rendererOutputFrameRate, int packetLossRate, int rxStreamType, int totalFrozenTime, int frozenRate, int totalActiveTime)
		{
			if (instance == null || instance.OnRemoteVideoStats == null || instance._AgoraCallbackObject == null)
			{
				return;
			}
			instance._AgoraCallbackObject._CallbackQueue?.EnQueue(delegate
			{
				if (instance != null && instance.OnRemoteVideoStats != null)
				{
					RemoteVideoStats remoteVideoStats = default(RemoteVideoStats);
					remoteVideoStats.uid = uid;
					remoteVideoStats.delay = delay;
					remoteVideoStats.width = width;
					remoteVideoStats.height = height;
					remoteVideoStats.receivedBitrate = receivedBitrate;
					remoteVideoStats.decoderOutputFrameRate = decoderOutputFrameRate;
					remoteVideoStats.rendererOutputFrameRate = rendererOutputFrameRate;
					remoteVideoStats.packetLossRate = packetLossRate;
					remoteVideoStats.rxStreamType = (REMOTE_VIDEO_STREAM_TYPE)rxStreamType;
					remoteVideoStats.totalFrozenTime = totalFrozenTime;
					remoteVideoStats.frozenRate = frozenRate;
					remoteVideoStats.totalActiveTime = totalActiveTime;
					instance.OnRemoteVideoStats(remoteVideoStats);
				}
			});
		}

		[MonoPInvokeCallback(typeof(EngineEventOnRemoteAudioStatsHandler))]
		private static void OnRemoteAudioStatsCallback(uint uid, int quality, int networkTransportDelay, int jitterBufferDelay, int audioLossRate, int numChannels, int receivedSampleRate, int receivedBitrate, int totalFrozenTime, int frozenRate, int totalActiveTime)
		{
			if (instance == null || instance.OnRemoteAudioStats == null || instance._AgoraCallbackObject == null)
			{
				return;
			}
			instance._AgoraCallbackObject._CallbackQueue?.EnQueue(delegate
			{
				if (instance != null && instance.OnRemoteAudioStats != null)
				{
					RemoteAudioStats remoteAudioStats = default(RemoteAudioStats);
					remoteAudioStats.uid = uid;
					remoteAudioStats.quality = quality;
					remoteAudioStats.networkTransportDelay = networkTransportDelay;
					remoteAudioStats.jitterBufferDelay = jitterBufferDelay;
					remoteAudioStats.audioLossRate = audioLossRate;
					remoteAudioStats.numChannels = numChannels;
					remoteAudioStats.receivedSampleRate = receivedSampleRate;
					remoteAudioStats.receivedBitrate = receivedBitrate;
					remoteAudioStats.totalFrozenTime = totalFrozenTime;
					remoteAudioStats.frozenRate = frozenRate;
					remoteAudioStats.totalActiveTime = totalActiveTime;
					instance.OnRemoteAudioStats(remoteAudioStats);
				}
			});
		}

		[MonoPInvokeCallback(typeof(OnAudioDeviceStateChangedHandler))]
		private static void OnAudioDeviceStateChangedCallback(string deviceId, int deviceType, int deviceState)
		{
			if (instance == null || instance.OnAudioDeviceStateChanged == null || instance._AgoraCallbackObject == null)
			{
				return;
			}
			instance._AgoraCallbackObject._CallbackQueue?.EnQueue(delegate
			{
				if (instance != null && instance.OnAudioDeviceStateChanged != null)
				{
					instance.OnAudioDeviceStateChanged(deviceId, deviceType, deviceState);
				}
			});
		}

		[MonoPInvokeCallback(typeof(OnCameraReadyHandler))]
		private static void OnCameraReadyCallback()
		{
			if (instance == null || instance.OnCameraReady == null || instance._AgoraCallbackObject == null)
			{
				return;
			}
			instance._AgoraCallbackObject._CallbackQueue?.EnQueue(delegate
			{
				if (instance != null && instance.OnCameraReady != null)
				{
					instance.OnCameraReady();
				}
			});
		}

		[MonoPInvokeCallback(typeof(OnCameraFocusAreaChangedHandler))]
		private static void OnCameraFocusAreaChangedCallback(int x, int y, int width, int height)
		{
			if (instance == null || instance.OnCameraFocusAreaChanged == null || instance._AgoraCallbackObject == null)
			{
				return;
			}
			instance._AgoraCallbackObject._CallbackQueue?.EnQueue(delegate
			{
				if (instance != null && instance.OnCameraFocusAreaChanged != null)
				{
					instance.OnCameraExposureAreaChanged(x, y, width, height);
				}
			});
		}

		[MonoPInvokeCallback(typeof(OnCameraExposureAreaChangedHandler))]
		private static void OnCameraExposureAreaChangedCallback(int x, int y, int width, int height)
		{
			if (instance == null || instance.OnCameraExposureAreaChanged == null || instance._AgoraCallbackObject == null)
			{
				return;
			}
			instance._AgoraCallbackObject._CallbackQueue?.EnQueue(delegate
			{
				if (instance != null && instance.OnCameraExposureAreaChanged != null)
				{
					instance.OnCameraExposureAreaChanged(x, y, width, height);
				}
			});
		}

		[MonoPInvokeCallback(typeof(OnRemoteAudioMixingBeginHandler))]
		private static void OnRemoteAudioMixingBeginCallback()
		{
			if (instance == null || instance.OnRemoteAudioMixingBegin == null || instance._AgoraCallbackObject == null)
			{
				return;
			}
			instance._AgoraCallbackObject._CallbackQueue?.EnQueue(delegate
			{
				if (instance != null && instance.OnRemoteAudioMixingBegin != null)
				{
					instance.OnRemoteAudioMixingBegin();
				}
			});
		}

		[MonoPInvokeCallback(typeof(OnRemoteAudioMixingEndHandler))]
		private static void OnRemoteAudioMixingEndCallback()
		{
			if (instance == null || instance.OnRemoteAudioMixingEnd == null || instance._AgoraCallbackObject == null)
			{
				return;
			}
			instance._AgoraCallbackObject._CallbackQueue?.EnQueue(delegate
			{
				if (instance != null && instance.OnRemoteAudioMixingEnd != null)
				{
					instance.OnRemoteAudioMixingEnd();
				}
			});
		}

		[MonoPInvokeCallback(typeof(OnAudioEffectFinishedHandler))]
		private static void OnAudioEffectFinishedCallback(int soundId)
		{
			if (instance == null || instance.OnAudioEffectFinished == null || instance._AgoraCallbackObject == null)
			{
				return;
			}
			instance._AgoraCallbackObject._CallbackQueue?.EnQueue(delegate
			{
				if (instance != null && instance.OnAudioEffectFinished != null)
				{
					instance.OnAudioEffectFinished(soundId);
				}
			});
		}

		[MonoPInvokeCallback(typeof(OnVideoDeviceStateChangedHandler))]
		private static void OnVideoDeviceStateChangedCallback(string deviceId, int deviceType, int deviceState)
		{
			if (instance == null || instance.OnVideoDeviceStateChanged == null || instance._AgoraCallbackObject == null)
			{
				return;
			}
			instance._AgoraCallbackObject._CallbackQueue?.EnQueue(delegate
			{
				if (instance != null && instance.OnVideoDeviceStateChanged != null)
				{
					instance.OnVideoDeviceStateChanged(deviceId, deviceType, deviceState);
				}
			});
		}

		[MonoPInvokeCallback(typeof(OnRemoteVideoTransportStatsHandler))]
		private static void OnRemoteVideoTransportStatsCallback(uint uid, ushort delay, ushort lost, ushort rxKBitRate)
		{
			if (instance == null || instance.OnRemoteVideoTransportStats == null || instance._AgoraCallbackObject == null)
			{
				return;
			}
			instance._AgoraCallbackObject._CallbackQueue?.EnQueue(delegate
			{
				if (instance != null && instance.OnRemoteVideoTransportStats != null)
				{
					instance.OnRemoteVideoTransportStats(uid, delay, lost, rxKBitRate);
				}
			});
		}

		[MonoPInvokeCallback(typeof(OnRemoteAudioTransportStatsHandler))]
		private static void OnRemoteAudioTransportStatsCallback(uint uid, ushort delay, ushort lost, ushort rxKBitRate)
		{
			if (instance == null || instance.OnRemoteAudioTransportStats == null || instance._AgoraCallbackObject == null)
			{
				return;
			}
			instance._AgoraCallbackObject._CallbackQueue?.EnQueue(delegate
			{
				if (instance != null && instance.OnRemoteAudioTransportStats != null)
				{
					instance.OnRemoteAudioTransportStats(uid, delay, lost, rxKBitRate);
				}
			});
		}

		[MonoPInvokeCallback(typeof(OnTranscodingUpdatedHandler))]
		private static void OnTranscodingUpdatedCallback()
		{
			if (instance == null || instance.OnTranscodingUpdated == null || instance._AgoraCallbackObject == null)
			{
				return;
			}
			instance._AgoraCallbackObject._CallbackQueue?.EnQueue(delegate
			{
				if (instance != null && instance.OnTranscodingUpdated != null)
				{
					instance.OnTranscodingUpdated();
				}
			});
		}

		[MonoPInvokeCallback(typeof(EngineEventOnAudioDeviceVolumeChangedHandler))]
		private static void OnAudioDeviceVolumeChangedCallback(int deviceType, int volume, bool muted)
		{
			if (instance == null || instance.OnAudioDeviceVolumeChanged == null || instance._AgoraCallbackObject == null)
			{
				return;
			}
			instance._AgoraCallbackObject._CallbackQueue?.EnQueue(delegate
			{
				if (instance != null && instance.OnAudioDeviceVolumeChanged != null)
				{
					instance.OnAudioDeviceVolumeChanged((MEDIA_DEVICE_TYPE)deviceType, volume, muted);
				}
			});
		}

		[MonoPInvokeCallback(typeof(OnMediaEngineStartCallSuccessHandler))]
		private static void OnMediaEngineStartCallSuccessCallback()
		{
			if (instance == null || instance.OnMediaEngineStartCallSuccess == null || instance._AgoraCallbackObject == null)
			{
				return;
			}
			instance._AgoraCallbackObject._CallbackQueue?.EnQueue(delegate
			{
				if (instance != null && instance.OnMediaEngineStartCallSuccess != null)
				{
					instance.OnMediaEngineStartCallSuccess();
				}
			});
		}

		[MonoPInvokeCallback(typeof(OnMediaEngineLoadSuccessHandler))]
		private static void OnMediaEngineLoadSuccessCallback()
		{
			if (instance == null || instance.OnMediaEngineLoadSuccess == null || instance._AgoraCallbackObject == null)
			{
				return;
			}
			instance._AgoraCallbackObject._CallbackQueue?.EnQueue(delegate
			{
				if (instance != null && instance.OnMediaEngineLoadSuccess != null)
				{
					instance.OnMediaEngineLoadSuccess();
				}
			});
		}

		[MonoPInvokeCallback(typeof(EngineEventOnAudioMixingStateChangedHandler))]
		private static void OnAudioMixingStateChangedCallback(int audioMixingStateType, int audioMixingErrorType)
		{
			if (instance == null || instance.OnAudioMixingStateChanged == null || instance._AgoraCallbackObject == null)
			{
				return;
			}
			instance._AgoraCallbackObject._CallbackQueue?.EnQueue(delegate
			{
				if (instance != null && instance.OnAudioMixingStateChanged != null)
				{
					instance.OnAudioMixingStateChanged((AUDIO_MIXING_STATE_TYPE)audioMixingStateType, (AUDIO_MIXING_ERROR_TYPE)audioMixingErrorType);
				}
			});
		}

		[MonoPInvokeCallback(typeof(OnFirstRemoteAudioDecodedHandler))]
		private static void OnFirstRemoteAudioDecodedCallback(uint uid, int elapsed)
		{
			if (instance == null || instance.OnFirstRemoteAudioDecoded == null || instance._AgoraCallbackObject == null)
			{
				return;
			}
			instance._AgoraCallbackObject._CallbackQueue?.EnQueue(delegate
			{
				if (instance != null && instance.OnFirstRemoteAudioDecoded != null)
				{
					instance.OnFirstRemoteAudioDecoded(uid, elapsed);
				}
			});
		}

		[MonoPInvokeCallback(typeof(EngineEventOnLocalVideoStateChanged))]
		private static void OnLocalVideoStateChangedCallback(int localVideoState, int error)
		{
			if (instance == null || instance.OnLocalVideoStateChanged == null || instance._AgoraCallbackObject == null)
			{
				return;
			}
			instance._AgoraCallbackObject._CallbackQueue?.EnQueue(delegate
			{
				if (instance != null && instance.OnLocalVideoStateChanged != null)
				{
					instance.OnLocalVideoStateChanged((LOCAL_VIDEO_STREAM_STATE)localVideoState, (LOCAL_VIDEO_STREAM_ERROR)error);
				}
			});
		}

		[MonoPInvokeCallback(typeof(EngineEventOnRtmpStreamingStateChangedHandler))]
		private static void OnRtmpStreamingStateChangedCallback(string url, int state, int errCode)
		{
			if (instance == null || instance.OnRtmpStreamingStateChanged == null || instance._AgoraCallbackObject == null)
			{
				return;
			}
			instance._AgoraCallbackObject._CallbackQueue?.EnQueue(delegate
			{
				if (instance != null && instance.OnRtmpStreamingStateChanged != null)
				{
					instance.OnRtmpStreamingStateChanged(url, (RTMP_STREAM_PUBLISH_STATE)state, (RTMP_STREAM_PUBLISH_ERROR)errCode);
				}
			});
		}

		[MonoPInvokeCallback(typeof(EngineEventOnNetworkTypeChangedHandler))]
		private static void OnNetworkTypeChangedCallback(int networkType)
		{
			if (instance == null || instance.OnNetworkTypeChanged == null || instance._AgoraCallbackObject == null)
			{
				return;
			}
			instance._AgoraCallbackObject._CallbackQueue?.EnQueue(delegate
			{
				if (instance != null && instance.OnNetworkTypeChanged != null)
				{
					instance.OnNetworkTypeChanged((NETWORK_TYPE)networkType);
				}
			});
		}

		[MonoPInvokeCallback(typeof(EngineEventOnLastmileProbeResultHandler))]
		private static void OnLastmileProbeResultCallback(int state, uint upLinkPacketLossRate, uint upLinkjitter, uint upLinkAvailableBandwidth, uint downLinkPacketLossRate, uint downLinkJitter, uint downLinkAvailableBandwidth, uint rtt)
		{
			if (instance == null || instance.OnLastmileProbeResult == null || instance._AgoraCallbackObject == null)
			{
				return;
			}
			instance._AgoraCallbackObject._CallbackQueue?.EnQueue(delegate
			{
				if (instance != null && instance.OnLastmileProbeResult != null)
				{
					LastmileProbeResult result = default(LastmileProbeResult);
					result.state = (LASTMILE_PROBE_RESULT_STATE)state;
					result.uplinkReport.packetLossRate = upLinkPacketLossRate;
					result.uplinkReport.jitter = upLinkjitter;
					result.uplinkReport.availableBandwidth = upLinkAvailableBandwidth;
					result.downlinkReport.packetLossRate = downLinkPacketLossRate;
					result.downlinkReport.jitter = downLinkJitter;
					result.downlinkReport.availableBandwidth = downLinkAvailableBandwidth;
					result.rtt = rtt;
					instance.OnLastmileProbeResult(result);
				}
			});
		}

		[MonoPInvokeCallback(typeof(EngineEventOnUserInfoUpdatedHandler))]
		private static void OnUserInfoUpdatedCallback(uint uid, uint userUid, string userAccount)
		{
			if (instance == null || instance.OnUserInfoUpdated == null || instance._AgoraCallbackObject == null)
			{
				return;
			}
			instance._AgoraCallbackObject._CallbackQueue?.EnQueue(delegate
			{
				if (instance != null && instance.OnUserInfoUpdated != null)
				{
					UserInfo userInfo = default(UserInfo);
					userInfo.uid = userUid;
					userInfo.userAccount = userAccount;
					instance.OnUserInfoUpdated(uid, userInfo);
				}
			});
		}

		[MonoPInvokeCallback(typeof(OnLocalUserRegisteredHandler))]
		private static void OnLocalUserRegisteredCallback(uint uid, string userAccount)
		{
			if (instance == null || instance.OnLocalUserRegistered == null || instance._AgoraCallbackObject == null)
			{
				return;
			}
			instance._AgoraCallbackObject._CallbackQueue?.EnQueue(delegate
			{
				if (instance != null && instance.OnLocalUserRegistered != null)
				{
					instance.OnLocalUserRegistered(uid, userAccount);
				}
			});
		}

		[MonoPInvokeCallback(typeof(EngineEventOnLocalAudioStateChangedHandler))]
		private static void OnLocalAudioStateChangedCallback(int state, int error)
		{
			if (instance == null || instance.OnLocalAudioStateChanged == null || instance._AgoraCallbackObject == null)
			{
				return;
			}
			instance._AgoraCallbackObject._CallbackQueue?.EnQueue(delegate
			{
				if (instance != null && instance.OnLocalAudioStateChanged != null)
				{
					instance.OnLocalAudioStateChanged((LOCAL_AUDIO_STREAM_STATE)state, (LOCAL_AUDIO_STREAM_ERROR)error);
				}
			});
		}

		[MonoPInvokeCallback(typeof(EngineEventOnRemoteAudioStateChangedHandler))]
		private static void OnRemoteAudioStateChangedCallback(uint uid, int state, int reason, int elapsed)
		{
			if (instance == null || instance.OnRemoteAudioStateChanged == null || instance._AgoraCallbackObject == null)
			{
				return;
			}
			instance._AgoraCallbackObject._CallbackQueue?.EnQueue(delegate
			{
				if (instance != null && instance.OnRemoteAudioStateChanged != null)
				{
					instance.OnRemoteAudioStateChanged(uid, (REMOTE_AUDIO_STATE)state, (REMOTE_AUDIO_STATE_REASON)reason, elapsed);
				}
			});
		}

		[MonoPInvokeCallback(typeof(EngineEventOnLocalAudioStatsHandler))]
		private static void OnLocalAudioStatsCallback(int numChannels, int sentSampleRate, int sentBitrate)
		{
			if (instance == null || instance.OnLocalAudioStats == null || instance._AgoraCallbackObject == null)
			{
				return;
			}
			instance._AgoraCallbackObject._CallbackQueue?.EnQueue(delegate
			{
				if (instance != null && instance.OnLocalAudioStats != null)
				{
					LocalAudioStats localAudioStats = default(LocalAudioStats);
					localAudioStats.numChannels = numChannels;
					localAudioStats.sentSampleRate = sentSampleRate;
					localAudioStats.sentBitrate = sentBitrate;
					instance.OnLocalAudioStats(localAudioStats);
				}
			});
		}

		[MonoPInvokeCallback(typeof(EngineEventOnChannelMediaRelayStateChangedHandler))]
		private static void OnChannelMediaRelayStateChangedCallback(int state, int code)
		{
			if (instance == null || instance.OnChannelMediaRelayStateChanged == null || instance._AgoraCallbackObject == null)
			{
				return;
			}
			instance._AgoraCallbackObject._CallbackQueue?.EnQueue(delegate
			{
				if (instance != null && instance.OnChannelMediaRelayStateChanged != null)
				{
					instance.OnChannelMediaRelayStateChanged((CHANNEL_MEDIA_RELAY_STATE)state, (CHANNEL_MEDIA_RELAY_ERROR)code);
				}
			});
		}

		[MonoPInvokeCallback(typeof(EngineEventOnChannelMediaRelayEventHandler))]
		private static void OnChannelMediaRelayEventCallback(int events)
		{
			if (instance == null || instance.OnChannelMediaRelayEvent == null || instance._AgoraCallbackObject == null)
			{
				return;
			}
			instance._AgoraCallbackObject._CallbackQueue?.EnQueue(delegate
			{
				if (instance != null && instance.OnChannelMediaRelayEvent != null)
				{
					instance.OnChannelMediaRelayEvent((CHANNEL_MEDIA_RELAY_EVENT)events);
				}
			});
		}

		[MonoPInvokeCallback(typeof(EngineEventOnFacePositionChanged))]
		private static void OnFacePositionChangedCallback(int imageWidth, int imageHeight, int x, int y, int width, int height, int vecDistance, int numFaces)
		{
			if (instance == null || instance.OnFacePositionChanged == null || instance._AgoraCallbackObject == null)
			{
				return;
			}
			instance._AgoraCallbackObject._CallbackQueue?.EnQueue(delegate
			{
				if (instance != null && instance.OnFacePositionChanged != null)
				{
					Rectangle vecRectangle = default(Rectangle);
					vecRectangle.x = x;
					vecRectangle.y = y;
					vecRectangle.width = width;
					vecRectangle.height = height;
					instance.OnFacePositionChanged(imageWidth, imageHeight, vecRectangle, vecDistance, numFaces);
				}
			});
		}

		private void InitEngineCallback()
		{
			IRtcEngineNative.initEventOnEngineCallback(OnJoinChannelSuccessCallback, OnReJoinChannelSuccessCallback, OnConnectionLostCallback, OnLeaveChannelCallback, OnConnectionInterruptedCallback, OnRequestTokenCallback, OnUserJoinedCallback, OnUserOfflineCallback, OnAudioVolumeIndicationCallback, OnUserMuteAudioCallback, OnSDKWarningCallback, OnSDKErrorCallback, OnRtcStatsCallback, OnAudioMixingFinishedCallback, OnAudioRouteChangedCallback, OnFirstRemoteVideoDecodedCallback, OnVideoSizeChangedCallback, OnClientRoleChangedCallback, OnUserMuteVideoCallback, OnMicrophoneEnabledCallback, OnApiExecutedCallback, OnFirstLocalAudioFrameCallback, OnFirstRemoteAudioFrameCallback, OnLastmileQualityCallback, OnAudioQualityCallback, OnStreamInjectedStatusCallback, OnStreamUnpublishedCallback, OnStreamPublishedCallback, OnStreamMessageErrorCallback, OnStreamMessageCallback, OnConnectionBannedCallback, OnVideoStoppedCallback, OnTokenPrivilegeWillExpireCallback, OnNetworkQualityCallback, OnLocalVideoStatsCallback, OnRemoteVideoStatsCallback, OnRemoteAudioStatsCallback, OnFirstLocalVideoFrameCallback, OnFirstRemoteVideoFrameCallback, OnUserEnableVideoCallback, OnAudioDeviceStateChangedCallback, OnCameraReadyCallback, OnCameraFocusAreaChangedCallback, OnCameraExposureAreaChangedCallback, OnRemoteAudioMixingBeginCallback, OnRemoteAudioMixingEndCallback, OnAudioEffectFinishedCallback, OnVideoDeviceStateChangedCallback, OnRemoteVideoStateChangedCallback, OnUserEnableLocalVideoCallback, OnLocalPublishFallbackToAudioOnlyCallback, OnRemoteSubscribeFallbackToAudioOnlyCallback, OnConnectionStateChangedCallback, OnRemoteVideoTransportStatsCallback, OnRemoteAudioTransportStatsCallback, OnTranscodingUpdatedCallback, OnAudioDeviceVolumeChangedCallback, OnActiveSpeakerCallback, OnMediaEngineStartCallSuccessCallback, OnMediaEngineLoadSuccessCallback, OnAudioMixingStateChangedCallback, OnFirstRemoteAudioDecodedCallback, OnLocalVideoStateChangedCallback, OnRtmpStreamingStateChangedCallback, OnNetworkTypeChangedCallback, OnLastmileProbeResultCallback, OnLocalUserRegisteredCallback, OnUserInfoUpdatedCallback, OnLocalAudioStateChangedCallback, OnRemoteAudioStateChangedCallback, OnLocalAudioStatsCallback, OnChannelMediaRelayStateChangedCallback, OnChannelMediaRelayEventCallback, OnFacePositionChangedCallback);
		}
	}
	public abstract class IAudioEffectManager : IRtcEngineNative
	{
		public abstract double GetEffectsVolume();

		public abstract int SetEffectsVolume(int volume);

		public abstract int PlayEffect(int soundId, string filePath, int loopCount, double pitch = 1.0, double pan = 0.0, int gain = 100, bool publish = false);

		public abstract int StopEffect(int soundId);

		public abstract int StopAllEffects();

		public abstract int PreloadEffect(int soundId, string filePath);

		public abstract int UnloadEffect(int soundId);

		public abstract int PauseEffect(int soundId);

		public abstract int PauseAllEffects();

		public abstract int ResumeEffect(int soundId);

		public abstract int ResumeAllEffects();

		public abstract int SetVoiceOnlyMode(bool enable);

		public abstract int SetRemoteVoicePosition(uint uid, double pan, double gain);

		public abstract int SetLocalVoicePitch(double pitch);
	}
	public sealed class AudioEffectManagerImpl : IAudioEffectManager
	{
		private IRtcEngine _mEngine;

		private static AudioEffectManagerImpl _audioEffectManagerImplInstance;

		private AudioEffectManagerImpl(IRtcEngine rtcEngine)
		{
			_mEngine = rtcEngine;
		}

		public static AudioEffectManagerImpl GetInstance(IRtcEngine rtcEngine)
		{
			if (_audioEffectManagerImplInstance == null)
			{
				_audioEffectManagerImplInstance = new AudioEffectManagerImpl(rtcEngine);
			}
			return _audioEffectManagerImplInstance;
		}

		public static void ReleaseInstance()
		{
			_audioEffectManagerImplInstance = null;
		}

		public void SetEngine(IRtcEngine engine)
		{
			_mEngine = engine;
		}

		public override double GetEffectsVolume()
		{
			if (_mEngine == null)
			{
				return -7.0;
			}
			return IRtcEngineNative.getEffectsVolume();
		}

		public override int SetEffectsVolume(int volume)
		{
			if (_mEngine == null)
			{
				return -7;
			}
			return IRtcEngineNative.setEffectsVolume(volume);
		}

		public override int PlayEffect(int soundId, string filePath, int loopCount, double pitch = 1.0, double pan = 0.0, int gain = 100, bool publish = false)
		{
			if (_mEngine == null)
			{
				return -7;
			}
			return IRtcEngineNative.playEffect(soundId, filePath, loopCount, pitch, pan, gain, publish);
		}

		public override int StopEffect(int soundId)
		{
			if (_mEngine == null)
			{
				return -7;
			}
			return IRtcEngineNative.stopEffect(soundId);
		}

		public override int StopAllEffects()
		{
			if (_mEngine == null)
			{
				return -7;
			}
			return IRtcEngineNative.stopAllEffects();
		}

		public override int PreloadEffect(int soundId, string filePath)
		{
			if (_mEngine == null)
			{
				return -7;
			}
			return IRtcEngineNative.preloadEffect(soundId, filePath);
		}

		public override int UnloadEffect(int soundId)
		{
			if (_mEngine == null)
			{
				return -7;
			}
			return IRtcEngineNative.unloadEffect(soundId);
		}

		public override int PauseEffect(int soundId)
		{
			if (_mEngine == null)
			{
				return -7;
			}
			return IRtcEngineNative.pauseEffect(soundId);
		}

		public override int PauseAllEffects()
		{
			if (_mEngine == null)
			{
				return -7;
			}
			return IRtcEngineNative.pauseAllEffects();
		}

		public override int ResumeEffect(int soundId)
		{
			if (_mEngine == null)
			{
				return -7;
			}
			return IRtcEngineNative.resumeEffect(soundId);
		}

		public override int ResumeAllEffects()
		{
			if (_mEngine == null)
			{
				return -7;
			}
			return IRtcEngineNative.resumeAllEffects();
		}

		public override int SetVoiceOnlyMode(bool enable)
		{
			if (_mEngine == null)
			{
				return -7;
			}
			return IRtcEngineNative.setVoiceOnlyMode(enable);
		}

		public override int SetRemoteVoicePosition(uint uid, double pan, double gain)
		{
			if (_mEngine == null)
			{
				return -7;
			}
			return IRtcEngineNative.setRemoteVoicePosition(uid, pan, gain);
		}

		public override int SetLocalVoicePitch(double pitch)
		{
			if (_mEngine == null)
			{
				return -7;
			}
			return IRtcEngineNative.setLocalVoicePitch(pitch);
		}
	}
	public abstract class IAudioPlaybackDeviceManager : IRtcEngineNative
	{
		public abstract bool CreateAAudioPlaybackDeviceManager();

		public abstract int ReleaseAAudioPlaybackDeviceManager();

		public abstract int GetAudioPlaybackDeviceCount();

		public abstract int GetAudioPlaybackDevice(int index, ref string deviceName, ref string deviceId);

		public abstract int SetAudioPlaybackDevice(string deviceId);

		public abstract int SetAudioPlaybackDeviceVolume(int volume);

		public abstract int GetAudioPlaybackDeviceVolume();

		public abstract int SetAudioPlaybackDeviceMute(bool mute);

		public abstract bool IsAudioPlaybackDeviceMute();

		public abstract int StartAudioPlaybackDeviceTest(string testAudioFilePath);

		public abstract int StopAudioPlaybackDeviceTest();

		public abstract int GetCurrentPlaybackDevice(ref string deviceId);

		public abstract int GetCurrentPlaybackDeviceInfo(ref string deviceName, ref string deviceId);
	}
	public sealed class AudioPlaybackDeviceManager : IAudioPlaybackDeviceManager
	{
		private IRtcEngine mEngine;

		private static AudioPlaybackDeviceManager _audioPlaybackDeviceManagerInstance;

		private AudioPlaybackDeviceManager(IRtcEngine rtcEngine)
		{
			mEngine = rtcEngine;
		}

		public static AudioPlaybackDeviceManager GetInstance(IRtcEngine rtcEngine)
		{
			if (_audioPlaybackDeviceManagerInstance == null)
			{
				_audioPlaybackDeviceManagerInstance = new AudioPlaybackDeviceManager(rtcEngine);
			}
			return _audioPlaybackDeviceManagerInstance;
		}

		public static void ReleaseInstance()
		{
			_audioPlaybackDeviceManagerInstance = null;
		}

		public void SetEngine(IRtcEngine engine)
		{
			mEngine = engine;
		}

		public override bool CreateAAudioPlaybackDeviceManager()
		{
			if (mEngine == null)
			{
				return false;
			}
			return IRtcEngineNative.creatAAudioPlaybackDeviceManager();
		}

		public override int ReleaseAAudioPlaybackDeviceManager()
		{
			if (mEngine == null)
			{
				return -7;
			}
			return IRtcEngineNative.releaseAAudioPlaybackDeviceManager();
		}

		public override int GetAudioPlaybackDeviceCount()
		{
			if (mEngine == null)
			{
				return -7;
			}
			return IRtcEngineNative.getAudioPlaybackDeviceCount();
		}

		public override int GetAudioPlaybackDevice(int index, ref string deviceName, ref string deviceId)
		{
			if (mEngine == null)
			{
				return -7;
			}
			if (index >= 0 && index < GetAudioPlaybackDeviceCount())
			{
				IntPtr intPtr = Marshal.AllocHGlobal(512);
				IntPtr intPtr2 = Marshal.AllocHGlobal(512);
				int audioPlaybackDevice = IRtcEngineNative.getAudioPlaybackDevice(index, intPtr, intPtr2);
				deviceName = Marshal.PtrToStringAnsi(intPtr);
				deviceId = Marshal.PtrToStringAnsi(intPtr2);
				Marshal.FreeHGlobal(intPtr);
				Marshal.FreeHGlobal(intPtr2);
				return audioPlaybackDevice;
			}
			return -2;
		}

		public override int GetCurrentPlaybackDevice(ref string deviceId)
		{
			if (mEngine == null)
			{
				return -7;
			}
			if (GetAudioPlaybackDeviceCount() > 0)
			{
				IntPtr intPtr = Marshal.AllocHGlobal(512);
				int currentPlaybackDevice = IRtcEngineNative.getCurrentPlaybackDevice(intPtr);
				deviceId = Marshal.PtrToStringAnsi(intPtr);
				Marshal.FreeHGlobal(intPtr);
				return currentPlaybackDevice;
			}
			return -100;
		}

		public override int SetAudioPlaybackDevice(string deviceId)
		{
			if (mEngine == null)
			{
				return -7;
			}
			return IRtcEngineNative.setAudioPlaybackDevice(deviceId);
		}

		public override int SetAudioPlaybackDeviceVolume(int volume)
		{
			if (mEngine == null)
			{
				return -7;
			}
			return IRtcEngineNative.setAudioPlaybackDeviceVolume(volume);
		}

		public override int GetAudioPlaybackDeviceVolume()
		{
			if (mEngine == null)
			{
				return -7;
			}
			return IRtcEngineNative.getAudioPlaybackDeviceVolume();
		}

		public override int SetAudioPlaybackDeviceMute(bool mute)
		{
			if (mEngine == null)
			{
				return -7;
			}
			return IRtcEngineNative.setAudioPlaybackDeviceMute(mute);
		}

		public override bool IsAudioPlaybackDeviceMute()
		{
			if (mEngine == null)
			{
				return false;
			}
			return IRtcEngineNative.isAudioPlaybackDeviceMute();
		}

		public override int StartAudioPlaybackDeviceTest(string testAudioFilePath)
		{
			if (mEngine == null)
			{
				return -7;
			}
			return IRtcEngineNative.startAudioPlaybackDeviceTest(testAudioFilePath);
		}

		public override int StopAudioPlaybackDeviceTest()
		{
			if (mEngine == null)
			{
				return -7;
			}
			return IRtcEngineNative.stopAudioPlaybackDeviceTest();
		}

		public override int GetCurrentPlaybackDeviceInfo(ref string deviceName, ref string deviceId)
		{
			if (mEngine == null)
			{
				return -7;
			}
			if (GetAudioPlaybackDeviceCount() > 0)
			{
				IntPtr intPtr = Marshal.AllocHGlobal(512);
				IntPtr intPtr2 = Marshal.AllocHGlobal(512);
				int currentPlaybackDeviceInfo = IRtcEngineNative.getCurrentPlaybackDeviceInfo(intPtr, intPtr2);
				deviceName = Marshal.PtrToStringAnsi(intPtr);
				deviceId = Marshal.PtrToStringAnsi(intPtr2);
				Marshal.FreeHGlobal(intPtr);
				Marshal.FreeHGlobal(intPtr2);
				return currentPlaybackDeviceInfo;
			}
			return -100;
		}
	}
	public abstract class IAudioRecordingDeviceManager : IRtcEngineNative
	{
		public abstract bool CreateAAudioRecordingDeviceManager();

		public abstract int ReleaseAAudioRecordingDeviceManager();

		public abstract int GetAudioRecordingDeviceCount();

		public abstract int GetAudioRecordingDevice(int index, ref string audioRecordingDeviceName, ref string audioRecordingDeviceId);

		public abstract int SetAudioRecordingDevice(string deviceId);

		public abstract int StartAudioRecordingDeviceTest(int indicationInterval);

		public abstract int StopAudioRecordingDeviceTest();

		public abstract int GetCurrentRecordingDevice(ref string deviceId);

		public abstract int SetAudioRecordingDeviceVolume(int volume);

		public abstract int GetAudioRecordingDeviceVolume();

		public abstract int SetAudioRecordingDeviceMute(bool mute);

		public abstract bool IsAudioRecordingDeviceMute();

		public abstract int GetCurrentRecordingDeviceInfo(ref string deviceName, ref string deviceId);
	}
	public sealed class AudioRecordingDeviceManager : IAudioRecordingDeviceManager
	{
		private IRtcEngine mEngine;

		private static AudioRecordingDeviceManager _audioRecordingDeviceManagerInstance;

		private AudioRecordingDeviceManager(IRtcEngine rtcEngine)
		{
			mEngine = rtcEngine;
		}

		public static AudioRecordingDeviceManager GetInstance(IRtcEngine rtcEngine)
		{
			if (_audioRecordingDeviceManagerInstance == null)
			{
				_audioRecordingDeviceManagerInstance = new AudioRecordingDeviceManager(rtcEngine);
			}
			return _audioRecordingDeviceManagerInstance;
		}

		public static void ReleaseInstance()
		{
			_audioRecordingDeviceManagerInstance = null;
		}

		public void SetEngine(IRtcEngine engine)
		{
			mEngine = engine;
		}

		public override bool CreateAAudioRecordingDeviceManager()
		{
			if (mEngine == null)
			{
				return false;
			}
			return IRtcEngineNative.creatAAudioRecordingDeviceManager();
		}

		public override int ReleaseAAudioRecordingDeviceManager()
		{
			if (mEngine == null)
			{
				return -7;
			}
			return IRtcEngineNative.releaseAAudioRecordingDeviceManager();
		}

		public override int GetAudioRecordingDeviceCount()
		{
			if (mEngine == null)
			{
				return -7;
			}
			return IRtcEngineNative.getAudioRecordingDeviceCount();
		}

		public override int GetAudioRecordingDevice(int index, ref string audioRecordingDeviceName, ref string audioRecordingDeviceId)
		{
			if (mEngine == null)
			{
				return -7;
			}
			if (index >= 0 && index < GetAudioRecordingDeviceCount())
			{
				IntPtr intPtr = Marshal.AllocHGlobal(512);
				IntPtr intPtr2 = Marshal.AllocHGlobal(512);
				int audioRecordingDevice = IRtcEngineNative.getAudioRecordingDevice(index, intPtr, intPtr2);
				audioRecordingDeviceName = Marshal.PtrToStringAnsi(intPtr);
				audioRecordingDeviceId = Marshal.PtrToStringAnsi(intPtr2);
				Marshal.FreeHGlobal(intPtr);
				Marshal.FreeHGlobal(intPtr2);
				return audioRecordingDevice;
			}
			return -2;
		}

		public override int GetCurrentRecordingDevice(ref string deviceId)
		{
			if (mEngine == null)
			{
				return -7;
			}
			if (GetAudioRecordingDeviceCount() > 0)
			{
				IntPtr intPtr = Marshal.AllocHGlobal(512);
				int currentRecordingDevice = IRtcEngineNative.getCurrentRecordingDevice(intPtr);
				deviceId = Marshal.PtrToStringAnsi(intPtr);
				Marshal.FreeHGlobal(intPtr);
				return currentRecordingDevice;
			}
			return -100;
		}

		public override int SetAudioRecordingDeviceVolume(int volume)
		{
			if (mEngine == null)
			{
				return -7;
			}
			return IRtcEngineNative.setAudioRecordingDeviceVolume(volume);
		}

		public override int GetAudioRecordingDeviceVolume()
		{
			if (mEngine == null)
			{
				return -7;
			}
			return IRtcEngineNative.getAudioRecordingDeviceVolume();
		}

		public override int SetAudioRecordingDeviceMute(bool mute)
		{
			if (mEngine == null)
			{
				return -7;
			}
			return IRtcEngineNative.setAudioRecordingDeviceMute(mute);
		}

		public override bool IsAudioRecordingDeviceMute()
		{
			if (mEngine == null)
			{
				return false;
			}
			return IRtcEngineNative.isAudioRecordingDeviceMute();
		}

		public override int SetAudioRecordingDevice(string deviceId)
		{
			if (mEngine == null)
			{
				return -7;
			}
			return IRtcEngineNative.setAudioRecordingDevice(deviceId);
		}

		public override int StartAudioRecordingDeviceTest(int indicationInterval)
		{
			if (mEngine == null)
			{
				return -7;
			}
			return IRtcEngineNative.startAudioRecordingDeviceTest(indicationInterval);
		}

		public override int StopAudioRecordingDeviceTest()
		{
			if (mEngine == null)
			{
				return -7;
			}
			return IRtcEngineNative.stopAudioRecordingDeviceTest();
		}

		public override int GetCurrentRecordingDeviceInfo(ref string deviceName, ref string deviceId)
		{
			if (mEngine == null)
			{
				return -7;
			}
			if (GetAudioRecordingDeviceCount() > 0)
			{
				IntPtr intPtr = Marshal.AllocHGlobal(512);
				IntPtr intPtr2 = Marshal.AllocHGlobal(512);
				int currentRecordingDeviceInfo = IRtcEngineNative.getCurrentRecordingDeviceInfo(intPtr, intPtr2);
				deviceName = Marshal.PtrToStringAnsi(intPtr);
				deviceId = Marshal.PtrToStringAnsi(intPtr2);
				Marshal.FreeHGlobal(intPtr);
				Marshal.FreeHGlobal(intPtr2);
				return currentRecordingDeviceInfo;
			}
			return -100;
		}
	}
	public abstract class IVideoDeviceManager : IRtcEngineNative
	{
		public abstract bool CreateAVideoDeviceManager();

		public abstract int ReleaseAVideoDeviceManager();

		public abstract int StartVideoDeviceTest(IntPtr hwnd);

		public abstract int StopVideoDeviceTest();

		public abstract int GetVideoDeviceCount();

		public abstract int GetVideoDevice(int index, ref string deviceName, ref string deviceId);

		public abstract int SetVideoDevice(string deviceId);

		public abstract int GetCurrentVideoDevice(ref string deviceId);
	}
	public sealed class VideoDeviceManager : IVideoDeviceManager
	{
		private IRtcEngine _mEngine;

		private static VideoDeviceManager _videoDeviceManagerInstance;

		private VideoDeviceManager(IRtcEngine rtcEngine)
		{
			_mEngine = rtcEngine;
		}

		public static VideoDeviceManager GetInstance(IRtcEngine rtcEngine)
		{
			if (_videoDeviceManagerInstance == null)
			{
				_videoDeviceManagerInstance = new VideoDeviceManager(rtcEngine);
			}
			return _videoDeviceManagerInstance;
		}

		public static void ReleaseInstance()
		{
			_videoDeviceManagerInstance = null;
		}

		public void SetEngine(IRtcEngine engine)
		{
			_mEngine = engine;
		}

		public override bool CreateAVideoDeviceManager()
		{
			if (_mEngine == null)
			{
				return false;
			}
			return IRtcEngineNative.createAVideoDeviceManager();
		}

		public override int ReleaseAVideoDeviceManager()
		{
			if (_mEngine == null)
			{
				return -7;
			}
			return IRtcEngineNative.releaseAVideoDeviceManager();
		}

		public override int StartVideoDeviceTest(IntPtr hwnd)
		{
			if (_mEngine == null)
			{
				return -7;
			}
			return IRtcEngineNative.startVideoDeviceTest(hwnd);
		}

		public override int StopVideoDeviceTest()
		{
			if (_mEngine == null)
			{
				return -7;
			}
			return IRtcEngineNative.stopVideoDeviceTest();
		}

		public override int GetVideoDeviceCount()
		{
			if (_mEngine == null)
			{
				return -7;
			}
			return IRtcEngineNative.getVideoDeviceCollectionCount();
		}

		public override int GetVideoDevice(int index, ref string deviceName, ref string deviceId)
		{
			if (_mEngine == null)
			{
				return -7;
			}
			if (index >= 0 && index < GetVideoDeviceCount())
			{
				IntPtr intPtr = Marshal.AllocHGlobal(512);
				IntPtr intPtr2 = Marshal.AllocHGlobal(512);
				int videoDeviceCollectionDevice = IRtcEngineNative.getVideoDeviceCollectionDevice(index, intPtr, intPtr2);
				deviceName = Marshal.PtrToStringAnsi(intPtr);
				deviceId = Marshal.PtrToStringAnsi(intPtr2);
				Marshal.FreeHGlobal(intPtr);
				Marshal.FreeHGlobal(intPtr2);
				return videoDeviceCollectionDevice;
			}
			return -2;
		}

		public override int GetCurrentVideoDevice(ref string deviceId)
		{
			if (_mEngine == null)
			{
				return -7;
			}
			if (GetVideoDeviceCount() > 0)
			{
				IntPtr intPtr = Marshal.AllocHGlobal(512);
				int currentVideoDevice = IRtcEngineNative.getCurrentVideoDevice(intPtr);
				deviceId = Marshal.PtrToStringAnsi(intPtr);
				Marshal.FreeHGlobal(intPtr);
				return currentVideoDevice;
			}
			return -100;
		}

		public override int SetVideoDevice(string deviceId)
		{
			if (_mEngine == null)
			{
				return -7;
			}
			return IRtcEngineNative.setVideoDeviceCollectionDevice(deviceId);
		}
	}
	public class IRtcEngineNative
	{
		protected delegate void EngineEventOnCaptureVideoFrame(int videoFrameType, int width, int height, int yStride, IntPtr yBuffer, int rotation, long renderTimeMs);

		protected delegate void EngineEventOnRenderVideoFrame(uint uid, int videoFrameType, int width, int height, int yStride, IntPtr yBuffer, int rotation, long renderTimeMs);

		protected delegate void EngineEventOnRecordAudioFrame(int type, int samples, int bytesPerSample, int channels, int samplesPerSec, IntPtr buffer, long renderTimeMs, int avsync_type);

		protected delegate void EngineEventOnPlaybackAudioFrame(int type, int samples, int bytesPerSample, int channels, int samplesPerSec, IntPtr buffer, long renderTimeMs, int avsync_type);

		protected delegate void EngineEventOnMixedAudioFrame(int type, int samples, int bytesPerSample, int channels, int samplesPerSec, IntPtr buffer, long renderTimeMs, int avsync_type);

		protected delegate void EngineEventOnPlaybackAudioFrameBeforeMixing(uint uid, int type, int samples, int bytesPerSample, int channels, int samplesPerSec, IntPtr buffer, long renderTimeMs, int avsync_type);

		protected delegate void EngineEventOnPullAudioFrameHandler(int type, int samples, int bytesPerSample, int channels, int samplesPerSec, IntPtr buffer, long renderTimeMs, int avsync_type);

		protected delegate void EngineEventOnLeaveChannelHandler(uint duration, uint txBytes, uint rxBytes, uint txAudioBytes, uint txVideoBytes, uint rxAudioBytes, uint rxVideoBytes, ushort txKBitRate, ushort rxKBitRate, ushort rxAudioKBitRate, ushort txAudioKBitRate, ushort rxVideoKBitRate, ushort txVideoKBitRate, ushort lastmileDelay, ushort txPacketLossRate, ushort rxPacketLossRate, uint userCount, double cpuAppUsage, double cpuTotalUsage, int gatewayRtt, double memoryAppUsageRatio, double memoryTotalUsageRatio, int memoryAppUsageInKbytes);

		protected delegate void EngineEventOnUserOfflineHandler(uint uid, int offLineReason);

		protected delegate void EngineEventOnAudioVolumeIndicationHandler(string volumeInfo, int speakerNumber, int totalVolume);

		protected delegate void EngineEventOnRtcStatsHandler(uint duration, uint txBytes, uint rxBytes, uint txAudioBytes, uint txVideoBytes, uint rxAudioBytes, uint rxVideoBytes, ushort txKBitRate, ushort rxKBitRate, ushort rxAudioKBitRate, ushort txAudioKBitRate, ushort rxVideoKBitRate, ushort txVideoKBitRate, ushort lastmileDelay, ushort txPacketLossRate, ushort rxPacketLossRate, uint userCount, double cpuAppUsage, double cpuTotalUsage, int gatewayRtt, double memoryAppUsageRatio, double memoryTotalUsageRatio, int memoryAppUsageInKbytes);

		protected delegate void EngineEventOnAudioRouteChangedHandler(int route);

		protected delegate void EngineEventOnLocalVideoStatsHandler(int sentBitrate, int sentFrameRate, int encoderOutputFrameRate, int rendererOutputFrameRate, int targetBitrate, int targetFrameRate, int qualityAdaptIndication, int encodedBitrate, int encodedFrameWidth, int encodedFrameHeight, int encodedFrameCount, int codecType);

		protected delegate void EngineEventOnRemoteVideoStatsHandler(uint uid, int delay, int width, int height, int receivedBitrate, int decoderOutputFrameRate, int rendererOutputFrameRate, int packetLossRate, int rxStreamType, int totalFrozenTime, int frozenRate, int totalActiveTime);

		protected delegate void EngineEventOnRemoteAudioStatsHandler(uint uid, int quality, int networkTransportDelay, int jitterBufferDelay, int audioLossRate, int numChannels, int receivedSampleRate, int receivedBitrate, int totalFrozenTime, int frozenRate, int totalActiveTime);

		protected delegate void EngineEventOnAudioDeviceVolumeChangedHandler(int deviceType, int volume, bool muted);

		protected delegate void EngineEventOnAudioMixingStateChangedHandler(int state, int errorCode);

		protected delegate void EngineEventOnRtmpStreamingStateChangedHandler(string url, int state, int errCode);

		protected delegate void EngineEventOnNetworkTypeChangedHandler(int type);

		protected delegate void EngineEventOnLastmileProbeResultHandler(int state, uint upLinkPacketLossRate, uint upLinkjitter, uint upLinkAvailableBandwidth, uint downLinkPacketLossRate, uint downLinkJitter, uint downLinkAvailableBandwidth, uint rtt);

		protected delegate void EngineEventOnUserInfoUpdatedHandler(uint uid, uint userUid, string userAccount);

		protected delegate void EngineEventOnLocalAudioStateChangedHandler(int state, int error);

		protected delegate void EngineEventOnRemoteAudioStateChangedHandler(uint uid, int state, int reason, int elapsed);

		protected delegate void EngineEventOnLocalAudioStatsHandler(int numChannels, int sentSampleRate, int sentBitrate);

		protected delegate void EngineEventOnChannelMediaRelayStateChangedHandler(int state, int code);

		protected delegate void EngineEventOnChannelMediaRelayEventHandler(int events);

		protected delegate bool EngineEventOnReceiveAudioPacketHandler(IntPtr buffer, IntPtr size);

		protected delegate bool EngineEventOnReceiveVideoPacketHandler(IntPtr buffer, IntPtr size);

		protected delegate bool EngineEventOnSendAudioPacketHandler(IntPtr buffer, IntPtr size);

		protected delegate bool EngineEventOnSendVideoPacketHandler(IntPtr buffer, IntPtr size);

		protected delegate void EngineEventOnMediaMetaDataReceived(uint uid, uint size, IntPtr buffer, long timeStampMs);

		protected delegate void EngineEventOnConnectionStateChanged(int state, int reason);

		protected delegate bool EngineEventOnReadyToSendMetadata();

		protected delegate int EngineEventOnGetMaxMetadataSize();

		protected delegate void EngineEventOnClientRoleChanged(int oldRole, int newRole);

		protected delegate void EngineEventOnRemoteVideoStateChanged(uint uid, int state, int reason, int elapsed);

		protected delegate void EngineEventOnLocalVideoStateChanged(int localVideoState, int error);

		protected delegate void EngineEventOnFacePositionChanged(int imageWidth, int imageHeight, int x, int y, int width, int height, int vecDistance, int numFaces);

		protected delegate void ChannelEngineEventOnLeaveChannelHandler(string channelId, uint duration, uint txBytes, uint rxBytes, uint txAudioBytes, uint txVideoBytes, uint rxAudioBytes, uint rxVideoBytes, ushort txKBitRate, ushort rxKBitRate, ushort rxAudioKBitRate, ushort txAudioKBitRate, ushort rxVideoKBitRate, ushort txVideoKBitRate, ushort lastmileDelay, ushort txPacketLossRate, ushort rxPacketLossRate, uint userCount, double cpuAppUsage, double cpuTotalUsage, int gatewayRtt, double memoryAppUsageRatio, double memoryTotalUsageRatio, int memoryAppUsageInKbytes);

		protected delegate void ChannelEngineEventOnRtcStatsHandler(string channelId, uint duration, uint txBytes, uint rxBytes, uint txAudioBytes, uint txVideoBytes, uint rxAudioBytes, uint rxVideoBytes, ushort txKBitRate, ushort rxKBitRate, ushort rxAudioKBitRate, ushort txAudioKBitRate, ushort rxVideoKBitRate, ushort txVideoKBitRate, ushort lastmileDelay, ushort txPacketLossRate, ushort rxPacketLossRate, uint userCount, double cpuAppUsage, double cpuTotalUsage, int gatewayRtt, double memoryAppUsageRatio, double memoryTotalUsageRatio, int memoryAppUsageInKbytes);

		protected delegate void ChannelEngineEventOnRemoteVideoStatsHandler(string channelId, uint uid, int delay, int width, int height, int receivedBitrate, int decoderOutputFrameRate, int rendererOutputFrameRate, int packetLossRate, int rxStreamType, int totalFrozenTime, int frozenRate, int totalActiveTime);

		protected delegate void ChannelEngineEventOnRemoteAudioStatsHandler(string channelId, uint uid, int quality, int networkTransportDelay, int jitterBufferDelay, int audioLossRate, int numChannels, int receivedSampleRate, int receivedBitrate, int totalFrozenTime, int frozenRate, int totalActiveTime);

		protected delegate void EngineEventOnStreamMessageHandler(uint userId, int streamId, IntPtr data, int length);

		public const string MyLibName = "agoraSdkCWrapper";

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern bool createEngine(string appId);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern bool createEngine2(string appId, uint areaCode);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern bool deleteEngine();

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern IntPtr getSdkVersion();

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int joinChannel(string channelKey, string channelName, string info, uint uid);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int setLocalVoicePitch(double pitch);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int setRemoteVoicePosition(uint uid, double pan, double gain);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int setVoiceOnlyMode(bool enable);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int leaveChannel();

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int enableLastmileTest();

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int disableLastmileTest();

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int enableVideo();

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int disableVideo();

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int enableLocalVideo(bool enabled);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int enableLocalAudio(bool enabled);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int setupLocalVideo(int hwnd, int renderMode, uint uid, IntPtr priv);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int setupRemoteVideo(int hwnd, int renderMode, uint uid, IntPtr priv);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int setLocalRenderMode(int renderMode);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int setRemoteRenderMode(uint userId, int renderMode);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int setLocalVideoMirrorMode(int mirrorMode);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int startPreview();

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int stopPreview();

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int enableAudio();

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int disableAudio();

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int setParameters(string options);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern IntPtr getCallId();

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int rate(string callId, int rating, string desc);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int complain(string callId, string desc);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int setEnableSpeakerphone(bool enabled);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern bool isSpeakerphoneEnabled();

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int setDefaultAudioRoutetoSpeakerphone(bool enabled);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int enableAudioVolumeIndication(int interval, int smooth, bool report_vad);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int startAudioRecording(string filePath, int quality);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int startAudioRecording2(string filePath, int sampleRate, int quality);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int stopAudioRecording();

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int startAudioMixing(string filePath, bool loopBack, bool replace, int cycle);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int stopAudioMixing();

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int pauseAudioMixing();

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int resumeAudioMixing();

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int adjustAudioMixingVolume(int volume);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int getAudioMixingDuration();

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int getAudioMixingCurrentPosition();

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int muteLocalAudioStream(bool mute);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int muteAllRemoteAudioStreams(bool mute);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int muteRemoteAudioStream(uint uid, bool mute);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int switchCamera();

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int setVideoProfile(int profile, bool swapWidthAndHeight);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int muteLocalVideoStream(bool mute);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int muteAllRemoteVideoStreams(bool mute);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int muteRemoteVideoStream(uint uid, bool mute);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int setLogFile(string filePath);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int renewToken(string token);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int setChannelProfile(int profile);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int setClientRole(int role);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int enableDualStreamMode(bool enabled);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int setEncryptionMode(string encryptionMode);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int setEncryptionSecret(string secret);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int startRecordingService(string recordingKey);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int stopRecordingService(string recordingKey);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int refreshRecordingServiceStatus();

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int createDataStream(bool reliable, bool ordered);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int sendStreamMessage(int streamId, byte[] data, long length);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int setSpeakerphoneVolume(int volume);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int adjustRecordingSignalVolume(int volume);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int adjustPlaybackSignalVolume(int volume);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int setHighQualityAudioParametersWithFullband(int fullband, int stereo, int fullBitrate);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int enableInEarMonitoring(bool enabled);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int enableWebSdkInteroperability(bool enabled);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int setVideoQualityParameters(bool preferFrameRateOverImageQuality);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int startEchoTest();

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int startEchoTest2(int intervalInSeconds);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int stopEchoTest();

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int setRemoteVideoStreamType(uint uid, int streamType);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int setMixedAudioFrameParameters(int sampleRate, int samplesPerCall);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int setAudioMixingPosition(int pos);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int setLogFilter(uint filter);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int enableVideoObserver();

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int disableVideoObserver();

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int generateNativeTexture();

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int updateTexture(int tex, IntPtr data, uint uid);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int deleteTexture(int tex);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int updateVideoRawData(IntPtr data, uint uid);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern void addUserVideoInfo(uint userId, uint textureId);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern void removeUserVideoInfo(uint userId);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int setPlaybackDeviceVolume(int volume);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int getEffectsVolume();

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int setEffectsVolume(int volume);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int playEffect(int soundId, string filePath, int loopCount, double pitch, double pan, int gain, bool publish);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int stopEffect(int soundId);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int stopAllEffects();

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int preloadEffect(int soundId, string filePath);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int unloadEffect(int soundId);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int pauseEffect(int soundId);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int pauseAllEffects();

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int resumeEffect(int soundId);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int resumeAllEffects();

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int setDefaultMuteAllRemoteAudioStreams(bool mute);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int setDefaultMuteAllRemoteVideoStreams(bool mute);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern void freeObject(IntPtr obj);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int getConnectionState();

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int setAudioProfile(int audioProfile, int scenario);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int setVideoEncoderConfiguration(int width, int height, int frameRate, int minFrameRate, int bitrate, int minBitrate, int orientationMode, int degradationPreference, int videoMirrorMode);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int adjustAudioMixingPlayoutVolume(int volume);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int adjustAudioMixingPublishVolume(int volume);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int setVolumeOfEffect(int soundId, int volume);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int setRecordingAudioFrameParameters(int sampleRate, int channel, int mode, int samplesPerCall);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int setPlaybackAudioFrameParameters(int sampleRate, int channel, int mode, int samplesPerCall);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int setLocalPublishFallbackOption(int option);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int setRemoteSubscribeFallbackOption(int option);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int setRemoteDefaultVideoStreamType(int remoteVideoStreamType);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int addPublishStreamUrl(string url, bool transcodingEnabled);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int removePublishStreamUrl(string url);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern IntPtr getErrorDescription(int code);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int setLiveTranscoding(int width, int height, int videoBitrate, int videoFramerate, bool lowLatency, int videoGroup, int video_codec_profile, uint backgroundColor, uint userCount, string transcodingUserInfo, string transcodingExtraInfo, string metaData, string watermarkRtcImageUrl, int watermarkRtcImageX, int watermarkRtcImageY, int watermarkRtcImageWidth, int watermarkRtcImageHeight, string backgroundImageRtcImageUrl, int backgroundImageRtcImageX, int backgroundImageRtcImageY, int backgroundImageRtcImageWidth, int backgroundImageRtcImageHeight, int audioSampleRate, int audioBitrate, int audioChannels, int audioCodecProfile);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern bool createAVideoDeviceManager();

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int releaseAVideoDeviceManager();

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int startVideoDeviceTest(IntPtr hwnd);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int stopVideoDeviceTest();

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int getVideoDeviceCollectionCount();

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int getVideoDeviceCollectionDevice(int index, IntPtr deviceName, IntPtr deviceId);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int setVideoDeviceCollectionDevice(string deviceId);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int getCurrentVideoDevice(IntPtr deviceId);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern bool creatAAudioRecordingDeviceManager();

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int releaseAAudioRecordingDeviceManager();

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int getAudioRecordingDeviceCount();

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int getAudioRecordingDevice(int index, IntPtr deviceName, IntPtr deviceId);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int setAudioRecordingDevice(string deviceId);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int setAudioRecordingDeviceVolume(int volume);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int getAudioRecordingDeviceVolume();

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int setAudioRecordingDeviceMute(bool mute);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern bool isAudioRecordingDeviceMute();

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int getCurrentRecordingDeviceInfo(IntPtr deviceName, IntPtr deviceId);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int getCurrentRecordingDevice(IntPtr deviceId);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int startAudioRecordingDeviceTest(int indicationInterval);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int stopAudioRecordingDeviceTest();

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int getAudioPlaybackDeviceCount();

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern bool creatAAudioPlaybackDeviceManager();

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int releaseAAudioPlaybackDeviceManager();

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int getAudioPlaybackDevice(int index, IntPtr deviceName, IntPtr deviceId);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int setAudioPlaybackDevice(string deviceId);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int setAudioPlaybackDeviceVolume(int volume);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int getAudioPlaybackDeviceVolume();

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int setAudioPlaybackDeviceMute(bool mute);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern bool isAudioPlaybackDeviceMute();

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int startAudioPlaybackDeviceTest(string testAudioFilePath);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int stopAudioPlaybackDeviceTest();

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int getCurrentPlaybackDeviceInfo(IntPtr deviceName, IntPtr deviceId);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int getCurrentPlaybackDevice(IntPtr deviceId);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int pushVideoFrame(int type, int format, byte[] videoBuffer, int stride, int height, int cropLeft, int cropTop, int cropRight, int cropBottom, int rotation, long timestamp);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int setExternalVideoSource(bool enable, bool useTexture);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int setExternalAudioSource(bool enabled, int sampleRate, int channels);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int pushAudioFrame_(int audioFrameType, int samples, int bytesPerSample, int channels, int samplesPerSec, byte[] buffer, long renderTimeMs, int avsync_type);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int registerVideoRawDataObserver();

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int unRegisterVideoRawDataObserver();

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int registerAudioRawDataObserver();

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int unRegisterAudioRawDataObserver();

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int setRenderMode(int renderMode);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int getAudioMixingPlayoutVolume();

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int getAudioMixingPublishVolume();

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int setLocalVoiceChanger(int voiceChanger);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int setLocalVoiceReverbPreset(int audioReverbPreset);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int enableSoundPositionIndication(bool enabled);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int setLocalVoiceEqualization(int bandFrequency, int bandGain);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int setLocalVoiceReverb(int reverbKey, int value);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int setCameraCapturerConfiguration(int cameraCaptureConfiguration, int cameraDirection);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int setRemoteUserPriority(uint uid, int userPriority);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int setLogFileSize(uint fileSizeInKBytes);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int setExternalAudioSink(bool enabled, int sampleRate, int channels);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int pullAudioFrame_(IntPtr audioBuffer, int type, int samples, int bytesPerSample, int channels, int samplesPerSec, long renderTimeMs, int avsync_type);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int startLastmileProbeTest(bool probeUplink, bool probeDownlink, uint expectedUplinkBitrate, uint expectedDownlinkBitrate);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int stopLastmileProbeTest();

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int configPublisher(int width, int height, int framerate, int bitrate, int defaultLayout, int lifecycle, bool owner, int injectStreamWidth, int injectStreamHeight, string injectStreamUrl, string publishUrl, string rawStreamUrl, string extraInfo);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int addVideoWatermark(string url, int x, int y, int width, int height);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int addVideoWatermark2(string watermarkUrl, bool visibleInPreview, int positionInLandscapeX, int positionInLandscapeY, int positionInLandscapeWidth, int positionInLandscapeHeight, int positionInPortraitX, int positionInPortraitY, int positionInPortraitWidth, int positionInPortraitHeight);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int clearVideoWatermarks();

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int registerLocalUserAccount(string appId, string userAccount);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int joinChannelWithUserAccount(string token, string channelId, string userAccount);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int getUserInfoByUserAccount(string userAccount);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern IntPtr getUserInfoByUid(uint uid);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int setBeautyEffectOptions(bool enabled, int lighteningContrastLevel, float lighteningLevel, float smoothnessLevel, float rednessLevel);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int setInEarMonitoringVolume(int volume);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int startScreenCaptureByDisplayId(uint displayId, int x, int y, int width, int height, int screenCaptureVideoDimenWidth, int screenCaptureVideoDimenHeight, int screenCaptureFrameRate, int screenCaptureBitrate, bool screenCaptureCaptureMouseCursor);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int startScreenCaptureByScreenRect(int screenRectX, int screenRectY, int screenRectWidth, int screenRectHeight, int regionRectX, int regionRectY, int regionRectWidth, int regionRectHeight, int screenCaptureVideoDimenWidth, int screenCaptureVideoDimenHeight, int screenCaptureFrameRate, int screenCaptureBitrate, bool screenCaptureCaptureMouseCursor);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int setScreenCaptureContentHint(int videoContentHint);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int updateScreenCaptureParameters(int screenCaptureVideoDimenWidth, int screenCaptureVideoDimenHeight, int screenCaptureFrameRate, int screenCaptureBitrate, bool screenCaptureCaptureMouseCursor);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int updateScreenCaptureRegion(int x, int y, int width, int height);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int stopScreenCapture();

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int addInjectStreamUrl(string url, int width, int height, int videoGop, int videoFramerate, int videoBitrate, int audioSampleRate, int audioBitrate, int audioChannels);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int removeInjectStreamUrl(string url);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int enableLoopbackRecording(bool enabled, string deviceName);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int setAudioSessionOperationRestriction(int restriction);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int switchChannel(string token, string channelId);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int startChannelMediaRelay(string srcChannelName, string srcToken, uint srcUid, string destChannelName, string destToken, uint destUid, int destCount);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int updateChannelMediaRelay(string srcChannelName, string srcToken, uint srcUid, string destChannelName, string destToken, uint destUid, int destCount);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int stopChannelMediaRelay();

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int sendMetadata(uint uid, uint size, byte[] buffer, long timeStampMs);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int registerPacketObserver();

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int unRegisterPacketObserver();

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int registerMediaMetadataObserver(int metaDataType);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int unRegisterMediaMetadataObserver();

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int setMirrorApplied(bool wheatherApply);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int sendMetadata(uint uid, uint size, string buffer, long timeStamps);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int startScreenCaptureByWindowId(int windowId, int regionRectX, int regionRectY, int regionRectWidth, int regionRectHeight, int screenCaptureVideoDimenWidth, int screenCaptureVideoDimenHeight, int screenCaptureFrameRate, int screenCaptureBitrate, bool screenCaptureCaptureMouseCursor);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int setDefaultEngineSettings();

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int adjustUserPlaybackSignalVolume(uint uid, int volume);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int setMultiChannelWant(bool multiChannelWant);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern bool getMultiChannelWanted();

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int setAudioMixingPitch(int pitch);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern void initEventOnEngineCallback(OnJoinChannelSuccessHandler OnJoinChannelSuccess, OnReJoinChannelSuccessHandler OnReJoinChannelSuccess, OnConnectionLostHandler OnConnectionLost, EngineEventOnLeaveChannelHandler OnLeaveChannel, OnConnectionInterruptedHandler OnConnectionInterrupted, OnRequestTokenHandler OnRequestToken, OnUserJoinedHandler OnUserJoined, EngineEventOnUserOfflineHandler OnUserOffline, EngineEventOnAudioVolumeIndicationHandler OnAudioVolumeIndication, OnUserMutedAudioHandler OnUserMuteAudio, OnSDKWarningHandler OnSDKWarning, OnSDKErrorHandler OnSDKError, EngineEventOnRtcStatsHandler OnRtcStats, OnAudioMixingFinishedHandler OnAudioMixingFinished, EngineEventOnAudioRouteChangedHandler OnAudioRouteChanged, OnFirstRemoteVideoDecodedHandler OnFirstRemoteVideoDecoded, OnVideoSizeChangedHandler OnVideoSizeChanged, EngineEventOnClientRoleChanged onClientRolteChanged, OnUserMuteVideoHandler OnUserMuteVideo, OnMicrophoneEnabledHandler OnMicrophoneEnabled, OnApiExecutedHandler OnApiExecuted, OnFirstLocalAudioFrameHandler OnFirstLocalAudioFrame, OnFirstRemoteAudioFrameHandler OnFirstRemoteAudioFrame, OnLastmileQualityHandler OnLastmileQuality, OnAudioQualityHandler onAudioQuality, OnStreamInjectedStatusHandler onStreamInjectedStatus, OnStreamUnpublishedHandler onStreamUnpublished, OnStreamPublishedHandler onStreamPublished, OnStreamMessageErrorHandler onStreamMessageError, EngineEventOnStreamMessageHandler onStreamMessage, OnConnectionBannedHandler onConnectionBanned, OnVideoStoppedHandler OnVideoStopped, OnTokenPrivilegeWillExpireHandler onTokenPrivilegeWillExpire, OnNetworkQualityHandler onNetworkQuality, EngineEventOnLocalVideoStatsHandler onLocalVideoStats, EngineEventOnRemoteVideoStatsHandler onRemoteVideoStats, EngineEventOnRemoteAudioStatsHandler onRemoteAudioStats, OnFirstLocalVideoFrameHandler OnFirstLocalVideoFrame, OnFirstRemoteVideoFrameHandler OnFirstRemoteVideoFrame, OnUserEnableVideoHandler OnUserEnableVideo, OnAudioDeviceStateChangedHandler onAudioDeviceStateChanged, OnCameraReadyHandler onCameraReady, OnCameraFocusAreaChangedHandler onCameraFocusAreaChanged, OnCameraExposureAreaChangedHandler onCameraExposureAreaChanged, OnRemoteAudioMixingBeginHandler onRemoteAudioMixingBegin, OnRemoteAudioMixingEndHandler onRemoteAudioMixingEnd, OnAudioEffectFinishedHandler onAudioEffectFinished, OnVideoDeviceStateChangedHandler onVideoDeviceStateChanged, EngineEventOnRemoteVideoStateChanged OnRemoteVideoStateChanged, OnUserEnableLocalVideoHandler OnUserEnableLocalVideo, OnLocalPublishFallbackToAudioOnlyHandler OnLocalPublishFallbackToAudioOnly, OnRemoteSubscribeFallbackToAudioOnlyHandler onRemoteSubscribeFallbackToAudioOnly, EngineEventOnConnectionStateChanged onConnectionStateChanged, OnRemoteVideoTransportStatsHandler onRemoteVideoTransportStats, OnRemoteAudioTransportStatsHandler onRemoteAudioTransportStats, OnTranscodingUpdatedHandler onTranscodingUpdated, EngineEventOnAudioDeviceVolumeChangedHandler onAudioDeviceVolumeChanged, OnActiveSpeakerHandler onActiveSpeaker, OnMediaEngineStartCallSuccessHandler onMediaEngineStartCallSuccess, OnMediaEngineLoadSuccessHandler onMediaEngineLoadSuccess, EngineEventOnAudioMixingStateChangedHandler onAudioMixingStateChanged, OnFirstRemoteAudioDecodedHandler onFirstRemoteAudioDecoded, EngineEventOnLocalVideoStateChanged onLocalVideoStateChanged, EngineEventOnRtmpStreamingStateChangedHandler onRtmpStreamingStateChanged, EngineEventOnNetworkTypeChangedHandler onNetworkTypeChanged, EngineEventOnLastmileProbeResultHandler onLastmileProbeResult, OnLocalUserRegisteredHandler onLocalUserRegistered, EngineEventOnUserInfoUpdatedHandler onUserInfoUpdated, EngineEventOnLocalAudioStateChangedHandler onLocalAudioStateChanged, EngineEventOnRemoteAudioStateChangedHandler onRemoteAudioStateChanged, EngineEventOnLocalAudioStatsHandler onLocalAudioStats, EngineEventOnChannelMediaRelayStateChangedHandler onChannelMediaRelayStateChanged, EngineEventOnChannelMediaRelayEventHandler onChannelMediaRelayEvent, EngineEventOnFacePositionChanged onFacePositionChanged);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern void initChannelEventCallback(IntPtr channel, ChannelOnWarningHandler onWarning, ChannelOnErrorHandler onError, ChannelOnJoinChannelSuccessHandler onJoinChannelSuccess, ChannelOnReJoinChannelSuccessHandler onRejoinChannelSuccess, ChannelEngineEventOnLeaveChannelHandler onLeaveChannel, ChannelOnClientRoleChangedHandler onClientRoleChanged, ChannelOnUserJoinedHandler onUserJoined, ChannelOnUserOffLineHandler onUserOffline, ChannelOnConnectionLostHandler onConnectionLost, ChannelOnRequestTokenHandler onRequestToken, ChannelOnTokenPrivilegeWillExpireHandler onTokenPrivilegeWillExpire, ChannelEngineEventOnRtcStatsHandler onRtcStats, ChannelOnNetworkQualityHandler onNetworkQuality, ChannelEngineEventOnRemoteVideoStatsHandler onRemoteVideoStats, ChannelEngineEventOnRemoteAudioStatsHandler onRemoteAudioStats, ChannelOnRemoteAudioStateChangedHandler onRemoteAudioStateChanged, ChannelOnActiveSpeakerHandler onActiveSpeaker, ChannelOnVideoSizeChangedHandler onVideoSizeChanged, ChannelOnRemoteVideoStateChangedHandler onRemoteVideoStateChanged, ChannelOnStreamMessageHandler onStreamMessage, ChannelOnStreamMessageErrorHandler onStreamMessageError, ChannelOnMediaRelayStateChangedHandler onMediaRelayStateChanged, ChannelOnMediaRelayEventHandler onMediaRelayEvent, ChannelOnRtmpStreamingStateChangedHandler onRtmpStreamingStateChanged, ChannelOnTranscodingUpdatedHandler onTranscodingUpdated, ChannelOnStreamInjectedStatusHandler onStreamInjectedStatus, ChannelOnRemoteSubscribeFallbackToAudioOnlyHandler onRemoteSubscribeFallbackToAudioOnly, ChannelOnConnectionStateChangedHandler onConnectionStateChanged, ChannelOnLocalPublishFallbackToAudioOnlyHandler onLocalPublishFallbackToAudioOnly);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern void initEventOnCaptureVideoFrame(EngineEventOnCaptureVideoFrame onCaptureVideoFrame);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern void initEventOnRenderVideoFrame(EngineEventOnRenderVideoFrame onRenderVideoFrame);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern void initEventOnRecordAudioFrame(EngineEventOnRecordAudioFrame onRecordAudioFrame);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern void initEventOnPlaybackAudioFrame(EngineEventOnPlaybackAudioFrame onPlaybackAudioFrame);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern void initEventOnMixedAudioFrame(EngineEventOnMixedAudioFrame onMixedAudioFrame);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern void initEventOnPlaybackAudioFrameBeforeMixing(EngineEventOnPlaybackAudioFrameBeforeMixing onPlaybackAudioFrameBeforeMixing);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern void initEventOnPullAudioFrame(EngineEventOnPullAudioFrameHandler onPullAudioFrame);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern void initEventOnPacketCallback(EngineEventOnReceiveAudioPacketHandler onReceiveAudioPacket, EngineEventOnReceiveVideoPacketHandler onReceiveVideoPacket, EngineEventOnSendAudioPacketHandler onSendAudioPacket, EngineEventOnSendVideoPacketHandler onSendVideoPacket);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern void initEventOnMetaDataCallback(EngineEventOnMediaMetaDataReceived onMetadataReceived, EngineEventOnReadyToSendMetadata onReadyToSendMetadata, EngineEventOnGetMaxMetadataSize onGetMaxMetadataSize);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern IntPtr createChannel(string channelId);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int ReleaseChannel(IntPtr channel);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int joinChannel2(IntPtr channel, string token, string info, uint uid, bool autoSubscribeAudio, bool autoSubscribeVideo);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int joinChannelWithUserAccount2(IntPtr channel, string token, string userAccount, bool autoSubscribeAudio, bool autoSubscribeVideo);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int leaveChannel2(IntPtr channel);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int publish(IntPtr channel);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int unpublish(IntPtr channel);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern IntPtr channelId(IntPtr channel);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern IntPtr getCallId2(IntPtr channel);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int renewToken2(IntPtr channel, string token);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int setEncryptionSecret2(IntPtr channel, string secret);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int setEncryptionMode2(IntPtr channel, string encryptionMode);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int setClientRole2(IntPtr channel, int role);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int setRemoteUserPriority2(IntPtr channel, uint uid, int userPriority);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int setRemoteVoicePosition2(IntPtr channel, uint uid, double pan, double gain);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int setRemoteRenderMode2(IntPtr channel, uint userId, int renderMode, int mirrorMode);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int setDefaultMuteAllRemoteAudioStreams2(IntPtr channel, bool mute);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int setDefaultMuteAllRemoteVideoStreams2(IntPtr channel, bool mute);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int muteAllRemoteAudioStreams2(IntPtr channel, bool mute);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int adjustUserPlaybackSignalVolume2(IntPtr channel, uint userId, int volume);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int muteRemoteAudioStream2(IntPtr channel, uint userId, bool mute);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int muteAllRemoteVideoStreams2(IntPtr channel, bool mute);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int muteRemoteVideoStream2(IntPtr channel, uint userId, bool mute);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int setRemoteVideoStreamType2(IntPtr channel, uint userId, int streamType);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int setRemoteDefaultVideoStreamType2(IntPtr channel, int streamType);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int createDataStream2(IntPtr channel, bool reliable, bool ordered);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int sendStreamMessage2(IntPtr channel, int streamId, string data, long length);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int addPublishStreamUrl2(IntPtr channel, string url, bool transcodingEnabled);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int removePublishStreamUrl2(IntPtr channel, string url);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int setLiveTranscoding2(IntPtr channel, int width, int height, int videoBitrate, int videoFramerate, bool lowLatency, int videoGroup, int video_codec_profile, uint backgroundColor, uint userCount, string transcodingUserInfo, string transcodingExtraInfo, string metaData, string watermarkRtcImageUrl, int watermarkRtcImageX, int watermarkRtcImageY, int watermarkRtcImageWidth, int watermarkRtcImageHeight, string backgroundImageRtcImageUrl, int backgroundImageRtcImageX, int backgroundImageRtcImageY, int backgroundImageRtcImageWidth, int backgroundImageRtcImageHeight, int audioSampleRate, int audioBitrate, int audioChannels, int audioCodecProfile);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int addInjectStreamUrl2(IntPtr channel, string url, int width, int height, int videoGop, int videoFramerate, int videoBitrate, int audioSampleRate, int audioBitrate, int audioChannels);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int removeInjectStreamUrl2(IntPtr channel, string url);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int startChannelMediaRelay2(IntPtr channel, string srcChannelName, string srcToken, uint srcUid, string destChannelName, string destToken, uint destUid, int destCount);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int updateChannelMediaRelay2(IntPtr channel, string srcChannelName, string srcToken, uint srcUid, string destChannelName, string destToken, uint destUid, int destCount);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int stopChannelMediaRelay2(IntPtr channel);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int getConnectionState2(IntPtr channel);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern void addUserVideoInfo2(string channelId, uint _userId, uint _textureId);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern void removeUserVideoInfo2(string channelId, uint _userId);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int updateVideoRawData2(IntPtr data, string channelId, uint uid);

		[DllImport("agoraSdkCWrapper", CharSet = CharSet.Ansi)]
		protected static extern int enableFaceDetection(bool enable);
	}
	public abstract class IMetadataObserver : IRtcEngineNative
	{
		public abstract int RegisterMediaMetadataObserver(METADATA_TYPE metaDataType);

		public abstract int UnRegisterMediaMetadataObserver();
	}
	public sealed class MetadataObserver : IMetadataObserver
	{
		public delegate void OnMediaMetaDataReceivedHandler(Metadata metadata);

		public delegate bool OnReadyToSendMetadataHandler(ref Metadata metadata);

		public delegate int OnGetMaxMetadataSizeHandler();

		public const int defaultMaxMetaDataSize = 1024;

		public OnMediaMetaDataReceivedHandler _OnMediaMetaDataReceived;

		public OnReadyToSendMetadataHandler _OnReadyToSendMetadata;

		public OnGetMaxMetadataSizeHandler _OnGetMaxMetadataSize;

		private static IRtcEngine _irtcEngine;

		public static MetadataObserver _metaDataObserver;

		private MetadataObserver(IRtcEngine irtcEngine)
		{
			_irtcEngine = irtcEngine;
		}

		public static MetadataObserver GetInstance(IRtcEngine irtcEngine)
		{
			if (_metaDataObserver == null)
			{
				_metaDataObserver = new MetadataObserver(irtcEngine);
			}
			return _metaDataObserver;
		}

		public static void releaseInstance()
		{
			_metaDataObserver = null;
		}

		public void SetEngine(IRtcEngine irtcEngine)
		{
			_irtcEngine = irtcEngine;
		}

		public override int RegisterMediaMetadataObserver(METADATA_TYPE metaDataType)
		{
			if (_irtcEngine == null)
			{
				return -7;
			}
			IRtcEngineNative.initEventOnMetaDataCallback(OnMediaMetaDataReceivedCallback, OnReadyToSendMetadataCallback, OnGetMaxMetadataSizeCallback);
			return IRtcEngineNative.registerMediaMetadataObserver((int)metaDataType);
		}

		public override int UnRegisterMediaMetadataObserver()
		{
			if (_irtcEngine == null)
			{
				return -7;
			}
			int result = IRtcEngineNative.unRegisterMediaMetadataObserver();
			IRtcEngineNative.initEventOnMetaDataCallback(null, null, null);
			return result;
		}

		[MonoPInvokeCallback(typeof(EngineEventOnMediaMetaDataReceived))]
		private static void OnMediaMetaDataReceivedCallback(uint uid, uint size, IntPtr buffer, long timeStampMs)
		{
			if (_irtcEngine != null && _metaDataObserver != null && _metaDataObserver._OnMediaMetaDataReceived != null)
			{
				Metadata metadata = default(Metadata);
				metadata.uid = uid;
				metadata.size = size;
				byte[] array = new byte[size];
				Marshal.Copy(buffer, array, 0, (int)size);
				metadata.buffer = array;
				metadata.timeStampMs = timeStampMs;
				_metaDataObserver._OnMediaMetaDataReceived(metadata);
			}
		}

		[MonoPInvokeCallback(typeof(EngineEventOnReadyToSendMetadata))]
		private static bool OnReadyToSendMetadataCallback()
		{
			if (_irtcEngine != null && _metaDataObserver != null && _metaDataObserver._OnReadyToSendMetadata != null)
			{
				Metadata metadata = default(Metadata);
				bool result = _metaDataObserver._OnReadyToSendMetadata(ref metadata);
				if (metadata.size != 0 && metadata.buffer != null)
				{
					IRtcEngineNative.sendMetadata(metadata.uid, metadata.size, metadata.buffer, metadata.timeStampMs);
				}
				return result;
			}
			return true;
		}

		[MonoPInvokeCallback(typeof(EngineEventOnGetMaxMetadataSize))]
		private static int OnGetMaxMetadataSizeCallback()
		{
			if (_irtcEngine != null && _metaDataObserver != null && _metaDataObserver._OnGetMaxMetadataSize != null)
			{
				return _metaDataObserver._OnGetMaxMetadataSize();
			}
			return 1024;
		}
	}
	public abstract class IPacketObserver : IRtcEngineNative
	{
		public abstract int RegisterPacketObserver();

		public abstract int UnRegisterPacketObserver();
	}
	public sealed class PacketObserver : IPacketObserver
	{
		public delegate bool OnReceiveAudioPacketHandler(Packet packet);

		public delegate bool OnReceiveVideoPacketHandler(Packet packet);

		public delegate bool OnSendVideoPacketHandler(Packet packet);

		public delegate bool OnSendAudioPacketHandler(Packet packet);

		public OnReceiveAudioPacketHandler _OnReceiveAudioPacket;

		public OnReceiveVideoPacketHandler _OnReceiveVideoPacket;

		public OnSendVideoPacketHandler _OnSendVideoPacket;

		public OnSendAudioPacketHandler _OnSendAudioPacket;

		private static IRtcEngine _irtcEngine;

		public static PacketObserver _packetObserver;

		private PacketObserver(IRtcEngine irtcEngine)
		{
			_irtcEngine = irtcEngine;
		}

		public static PacketObserver GetInstance(IRtcEngine irtcEngine)
		{
			if (_packetObserver == null)
			{
				_packetObserver = new PacketObserver(irtcEngine);
			}
			return _packetObserver;
		}

		public static void ReleaseInstance()
		{
			_packetObserver = null;
		}

		public void SetEngine(IRtcEngine irtcEngine)
		{
			_irtcEngine = irtcEngine;
		}

		public override int RegisterPacketObserver()
		{
			if (_irtcEngine == null)
			{
				return -7;
			}
			IRtcEngineNative.initEventOnPacketCallback(OnReceiveAudioPacketCallback, OnReceiveVideoPacketCallback, OnSendAudioPacketCallback, OnSendVideoPacketCallback);
			return IRtcEngineNative.registerPacketObserver();
		}

		public override int UnRegisterPacketObserver()
		{
			if (_irtcEngine == null)
			{
				return -7;
			}
			int result = IRtcEngineNative.unRegisterPacketObserver();
			IRtcEngineNative.initEventOnPacketCallback(null, null, null, null);
			return result;
		}

		[MonoPInvokeCallback(typeof(EngineEventOnReceiveAudioPacketHandler))]
		private static bool OnReceiveAudioPacketCallback(IntPtr buffer, IntPtr size)
		{
			if (_irtcEngine != null && _packetObserver != null && _packetObserver._OnReceiveAudioPacket != null)
			{
				Packet packet = default(Packet);
				packet.buffer = buffer;
				packet.size = size;
				return _packetObserver._OnReceiveAudioPacket(packet);
			}
			return true;
		}

		[MonoPInvokeCallback(typeof(EngineEventOnReceiveVideoPacketHandler))]
		private static bool OnReceiveVideoPacketCallback(IntPtr buffer, IntPtr size)
		{
			if (_irtcEngine != null && _packetObserver != null && _packetObserver._OnReceiveVideoPacket != null)
			{
				Packet packet = default(Packet);
				packet.buffer = buffer;
				packet.size = size;
				return _packetObserver._OnReceiveVideoPacket(packet);
			}
			return true;
		}

		[MonoPInvokeCallback(typeof(EngineEventOnSendAudioPacketHandler))]
		private static bool OnSendAudioPacketCallback(IntPtr buffer, IntPtr size)
		{
			if (_irtcEngine != null && _packetObserver != null && _packetObserver._OnSendAudioPacket != null)
			{
				Packet packet = default(Packet);
				packet.buffer = buffer;
				packet.size = size;
				return _packetObserver._OnSendAudioPacket(packet);
			}
			return true;
		}

		[MonoPInvokeCallback(typeof(EngineEventOnSendVideoPacketHandler))]
		private static bool OnSendVideoPacketCallback(IntPtr buffer, IntPtr size)
		{
			if (_irtcEngine != null && _packetObserver != null && _packetObserver._OnSendVideoPacket != null)
			{
				Packet packet = default(Packet);
				packet.buffer = buffer;
				packet.size = size;
				return _packetObserver._OnSendVideoPacket(packet);
			}
			return true;
		}
	}
	public abstract class IAudioRawDataManager : IRtcEngineNative
	{
		public abstract int SetOnRecordAudioFrameCallback(AudioRawDataManager.OnRecordAudioFrameHandler action);

		public abstract int SetOnPlaybackAudioFrameCallback(AudioRawDataManager.OnPlaybackAudioFrameHandler action);

		public abstract int SetOnMixedAudioFrameCallback(AudioRawDataManager.OnMixedAudioFrameHandler action);

		public abstract int SetOnPlaybackAudioFrameBeforeMixingCallback(AudioRawDataManager.OnPlaybackAudioFrameBeforeMixingHandler action);

		public abstract int RegisterAudioRawDataObserver();

		public abstract int UnRegisterAudioRawDataObserver();

		public abstract int PullAudioFrame(IntPtr audioBuffer, int type, int samples, int bytesPerSample, int channels, int samplesPerSec, long renderTimeMs, int avsync_type);
	}
	public sealed class AudioRawDataManager : IAudioRawDataManager
	{
		public delegate void OnRecordAudioFrameHandler(AudioFrame audioFrame);

		public delegate void OnPlaybackAudioFrameHandler(AudioFrame audioFrame);

		public delegate void OnMixedAudioFrameHandler(AudioFrame audioFrame);

		public delegate void OnPlaybackAudioFrameBeforeMixingHandler(uint uid, AudioFrame audioFrame);

		private static IRtcEngine _irtcEngine;

		private static AudioRawDataManager _audioRawDataManagerInstance;

		private OnRecordAudioFrameHandler OnRecordAudioFrame;

		private OnPlaybackAudioFrameHandler OnPlaybackAudioFrame;

		private OnMixedAudioFrameHandler OnMixedAudioFrame;

		private OnPlaybackAudioFrameBeforeMixingHandler OnPlaybackAudioFrameBeforeMixing;

		private AudioRawDataManager(IRtcEngine irtcEngine)
		{
			_irtcEngine = irtcEngine;
		}

		public static AudioRawDataManager GetInstance(IRtcEngine irtcEngine)
		{
			if (_audioRawDataManagerInstance == null)
			{
				_audioRawDataManagerInstance = new AudioRawDataManager(irtcEngine);
			}
			return _audioRawDataManagerInstance;
		}

		public static void ReleaseInstance()
		{
			_audioRawDataManagerInstance = null;
		}

		public void SetEngine(IRtcEngine irtcEngine)
		{
			_irtcEngine = irtcEngine;
		}

		public override int SetOnRecordAudioFrameCallback(OnRecordAudioFrameHandler action)
		{
			if (_irtcEngine == null)
			{
				return -7;
			}
			if (action == null)
			{
				OnRecordAudioFrame = null;
				IRtcEngineNative.initEventOnRecordAudioFrame(null);
			}
			else
			{
				OnRecordAudioFrame = action;
				IRtcEngineNative.initEventOnRecordAudioFrame(OnRecordAudioFrameCallback);
			}
			return 0;
		}

		public override int SetOnPlaybackAudioFrameCallback(OnPlaybackAudioFrameHandler action)
		{
			if (_irtcEngine == null)
			{
				return -7;
			}
			if (action == null)
			{
				OnPlaybackAudioFrame = null;
				IRtcEngineNative.initEventOnPlaybackAudioFrame(null);
			}
			else
			{
				OnPlaybackAudioFrame = action;
				IRtcEngineNative.initEventOnPlaybackAudioFrame(OnPlaybackAudioFrameCallback);
			}
			return 0;
		}

		public override int SetOnMixedAudioFrameCallback(OnMixedAudioFrameHandler action)
		{
			if (_irtcEngine == null)
			{
				return -7;
			}
			if (action == null)
			{
				OnMixedAudioFrame = null;
				IRtcEngineNative.initEventOnMixedAudioFrame(null);
			}
			else
			{
				OnMixedAudioFrame = action;
				IRtcEngineNative.initEventOnMixedAudioFrame(OnMixedAudioFrameCallback);
			}
			return 0;
		}

		public override int SetOnPlaybackAudioFrameBeforeMixingCallback(OnPlaybackAudioFrameBeforeMixingHandler action)
		{
			if (_irtcEngine == null)
			{
				return -7;
			}
			if (action == null)
			{
				OnPlaybackAudioFrameBeforeMixing = null;
				IRtcEngineNative.initEventOnPlaybackAudioFrameBeforeMixing(null);
			}
			else
			{
				OnPlaybackAudioFrameBeforeMixing = action;
				IRtcEngineNative.initEventOnPlaybackAudioFrameBeforeMixing(OnPlaybackAudioFrameBeforeMixingCallback);
			}
			return 0;
		}

		public override int RegisterAudioRawDataObserver()
		{
			if (_irtcEngine == null)
			{
				return -7;
			}
			return IRtcEngineNative.registerAudioRawDataObserver();
		}

		public override int UnRegisterAudioRawDataObserver()
		{
			if (_irtcEngine == null)
			{
				return -7;
			}
			return IRtcEngineNative.unRegisterAudioRawDataObserver();
		}

		public override int PullAudioFrame(IntPtr audioBuffer, int type, int samples, int bytesPerSample, int channels, int samplesPerSec, long renderTimeMs, int avsync_type)
		{
			if (_irtcEngine == null)
			{
				return -7;
			}
			return IRtcEngineNative.pullAudioFrame_(audioBuffer, type, samples, bytesPerSample, channels, samplesPerSec, renderTimeMs, avsync_type);
		}

		[MonoPInvokeCallback(typeof(EngineEventOnRecordAudioFrame))]
		private static void OnRecordAudioFrameCallback(int type, int samples, int bytesPerSample, int channels, int samplesPerSec, IntPtr buffer, long renderTimeMs, int avsync_type)
		{
			if (_irtcEngine != null && _audioRawDataManagerInstance != null && _audioRawDataManagerInstance.OnRecordAudioFrame != null)
			{
				AudioFrame audioFrame = default(AudioFrame);
				audioFrame.type = (AUDIO_FRAME_TYPE)type;
				audioFrame.samples = samples;
				audioFrame.bytesPerSample = bytesPerSample;
				audioFrame.channels = channels;
				audioFrame.samplesPerSec = samplesPerSec;
				byte[] array = new byte[bytesPerSample * channels * samples];
				Marshal.Copy(buffer, array, 0, bytesPerSample * channels * samples);
				audioFrame.buffer = array;
				audioFrame.renderTimeMs = renderTimeMs;
				audioFrame.avsync_type = avsync_type;
				_audioRawDataManagerInstance.OnRecordAudioFrame(audioFrame);
			}
		}

		[MonoPInvokeCallback(typeof(EngineEventOnPlaybackAudioFrame))]
		private static void OnPlaybackAudioFrameCallback(int type, int samples, int bytesPerSample, int channels, int samplesPerSec, IntPtr buffer, long renderTimeMs, int avsync_type)
		{
			if (_irtcEngine != null && _audioRawDataManagerInstance != null && _audioRawDataManagerInstance.OnPlaybackAudioFrame != null)
			{
				AudioFrame audioFrame = default(AudioFrame);
				audioFrame.type = (AUDIO_FRAME_TYPE)type;
				audioFrame.samples = samples;
				audioFrame.bytesPerSample = bytesPerSample;
				audioFrame.channels = channels;
				audioFrame.samplesPerSec = samplesPerSec;
				byte[] array = new byte[bytesPerSample * channels * samples];
				Marshal.Copy(buffer, array, 0, bytesPerSample * channels * samples);
				audioFrame.buffer = array;
				audioFrame.renderTimeMs = renderTimeMs;
				audioFrame.avsync_type = avsync_type;
				_audioRawDataManagerInstance.OnPlaybackAudioFrame(audioFrame);
			}
		}

		[MonoPInvokeCallback(typeof(EngineEventOnMixedAudioFrame))]
		private static void OnMixedAudioFrameCallback(int type, int samples, int bytesPerSample, int channels, int samplesPerSec, IntPtr buffer, long renderTimeMs, int avsync_type)
		{
			if (_irtcEngine != null && _audioRawDataManagerInstance != null && _audioRawDataManagerInstance.OnMixedAudioFrame != null)
			{
				AudioFrame audioFrame = default(AudioFrame);
				audioFrame.type = (AUDIO_FRAME_TYPE)type;
				audioFrame.samples = samples;
				audioFrame.bytesPerSample = bytesPerSample;
				audioFrame.channels = channels;
				audioFrame.samplesPerSec = samplesPerSec;
				byte[] array = new byte[bytesPerSample * channels * samples];
				Marshal.Copy(buffer, array, 0, bytesPerSample * channels * samples);
				audioFrame.buffer = array;
				audioFrame.renderTimeMs = renderTimeMs;
				audioFrame.avsync_type = avsync_type;
				_audioRawDataManagerInstance.OnMixedAudioFrame(audioFrame);
			}
		}

		[MonoPInvokeCallback(typeof(EngineEventOnPlaybackAudioFrameBeforeMixing))]
		private static void OnPlaybackAudioFrameBeforeMixingCallback(uint uid, int type, int samples, int bytesPerSample, int channels, int samplesPerSec, IntPtr buffer, long renderTimeMs, int avsync_type)
		{
			if (_irtcEngine != null && _audioRawDataManagerInstance != null && _audioRawDataManagerInstance.OnPlaybackAudioFrameBeforeMixing != null)
			{
				AudioFrame audioFrame = default(AudioFrame);
				audioFrame.type = (AUDIO_FRAME_TYPE)type;
				audioFrame.samples = samples;
				audioFrame.bytesPerSample = bytesPerSample;
				audioFrame.channels = channels;
				audioFrame.samplesPerSec = samplesPerSec;
				byte[] array = new byte[bytesPerSample * channels * samples];
				Marshal.Copy(buffer, array, 0, bytesPerSample * channels * samples);
				audioFrame.buffer = array;
				audioFrame.renderTimeMs = renderTimeMs;
				audioFrame.avsync_type = avsync_type;
				_audioRawDataManagerInstance.OnPlaybackAudioFrameBeforeMixing(uid, audioFrame);
			}
		}
	}
	public abstract class IVideoRawDataManager : IRtcEngineNative
	{
		public abstract int SetOnCaptureVideoFrameCallback(VideoRawDataManager.OnCaptureVideoFrameHandler action);

		public abstract int SetOnRenderVideoFrameCallback(VideoRawDataManager.OnRenderVideoFrameHandler action);

		public abstract int RegisterVideoRawDataObserver();

		public abstract int UnRegisterVideoRawDataObserver();
	}
	public sealed class VideoRawDataManager : IVideoRawDataManager
	{
		public delegate void OnCaptureVideoFrameHandler(VideoFrame videoFrame);

		public delegate void OnRenderVideoFrameHandler(uint uid, VideoFrame videoFrame);

		private static IRtcEngine _irtcEngine;

		private static VideoRawDataManager _videoRawDataManagerInstance;

		private OnCaptureVideoFrameHandler OnCaptureVideoFrame;

		private OnRenderVideoFrameHandler OnRenderVideoFrame;

		private VideoRawDataManager(IRtcEngine irtcEngine)
		{
			_irtcEngine = irtcEngine;
		}

		public static VideoRawDataManager GetInstance(IRtcEngine irtcEngine)
		{
			if (_videoRawDataManagerInstance == null)
			{
				_videoRawDataManagerInstance = new VideoRawDataManager(irtcEngine);
			}
			return _videoRawDataManagerInstance;
		}

		public static void ReleaseInstance()
		{
			_videoRawDataManagerInstance = null;
		}

		public void SetEngine(IRtcEngine irtcEngine)
		{
			_irtcEngine = irtcEngine;
		}

		public override int SetOnCaptureVideoFrameCallback(OnCaptureVideoFrameHandler action)
		{
			if (_irtcEngine == null)
			{
				return -7;
			}
			if (action == null)
			{
				OnCaptureVideoFrame = null;
				IRtcEngineNative.initEventOnCaptureVideoFrame(null);
			}
			else
			{
				OnCaptureVideoFrame = action;
				IRtcEngineNative.initEventOnCaptureVideoFrame(OnCaptureVideoFrameCallback);
			}
			return 0;
		}

		public override int SetOnRenderVideoFrameCallback(OnRenderVideoFrameHandler action)
		{
			if (_irtcEngine == null)
			{
				return -7;
			}
			if (action == null)
			{
				OnRenderVideoFrame = null;
				IRtcEngineNative.initEventOnRenderVideoFrame(null);
			}
			else
			{
				OnRenderVideoFrame = action;
				IRtcEngineNative.initEventOnRenderVideoFrame(OnRenderVideoFrameCallback);
			}
			return 0;
		}

		public override int RegisterVideoRawDataObserver()
		{
			if (_irtcEngine == null)
			{
				return 0;
			}
			return IRtcEngineNative.registerVideoRawDataObserver();
		}

		public override int UnRegisterVideoRawDataObserver()
		{
			if (_irtcEngine == null)
			{
				return 0;
			}
			return IRtcEngineNative.unRegisterVideoRawDataObserver();
		}

		[MonoPInvokeCallback(typeof(EngineEventOnCaptureVideoFrame))]
		private static void OnCaptureVideoFrameCallback(int videoFrameType, int width, int height, int yStride, IntPtr buffer, int rotation, long renderTimeMs)
		{
			if (_irtcEngine != null && _videoRawDataManagerInstance != null && _videoRawDataManagerInstance.OnCaptureVideoFrame != null)
			{
				VideoFrame videoFrame = default(VideoFrame);
				videoFrame.type = (VIDEO_FRAME_TYPE)videoFrameType;
				videoFrame.width = width;
				videoFrame.height = height;
				videoFrame.yStride = yStride;
				byte[] array = new byte[yStride * height];
				Marshal.Copy(buffer, array, 0, yStride * height);
				videoFrame.buffer = array;
				videoFrame.rotation = rotation;
				videoFrame.renderTimeMs = renderTimeMs;
				_videoRawDataManagerInstance.OnCaptureVideoFrame(videoFrame);
			}
		}

		[MonoPInvokeCallback(typeof(EngineEventOnRenderVideoFrame))]
		private static void OnRenderVideoFrameCallback(uint uid, int videoFrameType, int width, int height, int yStride, IntPtr yBuffer, int rotation, long renderTimeMs)
		{
			if (_irtcEngine != null && _videoRawDataManagerInstance != null && _videoRawDataManagerInstance.OnRenderVideoFrame != null)
			{
				VideoFrame videoFrame = default(VideoFrame);
				videoFrame.type = (VIDEO_FRAME_TYPE)videoFrameType;
				videoFrame.width = width;
				videoFrame.height = height;
				videoFrame.yStride = yStride;
				byte[] array = new byte[yStride * height];
				Marshal.Copy(yBuffer, array, 0, yStride * height);
				videoFrame.buffer = array;
				videoFrame.rotation = rotation;
				videoFrame.renderTimeMs = renderTimeMs;
				_videoRawDataManagerInstance.OnRenderVideoFrame(uid, videoFrame);
			}
		}
	}
	public sealed class AgoraCallbackObject
	{
		public GameObject _CallbackGameObject { get; set; }

		public AgoraCallbackQueue _CallbackQueue { get; set; }

		public string _GameObjectName { get; set; }

		public AgoraCallbackObject(string gameObjectName)
		{
			InitGameObject(gameObjectName);
		}

		public void Release()
		{
			if ((object)_CallbackGameObject != null)
			{
				if ((object)_CallbackQueue != null)
				{
					_CallbackQueue.ClearQueue();
				}
				UnityEngine.Object.Destroy(_CallbackGameObject);
				_CallbackGameObject = null;
				_CallbackQueue = null;
			}
		}

		private void InitGameObject(string gameObjectName)
		{
			DeInitGameObject(gameObjectName);
			_CallbackGameObject = new GameObject(gameObjectName);
			_CallbackQueue = _CallbackGameObject.AddComponent<AgoraCallbackQueue>();
			UnityEngine.Object.DontDestroyOnLoad(_CallbackGameObject);
			_CallbackGameObject.hideFlags = HideFlags.HideInHierarchy;
		}

		private void DeInitGameObject(string gameObjectName)
		{
			GameObject gameObject = GameObject.Find(gameObjectName);
			if ((object)gameObject != null)
			{
				gameObject.GetComponent<AgoraCallbackQueue>()?.ClearQueue();
				UnityEngine.Object.Destroy(gameObject);
				gameObject = null;
				AgoraCallbackQueue agoraCallbackQueue = null;
			}
		}
	}
	public sealed class AgoraCallbackQueue : MonoBehaviour
	{
		private Queue<Action> queue = new Queue<Action>();

		public void ClearQueue()
		{
			lock (queue)
			{
				queue.Clear();
			}
		}

		public void EnQueue(Action action)
		{
			lock (queue)
			{
				if (queue.Count >= 250)
				{
					queue.Dequeue();
				}
				queue.Enqueue(action);
			}
		}

		private Action DeQueue()
		{
			Action result = null;
			lock (queue)
			{
				if (queue.Count > 0)
				{
					result = queue.Dequeue();
				}
			}
			return result;
		}

		private void Awake()
		{
		}

		private void Update()
		{
			DeQueue()?.Invoke();
			Action action = null;
		}

		private void OnDestroy()
		{
			ClearQueue();
		}
	}
	public sealed class AgoraLog
	{
		internal static string tag = "Agora_Unity: ";

		public static void Log_Debug(string message)
		{
			UnityEngine.Debug.Log(tag + message);
		}

		public static void Log_Error(string message)
		{
			UnityEngine.Debug.LogError(tag + message);
		}
	}
	public abstract class IVideoRender : IRtcEngineNative
	{
		public abstract int SetVideoRenderMode(VIDEO_RENDER_MODE _renderMode);

		public abstract int UpdateTexture(int tex, uint uid, IntPtr data, ref int width, ref int height);

		public abstract int UpdateVideoRawData(uint uid, IntPtr data, ref int width, ref int height);

		public abstract int GenerateNativeTexture();

		public abstract void DeleteTexture(int tex);

		public abstract void AddUserVideoInfo(uint userId, uint textureId);

		public abstract void RemoveUserVideoInfo(uint _userId);

		public abstract void AddUserVideoInfo(string channelId, uint _userId, uint _textureId);

		public abstract void RemoveUserVideoInfo(string channelId, uint _userId);

		public abstract int UpdateVideoRawData(string channelId, uint uid, IntPtr data, ref int width, ref int height);

		public abstract bool GetMultiChannelWanted();
	}
	public sealed class VideoRender : IVideoRender
	{
		private static VideoRender _videoRenderInstance;

		private IRtcEngine _rtcEngine;

		private VideoRender(IRtcEngine rtcEngine)
		{
			_rtcEngine = rtcEngine;
		}

		public static VideoRender GetInstance(IRtcEngine rtcEngine)
		{
			if (_videoRenderInstance == null)
			{
				_videoRenderInstance = new VideoRender(rtcEngine);
			}
			return _videoRenderInstance;
		}

		public static void ReleaseInstance()
		{
			_videoRenderInstance = null;
		}

		public void SetEngine(IRtcEngine rtcEngine)
		{
			_rtcEngine = rtcEngine;
		}

		public override int SetVideoRenderMode(VIDEO_RENDER_MODE _renderMode)
		{
			if (_rtcEngine == null)
			{
				return -7;
			}
			return IRtcEngineNative.setRenderMode((int)_renderMode);
		}

		public override int UpdateVideoRawData(uint uid, IntPtr data, ref int width, ref int height)
		{
			if (_rtcEngine == null)
			{
				return -7;
			}
			int num = IRtcEngineNative.updateVideoRawData(data, uid);
			if (num == -1)
			{
				return -1;
			}
			width = num >> 16;
			height = num & 0xFFFF;
			return 0;
		}

		public override int UpdateVideoRawData(string channelId, uint uid, IntPtr data, ref int width, ref int height)
		{
			if (_rtcEngine == null)
			{
				return -7;
			}
			int num = IRtcEngineNative.updateVideoRawData2(data, channelId, uid);
			if (num == -1)
			{
				return -1;
			}
			width = num >> 16;
			height = num & 0xFFFF;
			return 0;
		}

		public override int UpdateTexture(int tex, uint uid, IntPtr data, ref int width, ref int height)
		{
			if (_rtcEngine == null)
			{
				return -7;
			}
			int num = IRtcEngineNative.updateTexture(tex, data, uid);
			if (num == -1)
			{
				return -1;
			}
			width = num >> 16;
			height = num & 0xFFFF;
			return 0;
		}

		public override void AddUserVideoInfo(uint userId, uint textureId)
		{
			if (_rtcEngine != null)
			{
				IRtcEngineNative.addUserVideoInfo(userId, textureId);
			}
		}

		public override void RemoveUserVideoInfo(uint _userId)
		{
			if (_rtcEngine != null)
			{
				IRtcEngineNative.removeUserVideoInfo(_userId);
			}
		}

		public override void AddUserVideoInfo(string channelId, uint _userId, uint _textureId)
		{
			if (_rtcEngine != null)
			{
				IRtcEngineNative.addUserVideoInfo2(channelId, _userId, _textureId);
			}
		}

		public override void RemoveUserVideoInfo(string channelId, uint _userId)
		{
			if (_rtcEngine != null)
			{
				IRtcEngineNative.removeUserVideoInfo2(channelId, _userId);
			}
		}

		public override int GenerateNativeTexture()
		{
			if (_rtcEngine == null)
			{
				return -7;
			}
			return IRtcEngineNative.generateNativeTexture();
		}

		public override void DeleteTexture(int tex)
		{
			if (_rtcEngine != null)
			{
				IRtcEngineNative.deleteTexture(tex);
			}
		}

		public override bool GetMultiChannelWanted()
		{
			if (_rtcEngine == null)
			{
				return false;
			}
			return IRtcEngineNative.getMultiChannelWanted();
		}
	}
	public enum AgoraVideoSurfaceType
	{
		Renderer,
		RawImage
	}
	public class VideoSurface : MonoBehaviour
	{
		private IntPtr data = Marshal.AllocHGlobal(8294400);

		private int defWidth;

		private int defHeight;

		private Texture2D nativeTexture;

		private bool initRenderMode;

		private VideoRender videoRender;

		private uint videoFilter = 15u;

		private uint updateVideoFrameCount;

		public bool isMultiChannelWant;

		private Renderer mRenderer;

		private RawImage mRawImage;

		private bool _initialized;

		public bool _enableFlipHorizontal;

		public bool _enableFlipVertical;

		public uint videoFps = 30u;

		[SerializeField]
		private AgoraVideoSurfaceType VideoSurfaceType;

		private uint mUid;

		private string mChannelId = "_0_";

		private bool mEnable = true;

		private void Start()
		{
			if (VideoSurfaceType == AgoraVideoSurfaceType.Renderer)
			{
				mRenderer = GetComponent<Renderer>();
			}
			if (mRenderer == null || VideoSurfaceType == AgoraVideoSurfaceType.RawImage)
			{
				mRawImage = GetComponent<RawImage>();
				if (mRawImage != null)
				{
					VideoSurfaceType = AgoraVideoSurfaceType.RawImage;
				}
			}
			if (mRawImage == null && mRenderer == null)
			{
				_initialized = false;
				UnityEngine.Debug.LogError("Unable to find surface render in VideoSurface component.");
			}
			else
			{
				_initialized = true;
			}
		}

		private void Update()
		{
			if (updateVideoFrameCount >= videoFps / videoFilter)
			{
				updateVideoFrameCount = 0u;
				if (GetEngine() == null || !_initialized || videoRender == null)
				{
					return;
				}
				uint num = mUid;
				if (mEnable)
				{
					if (IsBlankTexture())
					{
						int num2 = -1;
						num2 = ((!isMultiChannelWant) ? videoRender.UpdateVideoRawData(num, data, ref defWidth, ref defHeight) : ((num != 0) ? videoRender.UpdateVideoRawData(mChannelId, num, data, ref defWidth, ref defHeight) : videoRender.UpdateVideoRawData(num, data, ref defWidth, ref defHeight)));
						if (num2 == -1 || defWidth <= 0 || defHeight <= 0)
						{
							return;
						}
						try
						{
							nativeTexture = new Texture2D(defWidth, defHeight, TextureFormat.RGBA32, mipChain: false);
							nativeTexture.LoadRawTextureData(data, defWidth * defHeight * 4);
							ApplyTexture(nativeTexture);
							nativeTexture.Apply();
							return;
						}
						catch (Exception ex)
						{
							UnityEngine.Debug.LogError("Exception e = " + ex);
							return;
						}
					}
					if (nativeTexture == null)
					{
						UnityEngine.Debug.LogError("You didn't initialize native texture, please remove native texture and initialize it by agora.");
						return;
					}
					int width = 0;
					int height = 0;
					int num3 = -1;
					num3 = ((!isMultiChannelWant) ? videoRender.UpdateVideoRawData(num, data, ref width, ref height) : ((num != 0) ? videoRender.UpdateVideoRawData(mChannelId, mUid, data, ref width, ref height) : videoRender.UpdateVideoRawData(num, data, ref width, ref height)));
					if (num3 == -1)
					{
						return;
					}
					try
					{
						if (width == defWidth && height == defHeight)
						{
							nativeTexture.LoadRawTextureData(data, width * height * 4);
							nativeTexture.Apply();
							return;
						}
						defWidth = width;
						defHeight = height;
						nativeTexture.Resize(defWidth, defHeight);
						nativeTexture.LoadRawTextureData(data, width * height * 4);
						nativeTexture.Apply();
						return;
					}
					catch (Exception ex2)
					{
						UnityEngine.Debug.LogError("Exception e = " + ex2);
						return;
					}
				}
				if (!IsBlankTexture())
				{
					ApplyTexture(null);
				}
			}
			else
			{
				updateVideoFrameCount++;
			}
		}

		private void OnDestroy()
		{
			UnityEngine.Debug.Log("VideoSurface OnDestroy");
			if (videoRender != null && IRtcEngine.QueryEngine() != null)
			{
				if (isMultiChannelWant)
				{
					if (mUid == 0)
					{
						videoRender.RemoveUserVideoInfo(mUid);
					}
					else
					{
						videoRender.RemoveUserVideoInfo(mChannelId, mUid);
					}
				}
				else
				{
					videoRender.RemoveUserVideoInfo(mUid);
				}
			}
			if (data != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(data);
				data = IntPtr.Zero;
			}
			if (nativeTexture != null)
			{
				UnityEngine.Object.Destroy(nativeTexture);
				nativeTexture = null;
			}
			mRenderer = null;
		}

		public void SetGameFps(uint fps)
		{
			videoFps = fps;
		}

		public void SetForUser(uint uid)
		{
			if (IRtcEngine.QueryEngine() != null)
			{
				mUid = uid;
				IRtcEngine.QueryEngine().GetVideoRender().AddUserVideoInfo(mUid, 0u);
			}
			mUid = uid;
			UnityEngine.Debug.Log("Set uid " + uid + " for " + base.gameObject.name);
		}

		public void SetForMultiChannelUser(string channelId, uint uid)
		{
			if (IRtcEngine.QueryEngine() != null)
			{
				isMultiChannelWant = true;
				mUid = uid;
				mChannelId = channelId;
				IRtcEngine.QueryEngine().GetVideoRender().AddUserVideoInfo(mChannelId, mUid, 0u);
			}
			else
			{
				UnityEngine.Debug.LogError("Plear init agora engine first");
			}
		}

		public void EnableFilpTextureApply(bool enableFlipHorizontal, bool enableFlipVertical)
		{
			if (_enableFlipHorizontal != enableFlipHorizontal)
			{
				base.transform.localScale = new Vector3(0f - base.transform.localScale.x, base.transform.localScale.y, base.transform.localScale.z);
				_enableFlipHorizontal = enableFlipHorizontal;
			}
			if (_enableFlipVertical != enableFlipVertical)
			{
				base.transform.localScale = new Vector3(base.transform.localScale.x, 0f - base.transform.localScale.y, base.transform.localScale.z);
				_enableFlipVertical = enableFlipVertical;
			}
		}

		public void SetVideoSurfaceType(AgoraVideoSurfaceType agoraVideoSurfaceType)
		{
			VideoSurfaceType = agoraVideoSurfaceType;
		}

		public void SetEnable(bool enable)
		{
			mEnable = enable;
		}

		private IRtcEngine GetEngine()
		{
			IRtcEngine rtcEngine = IRtcEngine.QueryEngine();
			if (!initRenderMode && rtcEngine != null)
			{
				videoRender = (VideoRender)rtcEngine.GetVideoRender();
				videoRender.SetVideoRenderMode(VIDEO_RENDER_MODE.RENDER_RAWDATA);
				videoRender.AddUserVideoInfo(mUid, 0u);
				initRenderMode = true;
			}
			return rtcEngine;
		}

		private bool IsBlankTexture()
		{
			if (VideoSurfaceType == AgoraVideoSurfaceType.Renderer)
			{
				if (!(mRenderer.material.mainTexture == null))
				{
					return !(mRenderer.material.mainTexture is Texture2D);
				}
				return true;
			}
			if (VideoSurfaceType == AgoraVideoSurfaceType.RawImage)
			{
				return mRawImage.texture == null;
			}
			return true;
		}

		private void ApplyTexture(Texture2D texture)
		{
			if (VideoSurfaceType == AgoraVideoSurfaceType.Renderer)
			{
				mRenderer.material.mainTexture = texture;
			}
			else if (VideoSurfaceType == AgoraVideoSurfaceType.RawImage)
			{
				mRawImage.texture = texture;
			}
		}

		private void UpdateShader()
		{
			MeshRenderer component = GetComponent<MeshRenderer>();
			if (component != null)
			{
				component.material = new Material(Shader.Find("Unlit/Texture"));
			}
		}
	}
}
namespace agora_utilities
{
	public class UIElementDragger : EventTrigger
	{
		public override void OnDrag(PointerEventData eventData)
		{
			base.transform.position = new Vector2(Input.mousePosition.x, Input.mousePosition.y);
			base.OnDrag(eventData);
		}
	}
}
namespace hj
{
	public class public_TriggerActionWithCondition : MonoBehaviour
	{
		public bool shouldTrigger = true;

		[Header("ShouldTrigger = True 时")]
		public UnityEvent eventTriggerAction;

		[Header("ShouldTrigger = False 时")]
		public UnityEvent eventTriggerAction_ConditionNotMatch;

		public void J_SetTriggerEnable(bool isEnable)
		{
			shouldTrigger = isEnable;
		}

		public void J_TriggerAction()
		{
			if (shouldTrigger)
			{
				eventTriggerAction.Invoke();
			}
			else
			{
				eventTriggerAction_ConditionNotMatch.Invoke();
			}
		}
	}
	public class AudioRecWordsCtrl : BaiduAudioRecBase
	{
		private string recogedWordsAll = "";

		private string recogedWords = "";

		public Action<string> eventOnWordsRec;

		private void Start()
		{
			recogedWordsAll = "";
		}

		public void J_StartRec(Action<string> onWordsRectCallback)
		{
			try
			{
				StartVoiceRec();
				recogedWordsAll = "";
				eventOnWordsRec = onWordsRectCallback;
			}
			catch (Exception ex)
			{
				onWordsRectCallback?.Invoke(ex.Message);
			}
		}

		private void OnDisable()
		{
			J_StopRec();
		}

		private void OnDestroy()
		{
			J_StopRec();
		}

		public void J_StopRec()
		{
			StopVoiceRec();
			eventOnWordsRec = null;
		}

		protected override void OnRecStateChange(string msg)
		{
			if (!(msg == "start"))
			{
				if (msg == "stop")
				{
					UnityEngine.Debug.Log("-- baidu voice rec stopped");
					if (recStart)
					{
						recogedWordsAll += recogedWords;
						StartVoiceRec();
					}
				}
				else
				{
					UnityEngine.Debug.LogError("--unkonw state:" + msg);
				}
			}
			else
			{
				UnityEngine.Debug.Log("--baidu voice rec started");
			}
		}

		public override void OnReceivedRecResult(M_BaiduAudioRecResult recResult)
		{
			UnityEngine.Debug.Log(recResult.error);
			if (recStart)
			{
				recogedWords = recResult.best_result;
				if (eventOnWordsRec != null)
				{
					eventOnWordsRec(recogedWordsAll + recogedWords);
				}
			}
		}
	}
	public class J_WaveVR_CurveRayTeleport : MonoBehaviour
	{
		public GameObject m_Player;

		[Space(5f)]
		public LayerMask m_TeleportLayerMask;

		public int m_segmentCount = 35;

		[Tooltip("The amount of time in seconds to predict the motion of the projectile.")]
		public float arcDuration = 3f;

		[Tooltip("The speed at which the line segments of the arc move.")]
		public float arcSpeed = 10f;

		public float scale = 2f;

		private bool m_bIsRayGround;

		public LineRenderer m_lineRender;

		public GameObject m_objGroundQuad;

		private bool isShowCurveRay;

		private Vector3 vCheckPrePos;

		private RaycastHit hitInfo;

		private Vector3 hitPoint;

		private Vector3 vGravity = new Vector3(0f, -9.81f, 0f);

		private void Update()
		{
			if (isShowCurveRay)
			{
				FindCurveRayCast();
			}
		}

		public void J_ShowCurveRay()
		{
			isShowCurveRay = true;
			m_lineRender.gameObject.SetActive(value: true);
		}

		public void J_CheckCurveRayCast()
		{
			if (m_bIsRayGround)
			{
				UnityEngine.Debug.Log("--Teleport");
				if (m_Player != null)
				{
					m_Player.transform.position = hitPoint;
				}
			}
			isShowCurveRay = false;
			m_bIsRayGround = false;
			m_lineRender.gameObject.SetActive(value: false);
			m_objGroundQuad.gameObject.SetActive(value: false);
		}

		private void FindCurveRayCast()
		{
			m_bIsRayGround = false;
			float num = arcDuration / (float)m_segmentCount;
			float num2 = 0f;
			hitInfo = default(RaycastHit);
			Vector3 start = base.transform.position;
			List<Vector3> list = new List<Vector3>();
			list.Add(base.transform.position);
			for (int i = 0; i < m_segmentCount; i++)
			{
				float num3 = num2 + num;
				Vector3 arcPositionAtTime = GetArcPositionAtTime(num3);
				if (Physics.Linecast(start, arcPositionAtTime, out hitInfo, m_TeleportLayerMask))
				{
					m_bIsRayGround = true;
					hitPoint = hitInfo.point;
					list.Add(hitPoint);
					m_objGroundQuad.gameObject.SetActive(value: true);
					m_objGroundQuad.transform.position = hitPoint;
					m_objGroundQuad.transform.forward = hitInfo.normal;
					break;
				}
				num2 = num3;
				start = arcPositionAtTime;
				list.Add(arcPositionAtTime);
			}
			if (!m_bIsRayGround)
			{
				m_objGroundQuad.gameObject.SetActive(value: false);
			}
			m_lineRender.positionCount = list.Count;
			m_lineRender.SetPositions(list.ToArray());
		}

		private Vector3 GetArcPositionAtTime(float time)
		{
			return base.transform.position + (base.transform.forward * arcSpeed * time + 0.5f * time * time * vGravity) * scale;
		}

		private bool IsInLayer(GameObject objChcek)
		{
			UnityEngine.Debug.Log(m_TeleportLayerMask.value + ":" + objChcek.gameObject.layer + ":" + (m_TeleportLayerMask.value & objChcek.gameObject.layer));
			if ((m_TeleportLayerMask.value & (int)Mathf.Pow(2f, objChcek.gameObject.layer)) == (int)Mathf.Pow(2f, objChcek.gameObject.layer))
			{
				return true;
			}
			return false;
		}
	}
}
namespace UnityChan
{
	public class AutoBlink : MonoBehaviour
	{
		private enum Status
		{
			Close,
			HalfClose,
			Open
		}

		public bool isActive = true;

		public SkinnedMeshRenderer ref_SMR_EYE_DEF;

		public SkinnedMeshRenderer ref_SMR_EL_DEF;

		public float ratio_Close = 85f;

		public float ratio_HalfClose = 20f;

		[HideInInspector]
		public float ratio_Open;

		private bool timerStarted;

		private bool isBlink;

		public float timeBlink = 0.4f;

		private float timeRemining;

		public float threshold = 0.3f;

		public float interval = 3f;

		private Status eyeStatus;

		private void Awake()
		{
		}

		private void Start()
		{
			ResetTimer();
			StartCoroutine("RandomChange");
		}

		private void ResetTimer()
		{
			timeRemining = timeBlink;
			timerStarted = false;
		}

		private void Update()
		{
			if (!timerStarted)
			{
				eyeStatus = Status.Close;
				timerStarted = true;
			}
			if (timerStarted)
			{
				timeRemining -= Time.deltaTime;
				if (timeRemining <= 0f)
				{
					eyeStatus = Status.Open;
					ResetTimer();
				}
				else if (timeRemining <= timeBlink * 0.3f)
				{
					eyeStatus = Status.HalfClose;
				}
			}
		}

		private void LateUpdate()
		{
			if (isActive && isBlink)
			{
				switch (eyeStatus)
				{
				case Status.Close:
					SetCloseEyes();
					break;
				case Status.HalfClose:
					SetHalfCloseEyes();
					break;
				case Status.Open:
					SetOpenEyes();
					isBlink = false;
					break;
				}
			}
		}

		private void SetCloseEyes()
		{
			ref_SMR_EYE_DEF.SetBlendShapeWeight(6, ratio_Close);
			ref_SMR_EL_DEF.SetBlendShapeWeight(6, ratio_Close);
		}

		private void SetHalfCloseEyes()
		{
			ref_SMR_EYE_DEF.SetBlendShapeWeight(6, ratio_HalfClose);
			ref_SMR_EL_DEF.SetBlendShapeWeight(6, ratio_HalfClose);
		}

		private void SetOpenEyes()
		{
			ref_SMR_EYE_DEF.SetBlendShapeWeight(6, ratio_Open);
			ref_SMR_EL_DEF.SetBlendShapeWeight(6, ratio_Open);
		}

		private IEnumerator RandomChange()
		{
			while (true)
			{
				float num = UnityEngine.Random.Range(0f, 1f);
				if (!isBlink && num > threshold)
				{
					isBlink = true;
				}
				yield return new WaitForSeconds(interval);
			}
		}
	}
	public class IdleChanger : MonoBehaviour
	{
		private AnimatorStateInfo currentState;

		private AnimatorStateInfo previousState;

		public bool _random;

		public float _threshold = 0.5f;

		public float _interval = 10f;

		public bool isGUI = true;

		public Animator UnityChanA;

		public Animator UnityChanB;

		private void Start()
		{
			currentState = UnityChanA.GetCurrentAnimatorStateInfo(0);
			previousState = currentState;
			StartCoroutine("RandomChange");
		}

		private void Update()
		{
			if (Input.GetKeyDown("up") || Input.GetButton("Jump"))
			{
				UnityChanA.SetBool("Next", value: true);
				UnityChanB.SetBool("Next", value: true);
			}
			if (Input.GetKeyDown("down"))
			{
				UnityChanA.SetBool("Back", value: true);
				UnityChanB.SetBool("Back", value: true);
			}
			if (UnityChanA.GetBool("Next"))
			{
				currentState = UnityChanA.GetCurrentAnimatorStateInfo(0);
				if (previousState.fullPathHash != currentState.fullPathHash)
				{
					UnityChanA.SetBool("Next", value: false);
					UnityChanB.SetBool("Next", value: false);
					previousState = currentState;
				}
			}
			if (UnityChanA.GetBool("Back"))
			{
				currentState = UnityChanA.GetCurrentAnimatorStateInfo(0);
				if (previousState.fullPathHash != currentState.fullPathHash)
				{
					UnityChanA.SetBool("Back", value: false);
					UnityChanB.SetBool("Back", value: false);
					previousState = currentState;
				}
			}
		}

		private void OnGUI()
		{
			if (isGUI)
			{
				GUI.Box(new Rect(Screen.width - 110, 10f, 100f, 90f), "Change Motion");
				if (GUI.Button(new Rect(Screen.width - 100, 40f, 80f, 20f), "Next"))
				{
					UnityChanA.SetBool("Next", value: true);
					UnityChanB.SetBool("Next", value: true);
				}
				if (GUI.Button(new Rect(Screen.width - 100, 70f, 80f, 20f), "Back"))
				{
					UnityChanA.SetBool("Back", value: true);
					UnityChanB.SetBool("Back", value: true);
				}
			}
		}

		private IEnumerator RandomChange()
		{
			while (true)
			{
				if (_random)
				{
					float num = UnityEngine.Random.Range(0f, 1f);
					if (num < _threshold)
					{
						UnityChanA.SetBool("Back", value: true);
						UnityChanB.SetBool("Back", value: true);
					}
					else if (num >= _threshold)
					{
						UnityChanA.SetBool("Next", value: true);
						UnityChanB.SetBool("Next", value: true);
					}
				}
				yield return new WaitForSeconds(_interval);
			}
		}
	}
}
namespace BoingKit
{
	public class UFOController : MonoBehaviour
	{
		public float LinearThrust = 3f;

		public float MaxLinearSpeed = 2.5f;

		public float LinearDrag = 4f;

		public float Tilt = 15f;

		public float AngularThrust = 30f;

		public float MaxAngularSpeed = 30f;

		public float AngularDrag = 30f;

		[Range(0f, 1f)]
		public float Hover = 1f;

		public Transform Eyes;

		public float BlinkInterval = 5f;

		private float m_blinkTimer;

		private bool m_lastBlinkWasDouble;

		private Vector3 m_eyeInitScale;

		private Vector3 m_eyeInitPositionLs;

		private Vector3Spring m_eyeScaleSpring;

		private Vector3Spring m_eyePositionLsSpring;

		public Transform Motor;

		public float MotorBaseAngularSpeed = 10f;

		public float MotorMaxAngularSpeed = 10f;

		public ParticleSystem BubbleEmitter;

		public float BubbleBaseEmissionRate = 10f;

		public float BubbleMaxEmissionRate = 10f;

		private Vector3 m_linearVelocity;

		private float m_angularVelocity;

		private float m_yawAngle;

		private Vector3 m_hoverCenter;

		private float m_hoverPhase;

		private float m_motorAngle;

		private void Start()
		{
			m_linearVelocity = Vector3.zero;
			m_angularVelocity = 0f;
			m_yawAngle = base.transform.rotation.eulerAngles.y * MathUtil.Deg2Rad;
			m_hoverCenter = base.transform.position;
			m_hoverPhase = 0f;
			m_motorAngle = 0f;
			if (Eyes != null)
			{
				m_eyeInitScale = Eyes.localScale;
				m_eyeInitPositionLs = Eyes.localPosition;
				m_blinkTimer = BlinkInterval + UnityEngine.Random.Range(1f, 2f);
				m_lastBlinkWasDouble = false;
				m_eyeScaleSpring.Reset(m_eyeInitScale);
				m_eyePositionLsSpring.Reset(m_eyeInitPositionLs);
			}
		}

		private void OnEnable()
		{
			Start();
		}

		private void FixedUpdate()
		{
			float fixedDeltaTime = Time.fixedDeltaTime;
			Vector3 zero = Vector3.zero;
			if (Input.GetKey(KeyCode.W))
			{
				zero += Vector3.forward;
			}
			if (Input.GetKey(KeyCode.S))
			{
				zero += Vector3.back;
			}
			if (Input.GetKey(KeyCode.A))
			{
				zero += Vector3.left;
			}
			if (Input.GetKey(KeyCode.D))
			{
				zero += Vector3.right;
			}
			if (Input.GetKey(KeyCode.R))
			{
				zero += Vector3.up;
			}
			if (Input.GetKey(KeyCode.F))
			{
				zero += Vector3.down;
			}
			if (zero.sqrMagnitude > MathUtil.Epsilon)
			{
				zero = zero.normalized * LinearThrust;
				m_linearVelocity += zero * fixedDeltaTime;
				m_linearVelocity = VectorUtil.ClampLength(m_linearVelocity, 0f, MaxLinearSpeed);
			}
			else
			{
				m_linearVelocity = VectorUtil.ClampLength(m_linearVelocity, 0f, Mathf.Max(0f, m_linearVelocity.magnitude - LinearDrag * fixedDeltaTime));
			}
			float magnitude = m_linearVelocity.magnitude;
			float t = magnitude * MathUtil.InvSafe(MaxLinearSpeed);
			Quaternion quaternion = Quaternion.identity;
			float num = 1f;
			float num2 = 0f;
			if (magnitude > MathUtil.Epsilon)
			{
				Vector3 linearVelocity = m_linearVelocity;
				linearVelocity.y = 0f;
				num = ((m_linearVelocity.magnitude > 0.01f) ? (1f - Mathf.Clamp01(Mathf.Abs(m_linearVelocity.y) / m_linearVelocity.magnitude)) : 0f);
				num2 = Mathf.Min(1f, magnitude / Mathf.Max(MathUtil.Epsilon, MaxLinearSpeed)) * num;
				Vector3 normalized = Vector3.Cross(Vector3.up, linearVelocity).normalized;
				float angle = Tilt * MathUtil.Deg2Rad * num2;
				quaternion = QuaternionUtil.AxisAngle(normalized, angle);
			}
			float num3 = 0f;
			if (Input.GetKey(KeyCode.Q))
			{
				num3 -= 1f;
			}
			if (Input.GetKey(KeyCode.E))
			{
				num3 += 1f;
			}
			bool key = Input.GetKey(KeyCode.LeftControl);
			if (Mathf.Abs(num3) > MathUtil.Epsilon)
			{
				float num4 = MaxAngularSpeed * (key ? 2.5f : 1f);
				num3 *= AngularThrust * MathUtil.Deg2Rad;
				m_angularVelocity += num3 * fixedDeltaTime;
				m_angularVelocity = Mathf.Clamp(m_angularVelocity, (0f - num4) * MathUtil.Deg2Rad, num4 * MathUtil.Deg2Rad);
			}
			else
			{
				m_angularVelocity -= Mathf.Sign(m_angularVelocity) * Mathf.Min(Mathf.Abs(m_angularVelocity), AngularDrag * MathUtil.Deg2Rad * fixedDeltaTime);
			}
			m_yawAngle += m_angularVelocity * fixedDeltaTime;
			Quaternion quaternion2 = QuaternionUtil.AxisAngle(Vector3.up, m_yawAngle);
			m_hoverCenter += m_linearVelocity * fixedDeltaTime;
			m_hoverPhase += Time.deltaTime;
			Vector3 vector = 0.05f * Mathf.Sin(1.37f * m_hoverPhase) * Vector3.right + 0.05f * Mathf.Sin(1.93f * m_hoverPhase + 1.234f) * Vector3.forward + 0.04f * Mathf.Sin(0.97f * m_hoverPhase + 4.321f) * Vector3.up;
			vector *= Hover;
			Quaternion quaternion3 = Quaternion.FromToRotation(Vector3.up, vector + Vector3.up);
			base.transform.position = m_hoverCenter + vector;
			base.transform.rotation = quaternion * quaternion2 * quaternion3;
			if (Motor != null)
			{
				float num5 = Mathf.Lerp(MotorBaseAngularSpeed, MotorMaxAngularSpeed, num2);
				m_motorAngle += num5 * MathUtil.Deg2Rad * fixedDeltaTime;
				Motor.localRotation = QuaternionUtil.AxisAngle(Vector3.up, m_motorAngle - m_yawAngle);
			}
			if (BubbleEmitter != null)
			{
				ParticleSystem.EmissionModule emission = BubbleEmitter.emission;
				emission.rateOverTime = Mathf.Lerp(BubbleBaseEmissionRate, BubbleMaxEmissionRate, t);
			}
			if (Eyes != null)
			{
				m_blinkTimer -= fixedDeltaTime;
				if (m_blinkTimer <= 0f)
				{
					bool flag = !m_lastBlinkWasDouble && UnityEngine.Random.Range(0f, 1f) > 0.75f;
					m_blinkTimer = (flag ? 0.2f : (BlinkInterval + UnityEngine.Random.Range(1f, 2f)));
					m_lastBlinkWasDouble = flag;
					m_eyeScaleSpring.Value.y = 0f;
					m_eyePositionLsSpring.Value.y -= 0.025f;
				}
				Eyes.localScale = m_eyeScaleSpring.TrackDampingRatio(m_eyeInitScale, 30f, 0.8f, fixedDeltaTime);
				Eyes.localPosition = m_eyePositionLsSpring.TrackDampingRatio(m_eyeInitPositionLs, 30f, 0.8f, fixedDeltaTime);
			}
		}
	}
	public class BoingBehavior : MonoBehaviour
	{
		public BoingManager.UpdateMode UpdateMode;

		public BoingManager.UpdateTiming UpdateTiming = BoingManager.UpdateTiming.Late;

		public bool TwoDDistanceCheck;

		public bool TwoDPositionInfluence;

		public bool TwoDRotationInfluence;

		public bool EnablePositionEffect = true;

		public bool EnableRotationEffect = true;

		public bool GlobalReactionUpVector;

		public BoingManager.TranslationLockSpace TranslationLockSpace;

		public bool LockTranslationX;

		public bool LockTranslationY;

		public bool LockTranslationZ;

		public BoingWork.Params Params;

		public SharedBoingParams SharedParams;

		internal bool PositionSpringDirty;

		internal bool RotationSpringDirty;

		internal Vector3 CachedPosition;

		internal Vector3 RenderPosition;

		internal Quaternion CachedRotation;

		internal Quaternion RenderRotation;

		internal bool InitRebooted;

		public Vector3Spring PositionSpring
		{
			get
			{
				return Params.Instance.PositionSpring;
			}
			set
			{
				Params.Instance.PositionSpring = value;
				PositionSpringDirty = true;
			}
		}

		public QuaternionSpring RotationSpring
		{
			get
			{
				return Params.Instance.RotationSpring;
			}
			set
			{
				Params.Instance.RotationSpring = value;
				RotationSpringDirty = true;
			}
		}

		public BoingBehavior()
		{
			Params.Init();
		}

		public virtual void Reboot()
		{
			Params.Instance.PositionSpring.Reset(base.gameObject.transform.position);
			Params.Instance.RotationSpring.Reset(base.gameObject.transform.rotation);
			CachedPosition = base.gameObject.transform.position;
			CachedRotation = base.gameObject.transform.rotation;
		}

		public virtual void OnEnable()
		{
			InitRebooted = false;
			Register();
		}

		public void Start()
		{
			InitRebooted = false;
		}

		public void OnDisable()
		{
			Unregister();
		}

		protected virtual void Register()
		{
			BoingManager.Register(this);
		}

		protected virtual void Unregister()
		{
			BoingManager.Unregister(this);
		}

		public void UpdateFlags()
		{
			Params.Bits.SetBit(BoingWork.ReactorFlags.TwoDDistanceCheck, TwoDDistanceCheck);
			Params.Bits.SetBit(BoingWork.ReactorFlags.TwoDPositionInfluence, TwoDPositionInfluence);
			Params.Bits.SetBit(BoingWork.ReactorFlags.TwoDRotationInfluence, TwoDRotationInfluence);
			Params.Bits.SetBit(BoingWork.ReactorFlags.EnablePositionEffect, EnablePositionEffect);
			Params.Bits.SetBit(BoingWork.ReactorFlags.EnableRotationEffect, EnableRotationEffect);
			Params.Bits.SetBit(BoingWork.ReactorFlags.GlobalReactionUpVector, GlobalReactionUpVector);
			Params.Bits.SetBit(BoingWork.ReactorFlags.FixedUpdate, UpdateMode == BoingManager.UpdateMode.FixedUpdate);
			Params.Bits.SetBit(BoingWork.ReactorFlags.LateUpdateTiming, UpdateTiming == BoingManager.UpdateTiming.Late);
		}

		public virtual void PrepareExecute()
		{
			PrepareExecute(accumulateEffectors: false);
		}

		protected void PrepareExecute(bool accumulateEffectors)
		{
			if (SharedParams != null)
			{
				BoingWork.Params.Copy(ref SharedParams.Params, ref Params);
			}
			UpdateFlags();
			Params.InstanceID = GetInstanceID();
			Vector3 localScale = base.transform.localScale;
			Params.Instance.PrepareExecute(ref Params, CachedPosition, CachedRotation, Mathf.Min(localScale.x, localScale.y, localScale.z), accumulateEffectors);
		}

		public void Execute(float dt)
		{
			Params.Execute(dt);
		}

		public void PullResults()
		{
			PullResults(ref Params);
		}

		public void GatherOutput(ref BoingWork.Output o)
		{
			if (BoingManager.UseAsynchronousJobs)
			{
				if (PositionSpringDirty)
				{
					PositionSpringDirty = false;
				}
				else
				{
					Params.Instance.PositionSpring = o.PositionSpring;
				}
				if (RotationSpringDirty)
				{
					RotationSpringDirty = false;
				}
				else
				{
					Params.Instance.RotationSpring = o.RotationSpring;
				}
			}
			else
			{
				Params.Instance.PositionSpring = o.PositionSpring;
				Params.Instance.RotationSpring = o.RotationSpring;
			}
		}

		private void PullResults(ref BoingWork.Params p)
		{
			CachedPosition = base.transform.position;
			RenderPosition = BoingWork.ComputeTranslationalResults(base.transform, base.transform.position, p.Instance.PositionSpring.Value, this);
			base.transform.position = RenderPosition;
			CachedRotation = base.transform.rotation;
			RenderRotation = p.Instance.RotationSpring.ValueQuat;
			base.transform.rotation = RenderRotation;
		}

		public void Restore()
		{
			if (Application.isEditor)
			{
				if ((base.transform.position - RenderPosition).sqrMagnitude < 0.0001f)
				{
					base.transform.position = CachedPosition;
				}
				if (QuaternionUtil.GetAngle(base.transform.rotation * Quaternion.Inverse(RenderRotation)) < 0.01f)
				{
					base.transform.rotation = CachedRotation;
				}
			}
			else
			{
				base.transform.position = CachedPosition;
				base.transform.rotation = CachedRotation;
			}
		}
	}
	public class BoingBoneCollider : MonoBehaviour
	{
		public enum Type
		{
			Sphere,
			Capsule,
			Box
		}

		public Type Shape;

		public float Radius = 0.1f;

		public float Height = 0.25f;

		public Vector3 Dimensions = new Vector3(0.1f, 0.1f, 0.1f);

		public Bounds Bounds
		{
			get
			{
				switch (Shape)
				{
				case Type.Sphere:
				{
					float num2 = VectorUtil.MinComponent(base.transform.localScale);
					return new Bounds(base.transform.position, 2f * num2 * Radius * Vector3.one);
				}
				case Type.Capsule:
				{
					float num = VectorUtil.MinComponent(base.transform.localScale);
					return new Bounds(base.transform.position, 2f * num * Radius * Vector3.one + Height * VectorUtil.ComponentWiseAbs(base.transform.rotation * Vector3.up));
				}
				case Type.Box:
					return new Bounds(base.transform.position, VectorUtil.ComponentWiseMult(base.transform.localScale, VectorUtil.ComponentWiseAbs(base.transform.rotation * Dimensions)));
				default:
					return default(Bounds);
				}
			}
		}

		public bool Collide(Vector3 boneCenter, float boneRadius, out Vector3 push)
		{
			switch (Shape)
			{
			case Type.Sphere:
			{
				float num2 = VectorUtil.MinComponent(base.transform.localScale);
				return Collision.SphereSphere(boneCenter, boneRadius, base.transform.position, num2 * Radius, out push);
			}
			case Type.Capsule:
			{
				float num = VectorUtil.MinComponent(base.transform.localScale);
				Vector3 headB = base.transform.TransformPoint(0.5f * Height * Vector3.up);
				Vector3 tailB = base.transform.TransformPoint(0.5f * Height * Vector3.down);
				return Collision.SphereCapsule(boneCenter, boneRadius, headB, tailB, num * Radius, out push);
			}
			case Type.Box:
			{
				Vector3 centerOffsetA = base.transform.InverseTransformPoint(boneCenter);
				Vector3 halfExtentB = 0.5f * VectorUtil.ComponentWiseMult(base.transform.localScale, Dimensions);
				if (!Collision.SphereBox(centerOffsetA, boneRadius, halfExtentB, out push))
				{
					return false;
				}
				push = base.transform.TransformVector(push);
				return true;
			}
			default:
				push = Vector3.zero;
				return false;
			}
		}

		public void OnValidate()
		{
			Radius = Mathf.Max(0f, Radius);
			Dimensions.x = Mathf.Max(0f, Dimensions.x);
			Dimensions.y = Mathf.Max(0f, Dimensions.y);
			Dimensions.z = Mathf.Max(0f, Dimensions.z);
		}

		public void OnDrawGizmos()
		{
			DrawGizmos();
		}

		public void DrawGizmos()
		{
			switch (Shape)
			{
			case Type.Sphere:
			{
				float radius = VectorUtil.MinComponent(base.transform.localScale) * Radius;
				Gizmos.matrix = Matrix4x4.TRS(base.transform.position, base.transform.rotation, Vector3.one);
				if (Shape == Type.Sphere)
				{
					Gizmos.color = new Color(1f, 1f, 1f, 0.5f);
					Gizmos.DrawSphere(Vector3.zero, radius);
				}
				Gizmos.color = Color.white;
				Gizmos.DrawWireSphere(Vector3.zero, radius);
				Gizmos.matrix = Matrix4x4.identity;
				break;
			}
			case Type.Capsule:
			{
				float num = VectorUtil.MinComponent(base.transform.localScale);
				float num2 = num * Radius;
				float num3 = 0.5f * num * Height;
				Gizmos.matrix = Matrix4x4.TRS(base.transform.position, base.transform.rotation, Vector3.one);
				if (Shape == Type.Capsule)
				{
					Gizmos.color = new Color(1f, 1f, 1f, 0.5f);
					Gizmos.DrawSphere(num3 * Vector3.up, num2);
					Gizmos.DrawSphere(num3 * Vector3.down, num2);
				}
				Gizmos.color = Color.white;
				Gizmos.DrawWireSphere(num3 * Vector3.up, num2);
				Gizmos.DrawWireSphere(num3 * Vector3.down, num2);
				for (int i = 0; i < 4; i++)
				{
					float f = (float)i * MathUtil.HalfPi;
					Vector3 vector = new Vector3(num2 * Mathf.Cos(f), 0f, num2 * Mathf.Sin(f));
					Gizmos.DrawLine(vector + num3 * Vector3.up, vector + num3 * Vector3.down);
				}
				Gizmos.matrix = Matrix4x4.identity;
				break;
			}
			case Type.Box:
			{
				Vector3 size = VectorUtil.ComponentWiseMult(base.transform.localScale, Dimensions);
				Gizmos.matrix = base.transform.localToWorldMatrix;
				if (Shape == Type.Box)
				{
					Gizmos.color = new Color(1f, 1f, 1f, 0.5f);
					Gizmos.DrawCube(Vector3.zero, size);
				}
				Gizmos.color = Color.white;
				Gizmos.DrawWireCube(Vector3.zero, size);
				Gizmos.matrix = Matrix4x4.identity;
				break;
			}
			}
		}
	}
	public class BoingBones : BoingReactor
	{
		[Serializable]
		public class Bone
		{
			internal BoingWork.Params.InstanceData Instance;

			internal Transform Transform;

			internal Vector3 ScaleWs;

			internal Vector3 CachedScaleLs;

			internal Vector3 BlendedPositionWs;

			internal Vector3 BlendedScaleLs;

			internal Vector3 CachedPositionWs;

			internal Vector3 CachedPositionLs;

			internal Bounds Bounds;

			internal Quaternion RotationInverseWs;

			internal Quaternion SpringRotationWs;

			internal Quaternion SpringRotationInverseWs;

			internal Quaternion CachedRotationWs;

			internal Quaternion CachedRotationLs;

			internal Quaternion BlendedRotationWs;

			internal Quaternion RotationBackPropDeltaPs;

			internal int ParentIndex;

			internal int[] ChildIndices;

			internal float LengthFromRoot;

			internal float AnimationBlend;

			internal float LengthStiffness;

			internal float LengthStiffnessT;

			internal float FullyStiffToParentLength;

			internal float PoseStiffness;

			internal float BendAngleCap;

			internal float CollisionRadius;

			internal float SquashAndStretch;

			internal void UpdateBounds()
			{
				Bounds = new Bounds(Instance.PositionSpring.Value, 2f * CollisionRadius * Vector3.one);
			}

			internal Bone(Transform transform, int iParent, float lengthFromRoot)
			{
				Transform = transform;
				RotationInverseWs = Quaternion.identity;
				ParentIndex = iParent;
				LengthFromRoot = lengthFromRoot;
				Instance.Reset();
				CachedPositionWs = transform.position;
				CachedPositionLs = transform.localPosition;
				CachedRotationWs = transform.rotation;
				CachedRotationLs = transform.localRotation;
				CachedScaleLs = transform.localScale;
				AnimationBlend = 0f;
				LengthStiffness = 0f;
				PoseStiffness = 0f;
				BendAngleCap = 180f;
				CollisionRadius = 0f;
			}
		}

		[Serializable]
		public class Chain
		{
			public enum CurveType
			{
				ConstantOne,
				ConstantHalf,
				ConstantZero,
				RootOneTailHalf,
				RootOneTailZero,
				RootHalfTailOne,
				RootZeroTailOne,
				Custom
			}

			[Tooltip("Root Transform object from which to build a chain (or tree if a bone has multiple children) of bouncy boing bones.")]
			public Transform Root;

			[Tooltip("List of Transform objects to exclude from chain building.")]
			public Transform[] Exclusion;

			[Tooltip("Enable to allow reaction to boing effectors.")]
			public bool EffectorReaction = true;

			[Tooltip("Enable to allow root Transform object to be sprung around as well. Otherwise, no effects will be applied to the root Transform object.")]
			public bool LooseRoot;

			[Tooltip("Assign a SharedParamsOverride asset to override the parameters for this chain. Useful for chains using different parameters than that of the BoingBones component.")]
			public SharedBoingParams ParamsOverride;

			[ConditionalField(null, null, null, null, null, null, null, Label = "Animation Blend", Tooltip = "Animation blend determines each bone's final transform between the original raw transform and its corresponding boing bone. 1.0 means 100% contribution from raw (or animated) transform. 0.0 means 100% contribution from boing bone.\n\nEach curve type provides a type of mapping for each bone's percentage down the chain (0.0 at root & 1.0 at maximum chain length) to the bone's animation blend:\n\n - Constant One: 1.0 all the way.\n - Constant Half: 0.5 all the way.\n - Constant Zero: 0.0 all the way.\n - Root One Tail Half: 1.0 at 0% chain length and 0.5 at 100% chain length.\n - Root One Tail Zero: 1.0 at 0% chain length and 0.0 at 100% chain length.\n - Root Half Tail One: 0.5 at 0% chain length and 1.0 at 100% chain length.\n - Root Zero Tail One: 0.0 at 0% chain length and 1.0 at 100% chain length.\n - Custom: Custom curve.")]
			public CurveType AnimationBlendCurveType = CurveType.RootOneTailZero;

			[ConditionalField("AnimationBlendCurveType", CurveType.Custom, null, null, null, null, null, Label = "  Custom Curve")]
			public AnimationCurve AnimationBlendCustomCurve = AnimationCurve.Linear(0f, 1f, 1f, 0f);

			[ConditionalField(null, null, null, null, null, null, null, Label = "Length Stiffness", Tooltip = "Length stiffness determines how much each target bone (target transform each boing bone is sprung towards) tries to maintain original distance from its parent. 1.0 means 100% distance maintenance. 0.0 means 0% distance maintenance.\n\nEach curve type provides a type of mapping for each bone's percentage down the chain (0.0 at root & 1.0 at maximum chain length) to the bone's length stiffness:\n\n - Constant One: 1.0 all the way.\n - Constant Half: 0.5 all the way.\n - Constant Zero: 0.0 all the way.\n - Root One Tail Half: 1.0 at 0% chain length and 0.5 at 100% chain length.\n - Root One Tail Zero: 1.0 at 0% chain length and 0.0 at 100% chain length.\n - Root Half Tail One: 0.5 at 0% chain length and 1.0 at 100% chain length.\n - Root Zero Tail One: 0.0 at 0% chain length and 1.0 at 100% chain length.\n - Custom: Custom curve.")]
			public CurveType LengthStiffnessCurveType;

			[ConditionalField("LengthStiffnessCurveType", CurveType.Custom, null, null, null, null, null, Label = "  Custom Curve")]
			public AnimationCurve LengthStiffnessCustomCurve = AnimationCurve.Linear(0f, 1f, 1f, 1f);

			[ConditionalField(null, null, null, null, null, null, null, Label = "Pose Stiffness", Tooltip = "Pose stiffness determines how much each target bone (target transform each boing bone is sprung towards) tries to maintain original transform. 1.0 means 100% original transform maintenance. 0.0 means 0% original transform maintenance.\n\nEach curve type provides a type of mapping for each bone's percentage down the chain (0.0 at root & 1.0 at maximum chain length) to the bone's pose stiffness:\n\n - Constant One: 1.0 all the way.\n - Constant Half: 0.5 all the way.\n - Constant Zero: 0.0 all the way.\n - Root One Tail Half: 1.0 at 0% chain length and 0.5 at 100% chain length.\n - Root One Tail Zero: 1.0 at 0% chain length and 0.0 at 100% chain length.\n - Root Half Tail One: 0.5 at 0% chain length and 1.0 at 100% chain length.\n - Root Zero Tail One: 0.0 at 0% chain length and 1.0 at 100% chain length.\n - Custom: Custom curve.")]
			public CurveType PoseStiffnessCurveType;

			[ConditionalField("PoseStiffnessCurveType", CurveType.Custom, null, null, null, null, null, Label = "  Custom Curve")]
			public AnimationCurve PoseStiffnessCustomCurve = AnimationCurve.Linear(0f, 1f, 1f, 1f);

			[ConditionalField(null, null, null, null, null, null, null, Label = "Bend Angle Cap", Tooltip = "Maximum bone bend angle cap.", Min = 0f, Max = 180f)]
			public float MaxBendAngleCap = 180f;

			[ConditionalField(null, null, null, null, null, null, null, Label = "  Curve Type", Tooltip = "Percentage(0.0 = 0 %; 1.0 = 100 %) of maximum bone bend angle cap.Bend angle cap limits how much each bone can bend relative to the root (in degrees). 1.0 means 100% maximum bend angle cap. 0.0 means 0% maximum bend angle cap.\n\nEach curve type provides a type of mapping for each bone's percentage down the chain (0.0 at root & 1.0 at maximum chain length) to the bone's pose stiffness:\n\n - Constant One: 1.0 all the way.\n - Constant Half: 0.5 all the way.\n - Constant Zero: 0.0 all the way.\n - Root One Tail Half: 1.0 at 0% chain length and 0.5 at 100% chain length.\n - Root One Tail Zero: 1.0 at 0% chain length and 0.0 at 100% chain length.\n - Root Half Tail One: 0.5 at 0% chain length and 1.0 at 100% chain length.\n - Root Zero Tail One: 0.0 at 0% chain length and 1.0 at 100% chain length.\n - Custom: Custom curve.")]
			public CurveType BendAngleCapCurveType;

			[ConditionalField("BendAngleCapCurveType", CurveType.Custom, null, null, null, null, null, Label = "    Custom Curve")]
			public AnimationCurve BendAngleCapCustomCurve = AnimationCurve.Linear(0f, 1f, 1f, 1f);

			[ConditionalField(null, null, null, null, null, null, null, Label = "Collision Radius", Tooltip = "Maximum bone collision radius.")]
			public float MaxCollisionRadius = 0.1f;

			[ConditionalField(null, null, null, null, null, null, null, Label = "  Curve Type", Tooltip = "Percentage (0.0 = 0%; 1.0 = 100%) of maximum bone collision radius.\n\nEach curve type provides a type of mapping for each bone's percentage down the chain (0.0 at root & 1.0 at maximum chain length) to the bone's collision radius:\n\n - Constant One: 1.0 all the way.\n - Constant Half: 0.5 all the way.\n - Constant Zero: 0.0 all the way.\n - Root One Tail Half: 1.0 at 0% chain length and 0.5 at 100% chain length.\n - Root One Tail Zero: 1.0 at 0% chain length and 0.0 at 100% chain length.\n - Root Half Tail One: 0.5 at 0% chain length and 1.0 at 100% chain length.\n - Root Zero Tail One: 0.0 at 0% chain length and 1.0 at 100% chain length.\n - Custom: Custom curve.")]
			public CurveType CollisionRadiusCurveType;

			[ConditionalField("CollisionRadiusCurveType", CurveType.Custom, null, null, null, null, null, Label = "    Custom Curve")]
			public AnimationCurve CollisionRadiusCustomCurve = AnimationCurve.Linear(0f, 1f, 1f, 1f);

			[ConditionalField(null, null, null, null, null, null, null, Label = "Boing Kit Collision", Tooltip = "Enable to allow this chain to collide with Boing Kit's own implementation of lightweight colliders")]
			public bool EnableBoingKitCollision;

			[ConditionalField(null, null, null, null, null, null, null, Label = "Unity Collision", Tooltip = "Enable to allow this chain to collide with Unity colliders.")]
			public bool EnableUnityCollision;

			[ConditionalField(null, null, null, null, null, null, null, Label = "Inter-Chain Collision", Tooltip = "Enable to allow this chain to collide with other chain (under the same BoingBones component) with inter-chain collision enabled.")]
			public bool EnableInterChainCollision;

			public Vector3 Gravity = Vector3.zero;

			internal Bounds Bounds;

			[ConditionalField(null, null, null, null, null, null, null, Label = "Squash & Stretch", Tooltip = "Percentage (0.0 = 0%; 1.0 = 100%) of each bone's squash & stretch effect. Squash & stretch is the effect of volume preservation by scaling bones based on how compressed or stretched the distances between bones become.\n\nEach curve type provides a type of mapping for each bone's percentage down the chain (0.0 at root & 1.0 at maximum chain length) to the bone's squash & stretch effect amount:\n\n - Constant One: 1.0 all the way.\n - Constant Half: 0.5 all the way.\n - Constant Zero: 0.0 all the way.\n - Root One Tail Half: 1.0 at 0% chain length and 0.5 at 100% chain length.\n - Root One Tail Zero: 1.0 at 0% chain length and 0.0 at 100% chain length.\n - Root Half Tail One: 0.5 at 0% chain length and 1.0 at 100% chain length.\n - Root Zero Tail One: 0.0 at 0% chain length and 1.0 at 100% chain length.\n - Custom: Custom curve.")]
			public CurveType SquashAndStretchCurveType = CurveType.ConstantZero;

			[ConditionalField("SquashAndStretchCurveType", CurveType.Custom, null, null, null, null, null, Label = "  Custom Curve")]
			public AnimationCurve SquashAndStretchCustomCurve = AnimationCurve.Linear(0f, 0f, 1f, 0f);

			[ConditionalField(null, null, null, null, null, null, null, Label = "  Max Squash", Tooltip = "Maximum squash amount. For example, 2.0 means a maximum scale of 200% when squashed.", Min = 1f, Max = 5f)]
			public float MaxSquash = 1.1f;

			[ConditionalField(null, null, null, null, null, null, null, Label = "  Max Stretch", Tooltip = "Maximum stretch amount. For example, 2.0 means a minimum scale of 50% when stretched (200% stretched).", Min = 1f, Max = 5f)]
			public float MaxStretch = 2f;

			internal Transform m_scannedRoot;

			internal Transform[] m_scannedExclusion;

			internal float MaxLengthFromRoot;

			public static float EvaluateCurve(CurveType type, float t, AnimationCurve curve)
			{
				return type switch
				{
					CurveType.ConstantOne => 1f, 
					CurveType.ConstantHalf => 0.5f, 
					CurveType.ConstantZero => 0f, 
					CurveType.RootOneTailHalf => 1f - 0.5f * Mathf.Clamp01(t), 
					CurveType.RootOneTailZero => 1f - Mathf.Clamp01(t), 
					CurveType.RootHalfTailOne => 0.5f + 0.5f * Mathf.Clamp01(t), 
					CurveType.RootZeroTailOne => Mathf.Clamp01(t), 
					CurveType.Custom => curve.Evaluate(t), 
					_ => 0f, 
				};
			}
		}

		private class RescanEntry
		{
			internal Transform Transform;

			internal int ParentIndex;

			internal float LengthFromRoot;

			internal RescanEntry(Transform transform, int iParent, float lengthFromRoot)
			{
				Transform = transform;
				ParentIndex = iParent;
				LengthFromRoot = lengthFromRoot;
			}
		}

		[SerializeField]
		internal Bone[][] BoneData;

		public Chain[] BoneChains = new Chain[1];

		[Range(0.1f, 20f)]
		public float MaxCollisionResolutionSpeed = 3f;

		public BoingBoneCollider[] BoingColliders = new BoingBoneCollider[0];

		public Collider[] UnityColliders = new Collider[0];

		public bool DebugDrawRawBones;

		public bool DebugDrawTargetBones;

		public bool DebugDrawBoingBones;

		public bool DebugDrawFinalBones;

		public bool DebugDrawColliders;

		public bool DebugDrawChainBounds;

		public bool DebugDrawBoneNames;

		public bool DebugDrawLengthFromRoot;

		private float m_minScale = 1f;

		internal float MinScale => m_minScale;

		protected override void Register()
		{
			BoingManager.Register(this);
		}

		protected override void Unregister()
		{
			BoingManager.Unregister(this);
		}

		public void OnValidate()
		{
			RescanBoneChains();
			UpdateCollisionRadius();
		}

		public override void OnEnable()
		{
			base.OnEnable();
			RescanBoneChains();
			Reboot();
		}

		public void RescanBoneChains()
		{
			if (BoneChains == null)
			{
				return;
			}
			int num = BoneChains.Length;
			if (BoneData == null || BoneData.Length != num)
			{
				Bone[][] array = new Bone[num][];
				if (BoneData != null)
				{
					int i = 0;
					for (int num2 = Mathf.Min(BoneData.Length, num); i < num2; i++)
					{
						array[i] = BoneData[i];
					}
				}
				BoneData = array;
			}
			Queue<RescanEntry> queue = new Queue<RescanEntry>();
			for (int j = 0; j < num; j++)
			{
				Chain chain = BoneChains[j];
				bool flag = false;
				if (BoneData[j] == null)
				{
					flag = true;
				}
				else if (chain.m_scannedRoot == null)
				{
					flag = true;
				}
				else if (chain.m_scannedRoot != chain.Root)
				{
					flag = true;
				}
				else if (chain.m_scannedExclusion != null != (chain.Exclusion != null))
				{
					flag = true;
				}
				else if (chain.Exclusion != null)
				{
					if (chain.m_scannedExclusion.Length != chain.Exclusion.Length)
					{
						flag = true;
					}
					else
					{
						for (int k = 0; k < chain.m_scannedExclusion.Length; k++)
						{
							if (!(chain.m_scannedExclusion[k] == chain.Exclusion[k]))
							{
								flag = true;
								break;
							}
						}
					}
				}
				if (!flag)
				{
					continue;
				}
				Transform transform = chain?.Root;
				if (transform == null)
				{
					BoneData[j] = null;
					continue;
				}
				chain.m_scannedRoot = chain.Root;
				chain.m_scannedExclusion = chain.Exclusion.ToArray();
				chain.MaxLengthFromRoot = 0f;
				List<Bone> list = new List<Bone>();
				queue.Enqueue(new RescanEntry(transform, -1, 0f));
				while (queue.Count > 0)
				{
					RescanEntry rescanEntry = queue.Dequeue();
					if (chain.Exclusion.Contains(rescanEntry.Transform))
					{
						continue;
					}
					int count = list.Count;
					Transform transform2 = rescanEntry.Transform;
					int[] array2 = new int[transform2.childCount];
					for (int l = 0; l < array2.Length; l++)
					{
						array2[l] = -1;
					}
					int num3 = 0;
					int m = 0;
					for (int childCount = transform2.childCount; m < childCount; m++)
					{
						Transform child = transform2.GetChild(m);
						if (!chain.Exclusion.Contains(child))
						{
							float num4 = Vector3.Distance(rescanEntry.Transform.position, child.position);
							float lengthFromRoot = rescanEntry.LengthFromRoot + num4;
							queue.Enqueue(new RescanEntry(child, count, lengthFromRoot));
							num3++;
						}
					}
					chain.MaxLengthFromRoot = Mathf.Max(rescanEntry.LengthFromRoot, chain.MaxLengthFromRoot);
					Bone bone = new Bone(transform2, rescanEntry.ParentIndex, rescanEntry.LengthFromRoot);
					if (num3 > 0)
					{
						bone.ChildIndices = array2;
					}
					list.Add(bone);
				}
				for (int n = 0; n < list.Count; n++)
				{
					Bone bone2 = list[n];
					if (bone2.ParentIndex >= 0)
					{
						Bone bone3 = list[bone2.ParentIndex];
						int num5;
						for (num5 = 0; bone3.ChildIndices[num5] >= 0; num5++)
						{
						}
						if (num5 < bone3.ChildIndices.Length)
						{
							bone3.ChildIndices[num5] = n;
						}
					}
				}
				if (list.Count == 0)
				{
					continue;
				}
				float num6 = MathUtil.InvSafe(chain.MaxLengthFromRoot);
				foreach (Bone item in list)
				{
					float t = Mathf.Clamp01(item.LengthFromRoot * num6);
					item.CollisionRadius = chain.MaxCollisionRadius * Chain.EvaluateCurve(chain.CollisionRadiusCurveType, t, chain.CollisionRadiusCustomCurve);
				}
				BoneData[j] = list.ToArray();
				Reboot(j);
			}
		}

		private void UpdateCollisionRadius()
		{
			for (int i = 0; i < BoneData.Length; i++)
			{
				Chain chain = BoneChains[i];
				Bone[] array = BoneData[i];
				if (array != null)
				{
					float num = MathUtil.InvSafe(chain.MaxLengthFromRoot);
					Bone[] array2 = array;
					foreach (Bone obj in array2)
					{
						float t = Mathf.Clamp01(obj.LengthFromRoot * num);
						obj.CollisionRadius = chain.MaxCollisionRadius * Chain.EvaluateCurve(chain.CollisionRadiusCurveType, t, chain.CollisionRadiusCustomCurve);
					}
				}
			}
		}

		public override void Reboot()
		{
			base.Reboot();
			for (int i = 0; i < BoneData.Length; i++)
			{
				Reboot(i);
			}
		}

		public void Reboot(int iChain)
		{
			Bone[] array = BoneData[iChain];
			if (array != null)
			{
				Bone[] array2 = array;
				foreach (Bone bone in array2)
				{
					bone.Instance.PositionSpring.Reset(bone.Transform.position);
					bone.Instance.RotationSpring.Reset(bone.Transform.rotation);
					bone.CachedPositionWs = bone.Transform.position;
					bone.CachedPositionLs = bone.Transform.localPosition;
					bone.CachedRotationWs = bone.Transform.rotation;
					bone.CachedRotationLs = bone.Transform.localRotation;
					bone.CachedScaleLs = bone.Transform.localScale;
				}
			}
		}

		public override void PrepareExecute()
		{
			base.PrepareExecute();
			Params.Bits.SetBit(BoingWork.ReactorFlags.EnableRotationEffect, value: false);
			float fixedDeltaTime = Time.fixedDeltaTime;
			m_minScale = Mathf.Min(base.transform.localScale.x, base.transform.localScale.y, base.transform.localScale.z);
			for (int i = 0; i < BoneData.Length; i++)
			{
				Chain chain = BoneChains[i];
				Bone[] array = BoneData[i];
				if (array == null || chain.Root == null || array.Length == 0)
				{
					continue;
				}
				Vector3 vector = chain.Gravity * fixedDeltaTime;
				if (UpdateMode == BoingManager.UpdateMode.FixedUpdate)
				{
					vector *= (float)BoingManager.NumFixedUpdateIterations;
				}
				float num = 0f;
				Bone[] array2 = array;
				foreach (Bone bone in array2)
				{
					if (bone.ParentIndex < 0)
					{
						bone.LengthFromRoot = 0f;
						continue;
					}
					Bone bone2 = array[bone.ParentIndex];
					float num2 = Vector3.Distance(bone.Transform.position, bone2.Transform.position);
					bone.LengthFromRoot = bone2.LengthFromRoot + num2;
					num = Mathf.Max(num, bone.LengthFromRoot);
				}
				float num3 = MathUtil.InvSafe(num);
				array2 = array;
				foreach (Bone bone3 in array2)
				{
					float t = bone3.LengthFromRoot * num3;
					bone3.AnimationBlend = Chain.EvaluateCurve(chain.AnimationBlendCurveType, t, chain.AnimationBlendCustomCurve);
					bone3.LengthStiffness = Chain.EvaluateCurve(chain.LengthStiffnessCurveType, t, chain.LengthStiffnessCustomCurve);
					bone3.LengthStiffnessT = 1f - Mathf.Pow(1f - bone3.LengthStiffness, 30f * fixedDeltaTime);
					bone3.FullyStiffToParentLength = ((bone3.ParentIndex >= 0) ? Vector3.Distance(array[bone3.ParentIndex].Transform.position, bone3.Transform.position) : 0f);
					bone3.PoseStiffness = Chain.EvaluateCurve(chain.PoseStiffnessCurveType, t, chain.PoseStiffnessCustomCurve);
					bone3.BendAngleCap = chain.MaxBendAngleCap * MathUtil.Deg2Rad * Chain.EvaluateCurve(chain.BendAngleCapCurveType, t, chain.BendAngleCapCustomCurve);
					bone3.CollisionRadius = chain.MaxCollisionRadius * Chain.EvaluateCurve(chain.CollisionRadiusCurveType, t, chain.CollisionRadiusCustomCurve);
					bone3.SquashAndStretch = Chain.EvaluateCurve(chain.SquashAndStretchCurveType, t, chain.SquashAndStretchCustomCurve);
				}
				Vector3 position = array[0].Transform.position;
				for (int k = 0; k < array.Length; k++)
				{
					Bone bone4 = array[k];
					float t2 = bone4.LengthFromRoot * num3;
					bone4.AnimationBlend = Chain.EvaluateCurve(chain.AnimationBlendCurveType, t2, chain.AnimationBlendCustomCurve);
					bone4.LengthStiffness = Chain.EvaluateCurve(chain.LengthStiffnessCurveType, t2, chain.LengthStiffnessCustomCurve);
					bone4.PoseStiffness = Chain.EvaluateCurve(chain.PoseStiffnessCurveType, t2, chain.PoseStiffnessCustomCurve);
					bone4.BendAngleCap = chain.MaxBendAngleCap * MathUtil.Deg2Rad * Chain.EvaluateCurve(chain.BendAngleCapCurveType, t2, chain.BendAngleCapCustomCurve);
					bone4.CollisionRadius = chain.MaxCollisionRadius * Chain.EvaluateCurve(chain.CollisionRadiusCurveType, t2, chain.CollisionRadiusCustomCurve);
					bone4.SquashAndStretch = Chain.EvaluateCurve(chain.SquashAndStretchCurveType, t2, chain.SquashAndStretchCustomCurve);
					if (k > 0)
					{
						bone4.Instance.PositionSpring.Velocity += vector;
					}
					bone4.RotationInverseWs = Quaternion.Inverse(bone4.Transform.rotation);
					bone4.SpringRotationWs = bone4.Instance.RotationSpring.ValueQuat;
					bone4.SpringRotationInverseWs = Quaternion.Inverse(bone4.SpringRotationWs);
					Vector3 vector2 = bone4.Transform.position;
					Quaternion rotation = bone4.Transform.rotation;
					if (bone4.ParentIndex >= 0)
					{
						Bone bone5 = array[bone4.ParentIndex];
						Vector3 position2 = bone5.Transform.position;
						Vector3 value = bone5.Instance.PositionSpring.Value;
						Vector3 a = bone5.SpringRotationInverseWs * (bone4.Instance.PositionSpring.Value - value);
						Quaternion a2 = bone5.SpringRotationInverseWs * bone4.Instance.RotationSpring.ValueQuat;
						Vector3 position3 = bone4.Transform.position;
						Quaternion rotation2 = bone4.Transform.rotation;
						Vector3 b = bone5.RotationInverseWs * (position3 - position2);
						Quaternion b2 = bone5.RotationInverseWs * rotation2;
						float poseStiffness = bone4.PoseStiffness;
						Vector3 vector3 = Vector3.Lerp(a, b, poseStiffness);
						Quaternion quaternion = Quaternion.Slerp(a2, b2, poseStiffness);
						vector2 = value + bone5.SpringRotationWs * vector3;
						rotation = bone5.SpringRotationWs * quaternion;
						if (bone4.BendAngleCap < MathUtil.Pi - MathUtil.Epsilon)
						{
							Vector3 vector4 = vector2 - position;
							vector4 = VectorUtil.ClampBend(vector4, position3 - position, bone4.BendAngleCap);
							vector2 = position + vector4;
						}
					}
					if (chain.ParamsOverride == null)
					{
						bone4.Instance.PrepareExecute(ref Params, vector2, rotation, MinScale, accumulateEffectors: true);
					}
					else
					{
						bone4.Instance.PrepareExecute(ref chain.ParamsOverride.Params, vector2, rotation, MinScale, accumulateEffectors: true);
					}
				}
			}
		}

		public void AccumulateTarget(ref BoingEffector.Params effector)
		{
			for (int i = 0; i < BoneData.Length; i++)
			{
				Chain chain = BoneChains[i];
				Bone[] array = BoneData[i];
				if (array == null || !chain.EffectorReaction)
				{
					continue;
				}
				Bone[] array2 = array;
				foreach (Bone bone in array2)
				{
					if (chain.ParamsOverride == null)
					{
						bone.Instance.AccumulateTarget(ref Params, ref effector);
						continue;
					}
					Bits32 bits = chain.ParamsOverride.Params.Bits;
					chain.ParamsOverride.Params.Bits = Params.Bits;
					bone.Instance.AccumulateTarget(ref chain.ParamsOverride.Params, ref effector);
					chain.ParamsOverride.Params.Bits = bits;
				}
			}
		}

		public void EndAccumulateTargets()
		{
			for (int i = 0; i < BoneData.Length; i++)
			{
				Chain chain = BoneChains[i];
				Bone[] array = BoneData[i];
				if (array == null)
				{
					continue;
				}
				Bone[] array2 = array;
				foreach (Bone bone in array2)
				{
					if (chain.ParamsOverride == null)
					{
						bone.Instance.EndAccumulateTargets(ref Params);
					}
					else
					{
						bone.Instance.EndAccumulateTargets(ref chain.ParamsOverride.Params);
					}
				}
			}
		}

		public new void Restore()
		{
			for (int i = 0; i < BoneData.Length; i++)
			{
				Chain chain = BoneChains[i];
				Bone[] array = BoneData[i];
				if (array == null)
				{
					continue;
				}
				for (int j = 0; j < array.Length; j++)
				{
					Bone bone = array[j];
					if (j != 0 || chain.LooseRoot)
					{
						bone.Transform.localPosition = bone.CachedPositionLs;
						bone.Transform.localRotation = bone.CachedRotationLs;
						bone.Transform.localScale = bone.CachedScaleLs;
					}
				}
			}
		}
	}
	public class BoingEffector : MonoBehaviour
	{
		public struct Params
		{
			public static readonly int Stride = 80;

			public Vector3 PrevPosition;

			private float m_padding0;

			public Vector3 CurrPosition;

			private float m_padding1;

			public Vector3 LinearVelocityDir;

			private float m_padding2;

			public float Radius;

			public float FullEffectRadius;

			public float MoveDistance;

			public float LinearImpulse;

			public float RotateAngle;

			public float AngularImpulse;

			public Bits32 Bits;

			private int m_padding3;

			public Params(BoingEffector effector)
			{
				Bits = default(Bits32);
				Bits.SetBit(BoingWork.EffectorFlags.ContinuousMotion, effector.ContinuousMotion);
				float num = ((effector.MaxImpulseSpeed > MathUtil.Epsilon) ? Mathf.Min(1f, effector.LinearSpeed / effector.MaxImpulseSpeed) : 1f);
				PrevPosition = effector.m_prevPosition;
				CurrPosition = effector.m_currPosition;
				LinearVelocityDir = VectorUtil.NormalizeSafe(effector.LinearVelocity, Vector3.zero);
				Radius = effector.Radius;
				FullEffectRadius = Radius * effector.FullEffectRadiusRatio;
				MoveDistance = effector.MoveDistance;
				LinearImpulse = num * effector.LinearImpulse;
				RotateAngle = effector.RotationAngle * MathUtil.Deg2Rad;
				AngularImpulse = num * effector.AngularImpulse * MathUtil.Deg2Rad;
				m_padding0 = 0f;
				m_padding1 = 0f;
				m_padding2 = 0f;
				m_padding3 = 0;
			}

			public void Fill(BoingEffector effector)
			{
				this = new Params(effector);
			}

			private void SuppressWarnings()
			{
				m_padding0 = 0f;
				m_padding1 = 0f;
				m_padding2 = 0f;
				m_padding3 = 0;
				m_padding0 = m_padding1;
				m_padding1 = m_padding2;
				m_padding2 = m_padding3;
				m_padding3 = (int)m_padding0;
			}
		}

		[Header("Metrics")]
		[Range(0f, 20f)]
		[Tooltip("Maximum radius of influence.")]
		public float Radius = 3f;

		[Range(0f, 1f)]
		[Tooltip("Fraction of Radius past which influence begins decaying gradually to zero exactly at Radius.\n\ne.g. With a Radius of 10.0 and FullEffectRadiusRatio of 0.5, reactors within distance of 5.0 will be fully influenced, reactors at distance of 7.5 will experience 50% influence, and reactors past distance of 10.0 will not be influenced at all.")]
		public float FullEffectRadiusRatio = 0.5f;

		[Header("Dynamics")]
		[Range(0f, 100f)]
		[Tooltip("Speed of this effector at which impulse effects will be at maximum strength.\n\ne.g. With a MaxImpulseSpeed of 10.0 and an effector traveling at speed of 4.0, impulse effects will be at 40% maximum strength.")]
		public float MaxImpulseSpeed = 5f;

		[Tooltip("This affects impulse-related effects.\n\nIf checked, continuous motion will be simulated between frames. This means even if an effector \"teleports\" by moving a huge distance between frames, the effector will still affect all reactors caught on the effector's path in between frames, not just the reactors around the effector's discrete positions at different frames.")]
		public bool ContinuousMotion;

		[Header("Position Effect")]
		[Range(-10f, 10f)]
		[Tooltip("Distance to push away reactors at maximum influence.\n\ne.g. With a MoveDistance of 2.0, a Radius of 10.0, a FullEffectRadiusRatio of 0.5, and a reactor at distance of 7.5 away from effector, the reactor will be pushed away to 50% of maximum influence, i.e. 50% of MoveDistance, which is a distance of 1.0 away from the effector.")]
		public float MoveDistance = 0.5f;

		[Range(-200f, 200f)]
		[Tooltip("Under maximum impulse influence (within distance of Radius * FullEffectRadiusRatio and with effector moving at speed faster or equal to MaxImpulaseSpeed), a reactor's movement speed will be maintained to be at least as fast as LinearImpulse (unit: distance per second) in the direction of effector's movement direction.\n\ne.g. With a LinearImpulse of 2.0, a Radius of 10.0, a FullEffectRadiusRatio of 0.5, and a reactor at distance of 7.5 away from effector, the reactor's movement speed in the direction of effector's movement direction will be maintained to be at least 50% of LinearImpulse, which is 1.0 per second.")]
		public float LinearImpulse = 5f;

		[Header("Rotation Effect")]
		[Range(-180f, 180f)]
		[Tooltip("Angle (in degrees) to rotate reactors at maximum influence. The rotation will point reactors' up vectors (defined individually in the reactor component) away from the effector.\n\ne.g. With a RotationAngle of 20.0, a Radius of 10.0, a FullEffectRadiusRatio of 0.5, and a reactor at distance of 7.5 away from effector, the reactor will be rotated to 50% of maximum influence, i.e. 50% of RotationAngle, which is 10 degrees.")]
		public float RotationAngle = 20f;

		[Range(-2000f, 2000f)]
		[Tooltip("Under maximum impulse influence (within distance of Radius * FullEffectRadiusRatio and with effector moving at speed faster or equal to MaxImpulaseSpeed), a reactor's rotation speed will be maintained to be at least as fast as AngularImpulse (unit: degrees per second) in the direction of effector's movement direction, i.e. the reactor's up vector will be pulled in the direction of effector's movement direction.\n\ne.g. With a AngularImpulse of 20.0, a Radius of 10.0, a FullEffectRadiusRatio of 0.5, and a reactor at distance of 7.5 away from effector, the reactor's rotation speed in the direction of effector's movement direction will be maintained to be at least 50% of AngularImpulse, which is 10.0 degrees per second.")]
		public float AngularImpulse = 400f;

		[Header("Debug")]
		[Tooltip("If checked, gizmos of reactor fields affected by this effector will be drawn.")]
		public bool DrawAffectedReactorFieldGizmos;

		private Vector3 m_currPosition;

		private Vector3 m_prevPosition;

		private Vector3 m_linearVelocity;

		public Vector3 LinearVelocity => m_linearVelocity;

		public float LinearSpeed => m_linearVelocity.magnitude;

		public void OnEnable()
		{
			m_currPosition = base.transform.position;
			m_prevPosition = base.transform.position;
			m_linearVelocity = Vector3.zero;
			BoingManager.Register(this);
		}

		public void OnDisable()
		{
			BoingManager.Unregister(this);
		}

		public void Update()
		{
			float deltaTime = Time.deltaTime;
			if (!(deltaTime < MathUtil.Epsilon))
			{
				m_linearVelocity = (base.transform.position - m_prevPosition) / deltaTime;
				m_prevPosition = m_currPosition;
				m_currPosition = base.transform.position;
			}
		}

		public void OnDrawGizmosSelected()
		{
			if (base.isActiveAndEnabled)
			{
				if (FullEffectRadiusRatio < 1f)
				{
					Gizmos.color = new Color(1f, 0.5f, 0.2f, 0.4f);
					Gizmos.DrawWireSphere(base.transform.position, Radius);
				}
				Gizmos.color = new Color(1f, 0.5f, 0.2f, 1f);
				Gizmos.DrawWireSphere(base.transform.position, Radius * FullEffectRadiusRatio);
			}
		}
	}
	public static class BoingKit
	{
		public static readonly int MajorVersion = 1;

		public static readonly int MinorVersion = 2;

		public static readonly int Revision = 20;

		public static string Version => MajorVersion + "." + MinorVersion + "." + Revision;
	}
	public static class BoingManager
	{
		public enum UpdateMode
		{
			Update,
			FixedUpdate
		}

		public enum UpdateTiming
		{
			Early,
			Late
		}

		public enum TranslationLockSpace
		{
			Global,
			Local
		}

		public delegate void BehaviorRegisterDelegate(BoingBehavior behavior);

		public delegate void BehaviorUnregisterDelegate(BoingBehavior behavior);

		public delegate void EffectorRegisterDelegate(BoingEffector effector);

		public delegate void EffectorUnregisterDelegate(BoingEffector effector);

		public delegate void ReactorRegisterDelegate(BoingReactor reactor);

		public delegate void ReactorUnregisterDelegate(BoingReactor reactor);

		public delegate void ReactorFieldRegisterDelegate(BoingReactorField field);

		public delegate void ReactorFieldUnregisterDelegate(BoingReactorField field);

		public delegate void ReactorFieldCPUSamplerRegisterDelegate(BoingReactorFieldCPUSampler sampler);

		public delegate void ReactorFieldCPUSamplerUnregisterDelegate(BoingReactorFieldCPUSampler sampler);

		public delegate void ReactorFieldGPUSamplerRegisterDelegate(BoingReactorFieldGPUSampler sampler);

		public delegate void ReactorFieldGPUSamplerUnregisterDelegate(BoingReactorFieldGPUSampler sampler);

		public delegate void BonesRegisterDelegate(BoingBones bones);

		public delegate void BonesUnregisterDelegate(BoingBones bones);

		public static BehaviorRegisterDelegate OnBehaviorRegister;

		public static BehaviorUnregisterDelegate OnBehaviorUnregister;

		public static EffectorRegisterDelegate OnEffectorRegister;

		public static EffectorUnregisterDelegate OnEffectorUnregister;

		public static ReactorRegisterDelegate OnReactorRegister;

		public static ReactorUnregisterDelegate OnReactorUnregister;

		public static ReactorFieldRegisterDelegate OnReactorFieldRegister;

		public static ReactorFieldUnregisterDelegate OnReactorFieldUnregister;

		public static ReactorFieldCPUSamplerRegisterDelegate OnReactorFieldCPUSamplerRegister;

		public static ReactorFieldCPUSamplerUnregisterDelegate OnReactorFieldCPUSamplerUnregister;

		public static ReactorFieldGPUSamplerRegisterDelegate OnReactorFieldGPUSamplerRegister;

		public static ReactorFieldGPUSamplerUnregisterDelegate OnFieldGPUSamplerUnregister;

		public static BonesRegisterDelegate OnBonesRegister;

		public static BonesUnregisterDelegate OnBonesUnregister;

		private static float s_deltaTime = 0f;

		private static float s_fixedDeltaTime = 0f;

		private static int s_numFixedUpdateIterations = 0;

		private static Dictionary<int, BoingBehavior> s_behaviorMap = new Dictionary<int, BoingBehavior>();

		private static Dictionary<int, BoingEffector> s_effectorMap = new Dictionary<int, BoingEffector>();

		private static Dictionary<int, BoingReactor> s_reactorMap = new Dictionary<int, BoingReactor>();

		private static Dictionary<int, BoingReactorField> s_fieldMap = new Dictionary<int, BoingReactorField>();

		private static Dictionary<int, BoingReactorFieldCPUSampler> s_cpuSamplerMap = new Dictionary<int, BoingReactorFieldCPUSampler>();

		private static Dictionary<int, BoingReactorFieldGPUSampler> s_gpuSamplerMap = new Dictionary<int, BoingReactorFieldGPUSampler>();

		private static Dictionary<int, BoingBones> s_bonesMap = new Dictionary<int, BoingBones>();

		private static readonly int kEffectorParamsIncrement = 16;

		private static List<BoingEffector.Params> s_effectorParamsList = new List<BoingEffector.Params>(kEffectorParamsIncrement);

		private static BoingEffector.Params[] s_aEffectorParams;

		private static ComputeBuffer s_effectorParamsBuffer;

		private static Dictionary<int, int> s_effectorParamsIndexMap = new Dictionary<int, int>();

		internal static readonly bool UseAsynchronousJobs = true;

		internal static GameObject s_managerGo;

		public static IEnumerable<BoingBehavior> Behaviors => s_behaviorMap.Values;

		public static IEnumerable<BoingReactor> Reactors => s_reactorMap.Values;

		public static IEnumerable<BoingEffector> Effectors => s_effectorMap.Values;

		public static IEnumerable<BoingReactorField> ReactorFields => s_fieldMap.Values;

		public static IEnumerable<BoingReactorFieldCPUSampler> ReactorFieldCPUSamlers => s_cpuSamplerMap.Values;

		public static IEnumerable<BoingReactorFieldGPUSampler> ReactorFieldGPUSampler => s_gpuSamplerMap.Values;

		public static float DeltaTime => s_deltaTime;

		public static float FixedDeltaTime => s_fixedDeltaTime;

		public static int NumFixedUpdateIterations => s_numFixedUpdateIterations;

		internal static int NumBehaviors => s_behaviorMap.Count;

		internal static int NumEffectors => s_effectorMap.Count;

		internal static int NumReactors => s_reactorMap.Count;

		internal static int NumFields => s_fieldMap.Count;

		internal static int NumCPUFieldSamplers => s_cpuSamplerMap.Count;

		internal static int NumGPUFieldSamplers => s_gpuSamplerMap.Count;

		internal static SphereCollider SharedSphereCollider
		{
			get
			{
				if (s_managerGo == null)
				{
					return null;
				}
				return s_managerGo.GetComponent<SphereCollider>();
			}
		}

		private static void ValidateManager()
		{
			if (!(s_managerGo != null))
			{
				s_managerGo = new GameObject("Boing Kit manager (don't delete)");
				s_managerGo.AddComponent<BoingManagerPreUpdatePump>();
				s_managerGo.AddComponent<BoingManagerPostUpdatePump>();
				UnityEngine.Object.DontDestroyOnLoad(s_managerGo);
				s_managerGo.AddComponent<SphereCollider>().enabled = false;
			}
		}

		internal static void Register(BoingBehavior behavior)
		{
			PreRegisterBehavior();
			s_behaviorMap.Add(behavior.GetInstanceID(), behavior);
			if (OnBehaviorRegister != null)
			{
				OnBehaviorRegister(behavior);
			}
		}

		internal static void Unregister(BoingBehavior behavior)
		{
			if (OnBehaviorUnregister != null)
			{
				OnBehaviorUnregister(behavior);
			}
			s_behaviorMap.Remove(behavior.GetInstanceID());
			PostUnregisterBehavior();
		}

		internal static void Register(BoingEffector effector)
		{
			PreRegisterEffectorReactor();
			s_effectorMap.Add(effector.GetInstanceID(), effector);
			if (OnEffectorRegister != null)
			{
				OnEffectorRegister(effector);
			}
		}

		internal static void Unregister(BoingEffector effector)
		{
			if (OnEffectorUnregister != null)
			{
				OnEffectorUnregister(effector);
			}
			s_effectorMap.Remove(effector.GetInstanceID());
			PostUnregisterEffectorReactor();
		}

		internal static void Register(BoingReactor reactor)
		{
			PreRegisterEffectorReactor();
			s_reactorMap.Add(reactor.GetInstanceID(), reactor);
			if (OnReactorRegister != null)
			{
				OnReactorRegister(reactor);
			}
		}

		internal static void Unregister(BoingReactor reactor)
		{
			if (OnReactorUnregister != null)
			{
				OnReactorUnregister(reactor);
			}
			s_reactorMap.Remove(reactor.GetInstanceID());
			PostUnregisterEffectorReactor();
		}

		internal static void Register(BoingReactorField field)
		{
			PreRegisterEffectorReactor();
			s_fieldMap.Add(field.GetInstanceID(), field);
			if (OnReactorFieldRegister != null)
			{
				OnReactorFieldRegister(field);
			}
		}

		internal static void Unregister(BoingReactorField field)
		{
			if (OnReactorFieldUnregister != null)
			{
				OnReactorFieldUnregister(field);
			}
			s_fieldMap.Remove(field.GetInstanceID());
			PostUnregisterEffectorReactor();
		}

		internal static void Register(BoingReactorFieldCPUSampler sampler)
		{
			PreRegisterEffectorReactor();
			s_cpuSamplerMap.Add(sampler.GetInstanceID(), sampler);
			if (OnReactorFieldCPUSamplerRegister != null)
			{
				OnReactorFieldCPUSamplerUnregister(sampler);
			}
		}

		internal static void Unregister(BoingReactorFieldCPUSampler sampler)
		{
			if (OnReactorFieldCPUSamplerUnregister != null)
			{
				OnReactorFieldCPUSamplerUnregister(sampler);
			}
			s_cpuSamplerMap.Remove(sampler.GetInstanceID());
			PostUnregisterEffectorReactor();
		}

		internal static void Register(BoingReactorFieldGPUSampler sampler)
		{
			PreRegisterEffectorReactor();
			s_gpuSamplerMap.Add(sampler.GetInstanceID(), sampler);
			if (OnReactorFieldGPUSamplerRegister != null)
			{
				OnReactorFieldGPUSamplerRegister(sampler);
			}
		}

		internal static void Unregister(BoingReactorFieldGPUSampler sampler)
		{
			if (OnFieldGPUSamplerUnregister != null)
			{
				OnFieldGPUSamplerUnregister(sampler);
			}
			s_gpuSamplerMap.Remove(sampler.GetInstanceID());
			PostUnregisterEffectorReactor();
		}

		internal static void Register(BoingBones bones)
		{
			PreRegisterBones();
			s_bonesMap.Add(bones.GetInstanceID(), bones);
			if (OnBonesRegister != null)
			{
				OnBonesRegister(bones);
			}
		}

		internal static void Unregister(BoingBones bones)
		{
			if (OnBonesUnregister != null)
			{
				OnBonesUnregister(bones);
			}
			s_bonesMap.Remove(bones.GetInstanceID());
			PostUnregisterBones();
		}

		private static void PreRegisterBehavior()
		{
			ValidateManager();
		}

		private static void PostUnregisterBehavior()
		{
			if (s_behaviorMap.Count <= 0)
			{
				BoingWorkAsynchronous.PostUnregisterBehaviorCleanUp();
			}
		}

		private static void PreRegisterEffectorReactor()
		{
			ValidateManager();
			if (s_effectorParamsBuffer == null)
			{
				s_effectorParamsList = new List<BoingEffector.Params>(kEffectorParamsIncrement);
				s_effectorParamsBuffer = new ComputeBuffer(s_effectorParamsList.Capacity, BoingEffector.Params.Stride);
			}
			if (s_effectorMap.Count >= s_effectorParamsList.Capacity)
			{
				s_effectorParamsList.Capacity += kEffectorParamsIncrement;
				s_effectorParamsBuffer.Dispose();
				s_effectorParamsBuffer = new ComputeBuffer(s_effectorParamsList.Capacity, BoingEffector.Params.Stride);
			}
		}

		private static void PostUnregisterEffectorReactor()
		{
			if (s_effectorMap.Count <= 0 && s_reactorMap.Count <= 0 && s_fieldMap.Count <= 0 && s_cpuSamplerMap.Count <= 0 && s_gpuSamplerMap.Count <= 0)
			{
				s_effectorParamsList = null;
				s_effectorParamsBuffer.Dispose();
				s_effectorParamsBuffer = null;
				BoingWorkAsynchronous.PostUnregisterEffectorReactorCleanUp();
			}
		}

		private static void PreRegisterBones()
		{
			ValidateManager();
		}

		private static void PostUnregisterBones()
		{
		}

		internal static void FixedUpdate()
		{
			s_numFixedUpdateIterations++;
			s_fixedDeltaTime = Time.fixedDeltaTime;
		}

		internal static void Execute(UpdateTiming updateTiming)
		{
			if (updateTiming == UpdateTiming.Early)
			{
				s_deltaTime = Time.deltaTime;
			}
			RefreshEffectorParams();
			ExecuteBones(updateTiming);
			ExecuteBehaviors(updateTiming);
			ExecuteReactors(updateTiming);
			if (updateTiming == UpdateTiming.Late)
			{
				s_numFixedUpdateIterations = 0;
			}
		}

		internal static void ExecuteBehaviors(UpdateTiming updateTiming)
		{
			if (s_behaviorMap.Count == 0)
			{
				return;
			}
			foreach (KeyValuePair<int, BoingBehavior> item in s_behaviorMap)
			{
				BoingBehavior value = item.Value;
				if (!value.InitRebooted)
				{
					value.Reboot();
					value.InitRebooted = true;
				}
			}
			if (UseAsynchronousJobs)
			{
				BoingWorkAsynchronous.ExecuteBehaviors(s_behaviorMap, updateTiming);
			}
			else
			{
				BoingWorkSynchronous.ExecuteBehaviors(s_behaviorMap, updateTiming);
			}
		}

		internal static void PullBehaviorResults(UpdateTiming updateTiming)
		{
			foreach (KeyValuePair<int, BoingBehavior> item in s_behaviorMap)
			{
				if (item.Value.UpdateTiming == updateTiming)
				{
					item.Value.PullResults();
				}
			}
		}

		internal static void RestoreBehaviors()
		{
			foreach (KeyValuePair<int, BoingBehavior> item in s_behaviorMap)
			{
				item.Value.Restore();
			}
		}

		internal static void RefreshEffectorParams()
		{
			if (s_effectorParamsList == null)
			{
				return;
			}
			s_effectorParamsIndexMap.Clear();
			s_effectorParamsList.Clear();
			foreach (KeyValuePair<int, BoingEffector> item in s_effectorMap)
			{
				BoingEffector value = item.Value;
				s_effectorParamsIndexMap.Add(value.GetInstanceID(), s_effectorParamsList.Count);
				s_effectorParamsList.Add(new BoingEffector.Params(value));
			}
			if (s_aEffectorParams == null || s_aEffectorParams.Length != s_effectorParamsList.Count)
			{
				s_aEffectorParams = s_effectorParamsList.ToArray();
			}
			else
			{
				s_effectorParamsList.CopyTo(s_aEffectorParams);
			}
		}

		internal static void ExecuteReactors(UpdateTiming updateTiming)
		{
			if (s_effectorMap.Count == 0 && s_reactorMap.Count == 0 && s_fieldMap.Count == 0 && s_cpuSamplerMap.Count == 0)
			{
				return;
			}
			foreach (KeyValuePair<int, BoingReactor> item in s_reactorMap)
			{
				BoingReactor value = item.Value;
				if (!value.InitRebooted)
				{
					value.Reboot();
					value.InitRebooted = true;
				}
			}
			if (UseAsynchronousJobs)
			{
				BoingWorkAsynchronous.ExecuteReactors(s_effectorMap, s_reactorMap, s_fieldMap, s_cpuSamplerMap, updateTiming);
			}
			else
			{
				BoingWorkSynchronous.ExecuteReactors(s_aEffectorParams, s_reactorMap, s_fieldMap, s_cpuSamplerMap, updateTiming);
			}
		}

		internal static void PullReactorResults(UpdateTiming updateTiming)
		{
			foreach (KeyValuePair<int, BoingReactor> item in s_reactorMap)
			{
				if (item.Value.UpdateTiming == updateTiming)
				{
					item.Value.PullResults();
				}
			}
			foreach (KeyValuePair<int, BoingReactorFieldCPUSampler> item2 in s_cpuSamplerMap)
			{
				if (item2.Value.UpdateTiming == updateTiming)
				{
					item2.Value.SampleFromField();
				}
			}
		}

		internal static void RestoreReactors()
		{
			foreach (KeyValuePair<int, BoingReactor> item in s_reactorMap)
			{
				item.Value.Restore();
			}
			foreach (KeyValuePair<int, BoingReactorFieldCPUSampler> item2 in s_cpuSamplerMap)
			{
				item2.Value.Restore();
			}
		}

		internal static void DispatchReactorFieldCompute()
		{
			if (s_effectorParamsBuffer == null)
			{
				return;
			}
			s_effectorParamsBuffer.SetData(s_aEffectorParams);
			float deltaTime = Time.deltaTime;
			foreach (KeyValuePair<int, BoingReactorField> item in s_fieldMap)
			{
				BoingReactorField value = item.Value;
				BoingReactorField.HardwareModeEnum hardwareMode = value.HardwareMode;
				if (hardwareMode == BoingReactorField.HardwareModeEnum.GPU)
				{
					value.ExecuteGpu(deltaTime, s_effectorParamsBuffer, s_effectorParamsIndexMap);
				}
			}
		}

		internal static void ExecuteBones(UpdateTiming updateTiming)
		{
			if (s_bonesMap.Count == 0)
			{
				return;
			}
			foreach (KeyValuePair<int, BoingBones> item in s_bonesMap)
			{
				BoingBones value = item.Value;
				if (!value.InitRebooted)
				{
					value.Reboot();
					value.InitRebooted = true;
				}
			}
			if (UseAsynchronousJobs)
			{
				BoingWorkAsynchronous.ExecuteBones(s_aEffectorParams, s_bonesMap, updateTiming);
			}
			else
			{
				BoingWorkSynchronous.ExecuteBones(s_aEffectorParams, s_bonesMap, updateTiming);
			}
		}

		internal static void PullBonesResults(UpdateTiming updateTiming)
		{
			if (s_bonesMap.Count != 0)
			{
				if (UseAsynchronousJobs)
				{
					BoingWorkAsynchronous.PullBonesResults(s_aEffectorParams, s_bonesMap, updateTiming);
				}
				else
				{
					BoingWorkSynchronous.PullBonesResults(s_aEffectorParams, s_bonesMap, updateTiming);
				}
			}
		}

		internal static void RestoreBones()
		{
			foreach (KeyValuePair<int, BoingBones> item in s_bonesMap)
			{
				item.Value.Restore();
			}
		}
	}
	public class BoingManagerPostUpdatePump : MonoBehaviour
	{
		private void Start()
		{
			UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
		}

		private bool TryDestroyDuplicate()
		{
			if (BoingManager.s_managerGo == base.gameObject)
			{
				return false;
			}
			UnityEngine.Object.Destroy(base.gameObject);
			return true;
		}

		private void FixedUpdate()
		{
			if (!TryDestroyDuplicate())
			{
				BoingManager.FixedUpdate();
			}
		}

		private void Update()
		{
			if (!TryDestroyDuplicate())
			{
				BoingManager.Execute(BoingManager.UpdateTiming.Early);
				BoingManager.PullBehaviorResults(BoingManager.UpdateTiming.Early);
				BoingManager.PullReactorResults(BoingManager.UpdateTiming.Early);
				BoingManager.PullBonesResults(BoingManager.UpdateTiming.Early);
			}
		}

		private void LateUpdate()
		{
			if (!TryDestroyDuplicate())
			{
				BoingManager.Execute(BoingManager.UpdateTiming.Late);
				BoingManager.PullBehaviorResults(BoingManager.UpdateTiming.Late);
				BoingManager.PullReactorResults(BoingManager.UpdateTiming.Late);
				BoingManager.PullBonesResults(BoingManager.UpdateTiming.Late);
			}
		}
	}
	public class BoingManagerPreUpdatePump : MonoBehaviour
	{
		private int m_lastPumpedFrame = -1;

		private void FixedUpdate()
		{
			TryPump();
		}

		private void Update()
		{
			TryPump();
		}

		private void TryPump()
		{
			if (m_lastPumpedFrame < Time.frameCount)
			{
				if (m_lastPumpedFrame >= 0)
				{
					DoPump();
				}
				m_lastPumpedFrame = Time.frameCount;
			}
		}

		private void DoPump()
		{
			BoingManager.RestoreBehaviors();
			BoingManager.RestoreReactors();
			BoingManager.RestoreBones();
			BoingManager.DispatchReactorFieldCompute();
		}
	}
	public class BoingReactor : BoingBehavior
	{
		protected override void Register()
		{
			BoingManager.Register(this);
		}

		protected override void Unregister()
		{
			BoingManager.Unregister(this);
		}

		public override void PrepareExecute()
		{
			PrepareExecute(accumulateEffectors: true);
		}
	}
	public class BoingReactorField : MonoBehaviour
	{
		public enum HardwareModeEnum
		{
			CPU,
			GPU
		}

		public enum CellMoveModeEnum
		{
			Follow,
			WrapAround
		}

		public enum FalloffModeEnum
		{
			None,
			Circle,
			Square
		}

		public enum FalloffDimensionsEnum
		{
			XYZ,
			XY,
			XZ,
			YZ
		}

		public class ShaderPropertyIdSet
		{
			public int MoveParams;

			public int WrapParams;

			public int Effectors;

			public int EffectorIndices;

			public int ReactorParams;

			public int ComputeFieldParams;

			public int ComputeCells;

			public int RenderFieldParams;

			public int RenderCells;

			public int PositionSampleMultiplier;

			public int RotationSampleMultiplier;

			public int PropagationParams;

			public ShaderPropertyIdSet()
			{
				MoveParams = Shader.PropertyToID("moveParams");
				WrapParams = Shader.PropertyToID("wrapParams");
				Effectors = Shader.PropertyToID("aEffector");
				EffectorIndices = Shader.PropertyToID("aEffectorIndex");
				ReactorParams = Shader.PropertyToID("reactorParams");
				ComputeFieldParams = Shader.PropertyToID("fieldParams");
				ComputeCells = Shader.PropertyToID("aCell");
				RenderFieldParams = Shader.PropertyToID("aBoingFieldParams");
				RenderCells = Shader.PropertyToID("aBoingFieldCell");
				PositionSampleMultiplier = Shader.PropertyToID("positionSampleMultiplier");
				RotationSampleMultiplier = Shader.PropertyToID("rotationSampleMultiplier");
				PropagationParams = Shader.PropertyToID("propagationParams");
			}
		}

		private struct FieldParams
		{
			public static readonly int Stride = 112;

			public int CellsX;

			public int CellsY;

			public int CellsZ;

			public int NumEffectors;

			public int iCellBaseX;

			public int iCellBaseY;

			public int iCellBaseZ;

			public int m_padding0;

			public int FalloffMode;

			public int FalloffDimensions;

			public int PropagationDepth;

			public int m_padding1;

			public Vector3 GridCenter;

			private float m_padding3;

			public Vector3 UpWs;

			private float m_padding2;

			public Vector3 FieldPosition;

			public float m_padding4;

			public float FalloffRatio;

			public float CellSize;

			public float DeltaTime;

			private float m_padding5;

			private void SuppressWarnings()
			{
				m_padding0 = 0;
				m_padding1 = 0;
				m_padding2 = 0f;
				m_padding4 = 0f;
				m_padding5 = 0f;
				m_padding0 = m_padding1;
				m_padding1 = (int)m_padding2;
				m_padding2 = m_padding3;
				m_padding3 = m_padding4;
				m_padding4 = m_padding5;
			}
		}

		private class ComputeKernelId
		{
			public int InitKernel;

			public int MoveKernel;

			public int WrapXKernel;

			public int WrapYKernel;

			public int WrapZKernel;

			public int ExecuteKernel;
		}

		private static ShaderPropertyIdSet s_shaderPropertyId;

		private FieldParams m_fieldParams;

		public HardwareModeEnum HardwareMode = HardwareModeEnum.GPU;

		private HardwareModeEnum m_hardwareMode;

		public CellMoveModeEnum CellMoveMode = CellMoveModeEnum.WrapAround;

		private CellMoveModeEnum m_cellMoveMode;

		[Range(0.1f, 10f)]
		public float CellSize = 1f;

		public int CellsX = 8;

		public int CellsY = 1;

		public int CellsZ = 8;

		private int m_cellsX = -1;

		private int m_cellsY = -1;

		private int m_cellsZ = -1;

		private int m_iCellBaseX;

		private int m_iCellBaseY;

		private int m_iCellBaseZ;

		public FalloffModeEnum FalloffMode = FalloffModeEnum.Square;

		[Range(0f, 1f)]
		public float FalloffRatio = 0.7f;

		public FalloffDimensionsEnum FalloffDimensions = FalloffDimensionsEnum.XZ;

		public BoingEffector[] Effectors = new BoingEffector[1];

		private int m_numEffectors = -1;

		private Aabb m_bounds;

		public bool TwoDDistanceCheck;

		public bool TwoDPositionInfluence;

		public bool TwoDRotationInfluence;

		public bool EnablePositionEffect = true;

		public bool EnableRotationEffect = true;

		public bool GlobalReactionUpVector;

		public BoingWork.Params Params;

		public SharedBoingParams SharedParams;

		public bool EnablePropagation;

		[Range(0f, 1f)]
		public float PositionPropagation = 1f;

		[Range(0f, 1f)]
		public float RotationPropagation = 1f;

		[Range(1f, 3f)]
		public int PropagationDepth = 1;

		public bool AnchorPropagationAtBorder;

		private static readonly float kPropagationFactor = 600f;

		private BoingWork.Params.InstanceData[,,] m_aCpuCell;

		private ComputeShader m_shader;

		private ComputeBuffer m_effectorIndexBuffer;

		private ComputeBuffer m_reactorParamsBuffer;

		private ComputeBuffer m_fieldParamsBuffer;

		private ComputeBuffer m_cellsBuffer;

		private int m_gpuResourceSetId = -1;

		private static ComputeKernelId s_computeKernelId;

		private bool m_init;

		private Vector3 m_gridCenter;

		private Vector3 m_qPrevGridCenterNorm;

		private static Vector3[] s_aCellOffset = new Vector3[8];

		private bool m_cellBufferNeedsReset;

		private static float[] s_aSqrtInv = new float[28]
		{
			0f,
			1f,
			0.70711f,
			0.57735f,
			0.5f,
			0.44721f,
			0.40825f,
			0.37796f,
			0.35355f,
			0.33333f,
			0.31623f,
			0.30151f,
			0.28868f,
			0.27735f,
			0.26726f,
			0.2582f,
			0.25f,
			149f / (226f * (float)Math.E),
			0.2357f,
			0.22942f,
			0.22361f,
			0.21822f,
			0.2132f,
			0.20851f,
			0.20412f,
			0.2f,
			0.19612f,
			0.19245f
		};

		private BoingWork.Params[] s_aReactorParams = new BoingWork.Params[1];

		public static ShaderPropertyIdSet ShaderPropertyId
		{
			get
			{
				if (s_shaderPropertyId == null)
				{
					s_shaderPropertyId = new ShaderPropertyIdSet();
				}
				return s_shaderPropertyId;
			}
		}

		public int GpuResourceSetId => m_gpuResourceSetId;

		public bool UpdateShaderConstants(MaterialPropertyBlock props, float positionSampleMultiplier = 1f, float rotationSampleMultiplier = 1f)
		{
			if (HardwareMode != HardwareModeEnum.GPU)
			{
				return false;
			}
			if (m_fieldParamsBuffer == null || m_cellsBuffer == null)
			{
				return false;
			}
			props.SetFloat(ShaderPropertyId.PositionSampleMultiplier, positionSampleMultiplier);
			props.SetFloat(ShaderPropertyId.RotationSampleMultiplier, rotationSampleMultiplier);
			props.SetBuffer(ShaderPropertyId.RenderFieldParams, m_fieldParamsBuffer);
			props.SetBuffer(ShaderPropertyId.RenderCells, m_cellsBuffer);
			return true;
		}

		public bool UpdateShaderConstants(Material material, float positionSampleMultiplier = 1f, float rotationSampleMultiplier = 1f)
		{
			if (HardwareMode != HardwareModeEnum.GPU)
			{
				return false;
			}
			if (m_fieldParamsBuffer == null || m_cellsBuffer == null)
			{
				return false;
			}
			material.SetFloat(ShaderPropertyId.PositionSampleMultiplier, positionSampleMultiplier);
			material.SetFloat(ShaderPropertyId.RotationSampleMultiplier, rotationSampleMultiplier);
			material.SetBuffer(ShaderPropertyId.RenderFieldParams, m_fieldParamsBuffer);
			material.SetBuffer(ShaderPropertyId.RenderCells, m_cellsBuffer);
			return true;
		}

		public BoingReactorField()
		{
			Params.Init();
			m_bounds = Aabb.Empty;
			m_init = false;
		}

		public void Reboot()
		{
			m_gridCenter = base.transform.position;
			Vector3 vector = (m_qPrevGridCenterNorm = QuantizeNorm(m_gridCenter));
			switch (CellMoveMode)
			{
			case CellMoveModeEnum.Follow:
				m_gridCenter = base.transform.position;
				m_iCellBaseX = 0;
				m_iCellBaseY = 0;
				m_iCellBaseZ = 0;
				m_iCellBaseZ = 0;
				m_iCellBaseZ = 0;
				break;
			case CellMoveModeEnum.WrapAround:
				m_gridCenter = vector * CellSize;
				m_iCellBaseX = MathUtil.Modulo((int)m_qPrevGridCenterNorm.x, CellsX);
				m_iCellBaseY = MathUtil.Modulo((int)m_qPrevGridCenterNorm.y, CellsY);
				m_iCellBaseZ = MathUtil.Modulo((int)m_qPrevGridCenterNorm.z, CellsZ);
				break;
			}
		}

		public void OnEnable()
		{
			Reboot();
			BoingManager.Register(this);
		}

		public void Start()
		{
			Reboot();
			m_cellMoveMode = CellMoveMode;
		}

		public void OnDisable()
		{
			BoingManager.Unregister(this);
			DisposeCpuResources();
			DisposeGpuResources();
		}

		public void DisposeCpuResources()
		{
			m_aCpuCell = null;
		}

		public void DisposeGpuResources()
		{
			if (m_effectorIndexBuffer != null)
			{
				m_effectorIndexBuffer.Dispose();
				m_effectorIndexBuffer = null;
			}
			if (m_reactorParamsBuffer != null)
			{
				m_reactorParamsBuffer.Dispose();
				m_reactorParamsBuffer = null;
			}
			if (m_fieldParamsBuffer != null)
			{
				m_fieldParamsBuffer.Dispose();
				m_fieldParamsBuffer = null;
			}
			if (m_cellsBuffer != null)
			{
				m_cellsBuffer.Dispose();
				m_cellsBuffer = null;
			}
			if (m_cellsBuffer != null)
			{
				m_cellsBuffer.Dispose();
				m_cellsBuffer = null;
			}
		}

		public bool SampleCpuGrid(Vector3 p, out Vector3 positionOffset, out Vector4 rotationOffset)
		{
			bool flag = false;
			switch (FalloffDimensions)
			{
			case FalloffDimensionsEnum.XYZ:
				flag = m_bounds.Contains(p);
				break;
			case FalloffDimensionsEnum.XY:
				flag = m_bounds.ContainsX(p) && m_bounds.ContainsY(p);
				break;
			case FalloffDimensionsEnum.XZ:
				flag = m_bounds.ContainsX(p) && m_bounds.ContainsZ(p);
				break;
			case FalloffDimensionsEnum.YZ:
				flag = m_bounds.ContainsY(p) && m_bounds.ContainsZ(p);
				break;
			}
			if (!flag)
			{
				positionOffset = Vector3.zero;
				rotationOffset = QuaternionUtil.ToVector4(Quaternion.identity);
				return false;
			}
			float num = 0.5f * CellSize;
			Vector3 vector = p - (m_gridCenter + GetCellCenterOffset(0, 0, 0));
			Vector3 vector2 = QuantizeNorm(vector + new Vector3(0f - num, 0f - num, 0f - num));
			Vector3 vector3 = vector2 * CellSize;
			int num2 = Mathf.Clamp((int)vector2.x, 0, CellsX - 1);
			int num3 = Mathf.Clamp((int)vector2.y, 0, CellsY - 1);
			int num4 = Mathf.Clamp((int)vector2.z, 0, CellsZ - 1);
			int x = Mathf.Min(num2 + 1, CellsX - 1);
			int y = Mathf.Min(num3 + 1, CellsY - 1);
			int z = Mathf.Min(num4 + 1, CellsZ - 1);
			ResolveCellIndex(num2, num3, num4, 1, out var resX, out var resY, out var resZ);
			ResolveCellIndex(x, y, z, 1, out var resX2, out var resY2, out var resZ2);
			bool lerpX = resX != resX2;
			bool lerpY = resY != resY2;
			bool lerpZ = resZ != resZ2;
			Vector3 vector4 = (vector - vector3) / CellSize;
			Vector3 vector5 = p - base.transform.position;
			switch (FalloffDimensions)
			{
			case FalloffDimensionsEnum.XY:
				vector5.z = 0f;
				break;
			case FalloffDimensionsEnum.XZ:
				vector5.y = 0f;
				break;
			case FalloffDimensionsEnum.YZ:
				vector5.x = 0f;
				break;
			}
			int num5 = Mathf.Max(CellsX, CellsY, CellsZ);
			float num6 = 1f;
			switch (FalloffMode)
			{
			case FalloffModeEnum.Circle:
			{
				float num7 = num * (float)num5;
				Vector3 vector10 = new Vector3((float)num5 / (float)CellsX, (float)num5 / (float)CellsY, (float)num5 / (float)CellsZ);
				vector5.x *= vector10.x;
				vector5.y *= vector10.y;
				vector5.z *= vector10.z;
				float magnitude = vector5.magnitude;
				float num8 = Mathf.Max(0f, FalloffRatio * num7 - num);
				float num9 = Mathf.Max(MathUtil.Epsilon, (1f - FalloffRatio) * num7 - num);
				num6 = 1f - Mathf.Clamp01((magnitude - num8) / num9);
				break;
			}
			case FalloffModeEnum.Square:
			{
				Vector3 vector6 = num * new Vector3(CellsX, CellsY, CellsZ);
				Vector3 vector7 = FalloffRatio * vector6 - num * Vector3.one;
				vector7.x = Mathf.Max(0f, vector7.x);
				vector7.y = Mathf.Max(0f, vector7.y);
				vector7.z = Mathf.Max(0f, vector7.z);
				Vector3 vector8 = (1f - FalloffRatio) * vector6 - num * Vector3.one;
				vector8.x = Mathf.Max(MathUtil.Epsilon, vector8.x);
				vector8.y = Mathf.Max(MathUtil.Epsilon, vector8.y);
				vector8.z = Mathf.Max(MathUtil.Epsilon, vector8.z);
				Vector3 vector9 = new Vector3(1f - Mathf.Clamp01((Mathf.Abs(vector5.x) - vector7.x) / vector8.x), 1f - Mathf.Clamp01((Mathf.Abs(vector5.y) - vector7.y) / vector8.y), 1f - Mathf.Clamp01((Mathf.Abs(vector5.z) - vector7.z) / vector8.z));
				switch (FalloffDimensions)
				{
				case FalloffDimensionsEnum.XY:
					vector9.x = 1f;
					break;
				case FalloffDimensionsEnum.XZ:
					vector9.y = 1f;
					break;
				case FalloffDimensionsEnum.YZ:
					vector9.z = 1f;
					break;
				}
				num6 = Mathf.Min(vector9.x, vector9.y, vector9.z);
				break;
			}
			}
			s_aCellOffset[0] = m_aCpuCell[resZ, resY, resX].PositionSpring.Value - m_gridCenter - GetCellCenterOffset(num2, num3, num4);
			s_aCellOffset[1] = m_aCpuCell[resZ, resY, resX2].PositionSpring.Value - m_gridCenter - GetCellCenterOffset(x, num3, num4);
			s_aCellOffset[2] = m_aCpuCell[resZ, resY2, resX].PositionSpring.Value - m_gridCenter - GetCellCenterOffset(num2, y, num4);
			s_aCellOffset[3] = m_aCpuCell[resZ, resY2, resX2].PositionSpring.Value - m_gridCenter - GetCellCenterOffset(x, y, num4);
			s_aCellOffset[4] = m_aCpuCell[resZ2, resY, resX].PositionSpring.Value - m_gridCenter - GetCellCenterOffset(num2, num3, z);
			s_aCellOffset[5] = m_aCpuCell[resZ2, resY, resX2].PositionSpring.Value - m_gridCenter - GetCellCenterOffset(x, num3, z);
			s_aCellOffset[6] = m_aCpuCell[resZ2, resY2, resX].PositionSpring.Value - m_gridCenter - GetCellCenterOffset(num2, y, z);
			s_aCellOffset[7] = m_aCpuCell[resZ2, resY2, resX2].PositionSpring.Value - m_gridCenter - GetCellCenterOffset(x, y, z);
			positionOffset = VectorUtil.TriLerp(ref s_aCellOffset[0], ref s_aCellOffset[1], ref s_aCellOffset[2], ref s_aCellOffset[3], ref s_aCellOffset[4], ref s_aCellOffset[5], ref s_aCellOffset[6], ref s_aCellOffset[7], lerpX, lerpY, lerpZ, vector4.x, vector4.y, vector4.z);
			rotationOffset = VectorUtil.TriLerp(ref m_aCpuCell[resZ, resY, resX].RotationSpring.ValueVec, ref m_aCpuCell[resZ, resY, resX2].RotationSpring.ValueVec, ref m_aCpuCell[resZ, resY2, resX].RotationSpring.ValueVec, ref m_aCpuCell[resZ, resY2, resX2].RotationSpring.ValueVec, ref m_aCpuCell[resZ2, resY, resX].RotationSpring.ValueVec, ref m_aCpuCell[resZ2, resY, resX2].RotationSpring.ValueVec, ref m_aCpuCell[resZ2, resY2, resX].RotationSpring.ValueVec, ref m_aCpuCell[resZ2, resY2, resX2].RotationSpring.ValueVec, lerpX, lerpY, lerpZ, vector4.x, vector4.y, vector4.z);
			positionOffset *= num6;
			rotationOffset = QuaternionUtil.ToVector4(QuaternionUtil.Pow(QuaternionUtil.FromVector4(rotationOffset), num6));
			return true;
		}

		private void UpdateFieldParamsGpu()
		{
			m_fieldParams.CellsX = CellsX;
			m_fieldParams.CellsY = CellsY;
			m_fieldParams.CellsZ = CellsZ;
			m_fieldParams.NumEffectors = 0;
			if (Effectors != null)
			{
				BoingEffector[] effectors = Effectors;
				foreach (BoingEffector boingEffector in effectors)
				{
					if (!(boingEffector == null))
					{
						BoingEffector component = boingEffector.GetComponent<BoingEffector>();
						if (!(component == null) && component.isActiveAndEnabled)
						{
							m_fieldParams.NumEffectors++;
						}
					}
				}
			}
			m_fieldParams.iCellBaseX = m_iCellBaseX;
			m_fieldParams.iCellBaseY = m_iCellBaseY;
			m_fieldParams.iCellBaseZ = m_iCellBaseZ;
			m_fieldParams.FalloffMode = (int)FalloffMode;
			m_fieldParams.FalloffDimensions = (int)FalloffDimensions;
			m_fieldParams.PropagationDepth = PropagationDepth;
			m_fieldParams.GridCenter = m_gridCenter;
			m_fieldParams.UpWs = (Params.Bits.IsBitSet(BoingWork.ReactorFlags.GlobalReactionUpVector) ? Params.RotationReactionUp : (base.transform.rotation * VectorUtil.NormalizeSafe(Params.RotationReactionUp, Vector3.up)));
			m_fieldParams.FieldPosition = base.transform.position;
			m_fieldParams.FalloffRatio = FalloffRatio;
			m_fieldParams.CellSize = CellSize;
			m_fieldParams.DeltaTime = Time.deltaTime;
			if (m_fieldParamsBuffer != null)
			{
				m_fieldParamsBuffer.SetData(new FieldParams[1] { m_fieldParams });
			}
		}

		private void UpdateFlags()
		{
			Params.Bits.SetBit(BoingWork.ReactorFlags.TwoDDistanceCheck, TwoDDistanceCheck);
			Params.Bits.SetBit(BoingWork.ReactorFlags.TwoDPositionInfluence, TwoDPositionInfluence);
			Params.Bits.SetBit(BoingWork.ReactorFlags.TwoDRotationInfluence, TwoDRotationInfluence);
			Params.Bits.SetBit(BoingWork.ReactorFlags.EnablePositionEffect, EnablePositionEffect);
			Params.Bits.SetBit(BoingWork.ReactorFlags.EnableRotationEffect, EnableRotationEffect);
			Params.Bits.SetBit(BoingWork.ReactorFlags.GlobalReactionUpVector, GlobalReactionUpVector);
			Params.Bits.SetBit(BoingWork.ReactorFlags.EnablePropagation, EnablePropagation);
			Params.Bits.SetBit(BoingWork.ReactorFlags.AnchorPropagationAtBorder, AnchorPropagationAtBorder);
		}

		public void UpdateBounds()
		{
			m_bounds = new Aabb(m_gridCenter + GetCellCenterOffset(0, 0, 0), m_gridCenter + GetCellCenterOffset(CellsX - 1, CellsY - 1, CellsZ - 1));
			m_bounds.Expand(CellSize);
		}

		public void PrepareExecute()
		{
			Init();
			if (SharedParams != null)
			{
				BoingWork.Params.Copy(ref SharedParams.Params, ref Params);
			}
			UpdateFlags();
			UpdateBounds();
			if (m_hardwareMode != HardwareMode)
			{
				switch (m_hardwareMode)
				{
				case HardwareModeEnum.CPU:
					DisposeCpuResources();
					break;
				case HardwareModeEnum.GPU:
					DisposeGpuResources();
					break;
				}
				m_hardwareMode = HardwareMode;
			}
			switch (m_hardwareMode)
			{
			case HardwareModeEnum.CPU:
				ValidateCpuResources();
				break;
			case HardwareModeEnum.GPU:
				ValidateGpuResources();
				break;
			}
			HandleCellMove();
			switch (m_hardwareMode)
			{
			case HardwareModeEnum.CPU:
				FinishPrepareExecuteCpu();
				break;
			case HardwareModeEnum.GPU:
				FinishPrepareExecuteGpu();
				break;
			}
		}

		private void ValidateCpuResources()
		{
			CellsX = Mathf.Max(1, CellsX);
			CellsY = Mathf.Max(1, CellsY);
			CellsZ = Mathf.Max(1, CellsZ);
			if (m_aCpuCell != null && m_cellsX == CellsX && m_cellsY == CellsY && m_cellsZ == CellsZ)
			{
				return;
			}
			m_aCpuCell = new BoingWork.Params.InstanceData[CellsZ, CellsY, CellsX];
			for (int i = 0; i < CellsZ; i++)
			{
				for (int j = 0; j < CellsY; j++)
				{
					for (int k = 0; k < CellsX; k++)
					{
						ResolveCellIndex(k, j, i, -1, out var resX, out var resY, out var resZ);
						m_aCpuCell[i, j, k].Reset(m_gridCenter + GetCellCenterOffset(resX, resY, resZ), instantAccumulation: false);
					}
				}
			}
			m_cellsX = CellsX;
			m_cellsY = CellsY;
			m_cellsZ = CellsZ;
		}

		private void ValidateGpuResources()
		{
			bool flag = false;
			int num;
			if (!(m_shader == null))
			{
				num = ((s_computeKernelId == null) ? 1 : 0);
				if (num == 0)
				{
					goto IL_00e3;
				}
			}
			else
			{
				num = 1;
			}
			m_shader = Resources.Load<ComputeShader>("Boing Kit/BoingReactorFieldCompute");
			flag = true;
			if (s_computeKernelId == null)
			{
				s_computeKernelId = new ComputeKernelId();
				s_computeKernelId.InitKernel = m_shader.FindKernel("Init");
				s_computeKernelId.MoveKernel = m_shader.FindKernel("Move");
				s_computeKernelId.WrapXKernel = m_shader.FindKernel("WrapX");
				s_computeKernelId.WrapYKernel = m_shader.FindKernel("WrapY");
				s_computeKernelId.WrapZKernel = m_shader.FindKernel("WrapZ");
				s_computeKernelId.ExecuteKernel = m_shader.FindKernel("Execute");
			}
			goto IL_00e3;
			IL_00e3:
			bool flag2 = m_effectorIndexBuffer == null || (Effectors != null && m_numEffectors != Effectors.Length);
			if (flag2 && Effectors != null)
			{
				if (m_effectorIndexBuffer != null)
				{
					m_effectorIndexBuffer.Dispose();
				}
				m_effectorIndexBuffer = new ComputeBuffer(Effectors.Length, 4);
				flag = true;
				m_numEffectors = Effectors.Length;
			}
			if (((uint)num | (flag2 ? 1u : 0u)) != 0)
			{
				m_shader.SetBuffer(s_computeKernelId.ExecuteKernel, ShaderPropertyId.EffectorIndices, m_effectorIndexBuffer);
			}
			bool flag3 = m_reactorParamsBuffer == null;
			if (flag3)
			{
				m_reactorParamsBuffer = new ComputeBuffer(1, BoingWork.Params.Stride);
				flag = true;
			}
			if (((uint)num | (flag3 ? 1u : 0u)) != 0)
			{
				m_shader.SetBuffer(s_computeKernelId.ExecuteKernel, ShaderPropertyId.ReactorParams, m_reactorParamsBuffer);
			}
			bool flag4 = m_fieldParamsBuffer == null;
			if (flag4)
			{
				m_fieldParamsBuffer = new ComputeBuffer(1, FieldParams.Stride);
				flag = true;
			}
			if (((uint)num | (flag4 ? 1u : 0u)) != 0)
			{
				m_shader.SetBuffer(s_computeKernelId.InitKernel, ShaderPropertyId.ComputeFieldParams, m_fieldParamsBuffer);
				m_shader.SetBuffer(s_computeKernelId.MoveKernel, ShaderPropertyId.ComputeFieldParams, m_fieldParamsBuffer);
				m_shader.SetBuffer(s_computeKernelId.WrapXKernel, ShaderPropertyId.ComputeFieldParams, m_fieldParamsBuffer);
				m_shader.SetBuffer(s_computeKernelId.WrapYKernel, ShaderPropertyId.ComputeFieldParams, m_fieldParamsBuffer);
				m_shader.SetBuffer(s_computeKernelId.WrapZKernel, ShaderPropertyId.ComputeFieldParams, m_fieldParamsBuffer);
				m_shader.SetBuffer(s_computeKernelId.ExecuteKernel, ShaderPropertyId.ComputeFieldParams, m_fieldParamsBuffer);
			}
			m_cellBufferNeedsReset = m_cellsBuffer == null || m_cellsX != CellsX || m_cellsY != CellsY || m_cellsZ != CellsZ;
			if (m_cellBufferNeedsReset)
			{
				if (m_cellsBuffer != null)
				{
					m_cellsBuffer.Dispose();
				}
				m_cellsBuffer = new ComputeBuffer(CellsX * CellsY * CellsZ, BoingWork.Params.InstanceData.Stride);
				flag = true;
				m_cellsX = CellsX;
				m_cellsY = CellsY;
				m_cellsZ = CellsZ;
			}
			if (num != 0 || m_cellBufferNeedsReset)
			{
				m_shader.SetBuffer(s_computeKernelId.InitKernel, ShaderPropertyId.ComputeCells, m_cellsBuffer);
				m_shader.SetBuffer(s_computeKernelId.MoveKernel, ShaderPropertyId.ComputeCells, m_cellsBuffer);
				m_shader.SetBuffer(s_computeKernelId.WrapXKernel, ShaderPropertyId.ComputeCells, m_cellsBuffer);
				m_shader.SetBuffer(s_computeKernelId.WrapYKernel, ShaderPropertyId.ComputeCells, m_cellsBuffer);
				m_shader.SetBuffer(s_computeKernelId.WrapZKernel, ShaderPropertyId.ComputeCells, m_cellsBuffer);
				m_shader.SetBuffer(s_computeKernelId.ExecuteKernel, ShaderPropertyId.ComputeCells, m_cellsBuffer);
			}
			if (flag)
			{
				m_gpuResourceSetId++;
				if (m_gpuResourceSetId < 0)
				{
					m_gpuResourceSetId = -1;
				}
			}
		}

		private void FinishPrepareExecuteCpu()
		{
			Quaternion rotation = base.transform.rotation;
			for (int i = 0; i < CellsZ; i++)
			{
				for (int j = 0; j < CellsY; j++)
				{
					for (int k = 0; k < CellsX; k++)
					{
						ResolveCellIndex(k, j, i, -1, out var resX, out var resY, out var resZ);
						m_aCpuCell[i, j, k].PrepareExecute(ref Params, m_gridCenter, rotation, GetCellCenterOffset(resX, resY, resZ));
					}
				}
			}
		}

		private void FinishPrepareExecuteGpu()
		{
			if (m_cellBufferNeedsReset)
			{
				UpdateFieldParamsGpu();
				m_shader.Dispatch(s_computeKernelId.InitKernel, CellsX, CellsY, CellsZ);
			}
		}

		public void Init()
		{
			if (!m_init)
			{
				m_hardwareMode = HardwareMode;
				m_init = true;
			}
		}

		public void Sanitize()
		{
			if (PropagationDepth < 0)
			{
				UnityEngine.Debug.LogWarning("Propagation iterations must be a positive number.");
			}
			else if (PropagationDepth > 3)
			{
				UnityEngine.Debug.LogWarning("For performance reasons, propagation is limited to 3 iterations.");
			}
			PropagationDepth = Mathf.Clamp(PropagationDepth, 1, 3);
		}

		public void HandleCellMove()
		{
			if (m_cellMoveMode != CellMoveMode)
			{
				Reboot();
				m_cellMoveMode = CellMoveMode;
			}
			switch (CellMoveMode)
			{
			case CellMoveModeEnum.Follow:
			{
				Vector3 vector2 = base.transform.position - m_gridCenter;
				switch (HardwareMode)
				{
				case HardwareModeEnum.CPU:
				{
					for (int i = 0; i < CellsZ; i++)
					{
						for (int j = 0; j < CellsY; j++)
						{
							for (int k = 0; k < CellsX; k++)
							{
								m_aCpuCell[i, j, k].PositionSpring.Value += vector2;
							}
						}
					}
					break;
				}
				case HardwareModeEnum.GPU:
					UpdateFieldParamsGpu();
					m_shader.SetVector(ShaderPropertyId.MoveParams, vector2);
					m_shader.Dispatch(s_computeKernelId.MoveKernel, CellsX, CellsY, CellsZ);
					break;
				}
				m_gridCenter = base.transform.position;
				m_qPrevGridCenterNorm = QuantizeNorm(m_gridCenter);
				break;
			}
			case CellMoveModeEnum.WrapAround:
			{
				m_gridCenter = base.transform.position;
				Vector3 vector = QuantizeNorm(m_gridCenter);
				m_gridCenter = vector * CellSize;
				int num = (int)(vector.x - m_qPrevGridCenterNorm.x);
				int num2 = (int)(vector.y - m_qPrevGridCenterNorm.y);
				int num3 = (int)(vector.z - m_qPrevGridCenterNorm.z);
				m_qPrevGridCenterNorm = vector;
				if (num != 0 || num2 != 0 || num3 != 0)
				{
					switch (m_hardwareMode)
					{
					case HardwareModeEnum.CPU:
						WrapCpu(num, num2, num3);
						break;
					case HardwareModeEnum.GPU:
						WrapGpu(num, num2, num3);
						break;
					}
					m_iCellBaseX = MathUtil.Modulo(m_iCellBaseX + num, CellsX);
					m_iCellBaseY = MathUtil.Modulo(m_iCellBaseY + num2, CellsY);
					m_iCellBaseZ = MathUtil.Modulo(m_iCellBaseZ + num3, CellsZ);
				}
				break;
			}
			}
		}

		private void InitPropagationCpu(ref BoingWork.Params.InstanceData data)
		{
			data.PositionPropagationWorkData = Vector3.zero;
			data.RotationPropagationWorkData = Vector3.zero;
		}

		private void PropagateSpringCpu(ref BoingWork.Params.InstanceData data, float dt)
		{
			data.PositionSpring.Velocity += kPropagationFactor * PositionPropagation * data.PositionPropagationWorkData * dt;
			data.RotationSpring.VelocityVec += kPropagationFactor * RotationPropagation * data.RotationPropagationWorkData * dt;
		}

		private void ExtendPropagationBorder(ref BoingWork.Params.InstanceData data, float weight, int adjDeltaX, int adjDeltaY, int adjDeltaZ)
		{
			data.PositionPropagationWorkData += weight * (data.PositionOrigin + new Vector3(adjDeltaX, adjDeltaY, adjDeltaZ) * CellSize);
			data.RotationPropagationWorkData += weight * data.RotationOrigin;
		}

		private void AccumulatePropagationWeightedNeighbor(ref BoingWork.Params.InstanceData data, ref BoingWork.Params.InstanceData neighbor, float weight)
		{
			data.PositionPropagationWorkData += weight * (neighbor.PositionSpring.Value - neighbor.PositionOrigin);
			data.RotationPropagationWorkData += weight * (neighbor.RotationSpring.ValueVec - neighbor.RotationOrigin);
		}

		private void GatherPropagation(ref BoingWork.Params.InstanceData data, float weightSum)
		{
			data.PositionPropagationWorkData = data.PositionPropagationWorkData / weightSum - (data.PositionSpring.Value - data.PositionOrigin);
			data.RotationPropagationWorkData = data.RotationPropagationWorkData / weightSum - (data.RotationSpring.ValueVec - data.RotationOrigin);
		}

		private void AnchorPropagationBorder(ref BoingWork.Params.InstanceData data)
		{
			data.PositionPropagationWorkData = Vector3.zero;
			data.RotationPropagationWorkData = Vector3.zero;
		}

		private void PropagateCpu(float dt)
		{
			int[] array = new int[PropagationDepth * 2 + 1];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = i - PropagationDepth;
			}
			for (int j = 0; j < CellsZ; j++)
			{
				for (int k = 0; k < CellsY; k++)
				{
					for (int l = 0; l < CellsX; l++)
					{
						InitPropagationCpu(ref m_aCpuCell[j, k, l]);
					}
				}
			}
			for (int m = 0; m < CellsZ; m++)
			{
				for (int n = 0; n < CellsY; n++)
				{
					for (int num = 0; num < CellsX; num++)
					{
						ResolveCellIndex(num, n, m, -1, out var resX, out var resY, out var resZ);
						float num2 = 0f;
						int[] array2 = array;
						foreach (int num4 in array2)
						{
							int[] array3 = array;
							foreach (int num6 in array3)
							{
								int[] array4 = array;
								foreach (int num8 in array4)
								{
									if (num8 != 0 || num6 != 0 || num4 != 0)
									{
										int num9 = num8 * num8 + num6 * num6 + num4 * num4;
										float num10 = s_aSqrtInv[num9];
										num2 += num10;
										if ((CellsX <= 2 || ((resX != 0 || num8 >= 0) && (resX != CellsX - 1 || num8 <= 0))) && (CellsY <= 2 || ((resY != 0 || num6 >= 0) && (resY != CellsY - 1 || num6 <= 0))) && (CellsZ <= 2 || ((resZ != 0 || num4 >= 0) && (resZ != CellsZ - 1 || num4 <= 0))))
										{
											int num11 = MathUtil.Modulo(num + num8, CellsX);
											int num12 = MathUtil.Modulo(n + num6, CellsY);
											int num13 = MathUtil.Modulo(m + num4, CellsZ);
											AccumulatePropagationWeightedNeighbor(ref m_aCpuCell[m, n, num], ref m_aCpuCell[num13, num12, num11], num10);
										}
									}
								}
							}
						}
						if (!(num2 <= 0f))
						{
							GatherPropagation(ref m_aCpuCell[m, n, num], num2);
						}
					}
				}
			}
			if (AnchorPropagationAtBorder)
			{
				for (int num14 = 0; num14 < CellsZ; num14++)
				{
					for (int num15 = 0; num15 < CellsY; num15++)
					{
						for (int num16 = 0; num16 < CellsX; num16++)
						{
							ResolveCellIndex(num16, num15, num14, -1, out var resX2, out var resY2, out var resZ2);
							if (((resX2 == 0 || resX2 == CellsX - 1) && CellsX > 2) || ((resY2 == 0 || resY2 == CellsY - 1) && CellsY > 2) || ((resZ2 == 0 || resZ2 == CellsZ - 1) && CellsZ > 2))
							{
								AnchorPropagationBorder(ref m_aCpuCell[num14, num15, num16]);
							}
						}
					}
				}
			}
			for (int num17 = 0; num17 < CellsZ; num17++)
			{
				for (int num18 = 0; num18 < CellsY; num18++)
				{
					for (int num19 = 0; num19 < CellsX; num19++)
					{
						PropagateSpringCpu(ref m_aCpuCell[num17, num18, num19], dt);
					}
				}
			}
		}

		private void WrapCpu(int deltaX, int deltaY, int deltaZ)
		{
			if (deltaX != 0)
			{
				int num = ((deltaX <= 0) ? 1 : (-1));
				for (int i = 0; i < CellsZ; i++)
				{
					for (int j = 0; j < CellsY; j++)
					{
						for (int k = ((deltaX > 0) ? (deltaX - 1) : (CellsX + deltaX)); k >= 0 && k < CellsX; k += num)
						{
							ResolveCellIndex(k, j, i, 1, out var resX, out var resY, out var resZ);
							ResolveCellIndex(resX - deltaX, resY - deltaY, resZ - deltaZ, -1, out var resX2, out var resY2, out var resZ2);
							m_aCpuCell[resZ, resY, resX].Reset(m_gridCenter + GetCellCenterOffset(resX2, resY2, resZ2), instantAccumulation: true);
						}
					}
				}
			}
			if (deltaY != 0)
			{
				int num2 = ((deltaY <= 0) ? 1 : (-1));
				for (int l = 0; l < CellsZ; l++)
				{
					for (int m = ((deltaY > 0) ? (deltaY - 1) : (CellsY + deltaY)); m >= 0 && m < CellsY; m += num2)
					{
						for (int n = 0; n < CellsX; n++)
						{
							ResolveCellIndex(n, m, l, 1, out var resX3, out var resY3, out var resZ3);
							ResolveCellIndex(resX3 - deltaX, resY3 - deltaY, resZ3 - deltaZ, -1, out var resX4, out var resY4, out var resZ4);
							m_aCpuCell[resZ3, resY3, resX3].Reset(m_gridCenter + GetCellCenterOffset(resX4, resY4, resZ4), instantAccumulation: true);
						}
					}
				}
			}
			if (deltaZ == 0)
			{
				return;
			}
			int num3 = ((deltaZ <= 0) ? 1 : (-1));
			for (int num4 = ((deltaZ > 0) ? (deltaZ - 1) : (CellsZ + deltaZ)); num4 >= 0 && num4 < CellsZ; num4 += num3)
			{
				for (int num5 = 0; num5 < CellsY; num5++)
				{
					for (int num6 = 0; num6 < CellsX; num6++)
					{
						ResolveCellIndex(num6, num5, num4, 1, out var resX5, out var resY5, out var resZ5);
						ResolveCellIndex(resX5 - deltaX, resY5 - deltaY, resZ5 - deltaZ, -1, out var resX6, out var resY6, out var resZ6);
						m_aCpuCell[resZ5, resY5, resX5].Reset(m_gridCenter + GetCellCenterOffset(resX6, resY6, resZ6), instantAccumulation: true);
					}
				}
			}
		}

		private void WrapGpu(int deltaX, int deltaY, int deltaZ)
		{
			UpdateFieldParamsGpu();
			m_shader.SetInts(ShaderPropertyId.WrapParams, deltaX, deltaY, deltaZ);
			if (deltaX != 0)
			{
				m_shader.Dispatch(s_computeKernelId.WrapXKernel, 1, CellsY, CellsZ);
			}
			if (deltaY != 0)
			{
				m_shader.Dispatch(s_computeKernelId.WrapYKernel, CellsX, 1, CellsZ);
			}
			if (deltaZ != 0)
			{
				m_shader.Dispatch(s_computeKernelId.WrapZKernel, CellsX, CellsY, 1);
			}
		}

		public void ExecuteCpu(float dt)
		{
			PrepareExecute();
			if (Effectors == null || Effectors.Length == 0)
			{
				return;
			}
			if (EnablePropagation)
			{
				PropagateCpu(dt);
			}
			BoingEffector[] effectors = Effectors;
			foreach (BoingEffector boingEffector in effectors)
			{
				if (boingEffector == null)
				{
					continue;
				}
				BoingEffector.Params effector = default(BoingEffector.Params);
				effector.Fill(boingEffector);
				if (!m_bounds.Intersects(ref effector))
				{
					continue;
				}
				for (int j = 0; j < CellsZ; j++)
				{
					for (int k = 0; k < CellsY; k++)
					{
						for (int l = 0; l < CellsX; l++)
						{
							m_aCpuCell[j, k, l].AccumulateTarget(ref Params, ref effector);
						}
					}
				}
			}
			for (int m = 0; m < CellsZ; m++)
			{
				for (int n = 0; n < CellsY; n++)
				{
					for (int num = 0; num < CellsX; num++)
					{
						m_aCpuCell[m, n, num].EndAccumulateTargets(ref Params);
						m_aCpuCell[m, n, num].Execute(ref Params, dt);
					}
				}
			}
		}

		public void ExecuteGpu(float dt, ComputeBuffer effectorParamsBuffer, Dictionary<int, int> effectorParamsIndexMap)
		{
			PrepareExecute();
			UpdateFieldParamsGpu();
			m_shader.SetBuffer(s_computeKernelId.ExecuteKernel, ShaderPropertyId.Effectors, effectorParamsBuffer);
			if (m_fieldParams.NumEffectors > 0)
			{
				int[] array = new int[m_fieldParams.NumEffectors];
				int num = 0;
				BoingEffector[] effectors = Effectors;
				foreach (BoingEffector boingEffector in effectors)
				{
					if (!(boingEffector == null))
					{
						BoingEffector component = boingEffector.GetComponent<BoingEffector>();
						if (!(component == null) && component.isActiveAndEnabled && effectorParamsIndexMap.TryGetValue(component.GetInstanceID(), out var value))
						{
							array[num++] = value;
						}
					}
				}
				m_effectorIndexBuffer.SetData(array);
			}
			s_aReactorParams[0] = Params;
			m_reactorParamsBuffer.SetData(s_aReactorParams);
			m_shader.SetVector(ShaderPropertyId.PropagationParams, new Vector4(PositionPropagation, RotationPropagation, kPropagationFactor, 0f));
			m_shader.Dispatch(s_computeKernelId.ExecuteKernel, CellsX, CellsY, CellsZ);
		}

		public void OnDrawGizmosSelected()
		{
			if (base.isActiveAndEnabled)
			{
				DrawGizmos(drawEffectors: true);
			}
		}

		private void DrawGizmos(bool drawEffectors)
		{
			Vector3 vector = GetGridCenter();
			switch (CellMoveMode)
			{
			case CellMoveModeEnum.Follow:
				vector = base.transform.position;
				break;
			case CellMoveModeEnum.WrapAround:
				vector = new Vector3(Mathf.Round(base.transform.position.x / CellSize), Mathf.Round(base.transform.position.y / CellSize), Mathf.Round(base.transform.position.z / CellSize)) * CellSize;
				break;
			}
			BoingWork.Params.InstanceData[,,] array = null;
			switch (HardwareMode)
			{
			case HardwareModeEnum.CPU:
				array = m_aCpuCell;
				break;
			case HardwareModeEnum.GPU:
				if (m_cellsBuffer != null)
				{
					array = new BoingWork.Params.InstanceData[CellsZ, CellsY, CellsX];
					m_cellsBuffer.GetData(array);
				}
				break;
			}
			int num = 1;
			if (CellsX * CellsY * CellsZ > 1024)
			{
				num = 2;
			}
			if (CellsX * CellsY * CellsZ > 4096)
			{
				num = 3;
			}
			if (CellsX * CellsY * CellsZ > 8192)
			{
				num = 4;
			}
			for (int i = 0; i < CellsZ; i++)
			{
				for (int j = 0; j < CellsY; j++)
				{
					for (int k = 0; k < CellsX; k++)
					{
						ResolveCellIndex(k, j, i, -1, out var resX, out var resY, out var resZ);
						Vector3 center = vector + GetCellCenterOffset(resX, resY, resZ);
						if (array != null && k % num == 0 && j % num == 0 && i % num == 0)
						{
							BoingWork.Params.InstanceData instanceData = array[i, j, k];
							Gizmos.color = new Color(1f, 1f, 1f, 1f);
							Gizmos.matrix = Matrix4x4.TRS(instanceData.PositionSpring.Value, instanceData.RotationSpring.ValueQuat, Vector3.one);
							Gizmos.DrawCube(Vector3.zero, Mathf.Min(0.1f, 0.5f * CellSize) * Vector3.one);
							Gizmos.matrix = Matrix4x4.identity;
						}
						Gizmos.color = new Color(1f, 0.5f, 0.2f, 1f);
						Gizmos.DrawWireCube(center, CellSize * Vector3.one);
					}
				}
			}
			switch (FalloffMode)
			{
			case FalloffModeEnum.Circle:
			{
				float num2 = Mathf.Max(CellsX, CellsY, CellsZ);
				Gizmos.color = new Color(1f, 1f, 0.2f, 0.5f);
				Gizmos.matrix = Matrix4x4.Translate(vector) * Matrix4x4.Scale(new Vector3(CellsX, CellsY, CellsZ) / num2);
				Gizmos.DrawWireSphere(Vector3.zero, 0.5f * CellSize * num2 * FalloffRatio);
				Gizmos.matrix = Matrix4x4.identity;
				break;
			}
			case FalloffModeEnum.Square:
			{
				Vector3 size = CellSize * FalloffRatio * new Vector3(CellsX, CellsY, CellsZ);
				Gizmos.color = new Color(1f, 1f, 0.2f, 0.5f);
				Gizmos.DrawWireCube(vector, size);
				break;
			}
			}
			if (!drawEffectors || Effectors == null)
			{
				return;
			}
			BoingEffector[] effectors = Effectors;
			foreach (BoingEffector boingEffector in effectors)
			{
				if (!(boingEffector == null))
				{
					boingEffector.OnDrawGizmosSelected();
				}
			}
		}

		private Vector3 GetGridCenter()
		{
			return CellMoveMode switch
			{
				CellMoveModeEnum.Follow => base.transform.position, 
				CellMoveModeEnum.WrapAround => QuantizeNorm(base.transform.position) * CellSize, 
				_ => base.transform.position, 
			};
		}

		private Vector3 QuantizeNorm(Vector3 p)
		{
			return new Vector3(Mathf.Round(p.x / CellSize), Mathf.Round(p.y / CellSize), Mathf.Round(p.z / CellSize));
		}

		private Vector3 GetCellCenterOffset(int x, int y, int z)
		{
			return CellSize * (-0.5f * (new Vector3(CellsX, CellsY, CellsZ) - Vector3.one) + new Vector3(x, y, z));
		}

		private void ResolveCellIndex(int x, int y, int z, int baseMult, out int resX, out int resY, out int resZ)
		{
			resX = MathUtil.Modulo(x + baseMult * m_iCellBaseX, CellsX);
			resY = MathUtil.Modulo(y + baseMult * m_iCellBaseY, CellsY);
			resZ = MathUtil.Modulo(z + baseMult * m_iCellBaseZ, CellsZ);
		}
	}
	public class BoingReactorFieldCPUSampler : MonoBehaviour
	{
		public BoingReactorField ReactorField;

		[Tooltip("When to apply transforms for rendering.\n\nUpdate - Apply transforms for rendering during Update. Only use this mode if your render logic pulls transforms during Update(), such as Unity's skinned sprite renderer (in certain versions).\n\nLate Update - Apply transforms for rendering during LateUpdate(). This is the recommended option.")]
		public BoingManager.UpdateTiming UpdateTiming = BoingManager.UpdateTiming.Late;

		[Range(0f, 10f)]
		[Tooltip("Multiplier on positional samples from reactor field.\n1.0 means 100%.")]
		public float PositionSampleMultiplier = 1f;

		[Range(0f, 10f)]
		[Tooltip("Multiplier on rotational samples from reactor field.\n1.0 means 100%.")]
		public float RotationSampleMultiplier = 1f;

		private Vector3 m_objPosition;

		private Quaternion m_objRotation;

		public void OnEnable()
		{
			BoingManager.Register(this);
		}

		public void OnDisable()
		{
			BoingManager.Unregister(this);
		}

		public void SampleFromField()
		{
			m_objPosition = base.transform.position;
			m_objRotation = base.transform.rotation;
			if (!(ReactorField == null))
			{
				BoingReactorField component = ReactorField.GetComponent<BoingReactorField>();
				if (!(component == null) && component.HardwareMode == BoingReactorField.HardwareModeEnum.CPU && component.SampleCpuGrid(base.transform.position, out var positionOffset, out var rotationOffset))
				{
					base.transform.position = m_objPosition + positionOffset * PositionSampleMultiplier;
					base.transform.rotation = QuaternionUtil.Pow(QuaternionUtil.FromVector4(rotationOffset), RotationSampleMultiplier) * m_objRotation;
				}
			}
		}

		public void Restore()
		{
			base.transform.position = m_objPosition;
			base.transform.rotation = m_objRotation;
		}
	}
	public class BoingReactorFieldGPUSampler : MonoBehaviour
	{
		public BoingReactorField ReactorField;

		[Range(0f, 10f)]
		[Tooltip("Multiplier on positional samples from reactor field.\n1.0 means 100%.")]
		public float PositionSampleMultiplier = 1f;

		[Range(0f, 10f)]
		[Tooltip("Multiplier on rotational samples from reactor field.\n1.0 means 100%.")]
		public float RotationSampleMultiplier = 1f;

		private MaterialPropertyBlock m_matProps;

		private int m_fieldResourceSetId = -1;

		public void OnEnable()
		{
			BoingManager.Register(this);
		}

		public void OnDisable()
		{
			BoingManager.Unregister(this);
		}

		public void Update()
		{
			if (ReactorField == null)
			{
				return;
			}
			BoingReactorField component = ReactorField.GetComponent<BoingReactorField>();
			if (component == null || component.HardwareMode != BoingReactorField.HardwareModeEnum.GPU || m_fieldResourceSetId == component.GpuResourceSetId)
			{
				return;
			}
			if (m_matProps == null)
			{
				m_matProps = new MaterialPropertyBlock();
			}
			if (!component.UpdateShaderConstants(m_matProps, PositionSampleMultiplier, RotationSampleMultiplier))
			{
				return;
			}
			m_fieldResourceSetId = component.GpuResourceSetId;
			Renderer[] array = new Renderer[2]
			{
				GetComponent<MeshRenderer>(),
				GetComponent<SkinnedMeshRenderer>()
			};
			foreach (Renderer renderer in array)
			{
				if (!(renderer == null))
				{
					renderer.SetPropertyBlock(m_matProps);
				}
			}
		}
	}
	public static class BoingWork
	{
		public enum EffectorFlags
		{
			ContinuousMotion
		}

		public enum ReactorFlags
		{
			TwoDDistanceCheck,
			TwoDPositionInfluence,
			TwoDRotationInfluence,
			EnablePositionEffect,
			EnableRotationEffect,
			GlobalReactionUpVector,
			EnablePropagation,
			AnchorPropagationAtBorder,
			FixedUpdate,
			LateUpdateTiming
		}

		[Serializable]
		public struct Params
		{
			public struct InstanceData
			{
				public static readonly int Stride = 128 + Vector3Spring.Stride + QuaternionSpring.Stride;

				public Vector3 PositionTarget;

				private float m_padding0;

				public Vector3 PositionOrigin;

				private float m_padding1;

				public Vector4 RotationTarget;

				public Vector4 RotationOrigin;

				private int m_numEffectors;

				private int m_instantAccumulation;

				private int m_padding2;

				private int m_padding3;

				private Vector3 m_upWs;

				private float m_scale;

				public Vector3Spring PositionSpring;

				public QuaternionSpring RotationSpring;

				public Vector3 PositionPropagationWorkData;

				private float m_padding4;

				public Vector4 RotationPropagationWorkData;

				public void Reset()
				{
					PositionSpring.Reset();
					RotationSpring.Reset();
					PositionPropagationWorkData = Vector3.zero;
					RotationPropagationWorkData = Vector3.zero;
				}

				public void Reset(Vector3 position, bool instantAccumulation)
				{
					PositionSpring.Reset(position);
					RotationSpring.Reset();
					PositionPropagationWorkData = Vector3.zero;
					RotationPropagationWorkData = Vector3.zero;
					m_instantAccumulation = (instantAccumulation ? 1 : 0);
				}

				public void PrepareExecute(ref Params p, Vector3 position, Quaternion rotation, float scale, bool accumulateEffectors)
				{
					PositionTarget = (PositionOrigin = position);
					RotationTarget = (RotationOrigin = QuaternionUtil.ToVector4(rotation));
					if (accumulateEffectors)
					{
						PositionTarget = Vector3.zero;
						RotationTarget = Vector4.zero;
						m_numEffectors = 0;
						m_upWs = (p.Bits.IsBitSet(ReactorFlags.GlobalReactionUpVector) ? p.RotationReactionUp : (rotation * VectorUtil.NormalizeSafe(p.RotationReactionUp, Vector3.up)));
						m_scale = scale;
					}
					else
					{
						m_numEffectors = -1;
						m_upWs = Vector3.zero;
					}
				}

				public void PrepareExecute(ref Params p, Vector3 gridCenter, Quaternion gridRotation, Vector3 cellOffset)
				{
					PositionOrigin = gridCenter + cellOffset;
					RotationOrigin = QuaternionUtil.ToVector4(Quaternion.identity);
					PositionTarget = Vector3.zero;
					RotationTarget = Vector4.zero;
					m_numEffectors = 0;
					m_upWs = (p.Bits.IsBitSet(ReactorFlags.GlobalReactionUpVector) ? p.RotationReactionUp : (gridRotation * VectorUtil.NormalizeSafe(p.RotationReactionUp, Vector3.up)));
					m_scale = 1f;
				}

				public void AccumulateTarget(ref Params p, ref BoingEffector.Params effector)
				{
					Vector3 vector = (effector.Bits.IsBitSet(EffectorFlags.ContinuousMotion) ? VectorUtil.GetClosestPointOnSegment(PositionOrigin, effector.PrevPosition, effector.CurrPosition) : effector.CurrPosition);
					Vector3 vector2 = PositionOrigin - vector;
					Vector3 vector3 = vector2;
					if (p.Bits.IsBitSet(ReactorFlags.TwoDDistanceCheck))
					{
						switch (p.TwoDPlane)
						{
						case TwoDPlaneEnum.XY:
							vector2.z = 0f;
							break;
						case TwoDPlaneEnum.XZ:
							vector2.y = 0f;
							break;
						case TwoDPlaneEnum.YZ:
							vector2.x = 0f;
							break;
						}
					}
					if (!(Mathf.Abs(vector2.x) <= effector.Radius) || !(Mathf.Abs(vector2.y) <= effector.Radius) || !(Mathf.Abs(vector2.z) <= effector.Radius) || !(vector2.sqrMagnitude <= effector.Radius * effector.Radius))
					{
						return;
					}
					float magnitude = vector2.magnitude;
					float num = ((effector.Radius - effector.FullEffectRadius > MathUtil.Epsilon) ? (1f - Mathf.Clamp01((magnitude - effector.FullEffectRadius) / (effector.Radius - effector.FullEffectRadius))) : 1f);
					Vector3 vector4 = m_upWs;
					Vector3 vector5 = m_upWs;
					Vector3 vector6 = VectorUtil.NormalizeSafe(vector3, m_upWs);
					Vector3 vector7 = vector6;
					if (p.Bits.IsBitSet(ReactorFlags.TwoDPositionInfluence))
					{
						switch (p.TwoDPlane)
						{
						case TwoDPlaneEnum.XY:
							vector6.z = 0f;
							vector4.z = 0f;
							break;
						case TwoDPlaneEnum.XZ:
							vector6.y = 0f;
							vector4.y = 0f;
							break;
						case TwoDPlaneEnum.YZ:
							vector6.x = 0f;
							vector4.x = 0f;
							break;
						}
						if (vector4.sqrMagnitude < MathUtil.Epsilon)
						{
							switch (p.TwoDPlane)
							{
							case TwoDPlaneEnum.XY:
								vector4 = Vector3.up;
								break;
							case TwoDPlaneEnum.XZ:
								vector4 = Vector3.forward;
								break;
							case TwoDPlaneEnum.YZ:
								vector4 = Vector3.up;
								break;
							}
						}
						else
						{
							vector4.Normalize();
						}
						vector6 = VectorUtil.NormalizeSafe(vector6, vector4);
					}
					if (p.Bits.IsBitSet(ReactorFlags.TwoDRotationInfluence))
					{
						switch (p.TwoDPlane)
						{
						case TwoDPlaneEnum.XY:
							vector7.z = 0f;
							vector5.z = 0f;
							break;
						case TwoDPlaneEnum.XZ:
							vector7.y = 0f;
							vector5.y = 0f;
							break;
						case TwoDPlaneEnum.YZ:
							vector7.x = 0f;
							vector5.x = 0f;
							break;
						}
						if (vector5.sqrMagnitude < MathUtil.Epsilon)
						{
							switch (p.TwoDPlane)
							{
							case TwoDPlaneEnum.XY:
								vector5 = Vector3.up;
								break;
							case TwoDPlaneEnum.XZ:
								vector5 = Vector3.forward;
								break;
							case TwoDPlaneEnum.YZ:
								vector5 = Vector3.up;
								break;
							}
						}
						else
						{
							vector5.Normalize();
						}
						vector7 = VectorUtil.NormalizeSafe(vector7, vector5);
					}
					if (p.Bits.IsBitSet(ReactorFlags.EnablePositionEffect))
					{
						Vector3 vector8 = num * p.MoveReactionMultiplier * effector.MoveDistance * vector6;
						PositionTarget += vector8;
						PositionSpring.Velocity += num * p.LinearImpulseMultiplier * effector.LinearImpulse * effector.LinearVelocityDir;
					}
					if (p.Bits.IsBitSet(ReactorFlags.EnableRotationEffect))
					{
						Vector3 vector9 = VectorUtil.NormalizeSafe(Vector3.Cross(vector5, vector7), VectorUtil.FindOrthogonal(vector5));
						Vector3 v = num * p.RotationReactionMultiplier * effector.RotateAngle * vector9;
						RotationTarget += QuaternionUtil.ToVector4(QuaternionUtil.FromAngularVector(v));
						Vector3 v2 = VectorUtil.NormalizeSafe(Vector3.Cross(effector.LinearVelocityDir, vector7 - 0.01f * Vector3.up), vector9);
						float num2 = num * p.AngularImpulseMultiplier * effector.AngularImpulse;
						Vector4 vector10 = QuaternionUtil.ToVector4(QuaternionUtil.FromAngularVector(v2));
						RotationSpring.VelocityVec += num2 * vector10;
					}
					m_numEffectors++;
				}

				public void EndAccumulateTargets(ref Params p)
				{
					if (m_numEffectors > 0)
					{
						PositionTarget *= m_scale / (float)m_numEffectors;
						PositionTarget += PositionOrigin;
						RotationTarget /= (float)m_numEffectors;
						RotationTarget = QuaternionUtil.ToVector4(QuaternionUtil.FromVector4(RotationTarget) * QuaternionUtil.FromVector4(RotationOrigin));
					}
					else
					{
						PositionTarget = PositionOrigin;
						RotationTarget = RotationOrigin;
					}
				}

				public void Execute(ref Params p, float dt)
				{
					bool flag = m_numEffectors >= 0;
					bool flag2 = ((!flag) ? p.Bits.IsBitSet(ReactorFlags.EnablePositionEffect) : (PositionSpring.Velocity.sqrMagnitude > MathUtil.Epsilon || (PositionSpring.Value - PositionTarget).sqrMagnitude > MathUtil.Epsilon));
					bool flag3 = ((!flag) ? p.Bits.IsBitSet(ReactorFlags.EnableRotationEffect) : (RotationSpring.VelocityVec.sqrMagnitude > MathUtil.Epsilon || (RotationSpring.ValueVec - RotationTarget).sqrMagnitude > MathUtil.Epsilon));
					if (m_numEffectors == 0)
					{
						bool flag4 = true;
						if (flag2)
						{
							flag4 = false;
						}
						else
						{
							PositionSpring.Reset(PositionTarget);
						}
						if (flag3)
						{
							flag4 = false;
						}
						else
						{
							RotationSpring.Reset(QuaternionUtil.FromVector4(RotationTarget));
						}
						if (flag4)
						{
							return;
						}
					}
					if (m_instantAccumulation != 0)
					{
						PositionSpring.Value = PositionTarget;
						RotationSpring.ValueVec = RotationTarget;
						m_instantAccumulation = 0;
					}
					else
					{
						if (flag2)
						{
							switch (p.PositionParameterMode)
							{
							case ParameterMode.Exponential:
								PositionSpring.TrackExponential(PositionTarget, p.PositionExponentialHalfLife, dt);
								break;
							case ParameterMode.OscillationByHalfLife:
								PositionSpring.TrackHalfLife(PositionTarget, p.PositionOscillationFrequency, p.PositionOscillationHalfLife, dt);
								break;
							case ParameterMode.OscillationByDampingRatio:
								PositionSpring.TrackDampingRatio(PositionTarget, p.PositionOscillationFrequency * MathUtil.TwoPi, p.PositionOscillationDampingRatio, dt);
								break;
							}
						}
						if (flag3)
						{
							switch (p.RotationParameterMode)
							{
							case ParameterMode.Exponential:
								RotationSpring.TrackExponential(RotationTarget, p.RotationExponentialHalfLife, dt);
								break;
							case ParameterMode.OscillationByHalfLife:
								RotationSpring.TrackHalfLife(RotationTarget, p.RotationOscillationFrequency, p.RotationOscillationHalfLife, dt);
								break;
							case ParameterMode.OscillationByDampingRatio:
								RotationSpring.TrackDampingRatio(RotationTarget, p.RotationOscillationFrequency * MathUtil.TwoPi, p.RotationOscillationDampingRatio, dt);
								break;
							}
						}
					}
					if (!flag)
					{
						if (!flag2)
						{
							PositionSpring.Reset(PositionTarget);
						}
						if (!flag3)
						{
							RotationSpring.Reset(RotationTarget);
						}
					}
				}

				public void PullResults(BoingBones bones)
				{
					for (int i = 0; i < bones.BoneData.Length; i++)
					{
						BoingBones.Chain chain = bones.BoneChains[i];
						BoingBones.Bone[] array = bones.BoneData[i];
						if (array == null)
						{
							continue;
						}
						BoingBones.Bone[] array2 = array;
						foreach (BoingBones.Bone obj in array2)
						{
							obj.CachedPositionWs = obj.Transform.position;
							obj.CachedPositionLs = obj.Transform.localPosition;
							obj.CachedRotationWs = obj.Transform.rotation;
							obj.CachedRotationLs = obj.Transform.localRotation;
						}
						for (int k = 0; k < array.Length; k++)
						{
							BoingBones.Bone bone = array[k];
							if (k == 0 && !chain.LooseRoot)
							{
								bone.BlendedPositionWs = bone.CachedPositionWs;
							}
							else
							{
								bone.BlendedPositionWs = Vector3.Lerp(bone.Instance.PositionSpring.Value, bone.CachedPositionWs, bone.AnimationBlend);
							}
						}
						if (bones.EnableRotationEffect)
						{
							for (int l = 0; l < array.Length; l++)
							{
								BoingBones.Bone bone2 = array[l];
								if (l == 0 && !chain.LooseRoot)
								{
									bone2.BlendedRotationWs = bone2.CachedRotationWs;
									continue;
								}
								if (bone2.ChildIndices == null)
								{
									if (bone2.ParentIndex >= 0)
									{
										BoingBones.Bone bone3 = array[bone2.ParentIndex];
										bone2.BlendedRotationWs = bone3.BlendedRotationWs * (bone3.RotationInverseWs * bone2.CachedRotationWs);
									}
									continue;
								}
								Vector3 cachedPositionWs = bone2.CachedPositionWs;
								Vector3 vector = ComputeTranslationalResults(bone2.Transform, cachedPositionWs, bone2.BlendedPositionWs, bones);
								Quaternion cachedRotationWs = bone2.CachedRotationWs;
								Quaternion quaternion = Quaternion.Inverse(cachedRotationWs);
								Vector4 vector2 = Vector3.zero;
								float num = 0f;
								int[] childIndices = bone2.ChildIndices;
								foreach (int num2 in childIndices)
								{
									if (num2 >= 0)
									{
										BoingBones.Bone bone4 = array[num2];
										Vector3 cachedPositionWs2 = bone4.CachedPositionWs;
										Vector3 fromDirection = VectorUtil.NormalizeSafe(cachedPositionWs2 - cachedPositionWs, Vector3.zero);
										Vector3 toDirection = VectorUtil.NormalizeSafe(ComputeTranslationalResults(bone4.Transform, cachedPositionWs2, bone4.BlendedPositionWs, bones) - vector, Vector3.zero);
										Quaternion quaternion2 = Quaternion.FromToRotation(fromDirection, toDirection);
										Vector4 vector3 = QuaternionUtil.ToVector4(quaternion * quaternion2);
										float num3 = Mathf.Max(MathUtil.Epsilon, chain.MaxLengthFromRoot - bone4.LengthFromRoot);
										vector2 += num3 * vector3;
										num += num3;
									}
								}
								if (num > 0f)
								{
									Vector4 v = vector2 / num;
									bone2.RotationBackPropDeltaPs = QuaternionUtil.FromVector4(v);
									bone2.BlendedRotationWs = cachedRotationWs * bone2.RotationBackPropDeltaPs * cachedRotationWs;
								}
								else if (bone2.ParentIndex >= 0)
								{
									BoingBones.Bone bone5 = array[bone2.ParentIndex];
									bone2.BlendedRotationWs = bone5.BlendedRotationWs * (bone5.RotationInverseWs * bone2.CachedRotationWs);
								}
							}
						}
						for (int m = 0; m < array.Length; m++)
						{
							BoingBones.Bone bone6 = array[m];
							if (m == 0 && !chain.LooseRoot)
							{
								bone6.Instance.PositionSpring.Reset(bone6.CachedPositionWs);
								bone6.Instance.RotationSpring.Reset(bone6.CachedRotationWs);
							}
							else
							{
								bone6.Transform.position = ComputeTranslationalResults(bone6.Transform, bone6.Transform.position, bone6.BlendedPositionWs, bones);
								bone6.Transform.rotation = bone6.BlendedRotationWs;
								bone6.Transform.localScale = bone6.BlendedScaleLs;
							}
						}
					}
				}

				private void SuppressWarnings()
				{
					m_padding0 = 0f;
					m_padding1 = 0f;
					m_padding2 = 0;
					m_padding3 = 0;
					m_padding4 = 0f;
					m_padding4 = 0f;
					m_padding0 = m_padding1;
					m_padding1 = m_padding2;
					m_padding2 = m_padding3;
					m_padding3 = (int)m_padding4;
					m_padding4 = m_padding0;
				}
			}

			public static readonly int Stride = 96 + InstanceData.Stride;

			public int InstanceID;

			public Bits32 Bits;

			public TwoDPlaneEnum TwoDPlane;

			private int m_padding0;

			public ParameterMode PositionParameterMode;

			public ParameterMode RotationParameterMode;

			private int m_padding1;

			private int m_padding2;

			[Range(0f, 5f)]
			public float PositionExponentialHalfLife;

			[Range(0f, 5f)]
			public float PositionOscillationHalfLife;

			[Range(0f, 10f)]
			public float PositionOscillationFrequency;

			[Range(0f, 1f)]
			public float PositionOscillationDampingRatio;

			[Range(0f, 10f)]
			public float MoveReactionMultiplier;

			[Range(0f, 10f)]
			public float LinearImpulseMultiplier;

			[Range(0f, 5f)]
			public float RotationExponentialHalfLife;

			[Range(0f, 5f)]
			public float RotationOscillationHalfLife;

			[Range(0f, 10f)]
			public float RotationOscillationFrequency;

			[Range(0f, 1f)]
			public float RotationOscillationDampingRatio;

			[Range(0f, 10f)]
			public float RotationReactionMultiplier;

			[Range(0f, 10f)]
			public float AngularImpulseMultiplier;

			public Vector3 RotationReactionUp;

			private float m_padding3;

			public InstanceData Instance;

			public static void Copy(ref Params from, ref Params to)
			{
				to.PositionParameterMode = from.PositionParameterMode;
				to.RotationParameterMode = from.RotationParameterMode;
				to.PositionExponentialHalfLife = from.PositionExponentialHalfLife;
				to.PositionOscillationHalfLife = from.PositionOscillationHalfLife;
				to.PositionOscillationFrequency = from.PositionOscillationFrequency;
				to.PositionOscillationDampingRatio = from.PositionOscillationDampingRatio;
				to.MoveReactionMultiplier = from.MoveReactionMultiplier;
				to.LinearImpulseMultiplier = from.LinearImpulseMultiplier;
				to.RotationExponentialHalfLife = from.RotationExponentialHalfLife;
				to.RotationOscillationHalfLife = from.RotationOscillationHalfLife;
				to.RotationOscillationFrequency = from.RotationOscillationFrequency;
				to.RotationOscillationDampingRatio = from.RotationOscillationDampingRatio;
				to.RotationReactionMultiplier = from.RotationReactionMultiplier;
				to.AngularImpulseMultiplier = from.AngularImpulseMultiplier;
			}

			public void Init()
			{
				InstanceID = -1;
				Bits.Clear();
				TwoDPlane = TwoDPlaneEnum.XZ;
				PositionParameterMode = ParameterMode.OscillationByHalfLife;
				RotationParameterMode = ParameterMode.OscillationByHalfLife;
				PositionExponentialHalfLife = 0.02f;
				PositionOscillationHalfLife = 0.1f;
				PositionOscillationFrequency = 5f;
				PositionOscillationDampingRatio = 0.5f;
				MoveReactionMultiplier = 1f;
				LinearImpulseMultiplier = 1f;
				RotationExponentialHalfLife = 0.02f;
				RotationOscillationHalfLife = 0.1f;
				RotationOscillationFrequency = 5f;
				RotationOscillationDampingRatio = 0.5f;
				RotationReactionMultiplier = 1f;
				AngularImpulseMultiplier = 1f;
			}

			public void AccumulateTarget(ref BoingEffector.Params effector)
			{
				Instance.AccumulateTarget(ref this, ref effector);
			}

			public void EndAccumulateTargets()
			{
				Instance.EndAccumulateTargets(ref this);
			}

			public void Execute(float dt)
			{
				Instance.Execute(ref this, dt);
			}

			public void Execute(BoingBones bones, float dt)
			{
				float maxLen = bones.MaxCollisionResolutionSpeed * dt;
				for (int i = 0; i < bones.BoneData.Length; i++)
				{
					BoingBones.Chain chain = bones.BoneChains[i];
					BoingBones.Bone[] array = bones.BoneData[i];
					if (array == null)
					{
						continue;
					}
					foreach (BoingBones.Bone bone in array)
					{
						if (chain.ParamsOverride == null)
						{
							bone.Instance.Execute(ref bones.Params, dt);
						}
						else
						{
							bone.Instance.Execute(ref chain.ParamsOverride.Params, dt);
						}
					}
					BoingBones.Bone bone2 = array[0];
					bone2.ScaleWs = (bone2.BlendedScaleLs = bone2.CachedScaleLs);
					bone2.UpdateBounds();
					chain.Bounds = bone2.Bounds;
					Vector3 position = bone2.Transform.position;
					for (int k = 1; k < array.Length; k++)
					{
						BoingBones.Bone bone3 = array[k];
						BoingBones.Bone bone4 = array[bone3.ParentIndex];
						Vector3 vector = bone4.Instance.PositionSpring.Value - bone3.Instance.PositionSpring.Value;
						Vector3 vector2 = VectorUtil.NormalizeSafe(vector, Vector3.zero);
						float magnitude = vector.magnitude;
						float num = magnitude - bone3.FullyStiffToParentLength;
						float num2 = bone3.LengthStiffnessT * num;
						bone3.Instance.PositionSpring.Value += num2 * vector2;
						Vector3 vector3 = Vector3.Project(bone3.Instance.PositionSpring.Velocity, vector2);
						bone3.Instance.PositionSpring.Velocity -= bone3.LengthStiffnessT * vector3;
						if (bone3.BendAngleCap < MathUtil.Pi - MathUtil.Epsilon)
						{
							Vector3 position2 = bone3.Transform.position;
							Vector3 vector4 = bone3.Instance.PositionSpring.Value - position;
							vector4 = VectorUtil.ClampBend(vector4, position2 - position, bone3.BendAngleCap);
							bone3.Instance.PositionSpring.Value = position + vector4;
						}
						if (bone3.SquashAndStretch > 0f)
						{
							float num3 = magnitude * MathUtil.InvSafe(bone3.FullyStiffToParentLength);
							Vector3 b = VectorUtil.ComponentWiseDivSafe(Mathf.Clamp(Mathf.Sqrt(1f / num3), 1f / Mathf.Max(1f, chain.MaxStretch), Mathf.Max(1f, chain.MaxSquash)) * Vector3.one, bone4.ScaleWs);
							bone3.BlendedScaleLs = Vector3.Lerp(Vector3.Lerp(bone3.CachedScaleLs, b, bone3.SquashAndStretch), bone3.CachedScaleLs, bone3.AnimationBlend);
						}
						else
						{
							bone3.BlendedScaleLs = bone3.CachedScaleLs;
						}
						bone3.ScaleWs = VectorUtil.ComponentWiseMult(bone4.ScaleWs, bone3.BlendedScaleLs);
						bone3.UpdateBounds();
						chain.Bounds.Encapsulate(bone3.Bounds);
					}
					chain.Bounds.Expand(0.2f * Vector3.one);
					BoingBones.Bone[] array2;
					if (chain.EnableBoingKitCollision)
					{
						BoingBoneCollider[] boingColliders = bones.BoingColliders;
						foreach (BoingBoneCollider boingBoneCollider in boingColliders)
						{
							if (boingBoneCollider == null || !chain.Bounds.Intersects(boingBoneCollider.Bounds))
							{
								continue;
							}
							array2 = array;
							foreach (BoingBones.Bone bone5 in array2)
							{
								if (bone5.Bounds.Intersects(boingBoneCollider.Bounds) && boingBoneCollider.Collide(bone5.Instance.PositionSpring.Value, bones.MinScale * bone5.CollisionRadius, out var push))
								{
									bone5.Instance.PositionSpring.Value += VectorUtil.ClampLength(push, 0f, maxLen);
									bone5.Instance.PositionSpring.Velocity -= Vector3.Project(bone5.Instance.PositionSpring.Velocity, push);
								}
							}
						}
					}
					SphereCollider sharedSphereCollider = BoingManager.SharedSphereCollider;
					if (chain.EnableUnityCollision && sharedSphereCollider != null)
					{
						sharedSphereCollider.enabled = true;
						Collider[] unityColliders = bones.UnityColliders;
						foreach (Collider collider in unityColliders)
						{
							if (collider == null || !chain.Bounds.Intersects(collider.bounds))
							{
								continue;
							}
							array2 = array;
							foreach (BoingBones.Bone bone6 in array2)
							{
								if (bone6.Bounds.Intersects(collider.bounds))
								{
									sharedSphereCollider.center = bone6.Instance.PositionSpring.Value;
									sharedSphereCollider.radius = bone6.CollisionRadius;
									if (Physics.ComputePenetration(sharedSphereCollider, Vector3.zero, Quaternion.identity, collider, collider.transform.position, collider.transform.rotation, out var direction, out var distance))
									{
										bone6.Instance.PositionSpring.Value += VectorUtil.ClampLength(direction * distance, 0f, maxLen);
										bone6.Instance.PositionSpring.Velocity -= Vector3.Project(bone6.Instance.PositionSpring.Velocity, direction);
									}
								}
							}
						}
						sharedSphereCollider.enabled = false;
					}
					if (!chain.EnableInterChainCollision)
					{
						continue;
					}
					array2 = array;
					foreach (BoingBones.Bone bone7 in array2)
					{
						for (int n = i + 1; n < bones.BoneData.Length; n++)
						{
							BoingBones.Chain chain2 = bones.BoneChains[n];
							BoingBones.Bone[] array3 = bones.BoneData[n];
							if (array3 == null || !chain2.EnableInterChainCollision || !chain.Bounds.Intersects(chain2.Bounds))
							{
								continue;
							}
							BoingBones.Bone[] array4 = array3;
							foreach (BoingBones.Bone bone8 in array4)
							{
								if (Collision.SphereSphere(bone7.Instance.PositionSpring.Value, bones.MinScale * bone7.CollisionRadius, bone8.Instance.PositionSpring.Value, bones.MinScale * bone8.CollisionRadius, out var push2))
								{
									push2 = VectorUtil.ClampLength(push2, 0f, maxLen);
									float num4 = bone8.CollisionRadius * MathUtil.InvSafe(bone7.CollisionRadius + bone8.CollisionRadius);
									bone7.Instance.PositionSpring.Value += num4 * push2;
									bone8.Instance.PositionSpring.Value -= (1f - num4) * push2;
									bone7.Instance.PositionSpring.Velocity -= Vector3.Project(bone7.Instance.PositionSpring.Velocity, push2);
									bone8.Instance.PositionSpring.Velocity -= Vector3.Project(bone8.Instance.PositionSpring.Velocity, push2);
								}
							}
						}
					}
				}
			}

			public void PullResults(BoingBones bones)
			{
				Instance.PullResults(bones);
			}

			private void SuppressWarnings()
			{
				m_padding0 = 0;
				m_padding1 = 0;
				m_padding2 = 0;
				m_padding3 = 0f;
				m_padding0 = m_padding1;
				m_padding1 = m_padding2;
				m_padding2 = (int)m_padding3;
				m_padding3 = m_padding0;
			}
		}

		public struct Output
		{
			public static readonly int Stride = 16 + Vector3Spring.Stride + QuaternionSpring.Stride;

			public int InstanceID;

			public int m_padding0;

			public int m_padding1;

			public int m_padding2;

			public Vector3Spring PositionSpring;

			public QuaternionSpring RotationSpring;

			public Output(int instanceID, ref Vector3Spring positionSpring, ref QuaternionSpring rotationSpring)
			{
				InstanceID = instanceID;
				m_padding0 = (m_padding1 = (m_padding2 = 0));
				PositionSpring = positionSpring;
				RotationSpring = rotationSpring;
			}

			public void GatherOutput(Dictionary<int, BoingBehavior> behaviorMap)
			{
				if (behaviorMap.TryGetValue(InstanceID, out var value))
				{
					value.GatherOutput(ref this);
				}
			}

			public void GatherOutput(Dictionary<int, BoingReactor> reactorMap)
			{
				if (reactorMap.TryGetValue(InstanceID, out var value))
				{
					value.GatherOutput(ref this);
				}
			}

			private void SuppressWarnings()
			{
				m_padding0 = 0;
				m_padding1 = 0;
				m_padding2 = 0;
				m_padding0 = m_padding1;
				m_padding1 = m_padding2;
				m_padding2 = m_padding0;
			}
		}

		internal static Vector3 ComputeTranslationalResults(Transform t, Vector3 src, Vector3 dst, BoingBehavior b)
		{
			if (!b.LockTranslationX && !b.LockTranslationY && !b.LockTranslationZ)
			{
				return dst;
			}
			Vector3 vector = dst - src;
			switch (b.TranslationLockSpace)
			{
			case BoingManager.TranslationLockSpace.Global:
				if (b.LockTranslationX)
				{
					vector.x = 0f;
				}
				if (b.LockTranslationY)
				{
					vector.y = 0f;
				}
				if (b.LockTranslationZ)
				{
					vector.z = 0f;
				}
				break;
			case BoingManager.TranslationLockSpace.Local:
				if (b.LockTranslationX)
				{
					vector -= Vector3.Project(vector, t.right);
				}
				if (b.LockTranslationY)
				{
					vector -= Vector3.Project(vector, t.up);
				}
				if (b.LockTranslationZ)
				{
					vector -= Vector3.Project(vector, t.forward);
				}
				break;
			}
			return src + vector;
		}
	}
	public static class BoingWorkAsynchronous
	{
		private struct BehaviorJob : IJobParallelFor
		{
			public NativeArray<BoingWork.Params> Params;

			public NativeArray<BoingWork.Output> Output;

			public float DeltaTime;

			public float FixedDeltaTime;

			public int NumFixedUpdateIterations;

			public bool LateUpdateTiming;

			public void Execute(int index)
			{
				BoingWork.Params @params = Params[index];
				if (LateUpdateTiming != @params.Bits.IsBitSet(BoingWork.ReactorFlags.LateUpdateTiming))
				{
					return;
				}
				if (@params.Bits.IsBitSet(BoingWork.ReactorFlags.FixedUpdate))
				{
					for (int i = 0; i < NumFixedUpdateIterations; i++)
					{
						@params.Execute(FixedDeltaTime);
					}
				}
				else
				{
					@params.Execute(BoingManager.DeltaTime);
				}
				Output[index] = new BoingWork.Output(@params.InstanceID, ref @params.Instance.PositionSpring, ref @params.Instance.RotationSpring);
			}
		}

		private struct ReactorJob : IJobParallelFor
		{
			[Unity.Collections.ReadOnly]
			public NativeArray<BoingEffector.Params> Effectors;

			public NativeArray<BoingWork.Params> Params;

			public NativeArray<BoingWork.Output> Output;

			public float DeltaTime;

			public float FixedDeltaTime;

			public int NumFixedUpdateIterations;

			public bool LateUpdateTiming;

			public void Execute(int index)
			{
				BoingWork.Params @params = Params[index];
				if (LateUpdateTiming != @params.Bits.IsBitSet(BoingWork.ReactorFlags.LateUpdateTiming))
				{
					return;
				}
				int i = 0;
				for (int length = Effectors.Length; i < length; i++)
				{
					BoingEffector.Params effector = Effectors[i];
					@params.AccumulateTarget(ref effector);
				}
				@params.EndAccumulateTargets();
				if (@params.Bits.IsBitSet(BoingWork.ReactorFlags.FixedUpdate))
				{
					for (int j = 0; j < NumFixedUpdateIterations; j++)
					{
						@params.Execute(FixedDeltaTime);
					}
				}
				else
				{
					@params.Execute(BoingManager.DeltaTime);
				}
				Output[index] = new BoingWork.Output(@params.InstanceID, ref @params.Instance.PositionSpring, ref @params.Instance.RotationSpring);
			}
		}

		private static bool s_behaviorJobNeedsGather;

		private static JobHandle s_hBehaviorJob;

		private static NativeArray<BoingWork.Params> s_aBehaviorParams;

		private static NativeArray<BoingWork.Output> s_aBehaviorOutput;

		private static bool s_reactorJobNeedsGather;

		private static JobHandle s_hReactorJob;

		private static NativeArray<BoingEffector.Params> s_aEffectors;

		private static NativeArray<BoingWork.Params> s_aReactorExecParams;

		private static NativeArray<BoingWork.Output> s_aReactorExecOutput;

		internal static void PostUnregisterBehaviorCleanUp()
		{
			if (s_behaviorJobNeedsGather)
			{
				s_hBehaviorJob.Complete();
				s_aBehaviorParams.Dispose();
				s_aBehaviorOutput.Dispose();
				s_behaviorJobNeedsGather = false;
			}
		}

		internal static void PostUnregisterEffectorReactorCleanUp()
		{
			if (s_reactorJobNeedsGather)
			{
				s_hReactorJob.Complete();
				s_aEffectors.Dispose();
				s_aReactorExecParams.Dispose();
				s_aReactorExecOutput.Dispose();
				s_reactorJobNeedsGather = false;
			}
		}

		internal static void ExecuteBehaviors(Dictionary<int, BoingBehavior> behaviorMap, BoingManager.UpdateTiming updateTiming)
		{
			if (updateTiming == BoingManager.UpdateTiming.Early && s_behaviorJobNeedsGather)
			{
				s_hBehaviorJob.Complete();
				int i = 0;
				for (int length = s_aBehaviorParams.Length; i < length; i++)
				{
					s_aBehaviorOutput[i].GatherOutput(behaviorMap);
				}
				s_aBehaviorParams.Dispose();
				s_aBehaviorOutput.Dispose();
				s_behaviorJobNeedsGather = false;
			}
			if (updateTiming != BoingManager.UpdateTiming.Late)
			{
				return;
			}
			s_aBehaviorParams = new NativeArray<BoingWork.Params>(behaviorMap.Count, Allocator.TempJob, NativeArrayOptions.UninitializedMemory);
			s_aBehaviorOutput = new NativeArray<BoingWork.Output>(behaviorMap.Count, Allocator.TempJob, NativeArrayOptions.UninitializedMemory);
			int num = 0;
			foreach (KeyValuePair<int, BoingBehavior> item in behaviorMap)
			{
				BoingBehavior value = item.Value;
				value.PrepareExecute();
				s_aBehaviorParams[num++] = value.Params;
			}
			_ = Time.deltaTime;
			BehaviorJob jobData = default(BehaviorJob);
			jobData.Params = s_aBehaviorParams;
			jobData.Output = s_aBehaviorOutput;
			jobData.DeltaTime = BoingManager.DeltaTime;
			jobData.FixedDeltaTime = BoingManager.FixedDeltaTime;
			jobData.NumFixedUpdateIterations = BoingManager.NumFixedUpdateIterations;
			jobData.LateUpdateTiming = updateTiming == BoingManager.UpdateTiming.Late;
			s_hBehaviorJob = jobData.Schedule(s_aBehaviorParams.Length, 32);
			JobHandle.ScheduleBatchedJobs();
			s_behaviorJobNeedsGather = true;
		}

		internal static void ExecuteReactors(Dictionary<int, BoingEffector> effectorMap, Dictionary<int, BoingReactor> reactorMap, Dictionary<int, BoingReactorField> fieldMap, Dictionary<int, BoingReactorFieldCPUSampler> cpuSamplerMap, BoingManager.UpdateTiming updateTiming)
		{
			float deltaTime = Time.deltaTime;
			if (updateTiming == BoingManager.UpdateTiming.Early && s_reactorJobNeedsGather)
			{
				if (s_aEffectors.Length > 0 && s_aReactorExecParams.Length > 0)
				{
					s_hReactorJob.Complete();
					int i = 0;
					for (int length = s_aReactorExecParams.Length; i < length; i++)
					{
						s_aReactorExecOutput[i].GatherOutput(reactorMap);
					}
				}
				s_aEffectors.Dispose();
				s_aReactorExecParams.Dispose();
				s_aReactorExecOutput.Dispose();
				s_reactorJobNeedsGather = false;
			}
			if (updateTiming != BoingManager.UpdateTiming.Late)
			{
				return;
			}
			s_aEffectors = new NativeArray<BoingEffector.Params>(effectorMap.Count, Allocator.TempJob, NativeArrayOptions.UninitializedMemory);
			s_aReactorExecParams = new NativeArray<BoingWork.Params>(reactorMap.Count, Allocator.TempJob, NativeArrayOptions.UninitializedMemory);
			s_aReactorExecOutput = new NativeArray<BoingWork.Output>(reactorMap.Count, Allocator.TempJob, NativeArrayOptions.UninitializedMemory);
			int num = 0;
			BoingEffector.Params value = default(BoingEffector.Params);
			foreach (KeyValuePair<int, BoingEffector> item in effectorMap)
			{
				_ = item.Value;
				value.Fill(item.Value);
				s_aEffectors[num++] = value;
			}
			int num2 = 0;
			foreach (KeyValuePair<int, BoingReactor> item2 in reactorMap)
			{
				BoingReactor value2 = item2.Value;
				value2.PrepareExecute();
				s_aReactorExecParams[num2++] = value2.Params;
			}
			if (s_aEffectors.Length > 0 && s_aReactorExecParams.Length > 0)
			{
				ReactorJob jobData = default(ReactorJob);
				jobData.Effectors = s_aEffectors;
				jobData.Params = s_aReactorExecParams;
				jobData.Output = s_aReactorExecOutput;
				jobData.DeltaTime = deltaTime;
				jobData.FixedDeltaTime = BoingManager.FixedDeltaTime;
				jobData.NumFixedUpdateIterations = BoingManager.NumFixedUpdateIterations;
				jobData.LateUpdateTiming = updateTiming == BoingManager.UpdateTiming.Late;
				s_hReactorJob = jobData.Schedule(s_aReactorExecParams.Length, 32);
				JobHandle.ScheduleBatchedJobs();
			}
			foreach (KeyValuePair<int, BoingReactorField> item3 in fieldMap)
			{
				BoingReactorField value3 = item3.Value;
				if (value3.HardwareMode == BoingReactorField.HardwareModeEnum.CPU)
				{
					value3.ExecuteCpu(deltaTime);
				}
			}
			foreach (KeyValuePair<int, BoingReactorFieldCPUSampler> item4 in cpuSamplerMap)
			{
				_ = item4.Value;
			}
			s_reactorJobNeedsGather = true;
		}

		internal static void ExecuteBones(BoingEffector.Params[] aEffectorParams, Dictionary<int, BoingBones> bonesMap, BoingManager.UpdateTiming updateTiming)
		{
			foreach (KeyValuePair<int, BoingBones> item in bonesMap)
			{
				BoingBones value = item.Value;
				if (value.UpdateTiming != updateTiming)
				{
					continue;
				}
				value.PrepareExecute();
				for (int i = 0; i < aEffectorParams.Length; i++)
				{
					value.AccumulateTarget(ref aEffectorParams[i]);
				}
				value.EndAccumulateTargets();
				switch (value.UpdateMode)
				{
				case BoingManager.UpdateMode.Update:
					value.Params.Execute(value, BoingManager.DeltaTime);
					break;
				case BoingManager.UpdateMode.FixedUpdate:
				{
					for (int j = 0; j < BoingManager.NumFixedUpdateIterations; j++)
					{
						value.Params.Execute(value, BoingManager.FixedDeltaTime);
					}
					break;
				}
				}
			}
		}

		internal static void PullBonesResults(BoingEffector.Params[] aEffectorParams, Dictionary<int, BoingBones> bonesMap, BoingManager.UpdateTiming updateTiming)
		{
			foreach (KeyValuePair<int, BoingBones> item in bonesMap)
			{
				BoingBones value = item.Value;
				if (value.UpdateTiming == updateTiming)
				{
					value.Params.PullResults(value);
				}
			}
		}
	}
	internal static class BoingWorkSynchronous
	{
		internal static void ExecuteBehaviors(Dictionary<int, BoingBehavior> behaviorMap, BoingManager.UpdateTiming updateTiming)
		{
			float deltaTime = Time.deltaTime;
			foreach (KeyValuePair<int, BoingBehavior> item in behaviorMap)
			{
				BoingBehavior value = item.Value;
				if (value.UpdateTiming != updateTiming)
				{
					continue;
				}
				value.PrepareExecute();
				switch (value.UpdateMode)
				{
				case BoingManager.UpdateMode.Update:
					value.Execute(deltaTime);
					break;
				case BoingManager.UpdateMode.FixedUpdate:
				{
					for (int i = 0; i < BoingManager.NumFixedUpdateIterations; i++)
					{
						value.Execute(BoingManager.FixedDeltaTime);
					}
					break;
				}
				}
			}
		}

		internal static void ExecuteReactors(BoingEffector.Params[] aEffectorParams, Dictionary<int, BoingReactor> reactorMap, Dictionary<int, BoingReactorField> fieldMap, Dictionary<int, BoingReactorFieldCPUSampler> cpuSamplerMap, BoingManager.UpdateTiming updateTiming)
		{
			float deltaTime = Time.deltaTime;
			foreach (KeyValuePair<int, BoingReactor> item in reactorMap)
			{
				BoingReactor value = item.Value;
				if (value.UpdateTiming != updateTiming)
				{
					continue;
				}
				value.PrepareExecute();
				for (int i = 0; i < aEffectorParams.Length; i++)
				{
					value.Params.AccumulateTarget(ref aEffectorParams[i]);
				}
				value.Params.EndAccumulateTargets();
				switch (value.UpdateMode)
				{
				case BoingManager.UpdateMode.Update:
					value.Execute(deltaTime);
					break;
				case BoingManager.UpdateMode.FixedUpdate:
				{
					for (int j = 0; j < BoingManager.NumFixedUpdateIterations; j++)
					{
						value.Execute(BoingManager.FixedDeltaTime);
					}
					break;
				}
				}
			}
			foreach (KeyValuePair<int, BoingReactorField> item2 in fieldMap)
			{
				BoingReactorField value2 = item2.Value;
				if (value2.HardwareMode == BoingReactorField.HardwareModeEnum.CPU)
				{
					value2.ExecuteCpu(deltaTime);
				}
			}
			foreach (KeyValuePair<int, BoingReactorFieldCPUSampler> item3 in cpuSamplerMap)
			{
				_ = item3.Value;
			}
		}

		internal static void ExecuteBones(BoingEffector.Params[] aEffectorParams, Dictionary<int, BoingBones> bonesMap, BoingManager.UpdateTiming updateTiming)
		{
			foreach (KeyValuePair<int, BoingBones> item in bonesMap)
			{
				BoingBones value = item.Value;
				if (value.UpdateTiming != updateTiming)
				{
					continue;
				}
				value.PrepareExecute();
				for (int i = 0; i < aEffectorParams.Length; i++)
				{
					value.AccumulateTarget(ref aEffectorParams[i]);
				}
				value.EndAccumulateTargets();
				switch (value.UpdateMode)
				{
				case BoingManager.UpdateMode.Update:
					value.Params.Execute(value, BoingManager.DeltaTime);
					break;
				case BoingManager.UpdateMode.FixedUpdate:
				{
					for (int j = 0; j < BoingManager.NumFixedUpdateIterations; j++)
					{
						value.Params.Execute(value, BoingManager.FixedDeltaTime);
					}
					break;
				}
				}
			}
		}

		internal static void PullBonesResults(BoingEffector.Params[] aEffectorParams, Dictionary<int, BoingBones> bonesMap, BoingManager.UpdateTiming updateTiming)
		{
			foreach (KeyValuePair<int, BoingBones> item in bonesMap)
			{
				BoingBones value = item.Value;
				if (value.UpdateTiming == updateTiming)
				{
					value.Params.PullResults(value);
				}
			}
		}
	}
	[CreateAssetMenu(fileName = "BoingParams", menuName = "Boing Kit/Shared Boing Params", order = 550)]
	public class SharedBoingParams : ScriptableObject
	{
		public BoingWork.Params Params;

		public SharedBoingParams()
		{
			Params.Init();
		}
	}
	public enum ParameterMode
	{
		Exponential,
		OscillationByHalfLife,
		OscillationByDampingRatio
	}
	public enum TwoDPlaneEnum
	{
		XY,
		XZ,
		YZ
	}
	public struct Aabb
	{
		public Vector3 Min;

		public Vector3 Max;

		public float MinX
		{
			get
			{
				return Min.x;
			}
			set
			{
				Min.x = value;
			}
		}

		public float MinY
		{
			get
			{
				return Min.y;
			}
			set
			{
				Min.y = value;
			}
		}

		public float MinZ
		{
			get
			{
				return Min.z;
			}
			set
			{
				Min.z = value;
			}
		}

		public float MaxX
		{
			get
			{
				return Max.x;
			}
			set
			{
				Max.x = value;
			}
		}

		public float MaxY
		{
			get
			{
				return Max.y;
			}
			set
			{
				Max.y = value;
			}
		}

		public float MaxZ
		{
			get
			{
				return Max.z;
			}
			set
			{
				Max.z = value;
			}
		}

		public Vector3 Center => 0.5f * (Min + Max);

		public Vector3 Size
		{
			get
			{
				Vector3 result = Max - Min;
				result.x = Mathf.Max(0f, result.x);
				result.y = Mathf.Max(0f, result.y);
				result.z = Mathf.Max(0f, result.z);
				return result;
			}
		}

		public static Aabb Empty => new Aabb(new Vector3(float.MaxValue, float.MaxValue, float.MaxValue), new Vector3(float.MinValue, float.MinValue, float.MinValue));

		public static Aabb FromPoints(params Vector3[] aPoint)
		{
			Aabb empty = Empty;
			int i = 0;
			for (int num = aPoint.Length; i < num; i++)
			{
				empty.Include(aPoint[i]);
			}
			return empty;
		}

		public Aabb(Vector3 min, Vector3 max)
		{
			Min = min;
			Max = max;
		}

		public void Include(Vector3 p)
		{
			MinX = Mathf.Min(MinX, p.x);
			MinY = Mathf.Min(MinY, p.y);
			MinZ = Mathf.Min(MinZ, p.z);
			MaxX = Mathf.Max(MaxX, p.x);
			MaxY = Mathf.Max(MaxY, p.y);
			MaxZ = Mathf.Max(MaxZ, p.z);
		}

		public bool Contains(Vector3 p)
		{
			if (MinX <= p.x && MinY <= p.y && MinZ <= p.z && MaxX >= p.x && MaxY >= p.y)
			{
				return MaxZ >= p.z;
			}
			return false;
		}

		public bool ContainsX(Vector3 p)
		{
			if (MinX <= p.x)
			{
				return MaxX >= p.x;
			}
			return false;
		}

		public bool ContainsY(Vector3 p)
		{
			if (MinY <= p.y)
			{
				return MaxY >= p.y;
			}
			return false;
		}

		public bool ContainsZ(Vector3 p)
		{
			if (MinZ <= p.z)
			{
				return MaxZ >= p.z;
			}
			return false;
		}

		public bool Intersects(Aabb rhs)
		{
			if (MinX <= rhs.MaxX && MinY <= rhs.MaxY && MinZ <= rhs.MaxZ && MaxX >= rhs.MinX && MaxY >= rhs.MinY)
			{
				return MaxZ >= rhs.MinZ;
			}
			return false;
		}

		public bool Intersects(ref BoingEffector.Params effector)
		{
			if (!effector.Bits.IsBitSet(BoingWork.EffectorFlags.ContinuousMotion))
			{
				return Intersects(FromPoints(effector.CurrPosition).Expand(effector.Radius));
			}
			return Intersects(FromPoints(effector.PrevPosition, effector.CurrPosition).Expand(effector.Radius));
		}

		public Aabb Expand(float amount)
		{
			MinX -= amount;
			MinY -= amount;
			MinZ -= amount;
			MaxX += amount;
			MaxY += amount;
			MaxZ += amount;
			return this;
		}
	}
	[Serializable]
	public struct Bits32
	{
		[SerializeField]
		private int m_bits;

		public int IntValue => m_bits;

		public Bits32(int bits = 0)
		{
			m_bits = bits;
		}

		public void Clear()
		{
			m_bits = 0;
		}

		public void SetBit(int index, bool value)
		{
			if (value)
			{
				m_bits |= 1 << index;
			}
			else
			{
				m_bits &= ~(1 << index);
			}
		}

		public void SetBit(Enum index, bool value)
		{
			SetBit(Convert.ToInt32(index), value);
		}

		public bool IsBitSet(int index)
		{
			return (m_bits & (1 << index)) != 0;
		}

		public bool IsBitSet(Enum index)
		{
			return IsBitSet(Convert.ToInt32(index));
		}
	}
	public struct BitArray
	{
		private int[] m_aBlock;

		public int[] Blocks => m_aBlock;

		private static int GetBlockIndex(int index)
		{
			return index / 4;
		}

		private static int GetSubIndex(int index)
		{
			return index % 4;
		}

		private static void SetBit(int index, bool value, int[] blocks)
		{
			int blockIndex = GetBlockIndex(index);
			int subIndex = GetSubIndex(index);
			if (value)
			{
				blocks[blockIndex] |= 1 << subIndex;
			}
			else
			{
				blocks[blockIndex] &= ~(1 << subIndex);
			}
		}

		private static bool IsBitSet(int index, int[] blocks)
		{
			return (blocks[GetBlockIndex(index)] & (1 << GetSubIndex(index))) != 0;
		}

		public BitArray(int capacity)
		{
			int num = (capacity + 4 - 1) / 4;
			m_aBlock = new int[num];
			Clear();
		}

		public void Resize(int capacity)
		{
			int num = (capacity + 4 - 1) / 4;
			if (num > m_aBlock.Length)
			{
				int[] array = new int[num];
				int i = 0;
				for (int num2 = m_aBlock.Length; i < num2; i++)
				{
					array[i] = m_aBlock[i];
				}
				m_aBlock = array;
			}
		}

		public void Clear()
		{
			SetAllBits(value: false);
		}

		public void SetAllBits(bool value)
		{
			int num = ((!value) ? 1 : (-1));
			int i = 0;
			for (int num2 = m_aBlock.Length; i < num2; i++)
			{
				m_aBlock[i] = num;
			}
		}

		public void SetBit(int index, bool value)
		{
			SetBit(index, value, m_aBlock);
		}

		public bool IsBitSet(int index)
		{
			return IsBitSet(index, m_aBlock);
		}
	}
	public class Collision
	{
		public static bool SphereSphere(Vector3 centerA, float radiusA, Vector3 centerB, float radiusB, out Vector3 push)
		{
			push = Vector3.zero;
			Vector3 vector = centerA - centerB;
			float sqrMagnitude = vector.sqrMagnitude;
			float num = radiusA + radiusB;
			if (sqrMagnitude >= num * num)
			{
				return false;
			}
			float num2 = Mathf.Sqrt(sqrMagnitude);
			push = VectorUtil.NormalizeSafe(vector, Vector3.zero) * (num - num2);
			return true;
		}

		public static bool SphereSphereInverse(Vector3 centerA, float radiusA, Vector3 centerB, float radiusB, out Vector3 push)
		{
			push = Vector3.zero;
			Vector3 vector = centerB - centerA;
			float sqrMagnitude = vector.sqrMagnitude;
			float num = radiusB - radiusA;
			if (sqrMagnitude <= num * num)
			{
				return false;
			}
			float num2 = Mathf.Sqrt(sqrMagnitude);
			push = VectorUtil.NormalizeSafe(vector, Vector3.zero) * (num2 - num);
			return true;
		}

		public static bool SphereCapsule(Vector3 centerA, float radiusA, Vector3 headB, Vector3 tailB, float radiusB, out Vector3 push)
		{
			push = Vector3.zero;
			Vector3 vector = tailB - headB;
			float sqrMagnitude = vector.sqrMagnitude;
			if (sqrMagnitude < MathUtil.Epsilon)
			{
				return SphereSphereInverse(centerA, radiusA, 0.5f * (headB + tailB), radiusB, out push);
			}
			float num = 1f / Mathf.Sqrt(sqrMagnitude);
			Vector3 rhs = vector * num;
			float t = Mathf.Clamp01(Vector3.Dot(centerA - headB, rhs) * num);
			Vector3 centerB = Vector3.Lerp(headB, tailB, t);
			return SphereSphere(centerA, radiusA, centerB, radiusB, out push);
		}

		public static bool SphereCapsuleInverse(Vector3 centerA, float radiusA, Vector3 headB, Vector3 tailB, float radiusB, out Vector3 push)
		{
			push = Vector3.zero;
			Vector3 vector = tailB - headB;
			float sqrMagnitude = vector.sqrMagnitude;
			if (sqrMagnitude < MathUtil.Epsilon)
			{
				return SphereSphereInverse(centerA, radiusA, 0.5f * (headB + tailB), radiusB, out push);
			}
			float num = 1f / Mathf.Sqrt(sqrMagnitude);
			Vector3 rhs = vector * num;
			float t = Mathf.Clamp01(Vector3.Dot(centerA - headB, rhs) * num);
			Vector3 centerB = Vector3.Lerp(headB, tailB, t);
			return SphereSphereInverse(centerA, radiusA, centerB, radiusB, out push);
		}

		public static bool SphereBox(Vector3 centerOffsetA, float radiusA, Vector3 halfExtentB, out Vector3 push)
		{
			push = Vector3.zero;
			Vector3 vector = new Vector3(Mathf.Clamp(centerOffsetA.x, 0f - halfExtentB.x, halfExtentB.x), Mathf.Clamp(centerOffsetA.y, 0f - halfExtentB.y, halfExtentB.y), Mathf.Clamp(centerOffsetA.z, 0f - halfExtentB.z, halfExtentB.z));
			Vector3 vector2 = centerOffsetA - vector;
			float sqrMagnitude = vector2.sqrMagnitude;
			if (sqrMagnitude > radiusA * radiusA)
			{
				return false;
			}
			switch (((!(centerOffsetA.x < 0f - halfExtentB.x) && !(centerOffsetA.x > halfExtentB.x)) ? 1 : 0) + ((!(centerOffsetA.y < 0f - halfExtentB.y) && !(centerOffsetA.y > halfExtentB.y)) ? 1 : 0) + ((!(centerOffsetA.z < 0f - halfExtentB.z) && !(centerOffsetA.z > halfExtentB.z)) ? 1 : 0))
			{
			case 0:
			case 1:
			case 2:
				push = VectorUtil.NormalizeSafe(vector2, Vector3.right) * (radiusA - Mathf.Sqrt(sqrMagnitude));
				break;
			case 3:
			{
				Vector3 vector3 = new Vector3(halfExtentB.x - Mathf.Abs(centerOffsetA.x) + radiusA, halfExtentB.y - Mathf.Abs(centerOffsetA.y) + radiusA, halfExtentB.z - Mathf.Abs(centerOffsetA.z) + radiusA);
				if (vector3.x < vector3.y)
				{
					if (vector3.x < vector3.z)
					{
						push = new Vector3(Mathf.Sign(centerOffsetA.x) * vector3.x, 0f, 0f);
					}
					else
					{
						push = new Vector3(0f, 0f, Mathf.Sign(centerOffsetA.z) * vector3.z);
					}
				}
				else if (vector3.y < vector3.z)
				{
					push = new Vector3(0f, Mathf.Sign(centerOffsetA.y) * vector3.y, 0f);
				}
				else
				{
					push = new Vector3(0f, 0f, Mathf.Sign(centerOffsetA.z) * vector3.z);
				}
				break;
			}
			}
			return true;
		}

		public static bool SphereBoxInverse(Vector3 centerOffsetA, float radiusA, Vector3 halfExtentB, out Vector3 push)
		{
			push = Vector3.zero;
			return false;
		}
	}
	[AttributeUsage(AttributeTargets.Field)]
	public class ConditionalFieldAttribute : PropertyAttribute
	{
		public string PropertyToCheck;

		public object CompareValue;

		public object CompareValue2;

		public object CompareValue3;

		public object CompareValue4;

		public object CompareValue5;

		public object CompareValue6;

		public string Label;

		public string Tooltip;

		public float Min;

		public float Max;

		public bool ShowRange => Min != Max;

		public ConditionalFieldAttribute(string propertyToCheck = null, object compareValue = null, object compareValue2 = null, object compareValue3 = null, object compareValue4 = null, object compareValue5 = null, object compareValue6 = null)
		{
			PropertyToCheck = propertyToCheck;
			CompareValue = compareValue;
			CompareValue2 = compareValue2;
			CompareValue3 = compareValue3;
			CompareValue4 = compareValue4;
			CompareValue5 = compareValue5;
			CompareValue6 = compareValue6;
			Label = "";
			Tooltip = "";
			Min = 0f;
			Max = 0f;
		}
	}
	public class MathUtil
	{
		public static readonly float Pi = (float)Math.PI;

		public static readonly float TwoPi = (float)Math.PI * 2f;

		public static readonly float HalfPi = (float)Math.PI / 2f;

		public static readonly float QuaterPi = (float)Math.PI / 4f;

		public static readonly float SixthPi = (float)Math.PI / 6f;

		public static readonly float Sqrt2 = Mathf.Sqrt(2f);

		public static readonly float Sqrt2Inv = 1f / Mathf.Sqrt(2f);

		public static readonly float Sqrt3 = Mathf.Sqrt(3f);

		public static readonly float Sqrt3Inv = 1f / Mathf.Sqrt(3f);

		public static readonly float Epsilon = 1E-06f;

		public static readonly float Rad2Deg = 180f / (float)Math.PI;

		public static readonly float Deg2Rad = (float)Math.PI / 180f;

		public static float AsinSafe(float x)
		{
			return Mathf.Asin(Mathf.Clamp(x, -1f, 1f));
		}

		public static float AcosSafe(float x)
		{
			return Mathf.Acos(Mathf.Clamp(x, -1f, 1f));
		}

		public static float InvSafe(float x)
		{
			return 1f / Mathf.Max(Epsilon, x);
		}

		public static float PointLineDist(Vector2 point, Vector2 linePos, Vector2 lineDir)
		{
			Vector2 vector = point - linePos;
			return (vector - Vector2.Dot(vector, lineDir) * lineDir).magnitude;
		}

		public static float PointSegmentDist(Vector2 point, Vector2 segmentPosA, Vector2 segmentPosB)
		{
			Vector2 vector = segmentPosB - segmentPosA;
			float num = 1f / vector.magnitude;
			Vector2 rhs = vector * num;
			float value = Vector2.Dot(point - segmentPosA, rhs) * num;
			return (segmentPosA + Mathf.Clamp(value, 0f, 1f) * vector - point).magnitude;
		}

		public static float Seek(float current, float target, float maxDelta)
		{
			float f = target - current;
			f = Mathf.Sign(f) * Mathf.Min(maxDelta, Mathf.Abs(f));
			return current + f;
		}

		public static Vector2 Seek(Vector2 current, Vector2 target, float maxDelta)
		{
			Vector2 vector = target - current;
			float magnitude = vector.magnitude;
			if (magnitude < Epsilon)
			{
				return target;
			}
			vector = Mathf.Min(maxDelta, magnitude) * vector.normalized;
			return current + vector;
		}

		public static float Remainder(float a, float b)
		{
			return a - a / b * b;
		}

		public static int Remainder(int a, int b)
		{
			return a - a / b * b;
		}

		public static float Modulo(float a, float b)
		{
			return Mathf.Repeat(a, b);
		}

		public static int Modulo(int a, int b)
		{
			int num = a % b;
			if (num < 0)
			{
				return num + b;
			}
			return num;
		}
	}
	public class QuaternionUtil
	{
		public enum SterpMode
		{
			Nlerp,
			Slerp
		}

		public static float Magnitude(Quaternion q)
		{
			return Mathf.Sqrt(q.x * q.x + q.y * q.y + q.z * q.z + q.w * q.w);
		}

		public static float MagnitudeSqr(Quaternion q)
		{
			return q.x * q.x + q.y * q.y + q.z * q.z + q.w * q.w;
		}

		public static Quaternion Normalize(Quaternion q)
		{
			float num = 1f / Magnitude(q);
			return new Quaternion(num * q.x, num * q.y, num * q.z, num * q.w);
		}

		public static Quaternion AxisAngle(Vector3 axis, float angle)
		{
			float f = 0.5f * angle;
			float num = Mathf.Sin(f);
			float w = Mathf.Cos(f);
			return new Quaternion(num * axis.x, num * axis.y, num * axis.z, w);
		}

		public static Vector3 GetAxis(Quaternion q)
		{
			Vector3 vector = new Vector3(q.x, q.y, q.z);
			float magnitude = vector.magnitude;
			if (magnitude < MathUtil.Epsilon)
			{
				return Vector3.left;
			}
			return vector / magnitude;
		}

		public static float GetAngle(Quaternion q)
		{
			return 2f * Mathf.Acos(Mathf.Clamp(q.w, -1f, 1f));
		}

		public static Quaternion FromAngularVector(Vector3 v)
		{
			float magnitude = v.magnitude;
			if (magnitude < MathUtil.Epsilon)
			{
				return Quaternion.identity;
			}
			v /= magnitude;
			float f = 0.5f * magnitude;
			float num = Mathf.Sin(f);
			float w = Mathf.Cos(f);
			return new Quaternion(num * v.x, num * v.y, num * v.z, w);
		}

		public static Vector3 ToAngularVector(Quaternion q)
		{
			Vector3 axis = GetAxis(q);
			return GetAngle(q) * axis;
		}

		public static Quaternion Pow(Quaternion q, float exp)
		{
			Vector3 axis = GetAxis(q);
			float angle = GetAngle(q) * exp;
			return AxisAngle(axis, angle);
		}

		public static Quaternion Integrate(Quaternion q, Quaternion v, float dt)
		{
			return Pow(v, dt) * q;
		}

		public static Quaternion Integrate(Quaternion q, Vector3 omega, float dt)
		{
			omega *= 0.5f;
			Quaternion quaternion = new Quaternion(omega.x, omega.y, omega.z, 0f) * q;
			return Normalize(new Quaternion(q.x + quaternion.x * dt, q.y + quaternion.y * dt, q.z + quaternion.z * dt, q.w + quaternion.w * dt));
		}

		public static Vector4 ToVector4(Quaternion q)
		{
			return new Vector4(q.x, q.y, q.z, q.w);
		}

		public static Quaternion FromVector4(Vector4 v, bool normalize = true)
		{
			if (normalize)
			{
				float sqrMagnitude = v.sqrMagnitude;
				if (sqrMagnitude < MathUtil.Epsilon)
				{
					return Quaternion.identity;
				}
				v /= Mathf.Sqrt(sqrMagnitude);
			}
			return new Quaternion(v.x, v.y, v.z, v.w);
		}

		public static void DecomposeSwingTwist(Quaternion q, Vector3 twistAxis, out Quaternion swing, out Quaternion twist)
		{
			Vector3 vector = new Vector3(q.x, q.y, q.z);
			if (vector.sqrMagnitude < MathUtil.Epsilon)
			{
				Vector3 vector2 = q * twistAxis;
				Vector3 axis = Vector3.Cross(twistAxis, vector2);
				if (axis.sqrMagnitude > MathUtil.Epsilon)
				{
					float angle = Vector3.Angle(twistAxis, vector2);
					swing = Quaternion.AngleAxis(angle, axis);
				}
				else
				{
					swing = Quaternion.identity;
				}
				twist = Quaternion.AngleAxis(180f, twistAxis);
			}
			else
			{
				Vector3 vector3 = Vector3.Project(vector, twistAxis);
				twist = new Quaternion(vector3.x, vector3.y, vector3.z, q.w);
				twist = Normalize(twist);
				swing = q * Quaternion.Inverse(twist);
			}
		}

		public static Quaternion Sterp(Quaternion a, Quaternion b, Vector3 twistAxis, float t, SterpMode mode = SterpMode.Slerp)
		{
			Quaternion swing;
			Quaternion twist;
			return Sterp(a, b, twistAxis, t, out swing, out twist, mode);
		}

		public static Quaternion Sterp(Quaternion a, Quaternion b, Vector3 twistAxis, float t, out Quaternion swing, out Quaternion twist, SterpMode mode = SterpMode.Slerp)
		{
			return Sterp(a, b, twistAxis, t, t, out swing, out twist, mode);
		}

		public static Quaternion Sterp(Quaternion a, Quaternion b, Vector3 twistAxis, float tSwing, float tTwist, SterpMode mode = SterpMode.Slerp)
		{
			Quaternion swing;
			Quaternion twist;
			return Sterp(a, b, twistAxis, tSwing, tTwist, out swing, out twist, mode);
		}

		public static Quaternion Sterp(Quaternion a, Quaternion b, Vector3 twistAxis, float tSwing, float tTwist, out Quaternion swing, out Quaternion twist, SterpMode mode)
		{
			DecomposeSwingTwist(b * Quaternion.Inverse(a), twistAxis, out var swing2, out var twist2);
			if (mode == SterpMode.Nlerp || mode != SterpMode.Slerp)
			{
				swing = Quaternion.Lerp(Quaternion.identity, swing2, tSwing);
				twist = Quaternion.Lerp(Quaternion.identity, twist2, tTwist);
			}
			else
			{
				swing = Quaternion.Slerp(Quaternion.identity, swing2, tSwing);
				twist = Quaternion.Slerp(Quaternion.identity, twist2, tTwist);
			}
			return twist * swing;
		}
	}
	public struct FloatSpring
	{
		public static readonly int Stride = 8;

		public float Value;

		public float Velocity;

		public void Reset()
		{
			Value = 0f;
			Velocity = 0f;
		}

		public void Reset(float initValue)
		{
			Value = initValue;
			Velocity = 0f;
		}

		public void Reset(float initValue, float initVelocity)
		{
			Value = initValue;
			Velocity = initVelocity;
		}

		public float TrackDampingRatio(float targetValue, float angularFrequency, float dampingRatio, float deltaTime)
		{
			if (angularFrequency < MathUtil.Epsilon)
			{
				Velocity = 0f;
				return Value;
			}
			float num = targetValue - Value;
			float num2 = 1f + 2f * deltaTime * dampingRatio * angularFrequency;
			float num3 = angularFrequency * angularFrequency;
			float num4 = deltaTime * num3;
			float num5 = deltaTime * num4;
			float num6 = 1f / (num2 + num5);
			float num7 = num2 * Value + deltaTime * Velocity + num5 * targetValue;
			float num8 = Velocity + num4 * num;
			Velocity = num8 * num6;
			Value = num7 * num6;
			if (Velocity < MathUtil.Epsilon && num < MathUtil.Epsilon)
			{
				Velocity = 0f;
				Value = targetValue;
			}
			return Value;
		}

		public float TrackHalfLife(float targetValue, float frequencyHz, float halfLife, float deltaTime)
		{
			if (halfLife < MathUtil.Epsilon)
			{
				Velocity = 0f;
				Value = targetValue;
				return Value;
			}
			float num = frequencyHz * MathUtil.TwoPi;
			float dampingRatio = 0.6931472f / (num * halfLife);
			return TrackDampingRatio(targetValue, num, dampingRatio, deltaTime);
		}

		public float TrackExponential(float targetValue, float halfLife, float deltaTime)
		{
			if (halfLife < MathUtil.Epsilon)
			{
				Velocity = 0f;
				Value = targetValue;
				return Value;
			}
			float angularFrequency = 0.6931472f / halfLife;
			float dampingRatio = 1f;
			return TrackDampingRatio(targetValue, angularFrequency, dampingRatio, deltaTime);
		}
	}
	public struct Vector2Spring
	{
		public static readonly int Stride = 16;

		public Vector2 Value;

		public Vector2 Velocity;

		public void Reset()
		{
			Value = Vector2.zero;
			Velocity = Vector2.zero;
		}

		public void Reset(Vector2 initValue)
		{
			Value = initValue;
			Velocity = Vector2.zero;
		}

		public void Reset(Vector2 initValue, Vector2 initVelocity)
		{
			Value = initValue;
			Velocity = initVelocity;
		}

		public Vector2 TrackDampingRatio(Vector2 targetValue, float angularFrequency, float dampingRatio, float deltaTime)
		{
			if (angularFrequency < MathUtil.Epsilon)
			{
				Velocity = Vector2.zero;
				return Value;
			}
			Vector2 vector = targetValue - Value;
			float num = 1f + 2f * deltaTime * dampingRatio * angularFrequency;
			float num2 = angularFrequency * angularFrequency;
			float num3 = deltaTime * num2;
			float num4 = deltaTime * num3;
			float num5 = 1f / (num + num4);
			Vector2 vector2 = num * Value + deltaTime * Velocity + num4 * targetValue;
			Vector2 vector3 = Velocity + num3 * vector;
			Velocity = vector3 * num5;
			Value = vector2 * num5;
			if (Velocity.magnitude < MathUtil.Epsilon && vector.magnitude < MathUtil.Epsilon)
			{
				Velocity = Vector2.zero;
				Value = targetValue;
			}
			return Value;
		}

		public Vector2 TrackHalfLife(Vector2 targetValue, float frequencyHz, float halfLife, float deltaTime)
		{
			if (halfLife < MathUtil.Epsilon)
			{
				Velocity = Vector2.zero;
				Value = targetValue;
				return Value;
			}
			float num = frequencyHz * MathUtil.TwoPi;
			float dampingRatio = 0.6931472f / (num * halfLife);
			return TrackDampingRatio(targetValue, num, dampingRatio, deltaTime);
		}

		public Vector2 TrackExponential(Vector2 targetValue, float halfLife, float deltaTime)
		{
			if (halfLife < MathUtil.Epsilon)
			{
				Velocity = Vector2.zero;
				Value = targetValue;
				return Value;
			}
			float angularFrequency = 0.6931472f / halfLife;
			float dampingRatio = 1f;
			return TrackDampingRatio(targetValue, angularFrequency, dampingRatio, deltaTime);
		}
	}
	public struct Vector3Spring
	{
		public static readonly int Stride = 32;

		public Vector3 Value;

		private float m_padding0;

		public Vector3 Velocity;

		private float m_padding1;

		public void Reset()
		{
			Value = Vector3.zero;
			Velocity = Vector3.zero;
		}

		public void Reset(Vector3 initValue)
		{
			Value = initValue;
			Velocity = Vector3.zero;
		}

		public void Reset(Vector3 initValue, Vector3 initVelocity)
		{
			Value = initValue;
			Velocity = initVelocity;
		}

		public Vector3 TrackDampingRatio(Vector3 targetValue, float angularFrequency, float dampingRatio, float deltaTime)
		{
			if (angularFrequency < MathUtil.Epsilon)
			{
				Velocity = Vector3.zero;
				return Value;
			}
			Vector3 vector = targetValue - Value;
			float num = 1f + 2f * deltaTime * dampingRatio * angularFrequency;
			float num2 = angularFrequency * angularFrequency;
			float num3 = deltaTime * num2;
			float num4 = deltaTime * num3;
			float num5 = 1f / (num + num4);
			Vector3 vector2 = num * Value + deltaTime * Velocity + num4 * targetValue;
			Vector3 vector3 = Velocity + num3 * vector;
			Velocity = vector3 * num5;
			Value = vector2 * num5;
			if (Velocity.magnitude < MathUtil.Epsilon && vector.magnitude < MathUtil.Epsilon)
			{
				Velocity = Vector3.zero;
				Value = targetValue;
			}
			return Value;
		}

		public Vector3 TrackHalfLife(Vector3 targetValue, float frequencyHz, float halfLife, float deltaTime)
		{
			if (halfLife < MathUtil.Epsilon)
			{
				Velocity = Vector3.zero;
				Value = targetValue;
				return Value;
			}
			float num = frequencyHz * MathUtil.TwoPi;
			float dampingRatio = 0.6931472f / (num * halfLife);
			return TrackDampingRatio(targetValue, num, dampingRatio, deltaTime);
		}

		public Vector3 TrackExponential(Vector3 targetValue, float halfLife, float deltaTime)
		{
			if (halfLife < MathUtil.Epsilon)
			{
				Velocity = Vector3.zero;
				Value = targetValue;
				return Value;
			}
			float angularFrequency = 0.6931472f / halfLife;
			float dampingRatio = 1f;
			return TrackDampingRatio(targetValue, angularFrequency, dampingRatio, deltaTime);
		}
	}
	public struct Vector4Spring
	{
		public static readonly int Stride = 32;

		public Vector4 Value;

		public Vector4 Velocity;

		public void Reset()
		{
			Value = Vector4.zero;
			Velocity = Vector4.zero;
		}

		public void Reset(Vector4 initValue)
		{
			Value = initValue;
			Velocity = Vector4.zero;
		}

		public void Reset(Vector4 initValue, Vector4 initVelocity)
		{
			Value = initValue;
			Velocity = initVelocity;
		}

		public Vector4 TrackDampingRatio(Vector4 targetValue, float angularFrequency, float dampingRatio, float deltaTime)
		{
			if (angularFrequency < MathUtil.Epsilon)
			{
				Velocity = Vector4.zero;
				return Value;
			}
			Vector4 vector = targetValue - Value;
			float num = 1f + 2f * deltaTime * dampingRatio * angularFrequency;
			float num2 = angularFrequency * angularFrequency;
			float num3 = deltaTime * num2;
			float num4 = deltaTime * num3;
			float num5 = 1f / (num + num4);
			Vector4 vector2 = num * Value + deltaTime * Velocity + num4 * targetValue;
			Vector4 vector3 = Velocity + num3 * vector;
			Velocity = vector3 * num5;
			Value = vector2 * num5;
			if (Velocity.magnitude < MathUtil.Epsilon && vector.magnitude < MathUtil.Epsilon)
			{
				Velocity = Vector4.zero;
				Value = targetValue;
			}
			return Value;
		}

		public Vector4 TrackHalfLife(Vector4 targetValue, float frequencyHz, float halfLife, float deltaTime)
		{
			if (halfLife < MathUtil.Epsilon)
			{
				Velocity = Vector4.zero;
				Value = targetValue;
				return Value;
			}
			float num = frequencyHz * MathUtil.TwoPi;
			float dampingRatio = 0.6931472f / (num * halfLife);
			return TrackDampingRatio(targetValue, num, dampingRatio, deltaTime);
		}

		public Vector4 TrackExponential(Vector4 targetValue, float halfLife, float deltaTime)
		{
			if (halfLife < MathUtil.Epsilon)
			{
				Velocity = Vector4.zero;
				Value = targetValue;
				return Value;
			}
			float angularFrequency = 0.6931472f / halfLife;
			float dampingRatio = 1f;
			return TrackDampingRatio(targetValue, angularFrequency, dampingRatio, deltaTime);
		}
	}
	public struct QuaternionSpring
	{
		public static readonly int Stride = 32;

		public Vector4 ValueVec;

		public Vector4 VelocityVec;

		public Quaternion ValueQuat
		{
			get
			{
				return QuaternionUtil.FromVector4(ValueVec);
			}
			set
			{
				ValueVec = QuaternionUtil.ToVector4(value);
			}
		}

		public void Reset()
		{
			ValueVec = QuaternionUtil.ToVector4(Quaternion.identity);
			VelocityVec = Vector4.zero;
		}

		public void Reset(Vector4 initValue)
		{
			ValueVec = initValue;
			VelocityVec = Vector4.zero;
		}

		public void Reset(Vector4 initValue, Vector4 initVelocity)
		{
			ValueVec = initValue;
			VelocityVec = initVelocity;
		}

		public void Reset(Quaternion initValue)
		{
			ValueVec = QuaternionUtil.ToVector4(initValue);
			VelocityVec = Vector4.zero;
		}

		public void Reset(Quaternion initValue, Quaternion initVelocity)
		{
			ValueVec = QuaternionUtil.ToVector4(initValue);
			VelocityVec = QuaternionUtil.ToVector4(initVelocity);
		}

		public Quaternion TrackDampingRatio(Vector4 targetValueVec, float angularFrequency, float dampingRatio, float deltaTime)
		{
			if (angularFrequency < MathUtil.Epsilon)
			{
				VelocityVec = QuaternionUtil.ToVector4(Quaternion.identity);
				return QuaternionUtil.FromVector4(ValueVec);
			}
			if (Vector4.Dot(ValueVec, targetValueVec) < 0f)
			{
				targetValueVec = -targetValueVec;
			}
			Vector4 vector = targetValueVec - ValueVec;
			float num = 1f + 2f * deltaTime * dampingRatio * angularFrequency;
			float num2 = angularFrequency * angularFrequency;
			float num3 = deltaTime * num2;
			float num4 = deltaTime * num3;
			float num5 = 1f / (num + num4);
			Vector4 vector2 = num * ValueVec + deltaTime * VelocityVec + num4 * targetValueVec;
			Vector4 vector3 = VelocityVec + num3 * vector;
			VelocityVec = vector3 * num5;
			ValueVec = vector2 * num5;
			if (VelocityVec.magnitude < MathUtil.Epsilon && vector.magnitude < MathUtil.Epsilon)
			{
				VelocityVec = Vector4.zero;
				ValueVec = targetValueVec;
			}
			return QuaternionUtil.FromVector4(ValueVec);
		}

		public Quaternion TrackDampingRatio(Quaternion targetValue, float angularFrequency, float dampingRatio, float deltaTime)
		{
			return TrackDampingRatio(QuaternionUtil.ToVector4(targetValue), angularFrequency, dampingRatio, deltaTime);
		}

		public Quaternion TrackHalfLife(Vector4 targetValueVec, float frequencyHz, float halfLife, float deltaTime)
		{
			if (halfLife < MathUtil.Epsilon)
			{
				VelocityVec = Vector4.zero;
				ValueVec = targetValueVec;
				return QuaternionUtil.FromVector4(targetValueVec);
			}
			float num = frequencyHz * MathUtil.TwoPi;
			float dampingRatio = 0.6931472f / (num * halfLife);
			return TrackDampingRatio(targetValueVec, num, dampingRatio, deltaTime);
		}

		public Quaternion TrackHalfLife(Quaternion targetValue, float frequencyHz, float halfLife, float deltaTime)
		{
			if (halfLife < MathUtil.Epsilon)
			{
				VelocityVec = QuaternionUtil.ToVector4(Quaternion.identity);
				ValueVec = QuaternionUtil.ToVector4(targetValue);
				return targetValue;
			}
			float num = frequencyHz * MathUtil.TwoPi;
			float dampingRatio = 0.6931472f / (num * halfLife);
			return TrackDampingRatio(targetValue, num, dampingRatio, deltaTime);
		}

		public Quaternion TrackExponential(Vector4 targetValueVec, float halfLife, float deltaTime)
		{
			if (halfLife < MathUtil.Epsilon)
			{
				VelocityVec = Vector4.zero;
				ValueVec = targetValueVec;
				return QuaternionUtil.FromVector4(targetValueVec);
			}
			float angularFrequency = 0.6931472f / halfLife;
			float dampingRatio = 1f;
			return TrackDampingRatio(targetValueVec, angularFrequency, dampingRatio, deltaTime);
		}

		public Quaternion TrackExponential(Quaternion targetValue, float halfLife, float deltaTime)
		{
			if (halfLife < MathUtil.Epsilon)
			{
				VelocityVec = QuaternionUtil.ToVector4(Quaternion.identity);
				ValueVec = QuaternionUtil.ToVector4(targetValue);
				return targetValue;
			}
			float angularFrequency = 0.6931472f / halfLife;
			float dampingRatio = 1f;
			return TrackDampingRatio(targetValue, angularFrequency, dampingRatio, deltaTime);
		}
	}
	public class VectorUtil
	{
		public static readonly Vector3 Min = new Vector3(float.MinValue, float.MinValue, float.MinValue);

		public static readonly Vector3 Max = new Vector3(float.MaxValue, float.MaxValue, float.MaxValue);

		public static Vector3 Rotate2D(Vector3 v, float angle)
		{
			Vector3 result = v;
			float num = Mathf.Cos(angle);
			float num2 = Mathf.Sin(angle);
			result.x = num * v.x - num2 * v.y;
			result.y = num2 * v.x + num * v.y;
			return result;
		}

		public static Vector4 NormalizeSafe(Vector4 v, Vector4 fallback)
		{
			if (!(v.sqrMagnitude > MathUtil.Epsilon))
			{
				return fallback;
			}
			return v.normalized;
		}

		public static Vector3 FindOrthogonal(Vector3 v)
		{
			if (v.x >= MathUtil.Sqrt3Inv)
			{
				return new Vector3(v.y, 0f - v.x, 0f);
			}
			return new Vector3(0f, v.z, 0f - v.y);
		}

		public static void FormOrthogonalBasis(Vector3 v, out Vector3 a, out Vector3 b)
		{
			a = FindOrthogonal(v);
			b = Vector3.Cross(a, v);
		}

		public static Vector3 Slerp(Vector3 a, Vector3 b, float t)
		{
			float num = Vector3.Dot(a, b);
			if (num > 0.99999f)
			{
				return Vector3.Lerp(a, b, t);
			}
			if (num < -0.99999f)
			{
				Vector3 axis = FindOrthogonal(a);
				return Quaternion.AngleAxis(180f * t, axis) * a;
			}
			float num2 = MathUtil.AcosSafe(num);
			return (Mathf.Sin((1f - t) * num2) * a + Mathf.Sin(t * num2) * b) / Mathf.Sin(num2);
		}

		public static Vector3 GetClosestPointOnSegment(Vector3 p, Vector3 segA, Vector3 segB)
		{
			Vector3 vector = segB - segA;
			if (vector.sqrMagnitude < MathUtil.Epsilon)
			{
				return 0.5f * (segA + segB);
			}
			float num = Mathf.Clamp01(Vector3.Dot(p - segA, vector.normalized) / vector.magnitude);
			return segA + num * vector;
		}

		public static Vector3 TriLerp(ref Vector3 v000, ref Vector3 v001, ref Vector3 v010, ref Vector3 v011, ref Vector3 v100, ref Vector3 v101, ref Vector3 v110, ref Vector3 v111, float tx, float ty, float tz)
		{
			Vector3 a = Vector3.Lerp(v000, v001, tx);
			Vector3 b = Vector3.Lerp(v010, v011, tx);
			Vector3 a2 = Vector3.Lerp(v100, v101, tx);
			Vector3 b2 = Vector3.Lerp(v110, v111, tx);
			Vector3 a3 = Vector3.Lerp(a, b, ty);
			Vector3 b3 = Vector3.Lerp(a2, b2, ty);
			return Vector3.Lerp(a3, b3, tz);
		}

		public static Vector3 TriLerp(ref Vector3 v000, ref Vector3 v001, ref Vector3 v010, ref Vector3 v011, ref Vector3 v100, ref Vector3 v101, ref Vector3 v110, ref Vector3 v111, bool lerpX, bool lerpY, bool lerpZ, float tx, float ty, float tz)
		{
			Vector3 vector = (lerpX ? Vector3.Lerp(v000, v001, tx) : v000);
			Vector3 b = (lerpX ? Vector3.Lerp(v010, v011, tx) : v010);
			Vector3 vector2 = (lerpX ? Vector3.Lerp(v100, v101, tx) : v100);
			Vector3 b2 = (lerpX ? Vector3.Lerp(v110, v111, tx) : v110);
			Vector3 vector3 = (lerpY ? Vector3.Lerp(vector, b, ty) : vector);
			Vector3 b3 = (lerpY ? Vector3.Lerp(vector2, b2, ty) : vector2);
			if (!lerpZ)
			{
				return vector3;
			}
			return Vector3.Lerp(vector3, b3, tz);
		}

		public static Vector3 TriLerp(ref Vector3 min, ref Vector3 max, bool lerpX, bool lerpY, bool lerpZ, float tx, float ty, float tz)
		{
			Vector3 vector = (lerpX ? Vector3.Lerp(new Vector3(min.x, min.y, min.z), new Vector3(max.x, min.y, min.z), tx) : new Vector3(min.x, min.y, min.z));
			Vector3 b = (lerpX ? Vector3.Lerp(new Vector3(min.x, max.y, min.z), new Vector3(max.x, max.y, min.z), tx) : new Vector3(min.x, max.y, min.z));
			Vector3 vector2 = (lerpX ? Vector3.Lerp(new Vector3(min.x, min.y, max.z), new Vector3(max.x, min.y, max.z), tx) : new Vector3(min.x, min.y, max.z));
			Vector3 b2 = (lerpX ? Vector3.Lerp(new Vector3(min.x, max.y, max.z), new Vector3(max.x, max.y, max.z), tx) : new Vector3(min.x, max.y, max.z));
			Vector3 vector3 = (lerpY ? Vector3.Lerp(vector, b, ty) : vector);
			Vector3 b3 = (lerpY ? Vector3.Lerp(vector2, b2, ty) : vector2);
			if (!lerpZ)
			{
				return vector3;
			}
			return Vector3.Lerp(vector3, b3, tz);
		}

		public static Vector4 TriLerp(ref Vector4 v000, ref Vector4 v001, ref Vector4 v010, ref Vector4 v011, ref Vector4 v100, ref Vector4 v101, ref Vector4 v110, ref Vector4 v111, bool lerpX, bool lerpY, bool lerpZ, float tx, float ty, float tz)
		{
			Vector4 vector = (lerpX ? Vector4.Lerp(v000, v001, tx) : v000);
			Vector4 b = (lerpX ? Vector4.Lerp(v010, v011, tx) : v010);
			Vector4 vector2 = (lerpX ? Vector4.Lerp(v100, v101, tx) : v100);
			Vector4 b2 = (lerpX ? Vector4.Lerp(v110, v111, tx) : v110);
			Vector4 vector3 = (lerpY ? Vector4.Lerp(vector, b, ty) : vector);
			Vector4 b3 = (lerpY ? Vector4.Lerp(vector2, b2, ty) : vector2);
			if (!lerpZ)
			{
				return vector3;
			}
			return Vector4.Lerp(vector3, b3, tz);
		}

		public static Vector4 TriLerp(ref Vector4 min, ref Vector4 max, bool lerpX, bool lerpY, bool lerpZ, float tx, float ty, float tz)
		{
			Vector4 vector = (lerpX ? Vector4.Lerp(new Vector4(min.x, min.y, min.z), new Vector4(max.x, min.y, min.z), tx) : new Vector4(min.x, min.y, min.z));
			Vector4 b = (lerpX ? Vector4.Lerp(new Vector4(min.x, max.y, min.z), new Vector4(max.x, max.y, min.z), tx) : new Vector4(min.x, max.y, min.z));
			Vector4 vector2 = (lerpX ? Vector4.Lerp(new Vector4(min.x, min.y, max.z), new Vector4(max.x, min.y, max.z), tx) : new Vector4(min.x, min.y, max.z));
			Vector4 b2 = (lerpX ? Vector4.Lerp(new Vector4(min.x, max.y, max.z), new Vector4(max.x, max.y, max.z), tx) : new Vector4(min.x, max.y, max.z));
			Vector4 vector3 = (lerpY ? Vector4.Lerp(vector, b, ty) : vector);
			Vector4 b3 = (lerpY ? Vector4.Lerp(vector2, b2, ty) : vector2);
			if (!lerpZ)
			{
				return vector3;
			}
			return Vector4.Lerp(vector3, b3, tz);
		}

		public static Vector3 ClampLength(Vector3 v, float minLen, float maxLen)
		{
			float sqrMagnitude = v.sqrMagnitude;
			if (sqrMagnitude < MathUtil.Epsilon)
			{
				return v;
			}
			float num = Mathf.Sqrt(sqrMagnitude);
			return v * (Mathf.Clamp(num, minLen, maxLen) / num);
		}

		public static float MinComponent(Vector3 v)
		{
			return Mathf.Min(v.x, v.y, v.z);
		}

		public static float MaxComponent(Vector3 v)
		{
			return Mathf.Max(v.x, v.y, v.z);
		}

		public static Vector3 ComponentWiseAbs(Vector3 v)
		{
			return new Vector3(Mathf.Abs(v.x), Mathf.Abs(v.y), Mathf.Abs(v.z));
		}

		public static Vector3 ComponentWiseMin(params Vector3[] aVec)
		{
			if (aVec.Length == 0)
			{
				return new Vector3(float.MinValue, float.MinValue, float.MinValue);
			}
			Vector3 result = aVec[0];
			int i = 1;
			for (int num = aVec.Length; i < num; i++)
			{
				Vector3 vector = aVec[i];
				result.Set(Mathf.Min(result.x, vector.x), Mathf.Min(result.y, vector.y), Mathf.Min(result.z, vector.z));
			}
			return result;
		}

		public static Vector3 ComponentWiseMax(params Vector3[] aVec)
		{
			if (aVec.Length == 0)
			{
				return new Vector3(float.MaxValue, float.MaxValue, float.MaxValue);
			}
			Vector3 result = aVec[0];
			int i = 1;
			for (int num = aVec.Length; i < num; i++)
			{
				Vector3 vector = aVec[i];
				result.Set(Mathf.Max(result.x, vector.x), Mathf.Max(result.y, vector.y), Mathf.Max(result.z, vector.z));
			}
			return result;
		}

		public static Vector3 ComponentWiseMult(params Vector3[] aVec)
		{
			if (aVec.Length == 0)
			{
				return Vector3.one;
			}
			Vector3 result = aVec[0];
			int i = 1;
			for (int num = aVec.Length; i < num; i++)
			{
				Vector3 vector = aVec[i];
				result.Set(result.x * vector.x, result.y * vector.y, result.z * vector.z);
			}
			return result;
		}

		public static Vector3 ComponentWiseDiv(Vector3 num, Vector3 den)
		{
			return new Vector3(num.x / den.x, num.y / den.y, num.z / den.z);
		}

		public static Vector3 ComponentWiseDivSafe(Vector3 num, Vector3 den)
		{
			return new Vector3(num.x * MathUtil.InvSafe(den.x), num.y * MathUtil.InvSafe(den.y), num.z * MathUtil.InvSafe(den.z));
		}

		public static Vector3 ClampBend(Vector3 vector, Vector3 reference, float maxBendAngle)
		{
			float sqrMagnitude = vector.sqrMagnitude;
			if (sqrMagnitude < MathUtil.Epsilon)
			{
				return vector;
			}
			float sqrMagnitude2 = reference.sqrMagnitude;
			if (sqrMagnitude2 < MathUtil.Epsilon)
			{
				return vector;
			}
			Vector3 rhs = vector / Mathf.Sqrt(sqrMagnitude);
			Vector3 vector2 = reference / Mathf.Sqrt(sqrMagnitude2);
			Vector3 vector3 = Vector3.Cross(vector2, rhs);
			float value = Vector3.Dot(vector2, rhs);
			Vector3 axis = ((vector3.sqrMagnitude > MathUtil.Epsilon) ? vector3.normalized : FindOrthogonal(vector2));
			if (Mathf.Acos(Mathf.Clamp01(value)) <= maxBendAngle)
			{
				return vector;
			}
			return QuaternionUtil.AxisAngle(axis, maxBendAngle) * reference * (Mathf.Sqrt(sqrMagnitude) / Mathf.Sqrt(sqrMagnitude2));
		}
	}
}
namespace BoundarySystem_Ext
{
	internal static class Pvr_BoundaryAPI
	{
		private const string LibFileName = "Pvr_UnitySDK";

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void Pvr_StartSDKBoundary();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void Pvr_ShutdownSDKBoundary();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetMainSensorStateExt(ref float x, ref float y, ref float z, ref float w, ref float px, ref float py, ref float pz, ref float vfov, ref float hfov, ref int viewNumber);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr Pvr_GetCameraData_Ext();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void Pvr_ResetVrModebyForce();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_ResumeBoundaryForSTS();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_PauseBoundaryForSTS();

		public static int UPvr_GetMainSensorStateExt(ref float x, ref float y, ref float z, ref float w, ref float px, ref float py, ref float pz, ref float vfov, ref float hfov, ref int viewNumber)
		{
			return Pvr_GetMainSensorStateExt(ref x, ref y, ref z, ref w, ref px, ref py, ref pz, ref vfov, ref hfov, ref viewNumber);
		}

		public static IntPtr UPvr_GetCameraData_Ext()
		{
			_ = IntPtr.Zero;
			return Pvr_GetCameraData_Ext();
		}

		public static bool UPvr_ResumeBoundaryForSTS()
		{
			return Pvr_ResumeBoundaryForSTS();
		}

		public static void UPvr_PauseBoundaryForSTS()
		{
			Pvr_PauseBoundaryForSTS();
		}

		public static IntPtr StructToIntPtr<T>(T info)
		{
			IntPtr intPtr = Marshal.AllocHGlobal(Marshal.SizeOf(info));
			Marshal.StructureToPtr(info, intPtr, fDeleteOld: true);
			return intPtr;
		}

		public static T IntPtrToStruct<T>(IntPtr info)
		{
			return (T)Marshal.PtrToStructure(info, typeof(T));
		}
	}
	internal static class Pvr_SafeAreaAlgoAPI
	{
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		public delegate void SafeAreaCallback(IntPtr lineCollectionPtr, IntPtr safeAreaRectPtr);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		public delegate void SafeAreaCallbackShrink(IntPtr lineCollectionPtr, IntPtr safeAreaDetailRectPtr);

		public struct GSAPoint3i
		{
			public int x;

			public int y;

			public int z;
		}

		public struct GSALine
		{
			public IntPtr pointArray;

			public int pointCount;
		}

		public struct GSALineCollection
		{
			public IntPtr lineArray;

			public int lineCount;
		}

		public struct GSALegalData
		{
			public int overMaxRange;

			public int includeBigGrap;

			public int bigGapNum;

			public int centerOut;

			public int removeNarrow;

			public int overMaxRange_more;

			public int validShrinkArea;
		}

		public struct GSARect
		{
			public GSAPoint3i leftup;

			public GSAPoint3i leftdown;

			public GSAPoint3i rightup;

			public GSAPoint3i rightdown;

			public GSAPoint3i center;

			public uint width;

			public uint height;

			public int isLegal;

			public GSALegalData legalData;
		}

		private const string LibFileName = "SafetyArea";

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern int GSAInit(int width, int height);

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern int GSAShutDown();

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern int GSASetCallback(SafeAreaCallback cb);

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern int GSASetCallbackShrink(SafeAreaCallbackShrink cb);

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern int GSAUpDateData(IntPtr lineCollectionPtr);

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern int GSASetConfigFilePath(IntPtr configPath);

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool GSAGetClosedAreaUpdateFlag();

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern int GSALoadSafetyArea(IntPtr lineCollectionPtr);

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern double GSABoundaryDetector(ref GSAPoint3i pointPtr);

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern int GSALoadSafetyArea2(IntPtr lineCollectionPtr, bool isPlayArea);

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern double GSABoundaryDetector2(ref GSAPoint3i point, bool isPlayArea, ref GSAPoint3i closestPoint, ref GSAPoint3i normalDir);

		public static int Pvr_GSAInit(int width, int height)
		{
			return GSAInit(width, height);
		}

		public static int Pvr_GSASetCallback(SafeAreaCallback cb)
		{
			return GSASetCallback(cb);
		}

		public static int Pvr_GSASetCallbackShrink(SafeAreaCallbackShrink cb)
		{
			return GSASetCallbackShrink(cb);
		}

		public static int Pvr_GSAUpDateData(IntPtr lineCollectionPtr)
		{
			return GSAUpDateData(lineCollectionPtr);
		}

		public static bool Pvr_GSAGetClosedAreaUpdateFlag()
		{
			return GSAGetClosedAreaUpdateFlag();
		}

		public static int Pvr_GSASetConfigFilePath(string configPath)
		{
			int num = -1;
			IntPtr intPtr = Marshal.StringToHGlobalAnsi(configPath);
			num = GSASetConfigFilePath(intPtr);
			Marshal.FreeHGlobal(intPtr);
			return num;
		}

		public static int Pvr_GSALoadSafetyArea(IntPtr lineCollectionPtr)
		{
			return GSALoadSafetyArea(lineCollectionPtr);
		}

		public static double Pvr_GSABoundaryDetector(ref GSAPoint3i point)
		{
			return GSABoundaryDetector(ref point);
		}

		public static int Pvr_GSAShutDown()
		{
			return GSAShutDown();
		}

		public static int Pvr_GSALoadSafetyArea2(IntPtr lineCollectionPtr, bool isPlayArea)
		{
			return GSALoadSafetyArea2(lineCollectionPtr, isPlayArea);
		}

		public static double Pvr_GSABoundaryDetector2(ref GSAPoint3i point, bool isPlayArea, ref GSAPoint3i closestPoint, ref GSAPoint3i normalDir)
		{
			return GSABoundaryDetector2(ref point, isPlayArea, ref closestPoint, ref normalDir);
		}
	}
	public class Pvr_BoundarySystem
	{
		private static Pvr_BoundarySystem instance;

		public const int CameraImageWidth = 1280;

		public const int CameraImageHeight = 400;

		public IntPtr CameraFramePtr = IntPtr.Zero;

		public static Pvr_BoundarySystem Instance
		{
			get
			{
				if (instance == null)
				{
					instance = new Pvr_BoundarySystem();
				}
				return instance;
			}
		}

		public void OpenBoundary()
		{
			Pvr_BoundaryAPI.Pvr_StartSDKBoundary();
		}

		public void CloseBoundary()
		{
			Pvr_BoundaryAPI.Pvr_ShutdownSDKBoundary();
		}

		public void Reset6Dof()
		{
			Pvr_BoundaryAPI.Pvr_ResetVrModebyForce();
		}

		public float[] GetControllerFixedPoseData(int hand)
		{
			float[] result = new float[7] { 0f, 0f, 0f, 1f, 0f, 0f, 0f };
			if (Pvr_ControllerManager.controllerlink != null)
			{
				Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, Pvr_ControllerManager.controllerlink.javaCVClass, "getControllerFixedSensorState", hand);
			}
			result[2] = 0f - result[2];
			result[3] = 0f - result[3];
			return result;
		}
	}
	public class Pvr_SafeAreaAlgoModule
	{
		public struct ExtraInfo
		{
			public bool overMaxRange;

			public bool includeBigGap;

			public int bigGapNum;

			public bool centerOut;

			public bool removeNarrow;

			public bool overMaxRange_more;

			public int validShrinkArea;
		}

		public struct BoundaryPlayerArea
		{
			public Vector3 lowerleft;

			public Vector3 upperleft;

			public Vector3 upperRight;

			public Vector3 lowerRight;

			public Vector3 center;

			public uint width;

			public uint height;

			public bool isLegal;

			public ExtraInfo extraInfo;
		}

		public delegate void BoundarySystemCallback(BoundaryPlayerArea playAreaInfo, List<Vector3> boundaryPoints, List<List<Vector3>> unusedLines);

		public delegate void BoundarySystemCallbackShrink(List<Vector3> rectPoints, List<Vector3> boundaryPoints, List<List<Vector3>> unusedLines);

		private static Pvr_SafeAreaAlgoModule instance;

		private BoundarySystemCallback boundarySystemCallback;

		private BoundarySystemCallbackShrink boundarySystemCallbackShrink;

		public static Pvr_SafeAreaAlgoModule Instance
		{
			get
			{
				if (instance == null)
				{
					instance = new Pvr_SafeAreaAlgoModule();
				}
				return instance;
			}
		}

		public void RegisterCallBack(BoundarySystemCallback callback)
		{
			boundarySystemCallback = callback;
		}

		public void RegisterCallBackShrink(BoundarySystemCallbackShrink callback)
		{
			boundarySystemCallbackShrink = callback;
		}

		public bool Start()
		{
			int num = Pvr_SafeAreaAlgoAPI.Pvr_GSASetCallback(_SafeAreaCallback);
			int num2 = Pvr_SafeAreaAlgoAPI.Pvr_GSASetCallbackShrink(_SafeAreaCallbackShrink);
			if (num != 0 || num2 != 0)
			{
				UnityEngine.Debug.LogError("BoundarySystem register callback failed!");
				return false;
			}
			if (Pvr_SafeAreaAlgoAPI.Pvr_GSAInit(300, 300) != 0)
			{
				UnityEngine.Debug.LogError("BoundarySystem init failed!");
				return false;
			}
			return true;
		}

		public bool CommitNewLineData(bool isFistLine, Vector3[] points)
		{
			Pvr_SafeAreaAlgoAPI.GSALineCollection info = default(Pvr_SafeAreaAlgoAPI.GSALineCollection);
			info.lineCount = 2;
			Pvr_SafeAreaAlgoAPI.GSALine[] array = new Pvr_SafeAreaAlgoAPI.GSALine[2];
			if (isFistLine)
			{
				array[0].pointArray = IntPtr.Zero;
				array[0].pointCount = 0;
			}
			else
			{
				Pvr_SafeAreaAlgoAPI.GSAPoint3i[] arr = new Pvr_SafeAreaAlgoAPI.GSAPoint3i[1]
				{
					new Pvr_SafeAreaAlgoAPI.GSAPoint3i
					{
						x = 0,
						y = 0,
						z = 0
					}
				};
				array[0].pointArray = Marshal.UnsafeAddrOfPinnedArrayElement(arr, 0);
				array[0].pointCount = 1;
			}
			Pvr_SafeAreaAlgoAPI.GSAPoint3i[] array2 = new Pvr_SafeAreaAlgoAPI.GSAPoint3i[points.Length];
			for (int i = 0; i < points.Length; i++)
			{
				Pvr_SafeAreaAlgoAPI.GSAPoint3i gSAPoint3i = default(Pvr_SafeAreaAlgoAPI.GSAPoint3i);
				gSAPoint3i.x = (int)(points[i].x * 1000f);
				gSAPoint3i.y = (int)(points[i].y * 1000f);
				gSAPoint3i.z = (int)(points[i].z * 1000f);
				array2[i] = gSAPoint3i;
			}
			array[1].pointArray = Marshal.UnsafeAddrOfPinnedArrayElement(array2, 0);
			array[1].pointCount = array2.Length;
			info.lineArray = Marshal.UnsafeAddrOfPinnedArrayElement(array, 0);
			IntPtr intPtr = Pvr_BoundaryAPI.StructToIntPtr(info);
			int num = Pvr_SafeAreaAlgoAPI.Pvr_GSAUpDateData(intPtr);
			Marshal.FreeHGlobal(intPtr);
			if (num != 0)
			{
				UnityEngine.Debug.LogError("BoundarySystem commit new line data failed!");
				return false;
			}
			return true;
		}

		public bool Shutdown()
		{
			if (Pvr_SafeAreaAlgoAPI.Pvr_GSAShutDown() != 0)
			{
				UnityEngine.Debug.LogError("BoundarySystem shutdown failed!");
				return false;
			}
			return true;
		}

		public double QueryDistanceOfPoint(Vector3 point)
		{
			Pvr_SafeAreaAlgoAPI.GSAPoint3i point2 = default(Pvr_SafeAreaAlgoAPI.GSAPoint3i);
			point2.x = (int)(point.x * 1000f);
			point2.y = (int)(point.y * 1000f);
			point2.z = (int)(point.z * 1000f);
			return Pvr_SafeAreaAlgoAPI.Pvr_GSABoundaryDetector(ref point2) / 1000.0;
		}

		public double QueryDistanceOfPoint(Vector3 point, bool isPlayArea, ref Vector3 closestPoint, ref Vector3 normalDir)
		{
			Pvr_SafeAreaAlgoAPI.GSAPoint3i point2 = default(Pvr_SafeAreaAlgoAPI.GSAPoint3i);
			point2.x = (int)(point.x * 1000f);
			point2.y = (int)(point.y * 1000f);
			point2.z = (int)(point.z * 1000f);
			Pvr_SafeAreaAlgoAPI.GSAPoint3i closestPoint2 = default(Pvr_SafeAreaAlgoAPI.GSAPoint3i);
			Pvr_SafeAreaAlgoAPI.GSAPoint3i normalDir2 = default(Pvr_SafeAreaAlgoAPI.GSAPoint3i);
			double num = Pvr_SafeAreaAlgoAPI.Pvr_GSABoundaryDetector2(ref point2, isPlayArea, ref closestPoint2, ref normalDir2);
			closestPoint.x = (float)closestPoint2.x / 1000f;
			closestPoint.y = (float)closestPoint2.y / 1000f;
			closestPoint.z = (float)closestPoint2.z / 1000f;
			normalDir.x = (float)normalDir2.x / 1000f;
			normalDir.y = (float)normalDir2.y / 1000f;
			normalDir.z = (float)normalDir2.z / 1000f;
			return num / 1000.0;
		}

		[MonoPInvokeCallback(typeof(Pvr_SafeAreaAlgoAPI.SafeAreaCallback))]
		private static void _SafeAreaCallback(IntPtr lineCollectionPtr, IntPtr safeAreaRectPtr)
		{
			if (lineCollectionPtr == IntPtr.Zero || safeAreaRectPtr == IntPtr.Zero)
			{
				UnityEngine.Debug.LogError("BoundarySystem callback is inValid!");
			}
			else
			{
				if (instance.boundarySystemCallback == null)
				{
					return;
				}
				List<Vector3> boundaryPoints = new List<Vector3>();
				List<List<Vector3>> list = new List<List<Vector3>>();
				int num = Marshal.SizeOf(typeof(Pvr_SafeAreaAlgoAPI.GSALine));
				int num2 = Marshal.SizeOf(typeof(Pvr_SafeAreaAlgoAPI.GSAPoint3i));
				Pvr_SafeAreaAlgoAPI.GSALineCollection gSALineCollection = Pvr_BoundaryAPI.IntPtrToStruct<Pvr_SafeAreaAlgoAPI.GSALineCollection>(lineCollectionPtr);
				for (int i = 0; i < gSALineCollection.lineCount; i++)
				{
					Pvr_SafeAreaAlgoAPI.GSALine gSALine = (Pvr_SafeAreaAlgoAPI.GSALine)Marshal.PtrToStructure(new IntPtr(gSALineCollection.lineArray.ToInt64() + num * i), typeof(Pvr_SafeAreaAlgoAPI.GSALine));
					List<Vector3> list2 = new List<Vector3>();
					for (int j = 0; j < gSALine.pointCount; j++)
					{
						Pvr_SafeAreaAlgoAPI.GSAPoint3i gSAPoint3i = (Pvr_SafeAreaAlgoAPI.GSAPoint3i)Marshal.PtrToStructure(new IntPtr(gSALine.pointArray.ToInt64() + num2 * j), typeof(Pvr_SafeAreaAlgoAPI.GSAPoint3i));
						list2.Add(new Vector3((float)gSAPoint3i.x / 1000f, (float)gSAPoint3i.y / 1000f, (float)gSAPoint3i.z / 1000f));
					}
					if (i == 0)
					{
						boundaryPoints = list2;
					}
					else
					{
						list.Add(list2);
					}
				}
				Pvr_SafeAreaAlgoAPI.GSARect gSARect = Pvr_BoundaryAPI.IntPtrToStruct<Pvr_SafeAreaAlgoAPI.GSARect>(safeAreaRectPtr);
				BoundaryPlayerArea playAreaInfo = default(BoundaryPlayerArea);
				playAreaInfo.lowerleft = new Vector3((float)gSARect.leftup.x / 1000f, (float)gSARect.leftup.y / 1000f, (float)gSARect.leftup.z / 1000f);
				playAreaInfo.upperleft = new Vector3((float)gSARect.leftdown.x / 1000f, (float)gSARect.leftdown.y / 1000f, (float)gSARect.leftdown.z / 1000f);
				playAreaInfo.upperRight = new Vector3((float)gSARect.rightdown.x / 1000f, (float)gSARect.rightdown.y / 1000f, (float)gSARect.rightdown.z / 1000f);
				playAreaInfo.lowerRight = new Vector3((float)gSARect.rightup.x / 1000f, (float)gSARect.rightup.y / 1000f, (float)gSARect.rightup.z / 1000f);
				playAreaInfo.center = new Vector3((float)gSARect.center.x / 1000f, (float)gSARect.center.y / 1000f, (float)gSARect.center.z / 1000f);
				playAreaInfo.width = gSARect.width;
				playAreaInfo.height = gSARect.height;
				playAreaInfo.isLegal = ((gSARect.isLegal != 0) ? true : false);
				playAreaInfo.extraInfo.overMaxRange = ((gSARect.legalData.overMaxRange != 0) ? true : false);
				playAreaInfo.extraInfo.includeBigGap = ((gSARect.legalData.includeBigGrap != 0) ? true : false);
				playAreaInfo.extraInfo.bigGapNum = gSARect.legalData.bigGapNum;
				playAreaInfo.extraInfo.centerOut = ((gSARect.legalData.centerOut != 0) ? true : false);
				playAreaInfo.extraInfo.removeNarrow = ((gSARect.legalData.removeNarrow != 0) ? true : false);
				playAreaInfo.extraInfo.overMaxRange_more = ((gSARect.legalData.overMaxRange_more != 0) ? true : false);
				playAreaInfo.extraInfo.validShrinkArea = gSARect.legalData.validShrinkArea;
				instance.boundarySystemCallback(playAreaInfo, boundaryPoints, list);
			}
		}

		[MonoPInvokeCallback(typeof(Pvr_SafeAreaAlgoAPI.SafeAreaCallbackShrink))]
		private static void _SafeAreaCallbackShrink(IntPtr lineCollectionPtr, IntPtr safeAreaDetailRectPtr)
		{
			if (lineCollectionPtr == IntPtr.Zero || safeAreaDetailRectPtr == IntPtr.Zero)
			{
				UnityEngine.Debug.LogError("BoundarySystem callback is inValid!");
			}
			else
			{
				if (instance.boundarySystemCallbackShrink == null)
				{
					return;
				}
				List<Vector3> boundaryPoints = new List<Vector3>();
				List<List<Vector3>> list = new List<List<Vector3>>();
				int num = Marshal.SizeOf(typeof(Pvr_SafeAreaAlgoAPI.GSALine));
				int num2 = Marshal.SizeOf(typeof(Pvr_SafeAreaAlgoAPI.GSAPoint3i));
				Pvr_SafeAreaAlgoAPI.GSALineCollection gSALineCollection = Pvr_BoundaryAPI.IntPtrToStruct<Pvr_SafeAreaAlgoAPI.GSALineCollection>(lineCollectionPtr);
				for (int i = 0; i < gSALineCollection.lineCount; i++)
				{
					Pvr_SafeAreaAlgoAPI.GSALine gSALine = (Pvr_SafeAreaAlgoAPI.GSALine)Marshal.PtrToStructure(new IntPtr(gSALineCollection.lineArray.ToInt64() + num * i), typeof(Pvr_SafeAreaAlgoAPI.GSALine));
					List<Vector3> list2 = new List<Vector3>();
					for (int j = 0; j < gSALine.pointCount; j++)
					{
						Pvr_SafeAreaAlgoAPI.GSAPoint3i gSAPoint3i = (Pvr_SafeAreaAlgoAPI.GSAPoint3i)Marshal.PtrToStructure(new IntPtr(gSALine.pointArray.ToInt64() + num2 * j), typeof(Pvr_SafeAreaAlgoAPI.GSAPoint3i));
						list2.Add(new Vector3((float)gSAPoint3i.x / 1000f, (float)gSAPoint3i.y / 1000f, (float)gSAPoint3i.z / 1000f));
					}
					if (i == 0)
					{
						boundaryPoints = list2;
					}
					else
					{
						list.Add(list2);
					}
				}
				List<Vector3> list3 = new List<Vector3>();
				Pvr_SafeAreaAlgoAPI.GSALineCollection gSALineCollection2 = Pvr_BoundaryAPI.IntPtrToStruct<Pvr_SafeAreaAlgoAPI.GSALineCollection>(safeAreaDetailRectPtr);
				for (int k = 0; k < gSALineCollection2.lineCount; k++)
				{
					Pvr_SafeAreaAlgoAPI.GSALine gSALine2 = (Pvr_SafeAreaAlgoAPI.GSALine)Marshal.PtrToStructure(new IntPtr(gSALineCollection2.lineArray.ToInt64() + num * k), typeof(Pvr_SafeAreaAlgoAPI.GSALine));
					for (int l = 0; l < gSALine2.pointCount; l++)
					{
						Pvr_SafeAreaAlgoAPI.GSAPoint3i gSAPoint3i2 = (Pvr_SafeAreaAlgoAPI.GSAPoint3i)Marshal.PtrToStructure(new IntPtr(gSALine2.pointArray.ToInt64() + num2 * l), typeof(Pvr_SafeAreaAlgoAPI.GSAPoint3i));
						list3.Add(new Vector3((float)gSAPoint3i2.x / 1000f, (float)gSAPoint3i2.y / 1000f, (float)gSAPoint3i2.z / 1000f));
					}
				}
				instance.boundarySystemCallbackShrink(list3, boundaryPoints, list);
			}
		}
	}
}
namespace Pvr_UnitySDKAPI
{
	public class PvrControllerKey
	{
		public bool State;

		public bool PressedDown;

		public bool PressedUp;

		public bool LongPressed;

		public bool Click;

		public bool Touch;

		public bool TouchDown;

		public bool TouchUp;

		public PvrControllerKey()
		{
			State = false;
			PressedDown = false;
			PressedUp = false;
			LongPressed = false;
			Click = false;
			Touch = false;
			TouchDown = false;
			TouchUp = false;
		}
	}
	public class ControllerHand
	{
		public PvrControllerKey App;

		public PvrControllerKey Touch;

		public PvrControllerKey Home;

		public PvrControllerKey VolumeDown;

		public PvrControllerKey VolumeUp;

		public PvrControllerKey Trigger;

		public PvrControllerKey X;

		public PvrControllerKey Y;

		public PvrControllerKey A;

		public PvrControllerKey B;

		public PvrControllerKey Left;

		public PvrControllerKey Right;

		public PvrControllerKey Thumbrest;

		public Vector2 TouchPadPosition;

		public int TriggerNum;

		public int GripValue;

		public Quaternion Rotation;

		public Vector3 Position;

		public int Battery;

		public ControllerState ConnectState;

		public SwipeDirection SwipeDirection;

		public TouchPadClick TouchPadClick;

		public bool isShowBoundary;

		public ControllerHand()
		{
			App = new PvrControllerKey();
			Touch = new PvrControllerKey();
			Home = new PvrControllerKey();
			VolumeDown = new PvrControllerKey();
			VolumeUp = new PvrControllerKey();
			Trigger = new PvrControllerKey();
			A = new PvrControllerKey();
			B = new PvrControllerKey();
			X = new PvrControllerKey();
			Y = new PvrControllerKey();
			Left = new PvrControllerKey();
			Right = new PvrControllerKey();
			Thumbrest = new PvrControllerKey();
			TouchPadPosition = default(Vector2);
			Rotation = default(Quaternion);
			Position = default(Vector3);
			Battery = 0;
			TriggerNum = 0;
			GripValue = 0;
			ConnectState = ControllerState.Error;
			SwipeDirection = SwipeDirection.No;
			TouchPadClick = TouchPadClick.No;
			isShowBoundary = false;
		}
	}
	public enum ControllerState
	{
		Error = -1,
		DisConnected,
		Connected
	}
	public enum Pvr_KeyCode
	{
		None = 0,
		APP = 1,
		TOUCHPAD = 2,
		HOME = 4,
		VOLUMEUP = 8,
		VOLUMEDOWN = 16,
		TRIGGER = 32,
		A = 64,
		B = 128,
		X = 256,
		Y = 512,
		Left = 1024,
		Right = 2048,
		Thumbrest = 4096,
		Any = -1
	}
	public enum SwipeDirection
	{
		No,
		SwipeUp,
		SwipeDown,
		SwipeLeft,
		SwipeRight
	}
	public enum TouchPadClick
	{
		No,
		ClickUp,
		ClickDown,
		ClickLeft,
		ClickRight
	}
	[StructLayout(LayoutKind.Sequential, Size = 1)]
	public struct Controller
	{
		private const float JOYSTICK_THRESHOLD = 0.4f;

		public const string LibFileName = "Pvr_UnitySDK";

		public static Vector2 UPvr_GetTouchPadPosition(int hand)
		{
			return hand switch
			{
				0 => Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition, 
				1 => Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition, 
				_ => new Vector2(0f, 0f), 
			};
		}

		public static float UPvr_GetAxis1D(int hand, Pvr_KeyCode key)
		{
			return hand switch
			{
				0 => key switch
				{
					Pvr_KeyCode.TRIGGER => (float)Pvr_ControllerManager.controllerlink.Controller0.TriggerNum / 255f, 
					Pvr_KeyCode.Left => (float)Pvr_ControllerManager.controllerlink.Controller0.GripValue / 255f, 
					_ => 0f, 
				}, 
				1 => key switch
				{
					Pvr_KeyCode.TRIGGER => (float)Pvr_ControllerManager.controllerlink.Controller1.TriggerNum / 255f, 
					Pvr_KeyCode.Right => (float)Pvr_ControllerManager.controllerlink.Controller1.GripValue / 255f, 
					_ => 0f, 
				}, 
				_ => 0f, 
			};
		}

		public static Vector2 UPvr_GetAxis2D(int hand)
		{
			switch (hand)
			{
			case 0:
				if (Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition != Vector2.zero)
				{
					Vector2 result2 = new Vector2(Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition.x / 128f - 1f, Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition.y / 128f - 1f);
					if (result2.x > 1f || result2.x < -1f || result2.y > 1f || result2.y < -1f)
					{
						return Vector2.zero;
					}
					return result2;
				}
				return Vector2.zero;
			case 1:
				if (Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition != Vector2.zero)
				{
					Vector2 result = new Vector2(Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition.x / 128f - 1f, Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition.y / 128f - 1f);
					if (result.x > 1f || result.x < -1f || result.y > 1f || result.y < -1f)
					{
						return Vector2.zero;
					}
					return result;
				}
				return Vector2.zero;
			default:
				return Vector2.zero;
			}
		}

		public static bool UPvr_GetJoystickUp(int hand)
		{
			switch (hand)
			{
			case 0:
				if (Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition != Vector2.zero)
				{
					float value2 = Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition.x / 128f - 1f;
					float num2 = Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition.y / 128f - 1f;
					if (num2 > 0.4f && num2 > Math.Abs(value2))
					{
						return true;
					}
				}
				return false;
			case 1:
				if (Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition != Vector2.zero)
				{
					float value = Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition.x / 128f - 1f;
					float num = Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition.y / 128f - 1f;
					if (num > 0.4f && num > Math.Abs(value))
					{
						return true;
					}
				}
				return false;
			default:
				return false;
			}
		}

		public static bool UPvr_GetJoystickDown(int hand)
		{
			switch (hand)
			{
			case 0:
				if (Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition != Vector2.zero)
				{
					float value2 = Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition.x / 128f - 1f;
					float num2 = Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition.y / 128f - 1f;
					if (0f - num2 > 0.4f && 0f - num2 > Math.Abs(value2))
					{
						return true;
					}
				}
				return false;
			case 1:
				if (Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition != Vector2.zero)
				{
					float value = Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition.x / 128f - 1f;
					float num = Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition.y / 128f - 1f;
					if (0f - num > 0.4f && 0f - num > Math.Abs(value))
					{
						return true;
					}
				}
				return false;
			default:
				return false;
			}
		}

		public static bool UPvr_GetJoystickLeft(int hand)
		{
			switch (hand)
			{
			case 0:
				if (Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition != Vector2.zero)
				{
					float num2 = Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition.x / 128f - 1f;
					float value2 = Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition.y / 128f - 1f;
					if (0f - num2 > 0.4f && 0f - num2 > Math.Abs(value2))
					{
						return true;
					}
				}
				return false;
			case 1:
				if (Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition != Vector2.zero)
				{
					float num = Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition.x / 128f - 1f;
					float value = Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition.y / 128f - 1f;
					if (0f - num > 0.4f && 0f - num > Math.Abs(value))
					{
						return true;
					}
				}
				return false;
			default:
				return false;
			}
		}

		public static bool UPvr_GetJoystickRight(int hand)
		{
			switch (hand)
			{
			case 0:
				if (Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition != Vector2.zero)
				{
					float num2 = Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition.x / 128f - 1f;
					float value2 = Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition.y / 128f - 1f;
					if (num2 > 0.4f && num2 > Math.Abs(value2))
					{
						return true;
					}
				}
				return false;
			case 1:
				if (Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition != Vector2.zero)
				{
					float num = Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition.x / 128f - 1f;
					float value = Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition.y / 128f - 1f;
					if (num > 0.4f && num > Math.Abs(value))
					{
						return true;
					}
				}
				return false;
			default:
				return false;
			}
		}

		public static ControllerState UPvr_GetControllerState(int hand)
		{
			return hand switch
			{
				0 => (ControllerState)Convert.ToInt16(Pvr_ControllerManager.controllerlink.controller0Connected), 
				1 => (ControllerState)Convert.ToInt16(Pvr_ControllerManager.controllerlink.controller1Connected), 
				_ => ControllerState.Error, 
			};
		}

		public static Quaternion UPvr_GetControllerQUA(int hand)
		{
			return hand switch
			{
				0 => Pvr_ControllerManager.controllerlink.Controller0.Rotation, 
				1 => Pvr_ControllerManager.controllerlink.Controller1.Rotation, 
				_ => new Quaternion(0f, 0f, 0f, 1f), 
			};
		}

		public static Vector3 UPvr_GetControllerPOS(int hand)
		{
			return hand switch
			{
				0 => Pvr_ControllerManager.controllerlink.Controller0.Position, 
				1 => Pvr_ControllerManager.controllerlink.Controller1.Position, 
				_ => new Vector3(0f, 0f, 0f), 
			};
		}

		public static Quaternion UPvr_GetControllerPredictRotation(int hand, float predictTime)
		{
			float[] controllerPredictSensorData = Pvr_ControllerManager.controllerlink.GetControllerPredictSensorData(hand, predictTime);
			return new Quaternion(controllerPredictSensorData[0], controllerPredictSensorData[1], controllerPredictSensorData[2], controllerPredictSensorData[3]);
		}

		public static Vector3 UPvr_GetControllerPredictPosition(int hand, float predictTime)
		{
			float[] controllerPredictSensorData = Pvr_ControllerManager.controllerlink.GetControllerPredictSensorData(hand, predictTime);
			return new Vector3(controllerPredictSensorData[4] / 1000f, controllerPredictSensorData[5] / 1000f, (0f - controllerPredictSensorData[6]) / 1000f);
		}

		public static int UPvr_GetControllerTriggerValue(int hand)
		{
			return hand switch
			{
				0 => Pvr_ControllerManager.controllerlink.Controller0.TriggerNum, 
				1 => Pvr_ControllerManager.controllerlink.Controller1.TriggerNum, 
				_ => 0, 
			};
		}

		public static int UPvr_GetControllerPower(int hand)
		{
			return hand switch
			{
				0 => Pvr_ControllerManager.controllerlink.Controller0.Battery, 
				1 => Pvr_ControllerManager.controllerlink.Controller1.Battery, 
				_ => 0, 
			};
		}

		public static int UPvr_GetControllerPowerByPercent(int hand)
		{
			return hand switch
			{
				0 => Pvr_ControllerManager.controllerlink.Controller0.Battery * 20, 
				1 => Pvr_ControllerManager.controllerlink.Controller1.Battery * 20, 
				_ => 0, 
			};
		}

		public static SwipeDirection UPvr_GetSwipeDirection(int hand)
		{
			return hand switch
			{
				0 => Pvr_ControllerManager.controllerlink.Controller0.SwipeDirection, 
				1 => Pvr_ControllerManager.controllerlink.Controller1.SwipeDirection, 
				_ => SwipeDirection.No, 
			};
		}

		public static TouchPadClick UPvr_GetTouchPadClick(int hand)
		{
			return hand switch
			{
				0 => Pvr_ControllerManager.controllerlink.Controller0.TouchPadClick, 
				1 => Pvr_ControllerManager.controllerlink.Controller1.TouchPadClick, 
				_ => TouchPadClick.No, 
			};
		}

		public static bool UPvr_GetKey(int hand, Pvr_KeyCode key)
		{
			bool flag = false;
			if (hand == 0)
			{
				if ((Pvr_KeyCode.APP & key) == Pvr_KeyCode.APP)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.App.State;
				}
				if ((Pvr_KeyCode.HOME & key) == Pvr_KeyCode.HOME)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Home.State;
				}
				if ((Pvr_KeyCode.TOUCHPAD & key) == Pvr_KeyCode.TOUCHPAD)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Touch.State;
				}
				if ((Pvr_KeyCode.VOLUMEUP & key) == Pvr_KeyCode.VOLUMEUP)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.VolumeUp.State;
				}
				if ((Pvr_KeyCode.VOLUMEDOWN & key) == Pvr_KeyCode.VOLUMEDOWN)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.VolumeDown.State;
				}
				if ((Pvr_KeyCode.TRIGGER & key) == Pvr_KeyCode.TRIGGER)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Trigger.State;
				}
				if ((Pvr_KeyCode.X & key) == Pvr_KeyCode.X)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.X.State;
				}
				if ((Pvr_KeyCode.Y & key) == Pvr_KeyCode.Y)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Y.State;
				}
				if ((Pvr_KeyCode.Left & key) == Pvr_KeyCode.Left)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Left.State;
				}
			}
			if (hand == 1)
			{
				if ((Pvr_KeyCode.APP & key) == Pvr_KeyCode.APP)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.App.State;
				}
				if ((Pvr_KeyCode.HOME & key) == Pvr_KeyCode.HOME)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Home.State;
				}
				if ((Pvr_KeyCode.TOUCHPAD & key) == Pvr_KeyCode.TOUCHPAD)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Touch.State;
				}
				if ((Pvr_KeyCode.VOLUMEUP & key) == Pvr_KeyCode.VOLUMEUP)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.VolumeUp.State;
				}
				if ((Pvr_KeyCode.VOLUMEDOWN & key) == Pvr_KeyCode.VOLUMEDOWN)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.VolumeDown.State;
				}
				if ((Pvr_KeyCode.TRIGGER & key) == Pvr_KeyCode.TRIGGER)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Trigger.State;
				}
				if ((Pvr_KeyCode.A & key) == Pvr_KeyCode.A)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.A.State;
				}
				if ((Pvr_KeyCode.B & key) == Pvr_KeyCode.B)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.B.State;
				}
				if ((Pvr_KeyCode.Right & key) == Pvr_KeyCode.Right)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Right.State;
				}
			}
			return flag;
		}

		public static bool UPvr_GetKeyDown(int hand, Pvr_KeyCode key)
		{
			bool flag = false;
			if (hand == 0)
			{
				if ((Pvr_KeyCode.APP & key) == Pvr_KeyCode.APP)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.App.PressedDown;
				}
				if ((Pvr_KeyCode.HOME & key) == Pvr_KeyCode.HOME)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Home.PressedDown;
				}
				if ((Pvr_KeyCode.TOUCHPAD & key) == Pvr_KeyCode.TOUCHPAD)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Touch.PressedDown;
				}
				if ((Pvr_KeyCode.VOLUMEUP & key) == Pvr_KeyCode.VOLUMEUP)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.VolumeUp.PressedDown;
				}
				if ((Pvr_KeyCode.VOLUMEDOWN & key) == Pvr_KeyCode.VOLUMEDOWN)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.VolumeDown.PressedDown;
				}
				if ((Pvr_KeyCode.TRIGGER & key) == Pvr_KeyCode.TRIGGER)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Trigger.PressedDown;
				}
				if ((Pvr_KeyCode.X & key) == Pvr_KeyCode.X)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.X.PressedDown;
				}
				if ((Pvr_KeyCode.Y & key) == Pvr_KeyCode.Y)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Y.PressedDown;
				}
				if ((Pvr_KeyCode.Left & key) == Pvr_KeyCode.Left)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Left.PressedDown;
				}
			}
			if (hand == 1)
			{
				if ((Pvr_KeyCode.APP & key) == Pvr_KeyCode.APP)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.App.PressedDown;
				}
				if ((Pvr_KeyCode.HOME & key) == Pvr_KeyCode.HOME)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Home.PressedDown;
				}
				if ((Pvr_KeyCode.TOUCHPAD & key) == Pvr_KeyCode.TOUCHPAD)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Touch.PressedDown;
				}
				if ((Pvr_KeyCode.VOLUMEUP & key) == Pvr_KeyCode.VOLUMEUP)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.VolumeUp.PressedDown;
				}
				if ((Pvr_KeyCode.VOLUMEDOWN & key) == Pvr_KeyCode.VOLUMEDOWN)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.VolumeDown.PressedDown;
				}
				if ((Pvr_KeyCode.TRIGGER & key) == Pvr_KeyCode.TRIGGER)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Trigger.PressedDown;
				}
				if ((Pvr_KeyCode.A & key) == Pvr_KeyCode.A)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.A.PressedDown;
				}
				if ((Pvr_KeyCode.B & key) == Pvr_KeyCode.B)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.B.PressedDown;
				}
				if ((Pvr_KeyCode.Right & key) == Pvr_KeyCode.Right)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Right.PressedDown;
				}
			}
			return flag;
		}

		public static bool UPvr_GetKeyUp(int hand, Pvr_KeyCode key)
		{
			bool flag = false;
			if (hand == 0)
			{
				if ((Pvr_KeyCode.APP & key) == Pvr_KeyCode.APP)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.App.PressedUp;
				}
				if ((Pvr_KeyCode.HOME & key) == Pvr_KeyCode.HOME)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Home.PressedUp;
				}
				if ((Pvr_KeyCode.TOUCHPAD & key) == Pvr_KeyCode.TOUCHPAD)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Touch.PressedUp;
				}
				if ((Pvr_KeyCode.VOLUMEUP & key) == Pvr_KeyCode.VOLUMEUP)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.VolumeUp.PressedUp;
				}
				if ((Pvr_KeyCode.VOLUMEDOWN & key) == Pvr_KeyCode.VOLUMEDOWN)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.VolumeDown.PressedUp;
				}
				if ((Pvr_KeyCode.TRIGGER & key) == Pvr_KeyCode.TRIGGER)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Trigger.PressedUp;
				}
				if ((Pvr_KeyCode.X & key) == Pvr_KeyCode.X)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.X.PressedUp;
				}
				if ((Pvr_KeyCode.Y & key) == Pvr_KeyCode.Y)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Y.PressedUp;
				}
				if ((Pvr_KeyCode.Left & key) == Pvr_KeyCode.Left)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Left.PressedUp;
				}
			}
			if (hand == 1)
			{
				if ((Pvr_KeyCode.APP & key) == Pvr_KeyCode.APP)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.App.PressedUp;
				}
				if ((Pvr_KeyCode.HOME & key) == Pvr_KeyCode.HOME)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Home.PressedUp;
				}
				if ((Pvr_KeyCode.TOUCHPAD & key) == Pvr_KeyCode.TOUCHPAD)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Touch.PressedUp;
				}
				if ((Pvr_KeyCode.VOLUMEUP & key) == Pvr_KeyCode.VOLUMEUP)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.VolumeUp.PressedUp;
				}
				if ((Pvr_KeyCode.VOLUMEDOWN & key) == Pvr_KeyCode.VOLUMEDOWN)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.VolumeDown.PressedUp;
				}
				if ((Pvr_KeyCode.TRIGGER & key) == Pvr_KeyCode.TRIGGER)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Trigger.PressedUp;
				}
				if ((Pvr_KeyCode.A & key) == Pvr_KeyCode.A)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.A.PressedUp;
				}
				if ((Pvr_KeyCode.B & key) == Pvr_KeyCode.B)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.B.PressedUp;
				}
				if ((Pvr_KeyCode.Right & key) == Pvr_KeyCode.Right)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Right.PressedUp;
				}
			}
			return flag;
		}

		public static bool UPvr_GetTouch(int hand, Pvr_KeyCode key)
		{
			bool flag = false;
			if (hand == 0)
			{
				if ((Pvr_KeyCode.TOUCHPAD & key) == Pvr_KeyCode.TOUCHPAD)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Touch.Touch;
				}
				if ((Pvr_KeyCode.TRIGGER & key) == Pvr_KeyCode.TRIGGER)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Trigger.Touch;
				}
				if ((Pvr_KeyCode.X & key) == Pvr_KeyCode.X)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.X.Touch;
				}
				if ((Pvr_KeyCode.Y & key) == Pvr_KeyCode.Y)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Y.Touch;
				}
				if ((Pvr_KeyCode.Thumbrest & key) == Pvr_KeyCode.Thumbrest)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Thumbrest.Touch;
				}
			}
			if (hand == 1)
			{
				if ((Pvr_KeyCode.TOUCHPAD & key) == Pvr_KeyCode.TOUCHPAD)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Touch.Touch;
				}
				if ((Pvr_KeyCode.TRIGGER & key) == Pvr_KeyCode.TRIGGER)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Trigger.Touch;
				}
				if ((Pvr_KeyCode.A & key) == Pvr_KeyCode.A)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.A.Touch;
				}
				if ((Pvr_KeyCode.B & key) == Pvr_KeyCode.B)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.B.Touch;
				}
				if ((Pvr_KeyCode.Thumbrest & key) == Pvr_KeyCode.Thumbrest)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Thumbrest.Touch;
				}
			}
			return flag;
		}

		public static bool UPvr_GetTouchDown(int hand, Pvr_KeyCode key)
		{
			bool flag = false;
			if (hand == 0)
			{
				if ((Pvr_KeyCode.TOUCHPAD & key) == Pvr_KeyCode.TOUCHPAD)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Touch.TouchDown;
				}
				if ((Pvr_KeyCode.TRIGGER & key) == Pvr_KeyCode.TRIGGER)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Trigger.TouchDown;
				}
				if ((Pvr_KeyCode.X & key) == Pvr_KeyCode.X)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.X.TouchDown;
				}
				if ((Pvr_KeyCode.Y & key) == Pvr_KeyCode.Y)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Y.TouchDown;
				}
				if ((Pvr_KeyCode.Thumbrest & key) == Pvr_KeyCode.Thumbrest)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Thumbrest.TouchDown;
				}
			}
			if (hand == 1)
			{
				if ((Pvr_KeyCode.TOUCHPAD & key) == Pvr_KeyCode.TOUCHPAD)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Touch.TouchDown;
				}
				if ((Pvr_KeyCode.TRIGGER & key) == Pvr_KeyCode.TRIGGER)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Trigger.TouchDown;
				}
				if ((Pvr_KeyCode.A & key) == Pvr_KeyCode.A)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.A.TouchDown;
				}
				if ((Pvr_KeyCode.B & key) == Pvr_KeyCode.B)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.B.TouchDown;
				}
				if ((Pvr_KeyCode.Thumbrest & key) == Pvr_KeyCode.Thumbrest)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Thumbrest.TouchDown;
				}
			}
			return flag;
		}

		public static bool UPvr_GetTouchUp(int hand, Pvr_KeyCode key)
		{
			bool flag = false;
			if (hand == 0)
			{
				if ((Pvr_KeyCode.TOUCHPAD & key) == Pvr_KeyCode.TOUCHPAD)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Touch.TouchUp;
				}
				if ((Pvr_KeyCode.TRIGGER & key) == Pvr_KeyCode.TRIGGER)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Trigger.TouchUp;
				}
				if ((Pvr_KeyCode.X & key) == Pvr_KeyCode.X)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.X.TouchUp;
				}
				if ((Pvr_KeyCode.Y & key) == Pvr_KeyCode.Y)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Y.TouchUp;
				}
				if ((Pvr_KeyCode.Thumbrest & key) == Pvr_KeyCode.Thumbrest)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Thumbrest.TouchUp;
				}
			}
			if (hand == 1)
			{
				if ((Pvr_KeyCode.TOUCHPAD & key) == Pvr_KeyCode.TOUCHPAD)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Touch.TouchUp;
				}
				if ((Pvr_KeyCode.TRIGGER & key) == Pvr_KeyCode.TRIGGER)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Trigger.TouchUp;
				}
				if ((Pvr_KeyCode.A & key) == Pvr_KeyCode.A)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.A.TouchUp;
				}
				if ((Pvr_KeyCode.B & key) == Pvr_KeyCode.B)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.B.TouchUp;
				}
				if ((Pvr_KeyCode.Thumbrest & key) == Pvr_KeyCode.Thumbrest)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Thumbrest.TouchUp;
				}
			}
			return flag;
		}

		public static bool UPvr_GetKeyClick(int hand, Pvr_KeyCode key)
		{
			bool flag = false;
			if (hand == 0)
			{
				if ((Pvr_KeyCode.APP & key) == Pvr_KeyCode.APP)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.App.Click;
				}
				if ((Pvr_KeyCode.HOME & key) == Pvr_KeyCode.HOME)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Home.Click;
				}
				if ((Pvr_KeyCode.TOUCHPAD & key) == Pvr_KeyCode.TOUCHPAD)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Touch.Click;
				}
				if ((Pvr_KeyCode.VOLUMEUP & key) == Pvr_KeyCode.VOLUMEUP)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.VolumeUp.Click;
				}
				if ((Pvr_KeyCode.VOLUMEDOWN & key) == Pvr_KeyCode.VOLUMEDOWN)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.VolumeDown.Click;
				}
				if ((Pvr_KeyCode.TRIGGER & key) == Pvr_KeyCode.TRIGGER)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Trigger.Click;
				}
				if ((Pvr_KeyCode.X & key) == Pvr_KeyCode.X)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.X.Click;
				}
				if ((Pvr_KeyCode.Y & key) == Pvr_KeyCode.Y)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Y.Click;
				}
				if ((Pvr_KeyCode.Left & key) == Pvr_KeyCode.Left)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Left.Click;
				}
			}
			if (hand == 1)
			{
				if ((Pvr_KeyCode.APP & key) == Pvr_KeyCode.APP)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.App.Click;
				}
				if ((Pvr_KeyCode.HOME & key) == Pvr_KeyCode.HOME)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Home.Click;
				}
				if ((Pvr_KeyCode.TOUCHPAD & key) == Pvr_KeyCode.TOUCHPAD)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Touch.Click;
				}
				if ((Pvr_KeyCode.VOLUMEUP & key) == Pvr_KeyCode.VOLUMEUP)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.VolumeUp.Click;
				}
				if ((Pvr_KeyCode.VOLUMEDOWN & key) == Pvr_KeyCode.VOLUMEDOWN)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.VolumeDown.Click;
				}
				if ((Pvr_KeyCode.TRIGGER & key) == Pvr_KeyCode.TRIGGER)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Trigger.Click;
				}
				if ((Pvr_KeyCode.A & key) == Pvr_KeyCode.A)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.A.Click;
				}
				if ((Pvr_KeyCode.B & key) == Pvr_KeyCode.B)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.B.Click;
				}
				if ((Pvr_KeyCode.Right & key) == Pvr_KeyCode.Right)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Right.Click;
				}
			}
			return flag;
		}

		public static bool UPvr_GetKeyLongPressed(int hand, Pvr_KeyCode key)
		{
			bool flag = false;
			if (hand == 0)
			{
				if ((Pvr_KeyCode.APP & key) == Pvr_KeyCode.APP)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.App.LongPressed;
				}
				if ((Pvr_KeyCode.HOME & key) == Pvr_KeyCode.HOME)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Home.LongPressed;
				}
				if ((Pvr_KeyCode.TOUCHPAD & key) == Pvr_KeyCode.TOUCHPAD)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Touch.LongPressed;
				}
				if ((Pvr_KeyCode.VOLUMEUP & key) == Pvr_KeyCode.VOLUMEUP)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.VolumeUp.LongPressed;
				}
				if ((Pvr_KeyCode.VOLUMEDOWN & key) == Pvr_KeyCode.VOLUMEDOWN)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.VolumeDown.LongPressed;
				}
				if ((Pvr_KeyCode.TRIGGER & key) == Pvr_KeyCode.TRIGGER)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Trigger.LongPressed;
				}
				if ((Pvr_KeyCode.X & key) == Pvr_KeyCode.X)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.X.LongPressed;
				}
				if ((Pvr_KeyCode.Y & key) == Pvr_KeyCode.Y)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Y.LongPressed;
				}
				if ((Pvr_KeyCode.Left & key) == Pvr_KeyCode.Left)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller0.Left.LongPressed;
				}
			}
			if (hand == 1)
			{
				if ((Pvr_KeyCode.APP & key) == Pvr_KeyCode.APP)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.App.LongPressed;
				}
				if ((Pvr_KeyCode.HOME & key) == Pvr_KeyCode.HOME)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Home.LongPressed;
				}
				if ((Pvr_KeyCode.TOUCHPAD & key) == Pvr_KeyCode.TOUCHPAD)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Touch.LongPressed;
				}
				if ((Pvr_KeyCode.VOLUMEUP & key) == Pvr_KeyCode.VOLUMEUP)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.VolumeUp.LongPressed;
				}
				if ((Pvr_KeyCode.VOLUMEDOWN & key) == Pvr_KeyCode.VOLUMEDOWN)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.VolumeDown.LongPressed;
				}
				if ((Pvr_KeyCode.TRIGGER & key) == Pvr_KeyCode.TRIGGER)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Trigger.LongPressed;
				}
				if ((Pvr_KeyCode.A & key) == Pvr_KeyCode.A)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.A.LongPressed;
				}
				if ((Pvr_KeyCode.B & key) == Pvr_KeyCode.B)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.B.LongPressed;
				}
				if ((Pvr_KeyCode.Right & key) == Pvr_KeyCode.Right)
				{
					flag |= Pvr_ControllerManager.controllerlink.Controller1.Right.LongPressed;
				}
			}
			return flag;
		}

		public static bool UPvr_IsTouching(int hand)
		{
			switch (hand)
			{
			case 0:
				if (!(Math.Abs(Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition.x) > 0f))
				{
					return Math.Abs(Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition.y) > 0f;
				}
				return true;
			case 1:
				if (!(Math.Abs(Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition.x) > 0f))
				{
					return Math.Abs(Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition.y) > 0f;
				}
				return true;
			default:
				return false;
			}
		}

		public static void UPvr_SetHandNess(Pvr_Controller.UserHandNess hand)
		{
			if (Pvr_ControllerManager.controllerlink.getHandness() != (int)hand)
			{
				Pvr_ControllerManager.controllerlink.setHandness((int)hand);
			}
		}

		public static Pvr_Controller.UserHandNess UPvr_GetHandNess()
		{
			return Pvr_ControllerManager.controllerlink.handness;
		}

		public static int UPvr_GetPreferenceDevice()
		{
			int trackingmode = Pvr_ControllerManager.controllerlink.trackingmode;
			int systemProp = Pvr_ControllerManager.controllerlink.systemProp;
			if (trackingmode == 0 || trackingmode == 1 || ((trackingmode == 3 || trackingmode == 5 || trackingmode == 6) && (systemProp == 1 || systemProp == 3)))
			{
				return 1;
			}
			return 2;
		}

		public static bool UPvr_IsEnbleTrigger()
		{
			return Pvr_ControllerManager.controllerlink.IsEnbleTrigger();
		}

		public static int UPvr_GetDeviceType()
		{
			return Pvr_ControllerManager.controllerlink.controllerType;
		}

		public static int UPvr_GetMainHandNess()
		{
			return Pvr_ControllerManager.controllerlink.mainHandID;
		}

		public static void UPvr_SetMainHandNess(int hand)
		{
			Pvr_ControllerManager.controllerlink.SetMainController(hand);
		}

		public static int UPvr_GetControllerAbility(int hand)
		{
			return Pvr_ControllerManager.controllerlink.GetControllerAbility(hand);
		}

		public static void UPvr_VibrateNeo2Controller(float strength, int time, int hand)
		{
			Pvr_ControllerManager.controllerlink.VibrateNeo2Controller(strength, time, hand);
		}

		public static void UPvr_VibrateController(float strength, int time, int hand)
		{
			Pvr_ControllerManager.controllerlink.VibrateController(strength, time, hand);
		}

		public static int UPvr_GetControllerBindingState(int hand)
		{
			return Pvr_ControllerManager.controllerlink.GetControllerBindingState(hand);
		}

		public static Vector3 UPvr_GetVelocity(int hand)
		{
			return Pvr_ControllerManager.controllerlink.GetVelocity(hand);
		}

		public static Vector3 UPvr_GetAngularVelocity(int hand)
		{
			return Pvr_ControllerManager.controllerlink.GetAngularVelocity(hand);
		}

		public static Vector3 UPvr_GetAcceleration(int hand)
		{
			return Pvr_ControllerManager.controllerlink.GetAcceleration(hand);
		}

		public static Vector3 UPvr_GetAngularAcceleration(int hand)
		{
			return Pvr_ControllerManager.controllerlink.GetAngularAcceleration(hand);
		}

		public static void UPvr_ScanController()
		{
			Pvr_ControllerManager.controllerlink.StartScan();
		}

		public static void UPvr_StopScanController()
		{
			Pvr_ControllerManager.controllerlink.StopScan();
		}

		public static void UPvr_ConnectController(string mac)
		{
			if (mac != "")
			{
				Pvr_ControllerManager.controllerlink.hummingBirdMac = mac;
			}
			Pvr_ControllerManager.controllerlink.ConnectBLE();
		}

		public static void UPvr_DisConnectController()
		{
			Pvr_ControllerManager.controllerlink.DisConnectBLE();
		}

		public static void UPvr_ResetController(int hand)
		{
			Pvr_ControllerManager.controllerlink.ResetController(hand);
		}

		public static string UPvr_GetControllerVersion()
		{
			return Pvr_ControllerManager.controllerlink.GetControllerVersion();
		}

		public static void UPvr_GetDeviceVersion(int deviceType)
		{
			Pvr_ControllerManager.controllerlink.GetDeviceVersion(deviceType);
		}

		public static void UPvr_GetControllerSnCode(int controllerSerialNum)
		{
			Pvr_ControllerManager.controllerlink.GetControllerSnCode(controllerSerialNum);
		}

		public static void UPvr_SetControllerUnbind(int controllerSerialNum)
		{
			Pvr_ControllerManager.controllerlink.SetControllerUnbind(controllerSerialNum);
		}

		public static void UPvr_SetStationRestart()
		{
			Pvr_ControllerManager.controllerlink.SetStationRestart();
		}

		public static void UPvr_StartStationOtaUpdate()
		{
			Pvr_ControllerManager.controllerlink.StartStationOtaUpdate();
		}

		public static void UPvr_StartControllerOtaUpdate(int mode, int controllerSerialNum)
		{
			Pvr_ControllerManager.controllerlink.StartControllerOtaUpdate(mode, controllerSerialNum);
		}

		public static void UPvr_EnterPairMode(int controllerSerialNum)
		{
			Pvr_ControllerManager.controllerlink.EnterPairMode(controllerSerialNum);
		}

		public static void UPvr_SetControllerShutdown(int controllerSerialNum)
		{
			Pvr_ControllerManager.controllerlink.SetControllerShutdown(controllerSerialNum);
		}

		public static int UPvr_GetStationPairState()
		{
			return Pvr_ControllerManager.controllerlink.GetStationPairState();
		}

		public static int UPvr_GetStationOtaUpdateProgress()
		{
			return Pvr_ControllerManager.controllerlink.GetStationOtaUpdateProgress();
		}

		public static int UPvr_GetControllerOtaUpdateProgress()
		{
			return Pvr_ControllerManager.controllerlink.GetControllerOtaUpdateProgress();
		}

		public static void UPvr_GetControllerVersionAndSN(int controllerSerialNum)
		{
			Pvr_ControllerManager.controllerlink.GetControllerVersionAndSN(controllerSerialNum);
		}

		public static void UPvr_GetControllerUniqueID()
		{
			Pvr_ControllerManager.controllerlink.GetControllerUniqueID();
		}

		public void UPvr_InterruptStationPairMode()
		{
			Pvr_ControllerManager.controllerlink.InterruptStationPairMode();
		}

		public void UPvr_StartCV2PairingMode(int deviceType)
		{
			Pvr_ControllerManager.controllerlink.StartCV2PairingMode(deviceType);
		}

		public void UPvr_StopCV2PairingMode(int deviceType)
		{
			Pvr_ControllerManager.controllerlink.StopCV2PairingMode(deviceType);
		}

		public static void UPvr_SetArmModelParameters(int hand, int gazeType, float elbowHeight, float elbowDepth, float pointerTiltAngle)
		{
			Pvr_SetArmModelParameters(hand, gazeType, elbowHeight, elbowDepth, pointerTiltAngle);
		}

		public static void UPvr_CalcArmModelParameters(float[] headOrientation, float[] controllerOrientation, float[] controllerPrimary)
		{
			Pvr_CalcArmModelParameters(headOrientation, controllerOrientation, controllerPrimary);
		}

		public static void UPvr_GetPointerPose(float[] rotation, float[] position)
		{
			Pvr_GetPointerPose(rotation, position);
		}

		public static void UPvr_GetElbowPose(float[] rotation, float[] position)
		{
			Pvr_GetElbowPose(rotation, position);
		}

		public static void UPvr_GetWristPose(float[] rotation, float[] position)
		{
			Pvr_GetWristPose(rotation, position);
		}

		public static void UPvr_GetShoulderPose(float[] rotation, float[] position)
		{
			Pvr_GetShoulderPose(rotation, position);
		}

		public static void UPvr_IsEnbleHomeKey(bool state)
		{
			Pvr_ControllerManager.controllerlink.setIsEnbleHomeKey(state);
		}

		public static void UPvr_SwitchHomeKey(bool state)
		{
			Pvr_ControllerManager.controllerlink.SwitchHomeKey(state);
		}

		public static int UPvr_GetControllerSensorStatus(int id)
		{
			return Pvr_ControllerManager.controllerlink.getControllerSensorStatus(id);
		}

		public static void UPvr_SetControllerOriginOffset(int hand, Vector3 offset)
		{
			switch (hand)
			{
			case 0:
				Pvr_Controller.originOffsetL = offset;
				break;
			case 1:
				Pvr_Controller.originOffsetR = offset;
				break;
			}
		}

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_CalcArmModelParameters(float[] headOrientation, float[] controllerOrientation, float[] gyro);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_GetPointerPose(float[] rotation, float[] position);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_GetElbowPose(float[] rotation, float[] position);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_GetWristPose(float[] rotation, float[] position);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_GetShoulderPose(float[] rotation, float[] position);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetArmModelParameters(int hand, int gazeType, float elbowHeight, float elbowDepth, float pointerTiltAngle);
	}
	public enum ControllerVariety
	{
		Controller0,
		Controller1
	}
	public enum ControllerDevice
	{
		Goblin,
		Neo,
		G2,
		Neo2,
		Neo3,
		NewController
	}
	public enum PBS_SystemInfoEnum
	{
		ELECTRIC_QUANTITY,
		PUI_VERSION,
		EQUIPMENT_MODEL,
		EQUIPMENT_SN,
		CUSTOMER_SN,
		INTERNAL_STORAGE_SPACE_OF_THE_DEVICE,
		DEVICE_BLUETOOTH_STATUS,
		BLUETOOTH_NAME_CONNECTED,
		BLUETOOTH_MAC_ADDRESS,
		DEVICE_WIFI_STATUS,
		WIFI_NAME_CONNECTED,
		WLAN_MAC_ADDRESS,
		DEVICE_IP
	}
	public enum PBS_DeviceControlEnum
	{
		DEVICE_CONTROL_REBOOT,
		DEVICE_CONTROL_SHUTDOWN
	}
	public enum PBS_PackageControlEnum
	{
		PACKAGE_SILENCE_INSTALL,
		PACKAGE_SILENCE_UNINSTALL
	}
	public enum PBS_SwitchEnum
	{
		S_ON,
		S_OFF
	}
	public enum PBS_HomeEventEnum
	{
		SINGLE_CLICK,
		DOUBLE_CLICK,
		LONG_PRESS
	}
	public enum PBS_HomeFunctionEnum
	{
		VALUE_HOME_GO_TO_SETTING,
		VALUE_HOME_BACK,
		VALUE_HOME_RECENTER,
		VALUE_HOME_OPEN_APP,
		VALUE_HOME_DISABLE,
		VALUE_HOME_GO_TO_HOME,
		VALUE_HOME_SEND_BROADCAST,
		VALUE_HOME_CLEAN_MEMORY
	}
	public enum PBS_ScreenOffDelayTimeEnum
	{
		THREE = 3,
		TEN = 10,
		THIRTY = 30,
		SIXTY = 60,
		THREE_HUNDRED = 300,
		SIX_HUNDRED = 600,
		NEVER = -1
	}
	public enum PBS_SleepDelayTimeEnum
	{
		FIFTEEN = 15,
		THIRTY = 30,
		SIXTY = 60,
		THREE_HUNDRED = 300,
		SIX_HUNDRED = 600,
		ONE_THOUSAND_AND_EIGHT_HUNDRED = 1800,
		NEVER = -1
	}
	public enum PBS_SystemFunctionSwitchEnum
	{
		SFS_USB,
		SFS_AUTOSLEEP,
		SFS_SCREENON_CHARGING,
		SFS_OTG_CHARGING,
		SFS_RETURN_MENU_IN_2DMODE,
		SFS_COMBINATION_KEY,
		SFS_CALIBRATION_WITH_POWER_ON,
		SFS_SYSTEM_UPDATE,
		SFS_CAST_SERVICE,
		SFS_EYE_PROTECTION,
		SFS_SECURITY_ZONE_PERMANENTLY,
		SFS_GLOBAL_CALIBRATION,
		SFS_Auto_Calibration,
		SFS_USB_BOOT,
		SFS_VOLUME_UI,
		SFS_CONTROLLER_UI,
		SFS_NAVGATION_SWITCH
	}
	public enum PBS_USBConfigModeEnum
	{
		MTP,
		CHARGE
	}
	[StructLayout(LayoutKind.Sequential, Size = 1)]
	public struct ToBService
	{
		public static Action<bool> BoolCallback;

		public static Action<int> IntCallback;

		public static Action<long> LongCallback;

		public static Action<string> StringCallback;

		private static AndroidJavaClass unityPlayer;

		private static AndroidJavaObject currentActivity;

		private static AndroidJavaObject tobHelper;

		private static AndroidJavaClass tobHelperClass;

		public static void UPvr_InitToBService()
		{
			tobHelperClass = new AndroidJavaClass("com.pvr.tobservice.ToBServiceHelper");
			tobHelper = tobHelperClass.CallStatic<AndroidJavaObject>("getInstance", Array.Empty<object>());
			unityPlayer = new AndroidJavaClass("com.unity3d.player.UnityPlayer");
			currentActivity = unityPlayer.GetStatic<AndroidJavaObject>("currentActivity");
		}

		public static void UPvr_SetUnityObjectName(string obj)
		{
			System.UPvr_CallMethod(tobHelper, "setUnityObjectName", obj);
		}

		public static void UPvr_BindToBService()
		{
			System.UPvr_CallMethod(tobHelper, "bindTobService", currentActivity);
		}

		public static void UPvr_UnBindToBService()
		{
			System.UPvr_CallMethod(tobHelper, "unBindTobService", currentActivity);
		}

		private static AndroidJavaObject GetEnumType(Enum enumType)
		{
			return new AndroidJavaClass("com.pvr.tobservice.enums" + enumType.GetType().ToString().Replace("Pvr_UnitySDKAPI", "")).GetStatic<AndroidJavaObject>(enumType.ToString());
		}

		public static string UPvr_StateGetDeviceInfo(PBS_SystemInfoEnum type)
		{
			string result = "";
			System.UPvr_CallMethod(ref result, tobHelper, "pbsStateGetDeviceInfo", GetEnumType(type), 0);
			return result;
		}

		public static void UPvr_ControlSetDeviceAction(PBS_DeviceControlEnum deviceControl, Action<int> callback)
		{
			if (callback != null)
			{
				IntCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsControlSetDeviceAction", GetEnumType(deviceControl), null);
		}

		public static void UPvr_ControlAPPManger(PBS_PackageControlEnum packageControl, string path, Action<int> callback)
		{
			if (callback != null)
			{
				IntCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsControlAPPManger", GetEnumType(packageControl), path, 0, null);
		}

		public static void UPvr_ControlSetAutoConnectWIFI(string ssid, string pwd, Action<bool> callback)
		{
			if (callback != null)
			{
				BoolCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsControlSetAutoConnectWIFI", ssid, pwd, 0, null);
		}

		public static void UPvr_ControlClearAutoConnectWIFI(Action<bool> callback)
		{
			if (callback != null)
			{
				BoolCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsControlClearAutoConnectWIFI", null);
		}

		public static void UPvr_PropertySetHomeKey(PBS_HomeEventEnum eventEnum, PBS_HomeFunctionEnum function, Action<bool> callback)
		{
			if (callback != null)
			{
				BoolCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsPropertySetHomeKey", GetEnumType(eventEnum), GetEnumType(function), null);
		}

		public static void UPvr_PropertySetHomeKeyAll(PBS_HomeEventEnum eventEnum, PBS_HomeFunctionEnum function, int timesetup, string pkg, string className, Action<bool> callback)
		{
			if (callback != null)
			{
				BoolCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsPropertySetHomeKeyAll", GetEnumType(eventEnum), GetEnumType(function), timesetup, pkg, className, null);
		}

		public static void UPvr_PropertyDisablePowerKey(bool isSingleTap, bool enable, Action<int> callback)
		{
			if (callback != null)
			{
				IntCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsPropertyDisablePowerKey", isSingleTap, enable, null);
		}

		public static void UPvr_PropertySetScreenOffDelay(PBS_ScreenOffDelayTimeEnum timeEnum, Action<int> callback)
		{
			if (callback != null)
			{
				IntCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsPropertySetScreenOffDelay", GetEnumType(timeEnum), null);
		}

		public static void UPvr_PropertySetSleepDelay(PBS_SleepDelayTimeEnum timeEnum)
		{
			System.UPvr_CallMethod(tobHelper, "pbsPropertySetSleepDelay", GetEnumType(timeEnum));
		}

		public static void UPvr_SwitchSystemFunction(PBS_SystemFunctionSwitchEnum systemFunction, PBS_SwitchEnum switchEnum)
		{
			System.UPvr_CallMethod(tobHelper, "pbsSwitchSystemFunction", GetEnumType(systemFunction), GetEnumType(switchEnum), 0);
		}

		public static void UPvr_SwitchSetUsbConfigurationOption(PBS_USBConfigModeEnum uSBConfigModeEnum)
		{
			System.UPvr_CallMethod(tobHelper, "pbsSwitchSetUsbConfigurationOption", GetEnumType(uSBConfigModeEnum), 0);
		}

		public static void UPvr_ScreenOn()
		{
			System.UPvr_CallMethod(tobHelper, "pbsScreenOn");
		}

		public static void UPvr_ScreenOff()
		{
			System.UPvr_CallMethod(tobHelper, "pbsScreenOff");
		}

		public static void UPvr_AcquireWakeLock()
		{
			System.UPvr_CallMethod(tobHelper, "pbsAcquireWakeLock");
		}

		public static void UPvr_ReleaseWakeLock()
		{
			System.UPvr_CallMethod(tobHelper, "pbsReleaseWakeLock");
		}

		public static void UPvr_EnableEnterKey()
		{
			System.UPvr_CallMethod(tobHelper, "pbsEnableEnterKey");
		}

		public static void UPvr_DisableEnterKey()
		{
			System.UPvr_CallMethod(tobHelper, "pbsDisableEnterKey");
		}

		public static void UPvr_EnableVolumeKey()
		{
			System.UPvr_CallMethod(tobHelper, "pbsEnableVolumeKey");
		}

		public static void UPvr_DisableVolumeKey()
		{
			System.UPvr_CallMethod(tobHelper, "pbsDisableVolumeKey");
		}

		public static void UPvr_EnableBackKey()
		{
			System.UPvr_CallMethod(tobHelper, "pbsEnableBackKey");
		}

		public static void UPvr_DisableBackKey()
		{
			System.UPvr_CallMethod(tobHelper, "pbsDisableBackKey");
		}

		public static void UPvr_WriteConfigFileToDataLocal(string path, string content, Action<bool> callback)
		{
			if (callback != null)
			{
				BoolCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsWriteConfigFileToDataLocal", path, content, null);
		}

		public static void UPvr_ResetAllKeyToDefault(Action<bool> callback)
		{
			if (callback != null)
			{
				BoolCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsResetAllKeyToDefault", null);
		}

		public static void UPvr_SetAPPAsHome(PBS_SwitchEnum switchEnum, string packageName)
		{
			System.UPvr_CallMethod(tobHelper, "pbsAppSetAPPAsHomeTwo", GetEnumType(switchEnum), packageName);
		}

		public static void UPvr_KillAppsByPidOrPackageName(int[] pids, string[] packageNames)
		{
			System.UPvr_CallMethod(tobHelper, "pbsKillAppsByPidOrPackageName", pids, packageNames, 0);
		}

		public static void UPvr_FreezeScreen(bool freeze)
		{
			System.UPvr_CallMethod(tobHelper, "pbsFreezeScreen", freeze);
		}

		public static void UPvr_OpenMiracast()
		{
			System.UPvr_CallMethod(tobHelper, "pbsOpenMiracast");
		}

		public static bool UPvr_IsMiracastOn()
		{
			bool result = false;
			System.UPvr_CallMethod(ref result, tobHelper, "pbsIsMiracastOn");
			return result;
		}

		public static void UPvr_CloseMiracast()
		{
			System.UPvr_CallMethod(tobHelper, "pbsCloseMiracast");
		}

		public static void UPvr_StartScan()
		{
			System.UPvr_CallMethod(tobHelper, "pbsStartScan");
		}

		public static void UPvr_StopScan()
		{
			System.UPvr_CallMethod(tobHelper, "pbsStopScan");
		}

		public static void UPvr_ConnectWifiDisplay(string modelJson)
		{
			System.UPvr_CallMethod(tobHelper, "pbsUnityConnectWifiDisplay", modelJson);
		}

		public static void UPvr_DisConnectWifiDisplay()
		{
			System.UPvr_CallMethod(tobHelper, "pbsDisConnectWifiDisplay");
		}

		public static void UPvr_ForgetWifiDisplay(string address)
		{
			System.UPvr_CallMethod(tobHelper, "pbsForgetWifiDisplay", address);
		}

		public static void UPvr_RenameWifiDisplay(string address, string newName)
		{
			System.UPvr_CallMethod(tobHelper, "pbsRenameWifiDisplay", address, newName);
		}

		public static void UPvr_SetWDModelsCallback()
		{
			System.UPvr_CallMethod(tobHelper, "pbsSetWDModelsCallback", null);
		}

		public static void UPvr_SetWDJsonCallback()
		{
			System.UPvr_CallMethod(tobHelper, "pbsSetWDJsonCallback", null);
		}

		public static void UPvr_UpdateWifiDisplays(Action<string> callback)
		{
			if (callback != null)
			{
				StringCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsUpdateWifiDisplays");
		}

		public static string UPvr_GetConnectedWD()
		{
			string result = "";
			System.UPvr_CallMethod(ref result, tobHelper, "pbsUnityGetConnectedWD");
			return result;
		}
	}
	public enum GlobalIntConfigs
	{
		EYE_TEXTURE_RESOLUTION0,
		EYE_TEXTURE_RESOLUTION1,
		SEENSOR_COUNT,
		ABILITY6DOF,
		PLATFORM_TYPE,
		TRACKING_MODE,
		LOG_LEVEL,
		ENBLE_HAND6DOF_BY_HEAD,
		ENBLE_6DOF_GLOBAL_TRACKING,
		TARGET_FRAME_RATE,
		iShowFPS,
		SensorMode,
		LOGICFLOW,
		EYE_TEXTURE_RES_HIGH,
		EYE_TEXTURE_RES_NORMAL,
		iCtrlModelLoadingPri,
		iPhoneHMDModeEnabled,
		isEnableBoundary,
		Enable_Activity_Rotation,
		GetDisplay_Orientation,
		GetWaitFrameNum,
		GetResetFrameNum,
		EnableFFRBYSYS,
		RotControllerMode
	}
	public enum GlobalFloatConfigs
	{
		IPD,
		VFOV,
		HFOV,
		NECK_MODEL_X,
		NECK_MODEL_Y,
		NECK_MODEL_Z,
		DISPLAY_REFRESH_RATE
	}
	public enum RenderTextureAntiAliasing
	{
		X_1 = 1,
		X_2 = 2,
		X_4 = 4,
		X_8 = 8
	}
	public enum PlatForm
	{
		Android = 1,
		IOS,
		Win,
		Notsupport
	}
	public enum RenderTextureDepth
	{
		BD_0 = 0,
		BD_16 = 16,
		BD_24 = 24
	}
	public enum RenderTextureLevel
	{
		Normal,
		High
	}
	public enum Sensorindex
	{
		Default,
		FirstSensor,
		SecondSensor
	}
	public enum Eye
	{
		LeftEye,
		RightEye,
		BothEye
	}
	public enum ResUtilsType
	{
		TYPE_TEXTSIZE,
		TYPE_COLOR,
		TYPE_TEXT,
		TYPE_FONT,
		TYPE_VALUE,
		TYPE_DRAWABLE,
		TYPE_OBJECT,
		TYPR_OBJECTARRAY
	}
	public enum TrackingOrigin
	{
		EyeLevel,
		FloorLevel,
		StageLevel
	}
	public enum EFoveationLevel
	{
		Low,
		Med,
		High,
		Top_High
	}
	public enum StereoRenderingPathPico
	{
		MultiPass,
		SinglePass
	}
	public enum ExtraLatencyMode
	{
		ExtraLatencyModeOff,
		ExtraLatencyModeOn,
		ExtraLatencyModeDynamic
	}
	public enum pvrEyePoseStatus
	{
		kGazePointValid = 1,
		kGazeVectorValid = 2,
		kEyeOpennessValid = 4,
		kEyePupilDilationValid = 8,
		kEyePositionGuideValid = 0x10
	}
	public enum TrackingMode
	{
		PVR_TRACKING_MODE_ROTATION = 1,
		PVR_TRACKING_MODE_POSITION = 2,
		PVR_TRACKING_MODE_EYE = 4
	}
	public enum SystemDisplayFrequency
	{
		Default,
		RefreshRate72,
		RefreshRate90
	}
	public struct EyeTrackingData
	{
		public int leftEyePoseStatus;

		public int rightEyePoseStatus;

		public int combinedEyePoseStatus;

		public Vector3 leftEyeGazePoint;

		public Vector3 rightEyeGazePoint;

		public Vector3 combinedEyeGazePoint;

		public Vector3 leftEyeGazeVector;

		public Vector3 rightEyeGazeVector;

		public Vector3 combinedEyeGazeVector;

		public float leftEyeOpenness;

		public float rightEyeOpenness;

		public float leftEyePupilDilation;

		public float rightEyePupilDilation;

		public Vector3 leftEyePositionGuide;

		public Vector3 rightEyePositionGuide;

		public Vector3 foveatedGazeDirection;

		public int foveatedGazeTrackingState;

		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 8)]
		public byte[] reserved;
	}
	public struct EyeTrackingGazeRay
	{
		public Vector3 Direction;

		public bool IsValid;

		public Vector3 Origin;
	}
	public struct EyeDeviceInfo
	{
		public ViewFrustum targetFrustumLeft;

		public ViewFrustum targetFrustumRight;
	}
	public struct ViewFrustum
	{
		public float left;

		public float right;

		public float top;

		public float bottom;

		public float near;

		public float far;
	}
	public struct EyeSetting
	{
		public Transform eyelocalPosition;

		public Rect eyeRect;

		public float eyeFov;

		public float eyeAspect;

		public Matrix4x4 eyeProjectionMatrix;

		public Shader eyeShader;
	}
	[StructLayout(LayoutKind.Sequential, Size = 1)]
	public struct Sensor
	{
		public const string LibFileName = "Pvr_UnitySDK";

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_Enable6DofModule(bool enable);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_OptionalResetSensor(int index, int resetRot, int resetPos);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_Init(int index);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_StartSensor(int index);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_StopSensor(int index);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_ResetSensor(int index);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_ResetSensorAll(int index);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetSensorState(int index, ref float x, ref float y, ref float z, ref float w, ref float px, ref float py, ref float pz);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetMainSensorState(ref float x, ref float y, ref float z, ref float w, ref float px, ref float py, ref float pz, ref float vfov, ref float hfov, ref int viewNumber);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetPsensorState();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetHmdPSensorStatus();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetSensorGyroscope(int index, ref float x, ref float y, ref float z);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetSensorMagnet(int index, ref float x, ref float y, ref float z);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_Get6DofSensorQualityStatus();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_Get6DofSafePanelFlag();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetReinPosition(float x, float y, float z, float w, float px, float py, float pz, int hand, bool valid, int key);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_SetTrackingOriginType(TrackingOrigin trackingOriginType);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_GetAcceleration(ref float x, ref float y, ref float z);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_GetAngularVelocity(ref float x, ref float y, ref float z);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_GetVelocity(ref float x, ref float y, ref float z);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_GetAngularAcceleration(ref float x, ref float y, ref float z);

		public static bool UPvr_Pvr_Get6DofSafePanelFlag()
		{
			return Pvr_Get6DofSafePanelFlag();
		}

		public static int UPvr_Init(int index)
		{
			return Pvr_Init(index);
		}

		public static void UPvr_InitPsensor()
		{
			Pvr_InitPsensor();
		}

		public static int UPvr_GetPsensorState()
		{
			int res = -1;
			Render.UPvr_GetIntConfig(4, ref res);
			if (res == 1)
			{
				return Pvr_GetPsensorState();
			}
			int num = Pvr_GetAndroidPsensorState();
			if (num != 0 && num != -1)
			{
				num = 1;
			}
			return num;
		}

		public static int UPvr_GetPSensorStatus()
		{
			return Pvr_GetHmdPSensorStatus();
		}

		public static void UPvr_UnregisterPsensor()
		{
			Pvr_UnregisterPsensor();
		}

		public static int UPvr_StartSensor(int index)
		{
			return Pvr_StartSensor(index);
		}

		public static int UPvr_StopSensor(int index)
		{
			return Pvr_StopSensor(index);
		}

		public static int UPvr_ResetSensor(int index)
		{
			Pvr_UnitySDKManager.SDK.resetBasePos = default(Vector3);
			return Pvr_ResetSensor(index);
		}

		public static int UPvr_OptionalResetSensor(int index, int resetRot, int resetPos)
		{
			return Pvr_OptionalResetSensor(index, resetRot, resetPos);
		}

		public static int UPvr_GetSensorState(int index, ref float x, ref float y, ref float z, ref float w, ref float px, ref float py, ref float pz)
		{
			return Pvr_GetSensorState(index, ref x, ref y, ref z, ref w, ref px, ref py, ref pz);
		}

		public static int UPvr_GetMainSensorState(ref float x, ref float y, ref float z, ref float w, ref float px, ref float py, ref float pz, ref float vfov, ref float hfov, ref int viewNumber)
		{
			return Pvr_GetMainSensorState(ref x, ref y, ref z, ref w, ref px, ref py, ref pz, ref vfov, ref hfov, ref viewNumber);
		}

		public static int UPvr_GetSensorGyroscope(int index, ref float x, ref float y, ref float z)
		{
			return Pvr_GetSensorGyroscope(index, ref x, ref y, ref z);
		}

		public static int UPvr_GetSensorMagnet(int index, ref float x, ref float y, ref float z)
		{
			return Pvr_GetSensorMagnet(index, ref x, ref y, ref z);
		}

		public static int UPvr_Get6DofSensorQualityStatus()
		{
			return Pvr_Get6DofSensorQualityStatus();
		}

		public static int UPvr_Enable6DofModule(bool enable)
		{
			return Pvr_Enable6DofModule(enable);
		}

		public static void Pvr_InitPsensor()
		{
			try
			{
				System.UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaSysActivityClass, "initPsensor", Pvr_UnitySDKRender.Instance.activity);
			}
			catch (Exception ex)
			{
				PLOG.E("Error :" + ex.ToString());
			}
		}

		public static bool Pvr_IsHead6dofReset()
		{
			int res = 0;
			Render.UPvr_GetIntConfig(17, ref res);
			if (res > 0)
			{
				return false;
			}
			bool result = false;
			try
			{
				System.UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaSysActivityClass, "isHead6dofReset", Pvr_UnitySDKRender.Instance.activity);
			}
			catch (Exception ex)
			{
				PLOG.E("Error :" + ex.ToString());
			}
			return result;
		}

		public static int Pvr_GetAndroidPsensorState()
		{
			int result = -1;
			try
			{
				System.UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaSysActivityClass, "getPsensorState");
			}
			catch (Exception ex)
			{
				PLOG.E("Error :" + ex.ToString());
			}
			return result;
		}

		public static void Pvr_UnregisterPsensor()
		{
			try
			{
				System.UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaSysActivityClass, "unregisterListener");
			}
			catch (Exception ex)
			{
				PLOG.E("Error :" + ex.ToString());
			}
		}

		public static int UPvr_ResetSensorAll(int index)
		{
			return Pvr_ResetSensorAll(index);
		}

		public static void UPvr_SetReinPosition(float x, float y, float z, float w, float px, float py, float pz, int hand, bool valid, int key)
		{
			if (PLOG.logLevel > 2)
			{
				PLOG.D("PvrLog UPvr_SetReinPosition" + x + y + z + w + px + py + pz + hand + valid.ToString() + key);
			}
			Pvr_SetReinPosition(x, y, z, w, px, py, pz, hand, valid, key);
		}

		public static bool UPvr_SetTrackingOriginType(TrackingOrigin trackingOriginType)
		{
			return Pvr_SetTrackingOriginType(trackingOriginType);
		}

		public static Vector3 UPvr_GetAcceleration()
		{
			float x = 0f;
			float y = 0f;
			float z = 0f;
			Pvr_GetAcceleration(ref x, ref y, ref z);
			return new Vector3(x, y, 0f - z);
		}

		public static Vector3 UPvr_AngularVelocity()
		{
			float x = 0f;
			float y = 0f;
			float z = 0f;
			Pvr_GetAngularVelocity(ref x, ref y, ref z);
			return new Vector3(0f - x, 0f - y, z);
		}

		public static Vector3 UPvr_GetVelocity()
		{
			float x = 0f;
			float y = 0f;
			float z = 0f;
			Pvr_GetVelocity(ref x, ref y, ref z);
			return new Vector3(x, y, 0f - z);
		}

		public static Vector3 UPvr_GetAngularAcceleration()
		{
			float x = 0f;
			float y = 0f;
			float z = 0f;
			Pvr_GetAngularAcceleration(ref x, ref y, ref z);
			return new Vector3(0f - x, 0f - y, z);
		}
	}
	[StructLayout(LayoutKind.Sequential, Size = 1)]
	public struct Render
	{
		public const string LibFileName = "Pvr_UnitySDK";

		public static float[] SystemDisplayFrequenciesAvailable => UPvr_GetDisplayFrequenciesAvailable();

		public static float systemDisplayFrequency
		{
			get
			{
				return UPvr_GetSystemDisplayFrequency();
			}
			set
			{
				UPvr_SetSystemDisplayFrequency(value);
			}
		}

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_ChangeScreenParameters(string model, int width, int height, double xppi, double yppi, double densityDpi);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_SetRatio(float midH, float midV);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_SetPupillaryPoint(bool enable);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr Pvr_GetSupportHMDTypes();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetCurrentHMDType([MarshalAs(UnmanagedType.LPStr)] string type);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetIntConfig(int configsenum, ref int res);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetFloatConfig(int configsenum, ref float res);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetupLayerData(int layerIndex, int sideMask, int textureId, int textureType, int layerFlags, float[] colorScaleAndOffset);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetupLayerCoords(int layerIndex, int sideMask, float[] lowerLeft, float[] lowerRight, float[] upperLeft, float[] upperRight);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetOverlayModelViewMatrix(int overlayType, int overlayShape, int texId, int eyeSide, int layerIndex, bool isHeadLocked, int layerFlags, float[] mvMatrix, float[] modelS, float[] modelR, float[] modelT, float[] cameraR, float[] cameraT, float[] colorScaleAndOffset);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_EnableFoveation(bool enable);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetFoveationParameters(int textureId, int previousId, float focalPointX, float focalPointY, float foveationGainX, float foveationGainY, float foveationArea, float foveationMinimum);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetFoveationResource(int textureId, int previousId, float focalPointX, float focalPointY);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetFoveationParameters2(float foveationGainX, float foveationGainY, float foveationArea, float foveationMinimum);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetFoveationLevel(EFoveationLevel level);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern EFoveationLevel Pvr_GetFoveationLevel();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_GetIntSysProc(string property, ref int res);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetColorspaceType(int colorspaceType);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetCastingColorspaceType(int colorspaceType);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr Pvr_CreateLayerAndroidSurface(int layerType, int layerIndex);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr Pvr_GetLayerAndroidSurface(int layerType, int layerIndex);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetMonoMode(bool openMono);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_GetStencilMesh(int eye, ref int vertexCount, ref int triangleCount, ref IntPtr vertexData, ref IntPtr indexData);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetRefreshRate(ref float rate);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_SetRefreshRate(float rate);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_GetRawCameraFrame(byte[] buffer, ref uint width, ref uint height, ref uint count);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetDisplayFrequenciesAvailable(float[] rate, int length);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_SetDisplayFrequency(float rate);

		public static float[] UPvr_GetDisplayFrequenciesAvailable()
		{
			float[] array = new float[2];
			int length = 0;
			Pvr_GetDisplayFrequenciesAvailable(array, length);
			return array;
		}

		public static void UPvr_SetDisplayFrequency(float rate)
		{
			Pvr_SetDisplayFrequency(rate);
		}

		public static void UPvr_GetRawCameraData(byte[] buffer, ref uint width, ref uint height, ref uint count)
		{
			Pvr_GetRawCameraFrame(buffer, ref width, ref height, ref count);
		}

		public static void UPvr_ChangeScreenParameters(string model, int width, int height, double xppi, double yppi, double densityDpi)
		{
			Pvr_ChangeScreenParameters(model, width, height, xppi, yppi, densityDpi);
		}

		public static int UPvr_SetRatio(float midH, float midV)
		{
			return Pvr_SetRatio(midH, midV);
		}

		public static void UPvr_EnableFoveation(bool enable)
		{
			if (Pvr_UnitySDKManager.SDK.SystemFFRLevel != -1 || Pvr_UnitySDKManager.SDK.SystemDebugFFRLevel != -1)
			{
				enable = true;
			}
			Pvr_EnableFoveation(enable);
		}

		[Obsolete("This API will be removed in later versions")]
		public static void UPvr_SetFoveationParameters(int textureId, int previousId, float focalPointX, float focalPointY, float foveationGainX, float foveationGainY, float foveationArea, float foveationMinimum)
		{
			Pvr_SetFoveationParameters(textureId, previousId, focalPointX, focalPointY, foveationGainX, foveationGainY, foveationArea, foveationMinimum);
		}

		public static void UPvr_SetFoveationResource(int textureId, int previousId, float focalPointX, float focalPointY)
		{
			Pvr_SetFoveationResource(textureId, previousId, focalPointX, focalPointY);
		}

		public static void SetFoveatedRenderingLevel(EFoveationLevel level)
		{
			if (Pvr_UnitySDKManager.SDK.SystemDebugFFRLevel != -1)
			{
				Pvr_SetFoveationLevel((EFoveationLevel)Pvr_UnitySDKManager.SDK.SystemDebugFFRLevel);
			}
			else if (Pvr_UnitySDKManager.SDK.SystemFFRLevel != -1)
			{
				Pvr_SetFoveationLevel((EFoveationLevel)Pvr_UnitySDKManager.SDK.SystemFFRLevel);
			}
			else
			{
				Pvr_SetFoveationLevel(level);
			}
		}

		public static EFoveationLevel GetFoveatedRenderingLevel()
		{
			return Pvr_GetFoveationLevel();
		}

		public static void SetFoveatedRenderingParameters(Vector2 ffrGainValue, float ffrAreaValue, float ffrMinimumValue)
		{
			if (Pvr_UnitySDKManager.SDK.SystemDebugFFRLevel != -1)
			{
				Pvr_SetFoveationLevel((EFoveationLevel)Pvr_UnitySDKManager.SDK.SystemDebugFFRLevel);
			}
			else if (Pvr_UnitySDKManager.SDK.SystemFFRLevel != -1)
			{
				Pvr_SetFoveationLevel((EFoveationLevel)Pvr_UnitySDKManager.SDK.SystemFFRLevel);
			}
			else
			{
				Pvr_SetFoveationParameters2(ffrGainValue.x, ffrGainValue.y, ffrAreaValue, ffrMinimumValue);
			}
		}

		public static bool UPvr_GetIntSysProc(string property, ref int res)
		{
			return Pvr_GetIntSysProc(property, ref res);
		}

		public static int UPvr_GetIntConfig(int configsenum, ref int res)
		{
			return Pvr_GetIntConfig(configsenum, ref res);
		}

		public static int UPvr_GetFloatConfig(int configsenum, ref float res)
		{
			return Pvr_GetFloatConfig(configsenum, ref res);
		}

		public static string UPvr_GetSupportHMDTypes()
		{
			IntPtr intPtr = Pvr_GetSupportHMDTypes();
			if (intPtr != IntPtr.Zero)
			{
				return Marshal.PtrToStringAnsi(intPtr);
			}
			return null;
		}

		public static void UPvr_SetCurrentHMDType(string type)
		{
			Pvr_SetCurrentHMDType(type);
		}

		public static void UPvr_SetupLayerData(int layerIndex, int sideMask, int textureId, int textureType, int layerFlags, Vector4 colorScale, Vector4 colorOffset)
		{
			Pvr_SetupLayerData(layerIndex, sideMask, textureId, textureType, layerFlags, new float[8] { colorScale.x, colorScale.y, colorScale.z, colorScale.w, colorOffset.x, colorOffset.y, colorOffset.z, colorOffset.w });
		}

		public static void UPvr_SetupLayerCoords(int layerIndex, int sideMask, float[] lowerLeft, float[] lowerRight, float[] upperLeft, float[] upperRight)
		{
			Pvr_SetupLayerCoords(layerIndex, sideMask, lowerLeft, lowerRight, upperLeft, upperRight);
		}

		public static void UPvr_SetOverlayModelViewMatrix(int overlayType, int overlayShape, int texId, int eyeSide, int layerIndex, bool isHeadLocked, int layerFlags, Matrix4x4 mvMatrix, Vector3 modelS, Quaternion modelR, Vector3 modelT, Quaternion cameraR, Vector3 cameraT, Vector4 colorScale, Vector4 colorOffset)
		{
			Pvr_SetOverlayModelViewMatrix(overlayType, overlayShape, texId, eyeSide, layerIndex, isHeadLocked, layerFlags, new float[16]
			{
				mvMatrix.m00, mvMatrix.m01, mvMatrix.m02, mvMatrix.m03, mvMatrix.m10, mvMatrix.m11, mvMatrix.m12, mvMatrix.m13, mvMatrix.m20, mvMatrix.m21,
				mvMatrix.m22, mvMatrix.m23, mvMatrix.m30, mvMatrix.m31, mvMatrix.m32, mvMatrix.m33
			}, new float[3] { modelS.x, modelS.y, modelS.z }, new float[4] { modelR.x, modelR.y, modelR.z, modelR.w }, new float[3] { modelT.x, modelT.y, modelT.z }, new float[4] { cameraR.x, cameraR.y, cameraR.z, cameraR.w }, new float[3] { cameraT.x, cameraT.y, cameraT.z }, new float[8] { colorScale.x, colorScale.y, colorScale.z, colorScale.w, colorOffset.x, colorOffset.y, colorOffset.z, colorOffset.w });
		}

		public static void UPvr_SetColorspaceType(int colorspaceType)
		{
			Pvr_SetColorspaceType(colorspaceType);
		}

		public static void UPvr_SetCastingColorspaceType(int colorspaceType)
		{
			Pvr_SetCastingColorspaceType(colorspaceType);
		}

		public static IntPtr UPvr_CreateLayerAndroidSurface(int layerType, int layerIndex)
		{
			return Pvr_CreateLayerAndroidSurface(layerType, layerIndex);
		}

		public static IntPtr UPvr_GetLayerAndroidSurface(int layerType, int layerIndex)
		{
			return Pvr_GetLayerAndroidSurface(layerType, layerIndex);
		}

		public static void UPvr_SetMonoMode(bool openMono)
		{
			PLOG.I("PvrLog SetMonoMode : " + openMono);
			Pvr_SetMonoMode(openMono);
		}

		public static void UPvr_GetStencilMesh(int eye, ref int vertexCount, ref int triangleCount, ref IntPtr vertexDataPtr, ref IntPtr indexDataPtr)
		{
			Pvr_GetStencilMesh(eye, ref vertexCount, ref triangleCount, ref vertexDataPtr, ref indexDataPtr);
		}

		public static float UPvr_GetSystemDisplayFrequency()
		{
			float rate = 0f;
			Pvr_GetRefreshRate(ref rate);
			return rate;
		}

		public static void UPvr_SetSystemDisplayFrequency(float rate)
		{
			Pvr_SetRefreshRate(rate);
		}
	}
	[StructLayout(LayoutKind.Sequential, Size = 1)]
	public struct System
	{
		public const string LibFileName = "Pvr_UnitySDK";

		public const string UnitySDKVersion = "2.8.11.5";

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void Pvr_SetInitActivity(IntPtr activity, IntPtr vrActivityClass);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr Pvr_GetSDKVersion();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern int Pvr_GetHmdHardwareVersion();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr Pvr_GetHmdFirmwareVersion();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr Pvr_GetHmdSerialNumber();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern int PVR_GetHmdBatteryStatus();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern float PVR_GetHmdBatteryTemperature();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern int PVR_SetHmdAudioStatus(bool enable);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool Pvr_GetEyeTrackingData(ref int leftEyePoseStatus, ref int rightEyePoseStatus, ref int combinedEyePoseStatus, ref float leftEyeGazePointX, ref float leftEyeGazePointY, ref float leftEyeGazePointZ, ref float rightEyeGazePointX, ref float rightEyeGazePointY, ref float rightEyeGazePointZ, ref float combinedEyeGazePointX, ref float combinedEyeGazePointY, ref float combinedEyeGazePointZ, ref float leftEyeGazeVectorX, ref float leftEyeGazeVectorY, ref float leftEyeGazeVectorZ, ref float rightEyeGazeVectorX, ref float rightEyeGazeVectorY, ref float rightEyeGazeVectorZ, ref float combinedEyeGazeVectorX, ref float combinedEyeGazeVectorY, ref float combinedEyeGazeVectorZ, ref float leftEyeOpenness, ref float rightEyeOpenness, ref float leftEyePupilDilation, ref float rightEyePupilDilation, ref float leftEyePositionGuideX, ref float leftEyePositionGuideY, ref float leftEyePositionGuideZ, ref float rightEyePositionGuideX, ref float rightEyePositionGuideY, ref float rightEyePositionGuideZ, ref float foveatedGazeDirectionX, ref float foveatedGazeDirectionY, ref float foveatedGazeDirectionZ, ref int foveatedGazeTrackingState);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool Pvr_SetTrackingMode(int trackingMode);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern int Pvr_GetTrackingMode();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr GetRenderEventFunc();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void UnityEventData(long data);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool Pvr_EnableSinglePass(bool enable);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void Pvr_SetAntiAliasing(int antiAliasing);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void Pvr_SinglePassBeforeForwardOpaque();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void Pvr_SetCurrentRenderTexture(uint textureId);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool Pvr_SetSinglePassDepthBufferWidthHeight(int width, int height);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern int PVR_setPerformanceLevels(int cpuLevel, int gpuLevel);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool Pvr_SetIPD(float distance);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern float Pvr_GetIPD();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool Pvr_SetTrackingIPDEnabled(bool enable);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool Pvr_GetTrackingIPDEnabled();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool Pvr_GetEyeTrackingAutoIPD(ref float autoIPD);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern int PVR_GetHmdAudioStatus();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern float Pvr_GetPredictedDisplayTime();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool Pvr_SetExtraLatencyMode(int mode);

		public static bool UPvr_CallStaticMethod<T>(ref T result, AndroidJavaClass jclass, string name, params object[] args)
		{
			try
			{
				result = jclass.CallStatic<T>(name, args);
				return true;
			}
			catch (AndroidJavaException ex)
			{
				PLOG.E("Exception calling static method " + name + ": " + ex);
				return false;
			}
		}

		public static bool UPvr_CallStaticMethod(AndroidJavaObject jobj, string name, params object[] args)
		{
			try
			{
				jobj.CallStatic(name, args);
				return true;
			}
			catch (AndroidJavaException ex)
			{
				PLOG.E("CallStaticMethod  Exception calling activity method " + name + ": " + ex);
				return false;
			}
		}

		public static bool UPvr_CallMethod<T>(ref T result, AndroidJavaObject jobj, string name, params object[] args)
		{
			try
			{
				result = jobj.Call<T>(name, args);
				return true;
			}
			catch (AndroidJavaException ex)
			{
				PLOG.E("Exception calling activity method " + name + ": " + ex);
				return false;
			}
		}

		public static bool UPvr_CallMethod(AndroidJavaObject jobj, string name, params object[] args)
		{
			try
			{
				jobj.Call(name, args);
				return true;
			}
			catch (AndroidJavaException ex)
			{
				PLOG.E(" Exception calling activity method " + name + ": " + ex);
				return false;
			}
		}

		public static string UPvr_GetSDKVersion()
		{
			IntPtr intPtr = Pvr_GetSDKVersion();
			if (intPtr != IntPtr.Zero)
			{
				return Marshal.PtrToStringAnsi(intPtr);
			}
			return "";
		}

		public static string UPvr_GetUnitySDKVersion()
		{
			return "2.8.11.5";
		}

		public static string UPvr_GetDeviceMode()
		{
			return SystemInfo.deviceModel;
		}

		public static string UPvr_GetDeviceModel()
		{
			return SystemInfo.deviceModel;
		}

		public static string UPvr_GetDeviceSN()
		{
			string result = "UNKONWN";
			UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaSysActivityClass, "getDeviceSN");
			return result;
		}

		public static AndroidJavaObject UPvr_GetCurrentActivity()
		{
			return new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
		}

		public static bool UPvr_SetMonoPresentation()
		{
			return UPvr_CallMethod(UPvr_GetCurrentActivity(), "Pvr_setMonoPresentation");
		}

		public static bool UPvr_IsPresentationExisted()
		{
			bool result = false;
			return UPvr_CallMethod(ref result, UPvr_GetCurrentActivity(), "Pvr_isPresentationExisted") && result;
		}

		public static bool UPvr_GetMainActivityPauseStatus()
		{
			bool result = false;
			return UPvr_CallMethod(ref result, UPvr_GetCurrentActivity(), "Pvr_getMainActivityPauseStatus") && result;
		}

		public static void UPvr_Sleep()
		{
			UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaSysActivityClass, "Pvr_Sleep");
		}

		public static bool UPvr_StartHomeKeyReceiver(string startreceivre)
		{
			try
			{
				if (Pvr_UnitySDKRender.Instance != null)
				{
					UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaVrActivityLongReceiver, "Pvr_StartReceiver", Pvr_UnitySDKRender.Instance.activity, startreceivre);
					PLOG.I("Start home key Receiver");
					return true;
				}
			}
			catch (Exception ex)
			{
				PLOG.E("Start home key  Receiver  Error :" + ex.ToString());
				return false;
			}
			return true;
		}

		public static bool UPvr_StopHomeKeyReceiver()
		{
			try
			{
				if (Pvr_UnitySDKRender.Instance != null)
				{
					UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaVrActivityLongReceiver, "Pvr_StopReceiver", Pvr_UnitySDKRender.Instance.activity);
					PLOG.I("Stop home key Receiver");
					return true;
				}
			}
			catch (Exception ex)
			{
				PLOG.E("Stop home key Receiver Error :" + ex.ToString());
				return false;
			}
			return true;
		}

		public static void UPvr_StartVRModel()
		{
			UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaVrActivityClass, "startVRModel");
		}

		public static void UPvr_RemovePlatformLogo()
		{
			UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaVrActivityClass, "removePlatformLogo");
		}

		public static void UPvr_ShowPlatformLogo()
		{
			UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaVrActivityClass, "showPlatformLogo");
		}

		public static bool UPvr_IsPicoActivity()
		{
			bool result = false;
			return UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "isPicoActivity", UPvr_GetCurrentActivity()) && result;
		}

		public static void UPvr_StopVRModel()
		{
			UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaVrActivityClass, "stopVRModel");
		}

		public static string UPvr_GetCountryCode()
		{
			string result = "";
			UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getCountryCode", UPvr_GetCurrentActivity());
			return result;
		}

		public static bool UPvr_SetIPD(float distance)
		{
			bool flag = false;
			flag = Pvr_SetIPD(distance);
			if (flag)
			{
				for (int i = 0; i < Pvr_UnitySDKEyeManager.Instance.Eyes.Length; i++)
				{
					Pvr_UnitySDKEyeManager.Instance.Eyes[i].RefreshCameraPosition(distance);
				}
			}
			return flag;
		}

		public static float UPvr_GetIPD()
		{
			float num = Pvr_GetIPD();
			UnityEngine.Debug.Log("DISFT IPD:" + num);
			return num;
		}

		public static bool UPvr_SetTrackingIPDEnabled(bool enable)
		{
			return Pvr_SetTrackingIPDEnabled(enable);
		}

		public static bool UPvr_GetTrackingIPDEnabled()
		{
			return Pvr_GetTrackingIPDEnabled();
		}

		public static bool UPvr_GetEyeTrackingAutoIPD(ref float autoipd)
		{
			return Pvr_GetEyeTrackingAutoIPD(ref autoipd);
		}

		public static void UPvr_UnityEventData(long data)
		{
			UnityEventData(data);
		}

		public static long UPvr_GetEyeBufferData(int id)
		{
			return ((long)Pvr_UnitySDKRender.Instance.RenderviewNumber << 32) | id;
		}

		public static bool UPvr_checkDevice(string packagename)
		{
			bool result = false;
			UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "checkDevice", packagename, UPvr_GetCurrentActivity());
			return result;
		}

		public static int UPvr_GetHmdHardwareVersion()
		{
			return Pvr_GetHmdHardwareVersion();
		}

		public static string UPvr_GetHmdFirmwareVersion()
		{
			IntPtr intPtr = Pvr_GetHmdFirmwareVersion();
			if (intPtr != IntPtr.Zero)
			{
				return Marshal.PtrToStringAnsi(intPtr);
			}
			return "";
		}

		public static string UPvr_GetHmdSerialNumber()
		{
			IntPtr intPtr = Pvr_GetHmdSerialNumber();
			if (intPtr != IntPtr.Zero)
			{
				return Marshal.PtrToStringAnsi(intPtr);
			}
			return "";
		}

		public static int UPvr_GetHmdBatteryStatus()
		{
			return PVR_GetHmdBatteryStatus();
		}

		public static float UPvr_GetHmdBatteryTemperature()
		{
			return PVR_GetHmdBatteryTemperature();
		}

		public static int UPvr_SetHmdAudioStatus(bool enable)
		{
			return PVR_SetHmdAudioStatus(enable);
		}

		public static int UPvr_GetTrackingMode()
		{
			return Pvr_GetTrackingMode();
		}

		public static bool UPvr_setTrackingMode(int trackingMode)
		{
			return Pvr_SetTrackingMode(trackingMode);
		}

		public static bool UPvr_getEyeTrackingData(ref EyeTrackingData trackingData)
		{
			if (!Pvr_UnitySDKEyeManager.supportEyeTracking)
			{
				PLOG.E("The device is not supported");
				return false;
			}
			if (!Pvr_UnitySDKEyeManager.Instance.EyeTracking)
			{
				PLOG.E("Please Enable \"Pvr_UnitySDK/Head/Pvr_UnitySDKEyeManager.cs/EyeTracking\"option first.");
				return false;
			}
			bool result = Pvr_GetEyeTrackingData(ref trackingData.leftEyePoseStatus, ref trackingData.rightEyePoseStatus, ref trackingData.combinedEyePoseStatus, ref trackingData.leftEyeGazePoint.x, ref trackingData.leftEyeGazePoint.y, ref trackingData.leftEyeGazePoint.z, ref trackingData.rightEyeGazePoint.x, ref trackingData.rightEyeGazePoint.y, ref trackingData.rightEyeGazePoint.z, ref trackingData.combinedEyeGazePoint.x, ref trackingData.combinedEyeGazePoint.y, ref trackingData.combinedEyeGazePoint.z, ref trackingData.leftEyeGazeVector.x, ref trackingData.leftEyeGazeVector.y, ref trackingData.leftEyeGazeVector.z, ref trackingData.rightEyeGazeVector.x, ref trackingData.rightEyeGazeVector.y, ref trackingData.rightEyeGazeVector.z, ref trackingData.combinedEyeGazeVector.x, ref trackingData.combinedEyeGazeVector.y, ref trackingData.combinedEyeGazeVector.z, ref trackingData.leftEyeOpenness, ref trackingData.rightEyeOpenness, ref trackingData.leftEyePupilDilation, ref trackingData.rightEyePupilDilation, ref trackingData.leftEyePositionGuide.x, ref trackingData.leftEyePositionGuide.y, ref trackingData.leftEyePositionGuide.z, ref trackingData.rightEyePositionGuide.x, ref trackingData.rightEyePositionGuide.y, ref trackingData.rightEyePositionGuide.z, ref trackingData.foveatedGazeDirection.x, ref trackingData.foveatedGazeDirection.y, ref trackingData.foveatedGazeDirection.z, ref trackingData.foveatedGazeTrackingState);
			trackingData.leftEyeGazeVector.z = 0f - trackingData.leftEyeGazeVector.z;
			trackingData.rightEyeGazeVector.z = 0f - trackingData.rightEyeGazeVector.z;
			trackingData.combinedEyeGazeVector.z = 0f - trackingData.combinedEyeGazeVector.z;
			trackingData.leftEyeGazePoint.z = 0f - trackingData.leftEyeGazePoint.z;
			trackingData.rightEyeGazePoint.z = 0f - trackingData.rightEyeGazePoint.z;
			trackingData.combinedEyeGazePoint.z = 0f - trackingData.combinedEyeGazePoint.z;
			trackingData.foveatedGazeDirection.z = 0f - trackingData.foveatedGazeDirection.z;
			return result;
		}

		public static bool UPvr_getEyeTrackingGazeRay(ref EyeTrackingGazeRay gazeRay)
		{
			if (!Pvr_UnitySDKEyeManager.supportEyeTracking)
			{
				PLOG.E("The device is not supported");
				return false;
			}
			if (!Pvr_UnitySDKEyeManager.Instance.EyeTracking)
			{
				PLOG.E("Please Enable \"Pvr_UnitySDK/Head/Pvr_UnitySDKEyeManager.cs/EyeTracking\"option first.");
				return false;
			}
			EyeTrackingData trackingData = default(EyeTrackingData);
			UPvr_getEyeTrackingData(ref trackingData);
			gazeRay.IsValid = ((uint)trackingData.combinedEyePoseStatus & (true ? 1u : 0u)) != 0 && (trackingData.combinedEyePoseStatus & 2) != 0;
			if (gazeRay.IsValid)
			{
				gazeRay.Direction = trackingData.combinedEyeGazeVector;
				gazeRay.Origin = trackingData.combinedEyeGazePoint;
				gazeRay.Origin = Pvr_UnitySDKSensor.Instance.HeadPose.Matrix.MultiplyPoint(gazeRay.Origin);
				gazeRay.Direction = Pvr_UnitySDKSensor.Instance.HeadPose.Matrix.MultiplyVector(gazeRay.Direction);
				return true;
			}
			return false;
		}

		public static bool UPvr_getEyeTrackingGazeRayWorld(ref EyeTrackingGazeRay gazeRay)
		{
			if (!Pvr_UnitySDKEyeManager.supportEyeTracking)
			{
				PLOG.E("The device is not supported");
				return false;
			}
			if (!Pvr_UnitySDKEyeManager.Instance.EyeTracking)
			{
				PLOG.E("Please Enable \"Pvr_UnitySDK/Head/Pvr_UnitySDKEyeManager.cs/EyeTracking\"option first.");
				return false;
			}
			Transform transform = Pvr_UnitySDKEyeManager.Instance.transform;
			Matrix4x4 matrix4x = Matrix4x4.TRS(transform.position, transform.rotation, Vector3.one);
			EyeTrackingData trackingData = default(EyeTrackingData);
			UPvr_getEyeTrackingData(ref trackingData);
			gazeRay.IsValid = ((uint)trackingData.combinedEyePoseStatus & (true ? 1u : 0u)) != 0 && (trackingData.combinedEyePoseStatus & 2) != 0;
			if (gazeRay.IsValid)
			{
				gazeRay.Direction = trackingData.combinedEyeGazeVector;
				gazeRay.Origin = trackingData.combinedEyeGazePoint;
				gazeRay.Origin = matrix4x.MultiplyPoint(gazeRay.Origin);
				gazeRay.Direction = matrix4x.MultiplyVector(gazeRay.Direction);
				return true;
			}
			return false;
		}

		public static Vector3 UPvr_getEyeTrackingPos()
		{
			if (!Pvr_UnitySDKEyeManager.supportEyeTracking)
			{
				PLOG.E("The device is not supported");
				return Vector3.zero;
			}
			if (!Pvr_UnitySDKEyeManager.Instance.EyeTracking)
			{
				PLOG.E("Please Enable \"Pvr_UnitySDK/Head/Pvr_UnitySDKEyeManager.cs/EyeTracking\"option first.");
				return Vector3.zero;
			}
			return Pvr_UnitySDKEyeManager.Instance.GetEyeTrackingPos();
		}

		public static int UPvr_GetPhoneScreenBrightness()
		{
			int result = 0;
			UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClientClass, "Pvr_GetScreen_Brightness", UPvr_GetCurrentActivity());
			return result;
		}

		public static void UPvr_SetPhoneScreenBrightness(int level)
		{
			UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaVrActivityClientClass, "Pvr_setAPPScreen_Brightness", UPvr_GetCurrentActivity(), level);
		}

		public static bool UPvr_IsPicoDefaultActivity()
		{
			using (AndroidJavaClass androidJavaClass = new AndroidJavaClass("com.unity3d.player.UnityPlayer"))
			{
				using AndroidJavaObject androidJavaObject = androidJavaClass.GetStatic<AndroidJavaObject>("currentActivity");
				if (androidJavaObject.Call<string>("getLocalClassName", Array.Empty<object>()) == "com.unity3d.player.UnityPlayerNativeActivityPico")
				{
					return true;
				}
			}
			return false;
		}

		public static bool UPvr_EnableSinglePass(bool enable)
		{
			return Pvr_EnableSinglePass(enable);
		}

		public static void UPvr_SetAntiAliasing(int antiAliasing)
		{
			Pvr_SetAntiAliasing(antiAliasing);
		}

		public static void UPvr_SinglePassBeforeForwardOpaque()
		{
			Pvr_SinglePassBeforeForwardOpaque();
		}

		public static void UPvr_SetCurrentRenderTexture(uint textureId)
		{
			Pvr_SetCurrentRenderTexture(textureId);
		}

		public static bool UPvr_SetSinglePassDepthBufferWidthHeight(int width, int height)
		{
			return Pvr_SetSinglePassDepthBufferWidthHeight(width, height);
		}

		public static int UPVR_setPerformanceLevels(int cpuLevel, int gpuLevel)
		{
			return PVR_setPerformanceLevels(cpuLevel, gpuLevel);
		}

		public static int UPvr_GetColorRes(string name)
		{
			int result = -1;
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getColorRes", name);
			}
			catch (Exception ex)
			{
				PLOG.E("GetColorResError :" + ex.ToString());
			}
			return result;
		}

		public static int UPvr_GetConfigInt(string name)
		{
			int result = -1;
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getConfigInt", name);
			}
			catch (Exception ex)
			{
				PLOG.E("GetConfigIntError :" + ex.ToString());
			}
			return result;
		}

		public static string UPvr_GetConfigString(string name)
		{
			string result = "";
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getConfigString", name);
			}
			catch (Exception ex)
			{
				PLOG.E("GetConfigStringError :" + ex.ToString());
			}
			return result;
		}

		public static string UPvr_GetDrawableLocation(string name)
		{
			string result = "";
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getDrawableLocation", name);
			}
			catch (Exception ex)
			{
				PLOG.E("GetDrawableLocationError :" + ex.ToString());
			}
			return result;
		}

		public static int UPvr_GetTextSize(string name)
		{
			int result = -1;
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getTextSize", name);
			}
			catch (Exception ex)
			{
				PLOG.E("GetTextSizeError :" + ex.ToString());
			}
			return result;
		}

		public static string UPvr_GetLangString(string name)
		{
			string result = "";
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getLangString", name);
			}
			catch (Exception ex)
			{
				PLOG.E("GetLangStringError :" + ex.ToString());
			}
			return result;
		}

		public static string UPvr_GetStringValue(string id, int type)
		{
			string result = "";
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getStringValue", id, type);
			}
			catch (Exception ex)
			{
				PLOG.E("GetStringValueError :" + ex.ToString());
			}
			return result;
		}

		public static int UPvr_GetIntValue(string id, int type)
		{
			int result = -1;
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getIntValue", id, type);
			}
			catch (Exception ex)
			{
				PLOG.E("GetIntValueError :" + ex.ToString());
			}
			return result;
		}

		public static float UPvr_GetFloatValue(string id)
		{
			float result = -1f;
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getFloatValue", id);
			}
			catch (Exception ex)
			{
				PLOG.E("GetFloatValueError :" + ex.ToString());
			}
			return result;
		}

		public static string UPvr_GetObjectOrArray(string id, int type)
		{
			string result = "";
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getObjectOrArray", id, type);
			}
			catch (Exception ex)
			{
				PLOG.E("GetObjectOrArrayError :" + ex.ToString());
			}
			return result;
		}

		public static int UPvr_GetCharSpace(string id)
		{
			int result = -1;
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getCharSpace", id);
			}
			catch (Exception ex)
			{
				PLOG.E("GetCharSpaceError :" + ex.ToString());
			}
			return result;
		}

		public static bool UPvr_SetExtraLatencyMode(ExtraLatencyMode mode)
		{
			return Pvr_SetExtraLatencyMode((int)mode);
		}

		public static float UPvr_GetPredictedDisplayTime()
		{
			float result = 0f;
			try
			{
				result = Pvr_GetPredictedDisplayTime();
			}
			catch (Exception ex)
			{
				UnityEngine.Debug.Log("UPvr_GetPredictedDisplayTime :" + ex.ToString());
			}
			return result;
		}
	}
	[StructLayout(LayoutKind.Sequential, Size = 1)]
	public struct BoundarySystem
	{
		public enum BoundaryType
		{
			OuterBoundary,
			PlayArea
		}

		public struct BoundaryTestResult
		{
			public bool IsTriggering;

			public float ClosestDistance;

			public Vector3 ClosestPoint;

			public Vector3 ClosestPointNormal;
		}

		public enum BoundaryTrackingNode
		{
			HandLeft,
			HandRight,
			Head
		}

		public enum BoundaryTrackingState
		{
			LostNoReason = 3,
			LostCamera,
			LostHighLight,
			LostLowLight,
			LostLowFeatureCount,
			LostReLocation,
			LostInitialization,
			LostNoCamera,
			LostNoIMU,
			LostIMUJitter,
			LostUnknown
		}

		public const string LibFileName = "Pvr_UnitySDK";

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern float Pvr_GetFloorHeight();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetSeeThroughState();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_BoundarySetSTBackground(bool value);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetTrackingState();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_GetFrameRateLimit();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_IsBoundaryEnable();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_BoundaryGetConfigured();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_BoundaryTestNode(int node, bool isPlayArea, ref bool isTriggering, ref float closestDistance, ref float px, ref float py, ref float pz, ref float nx, ref float ny, ref float nz);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_BoundaryTestPoint(float x, float y, float z, bool isPlayArea, ref bool isTriggering, ref float closestDistance, ref float px, ref float py, ref float pz, ref float nx, ref float ny, ref float nz);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_BoundaryGetGeometry(out IntPtr handle, bool isPlayArea);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_BoundaryGetDimensions(ref float x, ref float y, ref float z, bool isPlayArea);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_BoundaryGetEnabled();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_BoundarySetVisible(bool value);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_BoundaryGetVisible();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_EnableLWRP(bool enable);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_SetViewportSize(int w, int h);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_BoundarySetSeeThroughVisible(bool value);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void PVR_SetCameraImageRect(int width, int height);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetGuardianSystemDisable(bool value);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetDialogState();

		public static float UPvr_GetFloorHeight()
		{
			return Pvr_GetFloorHeight();
		}

		public static int UPvr_GetSeeThroughState()
		{
			return Pvr_GetSeeThroughState();
		}

		public static void UPvr_EnableSeeThroughManual(bool enable)
		{
			Pvr_BoundarySetSTBackground(enable);
		}

		public static BoundaryTrackingState UPvr_GetTrackingState()
		{
			return (BoundaryTrackingState)Pvr_GetTrackingState();
		}

		public static bool UPvr_GetFrameRateLimit()
		{
			return Pvr_GetFrameRateLimit();
		}

		public static bool UPvr_IsBoundaryEnable()
		{
			return Pvr_IsBoundaryEnable();
		}

		public static bool UPvr_BoundaryGetConfigured()
		{
			return Pvr_BoundaryGetConfigured();
		}

		public static BoundaryTestResult UPvr_BoundaryTestNode(BoundaryTrackingNode node, BoundaryType boundaryType)
		{
			BoundaryTestResult result = default(BoundaryTestResult);
			bool num = Pvr_BoundaryTestNode((int)node, boundaryType == BoundaryType.PlayArea, ref result.IsTriggering, ref result.ClosestDistance, ref result.ClosestPoint.x, ref result.ClosestPoint.y, ref result.ClosestPoint.z, ref result.ClosestPointNormal.x, ref result.ClosestPointNormal.y, ref result.ClosestPointNormal.z);
			result.ClosestPoint.z = 0f - result.ClosestPoint.z;
			result.ClosestPointNormal.z = 0f - result.ClosestPointNormal.z;
			if (!num)
			{
				UnityEngine.Debug.LogError($"UPvr_BoundaryTestNode({node}, {boundaryType}) API call failed!");
			}
			return result;
		}

		public static BoundaryTestResult UPvr_BoundaryTestPoint(Vector3 point, BoundaryType boundaryType)
		{
			BoundaryTestResult result = default(BoundaryTestResult);
			if (!Pvr_BoundaryTestPoint(point.x, point.y, 0f - point.z, boundaryType == BoundaryType.PlayArea, ref result.IsTriggering, ref result.ClosestDistance, ref result.ClosestPoint.x, ref result.ClosestPoint.y, ref result.ClosestPoint.z, ref result.ClosestPointNormal.x, ref result.ClosestPointNormal.y, ref result.ClosestPointNormal.z))
			{
				UnityEngine.Debug.LogError($"UPvr_BoundaryTestPoint({point}, {boundaryType}) API call failed!");
			}
			return result;
		}

		public static Vector3[] UPvr_BoundaryGetGeometry(BoundaryType boundaryType)
		{
			IntPtr handle = IntPtr.Zero;
			int num = Pvr_BoundaryGetGeometry(out handle, boundaryType == BoundaryType.PlayArea);
			if (num <= 0)
			{
				UnityEngine.Debug.LogError("Boundary geometry point count is " + num);
				return null;
			}
			int num2 = num * 3;
			float[] array = new float[num2];
			Marshal.Copy(handle, array, 0, num2);
			Vector3[] array2 = new Vector3[num];
			for (int i = 0; i < num; i++)
			{
				array2[i] = new Vector3
				{
					x = array[3 * i],
					y = array[3 * i + 1],
					z = 0f - array[3 * i + 2]
				};
			}
			return array2;
		}

		public static Vector3 UPvr_BoundaryGetDimensions(BoundaryType boundaryType)
		{
			float x = 0f;
			float y = 0f;
			float z = 0f;
			Pvr_BoundaryGetDimensions(ref x, ref y, ref z, boundaryType == BoundaryType.PlayArea);
			return new Vector3(x, y, z);
		}

		public static bool UPvr_BoundaryGetEnabled()
		{
			return Pvr_BoundaryGetEnabled();
		}

		public static void UPvr_BoundarySetVisible(bool value)
		{
			Pvr_BoundarySetVisible(value);
		}

		public static bool UPvr_BoundaryGetVisible()
		{
			return Pvr_BoundaryGetVisible();
		}

		public static bool UPvr_EnableLWRP(bool enable)
		{
			return Pvr_EnableLWRP(enable);
		}

		public static bool UPvr_SetViewportSize(int width, int height)
		{
			return Pvr_SetViewportSize(width, height);
		}

		public static void UPvr_StartCameraFrame()
		{
			try
			{
				Pvr_UnitySDKPluginEvent.Issue(RenderEventType.StartCameraFrame);
			}
			catch (Exception ex)
			{
				PLOG.E("UPvr_StartCameraFrame :" + ex.ToString());
			}
		}

		public static void UPvr_StopCameraFrame()
		{
			try
			{
				Pvr_UnitySDKPluginEvent.Issue(RenderEventType.StopCameraFrame);
			}
			catch (Exception ex)
			{
				PLOG.E("UPvr_StopCameraFrame :" + ex.ToString());
			}
		}

		public static void UPvr_BoundaryGetSeeThroughData(int cameraIndex, RenderTexture renderTexture)
		{
			try
			{
				if (renderTexture.IsCreated())
				{
					System.UPvr_UnityEventData(renderTexture.GetNativeTexturePtr().ToInt32());
					switch (cameraIndex)
					{
					case 0:
						Pvr_UnitySDKPluginEvent.Issue(RenderEventType.CameraFrameLeft);
						break;
					case 1:
						Pvr_UnitySDKPluginEvent.Issue(RenderEventType.CameraFrameRight);
						break;
					}
				}
			}
			catch (Exception ex)
			{
				PLOG.E("UPvr_BoundaryGetSeeThroughDataError :" + ex.ToString());
			}
		}

		public static void UPvr_BoundarySetCameraImageRect(int width, int height)
		{
			try
			{
				PVR_SetCameraImageRect(width, height);
			}
			catch (Exception ex)
			{
				PLOG.E("UPvr_BoundarySetCameraImageRectError :" + ex.ToString());
			}
		}

		public static void UPvr_BoundarySetSeeThroughVisible(bool value)
		{
			try
			{
				Pvr_BoundarySetSeeThroughVisible(value);
			}
			catch (Exception ex)
			{
				PLOG.E("UPvr_BoundarySetSeeThroughVisibleError :" + ex.ToString());
			}
		}

		public static void UPvr_SetGuardianSystemDisable(bool value)
		{
			try
			{
				Pvr_SetGuardianSystemDisable(value);
			}
			catch (Exception ex)
			{
				PLOG.E("UPvr_SetGuardianSystemDisableError :" + ex.ToString());
			}
		}

		public static int UPvr_GetDialogState()
		{
			int result = 0;
			try
			{
				result = Pvr_GetDialogState();
			}
			catch (Exception ex)
			{
				PLOG.E("UPvr_GetDialogStateError :" + ex.ToString());
			}
			return result;
		}
	}
	[StructLayout(LayoutKind.Sequential, Size = 1)]
	public struct PlatformSettings
	{
		public static Pvr_UnitySDKPlatformSetting.simulationType UPvr_IsCurrentDeviceValid()
		{
			if (Pvr_UnitySDKPlatformSetting.Entitlementchecksimulation)
			{
				if (Pvr_UnitySDKPlatformSetting.Instance.deviceSN.Count <= 0)
				{
					UnityEngine.Debug.Log("DISFT Entitlement Check Simulation deviceSN is Null");
					return Pvr_UnitySDKPlatformSetting.simulationType.Null;
				}
				foreach (string item in Pvr_UnitySDKPlatformSetting.Instance.deviceSN)
				{
					if (System.UPvr_GetDeviceSN() == item)
					{
						return Pvr_UnitySDKPlatformSetting.simulationType.Valid;
					}
				}
				UnityEngine.Debug.Log("DISFT Entitlement Check Simulation deviceSN is Invalid");
				return Pvr_UnitySDKPlatformSetting.simulationType.Invalid;
			}
			UnityEngine.Debug.Log("DISFT Entitlement Check Simulation DO NOT Enable");
			return Pvr_UnitySDKPlatformSetting.simulationType.Invalid;
		}

		public static bool UPvr_AppEntitlementCheck(string appid)
		{
			bool result = false;
			try
			{
				System.UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "verifyAPP", System.UPvr_GetCurrentActivity(), appid, "");
			}
			catch (Exception ex)
			{
				PLOG.E("Error :" + ex.ToString());
			}
			UnityEngine.Debug.Log("PvrLog UPvr_AppEntitlementCheck" + result);
			return result;
		}

		[Obsolete("This API will be removed in later versions")]
		public static bool UPvr_KeyEntitlementCheck(string publicKey)
		{
			bool result = false;
			try
			{
				System.UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "verifyAPP", System.UPvr_GetCurrentActivity(), "", publicKey);
			}
			catch (Exception ex)
			{
				PLOG.E("Error :" + ex.ToString());
			}
			UnityEngine.Debug.Log("PvrLog UPvr_KeyEntitlementCheck" + result);
			return result;
		}

		public static int UPvr_AppEntitlementCheckExtra(string appid)
		{
			return 0;
		}

		public static int UPvr_KeyEntitlementCheckExtra(string publicKey)
		{
			int result = -1;
			try
			{
				System.UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "verifyAPPExt", System.UPvr_GetCurrentActivity(), "", publicKey);
			}
			catch (Exception ex)
			{
				PLOG.E("Error :" + ex.ToString());
			}
			UnityEngine.Debug.Log("PvrLog UPvr_KeyEntitlementCheck" + result);
			return result;
		}

		public static int UPvr_GetHmdAudioStatus()
		{
			return System.PVR_GetHmdAudioStatus();
		}
	}
	public enum DeviceCommand
	{
		SET_PICO_NEO_HMD_BRIGHTNESS = 12,
		SET_PICO_NEO_HMD_SLEEPDELAY
	}
	public enum BrightnessLevel
	{
		VR_BRIGHTNESS_LEVEL_MIN = 1,
		VR_BRIGHTNESS_LEVEL_MAX = 100,
		VR_BRIGHTNESS_LEVEL_DOWN = 1000,
		VR_BRIGHTNESS_LEVEL_UP = 1001,
		VR_BRIGHTNESS_LEVEL_SCREEN_OFF = -100
	}
	public struct VolumePowerBrightness
	{
		public const string LibFileName = "Pvr_UnitySDK";

		public AndroidJavaObject activity;

		public static AndroidJavaClass javaSysActivityClass;

		private static AndroidJavaClass batteryjavaVrActivityClass;

		private static AndroidJavaClass volumejavaVrActivityClass;

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void Pvr_SetInitActivity(IntPtr activity, IntPtr vrActivityClass);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_IsHmdExist();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetHmdScreenBrightness();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_SetHmdScreenBrightness(int brightness);

		public static bool UPvr_IsHmdExist()
		{
			return Pvr_IsHmdExist();
		}

		public static int UPvr_GetHmdScreenBrightness()
		{
			return Pvr_GetHmdScreenBrightness();
		}

		public static bool UPvr_SetHmdScreenBrightness(int brightness)
		{
			return Pvr_SetHmdScreenBrightness(brightness);
		}

		public static bool UPvr_SetCommonBrightness(int brightness)
		{
			bool flag = false;
			if (UPvr_IsHmdExist())
			{
				return UPvr_SetHmdScreenBrightness(brightness);
			}
			return UPvr_SetBrightness(brightness);
		}

		public static int UPvr_GetCommonBrightness()
		{
			int num = 0;
			if (UPvr_IsHmdExist())
			{
				return UPvr_GetHmdScreenBrightness();
			}
			return UPvr_GetCurrentBrightness();
		}

		public static int[] UPvr_GetScreenBrightnessLevel()
		{
			return Pvr_GetScreenBrightnessLevel();
		}

		public static void UPvr_SetScreenBrightnessLevel(int vrBrightness, int level)
		{
			Pvr_SetScreenBrightnessLevel(vrBrightness, level);
		}

		public static bool UPvr_SetDevicePropForUser(DeviceCommand deviceid, string number)
		{
			return setDevicePropForUser(deviceid, number);
		}

		public static string UPvr_GetDevicePropForUser(DeviceCommand deviceid)
		{
			return getDevicePropForUser(deviceid);
		}

		public static bool UPvr_InitBatteryClass()
		{
			try
			{
				if (javaSysActivityClass == null)
				{
					javaSysActivityClass = new AndroidJavaClass("com.psmart.aosoperation.SysActivity");
				}
				if (javaSysActivityClass != null && Pvr_UnitySDKRender.Instance.activity != null)
				{
					if (batteryjavaVrActivityClass == null)
					{
						batteryjavaVrActivityClass = new AndroidJavaClass("com.psmart.aosoperation.BatteryReceiver");
					}
					return true;
				}
				return false;
			}
			catch (Exception ex)
			{
				PLOG.E("startReceiver Error :" + ex.ToString());
				return false;
			}
		}

		public static bool UPvr_InitBatteryVolClass()
		{
			try
			{
				javaSysActivityClass = new AndroidJavaClass("com.psmart.aosoperation.SysActivity");
				if (javaSysActivityClass != null && Pvr_UnitySDKRender.Instance.activity != null)
				{
					batteryjavaVrActivityClass = new AndroidJavaClass("com.psmart.aosoperation.BatteryReceiver");
					volumejavaVrActivityClass = new AndroidJavaClass("com.psmart.aosoperation.AudioReceiver");
					System.UPvr_CallStaticMethod(javaSysActivityClass, "Pvr_InitAudioDevice", Pvr_UnitySDKRender.Instance.activity);
					return true;
				}
				return false;
			}
			catch (Exception ex)
			{
				PLOG.E("startReceiver Error :" + ex.ToString());
				return false;
			}
		}

		public static bool UPvr_StartBatteryReceiver(string startreceivre)
		{
			try
			{
				System.UPvr_CallStaticMethod(batteryjavaVrActivityClass, "Pvr_StartReceiver", Pvr_UnitySDKRender.Instance.activity, startreceivre);
				return true;
			}
			catch (Exception ex)
			{
				PLOG.E("startReceiver Error :" + ex.ToString());
				return false;
			}
		}

		public static bool UPvr_StopBatteryReceiver()
		{
			try
			{
				System.UPvr_CallStaticMethod(batteryjavaVrActivityClass, "Pvr_StopReceiver", Pvr_UnitySDKRender.Instance.activity);
				return true;
			}
			catch (Exception ex)
			{
				PLOG.E("startReceiver Error :" + ex.ToString());
				return false;
			}
		}

		public static bool UPvr_SetBrightness(int brightness)
		{
			try
			{
				System.UPvr_CallStaticMethod(javaSysActivityClass, "Pvr_SetScreen_Brightness", brightness, Pvr_UnitySDKRender.Instance.activity);
				return true;
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
				return false;
			}
		}

		public static int UPvr_GetCurrentBrightness()
		{
			int result = 0;
			try
			{
				System.UPvr_CallStaticMethod(ref result, javaSysActivityClass, "Pvr_GetScreen_Brightness", Pvr_UnitySDKRender.Instance.activity);
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
			}
			return result;
		}

		public static int[] Pvr_GetScreenBrightnessLevel()
		{
			int[] result = new int[1];
			try
			{
				System.UPvr_CallStaticMethod(ref result, javaSysActivityClass, "getScreenBrightnessLevel");
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
			}
			return result;
		}

		public static void Pvr_SetScreenBrightnessLevel(int vrBrightness, int level)
		{
			try
			{
				System.UPvr_CallStaticMethod(javaSysActivityClass, "setScreenBrightnessLevel", vrBrightness, level);
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
			}
		}

		public static bool UPvr_StartAudioReceiver(string startreceivre)
		{
			try
			{
				System.UPvr_CallStaticMethod(volumejavaVrActivityClass, "Pvr_StartReceiver", Pvr_UnitySDKRender.Instance.activity, startreceivre);
				return true;
			}
			catch (Exception ex)
			{
				PLOG.E("startReceiver Error :" + ex.ToString());
				return false;
			}
		}

		public static bool UPvr_StopAudioReceiver()
		{
			try
			{
				System.UPvr_CallStaticMethod(volumejavaVrActivityClass, "Pvr_StopReceiver", Pvr_UnitySDKRender.Instance.activity);
				return true;
			}
			catch (Exception ex)
			{
				PLOG.E("startReceiver Error :" + ex.ToString());
				return false;
			}
		}

		public static int UPvr_GetMaxVolumeNumber()
		{
			int result = 0;
			try
			{
				System.UPvr_CallStaticMethod(ref result, javaSysActivityClass, "Pvr_GetMaxAudionumber");
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
			}
			return result;
		}

		public static int UPvr_GetCurrentVolumeNumber()
		{
			int result = 0;
			try
			{
				System.UPvr_CallStaticMethod(ref result, javaSysActivityClass, "Pvr_GetAudionumber");
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
			}
			return result;
		}

		public static bool UPvr_VolumeUp()
		{
			try
			{
				System.UPvr_CallStaticMethod(javaSysActivityClass, "Pvr_UpAudio");
				return true;
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
				return false;
			}
		}

		public static bool UPvr_VolumeDown()
		{
			try
			{
				System.UPvr_CallStaticMethod(javaSysActivityClass, "Pvr_DownAudio");
				return true;
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
				return false;
			}
		}

		public static bool UPvr_SetVolumeNum(int volume)
		{
			try
			{
				System.UPvr_CallStaticMethod(javaSysActivityClass, "Pvr_ChangeAudio", volume);
				return true;
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
				return false;
			}
		}

		public static bool UPvr_SetAudio(string s)
		{
			return false;
		}

		public static bool UPvr_SetBattery(string s)
		{
			return false;
		}

		private static string getDevicePropForUser(DeviceCommand deviceid)
		{
			string result = "0";
			System.UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getDevicePropForUser", (int)deviceid);
			return result;
		}

		private static bool setDevicePropForUser(DeviceCommand deviceid, string number)
		{
			bool result = false;
			System.UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "setDevicePropForUser", (int)deviceid, number);
			return result;
		}
	}
}
namespace Pvr_UnitySDKAPI.Achievement
{
	public sealed class AchievementCore
	{
		private static bool IsPlatformInitialized = true;

		public static bool LogMessages = false;

		public static bool IsInitialized()
		{
			return IsPlatformInitialized;
		}

		public static void Initialize()
		{
		}

		public static void RegisterNetwork()
		{
			Pvr_AchievementAPI.RegisterNetwork();
		}

		public static void UnRegisterNetwork()
		{
			Pvr_AchievementAPI.UnRegisterNetwork();
		}
	}
	public static class Achievements
	{
		public static Pvr_Request<Pvr_AchievementUpdate> Init()
		{
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementUpdate>(Pvr_AchievementAPI.Init());
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementUpdate> AddCount(string name, long count)
		{
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementUpdate>(Pvr_AchievementAPI.pvr_Achievements_AddCount(name, count));
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementUpdate> AddFields(string name, string fields)
		{
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementUpdate>(Pvr_AchievementAPI.pvr_Achievements_AddFields(name, fields));
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementDefinitionList> GetAllDefinitions()
		{
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementDefinitionList>(Pvr_AchievementAPI.pvr_Achievements_GetAllDefinitions());
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementProgressList> GetAllProgress()
		{
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementProgressList>(Pvr_AchievementAPI.pvr_Achievements_GetAllProgress());
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementDefinitionList> GetDefinitionsByName(string[] names)
		{
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementDefinitionList>(Pvr_AchievementAPI.pvr_Achievements_GetDefinitionsByName(names, (names != null) ? names.Length : 0));
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementProgressList> GetProgressByName(string[] names)
		{
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementProgressList>(Pvr_AchievementAPI.pvr_Achievements_GetProgressByName(names, (names != null) ? names.Length : 0));
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementUpdate> Unlock(string name)
		{
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementUpdate>(Pvr_AchievementAPI.pvr_Achievements_Unlock(name));
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementDefinitionList> GetNextAchievementDefinitionListPage(Pvr_AchievementDefinitionList list)
		{
			if (!list.HasNextPage)
			{
				UnityEngine.Debug.LogWarning("Platform.GetNextAchievementDefinitionListPage: List has no next page");
				return null;
			}
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementDefinitionList>(Pvr_AchievementAPI.pvr_HTTP_GetWithMessageType(list.NextUrl, Pvr_Message.MessageType.Achievements_GetNextAchievementDefinitionArrayPage));
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementProgressList> GetNextAchievementProgressListPage(Pvr_AchievementProgressList list)
		{
			if (!list.HasNextPage)
			{
				UnityEngine.Debug.LogWarning("Platform.GetNextAchievementProgressListPage: List has no next page");
				return null;
			}
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementProgressList>(Pvr_AchievementAPI.pvr_HTTP_GetWithMessageType(list.NextUrl, Pvr_Message.MessageType.Achievements_GetNextAchievementProgressArrayPage));
			}
			return null;
		}
	}
	public enum AchievementType
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("SIMPLE")]
		Simple,
		[Description("BITFIELD")]
		Bitfield,
		[Description("COUNT")]
		Count
	}
	public class Pvr_AchievementAPI
	{
		private static AndroidJavaClass achievementAPI = new AndroidJavaClass("com.pico.achievement.AchievementAPI");

		private static AndroidJavaClass definitionArrayHandle = new AndroidJavaClass("com.picovr.achievement.utils.pvrAchievementDefinitionArrayHandle");

		private static AndroidJavaClass definitionHandle = new AndroidJavaClass("com.picovr.achievement.utils.pvrAchievementDefinitionHandle");

		private static AndroidJavaClass progressArrayHandle = new AndroidJavaClass("com.picovr.achievement.utils.pvrAchievementProgressArrayHandle");

		private static AndroidJavaClass progressHandle = new AndroidJavaClass("com.picovr.achievement.utils.pvrAchievementProgressHandle");

		private static AndroidJavaClass updateHandle = new AndroidJavaClass("com.picovr.achievement.utils.pvrAchievementUpdateHandle");

		private static AndroidJavaObject errorHandle = new AndroidJavaObject("com.picovr.achievement.utils.pvrAchievementErrorHandle");

		private static AndroidJavaObject unityInterface = new AndroidJavaObject("com.pico.loginpaysdk.UnityInterface");

		private static string openId;

		private static string accessToken;

		private static string appId = Pvr_UnitySDKPlatformSetting.Instance.appID;

		internal static long Init()
		{
			AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
			unityInterface.Call("init", @static);
			unityInterface.Call("authSSO");
			AndroidJavaObject androidJavaObject = new AndroidJavaClass("com.pico.loginpaysdk.utils.PicoAccessTokenKeeper").CallStatic<AndroidJavaObject>("readAccessToken", new object[1] { @static });
			accessToken = androidJavaObject.Call<string>("getAccessToken", Array.Empty<object>());
			openId = androidJavaObject.Call<string>("getOpenId", Array.Empty<object>());
			return achievementAPI.CallStatic<long>("init", new object[3] { accessToken, openId, @static });
		}

		internal static void RegisterNetwork()
		{
			AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
			achievementAPI.CallStatic("registerNetwork", @static);
		}

		internal static void UnRegisterNetwork()
		{
			achievementAPI.CallStatic("unregisterNetwork");
		}

		internal static AndroidJavaObject PopMessage()
		{
			return achievementAPI.CallStatic<AndroidJavaObject>("pvr_PopMessage", Array.Empty<object>());
		}

		internal static string pvr_Error_GetMessage(AndroidJavaObject popMessage)
		{
			return errorHandle.CallStatic<string>("pvr_Error_GetMessage", new object[1] { popMessage });
		}

		internal static int pvr_Error_GetHttpCode(AndroidJavaObject popMessage)
		{
			return errorHandle.CallStatic<int>("pvr_Error_GetHttpCode", new object[1] { popMessage });
		}

		internal static int pvr_Error_GetCode(AndroidJavaObject popMessage)
		{
			return errorHandle.CallStatic<int>("pvr_Error_GetCode", new object[1] { popMessage });
		}

		internal static long pvr_Achievements_AddCount(string name, long count)
		{
			return achievementAPI.CallStatic<long>("pvr_Achievements_AddCount", new object[3] { name, count, accessToken });
		}

		internal static long pvr_Achievements_AddFields(string name, string fields)
		{
			return achievementAPI.CallStatic<long>("pvr_Achievements_AddFields", new object[3] { name, fields, accessToken });
		}

		internal static long pvr_Achievements_GetAllDefinitions()
		{
			AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
			return achievementAPI.CallStatic<long>("pvr_Achievements_GetAllDefinitions", new object[2] { appId, @static });
		}

		internal static long pvr_Achievements_GetAllProgress()
		{
			return achievementAPI.CallStatic<long>("pvr_Achievements_GetAllProgress", new object[1] { accessToken });
		}

		internal static long pvr_Achievements_GetDefinitionsByName(string[] names, int v)
		{
			AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
			return achievementAPI.CallStatic<long>("pvr_Achievements_GetDefinitionsByName", new object[2] { names, @static });
		}

		internal static long pvr_Achievements_GetProgressByName(string[] names, int v)
		{
			return achievementAPI.CallStatic<long>("pvr_Achievements_GetProgressByName", new object[2] { names, accessToken });
		}

		internal static long pvr_Achievements_Unlock(string name)
		{
			return achievementAPI.CallStatic<long>("pvr_Achievements_Unlock", new object[2] { name, accessToken });
		}

		internal static long pvr_HTTP_GetWithMessageType(string nextUrl, Pvr_Message.MessageType messageType)
		{
			long result = 0L;
			switch (messageType)
			{
			case Pvr_Message.MessageType.Achievements_GetNextAchievementDefinitionArrayPage:
			{
				AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
				result = achievementAPI.CallStatic<long>("pvr_Achievements_GetAllDefinitionsByUrl", new object[2] { nextUrl, @static });
				break;
			}
			case Pvr_Message.MessageType.Achievements_GetNextAchievementProgressArrayPage:
				result = achievementAPI.CallStatic<long>("pvr_Achievements_GetAllProgressByUrl", new object[1] { nextUrl });
				break;
			}
			return result;
		}

		internal static long pvr_Message_GetType(AndroidJavaObject popMessage)
		{
			return popMessage.Call<AndroidJavaObject>("getHandleType", Array.Empty<object>()).Call<long>("getIndex", Array.Empty<object>());
		}

		internal static bool pvr_Message_IsError(AndroidJavaObject popMessage)
		{
			return popMessage.Call<bool>("isMessage_IsError", Array.Empty<object>());
		}

		internal static long pvr_Message_GetRequestID(AndroidJavaObject popMessage)
		{
			return popMessage.Call<long>("getId", Array.Empty<object>());
		}

		internal static string pvr_Message_GetString(AndroidJavaObject popMessage)
		{
			return popMessage.Call<string>("getContent", Array.Empty<object>());
		}

		internal static bool pvr_AchievementUpdate_GetJustUnlocked(AndroidJavaObject popMessage)
		{
			return updateHandle.CallStatic<bool>("pvr_AchievementUpdate_GetJustUnlocked", new object[1] { popMessage });
		}

		internal static string pvr_AchievementUpdate_GetName(AndroidJavaObject popMessage)
		{
			return updateHandle.CallStatic<string>("pvr_AchievementUpdate_GetName", new object[1] { popMessage });
		}

		internal static int pvr_AchievementProgressArray_GetSize(AndroidJavaObject msg)
		{
			return progressArrayHandle.CallStatic<int>("pvr_AchievementProgressArray_GetSize", new object[1] { msg });
		}

		internal static AndroidJavaObject pvr_AchievementProgressArray_GetElement(AndroidJavaObject msg, int index)
		{
			return progressArrayHandle.CallStatic<AndroidJavaObject>("pvr_AchievementProgressArray_GetElement", new object[2] { msg, index });
		}

		internal static string pvr_AchievementProgressArray_GetNextUrl(AndroidJavaObject msg)
		{
			return progressArrayHandle.CallStatic<string>("pvr_AchievementProgressArray_GetNextUrl", new object[1] { msg });
		}

		internal static string pvr_AchievementProgress_GetBitfield(AndroidJavaObject msg)
		{
			return progressHandle.CallStatic<string>("pvr_AchievementProgress_GetBitfield", new object[1] { msg });
		}

		internal static long pvr_AchievementProgress_GetCount(AndroidJavaObject msg)
		{
			return progressHandle.CallStatic<long>("pvr_AchievementProgress_GetCount", new object[1] { msg });
		}

		internal static bool pvr_AchievementProgress_GetIsUnlocked(AndroidJavaObject msg)
		{
			return progressHandle.CallStatic<bool>("pvr_AchievementProgress_GetIsUnlocked", new object[1] { msg });
		}

		internal static string pvr_AchievementProgress_GetName(AndroidJavaObject msg)
		{
			return progressHandle.CallStatic<string>("pvr_AchievementProgress_GetName", new object[1] { msg });
		}

		internal static DateTime pvr_AchievementProgress_GetUnlockTime(AndroidJavaObject msg)
		{
			new DateTime(1970, 1, 1, 0, 0, 0, 0);
			return DateTimeFromNative(progressHandle.CallStatic<long>("pvr_AchievementProgress_GetUnlockTime", new object[1] { msg }));
		}

		internal static DateTime DateTimeFromNative(long seconds_since_the_one_true_epoch)
		{
			return new DateTime(1970, 1, 1, 0, 0, 0, 0).AddSeconds(seconds_since_the_one_true_epoch).ToLocalTime();
		}

		internal static int pvr_AchievementDefinitionArray_GetSize(AndroidJavaObject msg)
		{
			return definitionArrayHandle.CallStatic<int>("pvr_AchievementDefinitionArray_GetSize", new object[1] { msg });
		}

		internal static AndroidJavaObject pvr_AchievementDefinitionArray_GetElement(AndroidJavaObject msg, int index)
		{
			return definitionArrayHandle.CallStatic<AndroidJavaObject>("pvr_AchievementDefinitionArray_GetElement", new object[2] { msg, index });
		}

		internal static string pvr_AchievementDefinitionArray_GetNextUrl(AndroidJavaObject msg)
		{
			return definitionArrayHandle.CallStatic<string>("pvr_AchievementDefinitionArray_GetNextUrl", new object[1] { msg });
		}

		internal static AchievementType pvr_AchievementDefinition_GetType(AndroidJavaObject msg)
		{
			return (AchievementType)definitionHandle.CallStatic<AndroidJavaObject>("pvr_AchievementDefinition_GetType", new object[1] { msg }).Call<int>("getIndex", Array.Empty<object>());
		}

		internal static string pvr_AchievementDefinition_GetName(AndroidJavaObject msg)
		{
			return definitionHandle.CallStatic<string>("pvr_AchievementDefinition_GetName", new object[1] { msg });
		}

		internal static int pvr_AchievementDefinition_GetBitfieldLength(AndroidJavaObject msg)
		{
			return definitionHandle.CallStatic<int>("pvr_AchievementDefinition_GetBitfieldLength", new object[1] { msg });
		}

		internal static long pvr_AchievementDefinition_GetTarget(AndroidJavaObject msg)
		{
			return definitionHandle.CallStatic<long>("pvr_AchievementDefinition_GetTarget", new object[1] { msg });
		}

		internal static string pvr_AchievementDefinition_GetTitle(AndroidJavaObject msg)
		{
			return definitionHandle.CallStatic<string>("pvr_AchievementDefinition_GetTitle", new object[1] { msg });
		}

		internal static string pvr_AchievementDefinition_GetUnlockedDescription(AndroidJavaObject msg)
		{
			return definitionHandle.CallStatic<string>("pvr_AchievementDefinition_GetUnlocked_description", new object[1] { msg });
		}

		internal static string pvr_AchievementDefinition_GetLockedIcon(AndroidJavaObject msg)
		{
			return definitionHandle.CallStatic<string>("pvr_AchievementDefinition_GetLocked_image", new object[1] { msg });
		}

		internal static bool pvr_AchievementDefinition_GetIsSecrect(AndroidJavaObject msg)
		{
			return definitionHandle.CallStatic<bool>("pvr_AchievementDefinition_GetIs_secret", new object[1] { msg });
		}

		internal static string pvr_AchievementDefinition_GetUnlockedIcon(AndroidJavaObject msg)
		{
			return definitionHandle.CallStatic<string>("pvr_AchievementDefinition_GetUnlocked_image", new object[1] { msg });
		}

		internal static string pvr_AchievementDefinition_GetDescription(AndroidJavaObject msg)
		{
			return definitionHandle.CallStatic<string>("pvr_AchievementDefinition_GetDescription", new object[1] { msg });
		}
	}
	public class Pvr_AchievementDefinition
	{
		public readonly AchievementType Type;

		public readonly string Name;

		public readonly int BitfieldLength;

		public readonly long Target;

		public readonly string Title;

		public readonly string Description;

		public readonly string UnlockedDescription;

		public readonly string UnlockedIcon;

		public readonly string LockedIcon;

		public readonly bool IsSecrect;

		public Pvr_AchievementDefinition(AndroidJavaObject msg)
		{
			Type = Pvr_AchievementAPI.pvr_AchievementDefinition_GetType(msg);
			Name = Pvr_AchievementAPI.pvr_AchievementDefinition_GetName(msg);
			BitfieldLength = Pvr_AchievementAPI.pvr_AchievementDefinition_GetBitfieldLength(msg);
			Target = Pvr_AchievementAPI.pvr_AchievementDefinition_GetTarget(msg);
			Title = Pvr_AchievementAPI.pvr_AchievementDefinition_GetTitle(msg);
			Description = Pvr_AchievementAPI.pvr_AchievementDefinition_GetDescription(msg);
			UnlockedDescription = Pvr_AchievementAPI.pvr_AchievementDefinition_GetUnlockedDescription(msg);
			UnlockedIcon = Pvr_AchievementAPI.pvr_AchievementDefinition_GetUnlockedIcon(msg);
			LockedIcon = Pvr_AchievementAPI.pvr_AchievementDefinition_GetLockedIcon(msg);
			IsSecrect = Pvr_AchievementAPI.pvr_AchievementDefinition_GetIsSecrect(msg);
		}
	}
	public class Pvr_AchievementDefinitionList : Pvr_DeserializableList<Pvr_AchievementDefinition>
	{
		public Pvr_AchievementDefinitionList(AndroidJavaObject msg)
		{
			int num = Pvr_AchievementAPI.pvr_AchievementDefinitionArray_GetSize(msg);
			data = new List<Pvr_AchievementDefinition>(num);
			for (int i = 0; i < num; i++)
			{
				data.Add(new Pvr_AchievementDefinition(Pvr_AchievementAPI.pvr_AchievementDefinitionArray_GetElement(msg, i)));
			}
			nextUrl = Pvr_AchievementAPI.pvr_AchievementDefinitionArray_GetNextUrl(msg);
		}
	}
	public class Pvr_AchievementProgress
	{
		public readonly string Bitfield;

		public readonly long Count;

		public readonly bool IsUnlocked;

		public readonly string Name;

		public readonly DateTime UnlockTime;

		public Pvr_AchievementProgress(AndroidJavaObject msg)
		{
			Bitfield = Pvr_AchievementAPI.pvr_AchievementProgress_GetBitfield(msg);
			Count = Pvr_AchievementAPI.pvr_AchievementProgress_GetCount(msg);
			IsUnlocked = Pvr_AchievementAPI.pvr_AchievementProgress_GetIsUnlocked(msg);
			Name = Pvr_AchievementAPI.pvr_AchievementProgress_GetName(msg);
			UnlockTime = Pvr_AchievementAPI.pvr_AchievementProgress_GetUnlockTime(msg);
		}
	}
	public class Pvr_AchievementProgressList : Pvr_DeserializableList<Pvr_AchievementProgress>
	{
		public Pvr_AchievementProgressList(AndroidJavaObject msg)
		{
			int num = Pvr_AchievementAPI.pvr_AchievementProgressArray_GetSize(msg);
			data = new List<Pvr_AchievementProgress>(num);
			for (int i = 0; i < num; i++)
			{
				data.Add(new Pvr_AchievementProgress(Pvr_AchievementAPI.pvr_AchievementProgressArray_GetElement(msg, i)));
			}
			nextUrl = Pvr_AchievementAPI.pvr_AchievementProgressArray_GetNextUrl(msg);
		}
	}
	public class Pvr_AchievementUpdate
	{
		public readonly bool JustUnlocked;

		public readonly string Name;

		public Pvr_AchievementUpdate(AndroidJavaObject msg)
		{
			JustUnlocked = Pvr_AchievementAPI.pvr_AchievementUpdate_GetJustUnlocked(msg);
			Name = Pvr_AchievementAPI.pvr_AchievementUpdate_GetName(msg);
		}
	}
	public class Pvr_DeserializableList<T> : IList<T>, ICollection<T>, IEnumerable<T>, IEnumerable
	{
		protected List<T> data;

		protected string nextUrl;

		protected string previousUrl;

		public int Count => data.Count;

		bool ICollection<T>.IsReadOnly => ((ICollection<T>)data).IsReadOnly;

		public T this[int index]
		{
			get
			{
				return data[index];
			}
			set
			{
				data[index] = value;
			}
		}

		public bool HasNextPage => !string.IsNullOrEmpty(NextUrl);

		public bool HasPreviousPage => !string.IsNullOrEmpty(PreviousUrl);

		public string NextUrl => nextUrl;

		public string PreviousUrl => previousUrl;

		public int IndexOf(T obj)
		{
			return data.IndexOf(obj);
		}

		public void Add(T item)
		{
			data.Add(item);
		}

		public void Clear()
		{
			data.Clear();
		}

		public bool Contains(T item)
		{
			return data.Contains(item);
		}

		public void CopyTo(T[] array, int arrayIndex)
		{
			data.CopyTo(array, arrayIndex);
		}

		public IEnumerator<T> GetEnumerator()
		{
			return data.GetEnumerator();
		}

		public void Insert(int index, T item)
		{
			data.Insert(index, item);
		}

		public bool Remove(T item)
		{
			return data.Remove(item);
		}

		public void RemoveAt(int index)
		{
			data.RemoveAt(index);
		}

		private IEnumerator GetEnumerator1()
		{
			return GetEnumerator();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator1();
		}
	}
	public static class Pvr_Callback
	{
		private class RequestCallback
		{
			private Pvr_Message.Callback messageCallback;

			public RequestCallback()
			{
			}

			public RequestCallback(Pvr_Message.Callback callback)
			{
				messageCallback = callback;
			}

			public virtual void HandleMessage(Pvr_Message msg)
			{
				if (messageCallback != null)
				{
					messageCallback(msg);
				}
			}
		}

		private sealed class RequestCallback<T> : RequestCallback
		{
			private Pvr_Message<T>.Callback callback;

			public RequestCallback(Pvr_Message<T>.Callback callback)
			{
				this.callback = callback;
			}

			public override void HandleMessage(Pvr_Message msg)
			{
				if (callback != null)
				{
					if (msg is Pvr_Message<T>)
					{
						callback((Pvr_Message<T>)msg);
					}
					else
					{
						UnityEngine.Debug.LogError("Unable to handle message: " + msg.GetType());
					}
				}
			}
		}

		private static Dictionary<long, Request> requestIDsToRequests = new Dictionary<long, Request>();

		private static Dictionary<Pvr_Message.MessageType, RequestCallback> notificationCallbacks = new Dictionary<Pvr_Message.MessageType, RequestCallback>();

		internal static void AddRequest(Request request)
		{
			if (request.RequestID <= 2)
			{
				long requestID = request.RequestID;
				if ((ulong)requestID <= 2uL)
				{
					switch (requestID)
					{
					case 0L:
						UnityEngine.Debug.LogError("An PARAM_INVALIDE error occurred. Request failed.");
						return;
					case 1L:
						UnityEngine.Debug.LogError("An NETWORK_INVALIDE error occurred. Request failed.");
						return;
					case 2L:
						UnityEngine.Debug.LogError("An NOT_INTIALIZE error occurred. Request failed.");
						return;
					}
				}
				UnityEngine.Debug.LogError("An unknown error occurred. Request failed.");
			}
			else
			{
				requestIDsToRequests[request.RequestID] = request;
			}
		}

		internal static void RunCallbacks()
		{
			while (true)
			{
				Pvr_Message pvr_Message = Pvr_Message.PopMessage();
				if (pvr_Message != null)
				{
					HandleMessage(pvr_Message);
					continue;
				}
				break;
			}
		}

		internal static void RunLimitedCallbacks(uint limit)
		{
			for (int i = 0; i < limit; i++)
			{
				Pvr_Message pvr_Message = Pvr_Message.PopMessage();
				if (pvr_Message != null)
				{
					HandleMessage(pvr_Message);
					continue;
				}
				break;
			}
		}

		internal static void OnApplicationQuit()
		{
			requestIDsToRequests.Clear();
			notificationCallbacks.Clear();
		}

		internal static void HandleMessage(Pvr_Message msg)
		{
			if (msg.RequestID != 0L && requestIDsToRequests.TryGetValue(msg.RequestID, out var value))
			{
				try
				{
					value.HandleMessage(msg);
					return;
				}
				finally
				{
					requestIDsToRequests.Remove(msg.RequestID);
				}
			}
			if (notificationCallbacks.TryGetValue(msg.Type, out var value2))
			{
				value2.HandleMessage(msg);
			}
		}
	}
	public class Pvr_CallbackRunner : MonoBehaviour
	{
		public bool IsPersistantBetweenSceneLoads = true;

		private void Awake()
		{
			if (UnityEngine.Object.FindObjectOfType<Pvr_CallbackRunner>() != this)
			{
				UnityEngine.Debug.LogWarning("You only need one instance of CallbackRunner");
			}
			if (IsPersistantBetweenSceneLoads)
			{
				UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
			}
		}

		private void Update()
		{
			Request.RunCallbacks();
		}

		private void OnApplicationQuit()
		{
			Pvr_Callback.OnApplicationQuit();
		}
	}
	public abstract class Pvr_Message<T> : Pvr_Message
	{
		public new delegate void Callback(Pvr_Message<T> message);

		private T data;

		public T Data => data;

		public Pvr_Message(AndroidJavaObject msg)
			: base(msg)
		{
			if (!base.IsError)
			{
				data = GetDataFromMessage(msg);
			}
		}

		protected abstract T GetDataFromMessage(AndroidJavaObject msg);
	}
	public class Pvr_Message
	{
		public delegate void Callback(Pvr_Message message);

		public enum MessageType : uint
		{
			Unknown = 0u,
			Achievements_AddCount = 65495601u,
			Achievements_AddFields = 346693929u,
			Achievements_GetAllDefinitions = 64177549u,
			Achievements_GetAllProgress = 1335877149u,
			Achievements_GetDefinitionsByName = 1653670332u,
			Achievements_GetNextAchievementDefinitionArrayPage = 712888917u,
			Achievements_GetNextAchievementProgressArrayPage = 792913703u,
			Achievements_GetProgressByName = 354837425u,
			Achievements_Unlock = 1497156573u,
			Achievements_WriteAchievementProgress = 121027549u,
			Achievements_VerifyAccessToken = 53284924u
		}

		internal delegate Pvr_Message ExtraMessageTypesHandler(AndroidJavaObject messageHandle, MessageType message_type);

		private MessageType type;

		private long requestID;

		private Error error;

		public MessageType Type => type;

		public bool IsError => error != null;

		public long RequestID => requestID;

		internal static ExtraMessageTypesHandler HandleExtraMessageTypes { private get; set; }

		public Pvr_Message(AndroidJavaObject msg)
		{
			type = (MessageType)Pvr_AchievementAPI.pvr_Message_GetType(msg);
			bool num = Pvr_AchievementAPI.pvr_Message_IsError(msg);
			requestID = Pvr_AchievementAPI.pvr_Message_GetRequestID(msg);
			if (num)
			{
				error = new Error(Pvr_AchievementAPI.pvr_Error_GetCode(msg), Pvr_AchievementAPI.pvr_Error_GetMessage(msg), Pvr_AchievementAPI.pvr_Error_GetHttpCode(msg));
			}
			else if (AchievementCore.LogMessages)
			{
				string text = Pvr_AchievementAPI.pvr_Message_GetString(msg);
				if (text != null)
				{
					UnityEngine.Debug.Log(text);
				}
				else
				{
					UnityEngine.Debug.Log($"null message string {msg}");
				}
			}
		}

		public virtual Error GetError()
		{
			return error;
		}

		public virtual Pvr_AchievementDefinitionList GetAchievementDefinitions()
		{
			return null;
		}

		public virtual Pvr_AchievementProgressList GetAchievementProgressList()
		{
			return null;
		}

		public virtual Pvr_AchievementUpdate GetAchievementUpdate()
		{
			return null;
		}

		public virtual string GetString()
		{
			return null;
		}

		internal static Pvr_Message ParseMessageHandle(AndroidJavaObject messageHandle)
		{
			if (messageHandle == null)
			{
				return null;
			}
			Pvr_Message result = null;
			switch ((MessageType)Pvr_AchievementAPI.pvr_Message_GetType(messageHandle))
			{
			case MessageType.Achievements_GetAllDefinitions:
			case MessageType.Achievements_GetNextAchievementDefinitionArrayPage:
			case MessageType.Achievements_GetDefinitionsByName:
				result = new MessageWithAchievementDefinitions(messageHandle);
				break;
			case MessageType.Achievements_GetProgressByName:
			case MessageType.Achievements_GetNextAchievementProgressArrayPage:
			case MessageType.Achievements_GetAllProgress:
				result = new MessageWithAchievementProgressList(messageHandle);
				break;
			case MessageType.Achievements_VerifyAccessToken:
			case MessageType.Achievements_AddCount:
			case MessageType.Achievements_AddFields:
			case MessageType.Achievements_Unlock:
				result = new MessageWithAchievementUpdate(messageHandle);
				break;
			}
			return result;
		}

		public static Pvr_Message PopMessage()
		{
			return ParseMessageHandle(Pvr_AchievementAPI.PopMessage());
		}
	}
	public class MessageWithAchievementDefinitions : Pvr_Message<Pvr_AchievementDefinitionList>
	{
		public MessageWithAchievementDefinitions(AndroidJavaObject msg)
			: base(msg)
		{
		}

		public override Pvr_AchievementDefinitionList GetAchievementDefinitions()
		{
			return base.Data;
		}

		protected override Pvr_AchievementDefinitionList GetDataFromMessage(AndroidJavaObject msg)
		{
			return new Pvr_AchievementDefinitionList(msg);
		}
	}
	public class MessageWithAchievementProgressList : Pvr_Message<Pvr_AchievementProgressList>
	{
		public MessageWithAchievementProgressList(AndroidJavaObject msg)
			: base(msg)
		{
		}

		public override Pvr_AchievementProgressList GetAchievementProgressList()
		{
			return base.Data;
		}

		protected override Pvr_AchievementProgressList GetDataFromMessage(AndroidJavaObject msg)
		{
			return new Pvr_AchievementProgressList(msg);
		}
	}
	public class MessageWithAchievementUpdate : Pvr_Message<Pvr_AchievementUpdate>
	{
		public MessageWithAchievementUpdate(AndroidJavaObject msg)
			: base(msg)
		{
		}

		public override Pvr_AchievementUpdate GetAchievementUpdate()
		{
			return base.Data;
		}

		protected override Pvr_AchievementUpdate GetDataFromMessage(AndroidJavaObject msg)
		{
			return new Pvr_AchievementUpdate(msg);
		}
	}
	public class MessageWithString : Pvr_Message<string>
	{
		public MessageWithString(AndroidJavaObject msg)
			: base(msg)
		{
		}

		public override string GetString()
		{
			return base.Data;
		}

		protected override string GetDataFromMessage(AndroidJavaObject msg)
		{
			return Pvr_AchievementAPI.pvr_Message_GetString(msg);
		}
	}
	public class Error
	{
		public readonly int Code;

		public readonly int HttpCode;

		public readonly string Message;

		public Error(int code, string message, int httpCode)
		{
			Message = message;
			Code = code;
			HttpCode = httpCode;
		}
	}
	public sealed class Pvr_Request<T> : Request
	{
		private Pvr_Message<T>.Callback callback_;

		public Pvr_Request(long requestID)
			: base(requestID)
		{
		}

		public Pvr_Request<T> OnComplete(Pvr_Message<T>.Callback callback)
		{
			if (callback_ != null)
			{
				throw new UnityException("Attempted to attach multiple handlers to a Request.  This is not allowed.");
			}
			callback_ = callback;
			Pvr_Callback.AddRequest(this);
			return this;
		}

		public override void HandleMessage(Pvr_Message msg)
		{
			if (!(msg is Pvr_Message<T>))
			{
				UnityEngine.Debug.LogError("Unable to handle message: " + msg.GetType());
				return;
			}
			if (callback_ != null)
			{
				callback_((Pvr_Message<T>)msg);
				return;
			}
			throw new UnityException("Request with no handler.  This should never happen.");
		}
	}
	public class Request
	{
		private Pvr_Message.Callback callback_;

		public long RequestID { get; set; }

		public Request(long requestID)
		{
			RequestID = requestID;
		}

		public Request OnComplete(Pvr_Message.Callback callback)
		{
			callback_ = callback;
			Pvr_Callback.AddRequest(this);
			return this;
		}

		public virtual void HandleMessage(Pvr_Message msg)
		{
			if (callback_ != null)
			{
				callback_(msg);
				return;
			}
			throw new UnityException("Request with no handler.  This should never happen.");
		}

		public static void RunCallbacks(uint limit = 0u)
		{
			if (limit == 0)
			{
				Pvr_Callback.RunCallbacks();
			}
			else
			{
				Pvr_Callback.RunLimitedCallbacks(limit);
			}
		}
	}
}
namespace Guava
{
	public class MicrophoneRecordCtrl : MonoBehaviour
	{
		private const float MIN_RECORD_TIME = 0.5f;

		private readonly int _frequency = 16000;

		private readonly int _micSecond = 90;

		private float micSecondCount = 90f;

		private AudioSource _curAudioSource;

		private int _deviceLength;

		private string _deviceName;

		private bool _isRecording;

		private string _strrecordSaveDir;

		private readonly string audioFileNAME = "AudioRecord";

		public int MaxRecordTime => _micSecond;

		public float[] Volume { get; private set; }

		public AudioSource CurAudioSource
		{
			get
			{
				if (_curAudioSource == null)
				{
					_curAudioSource = base.gameObject.AddComponent<AudioSource>();
				}
				return _curAudioSource;
			}
		}

		public float RecordAudioTime => AudioLength();

		public bool HasLocalVoice => CurAudioSource.clip != null;

		public bool m_isRecording => _isRecording;

		public string m_strRecordSavedir
		{
			get
			{
				if (string.IsNullOrEmpty(_strrecordSaveDir))
				{
					_strrecordSaveDir = Application.persistentDataPath + "/RecordAudios";
					if (!Directory.Exists(m_strRecordSavedir))
					{
						Directory.CreateDirectory(m_strRecordSavedir);
					}
				}
				return _strrecordSaveDir;
			}
		}

		private string fileurl => m_strRecordSavedir + "/" + audioFileNAME + ".wav";

		private void Start()
		{
			UnityEngine.Debug.Log(Application.persistentDataPath);
		}

		private void Update()
		{
			if (_isRecording)
			{
				micSecondCount -= Time.unscaledDeltaTime;
				if (micSecondCount <= 0f)
				{
					J_StopRecod();
				}
			}
		}

		public void J_StartRecod()
		{
			RequestPermission();
			if (Permission.HasUserAuthorizedPermission("android.permission.RECORD_AUDIO"))
			{
				StartRecord();
			}
		}

		public void J_StopRecod()
		{
			StopRecordAudio();
		}

		public void RequestPermission()
		{
			Permission.RequestUserPermission("android.permission.RECORD_AUDIO");
		}

		public float[] J_GetMaxVolume(int dataLENGTH)
		{
			return GetMaxVolume(dataLENGTH);
		}

		public byte[] J_GetRecordVoiceFileDatas()
		{
			if (File.Exists(fileurl))
			{
				return File.ReadAllBytes(fileurl);
			}
			return null;
		}

		private void GetMicrophoneDevice()
		{
			string[] devices = Microphone.devices;
			_deviceLength = devices.Length;
			if (_deviceLength == 0)
			{
				ShowInfoLog("cant find Microphone");
				return;
			}
			for (int i = 0; i < _deviceLength; i++)
			{
				ShowInfoLog($"find Microphone == {i}  " + devices[i]);
			}
		}

		private void StopRecordAudio()
		{
			ShowInfoLog("end record.....");
			if (_isRecording)
			{
				_isRecording = false;
				if (Microphone.IsRecording(_deviceName))
				{
					AudioLength();
					Microphone.End(_deviceName);
					CurAudioSource.Stop();
					SaveRecordData(audioFileNAME);
				}
			}
		}

		private void PlayRecordAudio()
		{
			ShowInfoLog("ready Play Record.....");
			if (!Microphone.IsRecording(_deviceName) && !(CurAudioSource.clip == null))
			{
				CurAudioSource.mute = false;
				CurAudioSource.loop = false;
				CurAudioSource.Play();
				_ = "total length: time:" + CurAudioSource.clip.length;
				ShowInfoLog("Play Record.....");
			}
		}

		private void StopAudio()
		{
			if (!Microphone.IsRecording(_deviceName) && !(CurAudioSource.clip == null))
			{
				CurAudioSource.Stop();
				ShowInfoLog("Stop Record.....");
			}
		}

		private void SaveRecordData(string audioName)
		{
			if (Microphone.IsRecording(_deviceName))
			{
				Microphone.End(_deviceName);
			}
			if (CurAudioSource.clip.length < 0.5f)
			{
				UnityEngine.Debug.LogWarning("--too shot");
				return;
			}
			using FileStream fileStream = CreateEmpty(m_strRecordSavedir + "/" + audioName + ".wav");
			ConvertAndWrite(fileStream, CurAudioSource.clip);
			WriteHeader(fileStream, CurAudioSource.clip);
		}

		private void LoadLocalAudio(string audioName, Action onComplete)
		{
			StartCoroutine(LoadAudio(Application.persistentDataPath + "/" + audioName + ".wav", onComplete));
		}

		private IEnumerator LoadAudio(string filepath, Action onComplete)
		{
			filepath = "file://" + filepath;
			using UnityWebRequest uwr = UnityWebRequestMultimedia.GetAudioClip(filepath, AudioType.WAV);
			yield return uwr.SendWebRequest();
			if (uwr.isDone && !uwr.isHttpError)
			{
				AudioClip content = DownloadHandlerAudioClip.GetContent(uwr);
				CurAudioSource.clip = content;
				string info = $"LoadAudio responseCode, {uwr.responseCode}";
				ShowInfoLog(info);
			}
			else
			{
				string info2 = "Fail LoadAudio " + filepath + ", " + uwr.error;
				ShowInfoLog(info2);
			}
			onComplete?.Invoke();
		}

		private void WriteHeader(FileStream stream, AudioClip clip)
		{
			int frequency = clip.frequency;
			int channels = clip.channels;
			int samples = clip.samples;
			stream.Seek(0L, SeekOrigin.Begin);
			byte[] bytes = Encoding.UTF8.GetBytes("RIFF");
			stream.Write(bytes, 0, 4);
			byte[] bytes2 = BitConverter.GetBytes(stream.Length - 8);
			stream.Write(bytes2, 0, 4);
			byte[] bytes3 = Encoding.UTF8.GetBytes("WAVE");
			stream.Write(bytes3, 0, 4);
			byte[] bytes4 = Encoding.UTF8.GetBytes("fmt ");
			stream.Write(bytes4, 0, 4);
			byte[] bytes5 = BitConverter.GetBytes(16);
			stream.Write(bytes5, 0, 4);
			byte[] bytes6 = BitConverter.GetBytes((ushort)1);
			stream.Write(bytes6, 0, 2);
			byte[] bytes7 = BitConverter.GetBytes(channels);
			stream.Write(bytes7, 0, 2);
			byte[] bytes8 = BitConverter.GetBytes(frequency);
			stream.Write(bytes8, 0, 4);
			byte[] bytes9 = BitConverter.GetBytes(frequency * channels * 2);
			stream.Write(bytes9, 0, 4);
			ushort value = (ushort)(channels * 2);
			stream.Write(BitConverter.GetBytes(value), 0, 2);
			byte[] bytes10 = BitConverter.GetBytes((ushort)16);
			stream.Write(bytes10, 0, 2);
			byte[] bytes11 = Encoding.UTF8.GetBytes("data");
			stream.Write(bytes11, 0, 4);
			byte[] bytes12 = BitConverter.GetBytes(samples * channels * 2);
			stream.Write(bytes12, 0, 4);
			UnityEngine.Debug.Log("stream.Length == " + stream.Length);
		}

		private FileStream CreateEmpty(string filepath)
		{
			FileStream fileStream = new FileStream(filepath, FileMode.Create);
			byte value = 0;
			for (int i = 0; i < 44; i++)
			{
				fileStream.WriteByte(value);
			}
			return fileStream;
		}

		private void ConvertAndWrite(FileStream fileStream, AudioClip clip)
		{
			float[] array = new float[clip.samples];
			clip.GetData(array, 0);
			short[] array2 = new short[array.Length];
			byte[] array3 = new byte[array.Length * 2];
			int num = 32767;
			for (int i = 0; i < array.Length; i++)
			{
				array2[i] = (short)(array[i] * (float)num);
				_ = new byte[2];
				BitConverter.GetBytes(array2[i]).CopyTo(array3, i * 2);
			}
			fileStream.Write(array3, 0, array3.Length);
		}

		private byte[] GetClipData()
		{
			if (CurAudioSource.clip == null)
			{
				return null;
			}
			float[] array = new float[CurAudioSource.clip.samples];
			CurAudioSource.clip.GetData(array, 0);
			byte[] array2 = new byte[array.Length * 2];
			int num = 32767;
			for (int i = 0; i < array.Length; i++)
			{
				byte[] bytes = BitConverter.GetBytes((short)(array[i] * (float)num));
				array2[i * 2] = bytes[0];
				array2[i * 2 + 1] = bytes[1];
			}
			if (array2.Length == 0)
			{
				ShowInfoLog("get data fail");
				return null;
			}
			return array2;
		}

		private void StartRecord()
		{
			if (!_isRecording)
			{
				File.Delete(fileurl);
				ShowInfoLog("ready start record.....");
				CurAudioSource.Stop();
				CurAudioSource.loop = false;
				CurAudioSource.mute = true;
				micSecondCount = _micSecond;
				CurAudioSource.clip = Microphone.Start(_deviceName, loop: false, _micSecond, _frequency);
				while (Microphone.GetPosition(_deviceName) <= 0)
				{
				}
				_isRecording = true;
				CurAudioSource.Play();
				ShowInfoLog("start record.....");
			}
		}

		private float[] GetMaxVolume(int dataLENGTH)
		{
			if (CurAudioSource.clip == null)
			{
				return null;
			}
			float[] array = new float[dataLENGTH];
			int num = Microphone.GetPosition(_deviceName) - dataLENGTH + 1;
			if (num < 0)
			{
				return array;
			}
			CurAudioSource.clip.GetData(array, num);
			return array;
		}

		private float AudioLength()
		{
			int position = Microphone.GetPosition(_deviceName);
			if (position > 0)
			{
				float[] array = new float[CurAudioSource.clip.samples * CurAudioSource.clip.channels];
				CurAudioSource.clip.GetData(array, 0);
				float[] array2 = new float[position * CurAudioSource.clip.channels];
				for (int i = 0; i < array2.Length; i++)
				{
					array2[i] = array[i];
				}
				CurAudioSource.clip = AudioClip.Create(CurAudioSource.clip.name, position, CurAudioSource.clip.channels, CurAudioSource.clip.frequency, stream: false);
				CurAudioSource.clip.SetData(array2, 0);
			}
			return CurAudioSource.clip.length;
		}

		private void ShowInfoLog(string info)
		{
			UnityEngine.Debug.Log(info);
		}
	}
	public class VoiceRecUtility
	{
		public class Token
		{
			public string access_token;

			public DateTime expireTime;
		}

		private delegate void AsyRequetCallback(object asyObj, string respStr, int statusCode, WebException webEx);

		private class AsyResultTag
		{
			public object obj { get; set; }

			public HttpWebRequest req { get; set; }

			public AsyRequetCallback callback { get; set; }
		}

		private static string m_url_qiniuyun_Token = UrlUtils.baseUrl_es + UrlUtils.Qiniuyun_Token;

		private static string m_url_qiniuyun_Upload = "https://upload-z2.qiniup.com";

		private static string m_url_api_voiceRec = UrlUtils.baseUrl_es + UrlUtils.voice;

		private static Token m_token;

		public static void J_GetVoiceResult(byte[] voicebytes, Action<DataRequestResult_voiceData> callback)
		{
			UnityEngine.Debug.Log("--start getting");
			if (voicebytes == null)
			{
				if (callback != null)
				{
					callback(null);
				}
				return;
			}
			GetQinuiyunToken(delegate(string token)
			{
				UnityEngine.Debug.Log(token);
				if (!string.IsNullOrEmpty(token))
				{
					Singleton<MiniMonoBehaviour>.Instance.StartCoroutine(uploadVoiceFileToQiniuyun(voicebytes, token, callback));
				}
			});
		}

		private static void GetQinuiyunToken(Action<string> callback)
		{
			UnityEngine.Debug.Log("--getting qiniuyun token");
			if (isTokenValid())
			{
				UnityEngine.Debug.Log("--token get");
				if (callback != null)
				{
					callback(m_token.access_token);
				}
				return;
			}
			Singleton<MiniMonoBehaviour>.Instance.StartCoroutine(yieldGetQinuiyunToken(delegate(string _token)
			{
				m_token = new Token();
				m_token.access_token = _token;
				m_token.expireTime = DateTime.Now;
				if (callback != null)
				{
					callback(m_token.access_token);
				}
			}));
		}

		private static bool isTokenValid()
		{
			if (m_token == null)
			{
				return false;
			}
			if (string.IsNullOrEmpty(m_token.access_token))
			{
				return false;
			}
			UnityEngine.Debug.Log("--check token expire time");
			TimeSpan ts = new TimeSpan(m_token.expireTime.Ticks);
			TimeSpan timeSpan = new TimeSpan(DateTime.Now.Ticks);
			if (timeSpan.Subtract(ts).Duration().Minutes > 60)
			{
				return false;
			}
			return true;
		}

		public static IEnumerator yieldGetQinuiyunToken(Action<string> callback)
		{
			WWWForm wWWForm = new WWWForm();
			wWWForm.AddField("prefix", "voice");
			string token = "";
			UnityEngine.Debug.Log("--getting qiniuyun token:sendwebrequest");
			using (UnityWebRequest webRequest = UnityWebRequest.Post(m_url_qiniuyun_Token, wWWForm))
			{
				webRequest.certificateHandler = new WebRequestCert();
				yield return webRequest.SendWebRequest();
				if (webRequest.isHttpError || webRequest.isNetworkError)
				{
					UnityEngine.Debug.LogError(webRequest.error);
				}
				else
				{
					UnityEngine.Debug.Log(webRequest.downloadHandler.text);
					try
					{
						DataRequestResult dataRequestResult = LitJson.JsonMapper.ToObject<DataRequestResult>(webRequest.downloadHandler.text);
						if (dataRequestResult.code == 200)
						{
							token = dataRequestResult.data;
						}
						else
						{
							m_token.access_token = null;
							UnityEngine.Debug.LogError("data error:" + webRequest.downloadHandler.text);
						}
					}
					catch (Exception ex)
					{
						m_token.access_token = null;
						UnityEngine.Debug.LogError("json format error:" + webRequest.downloadHandler.text);
						UnityEngine.Debug.LogError(ex.Message);
					}
				}
			}
			callback?.Invoke(token);
		}

		public static string HttpPostData(byte[] filedatas, string token)
		{
			string result = "";
			MemoryStream memoryStream = new MemoryStream();
			HttpWebRequest httpWebRequest = (HttpWebRequest)WebRequest.Create(m_url_qiniuyun_Upload);
			string text = "---------------" + DateTime.Now.Ticks.ToString("x");
			byte[] bytes = Encoding.ASCII.GetBytes("--" + text + "\r\n");
			byte[] bytes2 = Encoding.ASCII.GetBytes("--" + text + "--\r\n");
			httpWebRequest.Method = "POST";
			httpWebRequest.Timeout = 10000;
			httpWebRequest.ContentType = "multipart/form-data; boundary=" + text;
			byte[] bytes3 = Encoding.UTF8.GetBytes("Content-Disposition: form-data; name=\"file\"; filename=\"voiceRecord\"\r\nContent-Type: application/octet-stream\r\n\r\n");
			memoryStream.Write(bytes, 0, bytes.Length);
			memoryStream.Write(bytes3, 0, bytes3.Length);
			memoryStream.Write(filedatas, 0, filedatas.Length);
			byte[] bytes4 = Encoding.ASCII.GetBytes("\r\n");
			memoryStream.Write(bytes4, 0, bytes4.Length);
			string format = "\r\n--" + text + "\r\nContent-Disposition: form-data; name=\"{0}\"\r\n\r\n{1}\r\n";
			byte[] bytes5 = Encoding.UTF8.GetBytes(string.Format(format, "token", token));
			memoryStream.Write(bytes5, 0, bytes5.Length);
			memoryStream.Write(bytes2, 0, bytes2.Length);
			httpWebRequest.ContentLength = memoryStream.Length;
			Stream requestStream = httpWebRequest.GetRequestStream();
			memoryStream.Position = 0L;
			byte[] array = new byte[memoryStream.Length];
			memoryStream.Read(array, 0, array.Length);
			memoryStream.Close();
			requestStream.Write(array, 0, array.Length);
			requestStream.Close();
			HttpWebResponse httpWebResponse = (HttpWebResponse)httpWebRequest.GetResponse();
			using (StreamReader streamReader = new StreamReader(httpWebResponse.GetResponseStream(), Encoding.GetEncoding("utf-8")))
			{
				result = streamReader.ReadToEnd();
			}
			httpWebResponse.Close();
			httpWebRequest.Abort();
			return result;
		}

		private static void HttpCallback(IAsyncResult asynchronousResult)
		{
			new AsyResultTag();
			try
			{
				HttpWebResponse obj = (asynchronousResult.AsyncState as AsyResultTag).req.EndGetResponse(asynchronousResult) as HttpWebResponse;
				Stream responseStream = obj.GetResponseStream();
				StreamReader streamReader = new StreamReader(responseStream, Encoding.GetEncoding("utf-8"));
				UnityEngine.Debug.Log(streamReader.ReadToEnd());
				new GameObject("ds");
				streamReader.Close();
				responseStream.Close();
				_ = obj.StatusCode;
			}
			catch (WebException ex)
			{
				if ((HttpWebResponse)ex.Response != null)
				{
					_ = ((HttpWebResponse)ex.Response).StatusCode;
				}
			}
		}

		public static IEnumerator uploadVoiceFileToQiniuyun(byte[] filedatas, string token, Action<DataRequestResult_voiceData> callback)
		{
			string text = HttpPostData(filedatas, token);
			UnityEngine.Debug.Log(text);
			qiniuyun_DataRequestResult qiniuyun_DataRequestResult2 = LitJson.JsonMapper.ToObject<qiniuyun_DataRequestResult>(text);
			UnityEngine.Debug.Log("--try call server to rec voice");
			WWWForm wWWForm = new WWWForm();
			wWWForm.AddField("deviceuniqueID", SystemInfo.deviceUniqueIdentifier);
			wWWForm.AddField("file_key", qiniuyun_DataRequestResult2.file_key);
			wWWForm.AddField("file_url", qiniuyun_DataRequestResult2.file_url);
			wWWForm.AddField("file_name", qiniuyun_DataRequestResult2.file_name);
			wWWForm.AddField("file_size", qiniuyun_DataRequestResult2.file_size);
			wWWForm.AddField("mime_type", qiniuyun_DataRequestResult2.mime_type);
			DataRequestResult_voiceData recResult = new DataRequestResult_voiceData
			{
				file_txt = ""
			};
			using (UnityWebRequest webRequest = UnityWebRequest.Post(m_url_api_voiceRec, wWWForm))
			{
				webRequest.SetRequestHeader("Accept", "application/json");
				webRequest.certificateHandler = new WebRequestCert();
				yield return webRequest.SendWebRequest();
				if (webRequest.isHttpError || webRequest.isNetworkError)
				{
					UnityEngine.Debug.LogError(webRequest.error);
				}
				else
				{
					UnityEngine.Debug.Log(webRequest.downloadHandler.text);
					try
					{
						DataRequestResult_02 dataRequestResult_ = LitJson.JsonMapper.ToObject<DataRequestResult_02>(webRequest.downloadHandler.text);
						if (dataRequestResult_.code == 200)
						{
							recResult = dataRequestResult_.data;
						}
						else
						{
							UnityEngine.Debug.LogError("data error:" + webRequest.downloadHandler.text);
						}
					}
					catch (Exception ex)
					{
						UnityEngine.Debug.LogError("json format error:" + webRequest.downloadHandler.text);
						UnityEngine.Debug.LogError(ex.StackTrace + ":" + ex.Message);
					}
				}
			}
			callback?.Invoke(recResult);
		}

		private static bool CheckValidationResult(object sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors errors)
		{
			return true;
		}
	}
	public class DataRequestResult
	{
		public int code;

		public string msg;

		public string data;
	}
	public class DataRequestResult_02
	{
		public int code;

		public string msg;

		public DataRequestResult_voiceData data;
	}
	public class DataRequestResult_03
	{
		public int code;

		public string msg;

		public qiniuyun_DataRequestResult data;
	}
	public class qiniuyun_DataRequestResult
	{
		public string file_url;

		public string file_key;

		public int file_size;

		public string file_name;

		public string mime_type;

		public string id;
	}
	public class DataRequestResult_voiceData
	{
		public int id;

		public string file_key;

		public string file_url;

		public string file_txt;
	}
	public class VoiceRecUtility_adhd
	{
		public class Token
		{
			public string access_token;

			public DateTime expireTime;
		}

		private delegate void AsyRequetCallback(object asyObj, string respStr, int statusCode, WebException webEx);

		private class AsyResultTag
		{
			public object obj { get; set; }

			public HttpWebRequest req { get; set; }

			public AsyRequetCallback callback { get; set; }
		}

		private static Dictionary<string, Token> m_tokenDic;

		public static Dictionary<string, Token> TokenDic
		{
			get
			{
				if (m_tokenDic == null)
				{
					m_tokenDic = new Dictionary<string, Token>();
				}
				return m_tokenDic;
			}
		}

		public static void J_GetVoiceResult(byte[] voicebytes, Action<DataRequestResult_voiceData> callback, string prefix)
		{
			UnityEngine.Debug.Log("--start getting");
			if (voicebytes == null)
			{
				if (callback != null)
				{
					callback(null);
				}
				return;
			}
			GetQinuiyunToken("", delegate(string token)
			{
				UnityEngine.Debug.Log(token);
				if (!string.IsNullOrEmpty(token))
				{
					Singleton<MiniMonoBehaviour>.Instance.StartCoroutine(uploadVoiceFileToQiniuyun(voicebytes, token, callback));
				}
			}, prefix);
		}

		public static void UploadFileToQiniuyun(string base_url, string prefix, byte[] filebytes, Action<string> callback)
		{
			UnityEngine.Debug.Log("--start getting");
			if (filebytes == null)
			{
				if (callback != null)
				{
					callback(null);
				}
				return;
			}
			GetQinuiyunToken(base_url, delegate(string token)
			{
				UnityEngine.Debug.Log(token);
				if (!string.IsNullOrEmpty(token))
				{
					WWWForm wWWForm = new WWWForm();
					wWWForm.AddField("token", token);
					wWWForm.AddBinaryData("file", filebytes, "file");
					UnityWebRequestHelper.Instance.Upload(UrlUtils.Qiniuyun_Upload, wWWForm, delegate(RequestStatus status, string result)
					{
						if (status == RequestStatus.success)
						{
							callback(result);
						}
						else
						{
							callback(null);
						}
					});
				}
				else
				{
					callback(null);
				}
			}, prefix);
		}

		private static void GetQinuiyunToken(string base_url, Action<string> callback, string prefix)
		{
			UnityEngine.Debug.Log("--getting qiniuyun token");
			if (isTokenValid(prefix))
			{
				UnityEngine.Debug.Log("--token get");
				if (callback != null)
				{
					callback(TokenDic[prefix].access_token);
				}
				return;
			}
			TokenDic[prefix] = new Token();
			yieldGetQinuiyunToken(base_url, delegate(string _token)
			{
				if (string.IsNullOrEmpty(_token))
				{
					callback(_token);
				}
				else
				{
					TokenDic[prefix].access_token = _token;
					TokenDic[prefix].expireTime = DateTime.Now;
					if (callback != null)
					{
						callback(TokenDic[prefix].access_token);
					}
				}
			}, prefix);
		}

		private static bool isTokenValid(string prefix)
		{
			if (!TokenDic.ContainsKey(prefix))
			{
				return false;
			}
			if (string.IsNullOrEmpty(TokenDic[prefix].access_token))
			{
				return false;
			}
			UnityEngine.Debug.Log("--check token expire time");
			TimeSpan ts = new TimeSpan(TokenDic[prefix].expireTime.Ticks);
			TimeSpan timeSpan = new TimeSpan(DateTime.Now.Ticks);
			TimeSpan timeSpan2 = timeSpan.Subtract(ts).Duration();
			if (timeSpan2.Hours > 0 || timeSpan2.Minutes > 55)
			{
				return false;
			}
			return true;
		}

		private static void yieldGetQinuiyunToken(string base_url, Action<string> callback, string prefix)
		{
			string url = base_url + "?prefix=" + prefix;
			string token = "";
			UnityWebRequestHelper.Instance.Get(url, delegate(RequestStatus status, string result)
			{
				if (status == RequestStatus.success)
				{
					DataRequestResult dataRequestResult = LitJson.JsonMapper.ToObject<DataRequestResult>(result);
					token = dataRequestResult.data;
					callback?.Invoke(token);
				}
				else
				{
					TokenDic[prefix].access_token = null;
					UnityEngine.Debug.LogError("data error:" + result);
					callback?.Invoke("");
				}
			}, isToken: true);
		}

		private static string HttpPostData(byte[] filedatas, string token)
		{
			string result = "";
			MemoryStream memoryStream = new MemoryStream();
			HttpWebRequest httpWebRequest = (HttpWebRequest)WebRequest.Create(UrlUtils.Qiniuyun_Upload);
			string text = "---------------" + DateTime.Now.Ticks.ToString("x");
			byte[] bytes = Encoding.ASCII.GetBytes("--" + text + "\r\n");
			byte[] bytes2 = Encoding.ASCII.GetBytes("--" + text + "--\r\n");
			httpWebRequest.Method = "POST";
			httpWebRequest.Timeout = 10000;
			httpWebRequest.ContentType = "multipart/form-data; boundary=" + text;
			byte[] bytes3 = Encoding.UTF8.GetBytes("Content-Disposition: form-data; name=\"file\"; filename=\"voiceRecord\"\r\nContent-Type: application/octet-stream\r\n\r\n");
			memoryStream.Write(bytes, 0, bytes.Length);
			memoryStream.Write(bytes3, 0, bytes3.Length);
			memoryStream.Write(filedatas, 0, filedatas.Length);
			byte[] bytes4 = Encoding.ASCII.GetBytes("\r\n");
			memoryStream.Write(bytes4, 0, bytes4.Length);
			string format = "\r\n--" + text + "\r\nContent-Disposition: form-data; name=\"{0}\"\r\n\r\n{1}\r\n";
			byte[] bytes5 = Encoding.UTF8.GetBytes(string.Format(format, "token", token));
			memoryStream.Write(bytes5, 0, bytes5.Length);
			memoryStream.Write(bytes2, 0, bytes2.Length);
			httpWebRequest.ContentLength = memoryStream.Length;
			Stream requestStream = httpWebRequest.GetRequestStream();
			memoryStream.Position = 0L;
			byte[] array = new byte[memoryStream.Length];
			memoryStream.Read(array, 0, array.Length);
			memoryStream.Close();
			requestStream.Write(array, 0, array.Length);
			requestStream.Close();
			HttpWebResponse httpWebResponse = (HttpWebResponse)httpWebRequest.GetResponse();
			using (StreamReader streamReader = new StreamReader(httpWebResponse.GetResponseStream(), Encoding.GetEncoding("utf-8")))
			{
				result = streamReader.ReadToEnd();
			}
			httpWebResponse.Close();
			httpWebRequest.Abort();
			return result;
		}

		private static void HttpCallback(IAsyncResult asynchronousResult)
		{
			new AsyResultTag();
			try
			{
				HttpWebResponse obj = (asynchronousResult.AsyncState as AsyResultTag).req.EndGetResponse(asynchronousResult) as HttpWebResponse;
				Stream responseStream = obj.GetResponseStream();
				StreamReader streamReader = new StreamReader(responseStream, Encoding.GetEncoding("utf-8"));
				UnityEngine.Debug.Log(streamReader.ReadToEnd());
				new GameObject("ds");
				streamReader.Close();
				responseStream.Close();
				_ = obj.StatusCode;
			}
			catch (WebException ex)
			{
				if ((HttpWebResponse)ex.Response != null)
				{
					_ = ((HttpWebResponse)ex.Response).StatusCode;
				}
			}
		}

		private static IEnumerator uploadVoiceFileToQiniuyun(byte[] filedatas, string token, Action<DataRequestResult_voiceData> callback)
		{
			string text = HttpPostData(filedatas, token);
			UnityEngine.Debug.Log(text);
			qiniuyun_DataRequestResult_adhd qiniuyun_DataRequestResult_adhd2 = LitJson.JsonMapper.ToObject<qiniuyun_DataRequestResult_adhd>(text);
			UnityEngine.Debug.Log("--try call server to rec voice");
			WWWForm wWWForm = new WWWForm();
			wWWForm.AddField("file_key", qiniuyun_DataRequestResult_adhd2.data.file_key);
			wWWForm.AddField("file_url", qiniuyun_DataRequestResult_adhd2.data.file_url);
			wWWForm.AddField("file_name", qiniuyun_DataRequestResult_adhd2.data.file_name);
			wWWForm.AddField("file_size", qiniuyun_DataRequestResult_adhd2.data.file_size);
			wWWForm.AddField("mime_type", qiniuyun_DataRequestResult_adhd2.data.mime_type);
			DataRequestResult_voiceData recResult = new DataRequestResult_voiceData
			{
				file_txt = ""
			};
			using (UnityWebRequest webRequest = UnityWebRequest.Post(UrlUtils.baseUrl_adhd + UrlUtils.voiceRec, wWWForm))
			{
				webRequest.SetRequestHeader("Accept", "application/json");
				webRequest.SetRequestHeader("Authorization", "Bearer " + LoadManager.userData.data.token);
				webRequest.certificateHandler = new WebRequestCert();
				yield return webRequest.SendWebRequest();
				if (webRequest.isHttpError || webRequest.isNetworkError)
				{
					UnityEngine.Debug.LogError(webRequest.error);
				}
				else
				{
					UnityEngine.Debug.Log(webRequest.downloadHandler.text);
					try
					{
						DataRequestResult_02 dataRequestResult_ = LitJson.JsonMapper.ToObject<DataRequestResult_02>(webRequest.downloadHandler.text);
						if (dataRequestResult_.code == 200)
						{
							recResult = dataRequestResult_.data;
						}
						else
						{
							UnityEngine.Debug.LogError("data error:" + webRequest.downloadHandler.text);
						}
					}
					catch (Exception ex)
					{
						UnityEngine.Debug.LogError("json format error:" + webRequest.downloadHandler.text);
						UnityEngine.Debug.LogError(ex.StackTrace + ":" + ex.Message);
					}
				}
			}
			callback?.Invoke(recResult);
		}

		private static void UploadFileToQiniuyun(byte[] filedatas, string token, Action<DataRequestResult_voiceData> callback)
		{
		}

		private static bool CheckValidationResult(object sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors errors)
		{
			return true;
		}
	}
	public class qiniuyun_DataRequestResult_adhd
	{
		public int code;

		public string msg;

		public qiniuyun_DataRequestResult_01 data;
	}
	public class qiniuyun_DataRequestResult_01
	{
		public string id;

		public string file_url;

		public string file_key;

		public int file_size;

		public string file_name;

		public string mime_type;
	}
}
namespace J_LitCSV
{
	public class CsvMapper
	{
		public static List<T> ToObjectList<T>(string csv)
		{
			string[][] array = CsvParser.Parse(csv);
			List<T> list = new List<T>();
			FieldInfo[] fields = typeof(T).GetFields(BindingFlags.Instance | BindingFlags.Public);
			for (int i = 1; i < array.Length; i++)
			{
				object obj = Activator.CreateInstance(typeof(T));
				for (int j = 0; j < array[i].Length; j++)
				{
					string fieldName = array[0][j];
					string text = array[i][j];
					FieldInfo[] array2 = fields.Where((FieldInfo t) => t.Name == fieldName).ToArray();
					if (array2 == null || array2.Length != 1)
					{
						continue;
					}
					FieldInfo fieldInfo = array2[0];
					if (fieldInfo.FieldType == typeof(int))
					{
						fieldInfo.SetValue(obj, int.Parse(text));
					}
					else if (fieldInfo.FieldType == typeof(string))
					{
						fieldInfo.SetValue(obj, text);
					}
					else if (fieldInfo.FieldType == typeof(float))
					{
						fieldInfo.SetValue(obj, float.Parse(text));
					}
					else if (fieldInfo.FieldType == typeof(List<int>))
					{
						string[] array3 = text.Split(',');
						List<int> list2 = new List<int>();
						string[] array4 = array3;
						foreach (string s in array4)
						{
							list2.Add(int.Parse(s));
						}
						fieldInfo.SetValue(obj, list2);
					}
					else if (fieldInfo.FieldType == typeof(List<float>))
					{
						string[] array5 = text.Split(',');
						List<float> list3 = new List<float>();
						string[] array4 = array5;
						foreach (string s2 in array4)
						{
							list3.Add(float.Parse(s2));
						}
						fieldInfo.SetValue(obj, list3);
					}
					else if (fieldInfo.FieldType == typeof(List<string>))
					{
						string[] source = text.Split(',');
						fieldInfo.SetValue(obj, source.ToList());
					}
				}
				list.Add((T)obj);
			}
			return list;
		}
	}
	public class CsvParser
	{
		private abstract class ParserState
		{
			public static readonly LineStartState LineStartState = new LineStartState();

			public static readonly ValueStartState ValueStartState = new ValueStartState();

			public static readonly ValueState ValueState = new ValueState();

			public static readonly QuotedValueState QuotedValueState = new QuotedValueState();

			public static readonly QuoteState QuoteState = new QuoteState();

			public abstract ParserState AnyChar(char ch, ParserContext context);

			public abstract ParserState Comma(ParserContext context);

			public abstract ParserState Quote(ParserContext context);

			public abstract ParserState EndOfLine(ParserContext context);
		}

		private class LineStartState : ParserState
		{
			public override ParserState AnyChar(char ch, ParserContext context)
			{
				context.AddChar(ch);
				return ParserState.ValueState;
			}

			public override ParserState Comma(ParserContext context)
			{
				context.AddValue();
				return ParserState.ValueStartState;
			}

			public override ParserState Quote(ParserContext context)
			{
				return ParserState.QuotedValueState;
			}

			public override ParserState EndOfLine(ParserContext context)
			{
				context.AddLine();
				return ParserState.LineStartState;
			}
		}

		private class ValueStartState : LineStartState
		{
			public override ParserState EndOfLine(ParserContext context)
			{
				context.AddValue();
				context.AddLine();
				return ParserState.LineStartState;
			}
		}

		private class ValueState : ParserState
		{
			public override ParserState AnyChar(char ch, ParserContext context)
			{
				context.AddChar(ch);
				return ParserState.ValueState;
			}

			public override ParserState Comma(ParserContext context)
			{
				context.AddValue();
				return ParserState.ValueStartState;
			}

			public override ParserState Quote(ParserContext context)
			{
				context.AddChar('"');
				return ParserState.ValueState;
			}

			public override ParserState EndOfLine(ParserContext context)
			{
				context.AddValue();
				context.AddLine();
				return ParserState.LineStartState;
			}
		}

		private class QuotedValueState : ParserState
		{
			public override ParserState AnyChar(char ch, ParserContext context)
			{
				context.AddChar(ch);
				return ParserState.QuotedValueState;
			}

			public override ParserState Comma(ParserContext context)
			{
				context.AddChar(',');
				return ParserState.QuotedValueState;
			}

			public override ParserState Quote(ParserContext context)
			{
				return ParserState.QuoteState;
			}

			public override ParserState EndOfLine(ParserContext context)
			{
				context.AddChar('\r');
				context.AddChar('\n');
				return ParserState.QuotedValueState;
			}
		}

		private class QuoteState : ParserState
		{
			public override ParserState AnyChar(char ch, ParserContext context)
			{
				context.AddChar(ch);
				return ParserState.QuotedValueState;
			}

			public override ParserState Comma(ParserContext context)
			{
				context.AddValue();
				return ParserState.ValueStartState;
			}

			public override ParserState Quote(ParserContext context)
			{
				context.AddChar('"');
				return ParserState.QuotedValueState;
			}

			public override ParserState EndOfLine(ParserContext context)
			{
				context.AddValue();
				context.AddLine();
				return ParserState.LineStartState;
			}
		}

		private class ParserContext
		{
			private readonly StringBuilder _currentValue = new StringBuilder();

			private readonly List<string[]> _lines = new List<string[]>();

			private readonly List<string> _currentLine = new List<string>();

			public void AddChar(char ch)
			{
				_currentValue.Append(ch);
			}

			public void AddValue()
			{
				_currentLine.Add(_currentValue.ToString());
				_currentValue.Remove(0, _currentValue.Length);
			}

			public void AddLine()
			{
				_lines.Add(_currentLine.ToArray());
				_currentLine.Clear();
			}

			public List<string[]> GetAllLines()
			{
				if (_currentValue.Length > 0)
				{
					AddValue();
				}
				if (_currentLine.Count > 0)
				{
					AddLine();
				}
				return _lines;
			}
		}

		private const char CommaCharacter = ',';

		private const char QuoteCharacter = '"';

		public string[][] Parse(TextReader reader)
		{
			ParserContext parserContext = new ParserContext();
			ParserState parserState = ParserState.LineStartState;
			string text;
			while ((text = reader.ReadLine()) != null)
			{
				string text2 = text;
				foreach (char c in text2)
				{
					parserState = c switch
					{
						',' => parserState.Comma(parserContext), 
						'"' => parserState.Quote(parserContext), 
						_ => parserState.AnyChar(c, parserContext), 
					};
				}
				parserState = parserState.EndOfLine(parserContext);
			}
			return parserContext.GetAllLines().ToArray();
		}

		public static string[][] Parse(string input)
		{
			CsvParser csvParser = new CsvParser();
			using StringReader reader = new StringReader(input);
			return csvParser.Parse(reader);
		}
	}
}
namespace SplineMesh
{
	[Serializable]
	public class CubicBezierCurve
	{
		private const int STEP_COUNT = 30;

		private const float T_STEP = 1f / 30f;

		private readonly List<CurveSample> samples = new List<CurveSample>(30);

		public SplineNode n1;

		public SplineNode n2;

		public UnityEvent Changed = new UnityEvent();

		public float Length { get; private set; }

		public CubicBezierCurve(SplineNode n1, SplineNode n2)
		{
			this.n1 = n1;
			this.n2 = n2;
			n1.Changed += ComputeSamples;
			n2.Changed += ComputeSamples;
			ComputeSamples(null, null);
		}

		public void ConnectStart(SplineNode n1)
		{
			this.n1.Changed -= ComputeSamples;
			this.n1 = n1;
			n1.Changed += ComputeSamples;
			ComputeSamples(null, null);
		}

		public void ConnectEnd(SplineNode n2)
		{
			this.n2.Changed -= ComputeSamples;
			this.n2 = n2;
			n2.Changed += ComputeSamples;
			ComputeSamples(null, null);
		}

		public Vector3 GetInverseDirection()
		{
			return 2f * n2.Position - n2.Direction;
		}

		private Vector3 GetLocation(float t)
		{
			float num = 1f - t;
			float num2 = num * num;
			float num3 = t * t;
			return n1.Position * (num2 * num) + n1.Direction * (3f * num2 * t) + GetInverseDirection() * (3f * num * num3) + n2.Position * (num3 * t);
		}

		private Vector3 GetTangent(float t)
		{
			float num = 1f - t;
			float num2 = num * num;
			float num3 = t * t;
			return (n1.Position * (0f - num2) + n1.Direction * (3f * num2 - 2f * num) + GetInverseDirection() * (-3f * num3 + 2f * t) + n2.Position * num3).normalized;
		}

		private Vector3 GetUp(float t)
		{
			return Vector3.Lerp(n1.Up, n2.Up, t);
		}

		private Vector2 GetScale(float t)
		{
			return Vector2.Lerp(n1.Scale, n2.Scale, t);
		}

		private float GetRoll(float t)
		{
			return Mathf.Lerp(n1.Roll, n2.Roll, t);
		}

		private void ComputeSamples(object sender, EventArgs e)
		{
			samples.Clear();
			Length = 0f;
			Vector3 a = GetLocation(0f);
			for (float num = 0f; num < 1f; num += 1f / 30f)
			{
				Vector3 location = GetLocation(num);
				Length += Vector3.Distance(a, location);
				a = location;
				samples.Add(CreateSample(Length, num));
			}
			Length += Vector3.Distance(a, GetLocation(1f));
			samples.Add(CreateSample(Length, 1f));
			if (Changed != null)
			{
				Changed.Invoke();
			}
		}

		private CurveSample CreateSample(float distance, float time)
		{
			return new CurveSample(GetLocation(time), GetTangent(time), GetUp(time), GetScale(time), GetRoll(time), distance, time);
		}

		public CurveSample GetSample(float time)
		{
			AssertTimeInBounds(time);
			CurveSample curveSample = samples[0];
			CurveSample curveSample2 = default(CurveSample);
			bool flag = false;
			foreach (CurveSample sample in samples)
			{
				if (sample.timeInCurve >= time)
				{
					curveSample2 = sample;
					flag = true;
					break;
				}
				curveSample = sample;
			}
			if (!flag)
			{
				throw new Exception("Can't find curve samples.");
			}
			float t = ((curveSample2 == curveSample) ? 0f : ((time - curveSample.timeInCurve) / (curveSample2.timeInCurve - curveSample.timeInCurve)));
			return CurveSample.Lerp(curveSample, curveSample2, t);
		}

		public CurveSample GetSampleAtDistance(float d)
		{
			if (d < 0f || d > Length)
			{
				throw new ArgumentException("Distance must be positive and less than curve length. Length = " + Length + ", given distance was " + d);
			}
			CurveSample curveSample = samples[0];
			CurveSample curveSample2 = default(CurveSample);
			bool flag = false;
			foreach (CurveSample sample in samples)
			{
				if (sample.distanceInCurve >= d)
				{
					curveSample2 = sample;
					flag = true;
					break;
				}
				curveSample = sample;
			}
			if (!flag)
			{
				throw new Exception("Can't find curve samples.");
			}
			float t = ((curveSample2 == curveSample) ? 0f : ((d - curveSample.distanceInCurve) / (curveSample2.distanceInCurve - curveSample.distanceInCurve)));
			return CurveSample.Lerp(curveSample, curveSample2, t);
		}

		private static void AssertTimeInBounds(float time)
		{
			if (time < 0f || time > 1f)
			{
				throw new ArgumentException("Time must be between 0 and 1 (was " + time + ").");
			}
		}

		public CurveSample GetProjectionSample(Vector3 pointToProject)
		{
			float num = float.PositiveInfinity;
			int num2 = -1;
			int num3 = 0;
			foreach (CurveSample sample in samples)
			{
				float sqrMagnitude = (sample.location - pointToProject).sqrMagnitude;
				if (sqrMagnitude < num)
				{
					num = sqrMagnitude;
					num2 = num3;
				}
				num3++;
			}
			CurveSample a;
			CurveSample b;
			if (num2 == 0)
			{
				a = samples[num2];
				b = samples[num2 + 1];
			}
			else if (num2 == samples.Count - 1)
			{
				a = samples[num2 - 1];
				b = samples[num2];
			}
			else
			{
				float sqrMagnitude2 = (pointToProject - samples[num2 - 1].location).sqrMagnitude;
				float sqrMagnitude3 = (pointToProject - samples[num2 + 1].location).sqrMagnitude;
				if (sqrMagnitude2 < sqrMagnitude3)
				{
					a = samples[num2 - 1];
					b = samples[num2];
				}
				else
				{
					a = samples[num2];
					b = samples[num2 + 1];
				}
			}
			float value = (Vector3.Project(pointToProject - a.location, b.location - a.location) + a.location - a.location).sqrMagnitude / (b.location - a.location).sqrMagnitude;
			value = Mathf.Clamp(value, 0f, 1f);
			return CurveSample.Lerp(a, b, value);
		}
	}
	public struct CurveSample
	{
		public readonly Vector3 location;

		public readonly Vector3 tangent;

		public readonly Vector3 up;

		public readonly Vector2 scale;

		public readonly float roll;

		public readonly float distanceInCurve;

		public readonly float timeInCurve;

		private Quaternion rotation;

		public Quaternion Rotation
		{
			get
			{
				if (rotation == Quaternion.identity)
				{
					Vector3 upwards = Vector3.Cross(tangent, Vector3.Cross(Quaternion.AngleAxis(roll, Vector3.forward) * up, tangent).normalized);
					rotation = Quaternion.LookRotation(tangent, upwards);
				}
				return rotation;
			}
		}

		public CurveSample(Vector3 location, Vector3 tangent, Vector3 up, Vector2 scale, float roll, float distanceInCurve, float timeInCurve)
		{
			this.location = location;
			this.tangent = tangent;
			this.up = up;
			this.roll = roll;
			this.scale = scale;
			this.distanceInCurve = distanceInCurve;
			this.timeInCurve = timeInCurve;
			rotation = Quaternion.identity;
		}

		public override bool Equals(object obj)
		{
			if (obj == null || GetType() != obj.GetType())
			{
				return false;
			}
			CurveSample curveSample = (CurveSample)obj;
			if (location == curveSample.location && tangent == curveSample.tangent && up == curveSample.up && scale == curveSample.scale && roll == curveSample.roll && distanceInCurve == curveSample.distanceInCurve)
			{
				return timeInCurve == curveSample.timeInCurve;
			}
			return false;
		}

		public override int GetHashCode()
		{
			return base.GetHashCode();
		}

		public static bool operator ==(CurveSample cs1, CurveSample cs2)
		{
			return cs1.Equals(cs2);
		}

		public static bool operator !=(CurveSample cs1, CurveSample cs2)
		{
			return !cs1.Equals(cs2);
		}

		public static CurveSample Lerp(CurveSample a, CurveSample b, float t)
		{
			return new CurveSample(Vector3.Lerp(a.location, b.location, t), Vector3.Lerp(a.tangent, b.tangent, t).normalized, Vector3.Lerp(a.up, b.up, t), Vector2.Lerp(a.scale, b.scale, t), Mathf.Lerp(a.roll, b.roll, t), Mathf.Lerp(a.distanceInCurve, b.distanceInCurve, t), Mathf.Lerp(a.timeInCurve, b.timeInCurve, t));
		}

		public MeshVertex GetBent(MeshVertex vert)
		{
			MeshVertex meshVertex = new MeshVertex(vert.position, vert.normal, vert.uv);
			meshVertex.position = Vector3.Scale(meshVertex.position, new Vector3(0f, scale.y, scale.x));
			meshVertex.position = Quaternion.AngleAxis(roll, Vector3.right) * meshVertex.position;
			meshVertex.normal = Quaternion.AngleAxis(roll, Vector3.right) * meshVertex.normal;
			meshVertex.position.x = 0f;
			Quaternion quaternion = Rotation * Quaternion.Euler(0f, -90f, 0f);
			meshVertex.position = quaternion * meshVertex.position + location;
			meshVertex.normal = quaternion * meshVertex.normal;
			return meshVertex;
		}
	}
	[DisallowMultipleComponent]
	[ExecuteInEditMode]
	public class Spline : MonoBehaviour
	{
		public List<SplineNode> nodes = new List<SplineNode>();

		[HideInInspector]
		public List<CubicBezierCurve> curves = new List<CubicBezierCurve>();

		public float Length;

		[SerializeField]
		private bool isLoop;

		[HideInInspector]
		public UnityEvent CurveChanged = new UnityEvent();

		private SplineNode start;

		private SplineNode end;

		public bool IsLoop
		{
			get
			{
				return isLoop;
			}
			set
			{
				isLoop = value;
				updateLoopBinding();
			}
		}

		public event ListChangeHandler<SplineNode> NodeListChanged;

		private void Reset()
		{
			nodes.Clear();
			curves.Clear();
			AddNode(new SplineNode(new Vector3(5f, 0f, 0f), new Vector3(5f, 0f, -3f)));
			AddNode(new SplineNode(new Vector3(10f, 0f, 0f), new Vector3(10f, 0f, 3f)));
			RaiseNodeListChanged(new ListChangedEventArgs<SplineNode>
			{
				type = ListChangeType.clear
			});
			UpdateAfterCurveChanged();
		}

		private void OnEnable()
		{
			RefreshCurves();
		}

		public ReadOnlyCollection<CubicBezierCurve> GetCurves()
		{
			return curves.AsReadOnly();
		}

		private void RaiseNodeListChanged(ListChangedEventArgs<SplineNode> args)
		{
			if (this.NodeListChanged != null)
			{
				this.NodeListChanged(this, args);
			}
		}

		private void UpdateAfterCurveChanged()
		{
			Length = 0f;
			foreach (CubicBezierCurve curf in curves)
			{
				Length += curf.Length;
			}
			CurveChanged.Invoke();
		}

		public CurveSample GetSample(float t)
		{
			int nodeIndexForTime = GetNodeIndexForTime(t);
			return curves[nodeIndexForTime].GetSample(t - (float)nodeIndexForTime);
		}

		public CubicBezierCurve GetCurve(float t)
		{
			return curves[GetNodeIndexForTime(t)];
		}

		private int GetNodeIndexForTime(float t)
		{
			if (t < 0f || t > (float)(nodes.Count - 1))
			{
				throw new ArgumentException($"Time must be between 0 and last node index ({nodes.Count - 1}). Given time was {t}.");
			}
			int num = Mathf.FloorToInt(t);
			if (num == nodes.Count - 1)
			{
				num--;
			}
			return num;
		}

		public void RefreshCurves()
		{
			curves.Clear();
			for (int i = 0; i < nodes.Count - 1; i++)
			{
				SplineNode n = nodes[i];
				SplineNode n2 = nodes[i + 1];
				CubicBezierCurve cubicBezierCurve = new CubicBezierCurve(n, n2);
				cubicBezierCurve.Changed.AddListener(UpdateAfterCurveChanged);
				curves.Add(cubicBezierCurve);
			}
			RaiseNodeListChanged(new ListChangedEventArgs<SplineNode>
			{
				type = ListChangeType.clear
			});
			UpdateAfterCurveChanged();
		}

		public CurveSample GetSampleAtDistance(float d)
		{
			if (d < 0f || d > Length)
			{
				throw new ArgumentException($"Distance must be between 0 and spline length ({Length}). Given distance was {d}.");
			}
			foreach (CubicBezierCurve curf in curves)
			{
				if (d > curf.Length && d < curf.Length + 0.0001f)
				{
					d = curf.Length;
				}
				if (d > curf.Length)
				{
					d -= curf.Length;
					continue;
				}
				return curf.GetSampleAtDistance(d);
			}
			throw new Exception("Something went wrong with GetSampleAtDistance.");
		}

		public void AddNode(SplineNode node)
		{
			nodes.Add(node);
			if (nodes.Count != 1)
			{
				CubicBezierCurve cubicBezierCurve = new CubicBezierCurve(nodes[nodes.IndexOf(node) - 1], node);
				cubicBezierCurve.Changed.AddListener(UpdateAfterCurveChanged);
				curves.Add(cubicBezierCurve);
			}
			RaiseNodeListChanged(new ListChangedEventArgs<SplineNode>
			{
				type = ListChangeType.Add,
				newItems = new List<SplineNode> { node }
			});
			UpdateAfterCurveChanged();
			updateLoopBinding();
		}

		public void InsertNode(int index, SplineNode node)
		{
			if (index == 0)
			{
				throw new Exception("Can't insert a node at index 0");
			}
			_ = nodes[index - 1];
			SplineNode n = nodes[index];
			nodes.Insert(index, node);
			curves[index - 1].ConnectEnd(node);
			CubicBezierCurve cubicBezierCurve = new CubicBezierCurve(node, n);
			cubicBezierCurve.Changed.AddListener(UpdateAfterCurveChanged);
			curves.Insert(index, cubicBezierCurve);
			RaiseNodeListChanged(new ListChangedEventArgs<SplineNode>
			{
				type = ListChangeType.Insert,
				newItems = new List<SplineNode> { node },
				insertIndex = index
			});
			UpdateAfterCurveChanged();
			updateLoopBinding();
		}

		public void RemoveNode(SplineNode node)
		{
			int num = nodes.IndexOf(node);
			if (nodes.Count <= 2)
			{
				throw new Exception("Can't remove the node because a spline needs at least 2 nodes.");
			}
			CubicBezierCurve cubicBezierCurve = ((num == nodes.Count - 1) ? curves[num - 1] : curves[num]);
			if (num != 0 && num != nodes.Count - 1)
			{
				SplineNode n = nodes[num + 1];
				curves[num - 1].ConnectEnd(n);
			}
			nodes.RemoveAt(num);
			cubicBezierCurve.Changed.RemoveListener(UpdateAfterCurveChanged);
			curves.Remove(cubicBezierCurve);
			RaiseNodeListChanged(new ListChangedEventArgs<SplineNode>
			{
				type = ListChangeType.Remove,
				removedItems = new List<SplineNode> { node },
				removeIndex = num
			});
			UpdateAfterCurveChanged();
			updateLoopBinding();
		}

		private void updateLoopBinding()
		{
			if (start != null)
			{
				start.Changed -= StartNodeChanged;
			}
			if (end != null)
			{
				end.Changed -= EndNodeChanged;
			}
			if (isLoop)
			{
				start = nodes[0];
				end = nodes[nodes.Count - 1];
				start.Changed += StartNodeChanged;
				end.Changed += EndNodeChanged;
				StartNodeChanged(null, null);
			}
			else
			{
				start = null;
				end = null;
			}
		}

		private void StartNodeChanged(object sender, EventArgs e)
		{
			end.Changed -= EndNodeChanged;
			end.Position = start.Position;
			end.Direction = start.Direction;
			end.Roll = start.Roll;
			end.Scale = start.Scale;
			end.Up = start.Up;
			end.Changed += EndNodeChanged;
		}

		private void EndNodeChanged(object sender, EventArgs e)
		{
			start.Changed -= StartNodeChanged;
			start.Position = end.Position;
			start.Direction = end.Direction;
			start.Roll = end.Roll;
			start.Scale = end.Scale;
			start.Up = end.Up;
			start.Changed += StartNodeChanged;
		}

		public CurveSample GetProjectionSample(Vector3 pointToProject)
		{
			CurveSample result = default(CurveSample);
			float num = float.MaxValue;
			foreach (CubicBezierCurve curf in curves)
			{
				CurveSample projectionSample = curf.GetProjectionSample(pointToProject);
				if (curf == curves[0])
				{
					result = projectionSample;
					num = (projectionSample.location - pointToProject).sqrMagnitude;
					continue;
				}
				float sqrMagnitude = (projectionSample.location - pointToProject).sqrMagnitude;
				if (sqrMagnitude < num)
				{
					num = sqrMagnitude;
					result = projectionSample;
				}
			}
			return result;
		}
	}
	public enum ListChangeType
	{
		Add,
		Insert,
		Remove,
		clear
	}
	public class ListChangedEventArgs<T> : EventArgs
	{
		public ListChangeType type;

		public List<T> newItems;

		public List<T> removedItems;

		public int insertIndex;

		public int removeIndex;
	}
	public delegate void ListChangeHandler<T2>(object sender, ListChangedEventArgs<T2> args);
	[Serializable]
	public class SplineNode
	{
		[SerializeField]
		private Vector3 position;

		[SerializeField]
		private Vector3 direction;

		[SerializeField]
		private Vector3 up = Vector3.up;

		[SerializeField]
		private Vector2 scale = Vector2.one;

		[SerializeField]
		private float roll;

		public Vector3 Position
		{
			get
			{
				return position;
			}
			set
			{
				if (!position.Equals(value))
				{
					position.x = value.x;
					position.y = value.y;
					position.z = value.z;
					if (this.Changed != null)
					{
						this.Changed(this, EventArgs.Empty);
					}
				}
			}
		}

		public Vector3 Direction
		{
			get
			{
				return direction;
			}
			set
			{
				if (!direction.Equals(value))
				{
					direction.x = value.x;
					direction.y = value.y;
					direction.z = value.z;
					if (this.Changed != null)
					{
						this.Changed(this, EventArgs.Empty);
					}
				}
			}
		}

		public Vector3 Up
		{
			get
			{
				return up;
			}
			set
			{
				if (!up.Equals(value))
				{
					up.x = value.x;
					up.y = value.y;
					up.z = value.z;
					if (this.Changed != null)
					{
						this.Changed(this, EventArgs.Empty);
					}
				}
			}
		}

		public Vector2 Scale
		{
			get
			{
				return scale;
			}
			set
			{
				if (!scale.Equals(value))
				{
					scale.x = value.x;
					scale.y = value.y;
					if (this.Changed != null)
					{
						this.Changed(this, EventArgs.Empty);
					}
				}
			}
		}

		public float Roll
		{
			get
			{
				return roll;
			}
			set
			{
				if (roll != value)
				{
					roll = value;
					if (this.Changed != null)
					{
						this.Changed(this, EventArgs.Empty);
					}
				}
			}
		}

		[HideInInspector]
		public event EventHandler Changed;

		public SplineNode(Vector3 position, Vector3 direction)
		{
			Position = position;
			Direction = direction;
		}
	}
	[DisallowMultipleComponent]
	[ExecuteInEditMode]
	[RequireComponent(typeof(Spline))]
	public class SplineSmoother : MonoBehaviour
	{
		private Spline spline;

		[Range(0f, 1f)]
		public float curvature = 0.3f;

		private Spline Spline
		{
			get
			{
				if (spline == null)
				{
					spline = GetComponent<Spline>();
				}
				return spline;
			}
		}

		private void OnValidate()
		{
			SmoothAll();
		}

		private void OnEnable()
		{
			Spline.NodeListChanged += Spline_NodeListChanged;
			foreach (SplineNode node in Spline.nodes)
			{
				node.Changed += OnNodeChanged;
			}
			SmoothAll();
		}

		private void OnDisable()
		{
			Spline.NodeListChanged -= Spline_NodeListChanged;
			foreach (SplineNode node in Spline.nodes)
			{
				node.Changed -= OnNodeChanged;
			}
		}

		private void Spline_NodeListChanged(object sender, ListChangedEventArgs<SplineNode> args)
		{
			if (args.newItems != null)
			{
				foreach (SplineNode newItem in args.newItems)
				{
					newItem.Changed += OnNodeChanged;
				}
			}
			if (args.removedItems == null)
			{
				return;
			}
			foreach (SplineNode removedItem in args.removedItems)
			{
				removedItem.Changed -= OnNodeChanged;
			}
		}

		private void OnNodeChanged(object sender, EventArgs e)
		{
			SplineNode splineNode = (SplineNode)sender;
			SmoothNode(splineNode);
			int num = Spline.nodes.IndexOf(splineNode);
			if (num > 0)
			{
				SmoothNode(Spline.nodes[num - 1]);
			}
			if (num < Spline.nodes.Count - 1)
			{
				SmoothNode(Spline.nodes[num + 1]);
			}
		}

		private void SmoothNode(SplineNode node)
		{
			int num = Spline.nodes.IndexOf(node);
			Vector3 position = node.Position;
			Vector3 zero = Vector3.zero;
			float num2 = 0f;
			if (num != 0)
			{
				Vector3 position2 = Spline.nodes[num - 1].Position;
				Vector3 vector = position - position2;
				num2 += vector.magnitude;
				zero += vector.normalized;
			}
			if (num != Spline.nodes.Count - 1)
			{
				Vector3 position3 = Spline.nodes[num + 1].Position;
				Vector3 vector2 = position - position3;
				num2 += vector2.magnitude;
				zero -= vector2.normalized;
			}
			num2 *= 0.5f;
			zero = zero.normalized * num2 * curvature;
			Vector3 direction = zero + position;
			node.Direction = direction;
		}

		private void SmoothAll()
		{
			foreach (SplineNode node in Spline.nodes)
			{
				SmoothNode(node);
			}
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(Spline))]
	public class ExampleContortAlong : MonoBehaviour
	{
		private Spline spline;

		private float rate;

		private MeshBender meshBender;

		[HideInInspector]
		public GameObject generated;

		public Mesh mesh;

		public Material material;

		public Vector3 rotation;

		public Vector3 scale;

		public float DurationInSecond;

		private void OnEnable()
		{
			rate = 0f;
			Init();
		}

		private void OnDisable()
		{
		}

		private void OnValidate()
		{
			Init();
		}

		private void EditorUpdate()
		{
			rate += Time.deltaTime / DurationInSecond;
			if (rate > 1f)
			{
				rate -= 1f;
			}
			Contort();
		}

		private void Contort()
		{
			if (generated != null)
			{
				meshBender.SetInterval(spline, spline.Length * rate);
				meshBender.ComputeIfNeeded();
			}
		}

		private void Init()
		{
			string n = "generated by " + GetType().Name;
			Transform transform = base.transform.Find(n);
			generated = ((transform != null) ? transform.gameObject : UOUtility.Create(n, base.gameObject, typeof(MeshFilter), typeof(MeshRenderer), typeof(MeshBender)));
			generated.GetComponent<MeshRenderer>().material = material;
			meshBender = generated.GetComponent<MeshBender>();
			spline = GetComponent<Spline>();
			meshBender.Source = SourceMesh.Build(mesh).Rotate(Quaternion.Euler(rotation)).Scale(scale);
			meshBender.Mode = MeshBender.FillingMode.Once;
			meshBender.SetInterval(spline, 0f);
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(Spline))]
	public class ExampleFollowSpline : MonoBehaviour
	{
		private GameObject generated;

		private Spline spline;

		private float rate;

		public GameObject Follower;

		public float DurationInSecond;

		private void OnEnable()
		{
			rate = 0f;
			string n = "generated by " + GetType().Name;
			Transform transform = base.transform.Find(n);
			generated = ((transform != null) ? transform.gameObject : UnityEngine.Object.Instantiate(Follower, base.gameObject.transform));
			generated.name = n;
			spline = GetComponent<Spline>();
		}

		private void OnDisable()
		{
		}

		private void EditorUpdate()
		{
			rate += Time.deltaTime / DurationInSecond;
			if (rate > (float)(spline.nodes.Count - 1))
			{
				rate -= spline.nodes.Count - 1;
			}
			PlaceFollower();
		}

		private void PlaceFollower()
		{
			if (generated != null)
			{
				CurveSample sample = spline.GetSample(rate);
				generated.transform.localPosition = sample.location;
				generated.transform.localRotation = sample.Rotation;
			}
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(Spline))]
	public class ExampleGrowingRoot : MonoBehaviour
	{
		private GameObject generated;

		private Spline spline;

		private float rate;

		private MeshBender meshBender;

		public Mesh mesh;

		public Material material;

		public Vector3 rotation;

		public Vector3 scale;

		public float startScale = 1f;

		public float DurationInSecond;

		private void OnEnable()
		{
			rate = 0f;
			Init();
		}

		private void OnDisable()
		{
		}

		private void OnValidate()
		{
			Init();
		}

		private void EditorUpdate()
		{
			rate += Time.deltaTime / DurationInSecond;
			if (rate > 1f)
			{
				rate -= 1f;
			}
			Contort();
		}

		private void Contort()
		{
			float num = 0f;
			int num2 = 0;
			foreach (SplineNode node in spline.nodes)
			{
				float num3 = num / spline.Length;
				float num4 = startScale * (rate - num3);
				node.Scale = new Vector2(num4, num4);
				if (num2 < spline.curves.Count)
				{
					num += spline.curves[num2++].Length;
				}
			}
			if (generated != null)
			{
				meshBender.SetInterval(spline, 0f, spline.Length * rate);
				meshBender.ComputeIfNeeded();
			}
		}

		private void Init()
		{
			string n = "generated by " + GetType().Name;
			Transform transform = base.transform.Find(n);
			generated = ((transform != null) ? transform.gameObject : UOUtility.Create(n, base.gameObject, typeof(MeshFilter), typeof(MeshRenderer), typeof(MeshBender)));
			generated.GetComponent<MeshRenderer>().material = material;
			meshBender = generated.GetComponent<MeshBender>();
			spline = GetComponent<Spline>();
			meshBender.Source = SourceMesh.Build(mesh).Rotate(Quaternion.Euler(rotation)).Scale(scale);
			meshBender.Mode = MeshBender.FillingMode.StretchToInterval;
			meshBender.SetInterval(spline, 0f, 0.01f);
		}
	}
	[ExecuteInEditMode]
	[SelectionBase]
	[DisallowMultipleComponent]
	public class ExampleSower : MonoBehaviour
	{
		private GameObject generated;

		private Spline spline;

		private bool toUpdate = true;

		public GameObject prefab;

		public float scale = 1f;

		public float scaleRange;

		public float spacing = 1f;

		public float spacingRange;

		public float offset;

		public float offsetRange;

		public bool isRandomYaw;

		public int randomSeed;

		private void OnEnable()
		{
			string n = "generated by " + GetType().Name;
			Transform transform = base.transform.Find(n);
			generated = ((transform != null) ? transform.gameObject : UOUtility.Create(n, base.gameObject));
			spline = GetComponentInParent<Spline>();
			spline.NodeListChanged += delegate
			{
				toUpdate = true;
				foreach (CubicBezierCurve curf in spline.GetCurves())
				{
					curf.Changed.AddListener(delegate
					{
						toUpdate = true;
					});
				}
			};
			foreach (CubicBezierCurve curf2 in spline.GetCurves())
			{
				curf2.Changed.AddListener(delegate
				{
					toUpdate = true;
				});
			}
		}

		private void OnValidate()
		{
			toUpdate = true;
		}

		private void Update()
		{
			if (toUpdate)
			{
				Sow();
				toUpdate = false;
			}
		}

		public void Sow()
		{
			UOUtility.DestroyChildren(generated);
			UnityEngine.Random.InitState(randomSeed);
			if (spacing + spacingRange <= 0f || prefab == null)
			{
				return;
			}
			for (float num = 0f; num <= spline.Length; num += spacing + UnityEngine.Random.Range(0f, spacingRange))
			{
				CurveSample sampleAtDistance = spline.GetSampleAtDistance(num);
				GameObject gameObject = UnityEngine.Object.Instantiate(prefab, generated.transform);
				gameObject.transform.localRotation = Quaternion.identity;
				gameObject.transform.localPosition = Vector3.zero;
				gameObject.transform.localScale = Vector3.one;
				gameObject.transform.localPosition = sampleAtDistance.location;
				float num2 = scale + UnityEngine.Random.Range(0f, scaleRange);
				gameObject.transform.localScale = new Vector3(num2, num2, num2);
				if (isRandomYaw)
				{
					gameObject.transform.Rotate(0f, 0f, UnityEngine.Random.Range(-180, 180));
				}
				else
				{
					gameObject.transform.rotation = sampleAtDistance.Rotation;
				}
				Vector3 normalized = (Quaternion.LookRotation(sampleAtDistance.tangent, sampleAtDistance.up) * Vector3.right).normalized;
				float num3 = offset + UnityEngine.Random.Range(0f, offsetRange * (float)Math.Sign(offset));
				num3 *= sampleAtDistance.scale.x;
				normalized *= num3;
				gameObject.transform.position += normalized;
			}
		}
	}
	[DisallowMultipleComponent]
	public class ExampleTentacle : MonoBehaviour
	{
		private Spline spline;

		public float startScale = 1f;

		public float endScale = 1f;

		public float startRoll;

		public float endRoll;

		private void OnEnable()
		{
			spline = GetComponentInParent<Spline>();
		}

		private void OnValidate()
		{
			if (spline == null)
			{
				return;
			}
			float num = 0f;
			foreach (CubicBezierCurve curf in spline.GetCurves())
			{
				float num2 = num / spline.Length;
				num += curf.Length;
				float num3 = num / spline.Length;
				curf.n1.Scale = Vector2.one * (startScale + (endScale - startScale) * num2);
				curf.n2.Scale = Vector2.one * (startScale + (endScale - startScale) * num3);
				curf.n1.Roll = startRoll + (endRoll - startRoll) * num2;
				curf.n2.Roll = startRoll + (endRoll - startRoll) * num3;
			}
		}
	}
	[ExecuteInEditMode]
	[SelectionBase]
	[DisallowMultipleComponent]
	public class ExampleTrack : MonoBehaviour
	{
		private GameObject generated;

		private Spline spline;

		private bool toUpdate;

		public List<TrackSegment> segments = new List<TrackSegment>();

		public bool updateInPlayMode;

		private void OnEnable()
		{
			string n = "generated by " + GetType().Name;
			Transform transform = base.transform.Find(n);
			generated = ((transform != null) ? transform.gameObject : UOUtility.Create(n, base.gameObject));
			spline = GetComponentInParent<Spline>();
			while (segments.Count < spline.nodes.Count)
			{
				segments.Add(new TrackSegment());
			}
			while (segments.Count > spline.nodes.Count)
			{
				segments.RemoveAt(segments.Count - 1);
			}
			spline.NodeListChanged += delegate(object s, ListChangedEventArgs<SplineNode> e)
			{
				switch (e.type)
				{
				case ListChangeType.Add:
					segments.Add(new TrackSegment());
					break;
				case ListChangeType.Remove:
					segments.RemoveAt(e.removeIndex);
					break;
				case ListChangeType.Insert:
					segments.Insert(e.insertIndex, new TrackSegment());
					break;
				}
				toUpdate = true;
			};
			toUpdate = true;
		}

		private void OnValidate()
		{
			if (!(spline == null))
			{
				toUpdate = true;
			}
		}

		private void Update()
		{
			if ((updateInPlayMode || !Application.isPlaying) && toUpdate)
			{
				toUpdate = false;
				CreateMeshes();
			}
		}

		public void CreateMeshes()
		{
			List<GameObject> list = new List<GameObject>();
			for (int i = 0; i < spline.GetCurves().Count; i++)
			{
				CubicBezierCurve interval = spline.GetCurves()[i];
				foreach (TransformedMesh transformedMesh in segments[i].transformedMeshes)
				{
					if (!(transformedMesh.mesh == null))
					{
						string n = "segment " + i + " mesh " + segments[i].transformedMeshes.IndexOf(transformedMesh);
						Transform transform = generated.transform.Find(n);
						GameObject gameObject;
						if (transform == null)
						{
							gameObject = UOUtility.Create(n, generated, typeof(MeshFilter), typeof(MeshRenderer), typeof(MeshBender), typeof(MeshCollider));
							gameObject.isStatic = true;
						}
						else
						{
							gameObject = transform.gameObject;
						}
						gameObject.GetComponent<MeshRenderer>().material = transformedMesh.material;
						gameObject.GetComponent<MeshCollider>().material = transformedMesh.physicMaterial;
						MeshBender component = gameObject.GetComponent<MeshBender>();
						component.Source = SourceMesh.Build(transformedMesh.mesh).Translate(transformedMesh.translation).Rotate(Quaternion.Euler(transformedMesh.rotation))
							.Scale(transformedMesh.scale);
						component.SetInterval(interval);
						component.ComputeIfNeeded();
						list.Add(gameObject);
					}
				}
			}
			foreach (GameObject item in (from Transform child in generated.transform
				select child.gameObject).Except(list))
			{
				UOUtility.Destroy(item);
			}
		}
	}
	[Serializable]
	public class TrackSegment
	{
		public List<TransformedMesh> transformedMeshes = new List<TransformedMesh>();
	}
	[Serializable]
	public class TransformedMesh
	{
		public Mesh mesh;

		public Material material;

		public PhysicMaterial physicMaterial;

		public Vector3 translation;

		public Vector3 rotation;

		public Vector3 scale = Vector3.one;

		public TransformedMesh()
		{
			scale = Vector3.one;
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(Spline))]
	public class RopeBuilder : MonoBehaviour
	{
		private bool toUpdate;

		private GameObject generated;

		private Spline spline;

		private GameObject firstSegment;

		[SerializeField]
		public List<GameObject> wayPoints = new List<GameObject>();

		public GameObject segmentPrefab;

		public int segmentCount;

		public float segmentSpacing;

		private GameObject Generated
		{
			get
			{
				if (generated == null)
				{
					string n = "generated by " + GetType().Name;
					Transform transform = base.transform.Find(n);
					generated = ((transform != null) ? transform.gameObject : UOUtility.Create(n, base.gameObject));
				}
				return generated;
			}
		}

		private void OnEnable()
		{
			spline = GetComponent<Spline>();
			toUpdate = true;
		}

		private void OnValidate()
		{
			toUpdate = true;
		}

		private void Update()
		{
			if (toUpdate)
			{
				toUpdate = false;
				Generate();
				UpdateSpline();
			}
			UpdateNodes();
			if (Application.isPlaying)
			{
				firstSegment.transform.localPosition = new Vector3(Mathf.Sin(Time.time) * 3f, 0f, 0f);
			}
		}

		private void UpdateNodes()
		{
			int num = 0;
			foreach (GameObject wayPoint in wayPoints)
			{
				SplineNode splineNode = spline.nodes[num++];
				if (Vector3.Distance(splineNode.Position, base.transform.InverseTransformPoint(wayPoint.transform.position)) > 0.001f)
				{
					splineNode.Position = base.transform.InverseTransformPoint(wayPoint.transform.position);
					splineNode.Up = wayPoint.transform.up;
				}
			}
		}

		private void UpdateSpline()
		{
			foreach (GameObject item in wayPoints.ToList())
			{
				if (item == null)
				{
					wayPoints.Remove(item);
				}
			}
			int count = wayPoints.Count;
			while (spline.nodes.Count < count)
			{
				spline.AddNode(new SplineNode(Vector3.zero, Vector3.zero));
			}
			while (spline.nodes.Count > count && spline.nodes.Count > 2)
			{
				spline.RemoveNode(spline.nodes.Last());
			}
		}

		private void Generate()
		{
			UOUtility.DestroyChildren(Generated);
			wayPoints.Clear();
			float num = 0f;
			Joint joint = null;
			for (int i = 0; i < segmentCount; i++)
			{
				GameObject gameObject = UOUtility.Instantiate(segmentPrefab, Generated.transform);
				gameObject.transform.Translate(0f, 0f, num);
				Rigidbody component = gameObject.GetComponent<Rigidbody>();
				if (i == 0)
				{
					firstSegment = gameObject;
					component.constraints = RigidbodyConstraints.FreezePosition;
				}
				if (joint != null)
				{
					joint.connectedBody = component;
				}
				joint = gameObject.GetComponent<Joint>();
				wayPoints.Add(gameObject);
				num += segmentSpacing;
			}
			UOUtility.Destroy(joint);
		}
	}
	[ExecuteInEditMode]
	[DisallowMultipleComponent]
	[RequireComponent(typeof(MeshFilter))]
	[RequireComponent(typeof(MeshRenderer))]
	public class ExtrusionSegment : MonoBehaviour
	{
		[Serializable]
		public class Vertex
		{
			public Vector2 point;

			public Vector2 normal;

			public float uCoord;

			public Vertex(Vector2 point, Vector2 normal, float uCoord)
			{
				this.point = point;
				this.normal = normal;
				this.uCoord = uCoord;
			}

			public Vertex(Vertex other)
			{
				point = other.point;
				normal = other.normal;
				uCoord = other.uCoord;
			}
		}

		private bool isDirty;

		private MeshFilter mf;

		private Mesh result;

		private bool useSpline;

		private CubicBezierCurve curve;

		private Spline spline;

		private float intervalStart;

		private float intervalEnd;

		private List<Vertex> shapeVertices = new List<Vertex>();

		private float textureScale = 1f;

		private float textureOffset;

		private float sampleSpacing = 0.1f;

		public List<Vertex> ShapeVertices
		{
			get
			{
				return shapeVertices;
			}
			set
			{
				if (value != shapeVertices)
				{
					SetDirty();
					shapeVertices = value;
				}
			}
		}

		public float TextureScale
		{
			get
			{
				return textureScale;
			}
			set
			{
				if (value != textureScale)
				{
					SetDirty();
					textureScale = value;
				}
			}
		}

		public float TextureOffset
		{
			get
			{
				return textureOffset;
			}
			set
			{
				if (value != textureOffset)
				{
					SetDirty();
					textureOffset = value;
				}
			}
		}

		public float SampleSpacing
		{
			get
			{
				return sampleSpacing;
			}
			set
			{
				if (value != sampleSpacing)
				{
					if (value <= 0f)
					{
						throw new ArgumentOutOfRangeException("SampleSpacing", "Must be greater than 0");
					}
					SetDirty();
					sampleSpacing = value;
				}
			}
		}

		private void OnEnable()
		{
			mf = GetComponent<MeshFilter>();
			if (mf.sharedMesh == null)
			{
				mf.sharedMesh = new Mesh();
			}
		}

		public void SetInterval(CubicBezierCurve curve)
		{
			if (this.curve != curve)
			{
				if (curve == null)
				{
					throw new ArgumentNullException("curve");
				}
				if (this.curve != null)
				{
					this.curve.Changed.RemoveListener(SetDirty);
				}
				this.curve = curve;
				spline = null;
				curve.Changed.AddListener(SetDirty);
				useSpline = false;
				SetDirty();
			}
		}

		public void SetInterval(Spline spline, float intervalStart, float intervalEnd = 0f)
		{
			if (!(this.spline == spline) || this.intervalStart != intervalStart || this.intervalEnd != intervalEnd)
			{
				if (spline == null)
				{
					throw new ArgumentNullException("spline");
				}
				if (intervalStart < 0f || intervalStart >= spline.Length)
				{
					throw new ArgumentOutOfRangeException("interval start must be 0 or greater and lesser than spline length (was " + intervalStart + ")");
				}
				if ((intervalEnd != 0f && intervalEnd <= intervalStart) || intervalEnd > spline.Length)
				{
					throw new ArgumentOutOfRangeException("interval end must be 0 or greater than interval start, and lesser than spline length (was " + intervalEnd + ")");
				}
				if (this.spline != null)
				{
					this.spline.CurveChanged.RemoveListener(SetDirty);
				}
				this.spline = spline;
				spline.CurveChanged.AddListener(SetDirty);
				curve = null;
				this.intervalStart = intervalStart;
				this.intervalEnd = intervalEnd;
				useSpline = true;
				SetDirty();
			}
		}

		private void SetDirty()
		{
			isDirty = true;
		}

		private void Update()
		{
			ComputeIfNeeded();
		}

		public void ComputeIfNeeded()
		{
			if (isDirty)
			{
				Compute();
				isDirty = false;
			}
		}

		private List<CurveSample> GetPath()
		{
			List<CurveSample> list = new List<CurveSample>();
			if (useSpline)
			{
				for (float num = intervalStart; num < intervalEnd; num += sampleSpacing)
				{
					list.Add(spline.GetSampleAtDistance(num));
				}
				list.Add(spline.GetSampleAtDistance(intervalEnd));
			}
			else
			{
				for (float num2 = 0f; num2 < curve.Length; num2 += sampleSpacing)
				{
					list.Add(curve.GetSampleAtDistance(num2));
				}
				list.Add(curve.GetSampleAtDistance(curve.Length));
			}
			return list;
		}

		public void Compute()
		{
			List<CurveSample> path = GetPath();
			int count = shapeVertices.Count;
			int num = path.Count - 1;
			List<int> list = new List<int>(count * 2 * num * 3);
			List<MeshVertex> list2 = new List<MeshVertex>(count * 2 * num * 3);
			foreach (CurveSample item5 in path)
			{
				foreach (Vertex shapeVertex in shapeVertices)
				{
					list2.Add(item5.GetBent(new MeshVertex(new Vector3(0f, shapeVertex.point.y, 0f - shapeVertex.point.x), new Vector3(0f, shapeVertex.normal.y, 0f - shapeVertex.normal.x), new Vector2(shapeVertex.uCoord, textureScale * (item5.distanceInCurve + textureOffset)))));
				}
			}
			int num2 = 0;
			for (int i = 0; i < num; i++)
			{
				for (int j = 0; j < shapeVertices.Count; j++)
				{
					int num3 = ((j != shapeVertices.Count - 1) ? 1 : (-(shapeVertices.Count - 1)));
					int item = num2 + shapeVertices.Count;
					int item2 = num2;
					int item3 = num2 + num3;
					int item4 = num2 + num3 + shapeVertices.Count;
					list.Add(item3);
					list.Add(item2);
					list.Add(item);
					list.Add(item);
					list.Add(item4);
					list.Add(item3);
					num2++;
				}
			}
			MeshUtility.Update(mf.sharedMesh, mf.sharedMesh, list, list2.Select((MeshVertex b) => b.position), list2.Select((MeshVertex b) => b.normal), list2.Select((MeshVertex b) => b.uv));
			MeshCollider component = GetComponent<MeshCollider>();
			if (component != null)
			{
				component.sharedMesh = mf.sharedMesh;
			}
		}
	}
	[DisallowMultipleComponent]
	[RequireComponent(typeof(MeshFilter))]
	[ExecuteInEditMode]
	public class MeshBender : MonoBehaviour
	{
		public enum FillingMode
		{
			Once,
			Repeat,
			StretchToInterval
		}

		private bool isDirty;

		private Mesh result;

		private bool useSpline;

		private Spline spline;

		private float intervalStart;

		private float intervalEnd;

		private CubicBezierCurve curve;

		private Dictionary<float, CurveSample> sampleCache = new Dictionary<float, CurveSample>();

		private SourceMesh source;

		private FillingMode mode = FillingMode.StretchToInterval;

		public SourceMesh Source
		{
			get
			{
				return source;
			}
			set
			{
				if (!(value == source))
				{
					SetDirty();
					source = value;
				}
			}
		}

		public FillingMode Mode
		{
			get
			{
				return mode;
			}
			set
			{
				if (value != mode)
				{
					SetDirty();
					mode = value;
				}
			}
		}

		public void SetInterval(CubicBezierCurve curve)
		{
			if (this.curve != curve)
			{
				if (curve == null)
				{
					throw new ArgumentNullException("curve");
				}
				if (this.curve != null)
				{
					this.curve.Changed.RemoveListener(SetDirty);
				}
				this.curve = curve;
				spline = null;
				curve.Changed.AddListener(SetDirty);
				useSpline = false;
				SetDirty();
			}
		}

		public void SetInterval(Spline spline, float intervalStart, float intervalEnd = 0f)
		{
			if (!(this.spline == spline) || this.intervalStart != intervalStart || this.intervalEnd != intervalEnd)
			{
				if (spline == null)
				{
					throw new ArgumentNullException("spline");
				}
				if (intervalStart < 0f || intervalStart >= spline.Length)
				{
					throw new ArgumentOutOfRangeException("interval start must be 0 or greater and lesser than spline length (was " + intervalStart + ")");
				}
				if ((intervalEnd != 0f && intervalEnd <= intervalStart) || intervalEnd > spline.Length)
				{
					throw new ArgumentOutOfRangeException("interval end must be 0 or greater than interval start, and lesser than spline length (was " + intervalEnd + ")");
				}
				if (this.spline != null)
				{
					this.spline.CurveChanged.RemoveListener(SetDirty);
				}
				this.spline = spline;
				spline.CurveChanged.AddListener(SetDirty);
				curve = null;
				this.intervalStart = intervalStart;
				this.intervalEnd = intervalEnd;
				useSpline = true;
				SetDirty();
			}
		}

		private void OnEnable()
		{
			if (GetComponent<MeshFilter>().sharedMesh != null)
			{
				result = GetComponent<MeshFilter>().sharedMesh;
				return;
			}
			GetComponent<MeshFilter>().sharedMesh = (result = new Mesh());
			result.name = "Generated by " + GetType().Name;
		}

		private void Update()
		{
			ComputeIfNeeded();
		}

		public void ComputeIfNeeded()
		{
			if (isDirty)
			{
				Compute();
			}
		}

		private void SetDirty()
		{
			isDirty = true;
		}

		private void Compute()
		{
			isDirty = false;
			switch (Mode)
			{
			case FillingMode.Once:
				FillOnce();
				break;
			case FillingMode.Repeat:
				FillRepeat();
				break;
			case FillingMode.StretchToInterval:
				FillStretch();
				break;
			}
		}

		private void OnDestroy()
		{
			if (curve != null)
			{
				curve.Changed.RemoveListener(Compute);
			}
		}

		private void FillOnce()
		{
			sampleCache.Clear();
			List<MeshVertex> list = new List<MeshVertex>(source.Vertices.Count);
			foreach (MeshVertex vertex in source.Vertices)
			{
				float num = vertex.position.x - source.MinX;
				if (!sampleCache.TryGetValue(num, out var value))
				{
					if (!useSpline)
					{
						if (num > curve.Length)
						{
							num = curve.Length;
						}
						value = curve.GetSampleAtDistance(num);
					}
					else
					{
						float num2 = intervalStart + num;
						if (num2 > spline.Length)
						{
							if (spline.IsLoop)
							{
								while (num2 > spline.Length)
								{
									num2 -= spline.Length;
								}
							}
							else
							{
								num2 = spline.Length;
							}
						}
						value = spline.GetSampleAtDistance(num2);
					}
					sampleCache[num] = value;
				}
				list.Add(value.GetBent(vertex));
			}
			MeshUtility.Update(result, source.Mesh, source.Triangles, list.Select((MeshVertex b) => b.position), list.Select((MeshVertex b) => b.normal));
		}

		private void FillRepeat()
		{
			int num = Mathf.FloorToInt((useSpline ? (((intervalEnd == 0f) ? spline.Length : intervalEnd) - intervalStart) : curve.Length) / source.Length);
			List<int> list = new List<int>();
			List<Vector2> list2 = new List<Vector2>();
			List<Vector2> list3 = new List<Vector2>();
			List<Vector2> list4 = new List<Vector2>();
			List<Vector2> list5 = new List<Vector2>();
			List<Vector2> list6 = new List<Vector2>();
			List<Vector2> list7 = new List<Vector2>();
			List<Vector2> list8 = new List<Vector2>();
			List<Vector2> list9 = new List<Vector2>();
			for (int i = 0; i < num; i++)
			{
				int[] triangles = source.Triangles;
				foreach (int num2 in triangles)
				{
					list.Add(num2 + source.Vertices.Count * i);
				}
				list2.AddRange(source.Mesh.uv);
				list3.AddRange(source.Mesh.uv2);
				list4.AddRange(source.Mesh.uv3);
				list5.AddRange(source.Mesh.uv4);
				list6.AddRange(source.Mesh.uv5);
				list7.AddRange(source.Mesh.uv6);
				list8.AddRange(source.Mesh.uv7);
				list9.AddRange(source.Mesh.uv8);
			}
			List<MeshVertex> list10 = new List<MeshVertex>(source.Vertices.Count);
			float num3 = 0f;
			for (int k = 0; k < num; k++)
			{
				sampleCache.Clear();
				foreach (MeshVertex vertex in source.Vertices)
				{
					float num4 = vertex.position.x - source.MinX + num3;
					if (!sampleCache.TryGetValue(num4, out var value))
					{
						if (!useSpline)
						{
							if (num4 > curve.Length)
							{
								continue;
							}
							value = curve.GetSampleAtDistance(num4);
						}
						else
						{
							float num5;
							for (num5 = intervalStart + num4; num5 > spline.Length; num5 -= spline.Length)
							{
							}
							value = spline.GetSampleAtDistance(num5);
						}
						sampleCache[num4] = value;
					}
					list10.Add(value.GetBent(vertex));
				}
				num3 += source.Length;
			}
			MeshUtility.Update(result, source.Mesh, list, list10.Select((MeshVertex b) => b.position), list10.Select((MeshVertex b) => b.normal), list2, list3, list4, list5, list6, list7, list8, list9);
		}

		private void FillStretch()
		{
			List<MeshVertex> list = new List<MeshVertex>(source.Vertices.Count);
			sampleCache.Clear();
			foreach (MeshVertex vertex in source.Vertices)
			{
				float num = ((source.Length == 0f) ? 0f : (Math.Abs(vertex.position.x - source.MinX) / source.Length));
				if (!sampleCache.TryGetValue(num, out var value))
				{
					if (!useSpline)
					{
						value = curve.GetSampleAtDistance(curve.Length * num);
					}
					else
					{
						float num2 = ((intervalEnd == 0f) ? (spline.Length - intervalStart) : (intervalEnd - intervalStart));
						float num3 = intervalStart + num2 * num;
						if (num3 > spline.Length)
						{
							num3 = spline.Length;
							UnityEngine.Debug.Log("dist " + num3 + " spline length " + spline.Length + " start " + intervalStart);
						}
						value = spline.GetSampleAtDistance(num3);
					}
					sampleCache[num] = value;
				}
				list.Add(value.GetBent(vertex));
			}
			MeshUtility.Update(result, source.Mesh, source.Triangles, list.Select((MeshVertex b) => b.position), list.Select((MeshVertex b) => b.normal));
		}
	}
	[Serializable]
	public class MeshVertex
	{
		public Vector3 position;

		public Vector3 normal;

		public Vector2 uv;

		public MeshVertex(Vector3 position, Vector3 normal, Vector2 uv)
		{
			this.position = position;
			this.normal = normal;
			this.uv = uv;
		}

		public MeshVertex(Vector3 position, Vector3 normal)
			: this(position, normal, Vector2.zero)
		{
		}
	}
	public struct SourceMesh
	{
		private Vector3 translation;

		private Quaternion rotation;

		private Vector3 scale;

		private List<MeshVertex> vertices;

		private int[] triangles;

		private float minX;

		private float length;

		internal Mesh Mesh { get; }

		internal List<MeshVertex> Vertices
		{
			get
			{
				if (vertices == null)
				{
					BuildData();
				}
				return vertices;
			}
		}

		internal int[] Triangles
		{
			get
			{
				if (vertices == null)
				{
					BuildData();
				}
				return triangles;
			}
		}

		internal float MinX
		{
			get
			{
				if (vertices == null)
				{
					BuildData();
				}
				return minX;
			}
		}

		internal float Length
		{
			get
			{
				if (vertices == null)
				{
					BuildData();
				}
				return length;
			}
		}

		private SourceMesh(Mesh mesh)
		{
			Mesh = mesh;
			translation = default(Vector3);
			rotation = default(Quaternion);
			scale = default(Vector3);
			vertices = null;
			triangles = null;
			minX = 0f;
			length = 0f;
		}

		private SourceMesh(SourceMesh other)
		{
			Mesh = other.Mesh;
			translation = other.translation;
			rotation = other.rotation;
			scale = other.scale;
			vertices = null;
			triangles = null;
			minX = 0f;
			length = 0f;
		}

		public static SourceMesh Build(Mesh mesh)
		{
			return new SourceMesh(mesh);
		}

		public SourceMesh Translate(Vector3 translation)
		{
			SourceMesh result = new SourceMesh(this);
			result.translation = translation;
			return result;
		}

		public SourceMesh Translate(float x, float y, float z)
		{
			return Translate(new Vector3(x, y, z));
		}

		public SourceMesh Rotate(Quaternion rotation)
		{
			SourceMesh result = new SourceMesh(this);
			result.rotation = rotation;
			return result;
		}

		public SourceMesh Scale(Vector3 scale)
		{
			SourceMesh result = new SourceMesh(this);
			result.scale = scale;
			return result;
		}

		public SourceMesh Scale(float x, float y, float z)
		{
			return Scale(new Vector3(x, y, z));
		}

		private void BuildData()
		{
			bool flag = scale.x < 0f;
			if (scale.y < 0f)
			{
				flag = !flag;
			}
			if (scale.z < 0f)
			{
				flag = !flag;
			}
			triangles = (flag ? MeshUtility.GetReversedTriangles(Mesh) : Mesh.triangles);
			int num = 0;
			vertices = new List<MeshVertex>(Mesh.vertexCount);
			Vector3[] array = Mesh.vertices;
			for (int i = 0; i < array.Length; i++)
			{
				MeshVertex meshVertex = new MeshVertex(array[i], Mesh.normals[num++]);
				if (rotation != Quaternion.identity)
				{
					meshVertex.position = rotation * meshVertex.position;
					meshVertex.normal = rotation * meshVertex.normal;
				}
				if (scale != Vector3.one)
				{
					meshVertex.position = Vector3.Scale(meshVertex.position, scale);
					meshVertex.normal = Vector3.Scale(meshVertex.normal, scale);
				}
				if (translation != Vector3.zero)
				{
					meshVertex.position += translation;
				}
				vertices.Add(meshVertex);
			}
			minX = float.MaxValue;
			float num2 = float.MinValue;
			foreach (MeshVertex vertex in vertices)
			{
				Vector3 position = vertex.position;
				num2 = Math.Max(num2, position.x);
				minX = Math.Min(minX, position.x);
			}
			length = Math.Abs(num2 - minX);
		}

		public override bool Equals(object obj)
		{
			if (obj == null || GetType() != obj.GetType())
			{
				return false;
			}
			SourceMesh sourceMesh = (SourceMesh)obj;
			if (Mesh == sourceMesh.Mesh && translation == sourceMesh.translation && rotation == sourceMesh.rotation)
			{
				return scale == sourceMesh.scale;
			}
			return false;
		}

		public override int GetHashCode()
		{
			return base.GetHashCode();
		}

		public static bool operator ==(SourceMesh sm1, SourceMesh sm2)
		{
			return sm1.Equals(sm2);
		}

		public static bool operator !=(SourceMesh sm1, SourceMesh sm2)
		{
			return sm1.Equals(sm2);
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(Spline))]
	public class SplineExtrusion : MonoBehaviour
	{
		private Spline spline;

		private bool toUpdate = true;

		private GameObject generated;

		public List<ExtrusionSegment.Vertex> shapeVertices = new List<ExtrusionSegment.Vertex>();

		public Material material;

		public float textureScale = 1f;

		public float sampleSpacing = 0.1f;

		private void Reset()
		{
			shapeVertices.Clear();
			shapeVertices.Add(new ExtrusionSegment.Vertex(new Vector2(0f, 0.5f), new Vector2(0f, 1f), 0f));
			shapeVertices.Add(new ExtrusionSegment.Vertex(new Vector2(1f, -0.5f), new Vector2(1f, -1f), 0.33f));
			shapeVertices.Add(new ExtrusionSegment.Vertex(new Vector2(-1f, -0.5f), new Vector2(-1f, -1f), 0.66f));
			toUpdate = true;
			OnEnable();
		}

		private void OnValidate()
		{
			toUpdate = true;
		}

		private void OnEnable()
		{
			string n = "generated by " + GetType().Name;
			Transform transform = base.transform.Find(n);
			generated = ((transform != null) ? transform.gameObject : UOUtility.Create(n, base.gameObject));
			spline = GetComponentInParent<Spline>();
			spline.NodeListChanged += delegate
			{
				toUpdate = true;
			};
		}

		private void Update()
		{
			if (toUpdate)
			{
				GenerateMesh();
				toUpdate = false;
			}
		}

		private void GenerateMesh()
		{
			UOUtility.DestroyChildren(generated);
			int num = 0;
			float num2 = 0f;
			foreach (CubicBezierCurve curf in spline.GetCurves())
			{
				GameObject obj = UOUtility.Create("segment " + num++, generated, typeof(MeshFilter), typeof(MeshRenderer), typeof(ExtrusionSegment), typeof(MeshCollider));
				obj.GetComponent<MeshRenderer>().material = material;
				ExtrusionSegment component = obj.GetComponent<ExtrusionSegment>();
				component.ShapeVertices = shapeVertices;
				component.TextureScale = textureScale;
				component.TextureOffset = num2;
				component.SampleSpacing = sampleSpacing;
				component.SetInterval(curf);
				num2 += curf.Length;
			}
		}

		public void SetToUpdate()
		{
			toUpdate = true;
		}
	}
	[ExecuteInEditMode]
	[SelectionBase]
	[DisallowMultipleComponent]
	public class SplineMeshTiling : MonoBehaviour
	{
		private GameObject generated;

		private Spline spline;

		private bool toUpdate;

		[Tooltip("Mesh to bend along the spline.")]
		public Mesh mesh;

		[Tooltip("Material to apply on the bent mesh.")]
		public Material material;

		[Tooltip("Physic material to apply on the bent mesh.")]
		public PhysicMaterial physicMaterial;

		[Tooltip("Translation to apply on the mesh before bending it.")]
		public Vector3 translation;

		[Tooltip("Rotation to apply on the mesh before bending it.")]
		public Vector3 rotation;

		[Tooltip("Scale to apply on the mesh before bending it.")]
		public Vector3 scale = Vector3.one;

		[Tooltip("If true, a mesh collider will be generated.")]
		public bool generateCollider = true;

		[Tooltip("If true, the mesh will be bent on play mode. If false, the bent mesh will be kept from the editor mode, allowing lighting baking.")]
		public bool updateInPlayMode;

		[Tooltip("If true, a mesh will be placed on each curve of the spline. If false, a single mesh will be placed for the whole spline.")]
		public bool curveSpace;

		[Tooltip("The mode to use to fill the choosen interval with the bent mesh.")]
		public MeshBender.FillingMode mode = MeshBender.FillingMode.StretchToInterval;

		private void OnEnable()
		{
			string n = "generated by " + GetType().Name;
			Transform transform = base.transform.Find(n);
			generated = ((transform != null) ? transform.gameObject : UOUtility.Create(n, base.gameObject));
			spline = GetComponentInParent<Spline>();
			spline.NodeListChanged += delegate
			{
				toUpdate = true;
			};
			toUpdate = true;
		}

		private void OnValidate()
		{
			if (!(spline == null))
			{
				toUpdate = true;
			}
		}

		private void Update()
		{
			if ((updateInPlayMode || !Application.isPlaying) && toUpdate)
			{
				toUpdate = false;
				CreateMeshes();
			}
		}

		public void CreateMeshes()
		{
			List<GameObject> list = new List<GameObject>();
			if (curveSpace)
			{
				int num = 0;
				foreach (CubicBezierCurve curf in spline.curves)
				{
					GameObject gameObject = FindOrCreate("segment " + num++ + " mesh");
					gameObject.GetComponent<MeshBender>().SetInterval(curf);
					gameObject.GetComponent<MeshCollider>().enabled = generateCollider;
					list.Add(gameObject);
				}
			}
			else
			{
				GameObject gameObject2 = FindOrCreate("segment 1 mesh");
				gameObject2.GetComponent<MeshBender>().SetInterval(spline, 0f);
				gameObject2.GetComponent<MeshCollider>().enabled = generateCollider;
				list.Add(gameObject2);
			}
			foreach (GameObject item in (from Transform child in generated.transform
				select child.gameObject).Except(list))
			{
				UOUtility.Destroy(item);
			}
		}

		private GameObject FindOrCreate(string name)
		{
			Transform transform = generated.transform.Find(name);
			GameObject gameObject;
			if (transform == null)
			{
				gameObject = UOUtility.Create(name, generated, typeof(MeshFilter), typeof(MeshRenderer), typeof(MeshBender), typeof(MeshCollider));
				gameObject.isStatic = true;
			}
			else
			{
				gameObject = transform.gameObject;
			}
			gameObject.GetComponent<MeshRenderer>().material = material;
			gameObject.GetComponent<MeshCollider>().material = physicMaterial;
			MeshBender component = gameObject.GetComponent<MeshBender>();
			component.Source = SourceMesh.Build(mesh).Translate(translation).Rotate(Quaternion.Euler(rotation))
				.Scale(scale);
			component.Mode = mode;
			return gameObject;
		}
	}
	public static class CameraUtility
	{
		public static bool IsOnScreen(Vector3 position)
		{
			Vector3 vector = Camera.current.WorldToViewportPoint(position);
			if (vector.z > 0f && vector.x > 0f && vector.y > 0f && vector.x < 1f)
			{
				return vector.y < 1f;
			}
			return false;
		}
	}
	public class MeshUtility
	{
		public static int[] GetReversedTriangles(Mesh mesh)
		{
			int[] array = mesh.triangles.ToArray();
			int num = array.Length / 3;
			for (int i = 0; i < num; i++)
			{
				int num2 = array[i * 3];
				array[i * 3] = array[i * 3 + 1];
				array[i * 3 + 1] = num2;
			}
			return array;
		}

		public static void Update(Mesh mesh, Mesh source, IEnumerable<int> triangles = null, IEnumerable<Vector3> vertices = null, IEnumerable<Vector3> normals = null, IEnumerable<Vector2> uv = null, IEnumerable<Vector2> uv2 = null, IEnumerable<Vector2> uv3 = null, IEnumerable<Vector2> uv4 = null, IEnumerable<Vector2> uv5 = null, IEnumerable<Vector2> uv6 = null, IEnumerable<Vector2> uv7 = null, IEnumerable<Vector2> uv8 = null)
		{
			mesh.hideFlags = source.hideFlags;
			mesh.indexFormat = source.indexFormat;
			mesh.triangles = new int[0];
			mesh.vertices = ((vertices == null) ? source.vertices : vertices.ToArray());
			mesh.normals = ((normals == null) ? source.normals : normals.ToArray());
			mesh.uv = ((uv == null) ? source.uv : uv.ToArray());
			mesh.uv2 = ((uv2 == null) ? source.uv2 : uv2.ToArray());
			mesh.uv3 = ((uv3 == null) ? source.uv3 : uv3.ToArray());
			mesh.uv4 = ((uv4 == null) ? source.uv4 : uv4.ToArray());
			mesh.uv5 = ((uv5 == null) ? source.uv5 : uv5.ToArray());
			mesh.uv6 = ((uv6 == null) ? source.uv6 : uv6.ToArray());
			mesh.uv7 = ((uv7 == null) ? source.uv7 : uv7.ToArray());
			mesh.uv8 = ((uv8 == null) ? source.uv8 : uv8.ToArray());
			mesh.triangles = ((triangles == null) ? source.triangles : triangles.ToArray());
			mesh.RecalculateBounds();
			mesh.RecalculateTangents();
		}
	}
	public static class UOUtility
	{
		public static GameObject Create(string name, GameObject parent, params Type[] components)
		{
			GameObject gameObject = new GameObject(name, components);
			gameObject.transform.parent = parent.transform;
			gameObject.transform.localPosition = Vector3.zero;
			gameObject.transform.localScale = Vector3.one;
			gameObject.transform.localRotation = Quaternion.identity;
			return gameObject;
		}

		public static GameObject Instantiate(GameObject prefab, Transform parent)
		{
			GameObject gameObject = UnityEngine.Object.Instantiate(prefab, parent);
			gameObject.transform.localPosition = Vector3.zero;
			gameObject.transform.localRotation = Quaternion.identity;
			gameObject.transform.localScale = Vector3.one;
			return gameObject;
		}

		public static void Destroy(GameObject go)
		{
			if (Application.isPlaying)
			{
				UnityEngine.Object.Destroy(go);
			}
			else
			{
				UnityEngine.Object.DestroyImmediate(go);
			}
		}

		public static void Destroy(UnityEngine.Component comp)
		{
			if (Application.isPlaying)
			{
				UnityEngine.Object.Destroy(comp);
			}
			else
			{
				UnityEngine.Object.DestroyImmediate(comp);
			}
		}

		public static void DestroyChildren(GameObject go)
		{
			foreach (Transform item in go.transform.Cast<Transform>().ToList())
			{
				Destroy(item.gameObject);
			}
		}
	}
}
namespace Common
{
	public class CustomRecordData
	{
	}
}
namespace UnityStandardAssets.Vehicles.Car
{
	internal enum CarDriveType
	{
		FrontWheelDrive,
		RearWheelDrive,
		FourWheelDrive,
		SixWheelDrive
	}
	internal enum SpeedType
	{
		MPH,
		KPH
	}
	public class CarController : MonoBehaviour
	{
		[SerializeField]
		private UnityStandardAssets.Vehicles.Car.CarDriveType m_CarDriveType = UnityStandardAssets.Vehicles.Car.CarDriveType.FourWheelDrive;

		[SerializeField]
		private WheelCollider[] m_WheelColliders = new WheelCollider[4];

		[SerializeField]
		private GameObject[] m_WheelMeshes = new GameObject[4];

		[SerializeField]
		private WheelEffects[] m_WheelEffects = new WheelEffects[4];

		[SerializeField]
		private Vector3 m_CentreOfMassOffset;

		[SerializeField]
		private float m_MaximumSteerAngle;

		[Range(0f, 1f)]
		[SerializeField]
		private float m_SteerHelper;

		[Range(0f, 1f)]
		[SerializeField]
		private float m_TractionControl;

		[SerializeField]
		private float m_FullTorqueOverAllWheels;

		[SerializeField]
		private float m_ReverseTorque;

		[SerializeField]
		private float m_MaxHandbrakeTorque;

		[SerializeField]
		private float m_Downforce = 100f;

		[SerializeField]
		private UnityStandardAssets.Vehicles.Car.SpeedType m_SpeedType;

		[SerializeField]
		private float m_Topspeed = 200f;

		[SerializeField]
		private static int NoOfGears = 5;

		[SerializeField]
		private float m_RevRangeBoundary = 1f;

		[SerializeField]
		private float m_SlipLimit;

		[SerializeField]
		private float m_BrakeTorque;

		private Quaternion[] m_WheelMeshLocalRotations;

		private Vector3 m_Prevpos;

		private Vector3 m_Pos;

		private float m_SteerAngle;

		private int m_GearNum;

		private float m_GearFactor;

		private float m_OldRotation;

		private float m_CurrentTorque;

		private Rigidbody m_Rigidbody;

		private const float k_ReversingThreshold = 0.01f;

		public bool Skidding { get; private set; }

		public float BrakeInput { get; private set; }

		public float CurrentSteerAngle => m_SteerAngle;

		public float CurrentSpeed => m_Rigidbody.velocity.magnitude * 2.2369363f;

		public float MaxSpeed => m_Topspeed;

		public float Revs { get; private set; }

		public float AccelInput { get; private set; }

		private void Start()
		{
			m_WheelMeshLocalRotations = new Quaternion[m_WheelColliders.Length];
			for (int i = 0; i < m_WheelColliders.Length; i++)
			{
				m_WheelMeshLocalRotations[i] = m_WheelMeshes[i].transform.localRotation;
			}
			m_WheelColliders[0].attachedRigidbody.centerOfMass = m_CentreOfMassOffset;
			m_MaxHandbrakeTorque = float.MaxValue;
			m_Rigidbody = GetComponent<Rigidbody>();
			m_CurrentTorque = m_FullTorqueOverAllWheels - m_TractionControl * m_FullTorqueOverAllWheels;
		}

		private void GearChanging()
		{
			float num = Mathf.Abs(CurrentSpeed / MaxSpeed);
			float num2 = 1f / (float)NoOfGears * (float)(m_GearNum + 1);
			float num3 = 1f / (float)NoOfGears * (float)m_GearNum;
			if (m_GearNum > 0 && num < num3)
			{
				m_GearNum--;
			}
			if (num > num2 && m_GearNum < NoOfGears - 1)
			{
				m_GearNum++;
			}
		}

		private static float CurveFactor(float factor)
		{
			return 1f - (1f - factor) * (1f - factor);
		}

		private static float ULerp(float from, float to, float value)
		{
			return (1f - value) * from + value * to;
		}

		private void CalculateGearFactor()
		{
			float num = 1f / (float)NoOfGears;
			float b = Mathf.InverseLerp(num * (float)m_GearNum, num * (float)(m_GearNum + 1), Mathf.Abs(CurrentSpeed / MaxSpeed));
			m_GearFactor = Mathf.Lerp(m_GearFactor, b, Time.deltaTime * 5f);
		}

		private void CalculateRevs()
		{
			CalculateGearFactor();
			float num = (float)m_GearNum / (float)NoOfGears;
			float from = ULerp(0f, m_RevRangeBoundary, CurveFactor(num));
			float to = ULerp(m_RevRangeBoundary, 1f, num);
			Revs = ULerp(from, to, m_GearFactor);
		}

		public void Move(float steering, float accel, float footbrake, float handbrake)
		{
			for (int i = 0; i < m_WheelColliders.Length; i++)
			{
				m_WheelColliders[i].GetWorldPose(out var pos, out var quat);
				m_WheelMeshes[i].transform.position = pos;
				m_WheelMeshes[i].transform.rotation = quat;
			}
			steering = Mathf.Clamp(steering, -1f, 1f);
			AccelInput = (accel = Mathf.Clamp(accel, 0f, 1f));
			BrakeInput = (footbrake = -1f * Mathf.Clamp(footbrake, -1f, 0f));
			handbrake = Mathf.Clamp(handbrake, 0f, 1f);
			m_SteerAngle = steering * m_MaximumSteerAngle;
			m_WheelColliders[0].steerAngle = m_SteerAngle;
			m_WheelColliders[1].steerAngle = m_SteerAngle;
			SteerHelper();
			ApplyDrive(accel, footbrake);
			CapSpeed();
			if (handbrake > 0f)
			{
				float brakeTorque = handbrake * m_MaxHandbrakeTorque;
				m_WheelColliders[2].brakeTorque = brakeTorque;
				m_WheelColliders[3].brakeTorque = brakeTorque;
			}
			CalculateRevs();
			GearChanging();
			AddDownForce();
			CheckForWheelSpin();
			TractionControl();
		}

		private void CapSpeed()
		{
			float magnitude = m_Rigidbody.velocity.magnitude;
			switch (m_SpeedType)
			{
			case UnityStandardAssets.Vehicles.Car.SpeedType.MPH:
				magnitude *= 2.2369363f;
				if (magnitude > m_Topspeed)
				{
					m_Rigidbody.velocity = m_Topspeed / 2.2369363f * m_Rigidbody.velocity.normalized;
				}
				break;
			case UnityStandardAssets.Vehicles.Car.SpeedType.KPH:
				magnitude *= 3.6f;
				if (magnitude > m_Topspeed)
				{
					m_Rigidbody.velocity = m_Topspeed / 3.6f * m_Rigidbody.velocity.normalized;
				}
				break;
			}
		}

		private void ApplyDrive(float accel, float footbrake)
		{
			switch (m_CarDriveType)
			{
			case UnityStandardAssets.Vehicles.Car.CarDriveType.SixWheelDrive:
			{
				float num = accel * (m_CurrentTorque / 6f);
				for (int j = 0; j < m_WheelColliders.Length; j++)
				{
					m_WheelColliders[j].motorTorque = num;
				}
				break;
			}
			case UnityStandardAssets.Vehicles.Car.CarDriveType.FourWheelDrive:
			{
				float num = accel * (m_CurrentTorque / 4f);
				for (int i = 0; i < m_WheelColliders.Length; i++)
				{
					m_WheelColliders[i].motorTorque = num;
				}
				break;
			}
			case UnityStandardAssets.Vehicles.Car.CarDriveType.FrontWheelDrive:
			{
				float num = accel * (m_CurrentTorque / 2f);
				WheelCollider obj2 = m_WheelColliders[0];
				float motorTorque = (m_WheelColliders[1].motorTorque = num);
				obj2.motorTorque = motorTorque;
				break;
			}
			case UnityStandardAssets.Vehicles.Car.CarDriveType.RearWheelDrive:
			{
				float num = accel * (m_CurrentTorque / 2f);
				WheelCollider obj = m_WheelColliders[2];
				float motorTorque = (m_WheelColliders[3].motorTorque = num);
				obj.motorTorque = motorTorque;
				break;
			}
			}
			for (int k = 0; k < m_WheelColliders.Length; k++)
			{
				if (CurrentSpeed > 5f && Vector3.Angle(base.transform.forward, m_Rigidbody.velocity) < 50f)
				{
					m_WheelColliders[k].brakeTorque = m_BrakeTorque * footbrake;
				}
				else if (footbrake > 0f)
				{
					m_WheelColliders[k].brakeTorque = 0f;
					m_WheelColliders[k].motorTorque = (0f - m_ReverseTorque) * footbrake;
				}
			}
		}

		private void SteerHelper()
		{
			for (int i = 0; i < m_WheelColliders.Length; i++)
			{
				m_WheelColliders[i].GetGroundHit(out var hit);
				if (hit.normal == Vector3.zero)
				{
					return;
				}
			}
			if (Mathf.Abs(m_OldRotation - base.transform.eulerAngles.y) < 10f)
			{
				Quaternion quaternion = Quaternion.AngleAxis((base.transform.eulerAngles.y - m_OldRotation) * m_SteerHelper, Vector3.up);
				m_Rigidbody.velocity = quaternion * m_Rigidbody.velocity;
			}
			m_OldRotation = base.transform.eulerAngles.y;
		}

		private void AddDownForce()
		{
			m_WheelColliders[0].attachedRigidbody.AddForce(-base.transform.up * m_Downforce * m_WheelColliders[0].attachedRigidbody.velocity.magnitude);
		}

		private void CheckForWheelSpin()
		{
			for (int i = 0; i < m_WheelEffects.Length; i++)
			{
				m_WheelColliders[i].GetGroundHit(out var hit);
				if (Mathf.Abs(hit.forwardSlip) >= m_SlipLimit || Mathf.Abs(hit.sidewaysSlip) >= m_SlipLimit)
				{
					m_WheelEffects[i].EmitTyreSmoke();
					if (!AnySkidSoundPlaying())
					{
						m_WheelEffects[i].PlayAudio();
					}
				}
				else
				{
					if (m_WheelEffects[i].PlayingAudio)
					{
						m_WheelEffects[i].StopAudio();
					}
					m_WheelEffects[i].EndSkidTrail();
				}
			}
		}

		private void TractionControl()
		{
			WheelHit hit;
			switch (m_CarDriveType)
			{
			case UnityStandardAssets.Vehicles.Car.CarDriveType.SixWheelDrive:
			{
				for (int j = 0; j < m_WheelColliders.Length; j++)
				{
					m_WheelColliders[j].GetGroundHit(out hit);
					AdjustTorque(hit.forwardSlip);
				}
				break;
			}
			case UnityStandardAssets.Vehicles.Car.CarDriveType.FourWheelDrive:
			{
				for (int i = 0; i < m_WheelColliders.Length; i++)
				{
					m_WheelColliders[i].GetGroundHit(out hit);
					AdjustTorque(hit.forwardSlip);
				}
				break;
			}
			case UnityStandardAssets.Vehicles.Car.CarDriveType.RearWheelDrive:
				m_WheelColliders[2].GetGroundHit(out hit);
				AdjustTorque(hit.forwardSlip);
				m_WheelColliders[3].GetGroundHit(out hit);
				AdjustTorque(hit.forwardSlip);
				break;
			case UnityStandardAssets.Vehicles.Car.CarDriveType.FrontWheelDrive:
				m_WheelColliders[0].GetGroundHit(out hit);
				AdjustTorque(hit.forwardSlip);
				m_WheelColliders[1].GetGroundHit(out hit);
				AdjustTorque(hit.forwardSlip);
				break;
			}
		}

		private void AdjustTorque(float forwardSlip)
		{
			if (forwardSlip >= m_SlipLimit && m_CurrentTorque >= 0f)
			{
				m_CurrentTorque -= 10f * m_TractionControl;
				return;
			}
			m_CurrentTorque += 10f * m_TractionControl;
			if (m_CurrentTorque > m_FullTorqueOverAllWheels)
			{
				m_CurrentTorque = m_FullTorqueOverAllWheels;
			}
		}

		private bool AnySkidSoundPlaying()
		{
			for (int i = 0; i < m_WheelEffects.Length; i++)
			{
				if (m_WheelEffects[i].PlayingAudio)
				{
					return true;
				}
			}
			return false;
		}
	}
}
namespace UnityStandardAssets.SceneUtils
{
	public class ParticleSceneControls : MonoBehaviour
	{
		public enum Mode
		{
			Activate,
			Instantiate,
			Trail
		}

		public enum AlignMode
		{
			Normal,
			Up
		}

		[Serializable]
		public class DemoParticleSystem
		{
			public Transform transform;

			public Mode mode;

			public AlignMode align;

			public int maxCount;

			public float minDist;

			public int camOffset = 15;

			public string instructionText;
		}

		[Serializable]
		public class DemoParticleSystemList
		{
			public DemoParticleSystem[] items;
		}

		public DemoParticleSystemList demoParticles;

		public float spawnOffset = 0.5f;

		public float multiply = 1f;

		public bool clearOnChange;

		public Text titleText;

		public Transform sceneCamera;

		public Text instructionText;

		public Button previousButton;

		public Button nextButton;

		public GraphicRaycaster graphicRaycaster;

		public EventSystem eventSystem;

		private ParticleSystemMultiplier m_ParticleMultiplier;

		private List<Transform> m_CurrentParticleList = new List<Transform>();

		private Transform m_Instance;

		private static int s_SelectedIndex;

		private Vector3 m_CamOffsetVelocity = Vector3.zero;

		private Vector3 m_LastPos;

		private static DemoParticleSystem s_Selected;

		private void Awake()
		{
			Select(s_SelectedIndex);
			previousButton.onClick.AddListener(Previous);
			nextButton.onClick.AddListener(Next);
		}

		private void OnDisable()
		{
			previousButton.onClick.RemoveListener(Previous);
			nextButton.onClick.RemoveListener(Next);
		}

		private void Previous()
		{
			s_SelectedIndex--;
			if (s_SelectedIndex == -1)
			{
				s_SelectedIndex = demoParticles.items.Length - 1;
			}
			Select(s_SelectedIndex);
		}

		public void Next()
		{
			s_SelectedIndex++;
			if (s_SelectedIndex == demoParticles.items.Length)
			{
				s_SelectedIndex = 0;
			}
			Select(s_SelectedIndex);
		}

		private void Update()
		{
			sceneCamera.localPosition = Vector3.SmoothDamp(sceneCamera.localPosition, Vector3.forward * -s_Selected.camOffset, ref m_CamOffsetVelocity, 1f);
			if (s_Selected.mode == Mode.Activate || CheckForGuiCollision())
			{
				return;
			}
			bool num = Input.GetMouseButtonDown(0) && s_Selected.mode == Mode.Instantiate;
			bool flag = Input.GetMouseButton(0) && s_Selected.mode == Mode.Trail;
			if (!(num || flag) || !Physics.Raycast(Camera.main.ScreenPointToRay(Input.mousePosition), out var hitInfo))
			{
				return;
			}
			Quaternion rotation = Quaternion.LookRotation(hitInfo.normal);
			if (s_Selected.align == AlignMode.Up)
			{
				rotation = Quaternion.identity;
			}
			Vector3 vector = hitInfo.point + hitInfo.normal * spawnOffset;
			if (!((vector - m_LastPos).magnitude > s_Selected.minDist))
			{
				return;
			}
			if (s_Selected.mode != Mode.Trail || m_Instance == null)
			{
				m_Instance = UnityEngine.Object.Instantiate(s_Selected.transform, vector, rotation);
				if (m_ParticleMultiplier != null)
				{
					m_Instance.GetComponent<ParticleSystemMultiplier>().multiplier = multiply;
				}
				m_CurrentParticleList.Add(m_Instance);
				if (s_Selected.maxCount > 0 && m_CurrentParticleList.Count > s_Selected.maxCount)
				{
					if (m_CurrentParticleList[0] != null)
					{
						UnityEngine.Object.Destroy(m_CurrentParticleList[0].gameObject);
					}
					m_CurrentParticleList.RemoveAt(0);
				}
			}
			else
			{
				m_Instance.position = vector;
				m_Instance.rotation = rotation;
			}
			if (s_Selected.mode == Mode.Trail)
			{
				ParticleSystem.EmissionModule emission = m_Instance.transform.GetComponent<ParticleSystem>().emission;
				emission.enabled = false;
				m_Instance.transform.GetComponent<ParticleSystem>().Emit(1);
			}
			m_Instance.parent = hitInfo.transform;
			m_LastPos = vector;
		}

		private bool CheckForGuiCollision()
		{
			PointerEventData pointerEventData = new PointerEventData(eventSystem);
			pointerEventData.pressPosition = Input.mousePosition;
			pointerEventData.position = Input.mousePosition;
			List<RaycastResult> list = new List<RaycastResult>();
			graphicRaycaster.Raycast(pointerEventData, list);
			return list.Count > 0;
		}

		private void Select(int i)
		{
			s_Selected = demoParticles.items[i];
			m_Instance = null;
			DemoParticleSystem[] items = demoParticles.items;
			foreach (DemoParticleSystem demoParticleSystem in items)
			{
				if (demoParticleSystem != s_Selected && demoParticleSystem.mode == Mode.Activate)
				{
					demoParticleSystem.transform.gameObject.SetActive(value: false);
				}
			}
			if (s_Selected.mode == Mode.Activate)
			{
				s_Selected.transform.gameObject.SetActive(value: true);
			}
			m_ParticleMultiplier = s_Selected.transform.GetComponent<ParticleSystemMultiplier>();
			multiply = 1f;
			if (clearOnChange)
			{
				while (m_CurrentParticleList.Count > 0)
				{
					UnityEngine.Object.Destroy(m_CurrentParticleList[0].gameObject);
					m_CurrentParticleList.RemoveAt(0);
				}
			}
			instructionText.text = s_Selected.instructionText;
			titleText.text = s_Selected.transform.name;
		}
	}
	public class PlaceTargetWithMouse : MonoBehaviour
	{
		public float surfaceOffset = 1.5f;

		public GameObject setTargetOn;

		private void Update()
		{
			if (Input.GetMouseButtonDown(0) && Physics.Raycast(Camera.main.ScreenPointToRay(Input.mousePosition), out var hitInfo))
			{
				base.transform.position = hitInfo.point + hitInfo.normal * surfaceOffset;
				if (setTargetOn != null)
				{
					setTargetOn.SendMessage("SetTarget", base.transform);
				}
			}
		}
	}
	public class SlowMoButton : MonoBehaviour
	{
		public Sprite FullSpeedTex;

		public Sprite SlowSpeedTex;

		public float fullSpeed = 1f;

		public float slowSpeed = 0.3f;

		public Button button;

		private bool m_SlowMo;

		private void Start()
		{
			m_SlowMo = false;
		}

		private void OnDestroy()
		{
			Time.timeScale = 1f;
		}

		public void ChangeSpeed()
		{
			m_SlowMo = !m_SlowMo;
			Image image = button.targetGraphic as Image;
			if (image != null)
			{
				image.sprite = (m_SlowMo ? SlowSpeedTex : FullSpeedTex);
			}
			button.targetGraphic = image;
			Time.timeScale = (m_SlowMo ? slowSpeed : fullSpeed);
		}
	}
}
namespace UnityStandardAssets.Water
{
	[ExecuteInEditMode]
	public class WaterBasic : MonoBehaviour
	{
		private void Update()
		{
			Renderer component = GetComponent<Renderer>();
			if ((bool)component)
			{
				Material sharedMaterial = component.sharedMaterial;
				if ((bool)sharedMaterial)
				{
					Vector4 vector = sharedMaterial.GetVector("WaveSpeed");
					float @float = sharedMaterial.GetFloat("_WaveScale");
					float num = Time.time / 20f;
					Vector4 vector2 = vector * (num * @float);
					Vector4 value = new Vector4(Mathf.Repeat(vector2.x, 1f), Mathf.Repeat(vector2.y, 1f), Mathf.Repeat(vector2.z, 1f), Mathf.Repeat(vector2.w, 1f));
					sharedMaterial.SetVector("_WaveOffset", value);
				}
			}
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(WaterBase))]
	public class Displace : MonoBehaviour
	{
		public void Awake()
		{
			if (base.enabled)
			{
				OnEnable();
			}
			else
			{
				OnDisable();
			}
		}

		public void OnEnable()
		{
			Shader.EnableKeyword("WATER_VERTEX_DISPLACEMENT_ON");
			Shader.DisableKeyword("WATER_VERTEX_DISPLACEMENT_OFF");
		}

		public void OnDisable()
		{
			Shader.EnableKeyword("WATER_VERTEX_DISPLACEMENT_OFF");
			Shader.DisableKeyword("WATER_VERTEX_DISPLACEMENT_ON");
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(WaterBase))]
	public class GerstnerDisplace : Displace
	{
	}
	public class MeshContainer
	{
		public Mesh mesh;

		public Vector3[] vertices;

		public Vector3[] normals;

		public MeshContainer(Mesh m)
		{
			mesh = m;
			vertices = m.vertices;
			normals = m.normals;
		}

		public void Update()
		{
			mesh.vertices = vertices;
			mesh.normals = normals;
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(WaterBase))]
	public class PlanarReflection : MonoBehaviour
	{
		public LayerMask reflectionMask;

		public bool reflectSkybox;

		public Color clearColor = Color.grey;

		public string reflectionSampler = "_ReflectionTex";

		public float clipPlaneOffset = 0.07f;

		private Vector3 m_Oldpos;

		private Camera m_ReflectionCamera;

		private Material m_SharedMaterial;

		private Dictionary<Camera, bool> m_HelperCameras;

		public void Start()
		{
			m_SharedMaterial = ((WaterBase)base.gameObject.GetComponent(typeof(WaterBase))).sharedMaterial;
		}

		private Camera CreateReflectionCameraFor(Camera cam)
		{
			string text = base.gameObject.name + "Reflection" + cam.name;
			GameObject gameObject = GameObject.Find(text);
			if (!gameObject)
			{
				gameObject = new GameObject(text, typeof(Camera));
			}
			if (!gameObject.GetComponent(typeof(Camera)))
			{
				gameObject.AddComponent(typeof(Camera));
			}
			Camera component = gameObject.GetComponent<Camera>();
			component.backgroundColor = clearColor;
			component.clearFlags = (reflectSkybox ? CameraClearFlags.Skybox : CameraClearFlags.Color);
			SetStandardCameraParameter(component, reflectionMask);
			if (!component.targetTexture)
			{
				component.targetTexture = CreateTextureFor(cam);
			}
			return component;
		}

		private void SetStandardCameraParameter(Camera cam, LayerMask mask)
		{
			cam.cullingMask = (int)mask & ~(1 << LayerMask.NameToLayer("Water"));
			cam.backgroundColor = Color.black;
			cam.enabled = false;
		}

		private RenderTexture CreateTextureFor(Camera cam)
		{
			return new RenderTexture(Mathf.FloorToInt((float)cam.pixelWidth * 0.5f), Mathf.FloorToInt((float)cam.pixelHeight * 0.5f), 24)
			{
				hideFlags = HideFlags.DontSave
			};
		}

		public void RenderHelpCameras(Camera currentCam)
		{
			if (m_HelperCameras == null)
			{
				m_HelperCameras = new Dictionary<Camera, bool>();
			}
			if (!m_HelperCameras.ContainsKey(currentCam))
			{
				m_HelperCameras.Add(currentCam, value: false);
			}
			if (!m_HelperCameras[currentCam])
			{
				if (!m_ReflectionCamera)
				{
					m_ReflectionCamera = CreateReflectionCameraFor(currentCam);
				}
				RenderReflectionFor(currentCam, m_ReflectionCamera);
				m_HelperCameras[currentCam] = true;
			}
		}

		public void LateUpdate()
		{
			if (m_HelperCameras != null)
			{
				m_HelperCameras.Clear();
			}
		}

		public void WaterTileBeingRendered(Transform tr, Camera currentCam)
		{
			RenderHelpCameras(currentCam);
			if ((bool)m_ReflectionCamera && (bool)m_SharedMaterial)
			{
				m_SharedMaterial.SetTexture(reflectionSampler, m_ReflectionCamera.targetTexture);
			}
		}

		public void OnEnable()
		{
			Shader.EnableKeyword("WATER_REFLECTIVE");
			Shader.DisableKeyword("WATER_SIMPLE");
		}

		public void OnDisable()
		{
			Shader.EnableKeyword("WATER_SIMPLE");
			Shader.DisableKeyword("WATER_REFLECTIVE");
		}

		private void RenderReflectionFor(Camera cam, Camera reflectCamera)
		{
			if (!reflectCamera || ((bool)m_SharedMaterial && !m_SharedMaterial.HasProperty(reflectionSampler)))
			{
				return;
			}
			reflectCamera.cullingMask = (int)reflectionMask & ~(1 << LayerMask.NameToLayer("Water"));
			SaneCameraSettings(reflectCamera);
			reflectCamera.backgroundColor = clearColor;
			reflectCamera.clearFlags = (reflectSkybox ? CameraClearFlags.Skybox : CameraClearFlags.Color);
			if (reflectSkybox && (bool)cam.gameObject.GetComponent(typeof(Skybox)))
			{
				Skybox skybox = (Skybox)reflectCamera.gameObject.GetComponent(typeof(Skybox));
				if (!skybox)
				{
					skybox = (Skybox)reflectCamera.gameObject.AddComponent(typeof(Skybox));
				}
				skybox.material = ((Skybox)cam.GetComponent(typeof(Skybox))).material;
			}
			GL.invertCulling = true;
			Transform transform = base.transform;
			Vector3 eulerAngles = cam.transform.eulerAngles;
			reflectCamera.transform.eulerAngles = new Vector3(0f - eulerAngles.x, eulerAngles.y, eulerAngles.z);
			reflectCamera.transform.position = cam.transform.position;
			Vector3 position = transform.transform.position;
			position.y = transform.position.y;
			Vector3 up = transform.transform.up;
			float w = 0f - Vector3.Dot(up, position) - clipPlaneOffset;
			Vector4 plane = new Vector4(up.x, up.y, up.z, w);
			Matrix4x4 zero = Matrix4x4.zero;
			zero = CalculateReflectionMatrix(zero, plane);
			m_Oldpos = cam.transform.position;
			Vector3 position2 = zero.MultiplyPoint(m_Oldpos);
			reflectCamera.worldToCameraMatrix = cam.worldToCameraMatrix * zero;
			Vector4 clipPlane = CameraSpacePlane(reflectCamera, position, up, 1f);
			Matrix4x4 projectionMatrix = cam.projectionMatrix;
			projectionMatrix = CalculateObliqueMatrix(projectionMatrix, clipPlane);
			reflectCamera.projectionMatrix = projectionMatrix;
			reflectCamera.transform.position = position2;
			Vector3 eulerAngles2 = cam.transform.eulerAngles;
			reflectCamera.transform.eulerAngles = new Vector3(0f - eulerAngles2.x, eulerAngles2.y, eulerAngles2.z);
			reflectCamera.Render();
			GL.invertCulling = false;
		}

		private void SaneCameraSettings(Camera helperCam)
		{
			helperCam.depthTextureMode = DepthTextureMode.None;
			helperCam.backgroundColor = Color.black;
			helperCam.clearFlags = CameraClearFlags.Color;
			helperCam.renderingPath = RenderingPath.Forward;
		}

		private static Matrix4x4 CalculateObliqueMatrix(Matrix4x4 projection, Vector4 clipPlane)
		{
			Vector4 b = projection.inverse * new Vector4(Sgn(clipPlane.x), Sgn(clipPlane.y), 1f, 1f);
			Vector4 vector = clipPlane * (2f / Vector4.Dot(clipPlane, b));
			projection[2] = vector.x - projection[3];
			projection[6] = vector.y - projection[7];
			projection[10] = vector.z - projection[11];
			projection[14] = vector.w - projection[15];
			return projection;
		}

		private static Matrix4x4 CalculateReflectionMatrix(Matrix4x4 reflectionMat, Vector4 plane)
		{
			reflectionMat.m00 = 1f - 2f * plane[0] * plane[0];
			reflectionMat.m01 = -2f * plane[0] * plane[1];
			reflectionMat.m02 = -2f * plane[0] * plane[2];
			reflectionMat.m03 = -2f * plane[3] * plane[0];
			reflectionMat.m10 = -2f * plane[1] * plane[0];
			reflectionMat.m11 = 1f - 2f * plane[1] * plane[1];
			reflectionMat.m12 = -2f * plane[1] * plane[2];
			reflectionMat.m13 = -2f * plane[3] * plane[1];
			reflectionMat.m20 = -2f * plane[2] * plane[0];
			reflectionMat.m21 = -2f * plane[2] * plane[1];
			reflectionMat.m22 = 1f - 2f * plane[2] * plane[2];
			reflectionMat.m23 = -2f * plane[3] * plane[2];
			reflectionMat.m30 = 0f;
			reflectionMat.m31 = 0f;
			reflectionMat.m32 = 0f;
			reflectionMat.m33 = 1f;
			return reflectionMat;
		}

		private static float Sgn(float a)
		{
			if (a > 0f)
			{
				return 1f;
			}
			if (a < 0f)
			{
				return -1f;
			}
			return 0f;
		}

		private Vector4 CameraSpacePlane(Camera cam, Vector3 pos, Vector3 normal, float sideSign)
		{
			Vector3 point = pos + normal * clipPlaneOffset;
			Matrix4x4 worldToCameraMatrix = cam.worldToCameraMatrix;
			Vector3 lhs = worldToCameraMatrix.MultiplyPoint(point);
			Vector3 rhs = worldToCameraMatrix.MultiplyVector(normal).normalized * sideSign;
			return new Vector4(rhs.x, rhs.y, rhs.z, 0f - Vector3.Dot(lhs, rhs));
		}
	}
	[RequireComponent(typeof(WaterBase))]
	[ExecuteInEditMode]
	public class SpecularLighting : MonoBehaviour
	{
		public Transform specularLight;

		private WaterBase m_WaterBase;

		public void Start()
		{
			m_WaterBase = (WaterBase)base.gameObject.GetComponent(typeof(WaterBase));
		}

		public void Update()
		{
			if (!m_WaterBase)
			{
				m_WaterBase = (WaterBase)base.gameObject.GetComponent(typeof(WaterBase));
			}
			if ((bool)specularLight && (bool)m_WaterBase.sharedMaterial)
			{
				m_WaterBase.sharedMaterial.SetVector("_WorldLightDir", specularLight.transform.forward);
			}
		}
	}
	[ExecuteInEditMode]
	public class Water : MonoBehaviour
	{
		public enum WaterMode
		{
			Simple,
			Reflective,
			Refractive
		}

		public WaterMode waterMode = WaterMode.Refractive;

		public bool disablePixelLights = true;

		public int textureSize = 256;

		public float clipPlaneOffset = 0.07f;

		public LayerMask reflectLayers = -1;

		public LayerMask refractLayers = -1;

		private Dictionary<Camera, Camera> m_ReflectionCameras = new Dictionary<Camera, Camera>();

		private Dictionary<Camera, Camera> m_RefractionCameras = new Dictionary<Camera, Camera>();

		private RenderTexture m_ReflectionTexture;

		private RenderTexture m_RefractionTexture;

		private WaterMode m_HardwareWaterSupport = WaterMode.Refractive;

		private int m_OldReflectionTextureSize;

		private int m_OldRefractionTextureSize;

		private static bool s_InsideWater;

		public void OnWillRenderObject()
		{
			if (!base.enabled || !GetComponent<Renderer>() || !GetComponent<Renderer>().sharedMaterial || !GetComponent<Renderer>().enabled)
			{
				return;
			}
			Camera current = Camera.current;
			if ((bool)current && !s_InsideWater)
			{
				s_InsideWater = true;
				m_HardwareWaterSupport = FindHardwareWaterSupport();
				WaterMode waterMode = GetWaterMode();
				CreateWaterObjects(current, out var reflectionCamera, out var refractionCamera);
				Vector3 position = base.transform.position;
				Vector3 up = base.transform.up;
				int pixelLightCount = QualitySettings.pixelLightCount;
				if (disablePixelLights)
				{
					QualitySettings.pixelLightCount = 0;
				}
				UpdateCameraModes(current, reflectionCamera);
				UpdateCameraModes(current, refractionCamera);
				if (waterMode >= WaterMode.Reflective)
				{
					float w = 0f - Vector3.Dot(up, position) - clipPlaneOffset;
					Vector4 plane = new Vector4(up.x, up.y, up.z, w);
					Matrix4x4 reflectionMat = Matrix4x4.zero;
					CalculateReflectionMatrix(ref reflectionMat, plane);
					Vector3 position2 = current.transform.position;
					Vector3 position3 = reflectionMat.MultiplyPoint(position2);
					reflectionCamera.worldToCameraMatrix = current.worldToCameraMatrix * reflectionMat;
					Vector4 clipPlane = CameraSpacePlane(reflectionCamera, position, up, 1f);
					reflectionCamera.projectionMatrix = current.CalculateObliqueMatrix(clipPlane);
					reflectionCamera.cullingMatrix = current.projectionMatrix * current.worldToCameraMatrix;
					reflectionCamera.cullingMask = -17 & reflectLayers.value;
					reflectionCamera.targetTexture = m_ReflectionTexture;
					bool invertCulling = GL.invertCulling;
					GL.invertCulling = !invertCulling;
					reflectionCamera.transform.position = position3;
					Vector3 eulerAngles = current.transform.eulerAngles;
					reflectionCamera.transform.eulerAngles = new Vector3(0f - eulerAngles.x, eulerAngles.y, eulerAngles.z);
					reflectionCamera.Render();
					reflectionCamera.transform.position = position2;
					GL.invertCulling = invertCulling;
					GetComponent<Renderer>().sharedMaterial.SetTexture("_ReflectionTex", m_ReflectionTexture);
				}
				if (waterMode >= WaterMode.Refractive)
				{
					refractionCamera.worldToCameraMatrix = current.worldToCameraMatrix;
					Vector4 clipPlane2 = CameraSpacePlane(refractionCamera, position, up, -1f);
					refractionCamera.projectionMatrix = current.CalculateObliqueMatrix(clipPlane2);
					refractionCamera.cullingMatrix = current.projectionMatrix * current.worldToCameraMatrix;
					refractionCamera.cullingMask = -17 & refractLayers.value;
					refractionCamera.targetTexture = m_RefractionTexture;
					refractionCamera.transform.position = current.transform.position;
					refractionCamera.transform.rotation = current.transform.rotation;
					refractionCamera.Render();
					GetComponent<Renderer>().sharedMaterial.SetTexture("_RefractionTex", m_RefractionTexture);
				}
				if (disablePixelLights)
				{
					QualitySettings.pixelLightCount = pixelLightCount;
				}
				switch (waterMode)
				{
				case WaterMode.Simple:
					Shader.EnableKeyword("WATER_SIMPLE");
					Shader.DisableKeyword("WATER_REFLECTIVE");
					Shader.DisableKeyword("WATER_REFRACTIVE");
					break;
				case WaterMode.Reflective:
					Shader.DisableKeyword("WATER_SIMPLE");
					Shader.EnableKeyword("WATER_REFLECTIVE");
					Shader.DisableKeyword("WATER_REFRACTIVE");
					break;
				case WaterMode.Refractive:
					Shader.DisableKeyword("WATER_SIMPLE");
					Shader.DisableKeyword("WATER_REFLECTIVE");
					Shader.EnableKeyword("WATER_REFRACTIVE");
					break;
				}
				s_InsideWater = false;
			}
		}

		private void OnDisable()
		{
			if ((bool)m_ReflectionTexture)
			{
				UnityEngine.Object.DestroyImmediate(m_ReflectionTexture);
				m_ReflectionTexture = null;
			}
			if ((bool)m_RefractionTexture)
			{
				UnityEngine.Object.DestroyImmediate(m_RefractionTexture);
				m_RefractionTexture = null;
			}
			foreach (KeyValuePair<Camera, Camera> reflectionCamera in m_ReflectionCameras)
			{
				UnityEngine.Object.DestroyImmediate(reflectionCamera.Value.gameObject);
			}
			m_ReflectionCameras.Clear();
			foreach (KeyValuePair<Camera, Camera> refractionCamera in m_RefractionCameras)
			{
				UnityEngine.Object.DestroyImmediate(refractionCamera.Value.gameObject);
			}
			m_RefractionCameras.Clear();
		}

		private void Update()
		{
			if ((bool)GetComponent<Renderer>())
			{
				Material sharedMaterial = GetComponent<Renderer>().sharedMaterial;
				if ((bool)sharedMaterial)
				{
					Vector4 vector = sharedMaterial.GetVector("WaveSpeed");
					float @float = sharedMaterial.GetFloat("_WaveScale");
					Vector4 value = new Vector4(@float, @float, @float * 0.4f, @float * 0.45f);
					double num = (double)Time.timeSinceLevelLoad / 20.0;
					Vector4 value2 = new Vector4((float)Math.IEEERemainder((double)(vector.x * value.x) * num, 1.0), (float)Math.IEEERemainder((double)(vector.y * value.y) * num, 1.0), (float)Math.IEEERemainder((double)(vector.z * value.z) * num, 1.0), (float)Math.IEEERemainder((double)(vector.w * value.w) * num, 1.0));
					sharedMaterial.SetVector("_WaveOffset", value2);
					sharedMaterial.SetVector("_WaveScale4", value);
				}
			}
		}

		private void UpdateCameraModes(Camera src, Camera dest)
		{
			if (dest == null)
			{
				return;
			}
			dest.clearFlags = src.clearFlags;
			dest.backgroundColor = src.backgroundColor;
			if (src.clearFlags == CameraClearFlags.Skybox)
			{
				Skybox component = src.GetComponent<Skybox>();
				Skybox component2 = dest.GetComponent<Skybox>();
				if (!component || !component.material)
				{
					component2.enabled = false;
				}
				else
				{
					component2.enabled = true;
					component2.material = component.material;
				}
			}
			dest.farClipPlane = src.farClipPlane;
			dest.nearClipPlane = src.nearClipPlane;
			dest.orthographic = src.orthographic;
			dest.fieldOfView = src.fieldOfView;
			dest.aspect = src.aspect;
			dest.orthographicSize = src.orthographicSize;
		}

		private void CreateWaterObjects(Camera currentCamera, out Camera reflectionCamera, out Camera refractionCamera)
		{
			WaterMode waterMode = GetWaterMode();
			reflectionCamera = null;
			refractionCamera = null;
			if (waterMode >= WaterMode.Reflective)
			{
				if (!m_ReflectionTexture || m_OldReflectionTextureSize != textureSize)
				{
					if ((bool)m_ReflectionTexture)
					{
						UnityEngine.Object.DestroyImmediate(m_ReflectionTexture);
					}
					m_ReflectionTexture = new RenderTexture(textureSize, textureSize, 16);
					m_ReflectionTexture.name = "__WaterReflection" + GetInstanceID();
					m_ReflectionTexture.isPowerOfTwo = true;
					m_ReflectionTexture.hideFlags = HideFlags.DontSave;
					m_OldReflectionTextureSize = textureSize;
				}
				m_ReflectionCameras.TryGetValue(currentCamera, out reflectionCamera);
				if (!reflectionCamera)
				{
					GameObject gameObject = new GameObject("Water Refl Camera id" + GetInstanceID() + " for " + currentCamera.GetInstanceID(), typeof(Camera), typeof(Skybox));
					reflectionCamera = gameObject.GetComponent<Camera>();
					reflectionCamera.enabled = false;
					reflectionCamera.transform.position = base.transform.position;
					reflectionCamera.transform.rotation = base.transform.rotation;
					reflectionCamera.gameObject.AddComponent<FlareLayer>();
					gameObject.hideFlags = HideFlags.HideAndDontSave;
					m_ReflectionCameras[currentCamera] = reflectionCamera;
				}
			}
			if (waterMode < WaterMode.Refractive)
			{
				return;
			}
			if (!m_RefractionTexture || m_OldRefractionTextureSize != textureSize)
			{
				if ((bool)m_RefractionTexture)
				{
					UnityEngine.Object.DestroyImmediate(m_RefractionTexture);
				}
				m_RefractionTexture = new RenderTexture(textureSize, textureSize, 16);
				m_RefractionTexture.name = "__WaterRefraction" + GetInstanceID();
				m_RefractionTexture.isPowerOfTwo = true;
				m_RefractionTexture.hideFlags = HideFlags.DontSave;
				m_OldRefractionTextureSize = textureSize;
			}
			m_RefractionCameras.TryGetValue(currentCamera, out refractionCamera);
			if (!refractionCamera)
			{
				GameObject gameObject2 = new GameObject("Water Refr Camera id" + GetInstanceID() + " for " + currentCamera.GetInstanceID(), typeof(Camera), typeof(Skybox));
				refractionCamera = gameObject2.GetComponent<Camera>();
				refractionCamera.enabled = false;
				refractionCamera.transform.position = base.transform.position;
				refractionCamera.transform.rotation = base.transform.rotation;
				refractionCamera.gameObject.AddComponent<FlareLayer>();
				gameObject2.hideFlags = HideFlags.HideAndDontSave;
				m_RefractionCameras[currentCamera] = refractionCamera;
			}
		}

		private WaterMode GetWaterMode()
		{
			if (m_HardwareWaterSupport < waterMode)
			{
				return m_HardwareWaterSupport;
			}
			return waterMode;
		}

		private WaterMode FindHardwareWaterSupport()
		{
			if (!GetComponent<Renderer>())
			{
				return WaterMode.Simple;
			}
			Material sharedMaterial = GetComponent<Renderer>().sharedMaterial;
			if (!sharedMaterial)
			{
				return WaterMode.Simple;
			}
			string text = sharedMaterial.GetTag("WATERMODE", searchFallbacks: false);
			if (text == "Refractive")
			{
				return WaterMode.Refractive;
			}
			if (text == "Reflective")
			{
				return WaterMode.Reflective;
			}
			return WaterMode.Simple;
		}

		private Vector4 CameraSpacePlane(Camera cam, Vector3 pos, Vector3 normal, float sideSign)
		{
			Vector3 point = pos + normal * clipPlaneOffset;
			Matrix4x4 worldToCameraMatrix = cam.worldToCameraMatrix;
			Vector3 lhs = worldToCameraMatrix.MultiplyPoint(point);
			Vector3 rhs = worldToCameraMatrix.MultiplyVector(normal).normalized * sideSign;
			return new Vector4(rhs.x, rhs.y, rhs.z, 0f - Vector3.Dot(lhs, rhs));
		}

		private static void CalculateReflectionMatrix(ref Matrix4x4 reflectionMat, Vector4 plane)
		{
			reflectionMat.m00 = 1f - 2f * plane[0] * plane[0];
			reflectionMat.m01 = -2f * plane[0] * plane[1];
			reflectionMat.m02 = -2f * plane[0] * plane[2];
			reflectionMat.m03 = -2f * plane[3] * plane[0];
			reflectionMat.m10 = -2f * plane[1] * plane[0];
			reflectionMat.m11 = 1f - 2f * plane[1] * plane[1];
			reflectionMat.m12 = -2f * plane[1] * plane[2];
			reflectionMat.m13 = -2f * plane[3] * plane[1];
			reflectionMat.m20 = -2f * plane[2] * plane[0];
			reflectionMat.m21 = -2f * plane[2] * plane[1];
			reflectionMat.m22 = 1f - 2f * plane[2] * plane[2];
			reflectionMat.m23 = -2f * plane[3] * plane[2];
			reflectionMat.m30 = 0f;
			reflectionMat.m31 = 0f;
			reflectionMat.m32 = 0f;
			reflectionMat.m33 = 1f;
		}
	}
	public enum WaterQuality
	{
		High = 2,
		Medium = 1,
		Low = 0
	}
	[ExecuteInEditMode]
	public class WaterBase : MonoBehaviour
	{
		public Material sharedMaterial;

		public WaterQuality waterQuality = WaterQuality.High;

		public bool edgeBlend = true;

		public void UpdateShader()
		{
			if (waterQuality > WaterQuality.Medium)
			{
				sharedMaterial.shader.maximumLOD = 501;
			}
			else if (waterQuality > WaterQuality.Low)
			{
				sharedMaterial.shader.maximumLOD = 301;
			}
			else
			{
				sharedMaterial.shader.maximumLOD = 201;
			}
			if (!SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.Depth))
			{
				edgeBlend = false;
			}
			if (edgeBlend)
			{
				Shader.EnableKeyword("WATER_EDGEBLEND_ON");
				Shader.DisableKeyword("WATER_EDGEBLEND_OFF");
				if ((bool)Camera.main)
				{
					Camera.main.depthTextureMode |= DepthTextureMode.Depth;
				}
			}
			else
			{
				Shader.EnableKeyword("WATER_EDGEBLEND_OFF");
				Shader.DisableKeyword("WATER_EDGEBLEND_ON");
			}
		}

		public void WaterTileBeingRendered(Transform tr, Camera currentCam)
		{
			if ((bool)currentCam && edgeBlend)
			{
				currentCam.depthTextureMode |= DepthTextureMode.Depth;
			}
		}

		public void Update()
		{
			if ((bool)sharedMaterial)
			{
				UpdateShader();
			}
		}
	}
	[ExecuteInEditMode]
	public class WaterTile : MonoBehaviour
	{
		public PlanarReflection reflection;

		public WaterBase waterBase;

		public void Start()
		{
			AcquireComponents();
		}

		private void AcquireComponents()
		{
			if (!reflection)
			{
				if ((bool)base.transform.parent)
				{
					reflection = base.transform.parent.GetComponent<PlanarReflection>();
				}
				else
				{
					reflection = base.transform.GetComponent<PlanarReflection>();
				}
			}
			if (!waterBase)
			{
				if ((bool)base.transform.parent)
				{
					waterBase = base.transform.parent.GetComponent<WaterBase>();
				}
				else
				{
					waterBase = base.transform.GetComponent<WaterBase>();
				}
			}
		}

		public void OnWillRenderObject()
		{
			if ((bool)reflection)
			{
				reflection.WaterTileBeingRendered(base.transform, Camera.current);
			}
			if ((bool)waterBase)
			{
				waterBase.WaterTileBeingRendered(base.transform, Camera.current);
			}
		}
	}
}
namespace J_LitJson
{
	public enum JsonType
	{
		None,
		Object,
		Array,
		String,
		Int,
		Long,
		Double,
		Single,
		Boolean
	}
	public interface IJsonWrapper : IList, ICollection, IEnumerable, IOrderedDictionary, IDictionary
	{
		bool IsArray { get; }

		bool IsBoolean { get; }

		bool IsDouble { get; }

		bool IsSingle { get; }

		bool IsInt { get; }

		bool IsLong { get; }

		bool IsObject { get; }

		bool IsString { get; }

		bool GetBoolean();

		double GetDouble();

		float GetSingle();

		int GetInt();

		JsonType GetJsonType();

		long GetLong();

		string GetString();

		void SetBoolean(bool val);

		void SetDouble(double val);

		void SetSingle(float val);

		void SetInt(int val);

		void SetJsonType(JsonType type);

		void SetLong(long val);

		void SetString(string val);

		string ToJson();

		void ToJson(JsonWriter writer);
	}
	public class JsonData : IJsonWrapper, IList, ICollection, IEnumerable, IOrderedDictionary, IDictionary, IEquatable<JsonData>
	{
		private IList<JsonData> inst_array;

		private bool inst_boolean;

		private double inst_double;

		private float inst_single;

		private int inst_int;

		private long inst_long;

		private IDictionary<string, JsonData> inst_object;

		private string inst_string;

		private string json;

		private JsonType type;

		private IList<KeyValuePair<string, JsonData>> object_list;

		public IDictionary<string, JsonData> Inst_Object => inst_object;

		public int Count => EnsureCollection().Count;

		public bool IsArray => type == JsonType.Array;

		public bool IsBoolean => type == JsonType.Boolean;

		public bool IsDouble => type == JsonType.Double;

		public bool IsSingle => type == JsonType.Single;

		public bool IsInt => type == JsonType.Int;

		public bool IsLong => type == JsonType.Long;

		public bool IsObject => type == JsonType.Object;

		public bool IsString => type == JsonType.String;

		int ICollection.Count => Count;

		bool ICollection.IsSynchronized => EnsureCollection().IsSynchronized;

		object ICollection.SyncRoot => EnsureCollection().SyncRoot;

		bool IDictionary.IsFixedSize => EnsureDictionary().IsFixedSize;

		bool IDictionary.IsReadOnly => EnsureDictionary().IsReadOnly;

		ICollection IDictionary.Keys
		{
			get
			{
				EnsureDictionary();
				IList<string> list = new List<string>();
				foreach (KeyValuePair<string, JsonData> item in object_list)
				{
					list.Add(item.Key);
				}
				return (ICollection)list;
			}
		}

		ICollection IDictionary.Values
		{
			get
			{
				EnsureDictionary();
				IList<JsonData> list = new List<JsonData>();
				foreach (KeyValuePair<string, JsonData> item in object_list)
				{
					list.Add(item.Value);
				}
				return (ICollection)list;
			}
		}

		bool IJsonWrapper.IsArray => IsArray;

		bool IJsonWrapper.IsBoolean => IsBoolean;

		bool IJsonWrapper.IsDouble => IsDouble;

		bool IJsonWrapper.IsSingle => IsSingle;

		bool IJsonWrapper.IsInt => IsInt;

		bool IJsonWrapper.IsLong => IsLong;

		bool IJsonWrapper.IsObject => IsObject;

		bool IJsonWrapper.IsString => IsString;

		bool IList.IsFixedSize => EnsureList().IsFixedSize;

		bool IList.IsReadOnly => EnsureList().IsReadOnly;

		object IDictionary.this[object key]
		{
			get
			{
				return EnsureDictionary()[key];
			}
			set
			{
				if (!(key is string))
				{
					throw new ArgumentException("The key has to be a string");
				}
				JsonData value2 = ToJsonData(value);
				this[(string)key] = value2;
			}
		}

		object IOrderedDictionary.this[int idx]
		{
			get
			{
				EnsureDictionary();
				return object_list[idx].Value;
			}
			set
			{
				EnsureDictionary();
				JsonData value2 = ToJsonData(value);
				KeyValuePair<string, JsonData> keyValuePair = object_list[idx];
				inst_object[keyValuePair.Key] = value2;
				KeyValuePair<string, JsonData> value3 = new KeyValuePair<string, JsonData>(keyValuePair.Key, value2);
				object_list[idx] = value3;
			}
		}

		object IList.this[int index]
		{
			get
			{
				return EnsureList()[index];
			}
			set
			{
				EnsureList();
				JsonData value2 = ToJsonData(value);
				this[index] = value2;
			}
		}

		public JsonData this[string prop_name]
		{
			get
			{
				EnsureDictionary();
				return inst_object[prop_name];
			}
			set
			{
				EnsureDictionary();
				KeyValuePair<string, JsonData> keyValuePair = new KeyValuePair<string, JsonData>(prop_name, value);
				if (inst_object.ContainsKey(prop_name))
				{
					for (int i = 0; i < object_list.Count; i++)
					{
						if (object_list[i].Key == prop_name)
						{
							object_list[i] = keyValuePair;
							break;
						}
					}
				}
				else
				{
					object_list.Add(keyValuePair);
				}
				inst_object[prop_name] = value;
				json = null;
			}
		}

		public JsonData this[int index]
		{
			get
			{
				EnsureCollection();
				if (type == JsonType.Array)
				{
					return inst_array[index];
				}
				return object_list[index].Value;
			}
			set
			{
				EnsureCollection();
				if (type == JsonType.Array)
				{
					inst_array[index] = value;
				}
				else
				{
					KeyValuePair<string, JsonData> keyValuePair = object_list[index];
					KeyValuePair<string, JsonData> value2 = new KeyValuePair<string, JsonData>(keyValuePair.Key, value);
					object_list[index] = value2;
					inst_object[keyValuePair.Key] = value;
				}
				json = null;
			}
		}

		public JsonData()
		{
		}

		public JsonData(bool boolean)
		{
			type = JsonType.Boolean;
			inst_boolean = boolean;
		}

		public JsonData(double number)
		{
			type = JsonType.Double;
			inst_double = number;
		}

		public JsonData(float number)
		{
			type = JsonType.Single;
			inst_single = number;
		}

		public JsonData(int number)
		{
			type = JsonType.Int;
			inst_int = number;
		}

		public JsonData(long number)
		{
			type = JsonType.Long;
			inst_long = number;
		}

		public JsonData(object obj)
		{
			if (obj is bool)
			{
				type = JsonType.Boolean;
				inst_boolean = (bool)obj;
				return;
			}
			if (obj is double)
			{
				type = JsonType.Double;
				inst_double = (double)obj;
				return;
			}
			if (obj is float)
			{
				type = JsonType.Single;
				inst_single = (float)obj;
				return;
			}
			if (obj is int)
			{
				type = JsonType.Int;
				inst_int = (int)obj;
				return;
			}
			if (obj is long)
			{
				type = JsonType.Long;
				inst_long = (long)obj;
				return;
			}
			if (obj is string)
			{
				type = JsonType.String;
				inst_string = (string)obj;
				return;
			}
			throw new ArgumentException("Unable to wrap the given object with JsonData");
		}

		public JsonData(string str)
		{
			type = JsonType.String;
			inst_string = str;
		}

		public static implicit operator JsonData(bool data)
		{
			return new JsonData(data);
		}

		public static implicit operator JsonData(double data)
		{
			return new JsonData(data);
		}

		public static implicit operator JsonData(float data)
		{
			return new JsonData(data);
		}

		public static implicit operator JsonData(int data)
		{
			return new JsonData(data);
		}

		public static implicit operator JsonData(long data)
		{
			return new JsonData(data);
		}

		public static implicit operator JsonData(string data)
		{
			return new JsonData(data);
		}

		public static explicit operator bool(JsonData data)
		{
			if (data.type != JsonType.Boolean)
			{
				throw new InvalidCastException("Instance of JsonData doesn't hold a double");
			}
			return data.inst_boolean;
		}

		public static explicit operator double(JsonData data)
		{
			if (data.type != JsonType.Double)
			{
				throw new InvalidCastException("Instance of JsonData doesn't hold a double");
			}
			return data.inst_double;
		}

		public static explicit operator float(JsonData data)
		{
			if (data.type != JsonType.Single)
			{
				throw new InvalidCastException("Instance of JsonData doesn't hold a single");
			}
			return data.inst_single;
		}

		public static explicit operator int(JsonData data)
		{
			if (data.type != JsonType.Int)
			{
				throw new InvalidCastException("Instance of JsonData doesn't hold an int");
			}
			return data.inst_int;
		}

		public static explicit operator long(JsonData data)
		{
			if (data.type != JsonType.Long)
			{
				throw new InvalidCastException("Instance of JsonData doesn't hold an int");
			}
			return data.inst_long;
		}

		public static explicit operator string(JsonData data)
		{
			if (data.type != JsonType.String)
			{
				throw new InvalidCastException("Instance of JsonData doesn't hold a string");
			}
			return data.inst_string;
		}

		void ICollection.CopyTo(Array array, int index)
		{
			EnsureCollection().CopyTo(array, index);
		}

		void IDictionary.Add(object key, object value)
		{
			JsonData value2 = ToJsonData(value);
			EnsureDictionary().Add(key, value2);
			KeyValuePair<string, JsonData> item = new KeyValuePair<string, JsonData>((string)key, value2);
			object_list.Add(item);
			json = null;
		}

		void IDictionary.Clear()
		{
			EnsureDictionary().Clear();
			object_list.Clear();
			json = null;
		}

		bool IDictionary.Contains(object key)
		{
			return EnsureDictionary().Contains(key);
		}

		IDictionaryEnumerator IDictionary.GetEnumerator()
		{
			return ((IOrderedDictionary)this).GetEnumerator();
		}

		void IDictionary.Remove(object key)
		{
			EnsureDictionary().Remove(key);
			for (int i = 0; i < object_list.Count; i++)
			{
				if (object_list[i].Key == (string)key)
				{
					object_list.RemoveAt(i);
					break;
				}
			}
			json = null;
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return EnsureCollection().GetEnumerator();
		}

		bool IJsonWrapper.GetBoolean()
		{
			if (type != JsonType.Boolean)
			{
				throw new InvalidOperationException("JsonData instance doesn't hold a boolean");
			}
			return inst_boolean;
		}

		double IJsonWrapper.GetDouble()
		{
			if (type != JsonType.Double)
			{
				throw new InvalidOperationException("JsonData instance doesn't hold a double");
			}
			return inst_double;
		}

		float IJsonWrapper.GetSingle()
		{
			if (type != JsonType.Single)
			{
				throw new InvalidOperationException("JsonData instance doesn't hold a single");
			}
			return inst_single;
		}

		int IJsonWrapper.GetInt()
		{
			if (type != JsonType.Int)
			{
				throw new InvalidOperationException("JsonData instance doesn't hold an int");
			}
			return inst_int;
		}

		long IJsonWrapper.GetLong()
		{
			if (type != JsonType.Long)
			{
				throw new InvalidOperationException("JsonData instance doesn't hold a long");
			}
			return inst_long;
		}

		string IJsonWrapper.GetString()
		{
			if (type != JsonType.String)
			{
				throw new InvalidOperationException("JsonData instance doesn't hold a string");
			}
			return inst_string;
		}

		void IJsonWrapper.SetBoolean(bool val)
		{
			type = JsonType.Boolean;
			inst_boolean = val;
			json = null;
		}

		void IJsonWrapper.SetDouble(double val)
		{
			type = JsonType.Double;
			inst_double = val;
			json = null;
		}

		void IJsonWrapper.SetSingle(float val)
		{
			type = JsonType.Single;
			inst_single = val;
			json = null;
		}

		void IJsonWrapper.SetInt(int val)
		{
			type = JsonType.Int;
			inst_int = val;
			json = null;
		}

		void IJsonWrapper.SetLong(long val)
		{
			type = JsonType.Long;
			inst_long = val;
			json = null;
		}

		void IJsonWrapper.SetString(string val)
		{
			type = JsonType.String;
			inst_string = val;
			json = null;
		}

		string IJsonWrapper.ToJson()
		{
			return ToJson();
		}

		void IJsonWrapper.ToJson(JsonWriter writer)
		{
			ToJson(writer);
		}

		int IList.Add(object value)
		{
			return Add(value);
		}

		void IList.Clear()
		{
			EnsureList().Clear();
			json = null;
		}

		bool IList.Contains(object value)
		{
			return EnsureList().Contains(value);
		}

		int IList.IndexOf(object value)
		{
			return EnsureList().IndexOf(value);
		}

		void IList.Insert(int index, object value)
		{
			EnsureList().Insert(index, value);
			json = null;
		}

		void IList.Remove(object value)
		{
			EnsureList().Remove(value);
			json = null;
		}

		void IList.RemoveAt(int index)
		{
			EnsureList().RemoveAt(index);
			json = null;
		}

		IDictionaryEnumerator IOrderedDictionary.GetEnumerator()
		{
			EnsureDictionary();
			return new OrderedDictionaryEnumerator(object_list.GetEnumerator());
		}

		void IOrderedDictionary.Insert(int idx, object key, object value)
		{
			string text = (string)key;
			JsonData value2 = (this[text] = ToJsonData(value));
			KeyValuePair<string, JsonData> item = new KeyValuePair<string, JsonData>(text, value2);
			object_list.Insert(idx, item);
		}

		void IOrderedDictionary.RemoveAt(int idx)
		{
			EnsureDictionary();
			inst_object.Remove(object_list[idx].Key);
			object_list.RemoveAt(idx);
		}

		private ICollection EnsureCollection()
		{
			if (type == JsonType.Array)
			{
				return (ICollection)inst_array;
			}
			if (type == JsonType.Object)
			{
				return (ICollection)inst_object;
			}
			throw new InvalidOperationException("The JsonData instance has to be initialized first");
		}

		private IDictionary EnsureDictionary()
		{
			if (type == JsonType.Object)
			{
				return (IDictionary)inst_object;
			}
			if (type != 0)
			{
				throw new InvalidOperationException("Instance of JsonData is not a dictionary");
			}
			type = JsonType.Object;
			inst_object = new Dictionary<string, JsonData>();
			object_list = new List<KeyValuePair<string, JsonData>>();
			return (IDictionary)inst_object;
		}

		private IList EnsureList()
		{
			if (type == JsonType.Array)
			{
				return (IList)inst_array;
			}
			if (type != 0)
			{
				throw new InvalidOperationException("Instance of JsonData is not a list");
			}
			type = JsonType.Array;
			inst_array = new List<JsonData>();
			return (IList)inst_array;
		}

		private JsonData ToJsonData(object obj)
		{
			if (obj == null)
			{
				return null;
			}
			if (obj is JsonData)
			{
				return (JsonData)obj;
			}
			return new JsonData(obj);
		}

		private static void WriteJson(IJsonWrapper obj, JsonWriter writer)
		{
			if (obj == null)
			{
				writer.Write(null);
			}
			else if (obj.IsString)
			{
				writer.Write(obj.GetString());
			}
			else if (obj.IsBoolean)
			{
				writer.Write(obj.GetBoolean());
			}
			else if (obj.IsDouble)
			{
				writer.Write(obj.GetDouble());
			}
			else if (obj.IsSingle)
			{
				writer.Write(obj.GetSingle());
			}
			else if (obj.IsInt)
			{
				writer.Write(obj.GetInt());
			}
			else if (obj.IsLong)
			{
				writer.Write(obj.GetLong());
			}
			else if (obj.IsArray)
			{
				writer.WriteArrayStart();
				foreach (JsonData item in (IEnumerable)obj)
				{
					WriteJson(item, writer);
				}
				writer.WriteArrayEnd();
			}
			else
			{
				if (!obj.IsObject)
				{
					return;
				}
				writer.WriteObjectStart();
				foreach (DictionaryEntry item2 in (IDictionary)obj)
				{
					writer.WritePropertyName((string)item2.Key);
					WriteJson((JsonData)item2.Value, writer);
				}
				writer.WriteObjectEnd();
			}
		}

		public int Add(object value)
		{
			JsonData value2 = ToJsonData(value);
			json = null;
			return EnsureList().Add(value2);
		}

		public void Clear()
		{
			if (IsObject)
			{
				((IDictionary)this).Clear();
			}
			else if (IsArray)
			{
				((IList)this).Clear();
			}
		}

		public bool Equals(JsonData x)
		{
			if (x == null)
			{
				return false;
			}
			if (x.type != type)
			{
				return false;
			}
			return type switch
			{
				JsonType.None => true, 
				JsonType.Object => inst_object.Equals(x.inst_object), 
				JsonType.Array => inst_array.Equals(x.inst_array), 
				JsonType.String => inst_string.Equals(x.inst_string), 
				JsonType.Int => inst_int.Equals(x.inst_int), 
				JsonType.Long => inst_long.Equals(x.inst_long), 
				JsonType.Double => inst_double.Equals(x.inst_double), 
				JsonType.Single => inst_single.Equals(x.inst_single), 
				JsonType.Boolean => inst_boolean.Equals(x.inst_boolean), 
				_ => false, 
			};
		}

		public JsonType GetJsonType()
		{
			return type;
		}

		public void SetJsonType(JsonType type)
		{
			if (this.type != type)
			{
				switch (type)
				{
				case JsonType.Object:
					inst_object = new Dictionary<string, JsonData>();
					object_list = new List<KeyValuePair<string, JsonData>>();
					break;
				case JsonType.Array:
					inst_array = new List<JsonData>();
					break;
				case JsonType.String:
					inst_string = null;
					break;
				case JsonType.Int:
					inst_int = 0;
					break;
				case JsonType.Long:
					inst_long = 0L;
					break;
				case JsonType.Double:
					inst_double = 0.0;
					break;
				case JsonType.Single:
					inst_single = 0f;
					break;
				case JsonType.Boolean:
					inst_boolean = false;
					break;
				}
				this.type = type;
			}
		}

		public string ToJson()
		{
			if (json != null)
			{
				return json;
			}
			StringWriter stringWriter = new StringWriter();
			JsonWriter jsonWriter = new JsonWriter(stringWriter);
			jsonWriter.Validate = false;
			WriteJson(this, jsonWriter);
			json = stringWriter.ToString();
			return json;
		}

		public void ToJson(JsonWriter writer)
		{
			bool validate = writer.Validate;
			writer.Validate = false;
			WriteJson(this, writer);
			writer.Validate = validate;
		}

		public override string ToString()
		{
			return type switch
			{
				JsonType.Array => "JsonData array", 
				JsonType.Boolean => inst_boolean.ToString(), 
				JsonType.Double => inst_double.ToString(), 
				JsonType.Single => inst_single.ToString(), 
				JsonType.Int => inst_int.ToString(), 
				JsonType.Long => inst_long.ToString(), 
				JsonType.Object => "JsonData object", 
				JsonType.String => inst_string, 
				_ => "Uninitialized JsonData", 
			};
		}
	}
	internal class OrderedDictionaryEnumerator : IDictionaryEnumerator, IEnumerator
	{
		private IEnumerator<KeyValuePair<string, JsonData>> list_enumerator;

		public object Current => Entry;

		public DictionaryEntry Entry
		{
			get
			{
				KeyValuePair<string, JsonData> current = list_enumerator.Current;
				return new DictionaryEntry(current.Key, current.Value);
			}
		}

		public object Key => list_enumerator.Current.Key;

		public object Value => list_enumerator.Current.Value;

		public OrderedDictionaryEnumerator(IEnumerator<KeyValuePair<string, JsonData>> enumerator)
		{
			list_enumerator = enumerator;
		}

		public bool MoveNext()
		{
			return list_enumerator.MoveNext();
		}

		public void Reset()
		{
			list_enumerator.Reset();
		}
	}
	public class JsonException : ApplicationException
	{
		public JsonException()
		{
		}

		internal JsonException(ParserToken token)
			: base($"Invalid token '{token}' in input string")
		{
		}

		internal JsonException(ParserToken token, Exception inner_exception)
			: base($"Invalid token '{token}' in input string", inner_exception)
		{
		}

		internal JsonException(int c)
			: base($"Invalid character '{(char)c}' in input string")
		{
		}

		internal JsonException(int c, Exception inner_exception)
			: base($"Invalid character '{(char)c}' in input string", inner_exception)
		{
		}

		public JsonException(string message)
			: base(message)
		{
		}

		public JsonException(string message, Exception inner_exception)
			: base(message, inner_exception)
		{
		}
	}
	internal struct PropertyMetadata
	{
		public MemberInfo Info;

		public bool IsField;

		public Type Type;
	}
	internal struct ArrayMetadata
	{
		private Type element_type;

		private bool is_array;

		private bool is_list;

		public Type ElementType
		{
			get
			{
				if (element_type == null)
				{
					return typeof(JsonData);
				}
				return element_type;
			}
			set
			{
				element_type = value;
			}
		}

		public bool IsArray
		{
			get
			{
				return is_array;
			}
			set
			{
				is_array = value;
			}
		}

		public bool IsList
		{
			get
			{
				return is_list;
			}
			set
			{
				is_list = value;
			}
		}
	}
	internal struct ObjectMetadata
	{
		private Type element_type;

		private bool is_dictionary;

		private IDictionary<string, PropertyMetadata> properties;

		public Type ElementType
		{
			get
			{
				if (element_type == null)
				{
					return typeof(JsonData);
				}
				return element_type;
			}
			set
			{
				element_type = value;
			}
		}

		public bool IsDictionary
		{
			get
			{
				return is_dictionary;
			}
			set
			{
				is_dictionary = value;
			}
		}

		public IDictionary<string, PropertyMetadata> Properties
		{
			get
			{
				return properties;
			}
			set
			{
				properties = value;
			}
		}
	}
	internal delegate void ExporterFunc(object obj, JsonWriter writer);
	public delegate void ExporterFunc<T>(T obj, JsonWriter writer);
	internal delegate object ImporterFunc(object input);
	public delegate TValue ImporterFunc<TJson, TValue>(TJson input);
	public delegate IJsonWrapper WrapperFactory();
	public class JsonMapper
	{
		private static int max_nesting_depth;

		private static IFormatProvider datetime_format;

		private static IDictionary<Type, ExporterFunc> base_exporters_table;

		private static IDictionary<Type, ExporterFunc> custom_exporters_table;

		private static IDictionary<Type, IDictionary<Type, ImporterFunc>> base_importers_table;

		private static IDictionary<Type, IDictionary<Type, ImporterFunc>> custom_importers_table;

		private static IDictionary<Type, ArrayMetadata> array_metadata;

		private static readonly object array_metadata_lock;

		private static IDictionary<Type, IDictionary<Type, MethodInfo>> conv_ops;

		private static readonly object conv_ops_lock;

		private static IDictionary<Type, ObjectMetadata> object_metadata;

		private static readonly object object_metadata_lock;

		private static IDictionary<Type, IList<PropertyMetadata>> type_properties;

		private static readonly object type_properties_lock;

		private static JsonWriter static_writer;

		private static readonly object static_writer_lock;

		static JsonMapper()
		{
			array_metadata_lock = new object();
			conv_ops_lock = new object();
			object_metadata_lock = new object();
			type_properties_lock = new object();
			static_writer_lock = new object();
			max_nesting_depth = 100;
			array_metadata = new Dictionary<Type, ArrayMetadata>();
			conv_ops = new Dictionary<Type, IDictionary<Type, MethodInfo>>();
			object_metadata = new Dictionary<Type, ObjectMetadata>();
			type_properties = new Dictionary<Type, IList<PropertyMetadata>>();
			static_writer = new JsonWriter();
			datetime_format = DateTimeFormatInfo.InvariantInfo;
			base_exporters_table = new Dictionary<Type, ExporterFunc>();
			custom_exporters_table = new Dictionary<Type, ExporterFunc>();
			base_importers_table = new Dictionary<Type, IDictionary<Type, ImporterFunc>>();
			custom_importers_table = new Dictionary<Type, IDictionary<Type, ImporterFunc>>();
			RegisterBaseExporters();
			RegisterBaseImporters();
		}

		private static void AddArrayMetadata(Type type)
		{
			if (array_metadata.ContainsKey(type))
			{
				return;
			}
			ArrayMetadata value = default(ArrayMetadata);
			value.IsArray = type.IsArray;
			if (type.GetInterface("System.Collections.IList") != null)
			{
				value.IsList = true;
			}
			PropertyInfo[] properties = type.GetProperties();
			foreach (PropertyInfo propertyInfo in properties)
			{
				if (!(propertyInfo.Name != "Item"))
				{
					ParameterInfo[] indexParameters = propertyInfo.GetIndexParameters();
					if (indexParameters.Length == 1 && indexParameters[0].ParameterType == typeof(int))
					{
						value.ElementType = propertyInfo.PropertyType;
					}
				}
			}
			lock (array_metadata_lock)
			{
				try
				{
					array_metadata.Add(type, value);
				}
				catch (ArgumentException)
				{
				}
			}
		}

		private static void AddObjectMetadata(Type type)
		{
			if (object_metadata.ContainsKey(type))
			{
				return;
			}
			ObjectMetadata value = default(ObjectMetadata);
			if (type.GetInterface("System.Collections.IDictionary") != null)
			{
				value.IsDictionary = true;
			}
			value.Properties = new Dictionary<string, PropertyMetadata>();
			PropertyInfo[] properties = type.GetProperties();
			foreach (PropertyInfo propertyInfo in properties)
			{
				if (propertyInfo.Name == "Item")
				{
					ParameterInfo[] indexParameters = propertyInfo.GetIndexParameters();
					if (indexParameters.Length == 1 && indexParameters[0].ParameterType == typeof(string))
					{
						value.ElementType = propertyInfo.PropertyType;
					}
				}
				else
				{
					PropertyMetadata value2 = default(PropertyMetadata);
					value2.Info = propertyInfo;
					value2.Type = propertyInfo.PropertyType;
					value.Properties.Add(propertyInfo.Name, value2);
				}
			}
			FieldInfo[] fields = type.GetFields();
			foreach (FieldInfo fieldInfo in fields)
			{
				PropertyMetadata value3 = default(PropertyMetadata);
				value3.Info = fieldInfo;
				value3.IsField = true;
				value3.Type = fieldInfo.FieldType;
				value.Properties.Add(fieldInfo.Name, value3);
			}
			lock (object_metadata_lock)
			{
				try
				{
					object_metadata.Add(type, value);
				}
				catch (ArgumentException)
				{
				}
			}
		}

		private static void AddTypeProperties(Type type)
		{
			if (type_properties.ContainsKey(type))
			{
				return;
			}
			IList<PropertyMetadata> list = new List<PropertyMetadata>();
			PropertyInfo[] properties = type.GetProperties();
			foreach (PropertyInfo propertyInfo in properties)
			{
				if (!(propertyInfo.Name == "Item"))
				{
					PropertyMetadata item = default(PropertyMetadata);
					item.Info = propertyInfo;
					item.IsField = false;
					list.Add(item);
				}
			}
			FieldInfo[] fields = type.GetFields();
			foreach (FieldInfo info in fields)
			{
				PropertyMetadata item2 = default(PropertyMetadata);
				item2.Info = info;
				item2.IsField = true;
				list.Add(item2);
			}
			lock (type_properties_lock)
			{
				try
				{
					type_properties.Add(type, list);
				}
				catch (ArgumentException)
				{
				}
			}
		}

		private static MethodInfo GetConvOp(Type t1, Type t2)
		{
			lock (conv_ops_lock)
			{
				if (!conv_ops.ContainsKey(t1))
				{
					conv_ops.Add(t1, new Dictionary<Type, MethodInfo>());
				}
			}
			if (conv_ops[t1].ContainsKey(t2))
			{
				return conv_ops[t1][t2];
			}
			MethodInfo method = t1.GetMethod("op_Implicit", new Type[1] { t2 });
			lock (conv_ops_lock)
			{
				try
				{
					conv_ops[t1].Add(t2, method);
					return method;
				}
				catch (ArgumentException)
				{
					return conv_ops[t1][t2];
				}
			}
		}

		private static object ReadValue(Type inst_type, JsonReader reader)
		{
			reader.Read();
			if (reader.Token == JsonToken.ArrayEnd)
			{
				return null;
			}
			if (reader.Token == JsonToken.Null)
			{
				if (!inst_type.IsClass)
				{
					throw new JsonException($"Can't assign null to an instance of type {inst_type}");
				}
				return null;
			}
			if (reader.Token == JsonToken.Double || reader.Token == JsonToken.Single || reader.Token == JsonToken.Int || reader.Token == JsonToken.Long || reader.Token == JsonToken.String || reader.Token == JsonToken.Boolean)
			{
				Type type = reader.Value.GetType();
				if (inst_type.IsAssignableFrom(type))
				{
					return reader.Value;
				}
				if (custom_importers_table.ContainsKey(type) && custom_importers_table[type].ContainsKey(inst_type))
				{
					return custom_importers_table[type][inst_type](reader.Value);
				}
				if (base_importers_table.ContainsKey(type) && base_importers_table[type].ContainsKey(inst_type))
				{
					return base_importers_table[type][inst_type](reader.Value);
				}
				if (inst_type.IsEnum)
				{
					return Enum.ToObject(inst_type, reader.Value);
				}
				MethodInfo convOp = GetConvOp(inst_type, type);
				if (convOp != null)
				{
					return convOp.Invoke(null, new object[1] { reader.Value });
				}
				throw new JsonException($"Can't assign value '{reader.Value}' (type {type}) to type {inst_type}");
			}
			object obj = null;
			if (reader.Token == JsonToken.ArrayStart)
			{
				AddArrayMetadata(inst_type);
				ArrayMetadata arrayMetadata = array_metadata[inst_type];
				if (!arrayMetadata.IsArray && !arrayMetadata.IsList)
				{
					throw new JsonException($"Type {inst_type} can't act as an array");
				}
				IList list;
				Type elementType;
				if (!arrayMetadata.IsArray)
				{
					list = (IList)Activator.CreateInstance(inst_type);
					elementType = arrayMetadata.ElementType;
				}
				else
				{
					list = new ArrayList();
					elementType = inst_type.GetElementType();
				}
				while (true)
				{
					object obj2 = ReadValue(elementType, reader);
					if (obj2 == null && reader.Token == JsonToken.ArrayEnd)
					{
						break;
					}
					list.Add(obj2);
				}
				if (arrayMetadata.IsArray)
				{
					int count = list.Count;
					obj = Array.CreateInstance(elementType, count);
					for (int i = 0; i < count; i++)
					{
						((Array)obj).SetValue(list[i], i);
					}
				}
				else
				{
					obj = list;
				}
			}
			else if (reader.Token == JsonToken.ObjectStart)
			{
				AddObjectMetadata(inst_type);
				ObjectMetadata objectMetadata = object_metadata[inst_type];
				obj = Activator.CreateInstance(inst_type);
				while (true)
				{
					reader.Read();
					if (reader.Token == JsonToken.ObjectEnd)
					{
						break;
					}
					string text = (string)reader.Value;
					if (objectMetadata.Properties.ContainsKey(text))
					{
						PropertyMetadata propertyMetadata = objectMetadata.Properties[text];
						if (propertyMetadata.IsField)
						{
							((FieldInfo)propertyMetadata.Info).SetValue(obj, ReadValue(propertyMetadata.Type, reader));
							continue;
						}
						PropertyInfo propertyInfo = (PropertyInfo)propertyMetadata.Info;
						if (propertyInfo.CanWrite)
						{
							propertyInfo.SetValue(obj, ReadValue(propertyMetadata.Type, reader), null);
						}
						else
						{
							ReadValue(propertyMetadata.Type, reader);
						}
					}
					else if (!objectMetadata.IsDictionary)
					{
						if (!reader.SkipNonMembers)
						{
							throw new JsonException($"The type {inst_type} doesn't have the property '{text}'");
						}
						ReadSkip(reader);
					}
					else
					{
						((IDictionary)obj).Add(text, ReadValue(objectMetadata.ElementType, reader));
					}
				}
			}
			return obj;
		}

		private static IJsonWrapper ReadValue(WrapperFactory factory, JsonReader reader)
		{
			reader.Read();
			if (reader.Token == JsonToken.ArrayEnd || reader.Token == JsonToken.Null)
			{
				return null;
			}
			IJsonWrapper jsonWrapper = factory();
			if (reader.Token == JsonToken.String)
			{
				jsonWrapper.SetString((string)reader.Value);
				return jsonWrapper;
			}
			if (reader.Token == JsonToken.Double)
			{
				jsonWrapper.SetDouble((double)reader.Value);
				return jsonWrapper;
			}
			if (reader.Token == JsonToken.Single)
			{
				jsonWrapper.SetSingle((float)reader.Value);
				return jsonWrapper;
			}
			if (reader.Token == JsonToken.Int)
			{
				jsonWrapper.SetInt((int)reader.Value);
				return jsonWrapper;
			}
			if (reader.Token == JsonToken.Long)
			{
				jsonWrapper.SetLong((long)reader.Value);
				return jsonWrapper;
			}
			if (reader.Token == JsonToken.Boolean)
			{
				jsonWrapper.SetBoolean((bool)reader.Value);
				return jsonWrapper;
			}
			if (reader.Token == JsonToken.ArrayStart)
			{
				jsonWrapper.SetJsonType(JsonType.Array);
				while (true)
				{
					IJsonWrapper jsonWrapper2 = ReadValue(factory, reader);
					if (jsonWrapper2 == null && reader.Token == JsonToken.ArrayEnd)
					{
						break;
					}
					jsonWrapper.Add(jsonWrapper2);
				}
			}
			else if (reader.Token == JsonToken.ObjectStart)
			{
				jsonWrapper.SetJsonType(JsonType.Object);
				while (true)
				{
					reader.Read();
					if (reader.Token == JsonToken.ObjectEnd)
					{
						break;
					}
					string key = (string)reader.Value;
					jsonWrapper[key] = ReadValue(factory, reader);
				}
			}
			return jsonWrapper;
		}

		private static void ReadSkip(JsonReader reader)
		{
			ToWrapper(() => new JsonMockWrapper(), reader);
		}

		private static void RegisterBaseExporters()
		{
			base_exporters_table[typeof(byte)] = delegate(object obj, JsonWriter writer)
			{
				writer.Write(Convert.ToInt32((byte)obj));
			};
			base_exporters_table[typeof(char)] = delegate(object obj, JsonWriter writer)
			{
				writer.Write(Convert.ToString((char)obj));
			};
			base_exporters_table[typeof(DateTime)] = delegate(object obj, JsonWriter writer)
			{
				writer.Write(Convert.ToString((DateTime)obj, datetime_format));
			};
			base_exporters_table[typeof(decimal)] = delegate(object obj, JsonWriter writer)
			{
				writer.Write((decimal)obj);
			};
			base_exporters_table[typeof(sbyte)] = delegate(object obj, JsonWriter writer)
			{
				writer.Write(Convert.ToInt32((sbyte)obj));
			};
			base_exporters_table[typeof(short)] = delegate(object obj, JsonWriter writer)
			{
				writer.Write(Convert.ToInt32((short)obj));
			};
			base_exporters_table[typeof(ushort)] = delegate(object obj, JsonWriter writer)
			{
				writer.Write(Convert.ToInt32((ushort)obj));
			};
			base_exporters_table[typeof(uint)] = delegate(object obj, JsonWriter writer)
			{
				writer.Write(Convert.ToUInt64((uint)obj));
			};
			base_exporters_table[typeof(ulong)] = delegate(object obj, JsonWriter writer)
			{
				writer.Write((ulong)obj);
			};
		}

		private static void RegisterBaseImporters()
		{
			ImporterFunc importer = (object input) => Convert.ToByte((int)input);
			RegisterImporter(base_importers_table, typeof(int), typeof(byte), importer);
			importer = (object input) => Convert.ToUInt64((int)input);
			RegisterImporter(base_importers_table, typeof(int), typeof(ulong), importer);
			importer = (object input) => Convert.ToSByte((int)input);
			RegisterImporter(base_importers_table, typeof(int), typeof(sbyte), importer);
			importer = (object input) => Convert.ToInt16((int)input);
			RegisterImporter(base_importers_table, typeof(int), typeof(short), importer);
			importer = (object input) => Convert.ToUInt16((int)input);
			RegisterImporter(base_importers_table, typeof(int), typeof(ushort), importer);
			importer = (object input) => Convert.ToUInt32((int)input);
			RegisterImporter(base_importers_table, typeof(int), typeof(uint), importer);
			importer = (object input) => Convert.ToSingle((int)input);
			RegisterImporter(base_importers_table, typeof(int), typeof(float), importer);
			importer = (object input) => Convert.ToDouble((int)input);
			RegisterImporter(base_importers_table, typeof(int), typeof(double), importer);
			importer = (object input) => Convert.ToDecimal((double)input);
			RegisterImporter(base_importers_table, typeof(double), typeof(decimal), importer);
			importer = (object input) => Convert.ToUInt32((long)input);
			RegisterImporter(base_importers_table, typeof(long), typeof(uint), importer);
			importer = (object input) => Convert.ToChar((string)input);
			RegisterImporter(base_importers_table, typeof(string), typeof(char), importer);
			importer = (object input) => Convert.ToDateTime((string)input, datetime_format);
			RegisterImporter(base_importers_table, typeof(string), typeof(DateTime), importer);
			RegisterImporter(base_importers_table, typeof(double), typeof(float), (object input) => Convert.ToSingle((double)input));
			RegisterImporter(base_importers_table, typeof(float), typeof(double), (object input) => Convert.ToDouble((float)input));
		}

		private static void RegisterImporter(IDictionary<Type, IDictionary<Type, ImporterFunc>> table, Type json_type, Type value_type, ImporterFunc importer)
		{
			if (!table.ContainsKey(json_type))
			{
				table.Add(json_type, new Dictionary<Type, ImporterFunc>());
			}
			table[json_type][value_type] = importer;
		}

		private static void WriteValue(object obj, JsonWriter writer, bool writer_is_private, int depth)
		{
			if (depth > max_nesting_depth)
			{
				throw new JsonException($"Max allowed object depth reached while trying to export from type {obj.GetType()}");
			}
			if (obj == null)
			{
				writer.Write(null);
				return;
			}
			if (obj is IJsonWrapper)
			{
				if (writer_is_private)
				{
					writer.TextWriter.Write(((IJsonWrapper)obj).ToJson());
				}
				else
				{
					((IJsonWrapper)obj).ToJson(writer);
				}
				return;
			}
			if (obj is string)
			{
				writer.Write((string)obj);
				return;
			}
			if (obj is double)
			{
				writer.Write((double)obj);
				return;
			}
			if (obj is float)
			{
				writer.Write((float)obj);
				return;
			}
			if (obj is int)
			{
				writer.Write((int)obj);
				return;
			}
			if (obj is bool)
			{
				writer.Write((bool)obj);
				return;
			}
			if (obj is long)
			{
				writer.Write((long)obj);
				return;
			}
			if (obj is Array)
			{
				writer.WriteArrayStart();
				foreach (object item in (Array)obj)
				{
					WriteValue(item, writer, writer_is_private, depth + 1);
				}
				writer.WriteArrayEnd();
				return;
			}
			if (obj is IList)
			{
				writer.WriteArrayStart();
				foreach (object item2 in (IList)obj)
				{
					WriteValue(item2, writer, writer_is_private, depth + 1);
				}
				writer.WriteArrayEnd();
				return;
			}
			if (obj is IDictionary)
			{
				writer.WriteObjectStart();
				foreach (DictionaryEntry item3 in (IDictionary)obj)
				{
					writer.WritePropertyName((string)item3.Key);
					WriteValue(item3.Value, writer, writer_is_private, depth + 1);
				}
				writer.WriteObjectEnd();
				return;
			}
			Type type = obj.GetType();
			if (custom_exporters_table.ContainsKey(type))
			{
				custom_exporters_table[type](obj, writer);
				return;
			}
			if (base_exporters_table.ContainsKey(type))
			{
				base_exporters_table[type](obj, writer);
				return;
			}
			if (obj is Enum)
			{
				Type underlyingType = Enum.GetUnderlyingType(type);
				if (underlyingType == typeof(long) || underlyingType == typeof(uint) || underlyingType == typeof(ulong))
				{
					writer.Write((ulong)obj);
				}
				else
				{
					writer.Write((int)obj);
				}
				return;
			}
			AddTypeProperties(type);
			IList<PropertyMetadata> list = type_properties[type];
			writer.WriteObjectStart();
			foreach (PropertyMetadata item4 in list)
			{
				if (item4.IsField)
				{
					writer.WritePropertyName(item4.Info.Name);
					WriteValue(((FieldInfo)item4.Info).GetValue(obj), writer, writer_is_private, depth + 1);
					continue;
				}
				PropertyInfo propertyInfo = (PropertyInfo)item4.Info;
				if (propertyInfo.CanRead)
				{
					writer.WritePropertyName(item4.Info.Name);
					WriteValue(propertyInfo.GetGetMethod().Invoke(obj, null), writer, writer_is_private, depth + 1);
				}
			}
			writer.WriteObjectEnd();
		}

		public static string ToJson(object obj)
		{
			lock (static_writer_lock)
			{
				static_writer.Reset();
				WriteValue(obj, static_writer, writer_is_private: true, 0);
				return static_writer.ToString();
			}
		}

		public static void ToJson(object obj, JsonWriter writer)
		{
			WriteValue(obj, writer, writer_is_private: false, 0);
		}

		public static JsonData ToObject(JsonReader reader)
		{
			return (JsonData)ToWrapper(() => new JsonData(), reader);
		}

		public static JsonData ToObject(TextReader reader)
		{
			JsonReader reader2 = new JsonReader(reader);
			return (JsonData)ToWrapper(() => new JsonData(), reader2);
		}

		public static JsonData ToObject(string json)
		{
			return (JsonData)ToWrapper(() => new JsonData(), json);
		}

		public static T ToObject<T>(JsonReader reader)
		{
			return (T)ReadValue(typeof(T), reader);
		}

		public static T ToObject<T>(TextReader reader)
		{
			JsonReader reader2 = new JsonReader(reader);
			return (T)ReadValue(typeof(T), reader2);
		}

		public static T ToObject<T>(string json)
		{
			JsonReader reader = new JsonReader(json);
			return (T)ReadValue(typeof(T), reader);
		}

		public static IJsonWrapper ToWrapper(WrapperFactory factory, JsonReader reader)
		{
			return ReadValue(factory, reader);
		}

		public static IJsonWrapper ToWrapper(WrapperFactory factory, string json)
		{
			JsonReader reader = new JsonReader(json);
			return ReadValue(factory, reader);
		}

		public static void RegisterExporter<T>(ExporterFunc<T> exporter)
		{
			ExporterFunc value = delegate(object obj, JsonWriter writer)
			{
				exporter((T)obj, writer);
			};
			custom_exporters_table[typeof(T)] = value;
		}

		public static void RegisterImporter<TJson, TValue>(ImporterFunc<TJson, TValue> importer)
		{
			ImporterFunc importer2 = (object input) => importer((TJson)input);
			RegisterImporter(custom_importers_table, typeof(TJson), typeof(TValue), importer2);
		}

		public static void UnregisterExporters()
		{
			custom_exporters_table.Clear();
		}

		public static void UnregisterImporters()
		{
			custom_importers_table.Clear();
		}
	}
	public class JsonMockWrapper : IJsonWrapper, IList, ICollection, IEnumerable, IOrderedDictionary, IDictionary
	{
		public bool IsArray => false;

		public bool IsBoolean => false;

		public bool IsDouble => false;

		public bool IsSingle => false;

		public bool IsInt => false;

		public bool IsLong => false;

		public bool IsObject => false;

		public bool IsString => false;

		bool IList.IsFixedSize => true;

		bool IList.IsReadOnly => true;

		object IList.this[int index]
		{
			get
			{
				return null;
			}
			set
			{
			}
		}

		int ICollection.Count => 0;

		bool ICollection.IsSynchronized => false;

		object ICollection.SyncRoot => null;

		bool IDictionary.IsFixedSize => true;

		bool IDictionary.IsReadOnly => true;

		ICollection IDictionary.Keys => null;

		ICollection IDictionary.Values => null;

		object IDictionary.this[object key]
		{
			get
			{
				return null;
			}
			set
			{
			}
		}

		object IOrderedDictionary.this[int idx]
		{
			get
			{
				return null;
			}
			set
			{
			}
		}

		public bool GetBoolean()
		{
			return false;
		}

		public double GetDouble()
		{
			return 0.0;
		}

		public float GetSingle()
		{
			return 0f;
		}

		public int GetInt()
		{
			return 0;
		}

		public JsonType GetJsonType()
		{
			return JsonType.None;
		}

		public long GetLong()
		{
			return 0L;
		}

		public string GetString()
		{
			return "";
		}

		public void SetBoolean(bool val)
		{
		}

		public void SetDouble(double val)
		{
		}

		public void SetSingle(float val)
		{
		}

		public void SetInt(int val)
		{
		}

		public void SetJsonType(JsonType type)
		{
		}

		public void SetLong(long val)
		{
		}

		public void SetString(string val)
		{
		}

		public string ToJson()
		{
			return "";
		}

		public void ToJson(JsonWriter writer)
		{
		}

		int IList.Add(object value)
		{
			return 0;
		}

		void IList.Clear()
		{
		}

		bool IList.Contains(object value)
		{
			return false;
		}

		int IList.IndexOf(object value)
		{
			return -1;
		}

		void IList.Insert(int i, object v)
		{
		}

		void IList.Remove(object value)
		{
		}

		void IList.RemoveAt(int index)
		{
		}

		void ICollection.CopyTo(Array array, int index)
		{
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return null;
		}

		void IDictionary.Add(object k, object v)
		{
		}

		void IDictionary.Clear()
		{
		}

		bool IDictionary.Contains(object key)
		{
			return false;
		}

		void IDictionary.Remove(object key)
		{
		}

		IDictionaryEnumerator IDictionary.GetEnumerator()
		{
			return null;
		}

		IDictionaryEnumerator IOrderedDictionary.GetEnumerator()
		{
			return null;
		}

		void IOrderedDictionary.Insert(int i, object k, object v)
		{
		}

		void IOrderedDictionary.RemoveAt(int i)
		{
		}
	}
	public enum JsonToken
	{
		None,
		ObjectStart,
		PropertyName,
		ObjectEnd,
		ArrayStart,
		ArrayEnd,
		Int,
		Long,
		Double,
		Single,
		String,
		Boolean,
		Null
	}
	public class JsonReader
	{
		private static IDictionary<int, IDictionary<int, int[]>> parse_table;

		private Stack<int> automaton_stack;

		private int current_input;

		private int current_symbol;

		private bool end_of_json;

		private bool end_of_input;

		private Lexer lexer;

		private bool parser_in_string;

		private bool parser_return;

		private bool read_started;

		private TextReader reader;

		private bool reader_is_owned;

		private bool skip_non_members;

		private object token_value;

		private JsonToken token;

		public bool AllowComments
		{
			get
			{
				return lexer.AllowComments;
			}
			set
			{
				lexer.AllowComments = value;
			}
		}

		public bool AllowSingleQuotedStrings
		{
			get
			{
				return lexer.AllowSingleQuotedStrings;
			}
			set
			{
				lexer.AllowSingleQuotedStrings = value;
			}
		}

		public bool SkipNonMembers
		{
			get
			{
				return skip_non_members;
			}
			set
			{
				skip_non_members = value;
			}
		}

		public bool EndOfInput => end_of_input;

		public bool EndOfJson => end_of_json;

		public JsonToken Token => token;

		public object Value => token_value;

		static JsonReader()
		{
			PopulateParseTable();
		}

		public JsonReader(string json_text)
			: this(new StringReader(json_text), owned: true)
		{
		}

		public JsonReader(TextReader reader)
			: this(reader, owned: false)
		{
		}

		private JsonReader(TextReader reader, bool owned)
		{
			if (reader == null)
			{
				throw new ArgumentNullException("reader");
			}
			parser_in_string = false;
			parser_return = false;
			read_started = false;
			automaton_stack = new Stack<int>();
			automaton_stack.Push(65553);
			automaton_stack.Push(65543);
			lexer = new Lexer(reader);
			end_of_input = false;
			end_of_json = false;
			skip_non_members = true;
			this.reader = reader;
			reader_is_owned = owned;
		}

		private static void PopulateParseTable()
		{
			parse_table = new Dictionary<int, IDictionary<int, int[]>>();
			TableAddRow(ParserToken.Array);
			TableAddCol(ParserToken.Array, 91, 91, 65549);
			TableAddRow(ParserToken.ArrayPrime);
			TableAddCol(ParserToken.ArrayPrime, 34, 65550, 65551, 93);
			TableAddCol(ParserToken.ArrayPrime, 91, 65550, 65551, 93);
			TableAddCol(ParserToken.ArrayPrime, 93, 93);
			TableAddCol(ParserToken.ArrayPrime, 123, 65550, 65551, 93);
			TableAddCol(ParserToken.ArrayPrime, 65537, 65550, 65551, 93);
			TableAddCol(ParserToken.ArrayPrime, 65538, 65550, 65551, 93);
			TableAddCol(ParserToken.ArrayPrime, 65539, 65550, 65551, 93);
			TableAddCol(ParserToken.ArrayPrime, 65540, 65550, 65551, 93);
			TableAddRow(ParserToken.Object);
			TableAddCol(ParserToken.Object, 123, 123, 65545);
			TableAddRow(ParserToken.ObjectPrime);
			TableAddCol(ParserToken.ObjectPrime, 34, 65546, 65547, 125);
			TableAddCol(ParserToken.ObjectPrime, 125, 125);
			TableAddRow(ParserToken.Pair);
			TableAddCol(ParserToken.Pair, 34, 65552, 58, 65550);
			TableAddRow(ParserToken.PairRest);
			TableAddCol(ParserToken.PairRest, 44, 44, 65546, 65547);
			TableAddCol(ParserToken.PairRest, 125, 65554);
			TableAddRow(ParserToken.String);
			TableAddCol(ParserToken.String, 34, 34, 65541, 34);
			TableAddRow(ParserToken.Text);
			TableAddCol(ParserToken.Text, 91, 65548);
			TableAddCol(ParserToken.Text, 123, 65544);
			TableAddRow(ParserToken.Value);
			TableAddCol(ParserToken.Value, 34, 65552);
			TableAddCol(ParserToken.Value, 91, 65548);
			TableAddCol(ParserToken.Value, 123, 65544);
			TableAddCol(ParserToken.Value, 65537, 65537);
			TableAddCol(ParserToken.Value, 65538, 65538);
			TableAddCol(ParserToken.Value, 65539, 65539);
			TableAddCol(ParserToken.Value, 65540, 65540);
			TableAddRow(ParserToken.ValueRest);
			TableAddCol(ParserToken.ValueRest, 44, 44, 65550, 65551);
			TableAddCol(ParserToken.ValueRest, 93, 65554);
		}

		private static void TableAddCol(ParserToken row, int col, params int[] symbols)
		{
			parse_table[(int)row].Add(col, symbols);
		}

		private static void TableAddRow(ParserToken rule)
		{
			parse_table.Add((int)rule, new Dictionary<int, int[]>());
		}

		private void ProcessNumber(string number)
		{
			int result2;
			long result3;
			if ((number.IndexOf('.') != -1 || number.IndexOf('e') != -1 || number.IndexOf('E') != -1) && double.TryParse(number, out var result))
			{
				token = JsonToken.Double;
				token_value = result;
			}
			else if (int.TryParse(number, out result2))
			{
				token = JsonToken.Int;
				token_value = result2;
			}
			else if (long.TryParse(number, out result3))
			{
				token = JsonToken.Long;
				token_value = result3;
			}
			else
			{
				token = JsonToken.Int;
				token_value = 0;
			}
		}

		private void ProcessSymbol()
		{
			if (current_symbol == 91)
			{
				token = JsonToken.ArrayStart;
				parser_return = true;
			}
			else if (current_symbol == 93)
			{
				token = JsonToken.ArrayEnd;
				parser_return = true;
			}
			else if (current_symbol == 123)
			{
				token = JsonToken.ObjectStart;
				parser_return = true;
			}
			else if (current_symbol == 125)
			{
				token = JsonToken.ObjectEnd;
				parser_return = true;
			}
			else if (current_symbol == 34)
			{
				if (parser_in_string)
				{
					parser_in_string = false;
					parser_return = true;
					return;
				}
				if (token == JsonToken.None)
				{
					token = JsonToken.String;
				}
				parser_in_string = true;
			}
			else if (current_symbol == 65541)
			{
				token_value = lexer.StringValue;
			}
			else if (current_symbol == 65539)
			{
				token = JsonToken.Boolean;
				token_value = false;
				parser_return = true;
			}
			else if (current_symbol == 65540)
			{
				token = JsonToken.Null;
				parser_return = true;
			}
			else if (current_symbol == 65537)
			{
				ProcessNumber(lexer.StringValue);
				parser_return = true;
			}
			else if (current_symbol == 65546)
			{
				token = JsonToken.PropertyName;
			}
			else if (current_symbol == 65538)
			{
				token = JsonToken.Boolean;
				token_value = true;
				parser_return = true;
			}
		}

		private bool ReadToken()
		{
			if (end_of_input)
			{
				return false;
			}
			lexer.NextToken();
			if (lexer.EndOfInput)
			{
				Close();
				return false;
			}
			current_input = lexer.Token;
			return true;
		}

		public void Close()
		{
			if (!end_of_input)
			{
				end_of_input = true;
				end_of_json = true;
				if (reader_is_owned)
				{
					reader.Close();
				}
				reader = null;
			}
		}

		public bool Read()
		{
			if (end_of_input)
			{
				return false;
			}
			if (end_of_json)
			{
				end_of_json = false;
				automaton_stack.Clear();
				automaton_stack.Push(65553);
				automaton_stack.Push(65543);
			}
			parser_in_string = false;
			parser_return = false;
			token = JsonToken.None;
			token_value = null;
			if (!read_started)
			{
				read_started = true;
				if (!ReadToken())
				{
					return false;
				}
			}
			while (true)
			{
				if (parser_return)
				{
					if (automaton_stack.Peek() == 65553)
					{
						end_of_json = true;
					}
					return true;
				}
				current_symbol = automaton_stack.Pop();
				ProcessSymbol();
				if (current_symbol == current_input)
				{
					if (!ReadToken())
					{
						break;
					}
					continue;
				}
				int[] array;
				try
				{
					array = parse_table[current_symbol][current_input];
				}
				catch (KeyNotFoundException inner_exception)
				{
					throw new JsonException((ParserToken)current_input, inner_exception);
				}
				if (array[0] != 65554)
				{
					for (int num = array.Length - 1; num >= 0; num--)
					{
						automaton_stack.Push(array[num]);
					}
				}
			}
			if (automaton_stack.Peek() != 65553)
			{
				throw new JsonException("Input doesn't evaluate to proper JSON text");
			}
			if (parser_return)
			{
				return true;
			}
			return false;
		}
	}
	internal enum Condition
	{
		InArray,
		InObject,
		NotAProperty,
		Property,
		Value
	}
	internal class WriterContext
	{
		public int Count;

		public bool InArray;

		public bool InObject;

		public bool ExpectingValue;

		public int Padding;
	}
	public class JsonWriter
	{
		private static NumberFormatInfo number_format;

		private WriterContext context;

		private Stack<WriterContext> ctx_stack;

		private bool has_reached_end;

		private int indentation;

		private int indent_value;

		private StringBuilder inst_string_builder;

		private bool pretty_print;

		private bool validate;

		private TextWriter writer;

		public int IndentValue
		{
			get
			{
				return indent_value;
			}
			set
			{
				indentation = indentation / indent_value * value;
				indent_value = value;
			}
		}

		public bool PrettyPrint
		{
			get
			{
				return pretty_print;
			}
			set
			{
				pretty_print = value;
			}
		}

		public TextWriter TextWriter => writer;

		public bool Validate
		{
			get
			{
				return validate;
			}
			set
			{
				validate = value;
			}
		}

		static JsonWriter()
		{
			number_format = NumberFormatInfo.InvariantInfo;
		}

		public JsonWriter()
		{
			inst_string_builder = new StringBuilder();
			writer = new StringWriter(inst_string_builder);
			Init();
		}

		public JsonWriter(StringBuilder sb)
			: this(new StringWriter(sb))
		{
		}

		public JsonWriter(TextWriter writer)
		{
			if (writer == null)
			{
				throw new ArgumentNullException("writer");
			}
			this.writer = writer;
			Init();
		}

		private void DoValidation(Condition cond)
		{
			if (!context.ExpectingValue)
			{
				context.Count++;
			}
			if (!validate)
			{
				return;
			}
			if (has_reached_end)
			{
				throw new JsonException("A complete JSON symbol has already been written");
			}
			switch (cond)
			{
			case Condition.InArray:
				if (!context.InArray)
				{
					throw new JsonException("Can't close an array here");
				}
				break;
			case Condition.InObject:
				if (!context.InObject || context.ExpectingValue)
				{
					throw new JsonException("Can't close an object here");
				}
				break;
			case Condition.NotAProperty:
				if (context.InObject && !context.ExpectingValue)
				{
					throw new JsonException("Expected a property");
				}
				break;
			case Condition.Property:
				if (!context.InObject || context.ExpectingValue)
				{
					throw new JsonException("Can't add a property here");
				}
				break;
			case Condition.Value:
				if (!context.InArray && (!context.InObject || !context.ExpectingValue))
				{
					throw new JsonException("Can't add a value here");
				}
				break;
			}
		}

		private void Init()
		{
			has_reached_end = false;
			indentation = 0;
			indent_value = 4;
			pretty_print = false;
			validate = true;
			ctx_stack = new Stack<WriterContext>();
			context = new WriterContext();
			ctx_stack.Push(context);
		}

		private static void IntToHex(int n, char[] hex)
		{
			for (int i = 0; i < 4; i++)
			{
				int num = n % 16;
				if (num < 10)
				{
					hex[3 - i] = (char)(48 + num);
				}
				else
				{
					hex[3 - i] = (char)(65 + (num - 10));
				}
				n >>= 4;
			}
		}

		private void Indent()
		{
			if (pretty_print)
			{
				indentation += indent_value;
			}
		}

		private void Put(string str)
		{
			if (pretty_print && !context.ExpectingValue)
			{
				for (int i = 0; i < indentation; i++)
				{
					writer.Write(' ');
				}
			}
			writer.Write(str);
		}

		private void PutNewline()
		{
			PutNewline(add_comma: true);
		}

		private void PutNewline(bool add_comma)
		{
			if (add_comma && !context.ExpectingValue && context.Count > 1)
			{
				writer.Write(',');
			}
			if (pretty_print && !context.ExpectingValue)
			{
				writer.Write('\n');
			}
		}

		private void PutString(string str)
		{
			Put(string.Empty);
			writer.Write('"');
			int length = str.Length;
			for (int i = 0; i < length; i++)
			{
				switch (str[i])
				{
				case '\n':
					writer.Write("\\n");
					break;
				case '\r':
					writer.Write("\\r");
					break;
				case '\t':
					writer.Write("\\t");
					break;
				case '"':
				case '\\':
					writer.Write('\\');
					writer.Write(str[i]);
					break;
				case '\f':
					writer.Write("\\f");
					break;
				case '\b':
					writer.Write("\\b");
					break;
				default:
					writer.Write(str[i]);
					break;
				}
			}
			writer.Write('"');
		}

		private void Unindent()
		{
			if (pretty_print)
			{
				indentation -= indent_value;
			}
		}

		public override string ToString()
		{
			if (inst_string_builder == null)
			{
				return string.Empty;
			}
			return inst_string_builder.ToString();
		}

		public void Reset()
		{
			has_reached_end = false;
			ctx_stack.Clear();
			context = new WriterContext();
			ctx_stack.Push(context);
			if (inst_string_builder != null)
			{
				inst_string_builder.Remove(0, inst_string_builder.Length);
			}
		}

		public void Write(bool boolean)
		{
			DoValidation(Condition.Value);
			PutNewline();
			Put(boolean ? "true" : "false");
			context.ExpectingValue = false;
		}

		public void Write(decimal number)
		{
			DoValidation(Condition.Value);
			PutNewline();
			Put(Convert.ToString(number, number_format));
			context.ExpectingValue = false;
		}

		public void Write(double number)
		{
			DoValidation(Condition.Value);
			PutNewline();
			string text = Convert.ToString(number, number_format);
			Put(text);
			if (text.IndexOf('.') == -1 && text.IndexOf('E') == -1)
			{
				writer.Write(".0");
			}
			context.ExpectingValue = false;
		}

		public void Write(float number)
		{
			DoValidation(Condition.Value);
			PutNewline();
			string text = Convert.ToString(number, number_format);
			Put(text);
			if (text.IndexOf('.') == -1 && text.IndexOf('E') == -1)
			{
				writer.Write(".0");
			}
			context.ExpectingValue = false;
		}

		public void Write(int number)
		{
			DoValidation(Condition.Value);
			PutNewline();
			Put(Convert.ToString(number, number_format));
			context.ExpectingValue = false;
		}

		public void Write(long number)
		{
			DoValidation(Condition.Value);
			PutNewline();
			Put(Convert.ToString(number, number_format));
			context.ExpectingValue = false;
		}

		public void Write(string str)
		{
			DoValidation(Condition.Value);
			PutNewline();
			if (str == null)
			{
				Put("null");
			}
			else
			{
				PutString(str);
			}
			context.ExpectingValue = false;
		}

		public void Write(ulong number)
		{
			DoValidation(Condition.Value);
			PutNewline();
			Put(Convert.ToString(number, number_format));
			context.ExpectingValue = false;
		}

		public void WriteArrayEnd()
		{
			DoValidation(Condition.InArray);
			PutNewline(add_comma: false);
			ctx_stack.Pop();
			if (ctx_stack.Count == 1)
			{
				has_reached_end = true;
			}
			else
			{
				context = ctx_stack.Peek();
				context.ExpectingValue = false;
			}
			Unindent();
			Put("]");
		}

		public void WriteArrayStart()
		{
			DoValidation(Condition.NotAProperty);
			PutNewline();
			Put("[");
			context = new WriterContext();
			context.InArray = true;
			ctx_stack.Push(context);
			Indent();
		}

		public void WriteObjectEnd()
		{
			DoValidation(Condition.InObject);
			PutNewline(add_comma: false);
			ctx_stack.Pop();
			if (ctx_stack.Count == 1)
			{
				has_reached_end = true;
			}
			else
			{
				context = ctx_stack.Peek();
				context.ExpectingValue = false;
			}
			Unindent();
			Put("}");
		}

		public void WriteObjectStart()
		{
			DoValidation(Condition.NotAProperty);
			PutNewline();
			Put("{");
			context = new WriterContext();
			context.InObject = true;
			ctx_stack.Push(context);
			Indent();
		}

		public void WritePropertyName(string property_name)
		{
			DoValidation(Condition.Property);
			PutNewline();
			PutString(property_name);
			if (pretty_print)
			{
				if (property_name.Length > context.Padding)
				{
					context.Padding = property_name.Length;
				}
				for (int num = context.Padding - property_name.Length; num >= 0; num--)
				{
					writer.Write(' ');
				}
				writer.Write(": ");
			}
			else
			{
				writer.Write(':');
			}
			context.ExpectingValue = true;
		}
	}
	internal class FsmContext
	{
		public bool Return;

		public int NextState;

		public Lexer L;

		public int StateStack;
	}
	internal class Lexer
	{
		private delegate bool StateHandler(FsmContext ctx);

		private static int[] fsm_return_table;

		private static StateHandler[] fsm_handler_table;

		private bool allow_comments;

		private bool allow_single_quoted_strings;

		private bool end_of_input;

		private FsmContext fsm_context;

		private int input_buffer;

		private int input_char;

		private TextReader reader;

		private int state;

		private StringBuilder string_buffer;

		private string string_value;

		private int token;

		private int unichar;

		public bool AllowComments
		{
			get
			{
				return allow_comments;
			}
			set
			{
				allow_comments = value;
			}
		}

		public bool AllowSingleQuotedStrings
		{
			get
			{
				return allow_single_quoted_strings;
			}
			set
			{
				allow_single_quoted_strings = value;
			}
		}

		public bool EndOfInput => end_of_input;

		public int Token => token;

		public string StringValue => string_value;

		static Lexer()
		{
			PopulateFsmTables();
		}

		public Lexer(TextReader reader)
		{
			allow_comments = true;
			allow_single_quoted_strings = true;
			input_buffer = 0;
			string_buffer = new StringBuilder(128);
			state = 1;
			end_of_input = false;
			this.reader = reader;
			fsm_context = new FsmContext();
			fsm_context.L = this;
		}

		private static int HexValue(int digit)
		{
			switch (digit)
			{
			case 65:
			case 97:
				return 10;
			case 66:
			case 98:
				return 11;
			case 67:
			case 99:
				return 12;
			case 68:
			case 100:
				return 13;
			case 69:
			case 101:
				return 14;
			case 70:
			case 102:
				return 15;
			default:
				return digit - 48;
			}
		}

		private static void PopulateFsmTables()
		{
			fsm_handler_table = new StateHandler[28]
			{
				State1, State2, State3, State4, State5, State6, State7, State8, State9, State10,
				State11, State12, State13, State14, State15, State16, State17, State18, State19, State20,
				State21, State22, State23, State24, State25, State26, State27, State28
			};
			fsm_return_table = new int[28]
			{
				65542, 0, 65537, 65537, 0, 65537, 0, 65537, 0, 0,
				65538, 0, 0, 0, 65539, 0, 0, 65540, 65541, 65542,
				0, 0, 65541, 65542, 0, 0, 0, 0
			};
		}

		private static char ProcessEscChar(int esc_char)
		{
			switch (esc_char)
			{
			case 34:
			case 39:
			case 47:
			case 92:
				return Convert.ToChar(esc_char);
			case 110:
				return '\n';
			case 116:
				return '\t';
			case 114:
				return '\r';
			case 98:
				return '\b';
			case 102:
				return '\f';
			default:
				return '?';
			}
		}

		private static bool State1(FsmContext ctx)
		{
			while (ctx.L.GetChar())
			{
				if (ctx.L.input_char == 32 || (ctx.L.input_char >= 9 && ctx.L.input_char <= 13))
				{
					continue;
				}
				if (ctx.L.input_char >= 49 && ctx.L.input_char <= 57)
				{
					ctx.L.string_buffer.Append((char)ctx.L.input_char);
					ctx.NextState = 3;
					return true;
				}
				switch (ctx.L.input_char)
				{
				case 34:
					ctx.NextState = 19;
					ctx.Return = true;
					return true;
				case 44:
				case 58:
				case 91:
				case 93:
				case 123:
				case 125:
					ctx.NextState = 1;
					ctx.Return = true;
					return true;
				case 45:
					ctx.L.string_buffer.Append((char)ctx.L.input_char);
					ctx.NextState = 2;
					return true;
				case 48:
					ctx.L.string_buffer.Append((char)ctx.L.input_char);
					ctx.NextState = 4;
					return true;
				case 102:
					ctx.NextState = 12;
					return true;
				case 110:
					ctx.NextState = 16;
					return true;
				case 116:
					ctx.NextState = 9;
					return true;
				case 39:
					if (!ctx.L.allow_single_quoted_strings)
					{
						return false;
					}
					ctx.L.input_char = 34;
					ctx.NextState = 23;
					ctx.Return = true;
					return true;
				case 47:
					if (!ctx.L.allow_comments)
					{
						return false;
					}
					ctx.NextState = 25;
					return true;
				default:
					return false;
				}
			}
			return true;
		}

		private static bool State2(FsmContext ctx)
		{
			ctx.L.GetChar();
			if (ctx.L.input_char >= 49 && ctx.L.input_char <= 57)
			{
				ctx.L.string_buffer.Append((char)ctx.L.input_char);
				ctx.NextState = 3;
				return true;
			}
			int num = ctx.L.input_char;
			if (num == 48)
			{
				ctx.L.string_buffer.Append((char)ctx.L.input_char);
				ctx.NextState = 4;
				return true;
			}
			return false;
		}

		private static bool State3(FsmContext ctx)
		{
			while (ctx.L.GetChar())
			{
				if (ctx.L.input_char >= 48 && ctx.L.input_char <= 57)
				{
					ctx.L.string_buffer.Append((char)ctx.L.input_char);
					continue;
				}
				if (ctx.L.input_char == 32 || (ctx.L.input_char >= 9 && ctx.L.input_char <= 13))
				{
					ctx.Return = true;
					ctx.NextState = 1;
					return true;
				}
				switch (ctx.L.input_char)
				{
				case 44:
				case 93:
				case 125:
					ctx.L.UngetChar();
					ctx.Return = true;
					ctx.NextState = 1;
					return true;
				case 46:
					ctx.L.string_buffer.Append((char)ctx.L.input_char);
					ctx.NextState = 5;
					return true;
				case 69:
				case 101:
					ctx.L.string_buffer.Append((char)ctx.L.input_char);
					ctx.NextState = 7;
					return true;
				default:
					return false;
				}
			}
			return true;
		}

		private static bool State4(FsmContext ctx)
		{
			ctx.L.GetChar();
			if (ctx.L.input_char == 32 || (ctx.L.input_char >= 9 && ctx.L.input_char <= 13))
			{
				ctx.Return = true;
				ctx.NextState = 1;
				return true;
			}
			switch (ctx.L.input_char)
			{
			case 44:
			case 93:
			case 125:
				ctx.L.UngetChar();
				ctx.Return = true;
				ctx.NextState = 1;
				return true;
			case 46:
				ctx.L.string_buffer.Append((char)ctx.L.input_char);
				ctx.NextState = 5;
				return true;
			case 69:
			case 101:
				ctx.L.string_buffer.Append((char)ctx.L.input_char);
				ctx.NextState = 7;
				return true;
			default:
				return false;
			}
		}

		private static bool State5(FsmContext ctx)
		{
			ctx.L.GetChar();
			if (ctx.L.input_char >= 48 && ctx.L.input_char <= 57)
			{
				ctx.L.string_buffer.Append((char)ctx.L.input_char);
				ctx.NextState = 6;
				return true;
			}
			return false;
		}

		private static bool State6(FsmContext ctx)
		{
			while (ctx.L.GetChar())
			{
				if (ctx.L.input_char >= 48 && ctx.L.input_char <= 57)
				{
					ctx.L.string_buffer.Append((char)ctx.L.input_char);
					continue;
				}
				if (ctx.L.input_char == 32 || (ctx.L.input_char >= 9 && ctx.L.input_char <= 13))
				{
					ctx.Return = true;
					ctx.NextState = 1;
					return true;
				}
				switch (ctx.L.input_char)
				{
				case 44:
				case 93:
				case 125:
					ctx.L.UngetChar();
					ctx.Return = true;
					ctx.NextState = 1;
					return true;
				case 69:
				case 101:
					ctx.L.string_buffer.Append((char)ctx.L.input_char);
					ctx.NextState = 7;
					return true;
				default:
					return false;
				}
			}
			return true;
		}

		private static bool State7(FsmContext ctx)
		{
			ctx.L.GetChar();
			if (ctx.L.input_char >= 48 && ctx.L.input_char <= 57)
			{
				ctx.L.string_buffer.Append((char)ctx.L.input_char);
				ctx.NextState = 8;
				return true;
			}
			int num = ctx.L.input_char;
			if (num == 43 || num == 45)
			{
				ctx.L.string_buffer.Append((char)ctx.L.input_char);
				ctx.NextState = 8;
				return true;
			}
			return false;
		}

		private static bool State8(FsmContext ctx)
		{
			while (ctx.L.GetChar())
			{
				if (ctx.L.input_char >= 48 && ctx.L.input_char <= 57)
				{
					ctx.L.string_buffer.Append((char)ctx.L.input_char);
					continue;
				}
				if (ctx.L.input_char == 32 || (ctx.L.input_char >= 9 && ctx.L.input_char <= 13))
				{
					ctx.Return = true;
					ctx.NextState = 1;
					return true;
				}
				int num = ctx.L.input_char;
				if (num == 44 || num == 93 || num == 125)
				{
					ctx.L.UngetChar();
					ctx.Return = true;
					ctx.NextState = 1;
					return true;
				}
				return false;
			}
			return true;
		}

		private static bool State9(FsmContext ctx)
		{
			ctx.L.GetChar();
			int num = ctx.L.input_char;
			if (num == 114)
			{
				ctx.NextState = 10;
				return true;
			}
			return false;
		}

		private static bool State10(FsmContext ctx)
		{
			ctx.L.GetChar();
			int num = ctx.L.input_char;
			if (num == 117)
			{
				ctx.NextState = 11;
				return true;
			}
			return false;
		}

		private static bool State11(FsmContext ctx)
		{
			ctx.L.GetChar();
			int num = ctx.L.input_char;
			if (num == 101)
			{
				ctx.Return = true;
				ctx.NextState = 1;
				return true;
			}
			return false;
		}

		private static bool State12(FsmContext ctx)
		{
			ctx.L.GetChar();
			int num = ctx.L.input_char;
			if (num == 97)
			{
				ctx.NextState = 13;
				return true;
			}
			return false;
		}

		private static bool State13(FsmContext ctx)
		{
			ctx.L.GetChar();
			int num = ctx.L.input_char;
			if (num == 108)
			{
				ctx.NextState = 14;
				return true;
			}
			return false;
		}

		private static bool State14(FsmContext ctx)
		{
			ctx.L.GetChar();
			int num = ctx.L.input_char;
			if (num == 115)
			{
				ctx.NextState = 15;
				return true;
			}
			return false;
		}

		private static bool State15(FsmContext ctx)
		{
			ctx.L.GetChar();
			int num = ctx.L.input_char;
			if (num == 101)
			{
				ctx.Return = true;
				ctx.NextState = 1;
				return true;
			}
			return false;
		}

		private static bool State16(FsmContext ctx)
		{
			ctx.L.GetChar();
			int num = ctx.L.input_char;
			if (num == 117)
			{
				ctx.NextState = 17;
				return true;
			}
			return false;
		}

		private static bool State17(FsmContext ctx)
		{
			ctx.L.GetChar();
			int num = ctx.L.input_char;
			if (num == 108)
			{
				ctx.NextState = 18;
				return true;
			}
			return false;
		}

		private static bool State18(FsmContext ctx)
		{
			ctx.L.GetChar();
			int num = ctx.L.input_char;
			if (num == 108)
			{
				ctx.Return = true;
				ctx.NextState = 1;
				return true;
			}
			return false;
		}

		private static bool State19(FsmContext ctx)
		{
			while (ctx.L.GetChar())
			{
				switch (ctx.L.input_char)
				{
				case 34:
					ctx.L.UngetChar();
					ctx.Return = true;
					ctx.NextState = 20;
					return true;
				case 92:
					ctx.StateStack = 19;
					ctx.NextState = 21;
					return true;
				}
				ctx.L.string_buffer.Append((char)ctx.L.input_char);
			}
			return true;
		}

		private static bool State20(FsmContext ctx)
		{
			ctx.L.GetChar();
			int num = ctx.L.input_char;
			if (num == 34)
			{
				ctx.Return = true;
				ctx.NextState = 1;
				return true;
			}
			return false;
		}

		private static bool State21(FsmContext ctx)
		{
			ctx.L.GetChar();
			switch (ctx.L.input_char)
			{
			case 117:
				ctx.NextState = 22;
				return true;
			case 34:
			case 39:
			case 47:
			case 92:
			case 98:
			case 102:
			case 110:
			case 114:
			case 116:
				ctx.L.string_buffer.Append(ProcessEscChar(ctx.L.input_char));
				ctx.NextState = ctx.StateStack;
				return true;
			default:
				return false;
			}
		}

		private static bool State22(FsmContext ctx)
		{
			int num = 0;
			int num2 = 4096;
			ctx.L.unichar = 0;
			while (ctx.L.GetChar())
			{
				if ((ctx.L.input_char >= 48 && ctx.L.input_char <= 57) || (ctx.L.input_char >= 65 && ctx.L.input_char <= 70) || (ctx.L.input_char >= 97 && ctx.L.input_char <= 102))
				{
					ctx.L.unichar += HexValue(ctx.L.input_char) * num2;
					num++;
					num2 /= 16;
					if (num == 4)
					{
						ctx.L.string_buffer.Append(Convert.ToChar(ctx.L.unichar));
						ctx.NextState = ctx.StateStack;
						return true;
					}
					continue;
				}
				return false;
			}
			return true;
		}

		private static bool State23(FsmContext ctx)
		{
			while (ctx.L.GetChar())
			{
				switch (ctx.L.input_char)
				{
				case 39:
					ctx.L.UngetChar();
					ctx.Return = true;
					ctx.NextState = 24;
					return true;
				case 92:
					ctx.StateStack = 23;
					ctx.NextState = 21;
					return true;
				}
				ctx.L.string_buffer.Append((char)ctx.L.input_char);
			}
			return true;
		}

		private static bool State24(FsmContext ctx)
		{
			ctx.L.GetChar();
			int num = ctx.L.input_char;
			if (num == 39)
			{
				ctx.L.input_char = 34;
				ctx.Return = true;
				ctx.NextState = 1;
				return true;
			}
			return false;
		}

		private static bool State25(FsmContext ctx)
		{
			ctx.L.GetChar();
			switch (ctx.L.input_char)
			{
			case 42:
				ctx.NextState = 27;
				return true;
			case 47:
				ctx.NextState = 26;
				return true;
			default:
				return false;
			}
		}

		private static bool State26(FsmContext ctx)
		{
			while (ctx.L.GetChar())
			{
				if (ctx.L.input_char == 10)
				{
					ctx.NextState = 1;
					return true;
				}
			}
			return true;
		}

		private static bool State27(FsmContext ctx)
		{
			while (ctx.L.GetChar())
			{
				if (ctx.L.input_char == 42)
				{
					ctx.NextState = 28;
					return true;
				}
			}
			return true;
		}

		private static bool State28(FsmContext ctx)
		{
			while (ctx.L.GetChar())
			{
				if (ctx.L.input_char != 42)
				{
					if (ctx.L.input_char == 47)
					{
						ctx.NextState = 1;
						return true;
					}
					ctx.NextState = 27;
					return true;
				}
			}
			return true;
		}

		private bool GetChar()
		{
			if ((input_char = NextChar()) != -1)
			{
				return true;
			}
			end_of_input = true;
			return false;
		}

		private int NextChar()
		{
			if (input_buffer != 0)
			{
				int result = input_buffer;
				input_buffer = 0;
				return result;
			}
			return reader.Read();
		}

		public bool NextToken()
		{
			fsm_context.Return = false;
			while (true)
			{
				if (!fsm_handler_table[state - 1](fsm_context))
				{
					throw new JsonException(input_char);
				}
				if (end_of_input)
				{
					return false;
				}
				if (fsm_context.Return)
				{
					break;
				}
				state = fsm_context.NextState;
			}
			string_value = string_buffer.ToString();
			string_buffer.Remove(0, string_buffer.Length);
			token = fsm_return_table[state - 1];
			if (token == 65542)
			{
				token = input_char;
			}
			state = fsm_context.NextState;
			return true;
		}

		private void UngetChar()
		{
			input_buffer = input_char;
		}
	}
	internal enum ParserToken
	{
		None = 65536,
		Number,
		True,
		False,
		Null,
		CharSeq,
		Char,
		Text,
		Object,
		ObjectPrime,
		Pair,
		PairRest,
		Array,
		ArrayPrime,
		Value,
		ValueRest,
		String,
		End,
		Epsilon
	}
}
namespace HighlightPlus
{
	public delegate bool OnObjectHighlightStartEvent(GameObject obj);
	public delegate void OnObjectHighlightEndEvent(GameObject obj);
	public delegate bool OnRendererHighlightEvent(Renderer renderer);
	public enum SeeThroughMode
	{
		WhenHighlighted,
		AlwaysWhenOccluded,
		Never
	}
	public enum QualityLevel
	{
		Fastest,
		High,
		Highest
	}
	public enum TargetOptions
	{
		Children,
		OnlyThisObject,
		RootToChildren,
		LayerInScene,
		LayerInChildren
	}
	public enum Visibility
	{
		Normal,
		AlwaysOnTop,
		OnlyWhenOccluded
	}
	public enum GlowBlendMode
	{
		Additive,
		AlphaBlend
	}
	[Serializable]
	public struct GlowPassData
	{
		public float offset;

		public float alpha;

		public Color color;
	}
	[ExecuteInEditMode]
	[HelpURL("https://kronnect.freshdesk.com/support/solutions/42000065090")]
	public class HighlightEffect : MonoBehaviour
	{
		private struct ModelMaterials
		{
			public bool render;

			public Transform transform;

			public bool bakedTransform;

			public Vector3 currentPosition;

			public Vector3 currentRotation;

			public Vector3 currentScale;

			public bool renderWasVisibleDuringSetup;

			public Mesh mesh;

			public Mesh originalMesh;

			public Renderer renderer;

			public bool skinnedMesh;

			public Material[] fxMatMask;

			public Material[] fxMatSolidColor;

			public Material[] fxMatSeeThroughInner;

			public Material[] fxMatSeeThroughBorder;

			public Material[] fxMatOverlay;

			public Material[] fxMatInnerGlow;

			public Matrix4x4 renderingMatrix;
		}

		private enum FadingState
		{
			FadingOut = -1,
			NoFading,
			FadingIn
		}

		public HighlightProfile profile;

		[Tooltip("If enabled, settings will be synced with profile.")]
		public bool profileSync;

		public bool previewInEditor = true;

		public TargetOptions effectGroup;

		public LayerMask effectGroupLayer = -1;

		[Range(0f, 1f)]
		public float alphaCutOff;

		public bool cullBackFaces = true;

		[Tooltip("Show highlight effects even if the object is not visible. If this object or its children use GPU Instancing tools, the MeshRenderer can be disabled although the object is visible. In this case, this option is useful to enable highlighting.")]
		public bool ignoreObjectVisibility;

		[Tooltip("Support reflection probes. Enable only if you want the effects to be visible in reflections.")]
		public bool reflectionProbes;

		[Tooltip("Enables depth buffer clipping. Only applies to outline or outer glow in High Quality mode.")]
		public bool depthClip;

		[Tooltip("Ignore highlighting on this object.")]
		public bool ignore;

		[SerializeField]
		private bool _highlighted;

		public float fadeInDuration;

		public float fadeOutDuration;

		public bool flipY;

		public bool constantWidth = true;

		[Range(0f, 1f)]
		public float overlay = 0.5f;

		public Color overlayColor = Color.yellow;

		public float overlayAnimationSpeed = 1f;

		[Range(0f, 1f)]
		public float overlayMinIntensity = 0.5f;

		[Range(0f, 1f)]
		public float overlayBlending = 1f;

		[Range(0f, 1f)]
		public float outline = 1f;

		public Color outlineColor = Color.black;

		public float outlineWidth = 0.45f;

		public QualityLevel outlineQuality = QualityLevel.High;

		[Range(1f, 8f)]
		public int outlineDownsampling = 2;

		public Visibility outlineVisibility;

		public bool outlineOptimalBlit = true;

		public bool outlineBlitDebug;

		public bool outlineIndependent;

		[Range(0f, 5f)]
		public float glow = 1f;

		public float glowWidth = 0.4f;

		public QualityLevel glowQuality = QualityLevel.High;

		[Range(1f, 8f)]
		public int glowDownsampling = 2;

		public Color glowHQColor = new Color(0.64f, 1f, 0f, 1f);

		public bool glowDithering = true;

		public GlowBlendMode glowBlendMode;

		public float glowMagicNumber1 = 0.75f;

		public float glowMagicNumber2 = 0.5f;

		public float glowAnimationSpeed = 1f;

		public Visibility glowVisibility;

		public bool glowOptimalBlit = true;

		public bool glowBlitDebug;

		public GlowPassData[] glowPasses;

		[Range(0f, 5f)]
		public float innerGlow;

		[Range(0f, 2f)]
		public float innerGlowWidth = 1f;

		public Color innerGlowColor = Color.white;

		public Visibility innerGlowVisibility;

		public bool targetFX;

		public Texture2D targetFXTexture;

		public Color targetFXColor = Color.white;

		public Transform targetFXCenter;

		public float targetFXRotationSpeed = 50f;

		public float targetFXInitialScale = 4f;

		public float targetFXEndScale = 1.5f;

		public float targetFXTransitionDuration = 0.5f;

		public float targetFXStayDuration = 1.5f;

		public SeeThroughMode seeThrough;

		public LayerMask seeThroughOccluderMask = -1;

		[Range(0.01f, 0.6f)]
		public float seeThroughOccluderThreshold = 0.3f;

		public float seeThroughOccluderCheckInterval = 1f;

		[Range(0f, 5f)]
		public float seeThroughIntensity = 0.8f;

		[Range(0f, 1f)]
		public float seeThroughTintAlpha = 0.5f;

		public Color seeThroughTintColor = Color.red;

		[Range(0f, 1f)]
		public float seeThroughNoise = 1f;

		[Range(0f, 1f)]
		public float seeThroughBorder;

		public Color seeThroughBorderColor = Color.black;

		public float seeThroughBorderWidth = 0.45f;

		[SerializeField]
		[HideInInspector]
		private ModelMaterials[] rms;

		[SerializeField]
		[HideInInspector]
		private int rmsCount;

		[NonSerialized]
		public Transform target;

		[NonSerialized]
		public float highlightStartTime;

		private const string SKW_ALPHACLIP = "HP_ALPHACLIP";

		private const string SKW_DEPTHCLIP = "HP_DEPTHCLIP";

		private const string UNIFORM_CUTOFF = "_CutOff";

		private const float TAU = 0.70711f;

		private static Material fxMatMask;

		private static Material fxMatSolidColor;

		private static Material fxMatSeeThroughInner;

		private static Material fxMatSeeThroughBorder;

		private static Material fxMatOverlay;

		private static Material fxMatGlowRef;

		private static Material fxMatInnerGlow;

		private static Material fxMatOutlineRef;

		private static Material fxMatTargetRef;

		private static Material fxMatComposeGlowRef;

		private static Material fxMatComposeOutlineRef;

		private static Material fxMatBlurGlowRef;

		private static Material fxMatBlurOutlineRef;

		private Material _fxMatOutline;

		private Material _fxMatGlow;

		private Material _fxMatTarget;

		private Material _fxMatComposeGlow;

		private Material _fxMatComposeOutline;

		private Material _fxMatBlurGlow;

		private Material _fxMatBlurOutline;

		private static Vector3[] offsets;

		private float fadeStartTime;

		private FadingState fading;

		private CommandBuffer cbMask;

		private CommandBuffer cbSeeThrough;

		private CommandBuffer cbGlow;

		private CommandBuffer cbOutline;

		private CommandBuffer cbOverlay;

		private CommandBuffer cbInnerGlow;

		private CommandBuffer cbSmoothBlend;

		private int[] mipGlowBuffers;

		private int[] mipOutlineBuffers;

		private int glowRT;

		private int outlineRT;

		private static Mesh quadMesh;

		private int sourceRT;

		private Matrix4x4 quadGlowMatrix;

		private Matrix4x4 quadOutlineMatrix;

		private Vector3[] corners;

		private RenderTextureDescriptor sourceDesc;

		private Color debugColor;

		private Color blackColor;

		private Visibility lastOutlineVisibility;

		private bool requireUpdateMaterial;

		private bool usingPipeline;

		private float occlusionCheckLastTime;

		private bool lastOcclusionTestResult;

		private List<Renderer> tempRR;

		private static List<Vector3> vertices;

		private static List<Vector3> normals;

		private static Vector3[] newNormals;

		private static int[] matches;

		private static Dictionary<Vector3, int> vv = new Dictionary<Vector3, int>();

		private static Dictionary<Mesh, Mesh> smoothMeshes = new Dictionary<Mesh, Mesh>();

		private bool overlayOneShotRunning;

		private bool currentHighlighted;

		private Color overlayOneShotCurrentColor;

		private float overlayOneShotCurrentAnimationSpeed;

		private float overlayOneShotCurrentOverlay;

		private float overlayOneShotCurrentOuterGlow;

		private float overlayOneShotCurrentInnerGlow;

		private float overlayOneShotCurrentOutline;

		private float overlayOneShotCurrentSeeThroughIntensity;

		private Coroutine overlayOneShotCo;

		private static List<HighlightSeeThroughOccluder> occluders = new List<HighlightSeeThroughOccluder>();

		private static Dictionary<Camera, int> occludersFrameCount = new Dictionary<Camera, int>();

		private static CommandBuffer cbOccluder;

		private static Material fxMatOccluder;

		private bool cancelSeeThroughThisFrame;

		public bool highlighted
		{
			get
			{
				return _highlighted;
			}
			set
			{
				SetHighlighted(value);
			}
		}

		private Material fxMatOutline
		{
			get
			{
				if (_fxMatOutline == null && fxMatOutlineRef != null)
				{
					_fxMatOutline = UnityEngine.Object.Instantiate(fxMatOutlineRef);
				}
				return _fxMatOutline;
			}
		}

		private Material fxMatGlow
		{
			get
			{
				if (_fxMatGlow == null && fxMatGlowRef != null)
				{
					_fxMatGlow = UnityEngine.Object.Instantiate(fxMatGlowRef);
				}
				return _fxMatGlow;
			}
		}

		private Material fxMatTarget
		{
			get
			{
				if (_fxMatTarget == null && fxMatTargetRef != null)
				{
					_fxMatTarget = UnityEngine.Object.Instantiate(fxMatTargetRef);
				}
				return _fxMatTarget;
			}
		}

		private Material fxMatComposeGlow
		{
			get
			{
				if (_fxMatComposeGlow == null && fxMatComposeGlowRef != null)
				{
					_fxMatComposeGlow = UnityEngine.Object.Instantiate(fxMatComposeGlowRef);
				}
				return _fxMatComposeGlow;
			}
		}

		private Material fxMatComposeOutline
		{
			get
			{
				if (_fxMatComposeOutline == null && fxMatComposeOutlineRef != null)
				{
					_fxMatComposeOutline = UnityEngine.Object.Instantiate(fxMatComposeOutlineRef);
				}
				return _fxMatComposeOutline;
			}
		}

		private Material fxMatBlurGlow
		{
			get
			{
				if (_fxMatBlurGlow == null && fxMatBlurGlowRef != null)
				{
					_fxMatBlurGlow = UnityEngine.Object.Instantiate(fxMatBlurGlowRef);
				}
				return _fxMatBlurGlow;
			}
		}

		private Material fxMatBlurOutline
		{
			get
			{
				if (_fxMatBlurOutline == null && fxMatBlurOutlineRef != null)
				{
					_fxMatBlurOutline = UnityEngine.Object.Instantiate(fxMatBlurOutlineRef);
				}
				return _fxMatBlurOutline;
			}
		}

		public event OnObjectHighlightStartEvent OnObjectHighlightStart;

		public event OnObjectHighlightEndEvent OnObjectHighlightEnd;

		public event OnRendererHighlightEvent OnRendererHighlightStart;

		private void OnEnable()
		{
			lastOutlineVisibility = outlineVisibility;
			debugColor = new Color(1f, 0f, 0f, 0.5f);
			blackColor = new Color(0f, 0f, 0f, 0f);
			if (offsets == null || offsets.Length != 8)
			{
				offsets = new Vector3[8]
				{
					Vector3.up,
					Vector3.right,
					Vector3.down,
					Vector3.left,
					new Vector3(-0.70711f, 0.70711f, 0f),
					new Vector3(0.70711f, 0.70711f, 0f),
					new Vector3(0.70711f, -0.70711f, 0f),
					new Vector3(-0.70711f, -0.70711f, 0f)
				};
			}
			if (corners == null || corners.Length != 8)
			{
				corners = new Vector3[8];
			}
			if (quadMesh == null)
			{
				BuildQuad();
			}
			if (target == null)
			{
				target = base.transform;
			}
			if (profileSync && profile != null)
			{
				profile.Load(this);
			}
			if (glowPasses == null || glowPasses.Length == 0)
			{
				glowPasses = new GlowPassData[4];
				glowPasses[0] = new GlowPassData
				{
					offset = 4f,
					alpha = 0.1f,
					color = new Color(0.64f, 1f, 0f, 1f)
				};
				glowPasses[1] = new GlowPassData
				{
					offset = 3f,
					alpha = 0.2f,
					color = new Color(0.64f, 1f, 0f, 1f)
				};
				glowPasses[2] = new GlowPassData
				{
					offset = 2f,
					alpha = 0.3f,
					color = new Color(0.64f, 1f, 0f, 1f)
				};
				glowPasses[3] = new GlowPassData
				{
					offset = 1f,
					alpha = 0.4f,
					color = new Color(0.64f, 1f, 0f, 1f)
				};
			}
			sourceRT = Shader.PropertyToID("_HPSourceRT");
			CheckGeometrySupportDependencies();
			SetupMaterial();
		}

		private void OnDisable()
		{
			UpdateMaterialPropertiesNow();
		}

		private void Reset()
		{
			SetupMaterial();
		}

		private void DestroyMaterial(Material mat)
		{
			if (mat != null)
			{
				UnityEngine.Object.DestroyImmediate(mat);
			}
		}

		private void DestroyMaterialArray(Material[] mm)
		{
			if (mm != null)
			{
				for (int i = 0; i < mm.Length; i++)
				{
					DestroyMaterial(mm[i]);
				}
			}
		}

		private void OnDestroy()
		{
			if (rms != null)
			{
				for (int i = 0; i < rms.Length; i++)
				{
					DestroyMaterialArray(rms[i].fxMatMask);
					DestroyMaterialArray(rms[i].fxMatSolidColor);
					DestroyMaterialArray(rms[i].fxMatSeeThroughInner);
					DestroyMaterialArray(rms[i].fxMatSeeThroughBorder);
					DestroyMaterialArray(rms[i].fxMatOverlay);
					DestroyMaterialArray(rms[i].fxMatInnerGlow);
				}
			}
			DestroyMaterial(fxMatGlow);
			DestroyMaterial(fxMatOutline);
			DestroyMaterial(fxMatTarget);
			DestroyMaterial(fxMatComposeGlow);
			DestroyMaterial(fxMatComposeOutline);
			DestroyMaterial(fxMatBlurGlow);
			DestroyMaterial(fxMatBlurOutline);
		}

		private void OnRenderObject()
		{
			if (!usingPipeline)
			{
				DoOnRenderObject(Camera.current);
			}
		}

		public void ProfileLoad(HighlightProfile profile)
		{
			if (profile != null)
			{
				profile.Load(this);
			}
		}

		public void ProfileReload()
		{
			if (profile != null)
			{
				profile.Load(this);
			}
		}

		public void ProfileSaveChanges(HighlightProfile profile)
		{
			if (profile != null)
			{
				profile.Save(this);
			}
		}

		public void ProfileSaveChanges()
		{
			if (profile != null)
			{
				profile.Save(this);
			}
		}

		public void Refresh()
		{
			if (base.enabled)
			{
				SetupMaterial();
			}
		}

		private void DoOnRenderObject(Camera cam)
		{
			if (cam == null || (!reflectionProbes && cam.cameraType == CameraType.Reflection))
			{
				return;
			}
			RenderOccluders(cam);
			if (requireUpdateMaterial)
			{
				requireUpdateMaterial = false;
				UpdateMaterialPropertiesNow();
			}
			bool flag = seeThroughIntensity > 0f && (seeThrough == SeeThroughMode.AlwaysWhenOccluded || (seeThrough == SeeThroughMode.WhenHighlighted && _highlighted));
			if (cancelSeeThroughThisFrame)
			{
				cancelSeeThroughThisFrame = false;
				flag = false;
			}
			if (flag && (int)seeThroughOccluderMask != -1)
			{
				flag = CheckOcclusion(cam);
			}
			if ((!_highlighted && !flag) || rms == null)
			{
				return;
			}
			int cullingMask = cam.cullingMask;
			if (!ignoreObjectVisibility)
			{
				for (int i = 0; i < rmsCount; i++)
				{
					if (rms[i].renderer != null && rms[i].renderer.isVisible != rms[i].renderWasVisibleDuringSetup)
					{
						SetupMaterial();
						break;
					}
				}
			}
			float num = (_highlighted ? glow : 0f);
			_ = base.gameObject.layer;
			if (fxMatMask == null)
			{
				return;
			}
			bool flag2 = glow > 0f && glowQuality == QualityLevel.Highest;
			bool flag3 = outline > 0f && outlineQuality == QualityLevel.Highest;
			bool flag4 = flag2 || flag3;
			if (flag4 && flag2 && flag3)
			{
				outlineVisibility = glowVisibility;
			}
			Visibility visibility = glowVisibility;
			Visibility visibility2 = outlineVisibility;
			if (flag4)
			{
				if (cam.allowMSAA && QualitySettings.antiAliasing > 1)
				{
					if (depthClip)
					{
						cam.depthTextureMode |= DepthTextureMode.Depth;
					}
					visibility = (visibility2 = Visibility.AlwaysOnTop);
				}
				else if (XRSettings.enabled && Application.isPlaying)
				{
					if (depthClip)
					{
						cam.depthTextureMode |= DepthTextureMode.Depth;
					}
					visibility = (visibility2 = Visibility.AlwaysOnTop);
				}
			}
			for (int j = 0; j < rmsCount; j++)
			{
				rms[j].render = false;
				Transform transform = rms[j].transform;
				if (transform == null)
				{
					continue;
				}
				Mesh mesh = rms[j].mesh;
				if (mesh == null || ((1 << transform.gameObject.layer) & cullingMask) == 0 || !rms[j].renderer.isVisible)
				{
					continue;
				}
				rms[j].render = true;
				if (!rms[j].skinnedMesh)
				{
					Vector3 lossyScale = transform.lossyScale;
					Vector3 position = transform.position;
					if (rms[j].bakedTransform)
					{
						if (rms[j].currentPosition != transform.position || rms[j].currentRotation != transform.eulerAngles || rms[j].currentScale != transform.lossyScale)
						{
							BakeTransform(j, duplicateMesh: true);
						}
						rms[j].renderingMatrix = Matrix4x4.identity;
					}
					else
					{
						rms[j].renderingMatrix = Matrix4x4.TRS(position, transform.rotation, lossyScale);
					}
				}
				if (outlineIndependent && outline > 0f)
				{
					Material material = fxMatOutline;
					for (int k = 0; k < mesh.subMeshCount; k++)
					{
						if (outlineQuality == QualityLevel.High)
						{
							for (int l = 0; l < offsets.Length; l++)
							{
								Vector3 vector = offsets[l] * (outlineWidth / 100f);
								vector.y *= cam.aspect;
								material.SetVector("_OutlineDirection", vector);
								if (rms[j].skinnedMesh)
								{
									cbOutline.Clear();
									cbOutline.DrawRenderer(rms[j].renderer, material, k, 1);
									Graphics.ExecuteCommandBuffer(cbOutline);
								}
								else
								{
									material.SetPass(1);
									Graphics.DrawMeshNow(mesh, rms[j].renderingMatrix, k);
								}
							}
						}
						else if (rms[j].skinnedMesh)
						{
							cbOutline.Clear();
							cbOutline.DrawRenderer(rms[j].renderer, material, k, 1);
							Graphics.ExecuteCommandBuffer(cbOutline);
						}
						else
						{
							material.SetPass(1);
							Graphics.DrawMeshNow(mesh, rms[j].renderingMatrix, k);
						}
					}
				}
				if (rms[j].skinnedMesh)
				{
					cbMask.Clear();
					for (int m = 0; m < mesh.subMeshCount; m++)
					{
						if (_highlighted && ((outline > 0f && visibility2 != 0) || (glow > 0f && visibility != 0) || (innerGlow > 0f && innerGlowVisibility != 0)))
						{
							rms[j].fxMatMask[m].SetInt("_ZTest", 8);
						}
						else
						{
							rms[j].fxMatMask[m].SetInt("_ZTest", 4);
						}
						cbMask.DrawRenderer(rms[j].renderer, rms[j].fxMatMask[m], m);
					}
					Graphics.ExecuteCommandBuffer(cbMask);
					continue;
				}
				for (int n = 0; n < mesh.subMeshCount; n++)
				{
					if (_highlighted && ((outline > 0f && visibility2 != 0) || (glow > 0f && visibility != 0) || (innerGlow > 0f && innerGlowVisibility != 0)))
					{
						rms[j].fxMatMask[n].SetInt("_ZTest", 8);
					}
					else
					{
						rms[j].fxMatMask[n].SetInt("_ZTest", 4);
					}
					rms[j].fxMatMask[n].SetPass(0);
					Graphics.DrawMeshNow(mesh, rms[j].renderingMatrix, n);
				}
			}
			float num2 = 1f;
			if (fading != 0)
			{
				if (fading == FadingState.FadingIn)
				{
					if (fadeInDuration > 0f)
					{
						num2 = (Time.time - fadeStartTime) / fadeInDuration;
						if (num2 > 1f)
						{
							num2 = 1f;
							fading = FadingState.NoFading;
						}
					}
				}
				else if (fadeOutDuration > 0f)
				{
					num2 = 1f - (Time.time - fadeStartTime) / fadeOutDuration;
					if (num2 < 0f)
					{
						num2 = 0f;
						fading = FadingState.NoFading;
						_highlighted = false;
						if (this.OnObjectHighlightEnd != null)
						{
							this.OnObjectHighlightEnd(base.gameObject);
						}
						SendMessage("HighlightEnd", null, SendMessageOptions.DontRequireReceiver);
					}
				}
			}
			if (glowQuality == QualityLevel.High)
			{
				num *= 0.25f;
			}
			int num3 = 0;
			int num4 = 0;
			Bounds bounds = default(Bounds);
			if (flag4)
			{
				if (cbSmoothBlend == null)
				{
					CheckBlurCommandBuffer();
				}
				cbSmoothBlend.Clear();
				num3 = cam.pixelWidth;
				num4 = cam.pixelHeight;
				if (num4 <= 0)
				{
					num4 = 1;
				}
				if (XRSettings.enabled && Application.isPlaying)
				{
					sourceDesc = XRSettings.eyeTextureDesc;
				}
				else
				{
					sourceDesc = new RenderTextureDescriptor(num3, num4, RenderTextureFormat.Default);
					sourceDesc.volumeDepth = 1;
				}
				sourceDesc.msaaSamples = 1;
				sourceDesc.useMipMap = false;
				sourceDesc.depthBufferBits = 0;
				cbSmoothBlend.GetTemporaryRT(sourceRT, sourceDesc, FilterMode.Bilinear);
				if ((glow > 0f && visibility == Visibility.AlwaysOnTop) || (outline > 0f && visibility2 == Visibility.AlwaysOnTop))
				{
					cbSmoothBlend.SetRenderTarget(sourceRT);
				}
				else
				{
					cbSmoothBlend.SetRenderTarget(sourceRT, BuiltinRenderTextureType.CameraTarget);
				}
				cbSmoothBlend.ClearRenderTarget(clearDepth: false, clearColor: true, new Color(0f, 0f, 0f, 0f));
			}
			for (int num5 = 0; num5 < rmsCount; num5++)
			{
				if (!rms[num5].render)
				{
					continue;
				}
				Mesh mesh2 = rms[num5].mesh;
				if (flag)
				{
					bool flag5 = seeThroughBorder * seeThroughBorderWidth > 0f;
					if (rms[num5].skinnedMesh)
					{
						cbSeeThrough.Clear();
						for (int num6 = 0; num6 < mesh2.subMeshCount; num6++)
						{
							if (num6 < rms[num5].fxMatSeeThroughInner.Length && rms[num5].fxMatSeeThroughInner[num6] != null)
							{
								cbSeeThrough.DrawRenderer(rms[num5].renderer, rms[num5].fxMatSeeThroughInner[num6], num6);
								if (flag5)
								{
									cbSeeThrough.DrawRenderer(rms[num5].renderer, rms[num5].fxMatSeeThroughBorder[num6], num6);
								}
							}
						}
						Graphics.ExecuteCommandBuffer(cbSeeThrough);
					}
					else
					{
						for (int num7 = 0; num7 < mesh2.subMeshCount; num7++)
						{
							if (num7 < rms[num5].fxMatSeeThroughInner.Length && rms[num5].fxMatSeeThroughInner[num7] != null)
							{
								rms[num5].fxMatSeeThroughInner[num7].SetPass(0);
								Graphics.DrawMeshNow(mesh2, rms[num5].renderingMatrix, num7);
								if (flag5)
								{
									rms[num5].fxMatSeeThroughBorder[num7].SetPass(0);
									Graphics.DrawMeshNow(mesh2, rms[num5].renderingMatrix, num7);
								}
							}
						}
					}
				}
				if (!_highlighted)
				{
					continue;
				}
				if (flag4)
				{
					if (num5 == 0)
					{
						bounds = rms[num5].renderer.bounds;
					}
					else
					{
						bounds.Encapsulate(rms[num5].renderer.bounds);
					}
				}
				for (int num8 = 0; num8 < mesh2.subMeshCount; num8++)
				{
					if (flag4 && num8 < rms[num5].fxMatSolidColor.Length)
					{
						if (rms[num5].skinnedMesh)
						{
							cbSmoothBlend.DrawRenderer(rms[num5].renderer, rms[num5].fxMatSolidColor[num8], num8);
						}
						else
						{
							cbSmoothBlend.DrawMesh(mesh2, rms[num5].renderingMatrix, rms[num5].fxMatSolidColor[num8], num8);
						}
					}
					if (glow > 0f && glowQuality != QualityLevel.Highest)
					{
						Material material2 = fxMatGlow;
						material2.SetVector("_GlowDirection", Vector3.zero);
						for (int num9 = 0; num9 < glowPasses.Length; num9++)
						{
							material2.SetColor("_GlowColor", glowPasses[num9].color);
							material2.SetVector("_Glow", new Vector4(num2 * num * glowPasses[num9].alpha, glowPasses[num9].offset * glowWidth / 100f, glowMagicNumber1, glowMagicNumber2));
							if (glowQuality == QualityLevel.High)
							{
								for (int num10 = 0; num10 < offsets.Length; num10++)
								{
									Vector3 vector2 = offsets[num10];
									vector2.y *= cam.aspect;
									material2.SetVector("_GlowDirection", vector2);
									if (rms[num5].skinnedMesh)
									{
										cbGlow.Clear();
										cbGlow.DrawRenderer(rms[num5].renderer, material2, num8);
										Graphics.ExecuteCommandBuffer(cbGlow);
									}
									else
									{
										material2.SetPass(0);
										Graphics.DrawMeshNow(mesh2, rms[num5].renderingMatrix, num8);
									}
								}
							}
							else if (rms[num5].skinnedMesh)
							{
								cbGlow.Clear();
								cbGlow.DrawRenderer(rms[num5].renderer, material2, num8);
								Graphics.ExecuteCommandBuffer(cbGlow);
							}
							else
							{
								material2.SetPass(0);
								Graphics.DrawMeshNow(mesh2, rms[num5].renderingMatrix, num8);
							}
						}
					}
					if (outline > 0f && outlineQuality != QualityLevel.Highest)
					{
						Color value = outlineColor;
						value.a = outline * num2;
						Material material3 = fxMatOutline;
						material3.SetColor("_OutlineColor", value);
						if (outlineQuality == QualityLevel.High)
						{
							for (int num11 = 0; num11 < offsets.Length; num11++)
							{
								Vector3 vector3 = offsets[num11] * (outlineWidth / 100f);
								vector3.y *= cam.aspect;
								material3.SetVector("_OutlineDirection", vector3);
								if (rms[num5].skinnedMesh)
								{
									cbOutline.Clear();
									cbOutline.DrawRenderer(rms[num5].renderer, material3, num8, 0);
									Graphics.ExecuteCommandBuffer(cbOutline);
								}
								else
								{
									material3.SetPass(0);
									Graphics.DrawMeshNow(mesh2, rms[num5].renderingMatrix, num8);
								}
							}
						}
						else if (rms[num5].skinnedMesh)
						{
							cbOutline.Clear();
							cbOutline.DrawRenderer(rms[num5].renderer, material3, num8, 0);
							Graphics.ExecuteCommandBuffer(cbOutline);
						}
						else
						{
							material3.SetPass(0);
							Graphics.DrawMeshNow(mesh2, rms[num5].renderingMatrix, num8);
						}
					}
					if (overlay > 0f && num8 < rms[num5].fxMatOverlay.Length && rms[num5].fxMatOverlay[num8] != null)
					{
						Color color = overlayColor;
						color.a = overlay * num2;
						rms[num5].fxMatOverlay[num8].color = color;
						rms[num5].fxMatOverlay[num8].SetVector("_OverlayData", new Vector3(overlayAnimationSpeed, overlayMinIntensity, overlayBlending));
						if (rms[num5].skinnedMesh)
						{
							cbOverlay.Clear();
							cbOverlay.DrawRenderer(rms[num5].renderer, rms[num5].fxMatOverlay[num8], num8);
							Graphics.ExecuteCommandBuffer(cbOverlay);
						}
						else
						{
							rms[num5].fxMatOverlay[num8].SetPass(0);
							Graphics.DrawMeshNow(mesh2, rms[num5].renderingMatrix, num8);
						}
					}
					if (innerGlow > 0f && innerGlowWidth > 0f && num8 < rms[num5].fxMatInnerGlow.Length && rms[num5].fxMatInnerGlow[num8] != null)
					{
						Color value2 = innerGlowColor;
						value2.a = innerGlow * num2;
						rms[num5].fxMatInnerGlow[num8].SetColor("_Color", value2);
						if (rms[num5].skinnedMesh)
						{
							cbInnerGlow.Clear();
							cbInnerGlow.DrawRenderer(rms[num5].renderer, rms[num5].fxMatInnerGlow[num8], num8);
							Graphics.ExecuteCommandBuffer(cbInnerGlow);
						}
						else
						{
							rms[num5].fxMatInnerGlow[num8].SetPass(0);
							Graphics.DrawMeshNow(mesh2, rms[num5].renderingMatrix, num8);
						}
					}
				}
				if (!targetFX)
				{
					continue;
				}
				float num12 = 1f;
				if (Application.isPlaying)
				{
					num12 = Time.time - highlightStartTime;
					if (num12 >= targetFXStayDuration)
					{
						num12 -= targetFXStayDuration;
						num12 = 1f - num12;
					}
					if (num12 > 1f)
					{
						num12 = 1f;
					}
				}
				if (!(num12 > 0f))
				{
					continue;
				}
				float t = 1f;
				float num13;
				if (Application.isPlaying)
				{
					t = (Time.time - highlightStartTime) / targetFXTransitionDuration;
					if (t > 1f)
					{
						t = 1f;
					}
					t = Mathf.Sin(t * (float)Math.PI * 0.5f);
					num13 = Time.time;
				}
				else
				{
					num13 = (float)DateTime.Now.Subtract(DateTime.Today).TotalSeconds;
				}
				Bounds bounds2 = rms[num5].renderer.bounds;
				Vector3 size = bounds2.size;
				float num14 = size.x;
				if (size.y < num14)
				{
					num14 = size.y;
				}
				if (size.z < num14)
				{
					num14 = size.z;
				}
				size.x = (size.y = (size.z = num14));
				size = Vector3.Lerp(size * targetFXInitialScale, size * targetFXEndScale, t);
				Quaternion q = Quaternion.LookRotation(cam.transform.position - rms[num5].transform.position);
				Quaternion quaternion = Quaternion.Euler(0f, 0f, num13 * targetFXRotationSpeed);
				q *= quaternion;
				Matrix4x4 matrix = Matrix4x4.TRS((targetFXCenter != null) ? targetFXCenter.transform.position : bounds2.center, q, size);
				Color color2 = targetFXColor;
				color2.a *= num2 * num12;
				Material material4 = fxMatTarget;
				material4.color = color2;
				material4.SetPass(0);
				Graphics.DrawMeshNow(quadMesh, matrix);
			}
			if (flag4 && ComputeSmoothQuadMatrix(cam, bounds))
			{
				if (flag2)
				{
					float num15 = glow * num2;
					fxMatComposeGlow.color = new Color(glowHQColor.r * num15, glowHQColor.g * num15, glowHQColor.b * num15, glowHQColor.a * num15);
					SmoothGlow(num3 / glowDownsampling, num4 / glowDownsampling);
				}
				if (flag3)
				{
					fxMatComposeOutline.color = new Color(outlineColor.r, outlineColor.g, outlineColor.b, 5f * outlineColor.a * outline * num2);
					SmoothOutline(num3 / outlineDownsampling, num4 / outlineDownsampling);
				}
				ComposeSmoothBlend(visibility, visibility2);
			}
		}

		private bool ComputeSmoothQuadMatrix(Camera cam, Bounds bounds)
		{
			Vector3 min = bounds.min;
			Vector3 max = bounds.max;
			corners[0] = new Vector3(min.x, min.y, min.z);
			corners[1] = new Vector3(min.x, min.y, max.z);
			corners[2] = new Vector3(max.x, min.y, min.z);
			corners[3] = new Vector3(max.x, min.y, max.z);
			corners[4] = new Vector3(min.x, max.y, min.z);
			corners[5] = new Vector3(min.x, max.y, max.z);
			corners[6] = new Vector3(max.x, max.y, min.z);
			corners[7] = new Vector3(max.x, max.y, max.z);
			Vector3 scrMin = new Vector3(float.MaxValue, float.MaxValue, 0f);
			Vector3 scrMax = new Vector3(float.MinValue, float.MinValue, 0f);
			float num = float.MaxValue;
			for (int i = 0; i < corners.Length; i++)
			{
				corners[i] = cam.WorldToScreenPoint(corners[i]);
				if (corners[i].x < scrMin.x)
				{
					scrMin.x = corners[i].x;
				}
				if (corners[i].y < scrMin.y)
				{
					scrMin.y = corners[i].y;
				}
				if (corners[i].x > scrMax.x)
				{
					scrMax.x = corners[i].x;
				}
				if (corners[i].y > scrMax.y)
				{
					scrMax.y = corners[i].y;
				}
				if (corners[i].z < num)
				{
					num = corners[i].z;
					if (num < cam.nearClipPlane)
					{
						scrMin.x = (scrMin.y = 0f);
						scrMax.x = cam.pixelWidth;
						scrMax.y = cam.pixelHeight;
						break;
					}
				}
			}
			if (scrMax.y == scrMin.y)
			{
				return false;
			}
			if (num < cam.nearClipPlane)
			{
				num = cam.nearClipPlane + 0.01f;
			}
			scrMin.z = (scrMax.z = num);
			if (outline > 0f)
			{
				BuildMatrix(cam, scrMin, scrMax, (int)(10f + 20f * outlineWidth + (float)(5 * outlineDownsampling)), ref quadOutlineMatrix);
			}
			if (glow > 0f)
			{
				BuildMatrix(cam, scrMin, scrMax, (int)(20f + 30f * glowWidth + (float)(10 * glowDownsampling)), ref quadGlowMatrix);
			}
			return true;
		}

		private void BuildMatrix(Camera cam, Vector3 scrMin, Vector3 scrMax, int border, ref Matrix4x4 quadMatrix)
		{
			scrMin.x -= border;
			scrMin.y -= border;
			scrMax.x += border;
			scrMax.y += border;
			Vector3 position = new Vector3(scrMax.x, scrMin.y, scrMin.z);
			scrMin = cam.ScreenToWorldPoint(scrMin);
			scrMax = cam.ScreenToWorldPoint(scrMax);
			position = cam.ScreenToWorldPoint(position);
			float x = Vector3.Distance(scrMin, position);
			float y = Vector3.Distance(scrMax, position);
			quadMatrix = Matrix4x4.TRS((scrMin + scrMax) * 0.5f, cam.transform.rotation, new Vector3(x, y, 1f));
		}

		private void SmoothGlow(int rtWidth, int rtHeight)
		{
			int num = 8;
			if (mipGlowBuffers == null || mipGlowBuffers.Length != num)
			{
				mipGlowBuffers = new int[num];
				for (int i = 0; i < num; i++)
				{
					mipGlowBuffers[i] = Shader.PropertyToID("_HPSmoothGlowTemp" + i);
				}
				glowRT = Shader.PropertyToID("_HPComposeGlowFinal");
				mipGlowBuffers[num - 2] = glowRT;
			}
			RenderTextureDescriptor desc = sourceDesc;
			desc.depthBufferBits = 0;
			if (desc.vrUsage == VRTextureUsage.TwoEyes)
			{
				desc.vrUsage = VRTextureUsage.None;
				fxMatBlurGlow.SetFloat("_StereoRendering", 0.5f);
				fxMatComposeGlow.SetFloat("_StereoRendering", 0.5f);
			}
			else
			{
				fxMatBlurGlow.SetFloat("_StereoRendering", 1f);
				fxMatComposeGlow.SetFloat("_StereoRendering", 1f);
			}
			for (int j = 0; j < num; j++)
			{
				float num2 = j / 2 + 2;
				int num3 = (int)((float)rtWidth / num2);
				int num4 = (int)((float)rtHeight / num2);
				if (num3 <= 0)
				{
					num3 = 1;
				}
				if (num4 <= 0)
				{
					num4 = 1;
				}
				desc.width = num3;
				desc.height = num4;
				cbSmoothBlend.GetTemporaryRT(mipGlowBuffers[j], desc, FilterMode.Bilinear);
			}
			Material mat = fxMatBlurGlow;
			for (int k = 0; k < num - 1; k += 2)
			{
				if (k == 0)
				{
					cbSmoothBlend.Blit(sourceRT, mipGlowBuffers[k + 1], mat, 0);
				}
				else
				{
					cbSmoothBlend.Blit(mipGlowBuffers[k], mipGlowBuffers[k + 1], mat, 0);
				}
				cbSmoothBlend.Blit(mipGlowBuffers[k + 1], mipGlowBuffers[k], mat, 1);
				if (k < num - 2)
				{
					cbSmoothBlend.Blit(mipGlowBuffers[k], mipGlowBuffers[k + 2], mat, 2);
				}
			}
		}

		private void SmoothOutline(int rtWidth, int rtHeight)
		{
			int num = 4;
			if (mipOutlineBuffers == null || mipOutlineBuffers.Length != num)
			{
				mipOutlineBuffers = new int[num];
				for (int i = 0; i < num; i++)
				{
					mipOutlineBuffers[i] = Shader.PropertyToID("_HPSmoothOutlineTemp" + i);
				}
				outlineRT = Shader.PropertyToID("_HPComposeOutlineFinal");
				mipOutlineBuffers[num - 2] = outlineRT;
			}
			RenderTextureDescriptor desc = sourceDesc;
			desc.depthBufferBits = 0;
			if (desc.vrUsage == VRTextureUsage.TwoEyes)
			{
				desc.vrUsage = VRTextureUsage.None;
				fxMatBlurOutline.SetFloat("_StereoRendering", 0.5f);
				fxMatComposeOutline.SetFloat("_StereoRendering", 0.5f);
			}
			else
			{
				fxMatBlurOutline.SetFloat("_StereoRendering", 1f);
				fxMatComposeOutline.SetFloat("_StereoRendering", 1f);
			}
			for (int j = 0; j < num; j++)
			{
				float num2 = j / 2 + 2;
				int num3 = (int)((float)rtWidth / num2);
				int num4 = (int)((float)rtHeight / num2);
				if (num3 <= 0)
				{
					num3 = 1;
				}
				if (num4 <= 0)
				{
					num4 = 1;
				}
				desc.width = num3;
				desc.height = num4;
				cbSmoothBlend.GetTemporaryRT(mipOutlineBuffers[j], desc, FilterMode.Bilinear);
			}
			Material mat = fxMatBlurOutline;
			for (int k = 0; k < num - 1; k += 2)
			{
				if (k == 0)
				{
					cbSmoothBlend.Blit(sourceRT, mipOutlineBuffers[k + 1], mat, 0);
				}
				else
				{
					cbSmoothBlend.Blit(mipOutlineBuffers[k], mipOutlineBuffers[k + 1], mat, 0);
				}
				cbSmoothBlend.Blit(mipOutlineBuffers[k + 1], mipOutlineBuffers[k], mat, 1);
				if (k < num - 2)
				{
					cbSmoothBlend.Blit(mipOutlineBuffers[k], mipOutlineBuffers[k + 2], mat, 2);
				}
			}
		}

		private void ComposeSmoothBlend(Visibility smoothGlowVisibility, Visibility smoothOutlineVisibility)
		{
			int num;
			if (glow > 0f)
			{
				num = ((glowQuality == QualityLevel.Highest) ? 1 : 0);
				if (num != 0)
				{
					Material material = fxMatComposeGlow;
					material.SetVector("_Flip", (XRSettings.enabled && flipY) ? new Vector3(1f, -1f, 0f) : new Vector3(0f, 1f, 0f));
					if (glowOptimalBlit)
					{
						cbSmoothBlend.SetRenderTarget(BuiltinRenderTextureType.CameraTarget);
						material.SetInt("_ZTest", GetZTestValue(smoothGlowVisibility));
						material.SetColor("_Debug", glowBlitDebug ? debugColor : blackColor);
						cbSmoothBlend.DrawMesh(quadMesh, quadGlowMatrix, material, 0, 0);
					}
					else
					{
						cbSmoothBlend.Blit(glowRT, BuiltinRenderTextureType.CameraTarget, material, 1);
					}
				}
			}
			else
			{
				num = 0;
			}
			bool flag = outline > 0f && outlineQuality == QualityLevel.Highest;
			if (flag)
			{
				Material material2 = fxMatComposeOutline;
				material2.SetVector("_Flip", (XRSettings.enabled && flipY) ? new Vector3(1f, -1f, 0f) : new Vector3(0f, 1f, 0f));
				if (outlineOptimalBlit)
				{
					cbSmoothBlend.SetRenderTarget(BuiltinRenderTextureType.CameraTarget);
					material2.SetInt("_ZTest", GetZTestValue(smoothOutlineVisibility));
					material2.SetColor("_Debug", outlineBlitDebug ? debugColor : blackColor);
					cbSmoothBlend.DrawMesh(quadMesh, quadOutlineMatrix, material2, 0, 0);
				}
				else
				{
					cbSmoothBlend.Blit(outlineRT, BuiltinRenderTextureType.CameraTarget, material2, 1);
				}
			}
			if (num != 0)
			{
				for (int i = 0; i < mipGlowBuffers.Length; i++)
				{
					cbSmoothBlend.ReleaseTemporaryRT(mipGlowBuffers[i]);
				}
			}
			if (flag)
			{
				for (int j = 0; j < mipOutlineBuffers.Length; j++)
				{
					cbSmoothBlend.ReleaseTemporaryRT(mipOutlineBuffers[j]);
				}
			}
			cbSmoothBlend.ReleaseTemporaryRT(sourceRT);
			Graphics.ExecuteCommandBuffer(cbSmoothBlend);
		}

		private void InitMaterial(ref Material material, string shaderName)
		{
			if (material == null)
			{
				Shader shader = Shader.Find(shaderName);
				if (shader == null)
				{
					UnityEngine.Debug.LogError("Shader " + shaderName + " not found.");
					base.enabled = false;
				}
				else
				{
					material = new Material(shader);
				}
			}
		}

		public void SetTarget(Transform transform)
		{
			if (!(transform == target) && !(transform == null))
			{
				if (_highlighted)
				{
					SetHighlighted(state: false);
				}
				target = transform;
				SetupMaterial();
			}
		}

		public void SetHighlighted(bool state)
		{
			if (!Application.isPlaying)
			{
				_highlighted = state;
				return;
			}
			if (fading == FadingState.NoFading)
			{
				fadeStartTime = Time.time;
			}
			if (state && !ignore)
			{
				if ((_highlighted && fading == FadingState.NoFading) || (this.OnObjectHighlightStart != null && !this.OnObjectHighlightStart(base.gameObject)))
				{
					return;
				}
				SendMessage("HighlightStart", null, SendMessageOptions.DontRequireReceiver);
				highlightStartTime = Time.time;
				if (fadeInDuration > 0f)
				{
					if (fading == FadingState.FadingOut)
					{
						float num = fadeOutDuration - (Time.time - fadeStartTime);
						fadeStartTime = Time.time - num;
					}
					fading = FadingState.FadingIn;
				}
				else
				{
					fading = FadingState.NoFading;
				}
				_highlighted = true;
				requireUpdateMaterial = true;
			}
			else
			{
				if (!_highlighted)
				{
					return;
				}
				if (fadeOutDuration > 0f)
				{
					if (fading == FadingState.FadingIn)
					{
						float num2 = Time.time - fadeStartTime;
						fadeStartTime = Time.time + num2 - fadeInDuration;
					}
					fading = FadingState.FadingOut;
					return;
				}
				fading = FadingState.NoFading;
				_highlighted = false;
				if (this.OnObjectHighlightEnd != null)
				{
					this.OnObjectHighlightEnd(base.gameObject);
				}
				SendMessage("HighlightEnd", null, SendMessageOptions.DontRequireReceiver);
				requireUpdateMaterial = true;
			}
		}

		private void SetupMaterial()
		{
			if (target == null || fxMatMask == null)
			{
				return;
			}
			Renderer[] array = null;
			switch (effectGroup)
			{
			case TargetOptions.OnlyThisObject:
			{
				Renderer component2 = target.GetComponent<Renderer>();
				if (component2 != null)
				{
					array = new Renderer[1] { component2 };
				}
				break;
			}
			case TargetOptions.RootToChildren:
			{
				Transform parent = target;
				while (parent.parent != null)
				{
					parent = parent.parent;
				}
				array = parent.GetComponentsInChildren<Renderer>();
				break;
			}
			case TargetOptions.LayerInScene:
			{
				HighlightEffect highlightEffect2 = this;
				if (target != base.transform)
				{
					HighlightEffect component3 = target.GetComponent<HighlightEffect>();
					if (component3 != null)
					{
						highlightEffect2 = component3;
					}
				}
				array = FindRenderersWithLayerInScene(highlightEffect2.effectGroupLayer);
				break;
			}
			case TargetOptions.LayerInChildren:
			{
				HighlightEffect highlightEffect = this;
				if (target != base.transform)
				{
					HighlightEffect component = target.GetComponent<HighlightEffect>();
					if (component != null)
					{
						highlightEffect = component;
					}
				}
				array = FindRenderersWithLayerInChildren(highlightEffect.effectGroupLayer);
				break;
			}
			default:
				array = target.GetComponentsInChildren<Renderer>();
				break;
			}
			if (array == null)
			{
				array = new Renderer[0];
			}
			if (rms == null || rms.Length < array.Length)
			{
				rms = new ModelMaterials[array.Length];
			}
			rmsCount = 0;
			for (int i = 0; i < array.Length; i++)
			{
				rms[rmsCount] = default(ModelMaterials);
				Renderer renderer = array[i];
				rms[rmsCount].renderer = renderer;
				rms[rmsCount].renderWasVisibleDuringSetup = renderer.isVisible;
				if (renderer.transform != target)
				{
					HighlightEffect component4 = renderer.GetComponent<HighlightEffect>();
					if (component4 != null && component4.enabled)
					{
						component4.highlighted = highlighted;
						continue;
					}
				}
				if (this.OnRendererHighlightStart != null && !this.OnRendererHighlightStart(renderer))
				{
					rmsCount++;
					continue;
				}
				if (renderer is SkinnedMeshRenderer)
				{
					rms[rmsCount].skinnedMesh = true;
					rms[rmsCount].mesh = ((SkinnedMeshRenderer)renderer).sharedMesh;
					CheckCommandBuffers();
				}
				else if (Application.isPlaying && renderer.isPartOfStaticBatch)
				{
					MeshCollider component5 = renderer.GetComponent<MeshCollider>();
					if (component5 != null)
					{
						rms[rmsCount].mesh = component5.sharedMesh;
					}
				}
				else
				{
					MeshFilter component6 = renderer.GetComponent<MeshFilter>();
					if (component6 != null)
					{
						rms[rmsCount].mesh = component6.sharedMesh;
					}
				}
				if (rms[rmsCount].mesh == null)
				{
					continue;
				}
				rms[rmsCount].transform = renderer.transform;
				rms[rmsCount].fxMatMask = Fork(fxMatMask, rms[rmsCount].mesh);
				rms[rmsCount].fxMatSeeThroughInner = Fork(fxMatSeeThroughInner, rms[rmsCount].mesh);
				rms[rmsCount].fxMatSeeThroughBorder = Fork(fxMatSeeThroughBorder, rms[rmsCount].mesh);
				rms[rmsCount].fxMatOverlay = Fork(fxMatOverlay, rms[rmsCount].mesh);
				rms[rmsCount].fxMatInnerGlow = Fork(fxMatInnerGlow, rms[rmsCount].mesh);
				rms[rmsCount].fxMatSolidColor = Fork(fxMatSolidColor, rms[rmsCount].mesh);
				rms[rmsCount].originalMesh = rms[rmsCount].mesh;
				if (!rms[rmsCount].skinnedMesh)
				{
					if (innerGlow > 0f || (glow > 0f && glowQuality != QualityLevel.Highest) || (outline > 0f && outlineQuality != QualityLevel.Highest))
					{
						AverageNormals(rmsCount);
					}
					BakeTransform(rmsCount, duplicateMesh: true);
				}
				rmsCount++;
			}
			UpdateMaterialPropertiesNow();
		}

		private Renderer[] FindRenderersWithLayerInScene(LayerMask layer)
		{
			Renderer[] array = UnityEngine.Object.FindObjectsOfType<Renderer>();
			if (tempRR == null)
			{
				tempRR = new List<Renderer>();
			}
			else
			{
				tempRR.Clear();
			}
			foreach (Renderer renderer in array)
			{
				if (((1 << renderer.gameObject.layer) & (int)layer) != 0)
				{
					tempRR.Add(renderer);
				}
			}
			return tempRR.ToArray();
		}

		private Renderer[] FindRenderersWithLayerInChildren(LayerMask layer)
		{
			Renderer[] componentsInChildren = target.GetComponentsInChildren<Renderer>();
			if (tempRR == null)
			{
				tempRR = new List<Renderer>();
			}
			else
			{
				tempRR.Clear();
			}
			foreach (Renderer renderer in componentsInChildren)
			{
				if (((1 << renderer.gameObject.layer) & (int)layer) != 0)
				{
					tempRR.Add(renderer);
				}
			}
			return tempRR.ToArray();
		}

		private void CheckGeometrySupportDependencies()
		{
			InitMaterial(ref fxMatMask, "HighlightPlus/Geometry/Mask");
			InitMaterial(ref fxMatOverlay, "HighlightPlus/Geometry/Overlay");
			InitMaterial(ref fxMatSeeThroughInner, "HighlightPlus/Geometry/SeeThroughInner");
			InitMaterial(ref fxMatSeeThroughBorder, "HighlightPlus/Geometry/SeeThroughBorder");
			InitMaterial(ref fxMatSolidColor, "HighlightPlus/Geometry/SolidColor");
			InitMaterial(ref fxMatOutlineRef, "HighlightPlus/Geometry/Outline");
			InitMaterial(ref fxMatGlowRef, "HighlightPlus/Geometry/Glow");
			InitMaterial(ref fxMatInnerGlow, "HighlightPlus/Geometry/InnerGlow");
			InitMaterial(ref fxMatTargetRef, "HighlightPlus/Geometry/Target");
			InitMaterial(ref fxMatComposeOutlineRef, "HighlightPlus/Geometry/ComposeOutline");
			InitMaterial(ref fxMatComposeGlowRef, "HighlightPlus/Geometry/ComposeGlow");
			InitMaterial(ref fxMatBlurOutlineRef, "HighlightPlus/Geometry/BlurOutline");
			InitMaterial(ref fxMatBlurGlowRef, "HighlightPlus/Geometry/BlurGlow");
		}

		private void CheckCommandBuffers()
		{
			if (cbMask == null)
			{
				cbMask = new CommandBuffer();
				cbMask.name = "Mask";
			}
			if (cbSeeThrough == null)
			{
				cbSeeThrough = new CommandBuffer();
				cbSeeThrough.name = "See Through";
			}
			if (cbGlow == null)
			{
				cbGlow = new CommandBuffer();
				cbGlow.name = "Outer Glow";
			}
			if (cbOutline == null)
			{
				cbOutline = new CommandBuffer();
				cbOutline.name = "Outline";
			}
			if (cbOverlay == null)
			{
				cbOverlay = new CommandBuffer();
				cbOverlay.name = "Overlay";
			}
			if (cbInnerGlow == null)
			{
				cbInnerGlow = new CommandBuffer();
				cbInnerGlow.name = "Inner Glow";
			}
		}

		private void CheckBlurCommandBuffer()
		{
			if (cbSmoothBlend == null)
			{
				cbSmoothBlend = new CommandBuffer();
				cbSmoothBlend.name = "Smooth Blend";
			}
		}

		private Material[] Fork(Material mat, Mesh mesh)
		{
			if (mesh == null)
			{
				return null;
			}
			int subMeshCount = mesh.subMeshCount;
			Material[] array = new Material[subMeshCount];
			for (int i = 0; i < subMeshCount; i++)
			{
				array[i] = UnityEngine.Object.Instantiate(mat);
			}
			return array;
		}

		private void BakeTransform(int objIndex, bool duplicateMesh)
		{
			if (rms[objIndex].mesh == null)
			{
				return;
			}
			Transform transform = rms[objIndex].transform;
			Vector3 localScale = transform.localScale;
			if (localScale.x >= 0f && localScale.y >= 0f && localScale.z >= 0f)
			{
				rms[objIndex].bakedTransform = false;
				return;
			}
			Mesh mesh = (duplicateMesh ? UnityEngine.Object.Instantiate(rms[objIndex].originalMesh) : rms[objIndex].mesh);
			Vector3[] array = mesh.vertices;
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = transform.TransformPoint(array[i]);
			}
			mesh.vertices = array;
			Vector3[] array2 = mesh.normals;
			if (array2 != null)
			{
				for (int j = 0; j < array2.Length; j++)
				{
					array2[j] = transform.TransformVector(array2[j]).normalized;
				}
				mesh.normals = array2;
			}
			mesh.RecalculateBounds();
			rms[objIndex].mesh = mesh;
			rms[objIndex].bakedTransform = true;
			rms[objIndex].currentPosition = transform.position;
			rms[objIndex].currentRotation = transform.eulerAngles;
			rms[objIndex].currentScale = transform.lossyScale;
		}

		public void UpdateMaterialProperties(bool forceNow = false)
		{
			if (forceNow || !Application.isPlaying)
			{
				UpdateMaterialPropertiesNow();
			}
			else
			{
				requireUpdateMaterial = true;
			}
		}

		private void UpdateMaterialPropertiesNow()
		{
			if (rms == null)
			{
				return;
			}
			if (ignore)
			{
				_highlighted = false;
			}
			Color value = seeThroughTintColor;
			value.a = seeThroughTintAlpha;
			if (lastOutlineVisibility != outlineVisibility)
			{
				if (glowQuality == QualityLevel.Highest && outlineQuality == QualityLevel.Highest)
				{
					glowVisibility = outlineVisibility;
				}
				lastOutlineVisibility = outlineVisibility;
			}
			if (outlineWidth < 0f)
			{
				outlineWidth = 0f;
			}
			if (glowWidth < 0f)
			{
				glowWidth = 0f;
			}
			if (overlay < overlayMinIntensity)
			{
				overlay = overlayMinIntensity;
			}
			if (targetFXTransitionDuration <= 0f)
			{
				targetFXTransitionDuration = 0.0001f;
			}
			if (targetFXStayDuration <= 0f)
			{
				targetFXStayDuration = 0.0001f;
			}
			if (seeThroughBorderWidth < 0f)
			{
				seeThroughBorderWidth = 0f;
			}
			bool flag = glow > 0f && glowQuality == QualityLevel.Highest;
			if (flag)
			{
				CheckBlurCommandBuffer();
				fxMatComposeGlow.SetInt("_Cull", cullBackFaces ? 2 : 0);
				fxMatBlurGlow.SetFloat("_BlurScale", glowWidth / (float)glowDownsampling);
				fxMatBlurGlow.SetFloat("_Speed", glowAnimationSpeed);
			}
			if (outline > 0f && outlineQuality == QualityLevel.Highest)
			{
				CheckBlurCommandBuffer();
				fxMatComposeOutline.SetInt("_Cull", cullBackFaces ? 2 : 0);
				fxMatBlurOutline.SetFloat("_BlurScale", outlineWidth / (float)outlineDownsampling);
			}
			for (int i = 0; i < rmsCount; i++)
			{
				if (!(rms[i].mesh != null))
				{
					continue;
				}
				float value2 = ((outlineQuality == QualityLevel.High) ? 0f : (outlineWidth / 100f));
				Material material = fxMatOutline;
				material.SetFloat("_OutlineWidth", value2);
				material.SetVector("_OutlineDirection", Vector3.zero);
				material.SetInt("_OutlineZTest", GetZTestValue(outlineVisibility));
				material.SetInt("_Cull", cullBackFaces ? 2 : 0);
				material.SetFloat("_ConstantWidth", constantWidth ? 1f : 0f);
				Material material2 = fxMatGlow;
				material2.SetVector("_Glow2", new Vector3(outlineWidth / 100f, glowAnimationSpeed, (!glowDithering) ? 1 : 0));
				material2.SetInt("_GlowZTest", GetZTestValue(glowVisibility));
				material2.SetInt("_Cull", cullBackFaces ? 2 : 0);
				material2.SetFloat("_ConstantWidth", constantWidth ? 1f : 0f);
				if (glowBlendMode == GlowBlendMode.AlphaBlend)
				{
					fxMatComposeGlow.SetInt("_SrcBlend", 5);
					fxMatComposeGlow.SetInt("_DstBlend", 10);
				}
				else
				{
					fxMatComposeGlow.SetInt("_SrcBlend", 1);
					fxMatComposeGlow.SetInt("_DstBlend", 1);
				}
				if (targetFX)
				{
					if (targetFXTexture == null)
					{
						targetFXTexture = Resources.Load<Texture2D>("HighlightPlus/target");
					}
					fxMatTarget.mainTexture = targetFXTexture;
				}
				for (int j = 0; j < rms[i].mesh.subMeshCount; j++)
				{
					Renderer renderer = rms[i].renderer;
					if (renderer == null)
					{
						continue;
					}
					Material material3 = null;
					if (renderer.sharedMaterials != null && j < renderer.sharedMaterials.Length)
					{
						material3 = renderer.sharedMaterials[j];
					}
					if (material3 == null)
					{
						continue;
					}
					bool flag2 = material3.HasProperty("_MainTex");
					bool flag3 = alphaCutOff > 0f && flag2;
					if (rms[i].fxMatMask != null && rms[i].fxMatMask.Length > j)
					{
						Material material4 = rms[i].fxMatMask[j];
						if (material4 != null)
						{
							if (flag2)
							{
								Texture mainTexture = material3.mainTexture;
								material4.mainTexture = mainTexture;
								material4.mainTextureOffset = material3.mainTextureOffset;
								material4.mainTextureScale = material3.mainTextureScale;
							}
							if (flag3)
							{
								material4.SetFloat("_CutOff", alphaCutOff);
								material4.EnableKeyword("HP_ALPHACLIP");
							}
							else
							{
								material4.DisableKeyword("HP_ALPHACLIP");
							}
							if (depthClip)
							{
								material4.EnableKeyword("HP_DEPTHCLIP");
							}
							else
							{
								material4.DisableKeyword("HP_DEPTHCLIP");
							}
							material4.SetInt("_Cull", cullBackFaces ? 2 : 0);
						}
					}
					if (rms[i].fxMatSeeThroughInner != null && rms[i].fxMatSeeThroughInner.Length > j)
					{
						Material material5 = rms[i].fxMatSeeThroughInner[j];
						if (material5 != null)
						{
							material5.SetFloat("_SeeThrough", seeThroughIntensity);
							material5.SetFloat("_SeeThroughNoise", seeThroughNoise);
							material5.SetColor("_SeeThroughTintColor", value);
							material5.SetFloat("_SeeThroughBorderWidth", (seeThroughBorder * seeThroughBorderWidth > 0f) ? (seeThroughBorderWidth / 100f) : 0f);
							material5.SetFloat("_SeeThroughBorderConstantWidth", constantWidth ? 1f : 0f);
							if (flag2)
							{
								Texture mainTexture2 = material3.mainTexture;
								material5.mainTexture = mainTexture2;
								material5.mainTextureOffset = material3.mainTextureOffset;
								material5.mainTextureScale = material3.mainTextureScale;
							}
							if (flag3)
							{
								material5.SetFloat("_CutOff", alphaCutOff);
								material5.EnableKeyword("HP_ALPHACLIP");
							}
							else
							{
								material5.DisableKeyword("HP_ALPHACLIP");
							}
						}
					}
					if (rms[i].fxMatSeeThroughBorder != null && rms[i].fxMatSeeThroughBorder.Length > j)
					{
						Material material6 = rms[i].fxMatSeeThroughBorder[j];
						if (material6 != null)
						{
							material6.SetColor("_SeeThroughBorderColor", new Color(seeThroughBorderColor.r, seeThroughBorderColor.g, seeThroughBorderColor.b, seeThroughBorder));
							if (flag2)
							{
								Texture mainTexture3 = material3.mainTexture;
								material6.mainTexture = mainTexture3;
								material6.mainTextureOffset = material3.mainTextureOffset;
								material6.mainTextureScale = material3.mainTextureScale;
							}
							if (flag3)
							{
								material6.SetFloat("_CutOff", alphaCutOff);
								material6.EnableKeyword("HP_ALPHACLIP");
							}
							else
							{
								material6.DisableKeyword("HP_ALPHACLIP");
							}
						}
					}
					if (rms[i].fxMatOverlay != null && rms[i].fxMatOverlay.Length > j)
					{
						Material material7 = rms[i].fxMatOverlay[j];
						if (material7 != null)
						{
							if (flag2)
							{
								Texture mainTexture4 = material3.mainTexture;
								material7.mainTexture = mainTexture4;
								material7.mainTextureOffset = material3.mainTextureOffset;
								material7.mainTextureScale = material3.mainTextureScale;
							}
							if (material3.HasProperty("_Color"))
							{
								material7.SetColor("_OverlayBackColor", material3.GetColor("_Color"));
							}
							if (flag3)
							{
								material7.SetFloat("_CutOff", alphaCutOff);
								material7.EnableKeyword("HP_ALPHACLIP");
							}
							else
							{
								material7.DisableKeyword("HP_ALPHACLIP");
							}
						}
					}
					if (rms[i].fxMatInnerGlow != null && rms[i].fxMatInnerGlow.Length > j)
					{
						Material material8 = rms[i].fxMatInnerGlow[j];
						if (material8 != null)
						{
							if (flag2)
							{
								Texture mainTexture5 = material3.mainTexture;
								material8.mainTexture = mainTexture5;
								material8.mainTextureOffset = material3.mainTextureOffset;
								material8.mainTextureScale = material3.mainTextureScale;
							}
							material8.SetFloat("_Width", innerGlowWidth);
							material8.SetInt("_InnerGlowZTest", GetZTestValue(innerGlowVisibility));
							if (flag3)
							{
								material8.SetFloat("_CutOff", alphaCutOff);
								material8.EnableKeyword("HP_ALPHACLIP");
							}
							else
							{
								material8.DisableKeyword("HP_ALPHACLIP");
							}
						}
					}
					if (rms[i].fxMatSolidColor == null || rms[i].fxMatSolidColor.Length <= j)
					{
						continue;
					}
					Material material9 = rms[i].fxMatSolidColor[j];
					if (material9 != null)
					{
						material9.color = glowHQColor;
						material9.SetInt("_Cull", cullBackFaces ? 2 : 0);
						material9.SetInt("_ZTest", GetZTestValue(flag ? glowVisibility : outlineVisibility));
						if (flag2)
						{
							Texture mainTexture6 = material3.mainTexture;
							material9.mainTexture = mainTexture6;
							material9.mainTextureOffset = material3.mainTextureOffset;
							material9.mainTextureScale = material3.mainTextureScale;
						}
						if (flag3)
						{
							material9.SetFloat("_CutOff", alphaCutOff);
							material9.EnableKeyword("HP_ALPHACLIP");
						}
						else
						{
							material9.DisableKeyword("HP_ALPHACLIP");
						}
						if (depthClip)
						{
							material9.EnableKeyword("HP_DEPTHCLIP");
						}
						else
						{
							material9.DisableKeyword("HP_DEPTHCLIP");
						}
					}
				}
			}
		}

		private int GetZTestValue(Visibility param)
		{
			return param switch
			{
				Visibility.AlwaysOnTop => 8, 
				Visibility.OnlyWhenOccluded => 5, 
				_ => 4, 
			};
		}

		private void BuildQuad()
		{
			quadMesh = new Mesh();
			Vector3[] array = new Vector3[4];
			float num = 0.5f;
			float num2 = 0.5f;
			array[0] = new Vector3(0f - num2, 0f - num, 0f);
			array[1] = new Vector3(0f - num2, num, 0f);
			array[2] = new Vector3(num2, 0f - num, 0f);
			array[3] = new Vector3(num2, num, 0f);
			Vector2[] array2 = new Vector2[array.Length];
			array2[0] = new Vector2(0f, 0f);
			array2[1] = new Vector2(0f, 1f);
			array2[2] = new Vector2(1f, 0f);
			array2[3] = new Vector2(1f, 1f);
			int[] triangles = new int[6] { 0, 1, 2, 3, 2, 1 };
			Vector3[] array3 = new Vector3[array.Length];
			for (int i = 0; i < array3.Length; i++)
			{
				array3[i] = Vector3.forward;
			}
			quadMesh.vertices = array;
			quadMesh.uv = array2;
			quadMesh.triangles = triangles;
			quadMesh.normals = array3;
			quadMesh.RecalculateBounds();
		}

		private bool CheckOcclusion(Camera cam)
		{
			if (Time.time - occlusionCheckLastTime < seeThroughOccluderCheckInterval)
			{
				return lastOcclusionTestResult;
			}
			occlusionCheckLastTime = Time.time;
			if (rms.Length == 0 || rms[0].renderer == null)
			{
				return false;
			}
			Vector3 position = cam.transform.position;
			Bounds bounds = rms[0].renderer.bounds;
			for (int i = 1; i < rms.Length; i++)
			{
				if (rms[i].renderer != null)
				{
					bounds.Encapsulate(rms[i].renderer.bounds);
				}
			}
			Vector3 center = bounds.center;
			Vector3 vector = center - position;
			float maxDistance = Vector3.Distance(center, position);
			lastOcclusionTestResult = Physics.BoxCast(center - vector, bounds.extents * seeThroughOccluderThreshold, vector.normalized, Quaternion.identity, maxDistance, seeThroughOccluderMask);
			return lastOcclusionTestResult;
		}

		private void AverageNormals(int objIndex)
		{
			if (rms == null || objIndex >= rms.Length)
			{
				return;
			}
			Mesh mesh = rms[objIndex].mesh;
			if (!smoothMeshes.TryGetValue(mesh, out var value))
			{
				if (!mesh.isReadable)
				{
					return;
				}
				if (normals == null)
				{
					normals = new List<Vector3>();
				}
				else
				{
					normals.Clear();
				}
				mesh.GetNormals(normals);
				int count = normals.Count;
				if (count == 0)
				{
					return;
				}
				if (vertices == null)
				{
					vertices = new List<Vector3>();
				}
				else
				{
					vertices.Clear();
				}
				mesh.GetVertices(vertices);
				int num = vertices.Count;
				if (count < num)
				{
					num = count;
				}
				if (newNormals == null || newNormals.Length < num)
				{
					newNormals = new Vector3[num];
				}
				else
				{
					Vector3 zero = Vector3.zero;
					for (int i = 0; i < num; i++)
					{
						newNormals[i] = zero;
					}
				}
				if (matches == null || matches.Length < num)
				{
					matches = new int[num];
				}
				vv.Clear();
				for (int j = 0; j < num; j++)
				{
					Vector3 key = vertices[j];
					if (!vv.TryGetValue(key, out var value2))
					{
						value2 = (vv[key] = j);
					}
					matches[j] = value2;
				}
				for (int k = 0; k < num; k++)
				{
					int num3 = matches[k];
					newNormals[num3] += normals[k];
				}
				for (int l = 0; l < num; l++)
				{
					int num4 = matches[l];
					normals[l] = newNormals[num4].normalized;
				}
				value = UnityEngine.Object.Instantiate(mesh);
				value.hideFlags = HideFlags.DontSave;
				value.SetNormals(normals);
				smoothMeshes[mesh] = value;
			}
			rms[objIndex].mesh = value;
		}

		public void OverlayOneShot(Color color, float duration)
		{
			if (duration != 0f)
			{
				if (overlayOneShotRunning)
				{
					OverlayOneShotEnd();
					StopCoroutine(overlayOneShotCo);
				}
				overlayOneShotRunning = true;
				overlayOneShotCurrentOverlay = overlay;
				overlayOneShotCurrentColor = overlayColor;
				overlayOneShotCurrentAnimationSpeed = overlayAnimationSpeed;
				overlayOneShotCurrentOuterGlow = glow;
				overlayOneShotCurrentInnerGlow = innerGlow;
				overlayOneShotCurrentOutline = outline;
				overlayOneShotCurrentSeeThroughIntensity = seeThroughIntensity;
				currentHighlighted = _highlighted;
				if (!currentHighlighted)
				{
					glow = (innerGlow = (outline = (seeThroughIntensity = 0f)));
				}
				overlayOneShotCo = StartCoroutine(OverlayOneShotAnimator(color, duration));
			}
		}

		private IEnumerator OverlayOneShotAnimator(Color color, float duration)
		{
			overlayAnimationSpeed = 0f;
			float startTime = Time.time;
			float t = 1f;
			highlighted = true;
			overlayColor = color;
			overlayAnimationSpeed = 0f;
			WaitForEndOfFrame ef = new WaitForEndOfFrame();
			while (t > 0f)
			{
				t = 1f - (Time.time - startTime) / duration;
				if (t < 0f)
				{
					t = 0f;
				}
				overlay = t;
				yield return ef;
			}
			OverlayOneShotEnd();
		}

		private void OverlayOneShotEnd()
		{
			overlay = overlayOneShotCurrentOverlay;
			overlayColor = overlayOneShotCurrentColor;
			overlayAnimationSpeed = overlayOneShotCurrentAnimationSpeed;
			if (!currentHighlighted)
			{
				glow = overlayOneShotCurrentOuterGlow;
				innerGlow = overlayOneShotCurrentInnerGlow;
				outline = overlayOneShotCurrentOutline;
				seeThroughIntensity = overlayOneShotCurrentSeeThroughIntensity;
				highlighted = false;
			}
			overlayOneShotRunning = false;
		}

		public static void RegisterOccluder(HighlightSeeThroughOccluder occluder)
		{
			if (!occluders.Contains(occluder))
			{
				occluders.Add(occluder);
			}
		}

		public static void UnregisterOccluder(HighlightSeeThroughOccluder occluder)
		{
			if (occluders.Contains(occluder))
			{
				occluders.Remove(occluder);
			}
		}

		public void RenderOccluders(Camera cam)
		{
			int count = occluders.Count;
			if (count == 0)
			{
				return;
			}
			occludersFrameCount.TryGetValue(cam, out var value);
			int frameCount = Time.frameCount;
			if (frameCount == value)
			{
				return;
			}
			occludersFrameCount[cam] = frameCount;
			if (cbOccluder == null)
			{
				cbOccluder = new CommandBuffer();
				cbOccluder.name = "Occluder";
			}
			if (fxMatOccluder == null)
			{
				InitMaterial(ref fxMatOccluder, "HighlightPlus/Geometry/SeeThroughOccluder");
				if (fxMatOccluder == null)
				{
					return;
				}
			}
			Vector3 position = cam.transform.position;
			cbOccluder.Clear();
			for (int i = 0; i < count; i++)
			{
				HighlightSeeThroughOccluder highlightSeeThroughOccluder = occluders[i];
				if (highlightSeeThroughOccluder == null || !highlightSeeThroughOccluder.isActiveAndEnabled)
				{
					continue;
				}
				if (highlightSeeThroughOccluder.detectionMethod == DetectionMethod.Stencil)
				{
					if (highlightSeeThroughOccluder.meshData == null || highlightSeeThroughOccluder.meshData.Length == 0)
					{
						continue;
					}
					for (int j = 0; j < highlightSeeThroughOccluder.meshData.Length; j++)
					{
						Renderer renderer = highlightSeeThroughOccluder.meshData[j].renderer;
						if (renderer.isVisible)
						{
							for (int k = 0; k < highlightSeeThroughOccluder.meshData[j].subMeshCount; k++)
							{
								cbOccluder.DrawRenderer(renderer, fxMatOccluder, k);
							}
						}
					}
				}
				else
				{
					if (rms.Length == 0 || rms[0].renderer == null)
					{
						continue;
					}
					Bounds bounds = rms[0].renderer.bounds;
					for (int l = 1; l < rms.Length; l++)
					{
						if (rms[l].renderer != null)
						{
							bounds.Encapsulate(rms[l].renderer.bounds);
						}
					}
					Vector3 center = bounds.center;
					Vector3 vector = center - position;
					if (Physics.BoxCast(maxDistance: Vector3.Distance(center, position), center: center - vector, halfExtents: bounds.extents * 0.9f, direction: vector.normalized, hitInfo: out var hitInfo, orientation: Quaternion.identity) && hitInfo.collider.transform == highlightSeeThroughOccluder.transform)
					{
						cancelSeeThroughThisFrame = true;
					}
				}
			}
			Graphics.ExecuteCommandBuffer(cbOccluder);
		}
	}
	[RequireComponent(typeof(HighlightEffect))]
	[HelpURL("https://kronnect.freshdesk.com/support/solutions/42000065090")]
	public class HighlightManager : MonoBehaviour
	{
		public LayerMask layerMask = -1;

		public Camera raycastCamera;

		public RayCastSource raycastSource;

		[Tooltip("Max Distance for target. 0 = infinity")]
		public float maxDistance;

		private HighlightEffect baseEffect;

		private HighlightEffect currentEffect;

		private Transform currentObject;

		private void OnEnable()
		{
			currentObject = null;
			currentEffect = null;
			if (baseEffect == null)
			{
				baseEffect = GetComponent<HighlightEffect>();
				if (baseEffect == null)
				{
					baseEffect = base.gameObject.AddComponent<HighlightEffect>();
				}
			}
			raycastCamera = GetComponent<Camera>();
			if (raycastCamera == null)
			{
				raycastCamera = GetCamera();
				if (raycastCamera == null)
				{
					UnityEngine.Debug.LogError("Highlight Manager: no camera found!");
				}
			}
		}

		private void OnDisable()
		{
			SwitchesCollider(null);
		}

		private void Update()
		{
			if (raycastCamera == null)
			{
				return;
			}
			Ray ray = ((raycastSource != 0) ? new Ray(raycastCamera.transform.position, raycastCamera.transform.forward) : raycastCamera.ScreenPointToRay(Input.mousePosition));
			if (Physics.Raycast(ray, out var hitInfo, (maxDistance > 0f) ? maxDistance : raycastCamera.farClipPlane, layerMask))
			{
				if (hitInfo.collider != currentObject)
				{
					SwitchesCollider(hitInfo.collider.transform);
				}
			}
			else
			{
				SwitchesCollider(null);
			}
		}

		private void SwitchesCollider(Transform newObject)
		{
			if (currentEffect != null)
			{
				currentEffect.SetHighlighted(state: false);
				currentEffect = null;
			}
			currentObject = newObject;
			if (!(newObject == null))
			{
				HighlightTrigger component = newObject.GetComponent<HighlightTrigger>();
				if (!(component != null) || !component.enabled)
				{
					HighlightEffect component2 = newObject.GetComponent<HighlightEffect>();
					currentEffect = ((component2 != null) ? component2 : baseEffect);
					currentEffect.SetTarget(currentObject.transform);
					currentEffect.SetHighlighted(state: true);
				}
			}
		}

		public static Camera GetCamera()
		{
			Camera camera = Camera.main;
			if (camera == null)
			{
				camera = UnityEngine.Object.FindObjectOfType<Camera>();
			}
			return camera;
		}
	}
	[CreateAssetMenu(menuName = "Highlight Plus Profile", fileName = "Highlight Plus Profile", order = 100)]
	[HelpURL("https://kronnect.freshdesk.com/support/solutions/42000065090")]
	public class HighlightProfile : ScriptableObject
	{
		public TargetOptions effectGroup;

		public LayerMask effectGroupLayer = -1;

		[Range(0f, 1f)]
		public float alphaCutOff;

		public bool cullBackFaces = true;

		public bool depthClip;

		public float fadeInDuration;

		public float fadeOutDuration;

		[Range(0f, 1f)]
		public float overlay = 0.5f;

		public Color overlayColor = Color.yellow;

		public float overlayAnimationSpeed = 1f;

		[Range(0f, 1f)]
		public float overlayMinIntensity = 0.5f;

		[Range(0f, 1f)]
		public float overlayBlending = 1f;

		[Range(0f, 1f)]
		public float outline = 1f;

		public Color outlineColor = Color.black;

		public float outlineWidth = 0.45f;

		public QualityLevel outlineQuality = QualityLevel.High;

		[Range(1f, 8f)]
		public int outlineDownsampling = 2;

		public bool outlineOptimalBlit = true;

		public Visibility outlineVisibility;

		public bool outlineIndependent;

		[Range(0f, 5f)]
		public float glow = 1f;

		public float glowWidth = 0.4f;

		public QualityLevel glowQuality = QualityLevel.High;

		[Range(1f, 8f)]
		public int glowDownsampling = 2;

		public Color glowHQColor = new Color(0.64f, 1f, 0f, 1f);

		public bool glowDithering = true;

		public GlowBlendMode glowBlendMode;

		public bool glowOptimalBlit = true;

		public float glowMagicNumber1 = 0.75f;

		public float glowMagicNumber2 = 0.5f;

		public float glowAnimationSpeed = 1f;

		public Visibility glowVisibility;

		public GlowPassData[] glowPasses;

		[Range(0f, 5f)]
		public float innerGlow;

		[Range(0f, 2f)]
		public float innerGlowWidth = 1f;

		public Color innerGlowColor = Color.white;

		public Visibility innerGlowVisibility;

		public bool targetFX;

		public Texture2D targetFXTexture;

		public Color targetFXColor = Color.white;

		public float targetFXRotationSpeed = 50f;

		public float targetFXInitialScale = 4f;

		public float targetFXEndScale = 1.5f;

		public float targetFXTransitionDuration = 0.5f;

		public float targetFXStayDuration = 1.5f;

		public SeeThroughMode seeThrough;

		public LayerMask seeThroughOccluderMask = -1;

		[Range(0.01f, 0.9f)]
		public float seeThroughOccluderThreshold = 0.4f;

		public float seeThroughOccluderCheckInterval = 1f;

		[Range(0f, 5f)]
		public float seeThroughIntensity = 0.8f;

		[Range(0f, 1f)]
		public float seeThroughTintAlpha = 0.5f;

		public Color seeThroughTintColor = Color.red;

		[Range(0f, 1f)]
		public float seeThroughNoise = 1f;

		[Range(0f, 1f)]
		public float seeThroughBorder;

		public Color seeThroughBorderColor = Color.black;

		public float seeThroughBorderWidth = 0.45f;

		public void Load(HighlightEffect effect)
		{
			effect.effectGroup = effectGroup;
			effect.effectGroupLayer = effectGroupLayer;
			effect.alphaCutOff = alphaCutOff;
			effect.cullBackFaces = cullBackFaces;
			effect.depthClip = depthClip;
			effect.fadeInDuration = fadeInDuration;
			effect.fadeOutDuration = fadeOutDuration;
			effect.overlay = overlay;
			effect.overlayColor = overlayColor;
			effect.overlayAnimationSpeed = overlayAnimationSpeed;
			effect.overlayMinIntensity = overlayMinIntensity;
			effect.overlayBlending = overlayBlending;
			effect.outline = outline;
			effect.outlineColor = outlineColor;
			effect.outlineWidth = outlineWidth;
			effect.outlineQuality = outlineQuality;
			effect.outlineOptimalBlit = outlineOptimalBlit;
			effect.outlineDownsampling = outlineDownsampling;
			effect.outlineVisibility = outlineVisibility;
			effect.outlineIndependent = outlineIndependent;
			effect.glow = glow;
			effect.glowWidth = glowWidth;
			effect.glowQuality = glowQuality;
			effect.glowOptimalBlit = glowOptimalBlit;
			effect.glowDownsampling = glowDownsampling;
			effect.glowHQColor = glowHQColor;
			effect.glowDithering = glowDithering;
			effect.glowMagicNumber1 = glowMagicNumber1;
			effect.glowMagicNumber2 = glowMagicNumber2;
			effect.glowAnimationSpeed = glowAnimationSpeed;
			effect.glowVisibility = glowVisibility;
			effect.glowBlendMode = glowBlendMode;
			effect.glowPasses = GetGlowPassesCopy(glowPasses);
			effect.innerGlow = innerGlow;
			effect.innerGlowWidth = innerGlowWidth;
			effect.innerGlowColor = innerGlowColor;
			effect.innerGlowVisibility = innerGlowVisibility;
			effect.targetFX = targetFX;
			effect.targetFXColor = targetFXColor;
			effect.targetFXEndScale = targetFXEndScale;
			effect.targetFXInitialScale = targetFXInitialScale;
			effect.targetFXRotationSpeed = targetFXRotationSpeed;
			effect.targetFXStayDuration = targetFXStayDuration;
			effect.targetFXTexture = targetFXTexture;
			effect.targetFXTransitionDuration = targetFXTransitionDuration;
			effect.seeThrough = seeThrough;
			effect.seeThroughOccluderMask = seeThroughOccluderMask;
			effect.seeThroughOccluderThreshold = seeThroughOccluderThreshold;
			effect.seeThroughOccluderCheckInterval = seeThroughOccluderCheckInterval;
			effect.seeThroughIntensity = seeThroughIntensity;
			effect.seeThroughTintAlpha = seeThroughTintAlpha;
			effect.seeThroughTintColor = seeThroughTintColor;
			effect.seeThroughNoise = seeThroughNoise;
			effect.seeThroughBorder = seeThroughBorder;
			effect.seeThroughBorderColor = seeThroughBorderColor;
			effect.seeThroughBorderWidth = seeThroughBorderWidth;
			effect.UpdateMaterialProperties();
		}

		public void Save(HighlightEffect effect)
		{
			effectGroup = effect.effectGroup;
			effectGroupLayer = effect.effectGroupLayer;
			alphaCutOff = effect.alphaCutOff;
			cullBackFaces = effect.cullBackFaces;
			depthClip = effect.depthClip;
			fadeInDuration = effect.fadeInDuration;
			fadeOutDuration = effect.fadeOutDuration;
			overlay = effect.overlay;
			overlayColor = effect.overlayColor;
			overlayAnimationSpeed = effect.overlayAnimationSpeed;
			overlayMinIntensity = effect.overlayMinIntensity;
			overlayBlending = effect.overlayBlending;
			outline = effect.outline;
			outlineColor = effect.outlineColor;
			outlineWidth = effect.outlineWidth;
			outlineQuality = effect.outlineQuality;
			outlineDownsampling = effect.outlineDownsampling;
			outlineVisibility = effect.outlineVisibility;
			outlineIndependent = effect.outlineIndependent;
			outlineOptimalBlit = effect.outlineOptimalBlit;
			glow = effect.glow;
			glowWidth = effect.glowWidth;
			glowQuality = effect.glowQuality;
			glowOptimalBlit = effect.glowOptimalBlit;
			glowDownsampling = effect.glowDownsampling;
			glowHQColor = effect.glowHQColor;
			glowDithering = effect.glowDithering;
			glowMagicNumber1 = effect.glowMagicNumber1;
			glowMagicNumber2 = effect.glowMagicNumber2;
			glowAnimationSpeed = effect.glowAnimationSpeed;
			glowVisibility = effect.glowVisibility;
			glowBlendMode = effect.glowBlendMode;
			glowPasses = GetGlowPassesCopy(effect.glowPasses);
			innerGlow = effect.innerGlow;
			innerGlowWidth = effect.innerGlowWidth;
			innerGlowColor = effect.innerGlowColor;
			innerGlowVisibility = effect.innerGlowVisibility;
			targetFX = effect.targetFX;
			targetFXColor = effect.targetFXColor;
			targetFXEndScale = effect.targetFXEndScale;
			targetFXInitialScale = effect.targetFXInitialScale;
			targetFXRotationSpeed = effect.targetFXRotationSpeed;
			targetFXStayDuration = effect.targetFXStayDuration;
			targetFXTexture = effect.targetFXTexture;
			targetFXTransitionDuration = effect.targetFXTransitionDuration;
			seeThrough = effect.seeThrough;
			seeThroughOccluderMask = effect.seeThroughOccluderMask;
			seeThroughOccluderThreshold = effect.seeThroughOccluderThreshold;
			seeThroughOccluderCheckInterval = effect.seeThroughOccluderCheckInterval;
			seeThroughIntensity = effect.seeThroughIntensity;
			seeThroughTintAlpha = effect.seeThroughTintAlpha;
			seeThroughTintColor = effect.seeThroughTintColor;
			seeThroughNoise = effect.seeThroughNoise;
			seeThroughBorder = effect.seeThroughBorder;
			seeThroughBorderColor = effect.seeThroughBorderColor;
			seeThroughBorderWidth = effect.seeThroughBorderWidth;
		}

		private GlowPassData[] GetGlowPassesCopy(GlowPassData[] glowPasses)
		{
			if (glowPasses == null)
			{
				return new GlowPassData[0];
			}
			GlowPassData[] array = new GlowPassData[glowPasses.Length];
			for (int i = 0; i < glowPasses.Length; i++)
			{
				array[i].alpha = glowPasses[i].alpha;
				array[i].color = glowPasses[i].color;
				array[i].offset = glowPasses[i].offset;
			}
			return array;
		}
	}
	public struct MeshData
	{
		public Renderer renderer;

		public int subMeshCount;
	}
	public enum DetectionMethod
	{
		Stencil,
		CapsuleCast
	}
	[HelpURL("https://kronnect.freshdesk.com/support/solutions/42000065090")]
	[ExecuteInEditMode]
	public class HighlightSeeThroughOccluder : MonoBehaviour
	{
		public DetectionMethod detectionMethod;

		[NonSerialized]
		public MeshData[] meshData;

		private List<Renderer> rr;

		private void OnEnable()
		{
			if (base.gameObject.activeInHierarchy)
			{
				Init();
			}
		}

		private void Init()
		{
			if (detectionMethod == DetectionMethod.CapsuleCast)
			{
				HighlightEffect.RegisterOccluder(this);
				return;
			}
			if (rr == null)
			{
				rr = new List<Renderer>();
			}
			else
			{
				rr.Clear();
			}
			GetComponentsInChildren(rr);
			int count = rr.Count;
			meshData = new MeshData[count];
			for (int i = 0; i < count; i++)
			{
				meshData[i].renderer = rr[i];
				meshData[i].subMeshCount = 1;
				if (rr[i] is MeshRenderer)
				{
					MeshFilter component = rr[i].GetComponent<MeshFilter>();
					if (component != null && component.sharedMesh != null)
					{
						meshData[i].subMeshCount = component.sharedMesh.subMeshCount;
					}
				}
				else if (rr[i] is SkinnedMeshRenderer)
				{
					SkinnedMeshRenderer skinnedMeshRenderer = (SkinnedMeshRenderer)rr[i];
					meshData[i].subMeshCount = skinnedMeshRenderer.sharedMesh.subMeshCount;
				}
			}
			if (count > 0)
			{
				HighlightEffect.RegisterOccluder(this);
			}
		}

		private void OnDisable()
		{
			HighlightEffect.UnregisterOccluder(this);
		}
	}
	public enum TriggerMode
	{
		ColliderEventsOnlyOnThisObject,
		RaycastOnThisObjectAndChildren
	}
	public enum RayCastSource
	{
		MousePosition,
		CameraDirection
	}
	[RequireComponent(typeof(HighlightEffect))]
	[HelpURL("https://kronnect.freshdesk.com/support/solutions/42000065090")]
	[ExecuteInEditMode]
	public class HighlightTrigger : MonoBehaviour
	{
		[Tooltip("Used to trigger automatic highlighting including children objects.")]
		public TriggerMode triggerMode;

		public Camera raycastCamera;

		public RayCastSource raycastSource;

		public float maxDistance;

		private const int MAX_RAYCAST_HITS = 100;

		[NonSerialized]
		public Collider[] colliders;

		private Collider currentCollider;

		private static RaycastHit[] hits;

		private void OnEnable()
		{
			Init();
		}

		private void Start()
		{
			if (triggerMode == TriggerMode.RaycastOnThisObjectAndChildren)
			{
				if (raycastCamera == null)
				{
					raycastCamera = HighlightManager.GetCamera();
					if (raycastCamera == null)
					{
						UnityEngine.Debug.LogError("Highlight Trigger on " + base.gameObject.name + ": no camera found!");
					}
				}
				if (colliders != null && colliders.Length != 0)
				{
					hits = new RaycastHit[100];
					StartCoroutine(DoRayCast());
				}
			}
			else if (GetComponent<Collider>() == null && GetComponent<MeshFilter>() != null)
			{
				base.gameObject.AddComponent<MeshCollider>();
			}
		}

		private IEnumerator DoRayCast()
		{
			while (triggerMode == TriggerMode.RaycastOnThisObjectAndChildren)
			{
				if (raycastCamera != null)
				{
					Ray ray = ((raycastSource != 0) ? new Ray(raycastCamera.transform.position, raycastCamera.transform.forward) : raycastCamera.ScreenPointToRay(Input.mousePosition));
					int num = ((!(maxDistance > 0f)) ? Physics.RaycastNonAlloc(ray, hits) : Physics.RaycastNonAlloc(ray, hits, maxDistance));
					bool flag = false;
					for (int i = 0; i < num; i++)
					{
						Collider collider = hits[i].collider;
						for (int j = 0; j < colliders.Length; j++)
						{
							if (colliders[j] == collider)
							{
								flag = true;
								if (collider != currentCollider)
								{
									SwitchCollider(collider);
									i = num;
									break;
								}
							}
						}
					}
					if (!flag && currentCollider != null)
					{
						SwitchCollider(null);
					}
				}
				yield return null;
			}
		}

		private void SwitchCollider(Collider newCollider)
		{
			currentCollider = newCollider;
			if (currentCollider != null)
			{
				Highlight(state: true);
			}
			else
			{
				Highlight(state: false);
			}
		}

		private void OnMouseDown()
		{
			if (base.isActiveAndEnabled && triggerMode == TriggerMode.ColliderEventsOnlyOnThisObject)
			{
				Highlight(state: true);
			}
		}

		private void OnMouseEnter()
		{
			if (base.isActiveAndEnabled && triggerMode == TriggerMode.ColliderEventsOnlyOnThisObject)
			{
				Highlight(state: true);
			}
		}

		private void OnMouseExit()
		{
			if (base.isActiveAndEnabled && triggerMode == TriggerMode.ColliderEventsOnlyOnThisObject)
			{
				Highlight(state: false);
			}
		}

		private void Highlight(bool state)
		{
			HighlightEffect highlightEffect = base.transform.GetComponent<HighlightEffect>();
			if (highlightEffect == null && state)
			{
				highlightEffect = base.gameObject.AddComponent<HighlightEffect>();
			}
			if (highlightEffect != null)
			{
				highlightEffect.SetHighlighted(state);
			}
		}

		public void Init()
		{
			if (raycastCamera == null)
			{
				raycastCamera = HighlightManager.GetCamera();
			}
			if (triggerMode == TriggerMode.RaycastOnThisObjectAndChildren)
			{
				colliders = GetComponentsInChildren<Collider>();
			}
		}
	}
}
namespace HighlightPlus.Demos
{
	public class SphereHighlightEventExample : MonoBehaviour
	{
		private HighlightEffect effect;

		private void Start()
		{
			effect = GetComponent<HighlightEffect>();
			effect.OnObjectHighlightStart += ValidateHighlightObject;
		}

		private bool ValidateHighlightObject(GameObject obj)
		{
			return true;
		}

		private void HighlightStart()
		{
			UnityEngine.Debug.Log("Gold sphere highlighted!");
		}

		private void HighlightEnd()
		{
			UnityEngine.Debug.Log("Gold sphere not highlighted!");
		}

		private void Update()
		{
			if (Input.GetKeyDown(KeyCode.Space))
			{
				effect.OverlayOneShot(Color.blue, 0.4f);
			}
		}
	}
}
namespace FogOfWar
{
	public class FowFogRenderer : MonoBehaviour
	{
		public FowManager fowManager;

		public GameObject rendererPrefab;

		public InitMapByPhysics initMapByPhysics;

		private Material material;

		private void Start()
		{
		}

		private void Update()
		{
			if (fowManager.map.FogTexture != null)
			{
				material.SetTexture("_MainTex", fowManager.map.FogTexture);
			}
		}

		public void InitFowFogRenderer(float fogSizeX, float fogSizeY, FowViewer viewer)
		{
			fowManager.FogSizeX = fogSizeX;
			fowManager.FogSizeY = fogSizeY;
			GameObject gameObject = UnityEngine.Object.Instantiate(rendererPrefab, base.transform);
			gameObject.transform.localPosition = Vector3.zero;
			gameObject.transform.localScale = new Vector3(fowManager.FogSizeX / 2f, 1f, fowManager.FogSizeY / 2f);
			material = gameObject.GetComponentInChildren<Renderer>().material;
			initMapByPhysics.PhysicsCheck();
			fowManager.AddViewer(viewer);
		}
	}
	public class FowManager : MonoBehaviour
	{
		public float FogSizeX = 10f;

		public float FogSizeY = 10f;

		public float MapTileSize = 1f;

		public FOWMap map;

		public List<FowViewer> viewerList;

		public List<int[]> viewerPos;

		protected int[,] mapData;

		public float updateTime = 0.5f;

		public Shader averageBlur;

		public void AddViewer(FowViewer viewer)
		{
			if (!viewerList.Contains(viewer))
			{
				viewerList.Add(viewer);
			}
		}

		public void RemoveViewer(FowViewer viewer)
		{
			if (viewerList.Contains(viewer))
			{
				viewerList.Remove(viewer);
			}
		}

		private void Awake()
		{
			viewerList = new List<FowViewer>();
			viewerPos = new List<int[]>();
			InvokeRepeating("NewFog", 0f, updateTime);
		}

		public int[] GetPos(FowViewer viewer)
		{
			int num = (int)((viewer.transform.position.x - base.transform.position.x + FogSizeX / 2f) / MapTileSize);
			int num2 = (int)((viewer.transform.position.z - base.transform.position.z + FogSizeY / 2f) / MapTileSize);
			return new int[2] { num, num2 };
		}

		public Vector3 GetV3(int[] pos)
		{
			return new Vector3((float)pos[0] * MapTileSize, 0f, (float)pos[1] * MapTileSize) + new Vector3(MapTileSize / 2f, 0f, MapTileSize / 2f) + base.transform.position - new Vector3(FogSizeX / 2f, 0f, FogSizeY / 2f);
		}

		public void InitMap(int[,] mapData)
		{
			map = new FOWMap();
			map.InitMap(mapData, averageBlur);
			this.mapData = mapData;
		}

		public void NewFog()
		{
			if (map == null)
			{
				return;
			}
			map.FreshFog();
			viewerPos.Clear();
			foreach (FowViewer viewer in viewerList)
			{
				RoomRootController.Instance.ResetAngle(isReset: false);
				int[] pos = GetPos(viewer);
				RoomRootController.Instance.ResetAngle(isReset: true);
				viewerPos.Add(pos);
				map.ComputeFog(pos[0], pos[1], viewer.viewerRange / MapTileSize);
			}
		}

		public void LerpFog()
		{
			map.Lerp();
		}

		private void Update()
		{
			LerpFog();
		}

		private void OnDestroy()
		{
			map.Release();
		}

		private void OnDrawGizmosSelected()
		{
			Gizmos.color = Color.blue;
			Gizmos.DrawWireCube(base.transform.position, new Vector3(FogSizeX, 0f, FogSizeY));
			if (mapData == null)
			{
				return;
			}
			for (int i = 0; i < mapData.GetLength(0); i++)
			{
				for (int j = 0; j < mapData.GetLength(1); j++)
				{
					Gizmos.color = ((mapData[i, j] == 1) ? Color.red : Color.white);
					Gizmos.DrawWireCube(GetV3(new int[2] { i, j }), new Vector3(MapTileSize - 0.02f, 0f, MapTileSize - 0.02f));
				}
			}
			foreach (int[] viewerPo in viewerPos)
			{
				Gizmos.color = Color.green;
				Gizmos.DrawCube(GetV3(viewerPo), new Vector3(MapTileSize - 0.02f, 1f, MapTileSize - 0.02f));
			}
		}
	}
	public class FOWMap
	{
		protected List<FOWTile> map = new List<FOWTile>();

		protected int mapWidth;

		protected int mapHeight;

		public Color32[] colorBuffer;

		public Color32[] blurBuffer;

		public Material blurMat;

		private Texture2D texBuffer;

		private RenderTexture renderBuffer;

		private RenderTexture renderBuffer2;

		private RenderTexture nextTexture;

		private RenderTexture curTexture;

		public bool fix = true;

		public Texture FogTexture => curTexture;

		public Color32 this[int x, int y]
		{
			get
			{
				if (x >= 0 && y >= 0 && x < mapWidth && y < mapHeight)
				{
					return colorBuffer[x + y * mapWidth];
				}
				return default(Color32);
			}
			set
			{
				if (x >= 0 && y >= 0 && x < mapWidth && y < mapHeight)
				{
					colorBuffer[x + y * mapWidth] = value;
				}
			}
		}

		public FOWTile GetTile(int x, int y)
		{
			if (x >= 0 && y >= 0 && x < mapWidth && y < mapHeight)
			{
				return map[x + y * mapWidth];
			}
			return null;
		}

		public int Index(int x, int y)
		{
			if (x >= 0 && y >= 0 && x < mapWidth && y < mapHeight)
			{
				return x + y * mapWidth;
			}
			return -1;
		}

		public bool InMap(int x, int y)
		{
			return Index(x, y) != -1;
		}

		public void Lerp()
		{
			Graphics.Blit(curTexture, renderBuffer);
			blurMat.SetTexture("_LastTex", renderBuffer);
			Graphics.Blit(nextTexture, curTexture, blurMat, 1);
		}

		protected void Blur()
		{
			foreach (FOWTile item in map)
			{
				Color32 color = colorBuffer[Index(item.x, item.y)];
				if (color.r == 0)
				{
					blurBuffer[Index(item.x, item.y)].a = (byte)((color.b == byte.MaxValue) ? 120 : byte.MaxValue);
				}
				else
				{
					blurBuffer[Index(item.x, item.y)].a = (byte)(255 - color.r);
				}
			}
			texBuffer.SetPixels32(blurBuffer);
			texBuffer.Apply();
			Graphics.Blit(texBuffer, renderBuffer, blurMat, 0);
			for (int i = 0; i < 1; i++)
			{
				Graphics.Blit(renderBuffer, renderBuffer2, blurMat, 0);
				Graphics.Blit(renderBuffer2, renderBuffer, blurMat, 0);
			}
			Graphics.Blit(renderBuffer, nextTexture);
		}

		public void ComputeFog(int playerX, int playerY, float range)
		{
			int num = (int)(range * range);
			List<FOWTile> list = new List<FOWTile>();
			for (int i = (int)(0f - range); (float)i <= range; i++)
			{
				for (int j = (int)(0f - range); (float)j <= range; j++)
				{
					if (i * i + j * j <= num)
					{
						FOWTile tile = GetTile(playerX + i, playerY + j);
						if (tile != null)
						{
							colorBuffer[Index(playerX + i, playerY + j)].r = byte.MaxValue;
							list.Add(tile);
						}
					}
				}
			}
			list.Sort((FOWTile a, FOWTile b) => a.Distance(playerX, playerY) - b.Distance(playerX, playerY));
			List<FOWTile> obstacle = GetObstacle(playerX, playerY, range);
			while (obstacle.Count > 0)
			{
				FOWTile fOWTile = obstacle[0];
				foreach (FOWTile item in fOWTile.RayCast(playerX, playerY, list))
				{
					colorBuffer[Index(item.x, item.y)].r = 0;
				}
				obstacle.Remove(fOWTile);
			}
			foreach (FOWTile item2 in list)
			{
				if (colorBuffer[Index(item2.x, item2.y)].r == byte.MaxValue)
				{
					colorBuffer[Index(item2.x, item2.y)].b = byte.MaxValue;
				}
			}
			Blur();
		}

		public List<FOWTile> GetObstacle(int x, int y, float range)
		{
			List<FOWTile> list = new List<FOWTile>();
			float num = (float)(int)range * range;
			for (int i = (int)(0f - range); (float)i <= range; i++)
			{
				for (int j = (int)(0f - range); (float)j <= range; j++)
				{
					if ((i != 0 || i != j) && (float)(i * i + j * j) <= num)
					{
						FOWTile tile = GetTile(x + i, y + j);
						if (tile != null && tile.type == 1)
						{
							list.Add(tile);
						}
					}
				}
			}
			list.Sort((FOWTile a, FOWTile b) => a.Distance(x, y) - b.Distance(x, y));
			return list;
		}

		public void FreshFog()
		{
			foreach (FOWTile item in map)
			{
				if (colorBuffer[Index(item.x, item.y)].r == byte.MaxValue)
				{
					colorBuffer[Index(item.x, item.y)].r = 0;
				}
			}
		}

		public void InitMap(int[,] mapData, Shader averageBlur)
		{
			map.Clear();
			mapWidth = mapData.GetLength(0);
			mapHeight = mapData.GetLength(1);
			colorBuffer = new Color32[mapWidth * mapHeight];
			blurBuffer = new Color32[mapWidth * mapHeight];
			blurMat = new Material(averageBlur);
			texBuffer = new Texture2D(mapWidth, mapHeight, TextureFormat.ARGB32, mipChain: false);
			texBuffer.wrapMode = TextureWrapMode.Clamp;
			renderBuffer = RenderTexture.GetTemporary((int)((float)mapWidth * 1.5f), (int)((float)mapHeight * 1.5f), 0);
			renderBuffer2 = RenderTexture.GetTemporary((int)((float)mapWidth * 1.5f), (int)((float)mapHeight * 1.5f), 0);
			nextTexture = RenderTexture.GetTemporary((int)((float)mapWidth * 1.5f), (int)((float)mapHeight * 1.5f), 0);
			curTexture = RenderTexture.GetTemporary((int)((float)mapWidth * 1.5f), (int)((float)mapHeight * 1.5f), 0);
			for (int i = 0; i < mapHeight; i++)
			{
				for (int j = 0; j < mapWidth; j++)
				{
					map.Add(new FOWTile(mapData[j, i], j, i));
					colorBuffer[j] = new Color32(0, 0, 0, byte.MaxValue);
				}
			}
		}

		public void Release()
		{
			RenderTexture.ReleaseTemporary(renderBuffer);
			RenderTexture.ReleaseTemporary(renderBuffer2);
			RenderTexture.ReleaseTemporary(nextTexture);
			RenderTexture.ReleaseTemporary(curTexture);
		}
	}
	public class FOWTile
	{
		public int type;

		public int x;

		public int y;

		public FOWTile(int type, int x, int y)
		{
			this.type = type;
			this.x = x;
			this.y = y;
		}

		public bool CantDisplay(FOWTile ob, int playerX, int playerY)
		{
			return FOWTool.CantDisplay(ob.x - playerX, ob.y - playerY, x - playerX, y - playerY, (float)Math.PI / (6f + (float)ob.Distance(playerX, playerY) / 1.2f));
		}

		public List<FOWTile> RayCast(int x, int y, List<FOWTile> tiles)
		{
			List<FOWTile> list = new List<FOWTile>();
			for (int i = tiles.IndexOf(this) + 1; i < tiles.Count; i++)
			{
				FOWTile fOWTile = tiles[i];
				if (fOWTile.CantDisplay(this, x, y))
				{
					list.Add(fOWTile);
				}
			}
			return list;
		}

		public int Distance(int ox, int oy)
		{
			int num = ox - x;
			int num2 = oy - y;
			return num * num + num2 * num2;
		}
	}
	public static class FOWTool
	{
		public static bool InMap(int x, int y, int mapWidth, int mapHeight)
		{
			if (x >= 0 && y >= 0 && x < mapWidth)
			{
				return y < mapHeight;
			}
			return false;
		}

		public static bool CantDisplay(int x1, int y1, int x2, int y2, float z)
		{
			if ((x1 == 0 && y1 == 0) || (x2 == 0 && y2 == 0))
			{
				return true;
			}
			if (x1 == 0 || x2 == 0)
			{
				int num = y1;
				y1 = x1;
				x1 = num;
				int num2 = y2;
				y2 = x2;
				x2 = num2;
			}
			float k = (float)y1 * 1f / (float)x1;
			float k2 = (float)y2 * 1f / (float)x2;
			if (x1 * x2 + y1 * y2 > 0)
			{
				return Angle(k, k2) < z;
			}
			return false;
		}

		public static float Angle(float k1, float k2)
		{
			return Mathf.Abs((k2 - k1) / (1f + k1 * k2));
		}
	}
	public class FowViewer : MonoBehaviour
	{
		public float viewerRange = 1f;

		private void Start()
		{
		}

		private void Update()
		{
		}

		private void OnDestroy()
		{
		}
	}
	public class InitMapByPhysics : MonoBehaviour
	{
		public FowManager fowManager;

		private int[,] mapData;

		private void Start()
		{
		}

		public void PhysicsCheck()
		{
			mapData = new int[(int)(fowManager.FogSizeX / fowManager.MapTileSize), (int)(fowManager.FogSizeY / fowManager.MapTileSize)];
			for (int i = 0; i < mapData.GetLength(0); i++)
			{
				for (int j = 0; j < mapData.GetLength(1); j++)
				{
					if (Physics.CheckBox(fowManager.GetV3(new int[2] { i, j }), new Vector3(fowManager.MapTileSize - 0.02f, 0f, fowManager.MapTileSize - 0.02f) / 2f))
					{
						mapData[i, j] = 1;
					}
					else
					{
						mapData[i, j] = 0;
					}
				}
			}
			fowManager.InitMap(mapData);
		}
	}
}
namespace CRCI_SpeechTrain
{
	public class TestControl_01 : MonoBehaviour
	{
		[Serializable]
		public class cdata
		{
			public GameObject targetObj;

			public TextAsset m_txtConfig;
		}

		public List<cdata> m_listDatas;

		public V_testResultTable v_testResultTable;

		[SerializeField]
		private M_TestTable curTestTable;

		private int currecWordID;

		private I_VoiceCheckResultBase m_curTargetCheck;

		private void Start()
		{
			foreach (cdata listData in m_listDatas)
			{
				UnityEngine.Debug.Log(LitJson.JsonMapper.ToObject<M_TestTable>(listData.m_txtConfig.text).tablename);
			}
			int index = UnityEngine.Random.Range(0, m_listDatas.Count);
			curTestTable = LitJson.JsonMapper.ToObject<M_TestTable>(m_listDatas[index].m_txtConfig.text);
		}

		private void Update()
		{
			if (Input.GetKeyDown(KeyCode.S) || Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.B))
			{
				UnityEngine.Debug.Log("--手动语音，下一个");
				if (m_curTargetCheck != null)
				{
					J_SetItemScore(m_curTargetCheck.wordID, 1, 0);
					m_curTargetCheck.m_eventWhenCorrect.Invoke();
				}
			}
		}

		public void J_ReloadScene()
		{
			SceneManager.LoadScene(SceneManager.GetActiveScene().name, LoadSceneMode.Single);
		}

		public void J_SetCheckContent(I_VoiceCheckResultBase itargetCheck)
		{
			currecWordID = itargetCheck.wordID;
			float num = 0.1f;
			bool rec = true;
			if (currecWordID == 0)
			{
				num = 3.5f;
			}
			else if (currecWordID < 200)
			{
				num = 2.5f;
			}
			else if (currecWordID < 300)
			{
				int length = (itargetCheck as I_VoiceCheckResult_Repeat).words.Length;
				num = 4f + (float)length * 0.33f;
				J_VoiceRecCtrl.Inst.daojishi = ((length < 8) ? 10 : 20);
			}
			else if (currecWordID < 400)
			{
				J_VoiceRecCtrl.Inst.daojishi = 20f;
				num = 4f;
			}
			else
			{
				J_VoiceRecCtrl.Inst.daojishi = 0f;
				rec = false;
			}
			J_VoiceRecCtrl.Inst.m_txtRecResult.text = "";
			num = 0.5f;
			m_curTargetCheck = itargetCheck;
			delayAction(num, delegate
			{
				if (rec)
				{
					J_VoiceRecCtrl.Inst.StartRec();
				}
				SetCnt(itargetCheck);
			});
		}

		private void SetCnt(I_VoiceCheckResultBase itargetCheck)
		{
			J_VoiceRecCtrl.Inst.J_SetWordsRecResultReceiver(delegate(DataRequestResult_voiceData recWords)
			{
				if (!string.IsNullOrEmpty(recWords.file_txt))
				{
					if (m_curTargetCheck == null)
					{
						UnityEngine.Debug.LogWarning("--empty receiver");
					}
					else
					{
						m_curTargetCheck.OnResultCheck(recWords.file_txt, delegate(bool isMatch)
						{
							if (isMatch)
							{
								J_VoiceRecCtrl.Inst.J_SetWordsRecResultReceiver(null);
								J_VoiceRecCtrl.Inst.StopRec();
								J_SetItemScore(m_curTargetCheck.wordID, 1, recWords.id);
								delayAction(1.3f, delegate
								{
									m_curTargetCheck.m_eventWhenCorrect.Invoke();
								});
							}
							else if (!(J_VoiceRecCtrl.Inst.daojishi > 0f) && m_curTargetCheck.m_eventWhenWrong.GetPersistentEventCount() > 0)
							{
								J_VoiceRecCtrl.Inst.StopRec();
								J_VoiceRecCtrl.Inst.J_SetWordsRecResultReceiver(null);
								J_SetItemScore(m_curTargetCheck.wordID, 0, recWords.id);
								delayAction(1.3f, delegate
								{
									m_curTargetCheck.m_eventWhenWrong.Invoke();
								});
							}
						});
					}
				}
			});
		}

		private void delayAction(float delaytime, Action action)
		{
			StartCoroutine(yieldDelayaction(delaytime, action));
		}

		private IEnumerator yieldDelayaction(float delaytime, Action action)
		{
			yield return new WaitForSeconds(delaytime);
			action?.Invoke();
		}

		public void J_QuitApp()
		{
			SceneManager.LoadScene("2_MainStart");
		}

		public void J_SetCheckContent_picSelect(I_VoiceCheckResultBase itargetCheck)
		{
			J_VoiceRecCtrl.Inst.m_objShengBo.SetActive(value: false);
			J_VoiceRecCtrl.Inst.m_objTxtResult.SetActive(value: false);
			m_curTargetCheck = itargetCheck;
			UnityEngine.Debug.Log(m_curTargetCheck.wordID);
		}

		public void J_ClickPic(int picid)
		{
			UnityEngine.Debug.Log(picid + "," + m_curTargetCheck.wordID);
			if (picid == m_curTargetCheck.wordID)
			{
				J_SetItemScore(m_curTargetCheck.wordID, 1, 0);
				m_curTargetCheck.m_eventWhenCorrect.Invoke();
			}
			else
			{
				J_SetItemScore(m_curTargetCheck.wordID, 0, 0);
				m_curTargetCheck.m_eventWhenWrong.Invoke();
			}
		}

		private void J_SetItemScore(int cid, int score, int voicefileid)
		{
			UnityEngine.Debug.Log(cid + "," + score);
			int num = 0;
			foreach (M_TestTable.cPart01 datum in curTestTable.data)
			{
				foreach (M_TestTable.cPart01.cPart02 datum2 in datum.data)
				{
					foreach (M_TestTable.cPart01.cPart02.cPart03 datum3 in datum2.data)
					{
						if (cid == datum3.cid)
						{
							num++;
							datum3.score = score;
							datum3.voice_file_id = voicefileid;
						}
					}
				}
			}
			if (num < 1)
			{
				UnityEngine.Debug.LogError("--unknow id:" + cid);
			}
			else if (num > 1)
			{
				UnityEngine.Debug.LogError("--multiple id:" + cid);
			}
		}

		public void J_ShowResult()
		{
			v_testResultTable.J_PassValue(curTestTable);
			string url = UrlUtils.baseUrl_es + UrlUtils.measure;
			WWWForm wWWForm = new WWWForm();
			wWWForm.AddField("measure", LitJson.JsonMapper.ToJson(curTestTable));
			UnityWebRequestHelper.Instance.Post(url, wWWForm, delegate(RequestStatus status, string result)
			{
				UnityEngine.Debug.Log("提交成功" + result);
			}, isToken: true);
		}
	}
}
namespace __
{
	public class PicoVR_ControllerDemoSimulator : MonoBehaviour
	{
	}
	public class WavrVR_ControllerAction : MonoBehaviour
	{
		public Pvr_KeyCode pvr_KeyCode = Pvr_KeyCode.APP;

		public UnityEvent onVirtualBtnDown;

		public UnityEvent onVirtualBtnUp;

		private void Start()
		{
		}

		private void Update()
		{
			if (Controller.UPvr_GetKeyDown(1, pvr_KeyCode))
			{
				onVirtualBtnDown.Invoke();
			}
			if (Controller.UPvr_GetKeyUp(1, pvr_KeyCode) || Input.GetKeyUp(KeyCode.Escape))
			{
				onVirtualBtnUp.Invoke();
			}
		}
	}
	public class NetworkManager : MonoBehaviour
	{
		private static NetworkManager _inst;

		private static string _networkurl;

		public static NetworkManager Inst
		{
			get
			{
				if (_inst == null)
				{
					GameObject obj = new GameObject("NetworkManager");
					_inst = obj.AddComponent<NetworkManager>();
					UnityEngine.Object.DontDestroyOnLoad(obj);
				}
				return _inst;
			}
		}

		public static string NetworkURL
		{
			get
			{
				if (string.IsNullOrEmpty(_networkurl))
				{
					if (Application.platform == RuntimePlatform.WindowsEditor || Application.platform == RuntimePlatform.WindowsPlayer)
					{
						_networkurl = File.ReadAllLines(string.Concat(Directory.GetParent(Application.dataPath), "/Datas/Configs/ips"))[0];
					}
					else
					{
						_networkurl = "test7.guavaamoy.com";
					}
				}
				return _networkurl;
			}
		}

		public static void J_CheckNetwork(Action<bool, string> callback)
		{
			Inst.StartCoroutine(yield_CheckNetwork(callback));
		}

		private static IEnumerator yield_CheckNetwork(Action<bool, string> callback)
		{
			WWWForm formData = new WWWForm();
			using UnityWebRequest www = UnityWebRequest.Post(NetworkURL + "/VRMedical/PHP/networkcheck.php", formData);
			yield return www.SendWebRequest();
			if (string.IsNullOrEmpty(www.error))
			{
				string text = www.downloadHandler.text;
				UnityEngine.Debug.Log("--network ok:" + text);
				callback?.Invoke(arg1: true, text);
			}
			else
			{
				UnityEngine.Debug.LogError(www.error);
				callback?.Invoke(arg1: false, "服务器连接出错");
			}
		}
	}
	public enum ETestState
	{
		Failed,
		Succeed
	}
	public class BallMotion_A2B : MonoBehaviour
	{
		public float m_fPassTime = 2f;

		public float m_fGravity = -5f;

		private float fPassTime;

		private float fGravity;

		private Vector3 speed;

		private Vector3 Gravity;

		private float dpassedTime;

		private Action m_actionOnReachPoint;

		private bool isStartMove;

		private void Start()
		{
			fPassTime = m_fPassTime;
			fGravity = m_fGravity;
		}

		private void Update()
		{
			if (Time.timeScale != 0f && isStartMove)
			{
				Vector3 vector = speed * Time.deltaTime + new Vector3(0f, fGravity * (dpassedTime += Time.deltaTime), 0f) * Time.deltaTime;
				base.transform.transform.forward = vector;
				base.transform.position += vector;
				if (dpassedTime >= fPassTime && m_actionOnReachPoint != null)
				{
					m_actionOnReachPoint();
					m_actionOnReachPoint = null;
				}
				if (base.transform.position.y < 0f)
				{
					YMQ_GameManager.Inst.J_ResetGameBall();
				}
			}
		}

		public void StartMoveFromTo(Vector3 vFrom, Vector3 vTo, Action callbackReachEndPoint = null)
		{
			fPassTime = m_fPassTime;
			fGravity = m_fGravity;
			base.transform.position = vFrom;
			speed = new Vector3((vTo.x - vFrom.x) / fPassTime, (vTo.y - vFrom.y) / fPassTime - 0.5f * fGravity * fPassTime, (vTo.z - vFrom.z) / fPassTime);
			Gravity = Vector3.zero;
			dpassedTime = 0f;
			isStartMove = true;
			m_actionOnReachPoint = callbackReachEndPoint;
		}

		public void StartMoveFromTo(Vector3 vFrom, Vector3 vTo, float psTime, float gravity, Action callbackReachEndPoint = null)
		{
			fPassTime = psTime;
			fGravity = gravity;
			base.transform.position = vFrom;
			speed = new Vector3((vTo.x - vFrom.x) / fPassTime, (vTo.y - vFrom.y) / fPassTime - 0.5f * fGravity * fPassTime, (vTo.z - vFrom.z) / fPassTime);
			Gravity = Vector3.zero;
			dpassedTime = 0f;
			isStartMove = true;
			m_actionOnReachPoint = callbackReachEndPoint;
		}

		public void StopMove()
		{
			isStartMove = false;
		}
	}
	public class OnColliderEvent : MonoBehaviour
	{
		[Serializable]
		public class collisionEvent : UnityEvent<UnityEngine.Collision>
		{
		}

		public collisionEvent m_actionsOnCollisionEnter = new collisionEvent();

		public collisionEvent m_actionsOnCollisionExit = new collisionEvent();

		private void OnCollisionEnter(UnityEngine.Collision collision)
		{
			UnityEngine.Debug.Log("--collid:" + collision.gameObject.name);
			if (m_actionsOnCollisionEnter != null)
			{
				m_actionsOnCollisionEnter.Invoke(collision);
			}
		}

		private void OnCollisionExit(UnityEngine.Collision collision)
		{
			if (m_actionsOnCollisionExit != null)
			{
				m_actionsOnCollisionExit.Invoke(collision);
			}
		}
	}
}
namespace NatSuite.Recorders
{
	[Doc("GIFRecorder")]
	public sealed class GIFRecorder : IMediaRecorder
	{
		private readonly IMediaRecorder recorder;

		[Doc("FrameSize")]
		public (int width, int height) frameSize => recorder.frameSize;

		[Doc("GIFRecorderCtor")]
		public GIFRecorder(int width, int height, float frameDuration)
		{
			recorder = new NativeRecorder((Bridge.CompletionHandler callback, IntPtr context) => Bridge.CreateGIFRecorder(width, height, frameDuration, Utility.GetPath(".gif"), callback, context));
		}

		[Doc("CommitFrame")]
		[Code("RecordWebCam")]
		public void CommitFrame<T>(T[] pixelBuffer, long timestamp) where T : struct
		{
			recorder.CommitFrame(pixelBuffer, timestamp);
		}

		[Doc("CommitFrame")]
		public void CommitFrame(IntPtr nativeBuffer, long timestamp)
		{
			recorder.CommitFrame(nativeBuffer, timestamp);
		}

		[Doc("CommitSamplesNotSupported")]
		public void CommitSamples(float[] sampleBuffer, long timestamp)
		{
		}

		[Doc("FinishWriting", "FinishWritingDiscussion")]
		public Task<string> FinishWriting()
		{
			return recorder.FinishWriting();
		}
	}
	[Doc("HEVCRecorder")]
	public sealed class HEVCRecorder : IMediaRecorder
	{
		private readonly IMediaRecorder recorder;

		[Doc("FrameSize")]
		public (int width, int height) frameSize => recorder.frameSize;

		[Doc("HEVCRecorderCtor")]
		public HEVCRecorder(int width, int height, float framerate, int sampleRate = 0, int channelCount = 0, int bitrate = 5909760, int keyframeInterval = 3)
		{
			recorder = new NativeRecorder((Bridge.CompletionHandler callback, IntPtr context) => Bridge.CreateHEVCRecorder(width, height, framerate, bitrate, keyframeInterval, sampleRate, channelCount, Utility.GetPath(".mp4"), callback, context));
		}

		[Doc("CommitFrame")]
		[Code("RecordWebCam")]
		public void CommitFrame<T>(T[] pixelBuffer, long timestamp) where T : struct
		{
			recorder.CommitFrame(pixelBuffer, timestamp);
		}

		[Doc("CommitFrame")]
		public void CommitFrame(IntPtr nativeBuffer, long timestamp)
		{
			recorder.CommitFrame(nativeBuffer, timestamp);
		}

		[Doc("CommitSamples", "CommitSamplesDiscussion")]
		[Code("RecordPCM")]
		public void CommitSamples(float[] sampleBuffer, long timestamp)
		{
			recorder.CommitSamples(sampleBuffer, timestamp);
		}

		[Doc("FinishWriting", "FinishWritingDiscussion")]
		public Task<string> FinishWriting()
		{
			return recorder.FinishWriting();
		}
	}
	public interface IMediaRecorder
	{
		(int width, int height) frameSize { get; }

		void CommitFrame<T>(T[] pixelBuffer, long timestamp) where T : struct;

		void CommitFrame(IntPtr nativeBuffer, long timestamp);

		void CommitSamples(float[] sampleBuffer, long timestamp);

		Task<string> FinishWriting();
	}
	[Doc("JPGRecorder")]
	public sealed class JPGRecorder : IMediaRecorder
	{
		private readonly Texture2D framebuffer;

		private readonly Queue<byte[]> writeQueue;

		private readonly Task<string> recordingTask;

		[Doc("FrameSize")]
		public (int width, int height) frameSize => (width: framebuffer.width, height: framebuffer.height);

		[Doc("JPGRecorderCtor")]
		public JPGRecorder(int imageWidth, int imageHeight)
		{
			framebuffer = new Texture2D(imageWidth, imageHeight, TextureFormat.RGBA32, mipChain: false, linear: false);
			writeQueue = new Queue<byte[]>();
			string recordingPath = Utility.GetPath(string.Empty);
			Directory.CreateDirectory(recordingPath);
			recordingTask = System.Threading.Tasks.Task.Run(delegate
			{
				int num = 0;
				while (true)
				{
					byte[] array;
					lock (((ICollection)writeQueue).SyncRoot)
					{
						if (writeQueue.Count > 0)
						{
							array = writeQueue.Dequeue();
							goto IL_004f;
						}
					}
					continue;
					IL_004f:
					if (array == null)
					{
						break;
					}
					File.WriteAllBytes(Path.Combine(recordingPath, ++num + ".jpg"), array);
				}
				return recordingPath;
			});
		}

		[Doc("CommitFrame")]
		public void CommitFrame<T>(T[] pixelBuffer, long timestamp) where T : struct
		{
			GCHandle gCHandle = GCHandle.Alloc(pixelBuffer, GCHandleType.Pinned);
			CommitFrame(gCHandle.AddrOfPinnedObject(), timestamp);
			gCHandle.Free();
		}

		[Doc("CommitFrame")]
		public void CommitFrame(IntPtr nativeBuffer, long timestamp)
		{
			framebuffer.LoadRawTextureData(nativeBuffer, framebuffer.width * framebuffer.height * 4);
			byte[] item = framebuffer.EncodeToJPG();
			lock (((ICollection)writeQueue).SyncRoot)
			{
				writeQueue.Enqueue(item);
			}
		}

		[Doc("CommitSamplesNotSupported")]
		public void CommitSamples(float[] sampleBuffer, long timestamp)
		{
		}

		[Doc("FinishWriting", "FinishWritingDiscussion")]
		public Task<string> FinishWriting()
		{
			lock (((ICollection)writeQueue).SyncRoot)
			{
				writeQueue.Enqueue(null);
			}
			UnityEngine.Object.Destroy(framebuffer);
			return recordingTask;
		}
	}
	[Doc("MP4Recorder")]
	public sealed class MP4Recorder : IMediaRecorder
	{
		private readonly IMediaRecorder recorder;

		[Doc("FrameSize")]
		public (int width, int height) frameSize => recorder.frameSize;

		[Doc("MP4RecorderCtor")]
		public MP4Recorder(int width, int height, float framerate, int sampleRate = 0, int channelCount = 0, int bitrate = 5909760, int keyframeInterval = 3)
		{
			recorder = new NativeRecorder((Bridge.CompletionHandler callback, IntPtr context) => Bridge.CreateMP4Recorder(width, height, framerate, bitrate, keyframeInterval, sampleRate, channelCount, Utility.GetPath(".mp4"), callback, context));
		}

		[Doc("CommitFrame")]
		[Code("RecordWebCam")]
		public void CommitFrame<T>(T[] pixelBuffer, long timestamp) where T : struct
		{
			recorder.CommitFrame(pixelBuffer, timestamp);
		}

		[Doc("CommitFrame")]
		public void CommitFrame(IntPtr nativeBuffer, long timestamp)
		{
			recorder.CommitFrame(nativeBuffer, timestamp);
		}

		[Doc("CommitSamples", "CommitSamplesDiscussion")]
		[Code("RecordPCM")]
		public void CommitSamples(float[] sampleBuffer, long timestamp)
		{
			recorder.CommitSamples(sampleBuffer, timestamp);
		}

		[Doc("FinishWriting", "FinishWritingDiscussion")]
		public Task<string> FinishWriting()
		{
			return recorder.FinishWriting();
		}
	}
	[Doc("WAVRecorder")]
	public sealed class WAVRecorder : IMediaRecorder
	{
		private readonly int sampleRate;

		private readonly int channelCount;

		private readonly FileStream stream;

		private int sampleCount;

		[Doc("FrameSizeNotSupported")]
		public (int width, int height) frameSize => default((int, int));

		[Doc("WAVRecorderCtor")]
		public WAVRecorder(int sampleRate, int channelCount)
		{
			this.sampleRate = sampleCount;
			this.channelCount = channelCount;
			stream = new FileStream(Utility.GetPath(".wav"), FileMode.Create);
			stream.Write(new byte[44], 0, 44);
		}

		[Doc("CommitFrameNotSupported")]
		public void CommitFrame<T>(T[] pixelBuffer, long timestamp) where T : struct
		{
		}

		[Doc("CommitFrameNotSupported")]
		public void CommitFrame(IntPtr nativeBuffer, long timestamp)
		{
		}

		[Doc("CommitSamples")]
		public void CommitSamples(float[] sampleBuffer, long timestamp)
		{
			short[] array = new short[sampleBuffer.Length];
			byte[] array2 = new byte[Buffer.ByteLength(array)];
			for (int i = 0; i < sampleBuffer.Length; i++)
			{
				array[i] = (short)(sampleBuffer[i] * 32767f);
			}
			Buffer.BlockCopy(array, 0, array2, 0, array2.Length);
			stream.Write(array2, 0, array2.Length);
			sampleCount += sampleBuffer.Length;
		}

		[Doc("FinishWriting")]
		public Task<string> FinishWriting()
		{
			stream.Seek(0L, SeekOrigin.Begin);
			stream.Write(Encoding.UTF8.GetBytes("RIFF"), 0, 4);
			stream.Write(BitConverter.GetBytes(stream.Length - 8), 0, 4);
			stream.Write(Encoding.UTF8.GetBytes("WAVE"), 0, 4);
			stream.Write(Encoding.UTF8.GetBytes("fmt "), 0, 4);
			stream.Write(BitConverter.GetBytes(16), 0, 4);
			stream.Write(BitConverter.GetBytes((ushort)1), 0, 2);
			stream.Write(BitConverter.GetBytes(channelCount), 0, 2);
			stream.Write(BitConverter.GetBytes(sampleRate), 0, 4);
			stream.Write(BitConverter.GetBytes(sampleRate * channelCount * 2), 0, 4);
			stream.Write(BitConverter.GetBytes((ushort)(channelCount * 2)), 0, 2);
			stream.Write(BitConverter.GetBytes((ushort)16), 0, 2);
			stream.Write(Encoding.UTF8.GetBytes("data"), 0, 4);
			stream.Write(BitConverter.GetBytes(sampleCount * 2), 0, 4);
			stream.Dispose();
			return System.Threading.Tasks.Task.FromResult(stream.Name);
		}
	}
}
namespace NatSuite.Recorders.Internal
{
	public static class Bridge
	{
		public delegate void CompletionHandler(IntPtr context, IntPtr path);

		private const string Assembly = "NatCorder";

		[DllImport("NatCorder", EntryPoint = "NCCreateMP4Recorder")]
		public static extern IntPtr CreateMP4Recorder(int width, int height, float framerate, int bitrate, int keyframeInterval, int sampleRate, int channelCount, [MarshalAs(UnmanagedType.LPStr)] string recordingPath, CompletionHandler callback, IntPtr context);

		[DllImport("NatCorder", EntryPoint = "NCCreateHEVCRecorder")]
		public static extern IntPtr CreateHEVCRecorder(int width, int height, float framerate, int bitrate, int keyframeInterval, int sampleRate, int channelCount, [MarshalAs(UnmanagedType.LPStr)] string recordingPath, CompletionHandler callback, IntPtr context);

		[DllImport("NatCorder", EntryPoint = "NCCreateGIFRecorder")]
		public static extern IntPtr CreateGIFRecorder(int width, int height, float frameDuration, [MarshalAs(UnmanagedType.LPStr)] string recordingPath, CompletionHandler callback, IntPtr context);

		[DllImport("NatCorder", EntryPoint = "NCFrameSize")]
		public static extern void FrameSize(this IntPtr recorder, out int width, out int height);

		[DllImport("NatCorder", EntryPoint = "NCCommitFrame")]
		public static extern void CommitFrame(this IntPtr recorder, IntPtr pixelBuffer, long timestamp);

		[DllImport("NatCorder", EntryPoint = "NCCommitSamples")]
		public static extern void CommitSamples(this IntPtr recorder, float[] sampleBuffer, int sampleCount, long timestamp);

		[DllImport("NatCorder", EntryPoint = "NCFinishWriting")]
		public static extern void FinishWriting(this IntPtr recorder);
	}
	public sealed class NativeRecorder : IMediaRecorder
	{
		private readonly IntPtr recorder;

		private readonly TaskCompletionSource<string> recordingTask;

		public (int width, int height) frameSize
		{
			get
			{
				recorder.FrameSize(out var width, out var height);
				return (width: width, height: height);
			}
		}

		public NativeRecorder(Func<Bridge.CompletionHandler, IntPtr, IntPtr> recorderCreator)
		{
			recordingTask = new TaskCompletionSource<string>();
			GCHandle gCHandle = GCHandle.Alloc(recordingTask, GCHandleType.Normal);
			recorder = recorderCreator(OnRecording, (IntPtr)gCHandle);
		}

		public void CommitFrame<T>(T[] pixelBuffer, long timestamp) where T : struct
		{
			GCHandle gCHandle = GCHandle.Alloc(pixelBuffer, GCHandleType.Pinned);
			CommitFrame(gCHandle.AddrOfPinnedObject(), timestamp);
			gCHandle.Free();
		}

		public void CommitFrame(IntPtr nativeBuffer, long timestamp)
		{
			recorder.CommitFrame(nativeBuffer, timestamp);
		}

		public void CommitSamples(float[] sampleBuffer, long timestamp)
		{
			recorder.CommitSamples(sampleBuffer, sampleBuffer.Length, timestamp);
		}

		public Task<string> FinishWriting()
		{
			recorder.FinishWriting();
			return recordingTask.Task;
		}

		[MonoPInvokeCallback(typeof(Bridge.CompletionHandler))]
		private static void OnRecording(IntPtr context, IntPtr path)
		{
			GCHandle gCHandle = (GCHandle)context;
			TaskCompletionSource<string> taskCompletionSource = gCHandle.Target as TaskCompletionSource<string>;
			gCHandle.Free();
			if (path != IntPtr.Zero)
			{
				taskCompletionSource.SetResult(Marshal.PtrToStringAnsi(path));
			}
			else
			{
				taskCompletionSource.SetException(new Exception("Recorder failed to finish writing"));
			}
		}
	}
	public static class Utility
	{
		private static string directory;

		public static string GetPath(string extension)
		{
			if (directory == null)
			{
				directory = GlobeConfig.VideoPaths;
				if (!Directory.Exists(directory))
				{
					Directory.CreateDirectory(directory);
				}
			}
			string text = DateTime.Now.ToString("yyyy_MM_dd_HH_mm_ss_fff");
			string text2 = "recording_" + text + extension;
			return ReplayCam.videoPath = directory + "/" + text2;
		}
	}
	public sealed class DocAttribute : Attribute
	{
		public DocAttribute(string descriptionKey)
		{
		}

		public DocAttribute(string summaryKey, string descriptionKey)
		{
		}
	}
	public sealed class CodeAttribute : Attribute
	{
		public CodeAttribute(string key)
		{
		}
	}
	public sealed class RefAttribute : Attribute
	{
		public RefAttribute(params string[] keys)
		{
		}
	}
}
namespace NatSuite.Recorders.Inputs
{
	[Doc("AudioInput")]
	public sealed class AudioInput : IDisposable
	{
		private class AudioInputAttachment : MonoBehaviour
		{
			public Action<float[]> sampleBufferDelegate;

			private void OnAudioFilterRead(float[] data, int channels)
			{
				sampleBufferDelegate?.Invoke(data);
			}
		}

		private readonly IMediaRecorder recorder;

		private readonly IClock clock;

		private readonly AudioInputAttachment attachment;

		private readonly bool mute;

		[Doc("AudioInputCtorListener")]
		public AudioInput(IMediaRecorder recorder, IClock clock, AudioListener audioListener)
			: this(recorder, clock, audioListener.gameObject)
		{
		}

		[Doc("AudioInputCtorSource")]
		public AudioInput(IMediaRecorder recorder, IClock clock, AudioSource audioSource, bool mute = false)
			: this(recorder, clock, audioSource.gameObject, mute)
		{
		}

		[Doc("AudioInputDispose")]
		public void Dispose()
		{
			UnityEngine.Object.Destroy(attachment);
		}

		private AudioInput(IMediaRecorder recorder, IClock clock, GameObject gameObject, bool mute = false)
		{
			this.recorder = recorder;
			this.clock = clock;
			attachment = gameObject.AddComponent<AudioInputAttachment>();
			attachment.sampleBufferDelegate = OnSampleBuffer;
			this.mute = mute;
		}

		private void OnSampleBuffer(float[] data)
		{
			AndroidJNI.AttachCurrentThread();
			recorder.CommitSamples(data, clock.timestamp);
			if (mute)
			{
				Array.Clear(data, 0, data.Length);
			}
		}
	}
	[Doc("CameraInput")]
	public sealed class CameraInput : IDisposable
	{
		private sealed class CameraInputAttachment : MonoBehaviour
		{
		}

		[Doc("CameraInputFrameSkip", "CameraInputFrameSkipDiscussion")]
		public int frameSkip;

		private readonly IMediaRecorder recorder;

		private readonly IClock clock;

		private readonly Camera[] cameras;

		private readonly CameraInputAttachment attachment;

		private readonly RenderTexture frameBuffer;

		private readonly Texture2D readbackBuffer;

		private byte[] pixelBuffer;

		private int frameCount;

		[Doc("CameraInputCtor")]
		public CameraInput(IMediaRecorder recorder, IClock clock, params Camera[] cameras)
		{
			Array.Sort(cameras, (Camera a, Camera b) => (int)(10f * (a.depth - b.depth)));
			this.recorder = recorder;
			this.clock = clock;
			this.cameras = cameras;
			attachment = cameras[0].gameObject.AddComponent<CameraInputAttachment>();
			frameBuffer = RenderTexture.GetTemporary(new RenderTextureDescriptor(recorder.frameSize.width, recorder.frameSize.height, RenderTextureFormat.ARGB32, 24)
			{
				sRGB = true
			});
			readbackBuffer = (SystemInfo.supportsAsyncGPUReadback ? null : new Texture2D(frameBuffer.width, frameBuffer.height, TextureFormat.RGBA32, mipChain: false, linear: false));
			pixelBuffer = new byte[frameBuffer.width * frameBuffer.height * 4];
			attachment.StartCoroutine(OnFrame());
		}

		[Doc("AudioInputDispose")]
		public void Dispose()
		{
			UnityEngine.Object.Destroy(attachment);
			RenderTexture.ReleaseTemporary(frameBuffer);
			UnityEngine.Object.Destroy(readbackBuffer);
			pixelBuffer = null;
		}

		private IEnumerator OnFrame()
		{
			WaitForEndOfFrame endOfFrame = new WaitForEndOfFrame();
			while (true)
			{
				yield return endOfFrame;
				if (frameCount++ % (frameSkip + 1) != 0)
				{
					continue;
				}
				for (int i = 0; i < cameras.Length; i++)
				{
					RenderTexture targetTexture = cameras[i].targetTexture;
					cameras[i].targetTexture = frameBuffer;
					cameras[i].Render();
					cameras[i].targetTexture = targetTexture;
				}
				long timestamp = clock.timestamp;
				if (SystemInfo.supportsAsyncGPUReadback)
				{
					AsyncGPUReadback.Request(frameBuffer, 0, delegate(AsyncGPUReadbackRequest request)
					{
						if (pixelBuffer != null)
						{
							request.GetData<byte>().CopyTo(pixelBuffer);
							recorder.CommitFrame(pixelBuffer, timestamp);
						}
					});
				}
				else
				{
					RenderTexture active = RenderTexture.active;
					RenderTexture.active = frameBuffer;
					readbackBuffer.ReadPixels(new Rect(0f, 0f, frameBuffer.width, frameBuffer.height), 0, 0, recalculateMipMaps: false);
					readbackBuffer.GetRawTextureData<byte>().CopyTo(pixelBuffer);
					recorder.CommitFrame(pixelBuffer, timestamp);
					RenderTexture.active = active;
				}
			}
		}
	}
	[Doc("WebCamTextureInput")]
	public class WebCamTextureInput : IDisposable
	{
		private sealed class WebCamTextureInputAttachment : MonoBehaviour
		{
		}

		private readonly IMediaRecorder recorder;

		private readonly IClock clock;

		private readonly WebCamTexture webCamTexture;

		private readonly Color32[] pixelBuffer;

		private readonly WebCamTextureInputAttachment attachment;

		[Doc("WebCamTextureInputCtor")]
		public WebCamTextureInput(IMediaRecorder recorder, IClock clock, WebCamTexture webCamTexture)
		{
			this.recorder = recorder;
			this.clock = clock;
			this.webCamTexture = webCamTexture;
			pixelBuffer = webCamTexture.GetPixels32();
			attachment = new GameObject("WebCamTextureInputAttachment").AddComponent<WebCamTextureInputAttachment>();
			attachment.StartCoroutine(OnFrame());
		}

		[Doc("AudioInputDispose")]
		public void Dispose()
		{
			UnityEngine.Object.Destroy(attachment.gameObject);
		}

		private IEnumerator OnFrame()
		{
			WaitForEndOfFrame endOfFrame = new WaitForEndOfFrame();
			while (true)
			{
				yield return endOfFrame;
				if (webCamTexture.didUpdateThisFrame)
				{
					webCamTexture.GetPixels32(pixelBuffer);
					recorder.CommitFrame(pixelBuffer, clock.timestamp);
				}
			}
		}
	}
}
namespace NatSuite.Recorders.Clocks
{
	[Doc("FixedIntervalClock")]
	public sealed class FixedIntervalClock : IClock
	{
		private readonly bool autoTick;

		private int ticks;

		[Doc("FixedIntervalClockInterval")]
		public double interval { get; set; }

		[Doc("Timestamp")]
		public long timestamp
		{
			[MethodImpl(MethodImplOptions.Synchronized)]
			get
			{
				return (long)((double)(autoTick ? ticks++ : ticks) * interval * 1000000000.0);
			}
		}

		[Doc("FixedIntervalClockCtorFramerate")]
		public FixedIntervalClock(int framerate, bool autoTick = true)
			: this(1.0 / (double)framerate, autoTick)
		{
		}

		[Doc("FixedIntervalClockCtorInterval")]
		public FixedIntervalClock(double interval, bool autoTick = true)
		{
			this.interval = interval;
			ticks = 0;
			this.autoTick = autoTick;
		}

		[MethodImpl(MethodImplOptions.Synchronized)]
		[Doc("FixedIntervalClockTick")]
		public void Tick()
		{
			ticks++;
		}
	}
	public interface IClock
	{
		long timestamp { get; }
	}
	[Doc("RealtimeClock")]
	public sealed class RealtimeClock : IClock
	{
		private readonly Stopwatch stopwatch;

		[Doc("Timestamp")]
		public long timestamp
		{
			[MethodImpl(MethodImplOptions.Synchronized)]
			get
			{
				long result = stopwatch.Elapsed.Ticks * 100;
				if (!stopwatch.IsRunning)
				{
					stopwatch.Start();
				}
				return result;
			}
		}

		[Doc("RealtimeClockPaused")]
		public bool paused
		{
			[MethodImpl(MethodImplOptions.Synchronized)]
			get
			{
				return !stopwatch.IsRunning;
			}
			[MethodImpl(MethodImplOptions.Synchronized)]
			set
			{
				(value ? new Action(stopwatch.Stop) : new Action(stopwatch.Start))();
			}
		}

		public RealtimeClock()
		{
			stopwatch = new Stopwatch();
		}
	}
}
namespace NatSuite.Examples
{
	public class Giffy : MonoBehaviour
	{
		[Header("GIF Settings")]
		public int imageWidth = 640;

		public int imageHeight = 480;

		public float frameDuration = 0.1f;

		private GIFRecorder recorder;

		private CameraInput cameraInput;

		public void StartRecording()
		{
			recorder = new GIFRecorder(imageWidth, imageHeight, frameDuration);
			cameraInput = new CameraInput(recorder, new RealtimeClock(), Camera.main);
			cameraInput.frameSkip = 4;
		}

		public async void StopRecording()
		{
			cameraInput.Dispose();
			string text = await recorder.FinishWriting();
			UnityEngine.Debug.Log("Saved animated GIF image to: " + text);
			Application.OpenURL(((Application.platform == RuntimePlatform.IPhonePlayer) ? "file://" : "") + text);
		}
	}
	public class ReplayCam : MonoBehaviour
	{
		[Header("Recording")]
		public int videoWidth = 1280;

		public int videoHeight = 720;

		public bool recordMicrophone;

		private IMediaRecorder recorder;

		private CameraInput cameraInput;

		private AudioInput audioInput;

		private AudioSource microphoneSource;

		public AudioListener audioListener;

		public Camera cam;

		public static string videoPath = "";

		private IEnumerator Start()
		{
			microphoneSource = base.gameObject.AddComponent<AudioSource>();
			AudioSource audioSource = microphoneSource;
			AudioSource audioSource2 = microphoneSource;
			bool mute = true;
			audioSource2.loop = true;
			audioSource.mute = mute;
			AudioSource audioSource3 = microphoneSource;
			AudioSource audioSource4 = microphoneSource;
			mute = false;
			audioSource4.bypassListenerEffects = false;
			audioSource3.bypassEffects = mute;
			if (recordMicrophone && Microphone.devices.Length != 0)
			{
				microphoneSource.clip = Microphone.Start(null, loop: true, 10, AudioSettings.outputSampleRate);
			}
			yield return new WaitUntil(() => Microphone.GetPosition(null) > 0);
			microphoneSource.Play();
		}

		private void OnDestroy()
		{
			if (recordMicrophone)
			{
				microphoneSource.Stop();
				Microphone.End(null);
			}
		}

		public async void StartRecording()
		{
			int num = 30;
			int outputSampleRate = AudioSettings.outputSampleRate;
			int speakerMode = (int)AudioSettings.speakerMode;
			RealtimeClock clock = new RealtimeClock();
			recorder = new MP4Recorder(videoWidth, videoHeight, num, outputSampleRate, speakerMode);
			cameraInput = new CameraInput(recorder, clock, cam);
			audioInput = (recordMicrophone ? new AudioInput(recorder, clock, microphoneSource, mute: true) : null);
			microphoneSource.mute = audioInput == null;
		}

		public async void StopRecording()
		{
			microphoneSource.mute = true;
			audioInput?.Dispose();
			cameraInput.Dispose();
			await recorder.FinishWriting();
			UnityEngine.Debug.Log("Saved recording to: " + videoPath);
			_ = Application.platform;
			_ = 8;
		}
	}
	public class WebCam : MonoBehaviour
	{
		public RawImage rawImage;

		public AspectRatioFitter aspectFitter;

		private WebCamTexture webCamTexture;

		private MP4Recorder recorder;

		private WebCamTextureInput webCamTextureInput;

		private IEnumerator Start()
		{
			yield return Application.RequestUserAuthorization(UserAuthorization.WebCam);
			if (Application.HasUserAuthorization(UserAuthorization.WebCam))
			{
				webCamTexture = new WebCamTexture(1280, 720, 30);
				webCamTexture.Play();
				yield return new WaitUntil(() => webCamTexture.width != 16 && webCamTexture.height != 16);
				rawImage.texture = webCamTexture;
				aspectFitter.aspectRatio = (float)webCamTexture.width / (float)webCamTexture.height;
			}
		}

		public void StartRecording()
		{
			RealtimeClock clock = new RealtimeClock();
			recorder = new MP4Recorder(webCamTexture.width, webCamTexture.height, 30f);
			webCamTextureInput = new WebCamTextureInput(recorder, clock, webCamTexture);
		}

		public async void StopRecording()
		{
			webCamTextureInput.Dispose();
			UnityEngine.Debug.Log("Saved recording to: " + await recorder.FinishWriting());
			_ = Application.platform;
			_ = 8;
		}
	}
}
namespace NatSuite.Examples.Components
{
	[RequireComponent(typeof(RawImage), typeof(AspectRatioFitter))]
	public class CameraPreview : MonoBehaviour
	{
		private RawImage rawImage;

		private AspectRatioFitter aspectFitter;

		public WebCamTexture cameraTexture { get; private set; }

		private IEnumerator Start()
		{
			rawImage = GetComponent<RawImage>();
			aspectFitter = GetComponent<AspectRatioFitter>();
			if (Application.platform == RuntimePlatform.Android)
			{
				if (!Permission.HasUserAuthorizedPermission("android.permission.CAMERA"))
				{
					Permission.RequestUserPermission("android.permission.CAMERA");
					yield return new WaitUntil(() => Permission.HasUserAuthorizedPermission("android.permission.CAMERA"));
				}
			}
			else
			{
				yield return Application.RequestUserAuthorization(UserAuthorization.WebCam);
				if (!Application.HasUserAuthorization(UserAuthorization.WebCam))
				{
					yield break;
				}
			}
			cameraTexture = new WebCamTexture(null, 1280, 720, 30);
			cameraTexture.Play();
			yield return new WaitUntil(() => cameraTexture.width != 16 && cameraTexture.height != 16);
			rawImage.texture = cameraTexture;
			rawImage.material = new Material(Shader.Find("Hidden/NatCorder/CameraPreview"));
			rawImage.material.SetFloat("_Rotation", (float)cameraTexture.videoRotationAngle * (float)Math.PI / 180f);
			rawImage.material.SetFloat("_Scale", (!cameraTexture.videoVerticallyMirrored) ? 1 : (-1));
			aspectFitter.aspectMode = AspectRatioFitter.AspectMode.HeightControlsWidth;
			if (cameraTexture.videoRotationAngle == 90 || cameraTexture.videoRotationAngle == 270)
			{
				aspectFitter.aspectRatio = (float)cameraTexture.height / (float)cameraTexture.width;
			}
			else
			{
				aspectFitter.aspectRatio = (float)cameraTexture.width / (float)cameraTexture.height;
			}
		}
	}
	[RequireComponent(typeof(EventTrigger))]
	public class RecordButton : MonoBehaviour, IPointerDownHandler, IEventSystemHandler, IPointerUpHandler
	{
		public Image button;

		public Image countdown;

		public UnityEvent onTouchDown;

		public UnityEvent onTouchUp;

		private bool pressed;

		private const float MaxRecordingTime = 10f;

		private void Start()
		{
			Reset();
		}

		private void Reset()
		{
			if ((bool)button)
			{
				button.fillAmount = 1f;
			}
			if ((bool)countdown)
			{
				countdown.fillAmount = 0f;
			}
		}

		void IPointerDownHandler.OnPointerDown(PointerEventData eventData)
		{
			StartCoroutine(Countdown());
		}

		void IPointerUpHandler.OnPointerUp(PointerEventData eventData)
		{
			pressed = false;
		}

		private IEnumerator Countdown()
		{
			pressed = true;
			yield return new WaitForSeconds(0.2f);
			if (pressed)
			{
				onTouchDown?.Invoke();
				float startTime = Time.time;
				float num;
				while (pressed && (num = (Time.time - startTime) / 10f) < 1f)
				{
					countdown.fillAmount = num;
					button.fillAmount = 1f - num;
					yield return null;
				}
				Reset();
				onTouchUp?.Invoke();
			}
		}
	}
}
namespace Mirror
{
	[StructLayout(LayoutKind.Auto, CharSet = CharSet.Auto)]
	public static class GeneratedNetworkCode
	{
		public static ErrorMessage _Read_Mirror.ErrorMessage(NetworkReader reader)
		{
			ErrorMessage result = default(ErrorMessage);
			result.value = NetworkReaderExtensions.ReadByte(reader);
			return result;
		}

		public static void _Write_Mirror.ErrorMessage(NetworkWriter writer, ErrorMessage value)
		{
			NetworkWriterExtensions.WriteByte(writer, value.value);
		}

		public static ReadyMessage _Read_Mirror.ReadyMessage(NetworkReader reader)
		{
			return default(ReadyMessage);
		}

		public static void _Write_Mirror.ReadyMessage(NetworkWriter writer, ReadyMessage value)
		{
		}

		public static NotReadyMessage _Read_Mirror.NotReadyMessage(NetworkReader reader)
		{
			return default(NotReadyMessage);
		}

		public static void _Write_Mirror.NotReadyMessage(NetworkWriter writer, NotReadyMessage value)
		{
		}

		public static AddPlayerMessage _Read_Mirror.AddPlayerMessage(NetworkReader reader)
		{
			return default(AddPlayerMessage);
		}

		public static void _Write_Mirror.AddPlayerMessage(NetworkWriter writer, AddPlayerMessage value)
		{
		}

		public static DisconnectMessage _Read_Mirror.DisconnectMessage(NetworkReader reader)
		{
			return default(DisconnectMessage);
		}

		public static void _Write_Mirror.DisconnectMessage(NetworkWriter writer, DisconnectMessage value)
		{
		}

		public static ConnectMessage _Read_Mirror.ConnectMessage(NetworkReader reader)
		{
			return default(ConnectMessage);
		}

		public static void _Write_Mirror.ConnectMessage(NetworkWriter writer, ConnectMessage value)
		{
		}

		public static SceneMessage _Read_Mirror.SceneMessage(NetworkReader reader)
		{
			SceneMessage result = default(SceneMessage);
			result.sceneName = reader.ReadString();
			result.sceneOperation = _Read_Mirror.SceneOperation(reader);
			result.customHandling = reader.ReadBoolean();
			return result;
		}

		public static SceneOperation _Read_Mirror.SceneOperation(NetworkReader reader)
		{
			return (SceneOperation)NetworkReaderExtensions.ReadByte(reader);
		}

		public static void _Write_Mirror.SceneMessage(NetworkWriter writer, SceneMessage value)
		{
			writer.WriteString(value.sceneName);
			_Write_Mirror.SceneOperation(writer, value.sceneOperation);
			writer.WriteBoolean(value.customHandling);
		}

		public static void _Write_Mirror.SceneOperation(NetworkWriter writer, SceneOperation value)
		{
			NetworkWriterExtensions.WriteByte(writer, (byte)value);
		}

		public static CommandMessage _Read_Mirror.CommandMessage(NetworkReader reader)
		{
			CommandMessage result = default(CommandMessage);
			result.netId = reader.ReadPackedUInt32();
			result.componentIndex = reader.ReadPackedInt32();
			result.functionHash = reader.ReadPackedInt32();
			result.payload = reader.ReadBytesAndSizeSegment();
			return result;
		}

		public static void _Write_Mirror.CommandMessage(NetworkWriter writer, CommandMessage value)
		{
			writer.WritePackedUInt32(value.netId);
			writer.WritePackedInt32(value.componentIndex);
			writer.WritePackedInt32(value.functionHash);
			writer.WriteBytesAndSizeSegment(value.payload);
		}

		public static RpcMessage _Read_Mirror.RpcMessage(NetworkReader reader)
		{
			RpcMessage result = default(RpcMessage);
			result.netId = reader.ReadPackedUInt32();
			result.componentIndex = reader.ReadPackedInt32();
			result.functionHash = reader.ReadPackedInt32();
			result.payload = reader.ReadBytesAndSizeSegment();
			return result;
		}

		public static void _Write_Mirror.RpcMessage(NetworkWriter writer, RpcMessage value)
		{
			writer.WritePackedUInt32(value.netId);
			writer.WritePackedInt32(value.componentIndex);
			writer.WritePackedInt32(value.functionHash);
			writer.WriteBytesAndSizeSegment(value.payload);
		}

		public static SpawnMessage _Read_Mirror.SpawnMessage(NetworkReader reader)
		{
			SpawnMessage result = default(SpawnMessage);
			result.netId = reader.ReadPackedUInt32();
			result.isLocalPlayer = reader.ReadBoolean();
			result.isOwner = reader.ReadBoolean();
			result.sceneId = reader.ReadPackedUInt64();
			result.assetId = reader.ReadGuid();
			result.position = reader.ReadVector3();
			result.rotation = reader.ReadQuaternion();
			result.scale = reader.ReadVector3();
			result.payload = reader.ReadBytesAndSizeSegment();
			return result;
		}

		public static void _Write_Mirror.SpawnMessage(NetworkWriter writer, SpawnMessage value)
		{
			writer.WritePackedUInt32(value.netId);
			writer.WriteBoolean(value.isLocalPlayer);
			writer.WriteBoolean(value.isOwner);
			writer.WritePackedUInt64(value.sceneId);
			writer.WriteGuid(value.assetId);
			writer.WriteVector3(value.position);
			writer.WriteQuaternion(value.rotation);
			writer.WriteVector3(value.scale);
			writer.WriteBytesAndSizeSegment(value.payload);
		}

		public static ObjectSpawnStartedMessage _Read_Mirror.ObjectSpawnStartedMessage(NetworkReader reader)
		{
			return default(ObjectSpawnStartedMessage);
		}

		public static void _Write_Mirror.ObjectSpawnStartedMessage(NetworkWriter writer, ObjectSpawnStartedMessage value)
		{
		}

		public static ObjectSpawnFinishedMessage _Read_Mirror.ObjectSpawnFinishedMessage(NetworkReader reader)
		{
			return default(ObjectSpawnFinishedMessage);
		}

		public static void _Write_Mirror.ObjectSpawnFinishedMessage(NetworkWriter writer, ObjectSpawnFinishedMessage value)
		{
		}

		public static ObjectDestroyMessage _Read_Mirror.ObjectDestroyMessage(NetworkReader reader)
		{
			ObjectDestroyMessage result = default(ObjectDestroyMessage);
			result.netId = reader.ReadPackedUInt32();
			return result;
		}

		public static void _Write_Mirror.ObjectDestroyMessage(NetworkWriter writer, ObjectDestroyMessage value)
		{
			writer.WritePackedUInt32(value.netId);
		}

		public static ObjectHideMessage _Read_Mirror.ObjectHideMessage(NetworkReader reader)
		{
			ObjectHideMessage result = default(ObjectHideMessage);
			result.netId = reader.ReadPackedUInt32();
			return result;
		}

		public static void _Write_Mirror.ObjectHideMessage(NetworkWriter writer, ObjectHideMessage value)
		{
			writer.WritePackedUInt32(value.netId);
		}

		public static UpdateVarsMessage _Read_Mirror.UpdateVarsMessage(NetworkReader reader)
		{
			UpdateVarsMessage result = default(UpdateVarsMessage);
			result.netId = reader.ReadPackedUInt32();
			result.payload = reader.ReadBytesAndSizeSegment();
			return result;
		}

		public static void _Write_Mirror.UpdateVarsMessage(NetworkWriter writer, UpdateVarsMessage value)
		{
			writer.WritePackedUInt32(value.netId);
			writer.WriteBytesAndSizeSegment(value.payload);
		}

		public static NetworkPingMessage _Read_Mirror.NetworkPingMessage(NetworkReader reader)
		{
			NetworkPingMessage result = default(NetworkPingMessage);
			result.clientTime = reader.ReadDouble();
			return result;
		}

		public static void _Write_Mirror.NetworkPingMessage(NetworkWriter writer, NetworkPingMessage value)
		{
			writer.WriteDouble(value.clientTime);
		}

		public static NetworkPongMessage _Read_Mirror.NetworkPongMessage(NetworkReader reader)
		{
			NetworkPongMessage result = default(NetworkPongMessage);
			result.clientTime = reader.ReadDouble();
			result.serverTime = reader.ReadDouble();
			return result;
		}

		public static void _Write_Mirror.NetworkPongMessage(NetworkWriter writer, NetworkPongMessage value)
		{
			writer.WriteDouble(value.clientTime);
			writer.WriteDouble(value.serverTime);
		}

		[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
		public static void InitReadWriters()
		{
			Writer<byte>.write = NetworkWriterExtensions.WriteByte;
			Writer<sbyte>.write = NetworkWriterExtensions.WriteSByte;
			Writer<char>.write = NetworkWriterExtensions.WriteChar;
			Writer<bool>.write = NetworkWriterExtensions.WriteBoolean;
			Writer<ushort>.write = NetworkWriterExtensions.WriteUInt16;
			Writer<short>.write = NetworkWriterExtensions.WriteInt16;
			Writer<float>.write = NetworkWriterExtensions.WriteSingle;
			Writer<double>.write = NetworkWriterExtensions.WriteDouble;
			Writer<decimal>.write = NetworkWriterExtensions.WriteDecimal;
			Writer<string>.write = NetworkWriterExtensions.WriteString;
			Writer<byte[]>.write = NetworkWriterExtensions.WriteBytesAndSize;
			Writer<ArraySegment<byte>>.write = NetworkWriterExtensions.WriteBytesAndSizeSegment;
			Writer<int>.write = NetworkWriterExtensions.WritePackedInt32;
			Writer<uint>.write = NetworkWriterExtensions.WritePackedUInt32;
			Writer<long>.write = NetworkWriterExtensions.WritePackedInt64;
			Writer<ulong>.write = NetworkWriterExtensions.WritePackedUInt64;
			Writer<Vector2>.write = NetworkWriterExtensions.WriteVector2;
			Writer<Vector3>.write = NetworkWriterExtensions.WriteVector3;
			Writer<Vector4>.write = NetworkWriterExtensions.WriteVector4;
			Writer<Vector2Int>.write = NetworkWriterExtensions.WriteVector2Int;
			Writer<Vector3Int>.write = NetworkWriterExtensions.WriteVector3Int;
			Writer<Color>.write = NetworkWriterExtensions.WriteColor;
			Writer<Color32>.write = NetworkWriterExtensions.WriteColor32;
			Writer<Quaternion>.write = NetworkWriterExtensions.WriteQuaternion;
			Writer<Rect>.write = NetworkWriterExtensions.WriteRect;
			Writer<Plane>.write = NetworkWriterExtensions.WritePlane;
			Writer<Ray>.write = NetworkWriterExtensions.WriteRay;
			Writer<Matrix4x4>.write = NetworkWriterExtensions.WriteMatrix4x4;
			Writer<Guid>.write = NetworkWriterExtensions.WriteGuid;
			Writer<NetworkIdentity>.write = NetworkWriterExtensions.WriteNetworkIdentity;
			Writer<Transform>.write = NetworkWriterExtensions.WriteTransform;
			Writer<GameObject>.write = NetworkWriterExtensions.WriteGameObject;
			Writer<Uri>.write = NetworkWriterExtensions.WriteUri;
			Writer<ErrorMessage>.write = _Write_Mirror.ErrorMessage;
			Writer<ReadyMessage>.write = _Write_Mirror.ReadyMessage;
			Writer<NotReadyMessage>.write = _Write_Mirror.NotReadyMessage;
			Writer<AddPlayerMessage>.write = _Write_Mirror.AddPlayerMessage;
			Writer<DisconnectMessage>.write = _Write_Mirror.DisconnectMessage;
			Writer<ConnectMessage>.write = _Write_Mirror.ConnectMessage;
			Writer<SceneMessage>.write = _Write_Mirror.SceneMessage;
			Writer<SceneOperation>.write = _Write_Mirror.SceneOperation;
			Writer<CommandMessage>.write = _Write_Mirror.CommandMessage;
			Writer<RpcMessage>.write = _Write_Mirror.RpcMessage;
			Writer<SpawnMessage>.write = _Write_Mirror.SpawnMessage;
			Writer<ObjectSpawnStartedMessage>.write = _Write_Mirror.ObjectSpawnStartedMessage;
			Writer<ObjectSpawnFinishedMessage>.write = _Write_Mirror.ObjectSpawnFinishedMessage;
			Writer<ObjectDestroyMessage>.write = _Write_Mirror.ObjectDestroyMessage;
			Writer<ObjectHideMessage>.write = _Write_Mirror.ObjectHideMessage;
			Writer<UpdateVarsMessage>.write = _Write_Mirror.UpdateVarsMessage;
			Writer<NetworkPingMessage>.write = _Write_Mirror.NetworkPingMessage;
			Writer<NetworkPongMessage>.write = _Write_Mirror.NetworkPongMessage;
			Reader<byte>.read = NetworkReaderExtensions.ReadByte;
			Reader<sbyte>.read = NetworkReaderExtensions.ReadSByte;
			Reader<char>.read = NetworkReaderExtensions.ReadChar;
			Reader<bool>.read = NetworkReaderExtensions.ReadBoolean;
			Reader<short>.read = NetworkReaderExtensions.ReadInt16;
			Reader<ushort>.read = NetworkReaderExtensions.ReadUInt16;
			Reader<int>.read = NetworkReaderExtensions.ReadPackedInt32;
			Reader<uint>.read = NetworkReaderExtensions.ReadPackedUInt32;
			Reader<long>.read = NetworkReaderExtensions.ReadPackedInt64;
			Reader<ulong>.read = NetworkReaderExtensions.ReadPackedUInt64;
			Reader<float>.read = NetworkReaderExtensions.ReadSingle;
			Reader<double>.read = NetworkReaderExtensions.ReadDouble;
			Reader<decimal>.read = NetworkReaderExtensions.ReadDecimal;
			Reader<string>.read = NetworkReaderExtensions.ReadString;
			Reader<byte[]>.read = NetworkReaderExtensions.ReadBytesAndSize;
			Reader<ArraySegment<byte>>.read = NetworkReaderExtensions.ReadBytesAndSizeSegment;
			Reader<Vector2>.read = NetworkReaderExtensions.ReadVector2;
			Reader<Vector3>.read = NetworkReaderExtensions.ReadVector3;
			Reader<Vector4>.read = NetworkReaderExtensions.ReadVector4;
			Reader<Vector2Int>.read = NetworkReaderExtensions.ReadVector2Int;
			Reader<Vector3Int>.read = NetworkReaderExtensions.ReadVector3Int;
			Reader<Color>.read = NetworkReaderExtensions.ReadColor;
			Reader<Color32>.read = NetworkReaderExtensions.ReadColor32;
			Reader<Quaternion>.read = NetworkReaderExtensions.ReadQuaternion;
			Reader<Rect>.read = NetworkReaderExtensions.ReadRect;
			Reader<Plane>.read = NetworkReaderExtensions.ReadPlane;
			Reader<Ray>.read = NetworkReaderExtensions.ReadRay;
			Reader<Matrix4x4>.read = NetworkReaderExtensions.ReadMatrix4x4;
			Reader<Guid>.read = NetworkReaderExtensions.ReadGuid;
			Reader<Transform>.read = NetworkReaderExtensions.ReadTransform;
			Reader<GameObject>.read = NetworkReaderExtensions.ReadGameObject;
			Reader<NetworkIdentity>.read = NetworkReaderExtensions.ReadNetworkIdentity;
			Reader<Uri>.read = NetworkReaderExtensions.ReadUri;
			Reader<ErrorMessage>.read = _Read_Mirror.ErrorMessage;
			Reader<ReadyMessage>.read = _Read_Mirror.ReadyMessage;
			Reader<NotReadyMessage>.read = _Read_Mirror.NotReadyMessage;
			Reader<AddPlayerMessage>.read = _Read_Mirror.AddPlayerMessage;
			Reader<DisconnectMessage>.read = _Read_Mirror.DisconnectMessage;
			Reader<ConnectMessage>.read = _Read_Mirror.ConnectMessage;
			Reader<SceneMessage>.read = _Read_Mirror.SceneMessage;
			Reader<SceneOperation>.read = _Read_Mirror.SceneOperation;
			Reader<CommandMessage>.read = _Read_Mirror.CommandMessage;
			Reader<RpcMessage>.read = _Read_Mirror.RpcMessage;
			Reader<SpawnMessage>.read = _Read_Mirror.SpawnMessage;
			Reader<ObjectSpawnStartedMessage>.read = _Read_Mirror.ObjectSpawnStartedMessage;
			Reader<ObjectSpawnFinishedMessage>.read = _Read_Mirror.ObjectSpawnFinishedMessage;
			Reader<ObjectDestroyMessage>.read = _Read_Mirror.ObjectDestroyMessage;
			Reader<ObjectHideMessage>.read = _Read_Mirror.ObjectHideMessage;
			Reader<UpdateVarsMessage>.read = _Read_Mirror.UpdateVarsMessage;
			Reader<NetworkPingMessage>.read = _Read_Mirror.NetworkPingMessage;
			Reader<NetworkPongMessage>.read = _Read_Mirror.NetworkPongMessage;
		}
	}
}
